/* eslint-disable */
/* tslint:disable */
/*
 * ---------------------------------------------------------------
 * ## THIS FILE WAS GENERATED VIA SWAGGER-TYPESCRIPT-API        ##
 * ##                                                           ##
 * ## AUTHOR: acacode                                           ##
 * ## SOURCE: https://github.com/acacode/swagger-typescript-api ##
 * ---------------------------------------------------------------
 */

/** Actor */
export interface Actor {
  type: "actors";
  id: string;
  attributes?: {
    actorType?: "USER" | "API_KEY" | "XCODE_CLOUD" | "APPLE";
    userFirstName?: string;
    userLastName?: string;
    userEmail?: string;
    apiKeyId?: string;
  };
  links?: ResourceLinks;
}

/** ActorsResponse */
export interface ActorsResponse {
  data: Actor[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** ActorResponse */
export interface ActorResponse {
  data: Actor;
  links: DocumentLinks;
}

/** AgeRatingDeclaration */
export interface AgeRatingDeclaration {
  type: "ageRatingDeclarations";
  id: string;
  attributes?: {
    alcoholTobaccoOrDrugUseOrReferences?: "NONE" | "INFREQUENT_OR_MILD" | "FREQUENT_OR_INTENSE";
    contests?: "NONE" | "INFREQUENT_OR_MILD" | "FREQUENT_OR_INTENSE";
    /** @deprecated */
    gamblingAndContests?: boolean;
    gambling?: boolean;
    gamblingSimulated?: "NONE" | "INFREQUENT_OR_MILD" | "FREQUENT_OR_INTENSE";
    kidsAgeBand?: KidsAgeBand;
    medicalOrTreatmentInformation?: "NONE" | "INFREQUENT_OR_MILD" | "FREQUENT_OR_INTENSE";
    profanityOrCrudeHumor?: "NONE" | "INFREQUENT_OR_MILD" | "FREQUENT_OR_INTENSE";
    sexualContentGraphicAndNudity?: "NONE" | "INFREQUENT_OR_MILD" | "FREQUENT_OR_INTENSE";
    sexualContentOrNudity?: "NONE" | "INFREQUENT_OR_MILD" | "FREQUENT_OR_INTENSE";
    /** @deprecated */
    seventeenPlus?: boolean;
    ageRatingOverride?: "NONE" | "SEVENTEEN_PLUS" | "UNRATED";
    horrorOrFearThemes?: "NONE" | "INFREQUENT_OR_MILD" | "FREQUENT_OR_INTENSE";
    matureOrSuggestiveThemes?: "NONE" | "INFREQUENT_OR_MILD" | "FREQUENT_OR_INTENSE";
    unrestrictedWebAccess?: boolean;
    violenceCartoonOrFantasy?: "NONE" | "INFREQUENT_OR_MILD" | "FREQUENT_OR_INTENSE";
    violenceRealisticProlongedGraphicOrSadistic?: "NONE" | "INFREQUENT_OR_MILD" | "FREQUENT_OR_INTENSE";
    violenceRealistic?: "NONE" | "INFREQUENT_OR_MILD" | "FREQUENT_OR_INTENSE";
  };
  links?: ResourceLinks;
}

/** AgeRatingDeclarationResponse */
export interface AgeRatingDeclarationResponse {
  data: AgeRatingDeclaration;
  links: DocumentLinks;
}

/** AgeRatingDeclarationUpdateRequest */
export interface AgeRatingDeclarationUpdateRequest {
  data: {
    type: "ageRatingDeclarations";
    id: string;
    attributes?: {
      alcoholTobaccoOrDrugUseOrReferences?: "NONE" | "INFREQUENT_OR_MILD" | "FREQUENT_OR_INTENSE";
      contests?: "NONE" | "INFREQUENT_OR_MILD" | "FREQUENT_OR_INTENSE";
      /** @deprecated */
      gamblingAndContests?: boolean;
      gambling?: boolean;
      gamblingSimulated?: "NONE" | "INFREQUENT_OR_MILD" | "FREQUENT_OR_INTENSE";
      kidsAgeBand?: KidsAgeBand;
      medicalOrTreatmentInformation?: "NONE" | "INFREQUENT_OR_MILD" | "FREQUENT_OR_INTENSE";
      profanityOrCrudeHumor?: "NONE" | "INFREQUENT_OR_MILD" | "FREQUENT_OR_INTENSE";
      sexualContentGraphicAndNudity?: "NONE" | "INFREQUENT_OR_MILD" | "FREQUENT_OR_INTENSE";
      sexualContentOrNudity?: "NONE" | "INFREQUENT_OR_MILD" | "FREQUENT_OR_INTENSE";
      /** @deprecated */
      seventeenPlus?: boolean;
      ageRatingOverride?: "NONE" | "SEVENTEEN_PLUS" | "UNRATED";
      horrorOrFearThemes?: "NONE" | "INFREQUENT_OR_MILD" | "FREQUENT_OR_INTENSE";
      matureOrSuggestiveThemes?: "NONE" | "INFREQUENT_OR_MILD" | "FREQUENT_OR_INTENSE";
      unrestrictedWebAccess?: boolean;
      violenceCartoonOrFantasy?: "NONE" | "INFREQUENT_OR_MILD" | "FREQUENT_OR_INTENSE";
      violenceRealisticProlongedGraphicOrSadistic?: "NONE" | "INFREQUENT_OR_MILD" | "FREQUENT_OR_INTENSE";
      violenceRealistic?: "NONE" | "INFREQUENT_OR_MILD" | "FREQUENT_OR_INTENSE";
    };
  };
}

/** AlternativeDistributionDomain */
export interface AlternativeDistributionDomain {
  type: "alternativeDistributionDomains";
  id: string;
  attributes?: {
    domain?: string;
    referenceName?: string;
    /** @format date-time */
    createdDate?: string;
  };
  links?: ResourceLinks;
}

/** AlternativeDistributionDomainsResponse */
export interface AlternativeDistributionDomainsResponse {
  data: AlternativeDistributionDomain[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** AlternativeDistributionDomainResponse */
export interface AlternativeDistributionDomainResponse {
  data: AlternativeDistributionDomain;
  links: DocumentLinks;
}

/** AlternativeDistributionDomainCreateRequest */
export interface AlternativeDistributionDomainCreateRequest {
  data: {
    type: "alternativeDistributionDomains";
    attributes: {
      domain: string;
      referenceName: string;
    };
  };
}

/** AlternativeDistributionKey */
export interface AlternativeDistributionKey {
  type: "alternativeDistributionKeys";
  id: string;
  attributes?: {
    publicKey?: string;
  };
  links?: ResourceLinks;
}

/** AlternativeDistributionKeyResponse */
export interface AlternativeDistributionKeyResponse {
  data: AlternativeDistributionKey;
  links: DocumentLinks;
}

/** AlternativeDistributionKeyCreateRequest */
export interface AlternativeDistributionKeyCreateRequest {
  data: {
    type: "alternativeDistributionKeys";
    attributes: {
      publicKey: string;
    };
    relationships: {
      app: {
        data: {
          type: "apps";
          id: string;
        };
      };
    };
  };
}

/** AlternativeDistributionPackageDelta */
export interface AlternativeDistributionPackageDelta {
  type: "alternativeDistributionPackageDeltas";
  id: string;
  attributes?: {
    /** @format uri */
    url?: string;
    /** @format date-time */
    urlExpirationDate?: string;
    alternativeDistributionKeyBlob?: string;
    fileChecksum?: string;
  };
  links?: ResourceLinks;
}

/** AlternativeDistributionPackageDeltasResponse */
export interface AlternativeDistributionPackageDeltasResponse {
  data: AlternativeDistributionPackageDelta[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** AlternativeDistributionPackageDeltaResponse */
export interface AlternativeDistributionPackageDeltaResponse {
  data: AlternativeDistributionPackageDelta;
  links: DocumentLinks;
}

/** AlternativeDistributionPackageVariant */
export interface AlternativeDistributionPackageVariant {
  type: "alternativeDistributionPackageVariants";
  id: string;
  attributes?: {
    /** @format uri */
    url?: string;
    /** @format date-time */
    urlExpirationDate?: string;
    alternativeDistributionKeyBlob?: string;
    fileChecksum?: string;
  };
  links?: ResourceLinks;
}

/** AlternativeDistributionPackageVariantsResponse */
export interface AlternativeDistributionPackageVariantsResponse {
  data: AlternativeDistributionPackageVariant[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** AlternativeDistributionPackageVariantResponse */
export interface AlternativeDistributionPackageVariantResponse {
  data: AlternativeDistributionPackageVariant;
  links: DocumentLinks;
}

/** AlternativeDistributionPackageVersion */
export interface AlternativeDistributionPackageVersion {
  type: "alternativeDistributionPackageVersions";
  id: string;
  attributes?: {
    /** @format uri */
    url?: string;
    /** @format date-time */
    urlExpirationDate?: string;
    version?: string;
    fileChecksum?: string;
    state?: "COMPLETED" | "REPLACED";
  };
  relationships?: {
    variants?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "alternativeDistributionPackageVariants";
        id: string;
      }[];
    };
    deltas?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "alternativeDistributionPackageDeltas";
        id: string;
      }[];
    };
    alternativeDistributionPackage?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "alternativeDistributionPackages";
        id: string;
      };
    };
  };
  links?: ResourceLinks;
}

/** AlternativeDistributionPackageVersionsResponse */
export interface AlternativeDistributionPackageVersionsResponse {
  data: AlternativeDistributionPackageVersion[];
  included?: (
    | AlternativeDistributionPackageVariant
    | AlternativeDistributionPackageDelta
    | AlternativeDistributionPackage
  )[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** AlternativeDistributionPackageVersionResponse */
export interface AlternativeDistributionPackageVersionResponse {
  data: AlternativeDistributionPackageVersion;
  included?: (
    | AlternativeDistributionPackageVariant
    | AlternativeDistributionPackageDelta
    | AlternativeDistributionPackage
  )[];
  links: DocumentLinks;
}

/** AlternativeDistributionPackage */
export interface AlternativeDistributionPackage {
  type: "alternativeDistributionPackages";
  id: string;
  relationships?: {
    versions?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "alternativeDistributionPackageVersions";
        id: string;
      }[];
    };
  };
  links?: ResourceLinks;
}

/** AlternativeDistributionPackageResponse */
export interface AlternativeDistributionPackageResponse {
  data: AlternativeDistributionPackage;
  included?: AlternativeDistributionPackageVersion[];
  links: DocumentLinks;
}

/** AlternativeDistributionPackageCreateRequest */
export interface AlternativeDistributionPackageCreateRequest {
  data: {
    type: "alternativeDistributionPackages";
    relationships: {
      appStoreVersion: {
        data: {
          type: "appStoreVersions";
          id: string;
        };
      };
    };
  };
}

/** AnalyticsReportInstance */
export interface AnalyticsReportInstance {
  type: "analyticsReportInstances";
  id: string;
  attributes?: {
    granularity?: "DAILY" | "WEEKLY" | "MONTHLY";
    /** @format date */
    processingDate?: string;
  };
  links?: ResourceLinks;
}

/** AnalyticsReportInstancesResponse */
export interface AnalyticsReportInstancesResponse {
  data: AnalyticsReportInstance[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** AnalyticsReportInstanceResponse */
export interface AnalyticsReportInstanceResponse {
  data: AnalyticsReportInstance;
  links: DocumentLinks;
}

/** AnalyticsReportRequest */
export interface AnalyticsReportRequest {
  type: "analyticsReportRequests";
  id: string;
  attributes?: {
    accessType?: "ONE_TIME_SNAPSHOT" | "ONGOING";
    stoppedDueToInactivity?: boolean;
  };
  relationships?: {
    reports?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "analyticsReports";
        id: string;
      }[];
    };
  };
  links?: ResourceLinks;
}

/** AnalyticsReportRequestsResponse */
export interface AnalyticsReportRequestsResponse {
  data: AnalyticsReportRequest[];
  included?: AnalyticsReport[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** AnalyticsReportRequestResponse */
export interface AnalyticsReportRequestResponse {
  data: AnalyticsReportRequest;
  included?: AnalyticsReport[];
  links: DocumentLinks;
}

/** AnalyticsReportRequestCreateRequest */
export interface AnalyticsReportRequestCreateRequest {
  data: {
    type: "analyticsReportRequests";
    attributes: {
      accessType: "ONE_TIME_SNAPSHOT" | "ONGOING";
    };
    relationships: {
      app: {
        data: {
          type: "apps";
          id: string;
        };
      };
    };
  };
}

/** AnalyticsReportSegment */
export interface AnalyticsReportSegment {
  type: "analyticsReportSegments";
  id: string;
  attributes?: {
    checksum?: string;
    sizeInBytes?: number;
    /** @format uri */
    url?: string;
  };
  links?: ResourceLinks;
}

/** AnalyticsReportSegmentsResponse */
export interface AnalyticsReportSegmentsResponse {
  data: AnalyticsReportSegment[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** AnalyticsReportSegmentResponse */
export interface AnalyticsReportSegmentResponse {
  data: AnalyticsReportSegment;
  links: DocumentLinks;
}

/** AnalyticsReport */
export interface AnalyticsReport {
  type: "analyticsReports";
  id: string;
  attributes?: {
    name?: string;
    category?: "APP_USAGE" | "APP_STORE_ENGAGEMENT" | "COMMERCE" | "FRAMEWORK_USAGE" | "PERFORMANCE";
  };
  links?: ResourceLinks;
}

/** AnalyticsReportsResponse */
export interface AnalyticsReportsResponse {
  data: AnalyticsReport[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** AnalyticsReportResponse */
export interface AnalyticsReportResponse {
  data: AnalyticsReport;
  links: DocumentLinks;
}

/** AppAvailabilityV2 */
export interface AppAvailabilityV2 {
  type: "appAvailabilities";
  id: string;
  attributes?: {
    availableInNewTerritories?: boolean;
  };
  relationships?: {
    territoryAvailabilities?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "territoryAvailabilities";
        id: string;
      }[];
    };
  };
  links?: ResourceLinks;
}

/** AppAvailabilityV2Response */
export interface AppAvailabilityV2Response {
  data: AppAvailabilityV2;
  included?: TerritoryAvailability[];
  links: DocumentLinks;
}

/** AppAvailabilityV2CreateRequest */
export interface AppAvailabilityV2CreateRequest {
  data: {
    type: "appAvailabilities";
    attributes: {
      availableInNewTerritories: boolean;
    };
    relationships: {
      app: {
        data: {
          type: "apps";
          id: string;
        };
      };
      territoryAvailabilities: {
        data: {
          type: "territoryAvailabilities";
          id: string;
        }[];
      };
    };
  };
  included?: TerritoryAvailabilityInlineCreate[];
}

/**
 * AppAvailability
 * @deprecated
 */
export interface AppAvailability {
  type: "appAvailabilities";
  id: string;
  attributes?: {
    availableInNewTerritories?: boolean;
  };
  relationships?: {
    app?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "apps";
        id: string;
      };
    };
    availableTerritories?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "territories";
        id: string;
      }[];
    };
  };
  links?: ResourceLinks;
}

/**
 * AppAvailabilityResponse
 * @deprecated
 */
export interface AppAvailabilityResponse {
  data: AppAvailability;
  included?: (App | Territory)[];
  links: DocumentLinks;
}

/**
 * AppAvailabilityCreateRequest
 * @deprecated
 */
export interface AppAvailabilityCreateRequest {
  data: {
    type: "appAvailabilities";
    attributes: {
      availableInNewTerritories: boolean;
    };
    relationships: {
      app: {
        data: {
          type: "apps";
          id: string;
        };
      };
      availableTerritories: {
        data: {
          type: "territories";
          id: string;
        }[];
      };
    };
  };
}

/** AppCategory */
export interface AppCategory {
  type: "appCategories";
  id: string;
  attributes?: {
    platforms?: Platform[];
  };
  relationships?: {
    subcategories?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "appCategories";
        id: string;
      }[];
    };
    parent?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "appCategories";
        id: string;
      };
    };
  };
  links?: ResourceLinks;
}

/** AppCategoriesResponse */
export interface AppCategoriesResponse {
  data: AppCategory[];
  included?: AppCategory[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** AppCategoryResponse */
export interface AppCategoryResponse {
  data: AppCategory;
  included?: AppCategory[];
  links: DocumentLinks;
}

/** AppClipAdvancedExperienceImage */
export interface AppClipAdvancedExperienceImage {
  type: "appClipAdvancedExperienceImages";
  id: string;
  attributes?: {
    fileSize?: number;
    fileName?: string;
    sourceFileChecksum?: string;
    imageAsset?: ImageAsset;
    uploadOperations?: UploadOperation[];
    assetDeliveryState?: AppMediaAssetState;
  };
  links?: ResourceLinks;
}

/** AppClipAdvancedExperienceImageResponse */
export interface AppClipAdvancedExperienceImageResponse {
  data: AppClipAdvancedExperienceImage;
  links: DocumentLinks;
}

/** AppClipAdvancedExperienceImageCreateRequest */
export interface AppClipAdvancedExperienceImageCreateRequest {
  data: {
    type: "appClipAdvancedExperienceImages";
    attributes: {
      fileSize: number;
      fileName: string;
    };
  };
}

/** AppClipAdvancedExperienceImageUpdateRequest */
export interface AppClipAdvancedExperienceImageUpdateRequest {
  data: {
    type: "appClipAdvancedExperienceImages";
    id: string;
    attributes?: {
      sourceFileChecksum?: string;
      uploaded?: boolean;
    };
  };
}

/** AppClipAdvancedExperienceLocalization */
export interface AppClipAdvancedExperienceLocalization {
  type: "appClipAdvancedExperienceLocalizations";
  id: string;
  attributes?: {
    language?: AppClipAdvancedExperienceLanguage;
    title?: string;
    subtitle?: string;
  };
  links?: ResourceLinks;
}

export interface AppClipAdvancedExperienceLocalizationInlineCreate {
  type: "appClipAdvancedExperienceLocalizations";
  id?: string;
  attributes?: {
    language?: AppClipAdvancedExperienceLanguage;
    title?: string;
    subtitle?: string;
  };
}

/** AppClipAdvancedExperience */
export interface AppClipAdvancedExperience {
  type: "appClipAdvancedExperiences";
  id: string;
  attributes?: {
    /** @format uri */
    link?: string;
    version?: number;
    status?: "RECEIVED" | "DEACTIVATED" | "APP_TRANSFER_IN_PROGRESS";
    action?: AppClipAction;
    isPoweredBy?: boolean;
    place?: {
      placeId?: string;
      names?: string[];
      mainAddress?: {
        fullAddress?: string;
        structuredAddress?: {
          streetAddress?: string[];
          floor?: string;
          neighborhood?: string;
          locality?: string;
          stateProvince?: string;
          postalCode?: string;
          countryCode?: string;
        };
      };
      displayPoint?: {
        coordinates?: {
          latitude?: number;
          longitude?: number;
        };
        source?: "CALCULATED" | "MANUALLY_PLACED";
      };
      mapAction?:
        | "BUY_TICKETS"
        | "VIEW_AVAILABILITY"
        | "VIEW_PRICING"
        | "HOTEL_BOOK_ROOM"
        | "PARKING_RESERVE_PARKING"
        | "RESTAURANT_JOIN_WAITLIST"
        | "RESTAURANT_ORDER_DELIVERY"
        | "RESTAURANT_ORDER_FOOD"
        | "RESTAURANT_ORDER_TAKEOUT"
        | "RESTAURANT_RESERVATION"
        | "SCHEDULE_APPOINTMENT"
        | "RESTAURANT_VIEW_MENU"
        | "THEATER_NOW_PLAYING";
      relationship?: "OWNER" | "AUTHORIZED" | "OTHER";
      phoneNumber?: {
        number?: string;
        type?: "FAX" | "LANDLINE" | "MOBILE" | "TOLLFREE";
        intent?: string;
      };
      homePage?: string;
      categories?: string[];
    };
    placeStatus?: "PENDING" | "MATCHED" | "NO_MATCH";
    businessCategory?:
      | "AUTOMOTIVE"
      | "BEAUTY"
      | "BIKES"
      | "BOOKS"
      | "CASINO"
      | "EDUCATION"
      | "EDUCATION_JAPAN"
      | "ENTERTAINMENT"
      | "EV_CHARGER"
      | "FINANCIAL_USD"
      | "FINANCIAL_CNY"
      | "FINANCIAL_GBP"
      | "FINANCIAL_JPY"
      | "FINANCIAL_EUR"
      | "FITNESS"
      | "FOOD_AND_DRINK"
      | "GAS"
      | "GROCERY"
      | "HEALTH_AND_MEDICAL"
      | "HOTEL_AND_TRAVEL"
      | "MUSIC"
      | "PARKING"
      | "PET_SERVICES"
      | "PROFESSIONAL_SERVICES"
      | "SHOPPING"
      | "TICKETING"
      | "TRANSIT";
    defaultLanguage?: AppClipAdvancedExperienceLanguage;
  };
  relationships?: {
    appClip?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "appClips";
        id: string;
      };
    };
    headerImage?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "appClipAdvancedExperienceImages";
        id: string;
      };
    };
    localizations?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "appClipAdvancedExperienceLocalizations";
        id: string;
      }[];
    };
  };
  links?: ResourceLinks;
}

/** AppClipAdvancedExperiencesResponse */
export interface AppClipAdvancedExperiencesResponse {
  data: AppClipAdvancedExperience[];
  included?: (AppClip | AppClipAdvancedExperienceImage | AppClipAdvancedExperienceLocalization)[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** AppClipAdvancedExperienceResponse */
export interface AppClipAdvancedExperienceResponse {
  data: AppClipAdvancedExperience;
  included?: (AppClip | AppClipAdvancedExperienceImage | AppClipAdvancedExperienceLocalization)[];
  links: DocumentLinks;
}

/** AppClipAdvancedExperienceCreateRequest */
export interface AppClipAdvancedExperienceCreateRequest {
  data: {
    type: "appClipAdvancedExperiences";
    attributes: {
      /** @format uri */
      link: string;
      action?: AppClipAction;
      isPoweredBy: boolean;
      place?: {
        placeId?: string;
        names?: string[];
        mainAddress?: {
          fullAddress?: string;
          structuredAddress?: {
            streetAddress?: string[];
            floor?: string;
            neighborhood?: string;
            locality?: string;
            stateProvince?: string;
            postalCode?: string;
            countryCode?: string;
          };
        };
        displayPoint?: {
          coordinates?: {
            latitude?: number;
            longitude?: number;
          };
          source?: "CALCULATED" | "MANUALLY_PLACED";
        };
        mapAction?:
          | "BUY_TICKETS"
          | "VIEW_AVAILABILITY"
          | "VIEW_PRICING"
          | "HOTEL_BOOK_ROOM"
          | "PARKING_RESERVE_PARKING"
          | "RESTAURANT_JOIN_WAITLIST"
          | "RESTAURANT_ORDER_DELIVERY"
          | "RESTAURANT_ORDER_FOOD"
          | "RESTAURANT_ORDER_TAKEOUT"
          | "RESTAURANT_RESERVATION"
          | "SCHEDULE_APPOINTMENT"
          | "RESTAURANT_VIEW_MENU"
          | "THEATER_NOW_PLAYING";
        relationship?: "OWNER" | "AUTHORIZED" | "OTHER";
        phoneNumber?: {
          number?: string;
          type?: "FAX" | "LANDLINE" | "MOBILE" | "TOLLFREE";
          intent?: string;
        };
        homePage?: string;
        categories?: string[];
      };
      businessCategory?:
        | "AUTOMOTIVE"
        | "BEAUTY"
        | "BIKES"
        | "BOOKS"
        | "CASINO"
        | "EDUCATION"
        | "EDUCATION_JAPAN"
        | "ENTERTAINMENT"
        | "EV_CHARGER"
        | "FINANCIAL_USD"
        | "FINANCIAL_CNY"
        | "FINANCIAL_GBP"
        | "FINANCIAL_JPY"
        | "FINANCIAL_EUR"
        | "FITNESS"
        | "FOOD_AND_DRINK"
        | "GAS"
        | "GROCERY"
        | "HEALTH_AND_MEDICAL"
        | "HOTEL_AND_TRAVEL"
        | "MUSIC"
        | "PARKING"
        | "PET_SERVICES"
        | "PROFESSIONAL_SERVICES"
        | "SHOPPING"
        | "TICKETING"
        | "TRANSIT";
      defaultLanguage: AppClipAdvancedExperienceLanguage;
    };
    relationships: {
      appClip: {
        data: {
          type: "appClips";
          id: string;
        };
      };
      headerImage: {
        data: {
          type: "appClipAdvancedExperienceImages";
          id: string;
        };
      };
      localizations: {
        data: {
          type: "appClipAdvancedExperienceLocalizations";
          id: string;
        }[];
      };
    };
  };
  included?: AppClipAdvancedExperienceLocalizationInlineCreate[];
}

/** AppClipAdvancedExperienceUpdateRequest */
export interface AppClipAdvancedExperienceUpdateRequest {
  data: {
    type: "appClipAdvancedExperiences";
    id: string;
    attributes?: {
      action?: AppClipAction;
      isPoweredBy?: boolean;
      place?: {
        placeId?: string;
        names?: string[];
        mainAddress?: {
          fullAddress?: string;
          structuredAddress?: {
            streetAddress?: string[];
            floor?: string;
            neighborhood?: string;
            locality?: string;
            stateProvince?: string;
            postalCode?: string;
            countryCode?: string;
          };
        };
        displayPoint?: {
          coordinates?: {
            latitude?: number;
            longitude?: number;
          };
          source?: "CALCULATED" | "MANUALLY_PLACED";
        };
        mapAction?:
          | "BUY_TICKETS"
          | "VIEW_AVAILABILITY"
          | "VIEW_PRICING"
          | "HOTEL_BOOK_ROOM"
          | "PARKING_RESERVE_PARKING"
          | "RESTAURANT_JOIN_WAITLIST"
          | "RESTAURANT_ORDER_DELIVERY"
          | "RESTAURANT_ORDER_FOOD"
          | "RESTAURANT_ORDER_TAKEOUT"
          | "RESTAURANT_RESERVATION"
          | "SCHEDULE_APPOINTMENT"
          | "RESTAURANT_VIEW_MENU"
          | "THEATER_NOW_PLAYING";
        relationship?: "OWNER" | "AUTHORIZED" | "OTHER";
        phoneNumber?: {
          number?: string;
          type?: "FAX" | "LANDLINE" | "MOBILE" | "TOLLFREE";
          intent?: string;
        };
        homePage?: string;
        categories?: string[];
      };
      businessCategory?:
        | "AUTOMOTIVE"
        | "BEAUTY"
        | "BIKES"
        | "BOOKS"
        | "CASINO"
        | "EDUCATION"
        | "EDUCATION_JAPAN"
        | "ENTERTAINMENT"
        | "EV_CHARGER"
        | "FINANCIAL_USD"
        | "FINANCIAL_CNY"
        | "FINANCIAL_GBP"
        | "FINANCIAL_JPY"
        | "FINANCIAL_EUR"
        | "FITNESS"
        | "FOOD_AND_DRINK"
        | "GAS"
        | "GROCERY"
        | "HEALTH_AND_MEDICAL"
        | "HOTEL_AND_TRAVEL"
        | "MUSIC"
        | "PARKING"
        | "PET_SERVICES"
        | "PROFESSIONAL_SERVICES"
        | "SHOPPING"
        | "TICKETING"
        | "TRANSIT";
      defaultLanguage?: AppClipAdvancedExperienceLanguage;
      removed?: boolean;
    };
    relationships?: {
      appClip?: {
        data?: {
          type: "appClips";
          id: string;
        };
      };
      headerImage?: {
        data?: {
          type: "appClipAdvancedExperienceImages";
          id: string;
        };
      };
      localizations?: {
        data?: {
          type: "appClipAdvancedExperienceLocalizations";
          id: string;
        }[];
      };
    };
  };
  included?: AppClipAdvancedExperienceLocalizationInlineCreate[];
}

/** AppClipAppStoreReviewDetail */
export interface AppClipAppStoreReviewDetail {
  type: "appClipAppStoreReviewDetails";
  id: string;
  attributes?: {
    invocationUrls?: string[];
  };
  relationships?: {
    appClipDefaultExperience?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "appClipDefaultExperiences";
        id: string;
      };
    };
  };
  links?: ResourceLinks;
}

/** AppClipAppStoreReviewDetailResponse */
export interface AppClipAppStoreReviewDetailResponse {
  data: AppClipAppStoreReviewDetail;
  included?: AppClipDefaultExperience[];
  links: DocumentLinks;
}

/** AppClipAppStoreReviewDetailCreateRequest */
export interface AppClipAppStoreReviewDetailCreateRequest {
  data: {
    type: "appClipAppStoreReviewDetails";
    attributes?: {
      invocationUrls?: string[];
    };
    relationships: {
      appClipDefaultExperience: {
        data: {
          type: "appClipDefaultExperiences";
          id: string;
        };
      };
    };
  };
}

/** AppClipAppStoreReviewDetailUpdateRequest */
export interface AppClipAppStoreReviewDetailUpdateRequest {
  data: {
    type: "appClipAppStoreReviewDetails";
    id: string;
    attributes?: {
      invocationUrls?: string[];
    };
  };
}

/** AppClipDefaultExperienceLocalization */
export interface AppClipDefaultExperienceLocalization {
  type: "appClipDefaultExperienceLocalizations";
  id: string;
  attributes?: {
    locale?: string;
    subtitle?: string;
  };
  relationships?: {
    appClipDefaultExperience?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "appClipDefaultExperiences";
        id: string;
      };
    };
    appClipHeaderImage?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "appClipHeaderImages";
        id: string;
      };
    };
  };
  links?: ResourceLinks;
}

/** AppClipDefaultExperienceLocalizationsResponse */
export interface AppClipDefaultExperienceLocalizationsResponse {
  data: AppClipDefaultExperienceLocalization[];
  included?: (AppClipDefaultExperience | AppClipHeaderImage)[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** AppClipDefaultExperienceLocalizationResponse */
export interface AppClipDefaultExperienceLocalizationResponse {
  data: AppClipDefaultExperienceLocalization;
  included?: (AppClipDefaultExperience | AppClipHeaderImage)[];
  links: DocumentLinks;
}

/** AppClipDefaultExperienceLocalizationCreateRequest */
export interface AppClipDefaultExperienceLocalizationCreateRequest {
  data: {
    type: "appClipDefaultExperienceLocalizations";
    attributes: {
      locale: string;
      subtitle?: string;
    };
    relationships: {
      appClipDefaultExperience: {
        data: {
          type: "appClipDefaultExperiences";
          id: string;
        };
      };
    };
  };
}

/** AppClipDefaultExperienceLocalizationUpdateRequest */
export interface AppClipDefaultExperienceLocalizationUpdateRequest {
  data: {
    type: "appClipDefaultExperienceLocalizations";
    id: string;
    attributes?: {
      subtitle?: string;
    };
  };
}

/** AppClipDefaultExperience */
export interface AppClipDefaultExperience {
  type: "appClipDefaultExperiences";
  id: string;
  attributes?: {
    action?: AppClipAction;
  };
  relationships?: {
    appClip?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "appClips";
        id: string;
      };
    };
    releaseWithAppStoreVersion?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "appStoreVersions";
        id: string;
      };
    };
    appClipDefaultExperienceLocalizations?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "appClipDefaultExperienceLocalizations";
        id: string;
      }[];
    };
    appClipAppStoreReviewDetail?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "appClipAppStoreReviewDetails";
        id: string;
      };
    };
  };
  links?: ResourceLinks;
}

/** AppClipDefaultExperiencesResponse */
export interface AppClipDefaultExperiencesResponse {
  data: AppClipDefaultExperience[];
  included?: (AppClip | AppStoreVersion | AppClipDefaultExperienceLocalization | AppClipAppStoreReviewDetail)[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** AppClipDefaultExperienceResponse */
export interface AppClipDefaultExperienceResponse {
  data: AppClipDefaultExperience;
  included?: (AppClip | AppStoreVersion | AppClipDefaultExperienceLocalization | AppClipAppStoreReviewDetail)[];
  links: DocumentLinks;
}

/** AppClipDefaultExperienceCreateRequest */
export interface AppClipDefaultExperienceCreateRequest {
  data: {
    type: "appClipDefaultExperiences";
    attributes?: {
      action?: AppClipAction;
    };
    relationships: {
      appClip: {
        data: {
          type: "appClips";
          id: string;
        };
      };
      releaseWithAppStoreVersion?: {
        data?: {
          type: "appStoreVersions";
          id: string;
        };
      };
      appClipDefaultExperienceTemplate?: {
        data?: {
          type: "appClipDefaultExperiences";
          id: string;
        };
      };
    };
  };
}

/** AppClipDefaultExperienceUpdateRequest */
export interface AppClipDefaultExperienceUpdateRequest {
  data: {
    type: "appClipDefaultExperiences";
    id: string;
    attributes?: {
      action?: AppClipAction;
    };
    relationships?: {
      releaseWithAppStoreVersion?: {
        data?: {
          type: "appStoreVersions";
          id: string;
        };
      };
    };
  };
}

/** AppClipDomainStatus */
export interface AppClipDomainStatus {
  type: "appClipDomainStatuses";
  id: string;
  attributes?: {
    domains?: {
      domain?: string;
      isValid?: boolean;
      /** @format date-time */
      lastUpdatedDate?: string;
      errorCode?:
        | "BAD_HTTP_RESPONSE"
        | "BAD_JSON_CONTENT"
        | "BAD_PKCS7_SIGNATURE"
        | "CANNOT_REACH_AASA_FILE"
        | "DNS_ERROR"
        | "INSECURE_REDIRECTS_FORBIDDEN"
        | "INVALID_ENTITLEMENT_MISSING_SECTION"
        | "INVALID_ENTITLEMENT_SYNTAX_ERROR"
        | "INVALID_ENTITLEMENT_UNHANDLED_SECTION"
        | "INVALID_ENTITLEMENT_UNKNOWN_ID"
        | "NETWORK_ERROR"
        | "NETWORK_ERROR_TEMPORARY"
        | "OTHER_ERROR"
        | "TIMEOUT"
        | "TLS_ERROR"
        | "UNEXPECTED_ERROR";
    }[];
    /** @format date-time */
    lastUpdatedDate?: string;
  };
  links?: ResourceLinks;
}

/** AppClipDomainStatusResponse */
export interface AppClipDomainStatusResponse {
  data: AppClipDomainStatus;
  links: DocumentLinks;
}

/** AppClipHeaderImage */
export interface AppClipHeaderImage {
  type: "appClipHeaderImages";
  id: string;
  attributes?: {
    fileSize?: number;
    fileName?: string;
    sourceFileChecksum?: string;
    imageAsset?: ImageAsset;
    uploadOperations?: UploadOperation[];
    assetDeliveryState?: AppMediaAssetState;
  };
  relationships?: {
    appClipDefaultExperienceLocalization?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "appClipDefaultExperienceLocalizations";
        id: string;
      };
    };
  };
  links?: ResourceLinks;
}

/** AppClipHeaderImageResponse */
export interface AppClipHeaderImageResponse {
  data: AppClipHeaderImage;
  included?: AppClipDefaultExperienceLocalization[];
  links: DocumentLinks;
}

/** AppClipHeaderImageCreateRequest */
export interface AppClipHeaderImageCreateRequest {
  data: {
    type: "appClipHeaderImages";
    attributes: {
      fileSize: number;
      fileName: string;
    };
    relationships: {
      appClipDefaultExperienceLocalization: {
        data: {
          type: "appClipDefaultExperienceLocalizations";
          id: string;
        };
      };
    };
  };
}

/** AppClipHeaderImageUpdateRequest */
export interface AppClipHeaderImageUpdateRequest {
  data: {
    type: "appClipHeaderImages";
    id: string;
    attributes?: {
      sourceFileChecksum?: string;
      uploaded?: boolean;
    };
  };
}

/** AppClip */
export interface AppClip {
  type: "appClips";
  id: string;
  attributes?: {
    bundleId?: string;
  };
  relationships?: {
    app?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "apps";
        id: string;
      };
    };
    appClipDefaultExperiences?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "appClipDefaultExperiences";
        id: string;
      }[];
    };
  };
  links?: ResourceLinks;
}

/** AppClipsResponse */
export interface AppClipsResponse {
  data: AppClip[];
  included?: (App | AppClipDefaultExperience)[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** AppClipResponse */
export interface AppClipResponse {
  data: AppClip;
  included?: (App | AppClipDefaultExperience)[];
  links: DocumentLinks;
}

/** AppCustomProductPageLocalization */
export interface AppCustomProductPageLocalization {
  type: "appCustomProductPageLocalizations";
  id: string;
  attributes?: {
    locale?: string;
    promotionalText?: string;
  };
  relationships?: {
    appCustomProductPageVersion?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "appCustomProductPageVersions";
        id: string;
      };
    };
    appScreenshotSets?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "appScreenshotSets";
        id: string;
      }[];
    };
    appPreviewSets?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "appPreviewSets";
        id: string;
      }[];
    };
  };
  links?: ResourceLinks;
}

export interface AppCustomProductPageLocalizationInlineCreate {
  type: "appCustomProductPageLocalizations";
  id?: string;
  attributes: {
    locale: string;
    promotionalText?: string;
  };
  relationships?: {
    appCustomProductPageVersion?: {
      data?: {
        type: "appCustomProductPageVersions";
        id: string;
      };
    };
  };
}

/** AppCustomProductPageLocalizationsResponse */
export interface AppCustomProductPageLocalizationsResponse {
  data: AppCustomProductPageLocalization[];
  included?: (AppCustomProductPageVersion | AppScreenshotSet | AppPreviewSet)[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** AppCustomProductPageLocalizationResponse */
export interface AppCustomProductPageLocalizationResponse {
  data: AppCustomProductPageLocalization;
  included?: (AppCustomProductPageVersion | AppScreenshotSet | AppPreviewSet)[];
  links: DocumentLinks;
}

/** AppCustomProductPageLocalizationCreateRequest */
export interface AppCustomProductPageLocalizationCreateRequest {
  data: {
    type: "appCustomProductPageLocalizations";
    attributes: {
      locale: string;
      promotionalText?: string;
    };
    relationships: {
      appCustomProductPageVersion: {
        data: {
          type: "appCustomProductPageVersions";
          id: string;
        };
      };
    };
  };
}

/** AppCustomProductPageLocalizationUpdateRequest */
export interface AppCustomProductPageLocalizationUpdateRequest {
  data: {
    type: "appCustomProductPageLocalizations";
    id: string;
    attributes?: {
      promotionalText?: string;
    };
  };
}

/** AppCustomProductPageVersion */
export interface AppCustomProductPageVersion {
  type: "appCustomProductPageVersions";
  id: string;
  attributes?: {
    version?: string;
    state?:
      | "PREPARE_FOR_SUBMISSION"
      | "READY_FOR_REVIEW"
      | "WAITING_FOR_REVIEW"
      | "IN_REVIEW"
      | "ACCEPTED"
      | "APPROVED"
      | "REPLACED_WITH_NEW_VERSION"
      | "REJECTED";
  };
  relationships?: {
    appCustomProductPage?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "appCustomProductPages";
        id: string;
      };
    };
    appCustomProductPageLocalizations?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "appCustomProductPageLocalizations";
        id: string;
      }[];
    };
  };
  links?: ResourceLinks;
}

export interface AppCustomProductPageVersionInlineCreate {
  type: "appCustomProductPageVersions";
  id?: string;
  relationships?: {
    appCustomProductPage?: {
      data?: {
        type: "appCustomProductPages";
        id: string;
      };
    };
    appCustomProductPageLocalizations?: {
      data?: {
        type: "appCustomProductPageLocalizations";
        id: string;
      }[];
    };
  };
}

/** AppCustomProductPageVersionsResponse */
export interface AppCustomProductPageVersionsResponse {
  data: AppCustomProductPageVersion[];
  included?: (AppCustomProductPage | AppCustomProductPageLocalization)[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** AppCustomProductPageVersionResponse */
export interface AppCustomProductPageVersionResponse {
  data: AppCustomProductPageVersion;
  included?: (AppCustomProductPage | AppCustomProductPageLocalization)[];
  links: DocumentLinks;
}

/** AppCustomProductPageVersionCreateRequest */
export interface AppCustomProductPageVersionCreateRequest {
  data: {
    type: "appCustomProductPageVersions";
    relationships: {
      appCustomProductPage: {
        data: {
          type: "appCustomProductPages";
          id: string;
        };
      };
      appCustomProductPageLocalizations?: {
        data?: {
          type: "appCustomProductPageLocalizations";
          id: string;
        }[];
      };
    };
  };
}

/** AppCustomProductPage */
export interface AppCustomProductPage {
  type: "appCustomProductPages";
  id: string;
  attributes?: {
    name?: string;
    /** @format uri */
    url?: string;
    visible?: boolean;
  };
  relationships?: {
    app?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "apps";
        id: string;
      };
    };
    appCustomProductPageVersions?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "appCustomProductPageVersions";
        id: string;
      }[];
    };
  };
  links?: ResourceLinks;
}

/** AppCustomProductPagesResponse */
export interface AppCustomProductPagesResponse {
  data: AppCustomProductPage[];
  included?: (App | AppCustomProductPageVersion)[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** AppCustomProductPageResponse */
export interface AppCustomProductPageResponse {
  data: AppCustomProductPage;
  included?: (App | AppCustomProductPageVersion)[];
  links: DocumentLinks;
}

/** AppCustomProductPageCreateRequest */
export interface AppCustomProductPageCreateRequest {
  data: {
    type: "appCustomProductPages";
    attributes: {
      name: string;
    };
    relationships: {
      app: {
        data: {
          type: "apps";
          id: string;
        };
      };
      appCustomProductPageVersions?: {
        data?: {
          type: "appCustomProductPageVersions";
          id: string;
        }[];
      };
      appStoreVersionTemplate?: {
        data?: {
          type: "appStoreVersions";
          id: string;
        };
      };
      customProductPageTemplate?: {
        data?: {
          type: "appCustomProductPages";
          id: string;
        };
      };
    };
  };
  included?: (AppCustomProductPageLocalizationInlineCreate | AppCustomProductPageVersionInlineCreate)[];
}

/** AppCustomProductPageUpdateRequest */
export interface AppCustomProductPageUpdateRequest {
  data: {
    type: "appCustomProductPages";
    id: string;
    attributes?: {
      name?: string;
      visible?: boolean;
    };
  };
}

/** AppEncryptionDeclarationDocument */
export interface AppEncryptionDeclarationDocument {
  type: "appEncryptionDeclarationDocuments";
  id: string;
  attributes?: {
    fileSize?: number;
    fileName?: string;
    assetToken?: string;
    /** @format uri */
    downloadUrl?: string;
    sourceFileChecksum?: string;
    uploadOperations?: UploadOperation[];
    assetDeliveryState?: AppMediaAssetState;
  };
  links?: ResourceLinks;
}

/** AppEncryptionDeclarationDocumentResponse */
export interface AppEncryptionDeclarationDocumentResponse {
  data: AppEncryptionDeclarationDocument;
  links: DocumentLinks;
}

/** AppEncryptionDeclarationDocumentCreateRequest */
export interface AppEncryptionDeclarationDocumentCreateRequest {
  data: {
    type: "appEncryptionDeclarationDocuments";
    attributes: {
      fileSize: number;
      fileName: string;
    };
    relationships: {
      appEncryptionDeclaration: {
        data: {
          type: "appEncryptionDeclarations";
          id: string;
        };
      };
    };
  };
}

/** AppEncryptionDeclarationDocumentUpdateRequest */
export interface AppEncryptionDeclarationDocumentUpdateRequest {
  data: {
    type: "appEncryptionDeclarationDocuments";
    id: string;
    attributes?: {
      sourceFileChecksum?: string;
      uploaded?: boolean;
    };
  };
}

/** AppEncryptionDeclaration */
export interface AppEncryptionDeclaration {
  type: "appEncryptionDeclarations";
  id: string;
  attributes?: {
    appDescription?: string;
    /** @format date-time */
    createdDate?: string;
    /** @deprecated */
    usesEncryption?: boolean;
    exempt?: boolean;
    containsProprietaryCryptography?: boolean;
    containsThirdPartyCryptography?: boolean;
    availableOnFrenchStore?: boolean;
    /** @deprecated */
    platform?: Platform;
    /**
     * @deprecated
     * @format date-time
     */
    uploadedDate?: string;
    /** @deprecated */
    documentUrl?: string;
    /** @deprecated */
    documentName?: string;
    /** @deprecated */
    documentType?: string;
    appEncryptionDeclarationState?: AppEncryptionDeclarationState;
    codeValue?: string;
  };
  relationships?: {
    app?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "apps";
        id: string;
      };
    };
    /** @deprecated */
    builds?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "builds";
        id: string;
      }[];
    };
    appEncryptionDeclarationDocument?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "appEncryptionDeclarationDocuments";
        id: string;
      };
    };
  };
  links?: ResourceLinks;
}

/** AppEncryptionDeclarationsResponse */
export interface AppEncryptionDeclarationsResponse {
  data: AppEncryptionDeclaration[];
  included?: (App | Build | AppEncryptionDeclarationDocument)[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** AppEncryptionDeclarationResponse */
export interface AppEncryptionDeclarationResponse {
  data: AppEncryptionDeclaration;
  included?: (App | Build | AppEncryptionDeclarationDocument)[];
  links: DocumentLinks;
}

/** AppEventLocalization */
export interface AppEventLocalization {
  type: "appEventLocalizations";
  id: string;
  attributes?: {
    locale?: string;
    name?: string;
    shortDescription?: string;
    longDescription?: string;
  };
  relationships?: {
    appEvent?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "appEvents";
        id: string;
      };
    };
    appEventScreenshots?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "appEventScreenshots";
        id: string;
      }[];
    };
    appEventVideoClips?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "appEventVideoClips";
        id: string;
      }[];
    };
  };
  links?: ResourceLinks;
}

/** AppEventLocalizationsResponse */
export interface AppEventLocalizationsResponse {
  data: AppEventLocalization[];
  included?: (AppEvent | AppEventScreenshot | AppEventVideoClip)[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** AppEventLocalizationResponse */
export interface AppEventLocalizationResponse {
  data: AppEventLocalization;
  included?: (AppEvent | AppEventScreenshot | AppEventVideoClip)[];
  links: DocumentLinks;
}

/** AppEventLocalizationCreateRequest */
export interface AppEventLocalizationCreateRequest {
  data: {
    type: "appEventLocalizations";
    attributes: {
      locale: string;
      name?: string;
      shortDescription?: string;
      longDescription?: string;
    };
    relationships: {
      appEvent: {
        data: {
          type: "appEvents";
          id: string;
        };
      };
    };
  };
}

/** AppEventLocalizationUpdateRequest */
export interface AppEventLocalizationUpdateRequest {
  data: {
    type: "appEventLocalizations";
    id: string;
    attributes?: {
      name?: string;
      shortDescription?: string;
      longDescription?: string;
    };
  };
}

/** AppEventScreenshot */
export interface AppEventScreenshot {
  type: "appEventScreenshots";
  id: string;
  attributes?: {
    fileSize?: number;
    fileName?: string;
    imageAsset?: ImageAsset;
    assetToken?: string;
    uploadOperations?: UploadOperation[];
    assetDeliveryState?: AppMediaAssetState;
    appEventAssetType?: AppEventAssetType;
  };
  relationships?: {
    appEventLocalization?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "appEventLocalizations";
        id: string;
      };
    };
  };
  links?: ResourceLinks;
}

/** AppEventScreenshotsResponse */
export interface AppEventScreenshotsResponse {
  data: AppEventScreenshot[];
  included?: AppEventLocalization[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** AppEventScreenshotResponse */
export interface AppEventScreenshotResponse {
  data: AppEventScreenshot;
  included?: AppEventLocalization[];
  links: DocumentLinks;
}

/** AppEventScreenshotCreateRequest */
export interface AppEventScreenshotCreateRequest {
  data: {
    type: "appEventScreenshots";
    attributes: {
      fileSize: number;
      fileName: string;
      appEventAssetType: AppEventAssetType;
    };
    relationships: {
      appEventLocalization: {
        data: {
          type: "appEventLocalizations";
          id: string;
        };
      };
    };
  };
}

/** AppEventScreenshotUpdateRequest */
export interface AppEventScreenshotUpdateRequest {
  data: {
    type: "appEventScreenshots";
    id: string;
    attributes?: {
      uploaded?: boolean;
    };
  };
}

/** AppEventVideoClip */
export interface AppEventVideoClip {
  type: "appEventVideoClips";
  id: string;
  attributes?: {
    fileSize?: number;
    fileName?: string;
    previewFrameTimeCode?: string;
    videoUrl?: string;
    previewImage?: ImageAsset;
    uploadOperations?: UploadOperation[];
    assetDeliveryState?: AppMediaAssetState;
    appEventAssetType?: AppEventAssetType;
  };
  relationships?: {
    appEventLocalization?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "appEventLocalizations";
        id: string;
      };
    };
  };
  links?: ResourceLinks;
}

/** AppEventVideoClipsResponse */
export interface AppEventVideoClipsResponse {
  data: AppEventVideoClip[];
  included?: AppEventLocalization[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** AppEventVideoClipResponse */
export interface AppEventVideoClipResponse {
  data: AppEventVideoClip;
  included?: AppEventLocalization[];
  links: DocumentLinks;
}

/** AppEventVideoClipCreateRequest */
export interface AppEventVideoClipCreateRequest {
  data: {
    type: "appEventVideoClips";
    attributes: {
      fileSize: number;
      fileName: string;
      previewFrameTimeCode?: string;
      appEventAssetType: AppEventAssetType;
    };
    relationships: {
      appEventLocalization: {
        data: {
          type: "appEventLocalizations";
          id: string;
        };
      };
    };
  };
}

/** AppEventVideoClipUpdateRequest */
export interface AppEventVideoClipUpdateRequest {
  data: {
    type: "appEventVideoClips";
    id: string;
    attributes?: {
      previewFrameTimeCode?: string;
      uploaded?: boolean;
    };
  };
}

/** AppEvent */
export interface AppEvent {
  type: "appEvents";
  id: string;
  attributes?: {
    referenceName?: string;
    badge?: "LIVE_EVENT" | "PREMIERE" | "CHALLENGE" | "COMPETITION" | "NEW_SEASON" | "MAJOR_UPDATE" | "SPECIAL_EVENT";
    eventState?:
      | "DRAFT"
      | "READY_FOR_REVIEW"
      | "WAITING_FOR_REVIEW"
      | "IN_REVIEW"
      | "REJECTED"
      | "ACCEPTED"
      | "APPROVED"
      | "PUBLISHED"
      | "PAST"
      | "ARCHIVED";
    /** @format uri */
    deepLink?: string;
    purchaseRequirement?:
      | "NO_COST_ASSOCIATED"
      | "IN_APP_PURCHASE"
      | "SUBSCRIPTION"
      | "IN_APP_PURCHASE_AND_SUBSCRIPTION"
      | "IN_APP_PURCHASE_OR_SUBSCRIPTION";
    primaryLocale?: string;
    priority?: "HIGH" | "NORMAL";
    purpose?:
      | "APPROPRIATE_FOR_ALL_USERS"
      | "ATTRACT_NEW_USERS"
      | "KEEP_ACTIVE_USERS_INFORMED"
      | "BRING_BACK_LAPSED_USERS";
    territorySchedules?: {
      territories?: string[];
      /** @format date-time */
      publishStart?: string;
      /** @format date-time */
      eventStart?: string;
      /** @format date-time */
      eventEnd?: string;
    }[];
    archivedTerritorySchedules?: {
      territories?: string[];
      /** @format date-time */
      publishStart?: string;
      /** @format date-time */
      eventStart?: string;
      /** @format date-time */
      eventEnd?: string;
    }[];
  };
  relationships?: {
    localizations?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "appEventLocalizations";
        id: string;
      }[];
    };
  };
  links?: ResourceLinks;
}

/** AppEventsResponse */
export interface AppEventsResponse {
  data: AppEvent[];
  included?: AppEventLocalization[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** AppEventResponse */
export interface AppEventResponse {
  data: AppEvent;
  included?: AppEventLocalization[];
  links: DocumentLinks;
}

/** AppEventCreateRequest */
export interface AppEventCreateRequest {
  data: {
    type: "appEvents";
    attributes: {
      referenceName: string;
      badge?: "LIVE_EVENT" | "PREMIERE" | "CHALLENGE" | "COMPETITION" | "NEW_SEASON" | "MAJOR_UPDATE" | "SPECIAL_EVENT";
      /** @format uri */
      deepLink?: string;
      purchaseRequirement?:
        | "NO_COST_ASSOCIATED"
        | "IN_APP_PURCHASE"
        | "SUBSCRIPTION"
        | "IN_APP_PURCHASE_AND_SUBSCRIPTION"
        | "IN_APP_PURCHASE_OR_SUBSCRIPTION";
      primaryLocale?: string;
      priority?: "HIGH" | "NORMAL";
      purpose?:
        | "APPROPRIATE_FOR_ALL_USERS"
        | "ATTRACT_NEW_USERS"
        | "KEEP_ACTIVE_USERS_INFORMED"
        | "BRING_BACK_LAPSED_USERS";
      territorySchedules?: {
        territories?: string[];
        /** @format date-time */
        publishStart?: string;
        /** @format date-time */
        eventStart?: string;
        /** @format date-time */
        eventEnd?: string;
      }[];
    };
    relationships: {
      app: {
        data: {
          type: "apps";
          id: string;
        };
      };
    };
  };
}

/** AppEventUpdateRequest */
export interface AppEventUpdateRequest {
  data: {
    type: "appEvents";
    id: string;
    attributes?: {
      referenceName?: string;
      badge?: "LIVE_EVENT" | "PREMIERE" | "CHALLENGE" | "COMPETITION" | "NEW_SEASON" | "MAJOR_UPDATE" | "SPECIAL_EVENT";
      /** @format uri */
      deepLink?: string;
      purchaseRequirement?:
        | "NO_COST_ASSOCIATED"
        | "IN_APP_PURCHASE"
        | "SUBSCRIPTION"
        | "IN_APP_PURCHASE_AND_SUBSCRIPTION"
        | "IN_APP_PURCHASE_OR_SUBSCRIPTION";
      primaryLocale?: string;
      priority?: "HIGH" | "NORMAL";
      purpose?:
        | "APPROPRIATE_FOR_ALL_USERS"
        | "ATTRACT_NEW_USERS"
        | "KEEP_ACTIVE_USERS_INFORMED"
        | "BRING_BACK_LAPSED_USERS";
      territorySchedules?: {
        territories?: string[];
        /** @format date-time */
        publishStart?: string;
        /** @format date-time */
        eventStart?: string;
        /** @format date-time */
        eventEnd?: string;
      }[];
    };
  };
}

/** AppInfoLocalization */
export interface AppInfoLocalization {
  type: "appInfoLocalizations";
  id: string;
  attributes?: {
    locale?: string;
    name?: string;
    subtitle?: string;
    privacyPolicyUrl?: string;
    privacyChoicesUrl?: string;
    privacyPolicyText?: string;
  };
  relationships?: {
    appInfo?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "appInfos";
        id: string;
      };
    };
  };
  links?: ResourceLinks;
}

/** AppInfoLocalizationsResponse */
export interface AppInfoLocalizationsResponse {
  data: AppInfoLocalization[];
  included?: AppInfo[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** AppInfoLocalizationResponse */
export interface AppInfoLocalizationResponse {
  data: AppInfoLocalization;
  included?: AppInfo[];
  links: DocumentLinks;
}

/** AppInfoLocalizationCreateRequest */
export interface AppInfoLocalizationCreateRequest {
  data: {
    type: "appInfoLocalizations";
    attributes: {
      locale: string;
      name?: string;
      subtitle?: string;
      privacyPolicyUrl?: string;
      privacyChoicesUrl?: string;
      privacyPolicyText?: string;
    };
    relationships: {
      appInfo: {
        data: {
          type: "appInfos";
          id: string;
        };
      };
    };
  };
}

/** AppInfoLocalizationUpdateRequest */
export interface AppInfoLocalizationUpdateRequest {
  data: {
    type: "appInfoLocalizations";
    id: string;
    attributes?: {
      name?: string;
      subtitle?: string;
      privacyPolicyUrl?: string;
      privacyChoicesUrl?: string;
      privacyPolicyText?: string;
    };
  };
}

/** AppInfo */
export interface AppInfo {
  type: "appInfos";
  id: string;
  attributes?: {
    /** @deprecated */
    appStoreState?: AppStoreVersionState;
    state?:
      | "ACCEPTED"
      | "DEVELOPER_REJECTED"
      | "IN_REVIEW"
      | "PENDING_RELEASE"
      | "PREPARE_FOR_SUBMISSION"
      | "READY_FOR_DISTRIBUTION"
      | "READY_FOR_REVIEW"
      | "REJECTED"
      | "REPLACED_WITH_NEW_INFO"
      | "WAITING_FOR_REVIEW";
    appStoreAgeRating?: AppStoreAgeRating;
    /** @deprecated */
    brazilAgeRating?: BrazilAgeRating;
    brazilAgeRatingV2?:
      | "SELF_RATED_L"
      | "SELF_RATED_TEN"
      | "SELF_RATED_TWELVE"
      | "SELF_RATED_FOURTEEN"
      | "SELF_RATED_SIXTEEN"
      | "SELF_RATED_EIGHTEEN"
      | "OFFICIAL_L"
      | "OFFICIAL_TEN"
      | "OFFICIAL_TWELVE"
      | "OFFICIAL_FOURTEEN"
      | "OFFICIAL_SIXTEEN"
      | "OFFICIAL_EIGHTEEN";
    kidsAgeBand?: KidsAgeBand;
  };
  relationships?: {
    app?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "apps";
        id: string;
      };
    };
    ageRatingDeclaration?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "ageRatingDeclarations";
        id: string;
      };
    };
    appInfoLocalizations?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "appInfoLocalizations";
        id: string;
      }[];
    };
    primaryCategory?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "appCategories";
        id: string;
      };
    };
    primarySubcategoryOne?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "appCategories";
        id: string;
      };
    };
    primarySubcategoryTwo?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "appCategories";
        id: string;
      };
    };
    secondaryCategory?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "appCategories";
        id: string;
      };
    };
    secondarySubcategoryOne?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "appCategories";
        id: string;
      };
    };
    secondarySubcategoryTwo?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "appCategories";
        id: string;
      };
    };
  };
  links?: ResourceLinks;
}

/** AppInfosResponse */
export interface AppInfosResponse {
  data: AppInfo[];
  included?: (App | AgeRatingDeclaration | AppInfoLocalization | AppCategory)[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** AppInfoResponse */
export interface AppInfoResponse {
  data: AppInfo;
  included?: (App | AgeRatingDeclaration | AppInfoLocalization | AppCategory)[];
  links: DocumentLinks;
}

/** AppInfoUpdateRequest */
export interface AppInfoUpdateRequest {
  data: {
    type: "appInfos";
    id: string;
    relationships?: {
      primaryCategory?: {
        data?: {
          type: "appCategories";
          id: string;
        };
      };
      primarySubcategoryOne?: {
        data?: {
          type: "appCategories";
          id: string;
        };
      };
      primarySubcategoryTwo?: {
        data?: {
          type: "appCategories";
          id: string;
        };
      };
      secondaryCategory?: {
        data?: {
          type: "appCategories";
          id: string;
        };
      };
      secondarySubcategoryOne?: {
        data?: {
          type: "appCategories";
          id: string;
        };
      };
      secondarySubcategoryTwo?: {
        data?: {
          type: "appCategories";
          id: string;
        };
      };
    };
  };
}

/**
 * AppPreOrder
 * @deprecated
 */
export interface AppPreOrder {
  type: "appPreOrders";
  id: string;
  attributes?: {
    /** @format date */
    preOrderAvailableDate?: string;
    /** @format date */
    appReleaseDate?: string;
  };
  relationships?: {
    app?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "apps";
        id: string;
      };
    };
  };
  links?: ResourceLinks;
}

/**
 * AppPreOrderResponse
 * @deprecated
 */
export interface AppPreOrderResponse {
  data: AppPreOrder;
  included?: App[];
  links: DocumentLinks;
}

/**
 * AppPreOrderCreateRequest
 * @deprecated
 */
export interface AppPreOrderCreateRequest {
  data: {
    type: "appPreOrders";
    attributes?: {
      /** @format date */
      appReleaseDate?: string;
    };
    relationships: {
      app: {
        data: {
          type: "apps";
          id: string;
        };
      };
    };
  };
}

/**
 * AppPreOrderUpdateRequest
 * @deprecated
 */
export interface AppPreOrderUpdateRequest {
  data: {
    type: "appPreOrders";
    id: string;
    attributes?: {
      /** @format date */
      appReleaseDate?: string;
    };
  };
}

/** AppPreviewSet */
export interface AppPreviewSet {
  type: "appPreviewSets";
  id: string;
  attributes?: {
    previewType?: PreviewType;
  };
  relationships?: {
    appStoreVersionLocalization?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "appStoreVersionLocalizations";
        id: string;
      };
    };
    appCustomProductPageLocalization?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "appCustomProductPageLocalizations";
        id: string;
      };
    };
    appStoreVersionExperimentTreatmentLocalization?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "appStoreVersionExperimentTreatmentLocalizations";
        id: string;
      };
    };
    appPreviews?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "appPreviews";
        id: string;
      }[];
    };
  };
  links?: ResourceLinks;
}

/** AppPreviewSetsResponse */
export interface AppPreviewSetsResponse {
  data: AppPreviewSet[];
  included?: (
    | AppStoreVersionLocalization
    | AppCustomProductPageLocalization
    | AppStoreVersionExperimentTreatmentLocalization
    | AppPreview
  )[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** AppPreviewSetResponse */
export interface AppPreviewSetResponse {
  data: AppPreviewSet;
  included?: (
    | AppStoreVersionLocalization
    | AppCustomProductPageLocalization
    | AppStoreVersionExperimentTreatmentLocalization
    | AppPreview
  )[];
  links: DocumentLinks;
}

/** AppPreviewSetCreateRequest */
export interface AppPreviewSetCreateRequest {
  data: {
    type: "appPreviewSets";
    attributes: {
      previewType: PreviewType;
    };
    relationships?: {
      appStoreVersionLocalization?: {
        data?: {
          type: "appStoreVersionLocalizations";
          id: string;
        };
      };
      appCustomProductPageLocalization?: {
        data?: {
          type: "appCustomProductPageLocalizations";
          id: string;
        };
      };
      appStoreVersionExperimentTreatmentLocalization?: {
        data?: {
          type: "appStoreVersionExperimentTreatmentLocalizations";
          id: string;
        };
      };
    };
  };
}

/** AppPreview */
export interface AppPreview {
  type: "appPreviews";
  id: string;
  attributes?: {
    fileSize?: number;
    fileName?: string;
    sourceFileChecksum?: string;
    previewFrameTimeCode?: string;
    mimeType?: string;
    videoUrl?: string;
    previewImage?: ImageAsset;
    uploadOperations?: UploadOperation[];
    assetDeliveryState?: AppMediaAssetState;
  };
  relationships?: {
    appPreviewSet?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "appPreviewSets";
        id: string;
      };
    };
  };
  links?: ResourceLinks;
}

/** AppPreviewsResponse */
export interface AppPreviewsResponse {
  data: AppPreview[];
  included?: AppPreviewSet[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** AppPreviewResponse */
export interface AppPreviewResponse {
  data: AppPreview;
  included?: AppPreviewSet[];
  links: DocumentLinks;
}

/** AppPreviewCreateRequest */
export interface AppPreviewCreateRequest {
  data: {
    type: "appPreviews";
    attributes: {
      fileSize: number;
      fileName: string;
      previewFrameTimeCode?: string;
      mimeType?: string;
    };
    relationships: {
      appPreviewSet: {
        data: {
          type: "appPreviewSets";
          id: string;
        };
      };
    };
  };
}

/** AppPreviewUpdateRequest */
export interface AppPreviewUpdateRequest {
  data: {
    type: "appPreviews";
    id: string;
    attributes?: {
      sourceFileChecksum?: string;
      previewFrameTimeCode?: string;
      uploaded?: boolean;
    };
  };
}

/**
 * AppPricePointV2
 * @deprecated
 */
export interface AppPricePointV2 {
  type: "appPricePoints";
  id: string;
  attributes?: {
    customerPrice?: string;
    proceeds?: string;
  };
  relationships?: {
    app?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "apps";
        id: string;
      };
    };
    priceTier?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "appPriceTiers";
        id: string;
      };
    };
    territory?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "territories";
        id: string;
      };
    };
  };
  links?: ResourceLinks;
}

/**
 * AppPricePointsV2Response
 * @deprecated
 */
export interface AppPricePointsV2Response {
  data: AppPricePointV2[];
  included?: (App | AppPriceTier | Territory)[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** AppPricePointV3 */
export interface AppPricePointV3 {
  type: "appPricePoints";
  id: string;
  attributes?: {
    customerPrice?: string;
    proceeds?: string;
  };
  relationships?: {
    app?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "apps";
        id: string;
      };
    };
    territory?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "territories";
        id: string;
      };
    };
  };
  links?: ResourceLinks;
}

/** AppPricePointsV3Response */
export interface AppPricePointsV3Response {
  data: AppPricePointV3[];
  included?: (App | Territory)[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** AppPricePointV3Response */
export interface AppPricePointV3Response {
  data: AppPricePointV3;
  included?: (App | Territory)[];
  links: DocumentLinks;
}

/**
 * AppPricePoint
 * @deprecated
 */
export interface AppPricePoint {
  type: "appPricePoints";
  id: string;
  attributes?: {
    customerPrice?: string;
    proceeds?: string;
  };
  relationships?: {
    priceTier?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "appPriceTiers";
        id: string;
      };
    };
    territory?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "territories";
        id: string;
      };
    };
  };
  links?: ResourceLinks;
}

/**
 * AppPricePointsResponse
 * @deprecated
 */
export interface AppPricePointsResponse {
  data: AppPricePoint[];
  included?: (AppPriceTier | Territory)[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/**
 * AppPricePointResponse
 * @deprecated
 */
export interface AppPricePointResponse {
  data: AppPricePoint;
  included?: (AppPriceTier | Territory)[];
  links: DocumentLinks;
}

/** AppPriceSchedule */
export interface AppPriceSchedule {
  type: "appPriceSchedules";
  id: string;
  relationships?: {
    app?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "apps";
        id: string;
      };
    };
    baseTerritory?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "territories";
        id: string;
      };
    };
    manualPrices?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "appPrices";
        id: string;
      }[];
    };
    automaticPrices?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "appPrices";
        id: string;
      }[];
    };
  };
  links?: ResourceLinks;
}

/** AppPriceScheduleResponse */
export interface AppPriceScheduleResponse {
  data: AppPriceSchedule;
  included?: (App | Territory | AppPriceV2)[];
  links: DocumentLinks;
}

/** AppPriceScheduleCreateRequest */
export interface AppPriceScheduleCreateRequest {
  data: {
    type: "appPriceSchedules";
    relationships: {
      app: {
        data: {
          type: "apps";
          id: string;
        };
      };
      baseTerritory: {
        data: {
          type: "territories";
          id: string;
        };
      };
      manualPrices: {
        data: {
          type: "appPrices";
          id: string;
        }[];
      };
    };
  };
  included?: (AppPriceV2InlineCreate | TerritoryInlineCreate)[];
}

/**
 * AppPriceTier
 * @deprecated
 */
export interface AppPriceTier {
  type: "appPriceTiers";
  id: string;
  relationships?: {
    /** @deprecated */
    pricePoints?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "appPricePoints";
        id: string;
      }[];
    };
  };
  links?: ResourceLinks;
}

/**
 * AppPriceTiersResponse
 * @deprecated
 */
export interface AppPriceTiersResponse {
  data: AppPriceTier[];
  included?: AppPricePoint[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/**
 * AppPriceTierResponse
 * @deprecated
 */
export interface AppPriceTierResponse {
  data: AppPriceTier;
  included?: AppPricePoint[];
  links: DocumentLinks;
}

/** AppPriceV2 */
export interface AppPriceV2 {
  type: "appPrices";
  id: string;
  attributes?: {
    manual?: boolean;
    /** @format date */
    startDate?: string;
    /** @format date */
    endDate?: string;
  };
  relationships?: {
    appPricePoint?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "appPricePoints";
        id: string;
      };
    };
    territory?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "territories";
        id: string;
      };
    };
  };
  links?: ResourceLinks;
}

export interface AppPriceV2InlineCreate {
  type: "appPrices";
  id?: string;
}

/** AppPricesV2Response */
export interface AppPricesV2Response {
  data: AppPriceV2[];
  included?: (AppPricePointV3 | Territory)[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/**
 * AppPrice
 * @deprecated
 */
export interface AppPrice {
  type: "appPrices";
  id: string;
  relationships?: {
    app?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "apps";
        id: string;
      };
    };
    priceTier?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "appPriceTiers";
        id: string;
      };
    };
  };
  links?: ResourceLinks;
}

export interface AppPriceInlineCreate {
  type: "appPrices";
  id?: string;
}

/**
 * AppPricesResponse
 * @deprecated
 */
export interface AppPricesResponse {
  data: AppPrice[];
  included?: (App | AppPriceTier)[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/**
 * AppPriceResponse
 * @deprecated
 */
export interface AppPriceResponse {
  data: AppPrice;
  included?: (App | AppPriceTier)[];
  links: DocumentLinks;
}

/** AppScreenshotSet */
export interface AppScreenshotSet {
  type: "appScreenshotSets";
  id: string;
  attributes?: {
    screenshotDisplayType?: ScreenshotDisplayType;
  };
  relationships?: {
    appStoreVersionLocalization?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "appStoreVersionLocalizations";
        id: string;
      };
    };
    appCustomProductPageLocalization?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "appCustomProductPageLocalizations";
        id: string;
      };
    };
    appStoreVersionExperimentTreatmentLocalization?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "appStoreVersionExperimentTreatmentLocalizations";
        id: string;
      };
    };
    appScreenshots?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "appScreenshots";
        id: string;
      }[];
    };
  };
  links?: ResourceLinks;
}

/** AppScreenshotSetsResponse */
export interface AppScreenshotSetsResponse {
  data: AppScreenshotSet[];
  included?: (
    | AppStoreVersionLocalization
    | AppCustomProductPageLocalization
    | AppStoreVersionExperimentTreatmentLocalization
    | AppScreenshot
  )[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** AppScreenshotSetResponse */
export interface AppScreenshotSetResponse {
  data: AppScreenshotSet;
  included?: (
    | AppStoreVersionLocalization
    | AppCustomProductPageLocalization
    | AppStoreVersionExperimentTreatmentLocalization
    | AppScreenshot
  )[];
  links: DocumentLinks;
}

/** AppScreenshotSetCreateRequest */
export interface AppScreenshotSetCreateRequest {
  data: {
    type: "appScreenshotSets";
    attributes: {
      screenshotDisplayType: ScreenshotDisplayType;
    };
    relationships?: {
      appStoreVersionLocalization?: {
        data?: {
          type: "appStoreVersionLocalizations";
          id: string;
        };
      };
      appCustomProductPageLocalization?: {
        data?: {
          type: "appCustomProductPageLocalizations";
          id: string;
        };
      };
      appStoreVersionExperimentTreatmentLocalization?: {
        data?: {
          type: "appStoreVersionExperimentTreatmentLocalizations";
          id: string;
        };
      };
    };
  };
}

/** AppScreenshot */
export interface AppScreenshot {
  type: "appScreenshots";
  id: string;
  attributes?: {
    fileSize?: number;
    fileName?: string;
    sourceFileChecksum?: string;
    imageAsset?: ImageAsset;
    assetToken?: string;
    assetType?: string;
    uploadOperations?: UploadOperation[];
    assetDeliveryState?: AppMediaAssetState;
  };
  relationships?: {
    appScreenshotSet?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "appScreenshotSets";
        id: string;
      };
    };
  };
  links?: ResourceLinks;
}

/** AppScreenshotsResponse */
export interface AppScreenshotsResponse {
  data: AppScreenshot[];
  included?: AppScreenshotSet[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** AppScreenshotResponse */
export interface AppScreenshotResponse {
  data: AppScreenshot;
  included?: AppScreenshotSet[];
  links: DocumentLinks;
}

/** AppScreenshotCreateRequest */
export interface AppScreenshotCreateRequest {
  data: {
    type: "appScreenshots";
    attributes: {
      fileSize: number;
      fileName: string;
    };
    relationships: {
      appScreenshotSet: {
        data: {
          type: "appScreenshotSets";
          id: string;
        };
      };
    };
  };
}

/** AppScreenshotUpdateRequest */
export interface AppScreenshotUpdateRequest {
  data: {
    type: "appScreenshots";
    id: string;
    attributes?: {
      sourceFileChecksum?: string;
      uploaded?: boolean;
    };
  };
}

/** AppStoreReviewAttachment */
export interface AppStoreReviewAttachment {
  type: "appStoreReviewAttachments";
  id: string;
  attributes?: {
    fileSize?: number;
    fileName?: string;
    sourceFileChecksum?: string;
    uploadOperations?: UploadOperation[];
    assetDeliveryState?: AppMediaAssetState;
  };
  relationships?: {
    appStoreReviewDetail?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "appStoreReviewDetails";
        id: string;
      };
    };
  };
  links?: ResourceLinks;
}

/** AppStoreReviewAttachmentsResponse */
export interface AppStoreReviewAttachmentsResponse {
  data: AppStoreReviewAttachment[];
  included?: AppStoreReviewDetail[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** AppStoreReviewAttachmentResponse */
export interface AppStoreReviewAttachmentResponse {
  data: AppStoreReviewAttachment;
  included?: AppStoreReviewDetail[];
  links: DocumentLinks;
}

/** AppStoreReviewAttachmentCreateRequest */
export interface AppStoreReviewAttachmentCreateRequest {
  data: {
    type: "appStoreReviewAttachments";
    attributes: {
      fileSize: number;
      fileName: string;
    };
    relationships: {
      appStoreReviewDetail: {
        data: {
          type: "appStoreReviewDetails";
          id: string;
        };
      };
    };
  };
}

/** AppStoreReviewAttachmentUpdateRequest */
export interface AppStoreReviewAttachmentUpdateRequest {
  data: {
    type: "appStoreReviewAttachments";
    id: string;
    attributes?: {
      sourceFileChecksum?: string;
      uploaded?: boolean;
    };
  };
}

/** AppStoreReviewDetail */
export interface AppStoreReviewDetail {
  type: "appStoreReviewDetails";
  id: string;
  attributes?: {
    contactFirstName?: string;
    contactLastName?: string;
    contactPhone?: string;
    contactEmail?: string;
    demoAccountName?: string;
    demoAccountPassword?: string;
    demoAccountRequired?: boolean;
    notes?: string;
  };
  relationships?: {
    appStoreVersion?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "appStoreVersions";
        id: string;
      };
    };
    appStoreReviewAttachments?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "appStoreReviewAttachments";
        id: string;
      }[];
    };
  };
  links?: ResourceLinks;
}

/** AppStoreReviewDetailResponse */
export interface AppStoreReviewDetailResponse {
  data: AppStoreReviewDetail;
  included?: (AppStoreVersion | AppStoreReviewAttachment)[];
  links: DocumentLinks;
}

/** AppStoreReviewDetailCreateRequest */
export interface AppStoreReviewDetailCreateRequest {
  data: {
    type: "appStoreReviewDetails";
    attributes?: {
      contactFirstName?: string;
      contactLastName?: string;
      contactPhone?: string;
      contactEmail?: string;
      demoAccountName?: string;
      demoAccountPassword?: string;
      demoAccountRequired?: boolean;
      notes?: string;
    };
    relationships: {
      appStoreVersion: {
        data: {
          type: "appStoreVersions";
          id: string;
        };
      };
    };
  };
}

/** AppStoreReviewDetailUpdateRequest */
export interface AppStoreReviewDetailUpdateRequest {
  data: {
    type: "appStoreReviewDetails";
    id: string;
    attributes?: {
      contactFirstName?: string;
      contactLastName?: string;
      contactPhone?: string;
      contactEmail?: string;
      demoAccountName?: string;
      demoAccountPassword?: string;
      demoAccountRequired?: boolean;
      notes?: string;
    };
  };
}

/** AppStoreVersionExperimentTreatmentLocalization */
export interface AppStoreVersionExperimentTreatmentLocalization {
  type: "appStoreVersionExperimentTreatmentLocalizations";
  id: string;
  attributes?: {
    locale?: string;
  };
  relationships?: {
    appStoreVersionExperimentTreatment?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "appStoreVersionExperimentTreatments";
        id: string;
      };
    };
    appScreenshotSets?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "appScreenshotSets";
        id: string;
      }[];
    };
    appPreviewSets?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "appPreviewSets";
        id: string;
      }[];
    };
  };
  links?: ResourceLinks;
}

/** AppStoreVersionExperimentTreatmentLocalizationsResponse */
export interface AppStoreVersionExperimentTreatmentLocalizationsResponse {
  data: AppStoreVersionExperimentTreatmentLocalization[];
  included?: (AppStoreVersionExperimentTreatment | AppScreenshotSet | AppPreviewSet)[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** AppStoreVersionExperimentTreatmentLocalizationResponse */
export interface AppStoreVersionExperimentTreatmentLocalizationResponse {
  data: AppStoreVersionExperimentTreatmentLocalization;
  included?: (AppStoreVersionExperimentTreatment | AppScreenshotSet | AppPreviewSet)[];
  links: DocumentLinks;
}

/** AppStoreVersionExperimentTreatmentLocalizationCreateRequest */
export interface AppStoreVersionExperimentTreatmentLocalizationCreateRequest {
  data: {
    type: "appStoreVersionExperimentTreatmentLocalizations";
    attributes: {
      locale: string;
    };
    relationships: {
      appStoreVersionExperimentTreatment: {
        data: {
          type: "appStoreVersionExperimentTreatments";
          id: string;
        };
      };
    };
  };
}

/** AppStoreVersionExperimentTreatment */
export interface AppStoreVersionExperimentTreatment {
  type: "appStoreVersionExperimentTreatments";
  id: string;
  attributes?: {
    name?: string;
    appIcon?: ImageAsset;
    appIconName?: string;
    /** @format date-time */
    promotedDate?: string;
  };
  relationships?: {
    appStoreVersionExperiment?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "appStoreVersionExperiments";
        id: string;
      };
    };
    appStoreVersionExperimentV2?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "appStoreVersionExperiments";
        id: string;
      };
    };
    appStoreVersionExperimentTreatmentLocalizations?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "appStoreVersionExperimentTreatmentLocalizations";
        id: string;
      }[];
    };
  };
  links?: ResourceLinks;
}

/** AppStoreVersionExperimentTreatmentsResponse */
export interface AppStoreVersionExperimentTreatmentsResponse {
  data: AppStoreVersionExperimentTreatment[];
  included?: (
    | AppStoreVersionExperiment
    | AppStoreVersionExperimentV2
    | AppStoreVersionExperimentTreatmentLocalization
  )[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** AppStoreVersionExperimentTreatmentResponse */
export interface AppStoreVersionExperimentTreatmentResponse {
  data: AppStoreVersionExperimentTreatment;
  included?: (
    | AppStoreVersionExperiment
    | AppStoreVersionExperimentV2
    | AppStoreVersionExperimentTreatmentLocalization
  )[];
  links: DocumentLinks;
}

/** AppStoreVersionExperimentTreatmentCreateRequest */
export interface AppStoreVersionExperimentTreatmentCreateRequest {
  data: {
    type: "appStoreVersionExperimentTreatments";
    attributes: {
      name: string;
      appIconName?: string;
    };
    relationships: {
      appStoreVersionExperiment: {
        data: {
          type: "appStoreVersionExperiments";
          id: string;
        };
      };
      appStoreVersionExperimentV2?: {
        data?: {
          type: "appStoreVersionExperiments";
          id: string;
        };
      };
    };
  };
}

/** AppStoreVersionExperimentTreatmentUpdateRequest */
export interface AppStoreVersionExperimentTreatmentUpdateRequest {
  data: {
    type: "appStoreVersionExperimentTreatments";
    id: string;
    attributes?: {
      name?: string;
      appIconName?: string;
    };
  };
}

/** AppStoreVersionExperimentV2 */
export interface AppStoreVersionExperimentV2 {
  type: "appStoreVersionExperiments";
  id: string;
  attributes?: {
    name?: string;
    platform?: Platform;
    trafficProportion?: number;
    state?:
      | "PREPARE_FOR_SUBMISSION"
      | "READY_FOR_REVIEW"
      | "WAITING_FOR_REVIEW"
      | "IN_REVIEW"
      | "ACCEPTED"
      | "APPROVED"
      | "REJECTED"
      | "COMPLETED"
      | "STOPPED";
    reviewRequired?: boolean;
    /** @format date-time */
    startDate?: string;
    /** @format date-time */
    endDate?: string;
  };
  relationships?: {
    app?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "apps";
        id: string;
      };
    };
    latestControlVersion?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "appStoreVersions";
        id: string;
      };
    };
    controlVersions?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "appStoreVersions";
        id: string;
      }[];
    };
    appStoreVersionExperimentTreatments?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "appStoreVersionExperimentTreatments";
        id: string;
      }[];
    };
  };
  links?: ResourceLinks;
}

/** AppStoreVersionExperimentsV2Response */
export interface AppStoreVersionExperimentsV2Response {
  data: AppStoreVersionExperimentV2[];
  included?: (App | AppStoreVersion | AppStoreVersionExperimentTreatment)[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** AppStoreVersionExperimentV2Response */
export interface AppStoreVersionExperimentV2Response {
  data: AppStoreVersionExperimentV2;
  included?: (App | AppStoreVersion | AppStoreVersionExperimentTreatment)[];
  links: DocumentLinks;
}

/** AppStoreVersionExperimentV2CreateRequest */
export interface AppStoreVersionExperimentV2CreateRequest {
  data: {
    type: "appStoreVersionExperiments";
    attributes: {
      name: string;
      platform: Platform;
      trafficProportion: number;
    };
    relationships: {
      app: {
        data: {
          type: "apps";
          id: string;
        };
      };
    };
  };
}

/** AppStoreVersionExperimentV2UpdateRequest */
export interface AppStoreVersionExperimentV2UpdateRequest {
  data: {
    type: "appStoreVersionExperiments";
    id: string;
    attributes?: {
      name?: string;
      trafficProportion?: number;
      started?: boolean;
    };
  };
}

/**
 * AppStoreVersionExperiment
 * @deprecated
 */
export interface AppStoreVersionExperiment {
  type: "appStoreVersionExperiments";
  id: string;
  attributes?: {
    name?: string;
    trafficProportion?: number;
    state?:
      | "PREPARE_FOR_SUBMISSION"
      | "READY_FOR_REVIEW"
      | "WAITING_FOR_REVIEW"
      | "IN_REVIEW"
      | "ACCEPTED"
      | "APPROVED"
      | "REJECTED"
      | "COMPLETED"
      | "STOPPED";
    reviewRequired?: boolean;
    /** @format date-time */
    startDate?: string;
    /** @format date-time */
    endDate?: string;
  };
  relationships?: {
    appStoreVersion?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "appStoreVersions";
        id: string;
      };
    };
    appStoreVersionExperimentTreatments?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "appStoreVersionExperimentTreatments";
        id: string;
      }[];
    };
  };
  links?: ResourceLinks;
}

/**
 * AppStoreVersionExperimentsResponse
 * @deprecated
 */
export interface AppStoreVersionExperimentsResponse {
  data: AppStoreVersionExperiment[];
  included?: (AppStoreVersion | AppStoreVersionExperimentTreatment)[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/**
 * AppStoreVersionExperimentResponse
 * @deprecated
 */
export interface AppStoreVersionExperimentResponse {
  data: AppStoreVersionExperiment;
  included?: (AppStoreVersion | AppStoreVersionExperimentTreatment)[];
  links: DocumentLinks;
}

/**
 * AppStoreVersionExperimentCreateRequest
 * @deprecated
 */
export interface AppStoreVersionExperimentCreateRequest {
  data: {
    type: "appStoreVersionExperiments";
    attributes: {
      name: string;
      trafficProportion: number;
    };
    relationships: {
      appStoreVersion: {
        data: {
          type: "appStoreVersions";
          id: string;
        };
      };
    };
  };
}

/**
 * AppStoreVersionExperimentUpdateRequest
 * @deprecated
 */
export interface AppStoreVersionExperimentUpdateRequest {
  data: {
    type: "appStoreVersionExperiments";
    id: string;
    attributes?: {
      name?: string;
      trafficProportion?: number;
      started?: boolean;
    };
  };
}

/** AppStoreVersionLocalization */
export interface AppStoreVersionLocalization {
  type: "appStoreVersionLocalizations";
  id: string;
  attributes?: {
    description?: string;
    locale?: string;
    keywords?: string;
    /** @format uri */
    marketingUrl?: string;
    promotionalText?: string;
    /** @format uri */
    supportUrl?: string;
    whatsNew?: string;
  };
  relationships?: {
    appStoreVersion?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "appStoreVersions";
        id: string;
      };
    };
    appScreenshotSets?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "appScreenshotSets";
        id: string;
      }[];
    };
    appPreviewSets?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "appPreviewSets";
        id: string;
      }[];
    };
  };
  links?: ResourceLinks;
}

/** AppStoreVersionLocalizationsResponse */
export interface AppStoreVersionLocalizationsResponse {
  data: AppStoreVersionLocalization[];
  included?: (AppStoreVersion | AppScreenshotSet | AppPreviewSet)[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** AppStoreVersionLocalizationResponse */
export interface AppStoreVersionLocalizationResponse {
  data: AppStoreVersionLocalization;
  included?: (AppStoreVersion | AppScreenshotSet | AppPreviewSet)[];
  links: DocumentLinks;
}

/** AppStoreVersionLocalizationCreateRequest */
export interface AppStoreVersionLocalizationCreateRequest {
  data: {
    type: "appStoreVersionLocalizations";
    attributes: {
      description?: string;
      locale: string;
      keywords?: string;
      /** @format uri */
      marketingUrl?: string;
      promotionalText?: string;
      /** @format uri */
      supportUrl?: string;
      whatsNew?: string;
    };
    relationships: {
      appStoreVersion: {
        data: {
          type: "appStoreVersions";
          id: string;
        };
      };
    };
  };
}

/** AppStoreVersionLocalizationUpdateRequest */
export interface AppStoreVersionLocalizationUpdateRequest {
  data: {
    type: "appStoreVersionLocalizations";
    id: string;
    attributes?: {
      description?: string;
      keywords?: string;
      /** @format uri */
      marketingUrl?: string;
      promotionalText?: string;
      /** @format uri */
      supportUrl?: string;
      whatsNew?: string;
    };
  };
}

/** AppStoreVersionPhasedRelease */
export interface AppStoreVersionPhasedRelease {
  type: "appStoreVersionPhasedReleases";
  id: string;
  attributes?: {
    phasedReleaseState?: PhasedReleaseState;
    /** @format date-time */
    startDate?: string;
    totalPauseDuration?: number;
    currentDayNumber?: number;
  };
  links?: ResourceLinks;
}

/** AppStoreVersionPhasedReleaseResponse */
export interface AppStoreVersionPhasedReleaseResponse {
  data: AppStoreVersionPhasedRelease;
  links: DocumentLinks;
}

/** AppStoreVersionPhasedReleaseCreateRequest */
export interface AppStoreVersionPhasedReleaseCreateRequest {
  data: {
    type: "appStoreVersionPhasedReleases";
    attributes?: {
      phasedReleaseState?: PhasedReleaseState;
    };
    relationships: {
      appStoreVersion: {
        data: {
          type: "appStoreVersions";
          id: string;
        };
      };
    };
  };
}

/** AppStoreVersionPhasedReleaseUpdateRequest */
export interface AppStoreVersionPhasedReleaseUpdateRequest {
  data: {
    type: "appStoreVersionPhasedReleases";
    id: string;
    attributes?: {
      phasedReleaseState?: PhasedReleaseState;
    };
  };
}

/** AppStoreVersionPromotion */
export interface AppStoreVersionPromotion {
  type: "appStoreVersionPromotions";
  id: string;
  links?: ResourceLinks;
}

/** AppStoreVersionPromotionResponse */
export interface AppStoreVersionPromotionResponse {
  data: AppStoreVersionPromotion;
  links: DocumentLinks;
}

/** AppStoreVersionPromotionCreateRequest */
export interface AppStoreVersionPromotionCreateRequest {
  data: {
    type: "appStoreVersionPromotions";
    relationships: {
      appStoreVersion: {
        data: {
          type: "appStoreVersions";
          id: string;
        };
      };
      appStoreVersionExperimentTreatment: {
        data: {
          type: "appStoreVersionExperimentTreatments";
          id: string;
        };
      };
    };
  };
}

/** AppStoreVersionReleaseRequest */
export interface AppStoreVersionReleaseRequest {
  type: "appStoreVersionReleaseRequests";
  id: string;
  links?: ResourceLinks;
}

/** AppStoreVersionReleaseRequestResponse */
export interface AppStoreVersionReleaseRequestResponse {
  data: AppStoreVersionReleaseRequest;
  links: DocumentLinks;
}

/** AppStoreVersionReleaseRequestCreateRequest */
export interface AppStoreVersionReleaseRequestCreateRequest {
  data: {
    type: "appStoreVersionReleaseRequests";
    relationships: {
      appStoreVersion: {
        data: {
          type: "appStoreVersions";
          id: string;
        };
      };
    };
  };
}

/**
 * AppStoreVersionSubmission
 * @deprecated
 */
export interface AppStoreVersionSubmission {
  type: "appStoreVersionSubmissions";
  id: string;
  relationships?: {
    appStoreVersion?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "appStoreVersions";
        id: string;
      };
    };
  };
  links?: ResourceLinks;
}

/**
 * AppStoreVersionSubmissionResponse
 * @deprecated
 */
export interface AppStoreVersionSubmissionResponse {
  data: AppStoreVersionSubmission;
  included?: AppStoreVersion[];
  links: DocumentLinks;
}

/**
 * AppStoreVersionSubmissionCreateRequest
 * @deprecated
 */
export interface AppStoreVersionSubmissionCreateRequest {
  data: {
    type: "appStoreVersionSubmissions";
    relationships: {
      appStoreVersion: {
        data: {
          type: "appStoreVersions";
          id: string;
        };
      };
    };
  };
}

/** AppStoreVersion */
export interface AppStoreVersion {
  type: "appStoreVersions";
  id: string;
  attributes?: {
    platform?: Platform;
    versionString?: string;
    /** @deprecated */
    appStoreState?: AppStoreVersionState;
    appVersionState?: AppVersionState;
    copyright?: string;
    reviewType?: "APP_STORE" | "NOTARIZATION";
    releaseType?: "MANUAL" | "AFTER_APPROVAL" | "SCHEDULED";
    /** @format date-time */
    earliestReleaseDate?: string;
    downloadable?: boolean;
    /** @format date-time */
    createdDate?: string;
  };
  relationships?: {
    app?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "apps";
        id: string;
      };
    };
    /** @deprecated */
    ageRatingDeclaration?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "ageRatingDeclarations";
        id: string;
      };
    };
    appStoreVersionLocalizations?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "appStoreVersionLocalizations";
        id: string;
      }[];
    };
    build?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "builds";
        id: string;
      };
    };
    appStoreVersionPhasedRelease?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "appStoreVersionPhasedReleases";
        id: string;
      };
    };
    routingAppCoverage?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "routingAppCoverages";
        id: string;
      };
    };
    appStoreReviewDetail?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "appStoreReviewDetails";
        id: string;
      };
    };
    appStoreVersionSubmission?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "appStoreVersionSubmissions";
        id: string;
      };
    };
    appClipDefaultExperience?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "appClipDefaultExperiences";
        id: string;
      };
    };
    appStoreVersionExperiments?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "appStoreVersionExperiments";
        id: string;
      }[];
    };
    appStoreVersionExperimentsV2?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "appStoreVersionExperiments";
        id: string;
      }[];
    };
    alternativeDistributionPackage?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "alternativeDistributionPackages";
        id: string;
      };
    };
  };
  links?: ResourceLinks;
}

/** AppStoreVersionsResponse */
export interface AppStoreVersionsResponse {
  data: AppStoreVersion[];
  included?: (
    | App
    | AgeRatingDeclaration
    | AppStoreVersionLocalization
    | Build
    | AppStoreVersionPhasedRelease
    | RoutingAppCoverage
    | AppStoreReviewDetail
    | AppStoreVersionSubmission
    | AppClipDefaultExperience
    | AppStoreVersionExperiment
    | AppStoreVersionExperimentV2
    | AlternativeDistributionPackage
  )[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** AppStoreVersionResponse */
export interface AppStoreVersionResponse {
  data: AppStoreVersion;
  included?: (
    | App
    | AgeRatingDeclaration
    | AppStoreVersionLocalization
    | Build
    | AppStoreVersionPhasedRelease
    | RoutingAppCoverage
    | AppStoreReviewDetail
    | AppStoreVersionSubmission
    | AppClipDefaultExperience
    | AppStoreVersionExperiment
    | AppStoreVersionExperimentV2
    | AlternativeDistributionPackage
  )[];
  links: DocumentLinks;
}

/** AppStoreVersionCreateRequest */
export interface AppStoreVersionCreateRequest {
  data: {
    type: "appStoreVersions";
    attributes: {
      platform: Platform;
      versionString: string;
      copyright?: string;
      reviewType?: "APP_STORE" | "NOTARIZATION";
      releaseType?: "MANUAL" | "AFTER_APPROVAL" | "SCHEDULED";
      /** @format date-time */
      earliestReleaseDate?: string;
    };
    relationships: {
      app: {
        data: {
          type: "apps";
          id: string;
        };
      };
      appStoreVersionLocalizations?: {
        data?: {
          type: "appStoreVersionLocalizations";
          id: string;
        }[];
      };
      build?: {
        data?: {
          type: "builds";
          id: string;
        };
      };
    };
  };
}

/** AppStoreVersionUpdateRequest */
export interface AppStoreVersionUpdateRequest {
  data: {
    type: "appStoreVersions";
    id: string;
    attributes?: {
      versionString?: string;
      copyright?: string;
      reviewType?: "APP_STORE" | "NOTARIZATION";
      releaseType?: "MANUAL" | "AFTER_APPROVAL" | "SCHEDULED";
      /** @format date-time */
      earliestReleaseDate?: string;
      downloadable?: boolean;
    };
    relationships?: {
      build?: {
        data?: {
          type: "builds";
          id: string;
        };
      };
      appClipDefaultExperience?: {
        data?: {
          type: "appClipDefaultExperiences";
          id: string;
        };
      };
    };
  };
}

/** App */
export interface App {
  type: "apps";
  id: string;
  attributes?: {
    name?: string;
    bundleId?: string;
    sku?: string;
    primaryLocale?: string;
    isOrEverWasMadeForKids?: boolean;
    /** @format uri */
    subscriptionStatusUrl?: string;
    subscriptionStatusUrlVersion?: SubscriptionStatusUrlVersion;
    /** @format uri */
    subscriptionStatusUrlForSandbox?: string;
    subscriptionStatusUrlVersionForSandbox?: SubscriptionStatusUrlVersion;
    /** @deprecated */
    availableInNewTerritories?: boolean;
    contentRightsDeclaration?: "DOES_NOT_USE_THIRD_PARTY_CONTENT" | "USES_THIRD_PARTY_CONTENT";
  };
  relationships?: {
    appEncryptionDeclarations?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "appEncryptionDeclarations";
        id: string;
      }[];
    };
    ciProduct?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "ciProducts";
        id: string;
      };
    };
    betaGroups?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "betaGroups";
        id: string;
      }[];
    };
    appStoreVersions?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "appStoreVersions";
        id: string;
      }[];
    };
    preReleaseVersions?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "preReleaseVersions";
        id: string;
      }[];
    };
    betaAppLocalizations?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "betaAppLocalizations";
        id: string;
      }[];
    };
    builds?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "builds";
        id: string;
      }[];
    };
    betaLicenseAgreement?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "betaLicenseAgreements";
        id: string;
      };
    };
    betaAppReviewDetail?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "betaAppReviewDetails";
        id: string;
      };
    };
    appInfos?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "appInfos";
        id: string;
      }[];
    };
    appClips?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "appClips";
        id: string;
      }[];
    };
    endUserLicenseAgreement?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "endUserLicenseAgreements";
        id: string;
      };
    };
    preOrder?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "appPreOrders";
        id: string;
      };
    };
    /** @deprecated */
    prices?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "appPrices";
        id: string;
      }[];
    };
    /** @deprecated */
    availableTerritories?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "territories";
        id: string;
      }[];
    };
    /** @deprecated */
    inAppPurchases?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "inAppPurchases";
        id: string;
      }[];
    };
    subscriptionGroups?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "subscriptionGroups";
        id: string;
      }[];
    };
    gameCenterEnabledVersions?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "gameCenterEnabledVersions";
        id: string;
      }[];
    };
    appCustomProductPages?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "appCustomProductPages";
        id: string;
      }[];
    };
    inAppPurchasesV2?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "inAppPurchases";
        id: string;
      }[];
    };
    promotedPurchases?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "promotedPurchases";
        id: string;
      }[];
    };
    appEvents?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "appEvents";
        id: string;
      }[];
    };
    reviewSubmissions?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "reviewSubmissions";
        id: string;
      }[];
    };
    subscriptionGracePeriod?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "subscriptionGracePeriods";
        id: string;
      };
    };
    gameCenterDetail?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "gameCenterDetails";
        id: string;
      };
    };
    appStoreVersionExperimentsV2?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "appStoreVersionExperiments";
        id: string;
      }[];
    };
  };
  links?: ResourceLinks;
}

/** AppsResponse */
export interface AppsResponse {
  data: App[];
  included?: (
    | AppEncryptionDeclaration
    | CiProduct
    | BetaGroup
    | AppStoreVersion
    | PrereleaseVersion
    | BetaAppLocalization
    | Build
    | BetaLicenseAgreement
    | BetaAppReviewDetail
    | AppInfo
    | AppClip
    | EndUserLicenseAgreement
    | AppPreOrder
    | AppPrice
    | Territory
    | InAppPurchase
    | SubscriptionGroup
    | GameCenterEnabledVersion
    | AppCustomProductPage
    | InAppPurchaseV2
    | PromotedPurchase
    | AppEvent
    | ReviewSubmission
    | SubscriptionGracePeriod
    | GameCenterDetail
    | AppStoreVersionExperimentV2
  )[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** AppResponse */
export interface AppResponse {
  data: App;
  included?: (
    | AppEncryptionDeclaration
    | CiProduct
    | BetaGroup
    | AppStoreVersion
    | PrereleaseVersion
    | BetaAppLocalization
    | Build
    | BetaLicenseAgreement
    | BetaAppReviewDetail
    | AppInfo
    | AppClip
    | EndUserLicenseAgreement
    | AppPreOrder
    | AppPrice
    | Territory
    | InAppPurchase
    | SubscriptionGroup
    | GameCenterEnabledVersion
    | AppCustomProductPage
    | InAppPurchaseV2
    | PromotedPurchase
    | AppEvent
    | ReviewSubmission
    | SubscriptionGracePeriod
    | GameCenterDetail
    | AppStoreVersionExperimentV2
  )[];
  links: DocumentLinks;
}

/** AppUpdateRequest */
export interface AppUpdateRequest {
  data: {
    type: "apps";
    id: string;
    attributes?: {
      bundleId?: string;
      primaryLocale?: string;
      /** @format uri */
      subscriptionStatusUrl?: string;
      subscriptionStatusUrlVersion?: SubscriptionStatusUrlVersion;
      /** @format uri */
      subscriptionStatusUrlForSandbox?: string;
      subscriptionStatusUrlVersionForSandbox?: SubscriptionStatusUrlVersion;
      /** @deprecated */
      availableInNewTerritories?: boolean;
      contentRightsDeclaration?: "DOES_NOT_USE_THIRD_PARTY_CONTENT" | "USES_THIRD_PARTY_CONTENT";
    };
    relationships?: {
      /** @deprecated */
      prices?: {
        data?: {
          type: "appPrices";
          id: string;
        }[];
      };
      /** @deprecated */
      availableTerritories?: {
        data?: {
          type: "territories";
          id: string;
        }[];
      };
    };
  };
  included?: AppPriceInlineCreate[];
}

/** BetaAppClipInvocationLocalization */
export interface BetaAppClipInvocationLocalization {
  type: "betaAppClipInvocationLocalizations";
  id: string;
  attributes?: {
    title?: string;
    locale?: string;
  };
  links?: ResourceLinks;
}

export interface BetaAppClipInvocationLocalizationInlineCreate {
  type: "betaAppClipInvocationLocalizations";
  id?: string;
  attributes: {
    title: string;
    locale: string;
  };
  relationships?: {
    betaAppClipInvocation?: {
      data?: {
        type: "betaAppClipInvocations";
        id: string;
      };
    };
  };
}

/** BetaAppClipInvocationLocalizationResponse */
export interface BetaAppClipInvocationLocalizationResponse {
  data: BetaAppClipInvocationLocalization;
  links: DocumentLinks;
}

/** BetaAppClipInvocationLocalizationCreateRequest */
export interface BetaAppClipInvocationLocalizationCreateRequest {
  data: {
    type: "betaAppClipInvocationLocalizations";
    attributes: {
      title: string;
      locale: string;
    };
    relationships: {
      betaAppClipInvocation: {
        data: {
          type: "betaAppClipInvocations";
          id: string;
        };
      };
    };
  };
}

/** BetaAppClipInvocationLocalizationUpdateRequest */
export interface BetaAppClipInvocationLocalizationUpdateRequest {
  data: {
    type: "betaAppClipInvocationLocalizations";
    id: string;
    attributes?: {
      title?: string;
    };
  };
}

/** BetaAppClipInvocation */
export interface BetaAppClipInvocation {
  type: "betaAppClipInvocations";
  id: string;
  attributes?: {
    /** @format uri */
    url?: string;
  };
  relationships?: {
    betaAppClipInvocationLocalizations?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "betaAppClipInvocationLocalizations";
        id: string;
      }[];
    };
  };
  links?: ResourceLinks;
}

/** BetaAppClipInvocationsResponse */
export interface BetaAppClipInvocationsResponse {
  data: BetaAppClipInvocation[];
  included?: BetaAppClipInvocationLocalization[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** BetaAppClipInvocationResponse */
export interface BetaAppClipInvocationResponse {
  data: BetaAppClipInvocation;
  included?: BetaAppClipInvocationLocalization[];
  links: DocumentLinks;
}

/** BetaAppClipInvocationCreateRequest */
export interface BetaAppClipInvocationCreateRequest {
  data: {
    type: "betaAppClipInvocations";
    attributes: {
      /** @format uri */
      url: string;
    };
    relationships: {
      buildBundle: {
        data: {
          type: "buildBundles";
          id: string;
        };
      };
      betaAppClipInvocationLocalizations: {
        data: {
          type: "betaAppClipInvocationLocalizations";
          id: string;
        }[];
      };
    };
  };
  included?: BetaAppClipInvocationLocalizationInlineCreate[];
}

/** BetaAppClipInvocationUpdateRequest */
export interface BetaAppClipInvocationUpdateRequest {
  data: {
    type: "betaAppClipInvocations";
    id: string;
    attributes?: {
      /** @format uri */
      url?: string;
    };
  };
}

/** BetaAppLocalization */
export interface BetaAppLocalization {
  type: "betaAppLocalizations";
  id: string;
  attributes?: {
    feedbackEmail?: string;
    marketingUrl?: string;
    privacyPolicyUrl?: string;
    tvOsPrivacyPolicy?: string;
    description?: string;
    locale?: string;
  };
  relationships?: {
    app?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "apps";
        id: string;
      };
    };
  };
  links?: ResourceLinks;
}

/** BetaAppLocalizationsResponse */
export interface BetaAppLocalizationsResponse {
  data: BetaAppLocalization[];
  included?: App[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** BetaAppLocalizationResponse */
export interface BetaAppLocalizationResponse {
  data: BetaAppLocalization;
  included?: App[];
  links: DocumentLinks;
}

/** BetaAppLocalizationCreateRequest */
export interface BetaAppLocalizationCreateRequest {
  data: {
    type: "betaAppLocalizations";
    attributes: {
      feedbackEmail?: string;
      marketingUrl?: string;
      privacyPolicyUrl?: string;
      tvOsPrivacyPolicy?: string;
      description?: string;
      locale: string;
    };
    relationships: {
      app: {
        data: {
          type: "apps";
          id: string;
        };
      };
    };
  };
}

/** BetaAppLocalizationUpdateRequest */
export interface BetaAppLocalizationUpdateRequest {
  data: {
    type: "betaAppLocalizations";
    id: string;
    attributes?: {
      feedbackEmail?: string;
      marketingUrl?: string;
      privacyPolicyUrl?: string;
      tvOsPrivacyPolicy?: string;
      description?: string;
    };
  };
}

/** BetaAppReviewDetail */
export interface BetaAppReviewDetail {
  type: "betaAppReviewDetails";
  id: string;
  attributes?: {
    contactFirstName?: string;
    contactLastName?: string;
    contactPhone?: string;
    contactEmail?: string;
    demoAccountName?: string;
    demoAccountPassword?: string;
    demoAccountRequired?: boolean;
    notes?: string;
  };
  relationships?: {
    app?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "apps";
        id: string;
      };
    };
  };
  links?: ResourceLinks;
}

/** BetaAppReviewDetailsResponse */
export interface BetaAppReviewDetailsResponse {
  data: BetaAppReviewDetail[];
  included?: App[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** BetaAppReviewDetailResponse */
export interface BetaAppReviewDetailResponse {
  data: BetaAppReviewDetail;
  included?: App[];
  links: DocumentLinks;
}

/** BetaAppReviewDetailUpdateRequest */
export interface BetaAppReviewDetailUpdateRequest {
  data: {
    type: "betaAppReviewDetails";
    id: string;
    attributes?: {
      contactFirstName?: string;
      contactLastName?: string;
      contactPhone?: string;
      contactEmail?: string;
      demoAccountName?: string;
      demoAccountPassword?: string;
      demoAccountRequired?: boolean;
      notes?: string;
    };
  };
}

/** BetaAppReviewSubmission */
export interface BetaAppReviewSubmission {
  type: "betaAppReviewSubmissions";
  id: string;
  attributes?: {
    betaReviewState?: BetaReviewState;
    /** @format date-time */
    submittedDate?: string;
  };
  relationships?: {
    build?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "builds";
        id: string;
      };
    };
  };
  links?: ResourceLinks;
}

/** BetaAppReviewSubmissionsResponse */
export interface BetaAppReviewSubmissionsResponse {
  data: BetaAppReviewSubmission[];
  included?: Build[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** BetaAppReviewSubmissionResponse */
export interface BetaAppReviewSubmissionResponse {
  data: BetaAppReviewSubmission;
  included?: Build[];
  links: DocumentLinks;
}

/** BetaAppReviewSubmissionCreateRequest */
export interface BetaAppReviewSubmissionCreateRequest {
  data: {
    type: "betaAppReviewSubmissions";
    relationships: {
      build: {
        data: {
          type: "builds";
          id: string;
        };
      };
    };
  };
}

/** BetaBuildLocalization */
export interface BetaBuildLocalization {
  type: "betaBuildLocalizations";
  id: string;
  attributes?: {
    whatsNew?: string;
    locale?: string;
  };
  relationships?: {
    build?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "builds";
        id: string;
      };
    };
  };
  links?: ResourceLinks;
}

/** BetaBuildLocalizationsResponse */
export interface BetaBuildLocalizationsResponse {
  data: BetaBuildLocalization[];
  included?: Build[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** BetaBuildLocalizationResponse */
export interface BetaBuildLocalizationResponse {
  data: BetaBuildLocalization;
  included?: Build[];
  links: DocumentLinks;
}

/** BetaBuildLocalizationCreateRequest */
export interface BetaBuildLocalizationCreateRequest {
  data: {
    type: "betaBuildLocalizations";
    attributes: {
      whatsNew?: string;
      locale: string;
    };
    relationships: {
      build: {
        data: {
          type: "builds";
          id: string;
        };
      };
    };
  };
}

/** BetaBuildLocalizationUpdateRequest */
export interface BetaBuildLocalizationUpdateRequest {
  data: {
    type: "betaBuildLocalizations";
    id: string;
    attributes?: {
      whatsNew?: string;
    };
  };
}

/** BetaGroup */
export interface BetaGroup {
  type: "betaGroups";
  id: string;
  attributes?: {
    name?: string;
    /** @format date-time */
    createdDate?: string;
    isInternalGroup?: boolean;
    hasAccessToAllBuilds?: boolean;
    publicLinkEnabled?: boolean;
    publicLinkId?: string;
    publicLinkLimitEnabled?: boolean;
    publicLinkLimit?: number;
    publicLink?: string;
    feedbackEnabled?: boolean;
    iosBuildsAvailableForAppleSiliconMac?: boolean;
  };
  relationships?: {
    app?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "apps";
        id: string;
      };
    };
    builds?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "builds";
        id: string;
      }[];
    };
    betaTesters?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "betaTesters";
        id: string;
      }[];
    };
  };
  links?: ResourceLinks;
}

/** BetaGroupsResponse */
export interface BetaGroupsResponse {
  data: BetaGroup[];
  included?: (App | Build | BetaTester)[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** BetaGroupResponse */
export interface BetaGroupResponse {
  data: BetaGroup;
  included?: (App | Build | BetaTester)[];
  links: DocumentLinks;
}

/** BetaGroupCreateRequest */
export interface BetaGroupCreateRequest {
  data: {
    type: "betaGroups";
    attributes: {
      name: string;
      isInternalGroup?: boolean;
      hasAccessToAllBuilds?: boolean;
      publicLinkEnabled?: boolean;
      publicLinkLimitEnabled?: boolean;
      publicLinkLimit?: number;
      feedbackEnabled?: boolean;
    };
    relationships: {
      app: {
        data: {
          type: "apps";
          id: string;
        };
      };
      builds?: {
        data?: {
          type: "builds";
          id: string;
        }[];
      };
      betaTesters?: {
        data?: {
          type: "betaTesters";
          id: string;
        }[];
      };
    };
  };
}

/** BetaGroupUpdateRequest */
export interface BetaGroupUpdateRequest {
  data: {
    type: "betaGroups";
    id: string;
    attributes?: {
      name?: string;
      publicLinkEnabled?: boolean;
      publicLinkLimitEnabled?: boolean;
      publicLinkLimit?: number;
      feedbackEnabled?: boolean;
      iosBuildsAvailableForAppleSiliconMac?: boolean;
    };
  };
}

/** BetaLicenseAgreement */
export interface BetaLicenseAgreement {
  type: "betaLicenseAgreements";
  id: string;
  attributes?: {
    agreementText?: string;
  };
  relationships?: {
    app?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "apps";
        id: string;
      };
    };
  };
  links?: ResourceLinks;
}

/** BetaLicenseAgreementsResponse */
export interface BetaLicenseAgreementsResponse {
  data: BetaLicenseAgreement[];
  included?: App[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** BetaLicenseAgreementResponse */
export interface BetaLicenseAgreementResponse {
  data: BetaLicenseAgreement;
  included?: App[];
  links: DocumentLinks;
}

/** BetaLicenseAgreementUpdateRequest */
export interface BetaLicenseAgreementUpdateRequest {
  data: {
    type: "betaLicenseAgreements";
    id: string;
    attributes?: {
      agreementText?: string;
    };
  };
}

/** BetaTesterInvitation */
export interface BetaTesterInvitation {
  type: "betaTesterInvitations";
  id: string;
  links?: ResourceLinks;
}

/** BetaTesterInvitationResponse */
export interface BetaTesterInvitationResponse {
  data: BetaTesterInvitation;
  links: DocumentLinks;
}

/** BetaTesterInvitationCreateRequest */
export interface BetaTesterInvitationCreateRequest {
  data: {
    type: "betaTesterInvitations";
    relationships: {
      betaTester: {
        data: {
          type: "betaTesters";
          id: string;
        };
      };
      app: {
        data: {
          type: "apps";
          id: string;
        };
      };
    };
  };
}

/** BetaTester */
export interface BetaTester {
  type: "betaTesters";
  id: string;
  attributes?: {
    firstName?: string;
    lastName?: string;
    /** @format email */
    email?: string;
    inviteType?: BetaInviteType;
  };
  relationships?: {
    apps?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "apps";
        id: string;
      }[];
    };
    betaGroups?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "betaGroups";
        id: string;
      }[];
    };
    builds?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "builds";
        id: string;
      }[];
    };
  };
  links?: ResourceLinks;
}

/** BetaTestersResponse */
export interface BetaTestersResponse {
  data: BetaTester[];
  included?: (App | BetaGroup | Build)[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** BetaTesterResponse */
export interface BetaTesterResponse {
  data: BetaTester;
  included?: (App | BetaGroup | Build)[];
  links: DocumentLinks;
}

/** BetaTesterCreateRequest */
export interface BetaTesterCreateRequest {
  data: {
    type: "betaTesters";
    attributes: {
      firstName?: string;
      lastName?: string;
      /** @format email */
      email: string;
    };
    relationships?: {
      betaGroups?: {
        data?: {
          type: "betaGroups";
          id: string;
        }[];
      };
      builds?: {
        data?: {
          type: "builds";
          id: string;
        }[];
      };
    };
  };
}

/** BuildBetaDetail */
export interface BuildBetaDetail {
  type: "buildBetaDetails";
  id: string;
  attributes?: {
    autoNotifyEnabled?: boolean;
    internalBuildState?: InternalBetaState;
    externalBuildState?: ExternalBetaState;
  };
  relationships?: {
    build?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "builds";
        id: string;
      };
    };
  };
  links?: ResourceLinks;
}

/** BuildBetaDetailsResponse */
export interface BuildBetaDetailsResponse {
  data: BuildBetaDetail[];
  included?: Build[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** BuildBetaDetailResponse */
export interface BuildBetaDetailResponse {
  data: BuildBetaDetail;
  included?: Build[];
  links: DocumentLinks;
}

/** BuildBetaDetailUpdateRequest */
export interface BuildBetaDetailUpdateRequest {
  data: {
    type: "buildBetaDetails";
    id: string;
    attributes?: {
      autoNotifyEnabled?: boolean;
    };
  };
}

/** BuildBetaNotification */
export interface BuildBetaNotification {
  type: "buildBetaNotifications";
  id: string;
  links?: ResourceLinks;
}

/** BuildBetaNotificationResponse */
export interface BuildBetaNotificationResponse {
  data: BuildBetaNotification;
  links: DocumentLinks;
}

/** BuildBetaNotificationCreateRequest */
export interface BuildBetaNotificationCreateRequest {
  data: {
    type: "buildBetaNotifications";
    relationships: {
      build: {
        data: {
          type: "builds";
          id: string;
        };
      };
    };
  };
}

/** BuildBundleFileSize */
export interface BuildBundleFileSize {
  type: "buildBundleFileSizes";
  id: string;
  attributes?: {
    deviceModel?: string;
    osVersion?: string;
    downloadBytes?: number;
    installBytes?: number;
  };
  links?: ResourceLinks;
}

/** BuildBundleFileSizesResponse */
export interface BuildBundleFileSizesResponse {
  data: BuildBundleFileSize[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** BuildBundle */
export interface BuildBundle {
  type: "buildBundles";
  id: string;
  attributes?: {
    bundleId?: string;
    bundleType?: "APP" | "APP_CLIP";
    sdkBuild?: string;
    platformBuild?: string;
    fileName?: string;
    hasSirikit?: boolean;
    hasOnDemandResources?: boolean;
    hasPrerenderedIcon?: boolean;
    usesLocationServices?: boolean;
    isIosBuildMacAppStoreCompatible?: boolean;
    includesSymbols?: boolean;
    /** @format uri */
    dSYMUrl?: string;
    supportedArchitectures?: string[];
    requiredCapabilities?: string[];
    deviceProtocols?: string[];
    locales?: string[];
    entitlements?: Record<string, Record<string, string>>;
  };
  relationships?: {
    appClipDomainCacheStatus?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "appClipDomainStatuses";
        id: string;
      };
    };
    appClipDomainDebugStatus?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "appClipDomainStatuses";
        id: string;
      };
    };
    betaAppClipInvocations?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "betaAppClipInvocations";
        id: string;
      }[];
    };
    buildBundleFileSizes?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "buildBundleFileSizes";
        id: string;
      }[];
    };
  };
  links?: ResourceLinks;
}

/** BuildIcon */
export interface BuildIcon {
  type: "buildIcons";
  id: string;
  attributes?: {
    name?: string;
    iconAsset?: ImageAsset;
    iconType?: IconAssetType;
  };
  links?: ResourceLinks;
}

/** BuildIconsResponse */
export interface BuildIconsResponse {
  data: BuildIcon[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** Build */
export interface Build {
  type: "builds";
  id: string;
  attributes?: {
    version?: string;
    /** @format date-time */
    uploadedDate?: string;
    /** @format date-time */
    expirationDate?: string;
    expired?: boolean;
    minOsVersion?: string;
    lsMinimumSystemVersion?: string;
    computedMinMacOsVersion?: string;
    iconAssetToken?: ImageAsset;
    processingState?: "PROCESSING" | "FAILED" | "INVALID" | "VALID";
    buildAudienceType?: BuildAudienceType;
    usesNonExemptEncryption?: boolean;
  };
  relationships?: {
    preReleaseVersion?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "preReleaseVersions";
        id: string;
      };
    };
    individualTesters?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "betaTesters";
        id: string;
      }[];
    };
    betaGroups?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "betaGroups";
        id: string;
      }[];
    };
    betaBuildLocalizations?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "betaBuildLocalizations";
        id: string;
      }[];
    };
    appEncryptionDeclaration?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "appEncryptionDeclarations";
        id: string;
      };
    };
    betaAppReviewSubmission?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "betaAppReviewSubmissions";
        id: string;
      };
    };
    app?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "apps";
        id: string;
      };
    };
    buildBetaDetail?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "buildBetaDetails";
        id: string;
      };
    };
    appStoreVersion?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "appStoreVersions";
        id: string;
      };
    };
    icons?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "buildIcons";
        id: string;
      }[];
    };
    buildBundles?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "buildBundles";
        id: string;
      }[];
    };
  };
  links?: ResourceLinks;
}

/** BuildsResponse */
export interface BuildsResponse {
  data: Build[];
  included?: (
    | PrereleaseVersion
    | BetaTester
    | BetaGroup
    | BetaBuildLocalization
    | AppEncryptionDeclaration
    | BetaAppReviewSubmission
    | App
    | BuildBetaDetail
    | AppStoreVersion
    | BuildIcon
    | BuildBundle
  )[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** BuildResponse */
export interface BuildResponse {
  data: Build;
  included?: (
    | PrereleaseVersion
    | BetaTester
    | BetaGroup
    | BetaBuildLocalization
    | AppEncryptionDeclaration
    | BetaAppReviewSubmission
    | App
    | BuildBetaDetail
    | AppStoreVersion
    | BuildIcon
    | BuildBundle
  )[];
  links: DocumentLinks;
}

/** BuildUpdateRequest */
export interface BuildUpdateRequest {
  data: {
    type: "builds";
    id: string;
    attributes?: {
      expired?: boolean;
      usesNonExemptEncryption?: boolean;
    };
    relationships?: {
      appEncryptionDeclaration?: {
        data?: {
          type: "appEncryptionDeclarations";
          id: string;
        };
      };
    };
  };
}

/** BundleIdCapability */
export interface BundleIdCapability {
  type: "bundleIdCapabilities";
  id: string;
  attributes?: {
    capabilityType?: CapabilityType;
    settings?: CapabilitySetting[];
  };
  links?: ResourceLinks;
}

/** BundleIdCapabilitiesResponse */
export interface BundleIdCapabilitiesResponse {
  data: BundleIdCapability[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** BundleIdCapabilityResponse */
export interface BundleIdCapabilityResponse {
  data: BundleIdCapability;
  links: DocumentLinks;
}

/** BundleIdCapabilityCreateRequest */
export interface BundleIdCapabilityCreateRequest {
  data: {
    type: "bundleIdCapabilities";
    attributes: {
      capabilityType: CapabilityType;
      settings?: CapabilitySetting[];
    };
    relationships: {
      bundleId: {
        data: {
          type: "bundleIds";
          id: string;
        };
      };
    };
  };
}

/** BundleIdCapabilityUpdateRequest */
export interface BundleIdCapabilityUpdateRequest {
  data: {
    type: "bundleIdCapabilities";
    id: string;
    attributes?: {
      capabilityType?: CapabilityType;
      settings?: CapabilitySetting[];
    };
  };
}

/** BundleId */
export interface BundleId {
  type: "bundleIds";
  id: string;
  attributes?: {
    name?: string;
    platform?: BundleIdPlatform;
    identifier?: string;
    seedId?: string;
  };
  relationships?: {
    profiles?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "profiles";
        id: string;
      }[];
    };
    bundleIdCapabilities?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "bundleIdCapabilities";
        id: string;
      }[];
    };
    app?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "apps";
        id: string;
      };
    };
  };
  links?: ResourceLinks;
}

/** BundleIdsResponse */
export interface BundleIdsResponse {
  data: BundleId[];
  included?: (Profile | BundleIdCapability | App)[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** BundleIdResponse */
export interface BundleIdResponse {
  data: BundleId;
  included?: (Profile | BundleIdCapability | App)[];
  links: DocumentLinks;
}

/** BundleIdCreateRequest */
export interface BundleIdCreateRequest {
  data: {
    type: "bundleIds";
    attributes: {
      name: string;
      platform: BundleIdPlatform;
      identifier: string;
      seedId?: string;
    };
  };
}

/** BundleIdUpdateRequest */
export interface BundleIdUpdateRequest {
  data: {
    type: "bundleIds";
    id: string;
    attributes?: {
      name?: string;
    };
  };
}

/** Certificate */
export interface Certificate {
  type: "certificates";
  id: string;
  attributes?: {
    name?: string;
    certificateType?: CertificateType;
    displayName?: string;
    serialNumber?: string;
    platform?: BundleIdPlatform;
    /** @format date-time */
    expirationDate?: string;
    certificateContent?: string;
  };
  links?: ResourceLinks;
}

/** CertificatesResponse */
export interface CertificatesResponse {
  data: Certificate[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** CertificateResponse */
export interface CertificateResponse {
  data: Certificate;
  links: DocumentLinks;
}

/** CertificateCreateRequest */
export interface CertificateCreateRequest {
  data: {
    type: "certificates";
    attributes: {
      csrContent: string;
      certificateType: CertificateType;
    };
  };
}

/** CiArtifact */
export interface CiArtifact {
  type: "ciArtifacts";
  id: string;
  attributes?: {
    fileType?:
      | "ARCHIVE"
      | "ARCHIVE_EXPORT"
      | "LOG_BUNDLE"
      | "RESULT_BUNDLE"
      | "TEST_PRODUCTS"
      | "XCODEBUILD_PRODUCTS"
      | "STAPLED_NOTARIZED_ARCHIVE";
    fileName?: string;
    fileSize?: number;
    /** @format uri */
    downloadUrl?: string;
  };
  links?: ResourceLinks;
}

/** CiArtifactsResponse */
export interface CiArtifactsResponse {
  data: CiArtifact[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** CiArtifactResponse */
export interface CiArtifactResponse {
  data: CiArtifact;
  links: DocumentLinks;
}

/** CiBuildAction */
export interface CiBuildAction {
  type: "ciBuildActions";
  id: string;
  attributes?: {
    name?: string;
    actionType?: CiActionType;
    /** @format date-time */
    startedDate?: string;
    /** @format date-time */
    finishedDate?: string;
    issueCounts?: CiIssueCounts;
    executionProgress?: CiExecutionProgress;
    completionStatus?: CiCompletionStatus;
    isRequiredToPass?: boolean;
  };
  relationships?: {
    buildRun?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "ciBuildRuns";
        id: string;
      };
    };
  };
  links?: ResourceLinks;
}

/** CiBuildActionsResponse */
export interface CiBuildActionsResponse {
  data: CiBuildAction[];
  included?: CiBuildRun[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** CiBuildActionResponse */
export interface CiBuildActionResponse {
  data: CiBuildAction;
  included?: CiBuildRun[];
  links: DocumentLinks;
}

/** CiBuildRun */
export interface CiBuildRun {
  type: "ciBuildRuns";
  id: string;
  attributes?: {
    number?: number;
    /** @format date-time */
    createdDate?: string;
    /** @format date-time */
    startedDate?: string;
    /** @format date-time */
    finishedDate?: string;
    sourceCommit?: {
      commitSha?: string;
      message?: string;
      author?: CiGitUser;
      committer?: CiGitUser;
      /** @format uri */
      webUrl?: string;
    };
    destinationCommit?: {
      commitSha?: string;
      message?: string;
      author?: CiGitUser;
      committer?: CiGitUser;
      /** @format uri */
      webUrl?: string;
    };
    isPullRequestBuild?: boolean;
    issueCounts?: CiIssueCounts;
    executionProgress?: CiExecutionProgress;
    completionStatus?: CiCompletionStatus;
    startReason?:
      | "GIT_REF_CHANGE"
      | "MANUAL"
      | "MANUAL_REBUILD"
      | "PULL_REQUEST_OPEN"
      | "PULL_REQUEST_UPDATE"
      | "SCHEDULE";
    cancelReason?: "AUTOMATICALLY_BY_NEWER_BUILD" | "MANUALLY_BY_USER";
  };
  relationships?: {
    builds?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "builds";
        id: string;
      }[];
    };
    workflow?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "ciWorkflows";
        id: string;
      };
    };
    product?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "ciProducts";
        id: string;
      };
    };
    sourceBranchOrTag?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "scmGitReferences";
        id: string;
      };
    };
    destinationBranch?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "scmGitReferences";
        id: string;
      };
    };
    pullRequest?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "scmPullRequests";
        id: string;
      };
    };
  };
  links?: ResourceLinks;
}

/** CiBuildRunsResponse */
export interface CiBuildRunsResponse {
  data: CiBuildRun[];
  included?: (Build | CiWorkflow | CiProduct | ScmGitReference | ScmPullRequest)[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** CiBuildRunResponse */
export interface CiBuildRunResponse {
  data: CiBuildRun;
  included?: (Build | CiWorkflow | CiProduct | ScmGitReference | ScmPullRequest)[];
  links: DocumentLinks;
}

/** CiBuildRunCreateRequest */
export interface CiBuildRunCreateRequest {
  data: {
    type: "ciBuildRuns";
    attributes?: {
      clean?: boolean;
    };
    relationships?: {
      buildRun?: {
        data?: {
          type: "ciBuildRuns";
          id: string;
        };
      };
      workflow?: {
        data?: {
          type: "ciWorkflows";
          id: string;
        };
      };
      sourceBranchOrTag?: {
        data?: {
          type: "scmGitReferences";
          id: string;
        };
      };
      pullRequest?: {
        data?: {
          type: "scmPullRequests";
          id: string;
        };
      };
    };
  };
}

/** CiIssue */
export interface CiIssue {
  type: "ciIssues";
  id: string;
  attributes?: {
    issueType?: "ANALYZER_WARNING" | "ERROR" | "TEST_FAILURE" | "WARNING";
    message?: string;
    fileSource?: FileLocation;
    category?: string;
  };
  links?: ResourceLinks;
}

/** CiIssuesResponse */
export interface CiIssuesResponse {
  data: CiIssue[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** CiIssueResponse */
export interface CiIssueResponse {
  data: CiIssue;
  links: DocumentLinks;
}

/** CiMacOsVersion */
export interface CiMacOsVersion {
  type: "ciMacOsVersions";
  id: string;
  attributes?: {
    version?: string;
    name?: string;
  };
  relationships?: {
    xcodeVersions?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "ciXcodeVersions";
        id: string;
      }[];
    };
  };
  links?: ResourceLinks;
}

/** CiMacOsVersionsResponse */
export interface CiMacOsVersionsResponse {
  data: CiMacOsVersion[];
  included?: CiXcodeVersion[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** CiMacOsVersionResponse */
export interface CiMacOsVersionResponse {
  data: CiMacOsVersion;
  included?: CiXcodeVersion[];
  links: DocumentLinks;
}

/** CiProduct */
export interface CiProduct {
  type: "ciProducts";
  id: string;
  attributes?: {
    name?: string;
    /** @format date-time */
    createdDate?: string;
    productType?: "APP" | "FRAMEWORK";
  };
  relationships?: {
    app?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "apps";
        id: string;
      };
    };
    bundleId?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "bundleIds";
        id: string;
      };
    };
    primaryRepositories?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "scmRepositories";
        id: string;
      }[];
    };
  };
  links?: ResourceLinks;
}

/** CiProductsResponse */
export interface CiProductsResponse {
  data: CiProduct[];
  included?: (App | BundleId | ScmRepository)[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** CiProductResponse */
export interface CiProductResponse {
  data: CiProduct;
  included?: (App | BundleId | ScmRepository)[];
  links: DocumentLinks;
}

/** CiTestResult */
export interface CiTestResult {
  type: "ciTestResults";
  id: string;
  attributes?: {
    className?: string;
    name?: string;
    status?: CiTestStatus;
    fileSource?: FileLocation;
    message?: string;
    destinationTestResults?: {
      uuid?: string;
      deviceName?: string;
      osVersion?: string;
      status?: CiTestStatus;
      duration?: number;
    }[];
  };
  links?: ResourceLinks;
}

/** CiTestResultsResponse */
export interface CiTestResultsResponse {
  data: CiTestResult[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** CiTestResultResponse */
export interface CiTestResultResponse {
  data: CiTestResult;
  links: DocumentLinks;
}

/** CiWorkflow */
export interface CiWorkflow {
  type: "ciWorkflows";
  id: string;
  attributes?: {
    name?: string;
    description?: string;
    branchStartCondition?: CiBranchStartCondition;
    tagStartCondition?: CiTagStartCondition;
    pullRequestStartCondition?: CiPullRequestStartCondition;
    scheduledStartCondition?: CiScheduledStartCondition;
    manualBranchStartCondition?: CiManualBranchStartCondition;
    manualTagStartCondition?: CiManualTagStartCondition;
    manualPullRequestStartCondition?: CiManualPullRequestStartCondition;
    actions?: CiAction[];
    isEnabled?: boolean;
    isLockedForEditing?: boolean;
    clean?: boolean;
    containerFilePath?: string;
    /** @format date-time */
    lastModifiedDate?: string;
  };
  relationships?: {
    product?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "ciProducts";
        id: string;
      };
    };
    repository?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "scmRepositories";
        id: string;
      };
    };
    xcodeVersion?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "ciXcodeVersions";
        id: string;
      };
    };
    macOsVersion?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "ciMacOsVersions";
        id: string;
      };
    };
  };
  links?: ResourceLinks;
}

/** CiWorkflowsResponse */
export interface CiWorkflowsResponse {
  data: CiWorkflow[];
  included?: (CiProduct | ScmRepository | CiXcodeVersion | CiMacOsVersion)[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** CiWorkflowResponse */
export interface CiWorkflowResponse {
  data: CiWorkflow;
  included?: (CiProduct | ScmRepository | CiXcodeVersion | CiMacOsVersion)[];
  links: DocumentLinks;
}

/** CiWorkflowCreateRequest */
export interface CiWorkflowCreateRequest {
  data: {
    type: "ciWorkflows";
    attributes: {
      name: string;
      description: string;
      branchStartCondition?: CiBranchStartCondition;
      tagStartCondition?: CiTagStartCondition;
      pullRequestStartCondition?: CiPullRequestStartCondition;
      scheduledStartCondition?: CiScheduledStartCondition;
      manualBranchStartCondition?: CiManualBranchStartCondition;
      manualTagStartCondition?: CiManualTagStartCondition;
      manualPullRequestStartCondition?: CiManualPullRequestStartCondition;
      actions: CiAction[];
      isEnabled: boolean;
      isLockedForEditing?: boolean;
      clean: boolean;
      containerFilePath: string;
    };
    relationships: {
      product: {
        data: {
          type: "ciProducts";
          id: string;
        };
      };
      repository: {
        data: {
          type: "scmRepositories";
          id: string;
        };
      };
      xcodeVersion: {
        data: {
          type: "ciXcodeVersions";
          id: string;
        };
      };
      macOsVersion: {
        data: {
          type: "ciMacOsVersions";
          id: string;
        };
      };
    };
  };
}

/** CiWorkflowUpdateRequest */
export interface CiWorkflowUpdateRequest {
  data: {
    type: "ciWorkflows";
    id: string;
    attributes?: {
      name?: string;
      description?: string;
      branchStartCondition?: CiBranchStartCondition;
      tagStartCondition?: CiTagStartCondition;
      pullRequestStartCondition?: CiPullRequestStartCondition;
      scheduledStartCondition?: CiScheduledStartCondition;
      manualBranchStartCondition?: CiManualBranchStartCondition;
      manualTagStartCondition?: CiManualTagStartCondition;
      manualPullRequestStartCondition?: CiManualPullRequestStartCondition;
      actions?: CiAction[];
      isEnabled?: boolean;
      isLockedForEditing?: boolean;
      clean?: boolean;
      containerFilePath?: string;
    };
    relationships?: {
      xcodeVersion?: {
        data?: {
          type: "ciXcodeVersions";
          id: string;
        };
      };
      macOsVersion?: {
        data?: {
          type: "ciMacOsVersions";
          id: string;
        };
      };
    };
  };
}

/** CiXcodeVersion */
export interface CiXcodeVersion {
  type: "ciXcodeVersions";
  id: string;
  attributes?: {
    version?: string;
    name?: string;
    testDestinations?: {
      deviceTypeName?: string;
      deviceTypeIdentifier?: string;
      availableRuntimes?: {
        runtimeName?: string;
        runtimeIdentifier?: string;
      }[];
      kind?: CiTestDestinationKind;
    }[];
  };
  relationships?: {
    macOsVersions?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "ciMacOsVersions";
        id: string;
      }[];
    };
  };
  links?: ResourceLinks;
}

/** CiXcodeVersionsResponse */
export interface CiXcodeVersionsResponse {
  data: CiXcodeVersion[];
  included?: CiMacOsVersion[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** CiXcodeVersionResponse */
export interface CiXcodeVersionResponse {
  data: CiXcodeVersion;
  included?: CiMacOsVersion[];
  links: DocumentLinks;
}

/** CustomerReviewResponseV1 */
export interface CustomerReviewResponseV1 {
  type: "customerReviewResponses";
  id: string;
  attributes?: {
    responseBody?: string;
    /** @format date-time */
    lastModifiedDate?: string;
    state?: "PUBLISHED" | "PENDING_PUBLISH";
  };
  relationships?: {
    review?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "customerReviews";
        id: string;
      };
    };
  };
  links?: ResourceLinks;
}

/** CustomerReviewResponseV1Response */
export interface CustomerReviewResponseV1Response {
  data: CustomerReviewResponseV1;
  included?: CustomerReview[];
  links: DocumentLinks;
}

/** CustomerReviewResponseV1CreateRequest */
export interface CustomerReviewResponseV1CreateRequest {
  data: {
    type: "customerReviewResponses";
    attributes: {
      responseBody: string;
    };
    relationships: {
      review: {
        data: {
          type: "customerReviews";
          id: string;
        };
      };
    };
  };
}

/** CustomerReview */
export interface CustomerReview {
  type: "customerReviews";
  id: string;
  attributes?: {
    /**
     * @min 1
     * @max 5
     */
    rating?: number;
    title?: string;
    body?: string;
    reviewerNickname?: string;
    /** @format date-time */
    createdDate?: string;
    territory?: TerritoryCode;
  };
  relationships?: {
    response?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "customerReviewResponses";
        id: string;
      };
    };
  };
  links?: ResourceLinks;
}

/** CustomerReviewsResponse */
export interface CustomerReviewsResponse {
  data: CustomerReview[];
  included?: CustomerReviewResponseV1[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** CustomerReviewResponse */
export interface CustomerReviewResponse {
  data: CustomerReview;
  included?: CustomerReviewResponseV1[];
  links: DocumentLinks;
}

/** Device */
export interface Device {
  type: "devices";
  id: string;
  attributes?: {
    name?: string;
    platform?: BundleIdPlatform;
    udid?: string;
    deviceClass?: "APPLE_WATCH" | "IPAD" | "IPHONE" | "IPOD" | "APPLE_TV" | "MAC";
    status?: "ENABLED" | "DISABLED";
    model?: string;
    /** @format date-time */
    addedDate?: string;
  };
  links?: ResourceLinks;
}

/** DevicesResponse */
export interface DevicesResponse {
  data: Device[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** DeviceResponse */
export interface DeviceResponse {
  data: Device;
  links: DocumentLinks;
}

/** DeviceCreateRequest */
export interface DeviceCreateRequest {
  data: {
    type: "devices";
    attributes: {
      name: string;
      platform: BundleIdPlatform;
      udid: string;
    };
  };
}

/** DeviceUpdateRequest */
export interface DeviceUpdateRequest {
  data: {
    type: "devices";
    id: string;
    attributes?: {
      name?: string;
      status?: "ENABLED" | "DISABLED";
    };
  };
}

/** DiagnosticLog */
export interface DiagnosticLog {
  type: "diagnosticLogs";
  id: string;
  links?: ResourceLinks;
}

/** DiagnosticSignature */
export interface DiagnosticSignature {
  type: "diagnosticSignatures";
  id: string;
  attributes?: {
    diagnosticType?: "DISK_WRITES" | "HANGS";
    signature?: string;
    weight?: number;
  };
  links?: ResourceLinks;
}

/** DiagnosticSignaturesResponse */
export interface DiagnosticSignaturesResponse {
  data: DiagnosticSignature[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** EndAppAvailabilityPreOrder */
export interface EndAppAvailabilityPreOrder {
  type: "endAppAvailabilityPreOrders";
  id: string;
  links?: ResourceLinks;
}

/** EndAppAvailabilityPreOrderResponse */
export interface EndAppAvailabilityPreOrderResponse {
  data: EndAppAvailabilityPreOrder;
  links: DocumentLinks;
}

/** EndAppAvailabilityPreOrderCreateRequest */
export interface EndAppAvailabilityPreOrderCreateRequest {
  data: {
    type: "endAppAvailabilityPreOrders";
    relationships: {
      territoryAvailabilities: {
        data: {
          type: "territoryAvailabilities";
          id: string;
        }[];
      };
    };
  };
}

/** EndUserLicenseAgreement */
export interface EndUserLicenseAgreement {
  type: "endUserLicenseAgreements";
  id: string;
  attributes?: {
    agreementText?: string;
  };
  relationships?: {
    app?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "apps";
        id: string;
      };
    };
    territories?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "territories";
        id: string;
      }[];
    };
  };
  links?: ResourceLinks;
}

/** EndUserLicenseAgreementResponse */
export interface EndUserLicenseAgreementResponse {
  data: EndUserLicenseAgreement;
  included?: (App | Territory)[];
  links: DocumentLinks;
}

/** EndUserLicenseAgreementCreateRequest */
export interface EndUserLicenseAgreementCreateRequest {
  data: {
    type: "endUserLicenseAgreements";
    attributes: {
      agreementText: string;
    };
    relationships: {
      app: {
        data: {
          type: "apps";
          id: string;
        };
      };
      territories: {
        data: {
          type: "territories";
          id: string;
        }[];
      };
    };
  };
}

/** EndUserLicenseAgreementUpdateRequest */
export interface EndUserLicenseAgreementUpdateRequest {
  data: {
    type: "endUserLicenseAgreements";
    id: string;
    attributes?: {
      agreementText?: string;
    };
    relationships?: {
      territories?: {
        data?: {
          type: "territories";
          id: string;
        }[];
      };
    };
  };
}

/** GameCenterAchievementImage */
export interface GameCenterAchievementImage {
  type: "gameCenterAchievementImages";
  id: string;
  attributes?: {
    fileSize?: number;
    fileName?: string;
    imageAsset?: ImageAsset;
    uploadOperations?: UploadOperation[];
    assetDeliveryState?: AppMediaAssetState;
  };
  relationships?: {
    gameCenterAchievementLocalization?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "gameCenterAchievementLocalizations";
        id: string;
      };
    };
  };
  links?: ResourceLinks;
}

/** GameCenterAchievementImageResponse */
export interface GameCenterAchievementImageResponse {
  data: GameCenterAchievementImage;
  included?: GameCenterAchievementLocalization[];
  links: DocumentLinks;
}

/** GameCenterAchievementImageCreateRequest */
export interface GameCenterAchievementImageCreateRequest {
  data: {
    type: "gameCenterAchievementImages";
    attributes: {
      fileSize: number;
      fileName: string;
    };
    relationships: {
      gameCenterAchievementLocalization: {
        data: {
          type: "gameCenterAchievementLocalizations";
          id: string;
        };
      };
    };
  };
}

/** GameCenterAchievementImageUpdateRequest */
export interface GameCenterAchievementImageUpdateRequest {
  data: {
    type: "gameCenterAchievementImages";
    id: string;
    attributes?: {
      uploaded?: boolean;
    };
  };
}

/** GameCenterAchievementLocalization */
export interface GameCenterAchievementLocalization {
  type: "gameCenterAchievementLocalizations";
  id: string;
  attributes?: {
    locale?: string;
    name?: string;
    beforeEarnedDescription?: string;
    afterEarnedDescription?: string;
  };
  relationships?: {
    gameCenterAchievement?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "gameCenterAchievements";
        id: string;
      };
    };
    gameCenterAchievementImage?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "gameCenterAchievementImages";
        id: string;
      };
    };
  };
  links?: ResourceLinks;
}

/** GameCenterAchievementLocalizationsResponse */
export interface GameCenterAchievementLocalizationsResponse {
  data: GameCenterAchievementLocalization[];
  included?: (GameCenterAchievement | GameCenterAchievementImage)[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** GameCenterAchievementLocalizationResponse */
export interface GameCenterAchievementLocalizationResponse {
  data: GameCenterAchievementLocalization;
  included?: (GameCenterAchievement | GameCenterAchievementImage)[];
  links: DocumentLinks;
}

/** GameCenterAchievementLocalizationCreateRequest */
export interface GameCenterAchievementLocalizationCreateRequest {
  data: {
    type: "gameCenterAchievementLocalizations";
    attributes: {
      locale: string;
      name: string;
      beforeEarnedDescription: string;
      afterEarnedDescription: string;
    };
    relationships: {
      gameCenterAchievement: {
        data: {
          type: "gameCenterAchievements";
          id: string;
        };
      };
    };
  };
}

/** GameCenterAchievementLocalizationUpdateRequest */
export interface GameCenterAchievementLocalizationUpdateRequest {
  data: {
    type: "gameCenterAchievementLocalizations";
    id: string;
    attributes?: {
      name?: string;
      beforeEarnedDescription?: string;
      afterEarnedDescription?: string;
    };
  };
}

/** GameCenterAchievementRelease */
export interface GameCenterAchievementRelease {
  type: "gameCenterAchievementReleases";
  id: string;
  attributes?: {
    live?: boolean;
  };
  relationships?: {
    gameCenterDetail?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "gameCenterDetails";
        id: string;
      };
    };
    gameCenterAchievement?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "gameCenterAchievements";
        id: string;
      };
    };
  };
  links?: ResourceLinks;
}

/** GameCenterAchievementReleasesResponse */
export interface GameCenterAchievementReleasesResponse {
  data: GameCenterAchievementRelease[];
  included?: (GameCenterDetail | GameCenterAchievement)[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** GameCenterAchievementReleaseResponse */
export interface GameCenterAchievementReleaseResponse {
  data: GameCenterAchievementRelease;
  included?: (GameCenterDetail | GameCenterAchievement)[];
  links: DocumentLinks;
}

/** GameCenterAchievementReleaseCreateRequest */
export interface GameCenterAchievementReleaseCreateRequest {
  data: {
    type: "gameCenterAchievementReleases";
    relationships: {
      gameCenterDetail: {
        data: {
          type: "gameCenterDetails";
          id: string;
        };
      };
      gameCenterAchievement: {
        data: {
          type: "gameCenterAchievements";
          id: string;
        };
      };
    };
  };
}

/** GameCenterAchievement */
export interface GameCenterAchievement {
  type: "gameCenterAchievements";
  id: string;
  attributes?: {
    referenceName?: string;
    vendorIdentifier?: string;
    points?: number;
    showBeforeEarned?: boolean;
    repeatable?: boolean;
    archived?: boolean;
  };
  relationships?: {
    gameCenterDetail?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "gameCenterDetails";
        id: string;
      };
    };
    gameCenterGroup?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "gameCenterGroups";
        id: string;
      };
    };
    groupAchievement?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "gameCenterAchievements";
        id: string;
      };
    };
    localizations?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "gameCenterAchievementLocalizations";
        id: string;
      }[];
    };
    releases?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "gameCenterAchievementReleases";
        id: string;
      }[];
    };
  };
  links?: ResourceLinks;
}

/** GameCenterAchievementsResponse */
export interface GameCenterAchievementsResponse {
  data: GameCenterAchievement[];
  included?: (
    | GameCenterDetail
    | GameCenterGroup
    | GameCenterAchievement
    | GameCenterAchievementLocalization
    | GameCenterAchievementRelease
  )[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** GameCenterAchievementResponse */
export interface GameCenterAchievementResponse {
  data: GameCenterAchievement;
  included?: (
    | GameCenterDetail
    | GameCenterGroup
    | GameCenterAchievement
    | GameCenterAchievementLocalization
    | GameCenterAchievementRelease
  )[];
  links: DocumentLinks;
}

/** GameCenterAchievementCreateRequest */
export interface GameCenterAchievementCreateRequest {
  data: {
    type: "gameCenterAchievements";
    attributes: {
      referenceName: string;
      vendorIdentifier: string;
      points: number;
      showBeforeEarned: boolean;
      repeatable: boolean;
    };
    relationships?: {
      gameCenterDetail?: {
        data?: {
          type: "gameCenterDetails";
          id: string;
        };
      };
      gameCenterGroup?: {
        data?: {
          type: "gameCenterGroups";
          id: string;
        };
      };
    };
  };
}

/** GameCenterAchievementUpdateRequest */
export interface GameCenterAchievementUpdateRequest {
  data: {
    type: "gameCenterAchievements";
    id: string;
    attributes?: {
      referenceName?: string;
      points?: number;
      showBeforeEarned?: boolean;
      repeatable?: boolean;
      archived?: boolean;
    };
  };
}

/** GameCenterAppVersion */
export interface GameCenterAppVersion {
  type: "gameCenterAppVersions";
  id: string;
  attributes?: {
    enabled?: boolean;
  };
  relationships?: {
    compatibilityVersions?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "gameCenterAppVersions";
        id: string;
      }[];
    };
    appStoreVersion?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "appStoreVersions";
        id: string;
      };
    };
  };
  links?: ResourceLinks;
}

/** GameCenterAppVersionsResponse */
export interface GameCenterAppVersionsResponse {
  data: GameCenterAppVersion[];
  included?: (GameCenterAppVersion | AppStoreVersion)[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** GameCenterAppVersionResponse */
export interface GameCenterAppVersionResponse {
  data: GameCenterAppVersion;
  included?: (GameCenterAppVersion | AppStoreVersion)[];
  links: DocumentLinks;
}

/** GameCenterAppVersionCreateRequest */
export interface GameCenterAppVersionCreateRequest {
  data: {
    type: "gameCenterAppVersions";
    relationships: {
      appStoreVersion: {
        data: {
          type: "appStoreVersions";
          id: string;
        };
      };
    };
  };
}

/** GameCenterAppVersionUpdateRequest */
export interface GameCenterAppVersionUpdateRequest {
  data: {
    type: "gameCenterAppVersions";
    id: string;
    attributes?: {
      enabled?: boolean;
    };
  };
}

/** GameCenterDetail */
export interface GameCenterDetail {
  type: "gameCenterDetails";
  id: string;
  attributes?: {
    arcadeEnabled?: boolean;
    challengeEnabled?: boolean;
  };
  relationships?: {
    app?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "apps";
        id: string;
      };
    };
    gameCenterAppVersions?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "gameCenterAppVersions";
        id: string;
      }[];
    };
    gameCenterGroup?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "gameCenterGroups";
        id: string;
      };
    };
    gameCenterLeaderboards?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "gameCenterLeaderboards";
        id: string;
      }[];
    };
    gameCenterLeaderboardSets?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "gameCenterLeaderboardSets";
        id: string;
      }[];
    };
    gameCenterAchievements?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "gameCenterAchievements";
        id: string;
      }[];
    };
    defaultLeaderboard?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "gameCenterLeaderboards";
        id: string;
      };
    };
    defaultGroupLeaderboard?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "gameCenterLeaderboards";
        id: string;
      };
    };
    achievementReleases?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "gameCenterAchievementReleases";
        id: string;
      }[];
    };
    leaderboardReleases?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "gameCenterLeaderboardReleases";
        id: string;
      }[];
    };
    leaderboardSetReleases?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "gameCenterLeaderboardSetReleases";
        id: string;
      }[];
    };
  };
  links?: ResourceLinks;
}

/** GameCenterDetailsResponse */
export interface GameCenterDetailsResponse {
  data: GameCenterDetail[];
  included?: (
    | App
    | GameCenterAppVersion
    | GameCenterGroup
    | GameCenterLeaderboard
    | GameCenterLeaderboardSet
    | GameCenterAchievement
    | GameCenterAchievementRelease
    | GameCenterLeaderboardRelease
    | GameCenterLeaderboardSetRelease
  )[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** GameCenterDetailResponse */
export interface GameCenterDetailResponse {
  data: GameCenterDetail;
  included?: (
    | App
    | GameCenterAppVersion
    | GameCenterGroup
    | GameCenterLeaderboard
    | GameCenterLeaderboardSet
    | GameCenterAchievement
    | GameCenterAchievementRelease
    | GameCenterLeaderboardRelease
    | GameCenterLeaderboardSetRelease
  )[];
  links: DocumentLinks;
}

/** GameCenterDetailCreateRequest */
export interface GameCenterDetailCreateRequest {
  data: {
    type: "gameCenterDetails";
    attributes?: {
      challengeEnabled?: boolean;
    };
    relationships: {
      app: {
        data: {
          type: "apps";
          id: string;
        };
      };
    };
  };
}

/** GameCenterDetailUpdateRequest */
export interface GameCenterDetailUpdateRequest {
  data: {
    type: "gameCenterDetails";
    id: string;
    attributes?: {
      challengeEnabled?: boolean;
    };
    relationships?: {
      gameCenterGroup?: {
        data?: {
          type: "gameCenterGroups";
          id: string;
        };
      };
      defaultLeaderboard?: {
        data?: {
          type: "gameCenterLeaderboards";
          id: string;
        };
      };
      defaultGroupLeaderboard?: {
        data?: {
          type: "gameCenterLeaderboards";
          id: string;
        };
      };
    };
  };
}

/**
 * GameCenterEnabledVersion
 * @deprecated
 */
export interface GameCenterEnabledVersion {
  type: "gameCenterEnabledVersions";
  id: string;
  attributes?: {
    platform?: Platform;
    versionString?: string;
    iconAsset?: ImageAsset;
  };
  relationships?: {
    compatibleVersions?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "gameCenterEnabledVersions";
        id: string;
      }[];
    };
    app?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "apps";
        id: string;
      };
    };
  };
  links?: ResourceLinks;
}

/**
 * GameCenterEnabledVersionsResponse
 * @deprecated
 */
export interface GameCenterEnabledVersionsResponse {
  data: GameCenterEnabledVersion[];
  included?: (GameCenterEnabledVersion | App)[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** GameCenterGroup */
export interface GameCenterGroup {
  type: "gameCenterGroups";
  id: string;
  attributes?: {
    referenceName?: string;
  };
  relationships?: {
    gameCenterDetails?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "gameCenterDetails";
        id: string;
      }[];
    };
    gameCenterLeaderboards?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "gameCenterLeaderboards";
        id: string;
      }[];
    };
    gameCenterLeaderboardSets?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "gameCenterLeaderboardSets";
        id: string;
      }[];
    };
    gameCenterAchievements?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "gameCenterAchievements";
        id: string;
      }[];
    };
  };
  links?: ResourceLinks;
}

/** GameCenterGroupsResponse */
export interface GameCenterGroupsResponse {
  data: GameCenterGroup[];
  included?: (GameCenterDetail | GameCenterLeaderboard | GameCenterLeaderboardSet | GameCenterAchievement)[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** GameCenterGroupResponse */
export interface GameCenterGroupResponse {
  data: GameCenterGroup;
  included?: (GameCenterDetail | GameCenterLeaderboard | GameCenterLeaderboardSet | GameCenterAchievement)[];
  links: DocumentLinks;
}

/** GameCenterGroupCreateRequest */
export interface GameCenterGroupCreateRequest {
  data: {
    type: "gameCenterGroups";
    attributes?: {
      referenceName?: string;
    };
  };
}

/** GameCenterGroupUpdateRequest */
export interface GameCenterGroupUpdateRequest {
  data: {
    type: "gameCenterGroups";
    id: string;
    attributes?: {
      referenceName?: string;
    };
  };
}

/** GameCenterLeaderboardEntrySubmission */
export interface GameCenterLeaderboardEntrySubmission {
  type: "gameCenterLeaderboardEntrySubmissions";
  id: string;
  attributes?: {
    bundleId?: string;
    challengeIds?: string[];
    /** @format number */
    context?: string;
    scopedPlayerId?: string;
    /** @format number */
    score?: string;
    /** @format date-time */
    submittedDate?: string;
    vendorIdentifier?: string;
  };
  links?: ResourceLinks;
}

/** GameCenterLeaderboardEntrySubmissionResponse */
export interface GameCenterLeaderboardEntrySubmissionResponse {
  data: GameCenterLeaderboardEntrySubmission;
  links: DocumentLinks;
}

/** GameCenterLeaderboardEntrySubmissionCreateRequest */
export interface GameCenterLeaderboardEntrySubmissionCreateRequest {
  data: {
    type: "gameCenterLeaderboardEntrySubmissions";
    attributes: {
      bundleId: string;
      challengeIds?: string[];
      /** @format number */
      context?: string;
      scopedPlayerId: string;
      /** @format number */
      score: string;
      /** @format date-time */
      submittedDate?: string;
      vendorIdentifier: string;
    };
  };
}

/** GameCenterLeaderboardImage */
export interface GameCenterLeaderboardImage {
  type: "gameCenterLeaderboardImages";
  id: string;
  attributes?: {
    fileSize?: number;
    fileName?: string;
    imageAsset?: ImageAsset;
    uploadOperations?: UploadOperation[];
    assetDeliveryState?: AppMediaAssetState;
  };
  relationships?: {
    gameCenterLeaderboardLocalization?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "gameCenterLeaderboardLocalizations";
        id: string;
      };
    };
  };
  links?: ResourceLinks;
}

/** GameCenterLeaderboardImageResponse */
export interface GameCenterLeaderboardImageResponse {
  data: GameCenterLeaderboardImage;
  included?: GameCenterLeaderboardLocalization[];
  links: DocumentLinks;
}

/** GameCenterLeaderboardImageCreateRequest */
export interface GameCenterLeaderboardImageCreateRequest {
  data: {
    type: "gameCenterLeaderboardImages";
    attributes: {
      fileSize: number;
      fileName: string;
    };
    relationships: {
      gameCenterLeaderboardLocalization: {
        data: {
          type: "gameCenterLeaderboardLocalizations";
          id: string;
        };
      };
    };
  };
}

/** GameCenterLeaderboardImageUpdateRequest */
export interface GameCenterLeaderboardImageUpdateRequest {
  data: {
    type: "gameCenterLeaderboardImages";
    id: string;
    attributes?: {
      uploaded?: boolean;
    };
  };
}

/** GameCenterLeaderboardLocalization */
export interface GameCenterLeaderboardLocalization {
  type: "gameCenterLeaderboardLocalizations";
  id: string;
  attributes?: {
    locale?: string;
    name?: string;
    formatterOverride?: GameCenterLeaderboardFormatter;
    formatterSuffix?: string;
    formatterSuffixSingular?: string;
  };
  relationships?: {
    gameCenterLeaderboard?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "gameCenterLeaderboards";
        id: string;
      };
    };
    gameCenterLeaderboardImage?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "gameCenterLeaderboardImages";
        id: string;
      };
    };
  };
  links?: ResourceLinks;
}

/** GameCenterLeaderboardLocalizationsResponse */
export interface GameCenterLeaderboardLocalizationsResponse {
  data: GameCenterLeaderboardLocalization[];
  included?: (GameCenterLeaderboard | GameCenterLeaderboardImage)[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** GameCenterLeaderboardLocalizationResponse */
export interface GameCenterLeaderboardLocalizationResponse {
  data: GameCenterLeaderboardLocalization;
  included?: (GameCenterLeaderboard | GameCenterLeaderboardImage)[];
  links: DocumentLinks;
}

/** GameCenterLeaderboardLocalizationCreateRequest */
export interface GameCenterLeaderboardLocalizationCreateRequest {
  data: {
    type: "gameCenterLeaderboardLocalizations";
    attributes: {
      locale: string;
      name: string;
      formatterOverride?: GameCenterLeaderboardFormatter;
      formatterSuffix?: string;
      formatterSuffixSingular?: string;
    };
    relationships: {
      gameCenterLeaderboard: {
        data: {
          type: "gameCenterLeaderboards";
          id: string;
        };
      };
    };
  };
}

/** GameCenterLeaderboardLocalizationUpdateRequest */
export interface GameCenterLeaderboardLocalizationUpdateRequest {
  data: {
    type: "gameCenterLeaderboardLocalizations";
    id: string;
    attributes?: {
      name?: string;
      formatterOverride?: GameCenterLeaderboardFormatter;
      formatterSuffix?: string;
      formatterSuffixSingular?: string;
    };
  };
}

/** GameCenterLeaderboardRelease */
export interface GameCenterLeaderboardRelease {
  type: "gameCenterLeaderboardReleases";
  id: string;
  attributes?: {
    live?: boolean;
  };
  relationships?: {
    gameCenterDetail?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "gameCenterDetails";
        id: string;
      };
    };
    gameCenterLeaderboard?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "gameCenterLeaderboards";
        id: string;
      };
    };
  };
  links?: ResourceLinks;
}

/** GameCenterLeaderboardReleasesResponse */
export interface GameCenterLeaderboardReleasesResponse {
  data: GameCenterLeaderboardRelease[];
  included?: (GameCenterDetail | GameCenterLeaderboard)[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** GameCenterLeaderboardReleaseResponse */
export interface GameCenterLeaderboardReleaseResponse {
  data: GameCenterLeaderboardRelease;
  included?: (GameCenterDetail | GameCenterLeaderboard)[];
  links: DocumentLinks;
}

/** GameCenterLeaderboardReleaseCreateRequest */
export interface GameCenterLeaderboardReleaseCreateRequest {
  data: {
    type: "gameCenterLeaderboardReleases";
    relationships: {
      gameCenterDetail: {
        data: {
          type: "gameCenterDetails";
          id: string;
        };
      };
      gameCenterLeaderboard: {
        data: {
          type: "gameCenterLeaderboards";
          id: string;
        };
      };
    };
  };
}

/** GameCenterLeaderboardSetImage */
export interface GameCenterLeaderboardSetImage {
  type: "gameCenterLeaderboardSetImages";
  id: string;
  attributes?: {
    fileSize?: number;
    fileName?: string;
    imageAsset?: ImageAsset;
    uploadOperations?: UploadOperation[];
    assetDeliveryState?: AppMediaAssetState;
  };
  relationships?: {
    gameCenterLeaderboardSetLocalization?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "gameCenterLeaderboardSetLocalizations";
        id: string;
      };
    };
  };
  links?: ResourceLinks;
}

/** GameCenterLeaderboardSetImageResponse */
export interface GameCenterLeaderboardSetImageResponse {
  data: GameCenterLeaderboardSetImage;
  included?: GameCenterLeaderboardSetLocalization[];
  links: DocumentLinks;
}

/** GameCenterLeaderboardSetImageCreateRequest */
export interface GameCenterLeaderboardSetImageCreateRequest {
  data: {
    type: "gameCenterLeaderboardSetImages";
    attributes: {
      fileSize: number;
      fileName: string;
    };
    relationships: {
      gameCenterLeaderboardSetLocalization: {
        data: {
          type: "gameCenterLeaderboardSetLocalizations";
          id: string;
        };
      };
    };
  };
}

/** GameCenterLeaderboardSetImageUpdateRequest */
export interface GameCenterLeaderboardSetImageUpdateRequest {
  data: {
    type: "gameCenterLeaderboardSetImages";
    id: string;
    attributes?: {
      uploaded?: boolean;
    };
  };
}

/** GameCenterLeaderboardSetLocalization */
export interface GameCenterLeaderboardSetLocalization {
  type: "gameCenterLeaderboardSetLocalizations";
  id: string;
  attributes?: {
    locale?: string;
    name?: string;
  };
  relationships?: {
    gameCenterLeaderboardSet?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "gameCenterLeaderboardSets";
        id: string;
      };
    };
    gameCenterLeaderboardSetImage?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "gameCenterLeaderboardSetImages";
        id: string;
      };
    };
  };
  links?: ResourceLinks;
}

/** GameCenterLeaderboardSetLocalizationsResponse */
export interface GameCenterLeaderboardSetLocalizationsResponse {
  data: GameCenterLeaderboardSetLocalization[];
  included?: (GameCenterLeaderboardSet | GameCenterLeaderboardSetImage)[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** GameCenterLeaderboardSetLocalizationResponse */
export interface GameCenterLeaderboardSetLocalizationResponse {
  data: GameCenterLeaderboardSetLocalization;
  included?: (GameCenterLeaderboardSet | GameCenterLeaderboardSetImage)[];
  links: DocumentLinks;
}

/** GameCenterLeaderboardSetLocalizationCreateRequest */
export interface GameCenterLeaderboardSetLocalizationCreateRequest {
  data: {
    type: "gameCenterLeaderboardSetLocalizations";
    attributes: {
      locale: string;
      name: string;
    };
    relationships: {
      gameCenterLeaderboardSet: {
        data: {
          type: "gameCenterLeaderboardSets";
          id: string;
        };
      };
    };
  };
}

/** GameCenterLeaderboardSetLocalizationUpdateRequest */
export interface GameCenterLeaderboardSetLocalizationUpdateRequest {
  data: {
    type: "gameCenterLeaderboardSetLocalizations";
    id: string;
    attributes?: {
      name?: string;
    };
  };
}

/** GameCenterLeaderboardSetMemberLocalization */
export interface GameCenterLeaderboardSetMemberLocalization {
  type: "gameCenterLeaderboardSetMemberLocalizations";
  id: string;
  attributes?: {
    name?: string;
    locale?: string;
  };
  relationships?: {
    gameCenterLeaderboardSet?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "gameCenterLeaderboardSets";
        id: string;
      };
    };
    gameCenterLeaderboard?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "gameCenterLeaderboards";
        id: string;
      };
    };
  };
  links?: ResourceLinks;
}

/** GameCenterLeaderboardSetMemberLocalizationsResponse */
export interface GameCenterLeaderboardSetMemberLocalizationsResponse {
  data: GameCenterLeaderboardSetMemberLocalization[];
  included?: (GameCenterLeaderboardSet | GameCenterLeaderboard)[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** GameCenterLeaderboardSetMemberLocalizationResponse */
export interface GameCenterLeaderboardSetMemberLocalizationResponse {
  data: GameCenterLeaderboardSetMemberLocalization;
  included?: (GameCenterLeaderboardSet | GameCenterLeaderboard)[];
  links: DocumentLinks;
}

/** GameCenterLeaderboardSetMemberLocalizationCreateRequest */
export interface GameCenterLeaderboardSetMemberLocalizationCreateRequest {
  data: {
    type: "gameCenterLeaderboardSetMemberLocalizations";
    attributes?: {
      name?: string;
      locale?: string;
    };
    relationships: {
      gameCenterLeaderboardSet: {
        data: {
          type: "gameCenterLeaderboardSets";
          id: string;
        };
      };
      gameCenterLeaderboard: {
        data: {
          type: "gameCenterLeaderboards";
          id: string;
        };
      };
    };
  };
}

/** GameCenterLeaderboardSetMemberLocalizationUpdateRequest */
export interface GameCenterLeaderboardSetMemberLocalizationUpdateRequest {
  data: {
    type: "gameCenterLeaderboardSetMemberLocalizations";
    id: string;
    attributes?: {
      name?: string;
    };
  };
}

/** GameCenterLeaderboardSetRelease */
export interface GameCenterLeaderboardSetRelease {
  type: "gameCenterLeaderboardSetReleases";
  id: string;
  attributes?: {
    live?: boolean;
  };
  relationships?: {
    gameCenterDetail?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "gameCenterDetails";
        id: string;
      };
    };
    gameCenterLeaderboardSet?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "gameCenterLeaderboardSets";
        id: string;
      };
    };
  };
  links?: ResourceLinks;
}

/** GameCenterLeaderboardSetReleasesResponse */
export interface GameCenterLeaderboardSetReleasesResponse {
  data: GameCenterLeaderboardSetRelease[];
  included?: (GameCenterDetail | GameCenterLeaderboardSet)[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** GameCenterLeaderboardSetReleaseResponse */
export interface GameCenterLeaderboardSetReleaseResponse {
  data: GameCenterLeaderboardSetRelease;
  included?: (GameCenterDetail | GameCenterLeaderboardSet)[];
  links: DocumentLinks;
}

/** GameCenterLeaderboardSetReleaseCreateRequest */
export interface GameCenterLeaderboardSetReleaseCreateRequest {
  data: {
    type: "gameCenterLeaderboardSetReleases";
    relationships: {
      gameCenterDetail: {
        data: {
          type: "gameCenterDetails";
          id: string;
        };
      };
      gameCenterLeaderboardSet: {
        data: {
          type: "gameCenterLeaderboardSets";
          id: string;
        };
      };
    };
  };
}

/** GameCenterLeaderboardSet */
export interface GameCenterLeaderboardSet {
  type: "gameCenterLeaderboardSets";
  id: string;
  attributes?: {
    referenceName?: string;
    vendorIdentifier?: string;
  };
  relationships?: {
    gameCenterDetail?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "gameCenterDetails";
        id: string;
      };
    };
    gameCenterGroup?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "gameCenterGroups";
        id: string;
      };
    };
    groupLeaderboardSet?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "gameCenterLeaderboardSets";
        id: string;
      };
    };
    localizations?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "gameCenterLeaderboardSetLocalizations";
        id: string;
      }[];
    };
    gameCenterLeaderboards?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "gameCenterLeaderboards";
        id: string;
      }[];
    };
    releases?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "gameCenterLeaderboardSetReleases";
        id: string;
      }[];
    };
  };
  links?: ResourceLinks;
}

/** GameCenterLeaderboardSetsResponse */
export interface GameCenterLeaderboardSetsResponse {
  data: GameCenterLeaderboardSet[];
  included?: (
    | GameCenterDetail
    | GameCenterGroup
    | GameCenterLeaderboardSet
    | GameCenterLeaderboardSetLocalization
    | GameCenterLeaderboard
    | GameCenterLeaderboardSetRelease
  )[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** GameCenterLeaderboardSetResponse */
export interface GameCenterLeaderboardSetResponse {
  data: GameCenterLeaderboardSet;
  included?: (
    | GameCenterDetail
    | GameCenterGroup
    | GameCenterLeaderboardSet
    | GameCenterLeaderboardSetLocalization
    | GameCenterLeaderboard
    | GameCenterLeaderboardSetRelease
  )[];
  links: DocumentLinks;
}

/** GameCenterLeaderboardSetCreateRequest */
export interface GameCenterLeaderboardSetCreateRequest {
  data: {
    type: "gameCenterLeaderboardSets";
    attributes: {
      referenceName: string;
      vendorIdentifier: string;
    };
    relationships?: {
      gameCenterDetail?: {
        data?: {
          type: "gameCenterDetails";
          id: string;
        };
      };
      gameCenterGroup?: {
        data?: {
          type: "gameCenterGroups";
          id: string;
        };
      };
      gameCenterLeaderboards?: {
        data?: {
          type: "gameCenterLeaderboards";
          id: string;
        }[];
      };
    };
  };
}

/** GameCenterLeaderboardSetUpdateRequest */
export interface GameCenterLeaderboardSetUpdateRequest {
  data: {
    type: "gameCenterLeaderboardSets";
    id: string;
    attributes?: {
      referenceName?: string;
    };
  };
}

/** GameCenterLeaderboard */
export interface GameCenterLeaderboard {
  type: "gameCenterLeaderboards";
  id: string;
  attributes?: {
    defaultFormatter?: GameCenterLeaderboardFormatter;
    referenceName?: string;
    vendorIdentifier?: string;
    submissionType?: "BEST_SCORE" | "MOST_RECENT_SCORE";
    scoreSortType?: "ASC" | "DESC";
    /** @format number */
    scoreRangeStart?: string;
    /** @format number */
    scoreRangeEnd?: string;
    /** @format date-time */
    recurrenceStartDate?: string;
    /** @format duration */
    recurrenceDuration?: string;
    recurrenceRule?: string;
    archived?: boolean;
  };
  relationships?: {
    gameCenterDetail?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "gameCenterDetails";
        id: string;
      };
    };
    gameCenterGroup?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "gameCenterGroups";
        id: string;
      };
    };
    groupLeaderboard?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "gameCenterLeaderboards";
        id: string;
      };
    };
    gameCenterLeaderboardSets?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "gameCenterLeaderboardSets";
        id: string;
      }[];
    };
    localizations?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "gameCenterLeaderboardLocalizations";
        id: string;
      }[];
    };
    releases?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "gameCenterLeaderboardReleases";
        id: string;
      }[];
    };
  };
  links?: ResourceLinks;
}

/** GameCenterLeaderboardsResponse */
export interface GameCenterLeaderboardsResponse {
  data: GameCenterLeaderboard[];
  included?: (
    | GameCenterDetail
    | GameCenterGroup
    | GameCenterLeaderboard
    | GameCenterLeaderboardSet
    | GameCenterLeaderboardLocalization
    | GameCenterLeaderboardRelease
  )[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** GameCenterLeaderboardResponse */
export interface GameCenterLeaderboardResponse {
  data: GameCenterLeaderboard;
  included?: (
    | GameCenterDetail
    | GameCenterGroup
    | GameCenterLeaderboard
    | GameCenterLeaderboardSet
    | GameCenterLeaderboardLocalization
    | GameCenterLeaderboardRelease
  )[];
  links: DocumentLinks;
}

/** GameCenterLeaderboardCreateRequest */
export interface GameCenterLeaderboardCreateRequest {
  data: {
    type: "gameCenterLeaderboards";
    attributes: {
      defaultFormatter: GameCenterLeaderboardFormatter;
      referenceName: string;
      vendorIdentifier: string;
      submissionType: "BEST_SCORE" | "MOST_RECENT_SCORE";
      scoreSortType: "ASC" | "DESC";
      /** @format number */
      scoreRangeStart?: string;
      /** @format number */
      scoreRangeEnd?: string;
      /** @format date-time */
      recurrenceStartDate?: string;
      /** @format duration */
      recurrenceDuration?: string;
      recurrenceRule?: string;
    };
    relationships?: {
      gameCenterDetail?: {
        data?: {
          type: "gameCenterDetails";
          id: string;
        };
      };
      gameCenterGroup?: {
        data?: {
          type: "gameCenterGroups";
          id: string;
        };
      };
      gameCenterLeaderboardSets?: {
        data?: {
          type: "gameCenterLeaderboardSets";
          id: string;
        }[];
      };
    };
  };
}

/** GameCenterLeaderboardUpdateRequest */
export interface GameCenterLeaderboardUpdateRequest {
  data: {
    type: "gameCenterLeaderboards";
    id: string;
    attributes?: {
      defaultFormatter?: GameCenterLeaderboardFormatter;
      referenceName?: string;
      submissionType?: "BEST_SCORE" | "MOST_RECENT_SCORE";
      scoreSortType?: "ASC" | "DESC";
      /** @format number */
      scoreRangeStart?: string;
      /** @format number */
      scoreRangeEnd?: string;
      /** @format date-time */
      recurrenceStartDate?: string;
      /** @format duration */
      recurrenceDuration?: string;
      recurrenceRule?: string;
      archived?: boolean;
    };
  };
}

/** GameCenterMatchmakingQueue */
export interface GameCenterMatchmakingQueue {
  type: "gameCenterMatchmakingQueues";
  id: string;
  attributes?: {
    referenceName?: string;
    classicMatchmakingBundleIds?: string[];
  };
  relationships?: {
    ruleSet?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "gameCenterMatchmakingRuleSets";
        id: string;
      };
    };
    experimentRuleSet?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "gameCenterMatchmakingRuleSets";
        id: string;
      };
    };
  };
  links?: ResourceLinks;
}

/** GameCenterMatchmakingQueuesResponse */
export interface GameCenterMatchmakingQueuesResponse {
  data: GameCenterMatchmakingQueue[];
  included?: GameCenterMatchmakingRuleSet[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** GameCenterMatchmakingQueueResponse */
export interface GameCenterMatchmakingQueueResponse {
  data: GameCenterMatchmakingQueue;
  included?: GameCenterMatchmakingRuleSet[];
  links: DocumentLinks;
}

/** GameCenterMatchmakingQueueCreateRequest */
export interface GameCenterMatchmakingQueueCreateRequest {
  data: {
    type: "gameCenterMatchmakingQueues";
    attributes: {
      referenceName: string;
      classicMatchmakingBundleIds?: string[];
    };
    relationships: {
      ruleSet: {
        data: {
          type: "gameCenterMatchmakingRuleSets";
          id: string;
        };
      };
      experimentRuleSet?: {
        data?: {
          type: "gameCenterMatchmakingRuleSets";
          id: string;
        };
      };
    };
  };
}

/** GameCenterMatchmakingQueueUpdateRequest */
export interface GameCenterMatchmakingQueueUpdateRequest {
  data: {
    type: "gameCenterMatchmakingQueues";
    id: string;
    attributes?: {
      classicMatchmakingBundleIds?: string[];
    };
    relationships?: {
      ruleSet?: {
        data?: {
          type: "gameCenterMatchmakingRuleSets";
          id: string;
        };
      };
      experimentRuleSet?: {
        data?: {
          type: "gameCenterMatchmakingRuleSets";
          id: string;
        };
      };
    };
  };
}

/** GameCenterMatchmakingRuleSetTest */
export interface GameCenterMatchmakingRuleSetTest {
  type: "gameCenterMatchmakingRuleSetTests";
  id: string;
  attributes?: {
    matchmakingResults?: {
      requestName?: string;
      teamAssignments?: GameCenterMatchmakingTeamAssignment[];
    }[][];
  };
  links?: ResourceLinks;
}

/** GameCenterMatchmakingRuleSetTestResponse */
export interface GameCenterMatchmakingRuleSetTestResponse {
  data: GameCenterMatchmakingRuleSetTest;
  links: DocumentLinks;
}

/** GameCenterMatchmakingRuleSetTestCreateRequest */
export interface GameCenterMatchmakingRuleSetTestCreateRequest {
  data: {
    type: "gameCenterMatchmakingRuleSetTests";
    relationships: {
      matchmakingRuleSet: {
        data: {
          type: "gameCenterMatchmakingRuleSets";
          id: string;
        };
      };
      matchmakingRequests: {
        data: {
          type: "gameCenterMatchmakingTestRequests";
          id: string;
        }[];
      };
    };
  };
  included?: (GameCenterMatchmakingTestPlayerPropertyInlineCreate | GameCenterMatchmakingTestRequestInlineCreate)[];
}

/** GameCenterMatchmakingRuleSet */
export interface GameCenterMatchmakingRuleSet {
  type: "gameCenterMatchmakingRuleSets";
  id: string;
  attributes?: {
    referenceName?: string;
    ruleLanguageVersion?: number;
    minPlayers?: number;
    maxPlayers?: number;
  };
  relationships?: {
    teams?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "gameCenterMatchmakingTeams";
        id: string;
      }[];
    };
    rules?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "gameCenterMatchmakingRules";
        id: string;
      }[];
    };
    matchmakingQueues?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "gameCenterMatchmakingQueues";
        id: string;
      }[];
    };
  };
  links?: ResourceLinks;
}

/** GameCenterMatchmakingRuleSetsResponse */
export interface GameCenterMatchmakingRuleSetsResponse {
  data: GameCenterMatchmakingRuleSet[];
  included?: (GameCenterMatchmakingTeam | GameCenterMatchmakingRule | GameCenterMatchmakingQueue)[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** GameCenterMatchmakingRuleSetResponse */
export interface GameCenterMatchmakingRuleSetResponse {
  data: GameCenterMatchmakingRuleSet;
  included?: (GameCenterMatchmakingTeam | GameCenterMatchmakingRule | GameCenterMatchmakingQueue)[];
  links: DocumentLinks;
}

/** GameCenterMatchmakingRuleSetCreateRequest */
export interface GameCenterMatchmakingRuleSetCreateRequest {
  data: {
    type: "gameCenterMatchmakingRuleSets";
    attributes: {
      referenceName: string;
      ruleLanguageVersion: number;
      minPlayers: number;
      maxPlayers: number;
    };
  };
}

/** GameCenterMatchmakingRuleSetUpdateRequest */
export interface GameCenterMatchmakingRuleSetUpdateRequest {
  data: {
    type: "gameCenterMatchmakingRuleSets";
    id: string;
    attributes?: {
      minPlayers?: number;
      maxPlayers?: number;
    };
  };
}

/** GameCenterMatchmakingRule */
export interface GameCenterMatchmakingRule {
  type: "gameCenterMatchmakingRules";
  id: string;
  attributes?: {
    referenceName?: string;
    description?: string;
    type?: "COMPATIBLE" | "DISTANCE" | "MATCH" | "TEAM";
    expression?: string;
    weight?: number;
  };
  links?: ResourceLinks;
}

/** GameCenterMatchmakingRulesResponse */
export interface GameCenterMatchmakingRulesResponse {
  data: GameCenterMatchmakingRule[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** GameCenterMatchmakingRuleResponse */
export interface GameCenterMatchmakingRuleResponse {
  data: GameCenterMatchmakingRule;
  links: DocumentLinks;
}

/** GameCenterMatchmakingRuleCreateRequest */
export interface GameCenterMatchmakingRuleCreateRequest {
  data: {
    type: "gameCenterMatchmakingRules";
    attributes: {
      referenceName: string;
      description: string;
      type: "COMPATIBLE" | "DISTANCE" | "MATCH" | "TEAM";
      expression: string;
      weight?: number;
    };
    relationships: {
      ruleSet: {
        data: {
          type: "gameCenterMatchmakingRuleSets";
          id: string;
        };
      };
    };
  };
}

/** GameCenterMatchmakingRuleUpdateRequest */
export interface GameCenterMatchmakingRuleUpdateRequest {
  data: {
    type: "gameCenterMatchmakingRules";
    id: string;
    attributes?: {
      description?: string;
      expression?: string;
      weight?: number;
    };
  };
}

/** GameCenterMatchmakingTeam */
export interface GameCenterMatchmakingTeam {
  type: "gameCenterMatchmakingTeams";
  id: string;
  attributes?: {
    referenceName?: string;
    minPlayers?: number;
    maxPlayers?: number;
  };
  links?: ResourceLinks;
}

/** GameCenterMatchmakingTeamsResponse */
export interface GameCenterMatchmakingTeamsResponse {
  data: GameCenterMatchmakingTeam[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** GameCenterMatchmakingTeamResponse */
export interface GameCenterMatchmakingTeamResponse {
  data: GameCenterMatchmakingTeam;
  links: DocumentLinks;
}

/** GameCenterMatchmakingTeamCreateRequest */
export interface GameCenterMatchmakingTeamCreateRequest {
  data: {
    type: "gameCenterMatchmakingTeams";
    attributes: {
      referenceName: string;
      minPlayers: number;
      maxPlayers: number;
    };
    relationships: {
      ruleSet: {
        data: {
          type: "gameCenterMatchmakingRuleSets";
          id: string;
        };
      };
    };
  };
}

/** GameCenterMatchmakingTeamUpdateRequest */
export interface GameCenterMatchmakingTeamUpdateRequest {
  data: {
    type: "gameCenterMatchmakingTeams";
    id: string;
    attributes?: {
      minPlayers?: number;
      maxPlayers?: number;
    };
  };
}

export interface GameCenterMatchmakingTestPlayerPropertyInlineCreate {
  type: "gameCenterMatchmakingTestPlayerProperties";
  id?: string;
  attributes: {
    playerId: string;
    properties?: Property[];
  };
}

export interface GameCenterMatchmakingTestRequestInlineCreate {
  type: "gameCenterMatchmakingTestRequests";
  id?: string;
  attributes: {
    requestName: string;
    secondsInQueue: number;
    locale?:
      | "AR-SA"
      | "CA-ES"
      | "CS-CZ"
      | "DA-DK"
      | "DE-DE"
      | "EL-GR"
      | "EN-AU"
      | "EN-GB"
      | "EN-US"
      | "EN-KY"
      | "ES-ES"
      | "ES-MX"
      | "FI-FI"
      | "FR-CA"
      | "FR-FR"
      | "HI-IN"
      | "HR-HR"
      | "HU-HU"
      | "ID-ID"
      | "IT-IT"
      | "IW-IL"
      | "JA-JP"
      | "KO-KR"
      | "MS-MY"
      | "NL-NL"
      | "NO-NO"
      | "PL-PL"
      | "PT-BR"
      | "PT-PT"
      | "RO-RO"
      | "RU-RU"
      | "SK-SK"
      | "SV-SE"
      | "TH-TH"
      | "TR-TR"
      | "UK-UA"
      | "ZH-CN"
      | "ZH-TW"
      | "ZH-HK";
    location?: Location;
    minPlayers?: number;
    maxPlayers?: number;
    playerCount?: number;
    bundleId: string;
    platform: Platform;
    appVersion: string;
  };
  relationships?: {
    matchmakingPlayerProperties?: {
      data?: {
        type: "gameCenterMatchmakingTestPlayerProperties";
        id: string;
      }[];
    };
  };
}

/** GameCenterPlayerAchievementSubmission */
export interface GameCenterPlayerAchievementSubmission {
  type: "gameCenterPlayerAchievementSubmissions";
  id: string;
  attributes?: {
    bundleId?: string;
    challengeIds?: string[];
    percentageAchieved?: number;
    scopedPlayerId?: string;
    /** @format date-time */
    submittedDate?: string;
    vendorIdentifier?: string;
  };
  links?: ResourceLinks;
}

/** GameCenterPlayerAchievementSubmissionResponse */
export interface GameCenterPlayerAchievementSubmissionResponse {
  data: GameCenterPlayerAchievementSubmission;
  links: DocumentLinks;
}

/** GameCenterPlayerAchievementSubmissionCreateRequest */
export interface GameCenterPlayerAchievementSubmissionCreateRequest {
  data: {
    type: "gameCenterPlayerAchievementSubmissions";
    attributes: {
      bundleId: string;
      challengeIds?: string[];
      percentageAchieved: number;
      scopedPlayerId: string;
      /** @format date-time */
      submittedDate?: string;
      vendorIdentifier: string;
    };
  };
}

/** InAppPurchaseAppStoreReviewScreenshot */
export interface InAppPurchaseAppStoreReviewScreenshot {
  type: "inAppPurchaseAppStoreReviewScreenshots";
  id: string;
  attributes?: {
    fileSize?: number;
    fileName?: string;
    sourceFileChecksum?: string;
    imageAsset?: ImageAsset;
    assetToken?: string;
    assetType?: string;
    uploadOperations?: UploadOperation[];
    assetDeliveryState?: AppMediaAssetState;
  };
  relationships?: {
    inAppPurchaseV2?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "inAppPurchases";
        id: string;
      };
    };
  };
  links?: ResourceLinks;
}

/** InAppPurchaseAppStoreReviewScreenshotResponse */
export interface InAppPurchaseAppStoreReviewScreenshotResponse {
  data: InAppPurchaseAppStoreReviewScreenshot;
  included?: InAppPurchaseV2[];
  links: DocumentLinks;
}

/** InAppPurchaseAppStoreReviewScreenshotCreateRequest */
export interface InAppPurchaseAppStoreReviewScreenshotCreateRequest {
  data: {
    type: "inAppPurchaseAppStoreReviewScreenshots";
    attributes: {
      fileSize: number;
      fileName: string;
    };
    relationships: {
      inAppPurchaseV2: {
        data: {
          type: "inAppPurchases";
          id: string;
        };
      };
    };
  };
}

/** InAppPurchaseAppStoreReviewScreenshotUpdateRequest */
export interface InAppPurchaseAppStoreReviewScreenshotUpdateRequest {
  data: {
    type: "inAppPurchaseAppStoreReviewScreenshots";
    id: string;
    attributes?: {
      sourceFileChecksum?: string;
      uploaded?: boolean;
    };
  };
}

/** InAppPurchaseAvailability */
export interface InAppPurchaseAvailability {
  type: "inAppPurchaseAvailabilities";
  id: string;
  attributes?: {
    availableInNewTerritories?: boolean;
  };
  relationships?: {
    availableTerritories?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "territories";
        id: string;
      }[];
    };
  };
  links?: ResourceLinks;
}

/** InAppPurchaseAvailabilityResponse */
export interface InAppPurchaseAvailabilityResponse {
  data: InAppPurchaseAvailability;
  included?: Territory[];
  links: DocumentLinks;
}

/** InAppPurchaseAvailabilityCreateRequest */
export interface InAppPurchaseAvailabilityCreateRequest {
  data: {
    type: "inAppPurchaseAvailabilities";
    attributes: {
      availableInNewTerritories: boolean;
    };
    relationships: {
      inAppPurchase: {
        data: {
          type: "inAppPurchases";
          id: string;
        };
      };
      availableTerritories: {
        data: {
          type: "territories";
          id: string;
        }[];
      };
    };
  };
}

/** InAppPurchaseContent */
export interface InAppPurchaseContent {
  type: "inAppPurchaseContents";
  id: string;
  attributes?: {
    fileName?: string;
    fileSize?: number;
    /** @format uri */
    url?: string;
    /** @format date-time */
    lastModifiedDate?: string;
  };
  relationships?: {
    inAppPurchaseV2?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "inAppPurchases";
        id: string;
      };
    };
  };
  links?: ResourceLinks;
}

/** InAppPurchaseContentResponse */
export interface InAppPurchaseContentResponse {
  data: InAppPurchaseContent;
  included?: InAppPurchaseV2[];
  links: DocumentLinks;
}

/** InAppPurchaseLocalization */
export interface InAppPurchaseLocalization {
  type: "inAppPurchaseLocalizations";
  id: string;
  attributes?: {
    name?: string;
    locale?: string;
    description?: string;
    state?: "PREPARE_FOR_SUBMISSION" | "WAITING_FOR_REVIEW" | "APPROVED" | "REJECTED";
  };
  relationships?: {
    inAppPurchaseV2?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "inAppPurchases";
        id: string;
      };
    };
  };
  links?: ResourceLinks;
}

/** InAppPurchaseLocalizationsResponse */
export interface InAppPurchaseLocalizationsResponse {
  data: InAppPurchaseLocalization[];
  included?: InAppPurchaseV2[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** InAppPurchaseLocalizationResponse */
export interface InAppPurchaseLocalizationResponse {
  data: InAppPurchaseLocalization;
  included?: InAppPurchaseV2[];
  links: DocumentLinks;
}

/** InAppPurchaseLocalizationCreateRequest */
export interface InAppPurchaseLocalizationCreateRequest {
  data: {
    type: "inAppPurchaseLocalizations";
    attributes: {
      name: string;
      locale: string;
      description?: string;
    };
    relationships: {
      inAppPurchaseV2: {
        data: {
          type: "inAppPurchases";
          id: string;
        };
      };
    };
  };
}

/** InAppPurchaseLocalizationUpdateRequest */
export interface InAppPurchaseLocalizationUpdateRequest {
  data: {
    type: "inAppPurchaseLocalizations";
    id: string;
    attributes?: {
      name?: string;
      description?: string;
    };
  };
}

/** InAppPurchasePricePoint */
export interface InAppPurchasePricePoint {
  type: "inAppPurchasePricePoints";
  id: string;
  attributes?: {
    customerPrice?: string;
    proceeds?: string;
    /** @deprecated */
    priceTier?: string;
  };
  relationships?: {
    territory?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "territories";
        id: string;
      };
    };
  };
  links?: ResourceLinks;
}

/** InAppPurchasePricePointsResponse */
export interface InAppPurchasePricePointsResponse {
  data: InAppPurchasePricePoint[];
  included?: Territory[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** InAppPurchasePriceSchedule */
export interface InAppPurchasePriceSchedule {
  type: "inAppPurchasePriceSchedules";
  id: string;
  relationships?: {
    inAppPurchase?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "inAppPurchases";
        id: string;
      };
    };
    baseTerritory?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "territories";
        id: string;
      };
    };
    manualPrices?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "inAppPurchasePrices";
        id: string;
      }[];
    };
    automaticPrices?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "inAppPurchasePrices";
        id: string;
      }[];
    };
  };
  links?: ResourceLinks;
}

/** InAppPurchasePriceScheduleResponse */
export interface InAppPurchasePriceScheduleResponse {
  data: InAppPurchasePriceSchedule;
  included?: (InAppPurchaseV2 | Territory | InAppPurchasePrice)[];
  links: DocumentLinks;
}

/** InAppPurchasePriceScheduleCreateRequest */
export interface InAppPurchasePriceScheduleCreateRequest {
  data: {
    type: "inAppPurchasePriceSchedules";
    relationships: {
      inAppPurchase: {
        data: {
          type: "inAppPurchases";
          id: string;
        };
      };
      baseTerritory: {
        data: {
          type: "territories";
          id: string;
        };
      };
      manualPrices: {
        data: {
          type: "inAppPurchasePrices";
          id: string;
        }[];
      };
    };
  };
  included?: (InAppPurchasePriceInlineCreate | TerritoryInlineCreate)[];
}

/** InAppPurchasePrice */
export interface InAppPurchasePrice {
  type: "inAppPurchasePrices";
  id: string;
  attributes?: {
    /** @format date */
    startDate?: string;
    /** @format date */
    endDate?: string;
    manual?: boolean;
  };
  relationships?: {
    inAppPurchasePricePoint?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "inAppPurchasePricePoints";
        id: string;
      };
    };
    territory?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "territories";
        id: string;
      };
    };
  };
  links?: ResourceLinks;
}

export interface InAppPurchasePriceInlineCreate {
  type: "inAppPurchasePrices";
  id?: string;
  attributes?: {
    /** @format date */
    startDate?: string;
    /** @format date */
    endDate?: string;
  };
  relationships?: {
    inAppPurchaseV2?: {
      data?: {
        type: "inAppPurchases";
        id: string;
      };
    };
    inAppPurchasePricePoint?: {
      data?: {
        type: "inAppPurchasePricePoints";
        id: string;
      };
    };
  };
}

/** InAppPurchasePricesResponse */
export interface InAppPurchasePricesResponse {
  data: InAppPurchasePrice[];
  included?: (InAppPurchasePricePoint | Territory)[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** InAppPurchaseSubmission */
export interface InAppPurchaseSubmission {
  type: "inAppPurchaseSubmissions";
  id: string;
  relationships?: {
    inAppPurchaseV2?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "inAppPurchases";
        id: string;
      };
    };
  };
  links?: ResourceLinks;
}

/** InAppPurchaseSubmissionResponse */
export interface InAppPurchaseSubmissionResponse {
  data: InAppPurchaseSubmission;
  included?: InAppPurchaseV2[];
  links: DocumentLinks;
}

/** InAppPurchaseSubmissionCreateRequest */
export interface InAppPurchaseSubmissionCreateRequest {
  data: {
    type: "inAppPurchaseSubmissions";
    relationships: {
      inAppPurchaseV2: {
        data: {
          type: "inAppPurchases";
          id: string;
        };
      };
    };
  };
}

/**
 * InAppPurchase
 * @deprecated
 */
export interface InAppPurchase {
  type: "inAppPurchases";
  id: string;
  attributes?: {
    referenceName?: string;
    productId?: string;
    inAppPurchaseType?:
      | "AUTOMATICALLY_RENEWABLE_SUBSCRIPTION"
      | "NON_CONSUMABLE"
      | "CONSUMABLE"
      | "NON_RENEWING_SUBSCRIPTION"
      | "FREE_SUBSCRIPTION";
    state?:
      | "CREATED"
      | "DEVELOPER_SIGNED_OFF"
      | "DEVELOPER_ACTION_NEEDED"
      | "DELETION_IN_PROGRESS"
      | "APPROVED"
      | "DELETED"
      | "REMOVED_FROM_SALE"
      | "DEVELOPER_REMOVED_FROM_SALE"
      | "WAITING_FOR_UPLOAD"
      | "PROCESSING_CONTENT"
      | "REPLACED"
      | "REJECTED"
      | "WAITING_FOR_SCREENSHOT"
      | "PREPARE_FOR_SUBMISSION"
      | "MISSING_METADATA"
      | "READY_TO_SUBMIT"
      | "WAITING_FOR_REVIEW"
      | "IN_REVIEW"
      | "PENDING_DEVELOPER_RELEASE";
  };
  relationships?: {
    apps?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "apps";
        id: string;
      }[];
    };
  };
  links?: ResourceLinks;
}

/**
 * InAppPurchasesResponse
 * @deprecated
 */
export interface InAppPurchasesResponse {
  data: InAppPurchase[];
  included?: App[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/**
 * InAppPurchaseResponse
 * @deprecated
 */
export interface InAppPurchaseResponse {
  data: InAppPurchase;
  included?: App[];
  links: DocumentLinks;
}

/** InAppPurchaseV2 */
export interface InAppPurchaseV2 {
  type: "inAppPurchases";
  id: string;
  attributes?: {
    name?: string;
    productId?: string;
    inAppPurchaseType?: InAppPurchaseType;
    state?: InAppPurchaseState;
    reviewNote?: string;
    familySharable?: boolean;
    contentHosting?: boolean;
  };
  relationships?: {
    inAppPurchaseLocalizations?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "inAppPurchaseLocalizations";
        id: string;
      }[];
    };
    pricePoints?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "inAppPurchasePricePoints";
        id: string;
      }[];
    };
    content?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "inAppPurchaseContents";
        id: string;
      };
    };
    appStoreReviewScreenshot?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "inAppPurchaseAppStoreReviewScreenshots";
        id: string;
      };
    };
    promotedPurchase?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "promotedPurchases";
        id: string;
      };
    };
    iapPriceSchedule?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "inAppPurchasePriceSchedules";
        id: string;
      };
    };
    inAppPurchaseAvailability?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "inAppPurchaseAvailabilities";
        id: string;
      };
    };
  };
  links?: ResourceLinks;
}

/** InAppPurchasesV2Response */
export interface InAppPurchasesV2Response {
  data: InAppPurchaseV2[];
  included?: (
    | InAppPurchaseLocalization
    | InAppPurchasePricePoint
    | InAppPurchaseContent
    | InAppPurchaseAppStoreReviewScreenshot
    | PromotedPurchase
    | InAppPurchasePriceSchedule
    | InAppPurchaseAvailability
  )[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** InAppPurchaseV2Response */
export interface InAppPurchaseV2Response {
  data: InAppPurchaseV2;
  included?: (
    | InAppPurchaseLocalization
    | InAppPurchasePricePoint
    | InAppPurchaseContent
    | InAppPurchaseAppStoreReviewScreenshot
    | PromotedPurchase
    | InAppPurchasePriceSchedule
    | InAppPurchaseAvailability
  )[];
  links: DocumentLinks;
}

/** InAppPurchaseV2CreateRequest */
export interface InAppPurchaseV2CreateRequest {
  data: {
    type: "inAppPurchases";
    attributes: {
      name: string;
      productId: string;
      inAppPurchaseType: InAppPurchaseType;
      reviewNote?: string;
      familySharable?: boolean;
    };
    relationships: {
      app: {
        data: {
          type: "apps";
          id: string;
        };
      };
    };
  };
}

/** InAppPurchaseV2UpdateRequest */
export interface InAppPurchaseV2UpdateRequest {
  data: {
    type: "inAppPurchases";
    id: string;
    attributes?: {
      name?: string;
      reviewNote?: string;
      familySharable?: boolean;
    };
  };
}

/**
 * MarketplaceDomain
 * @deprecated
 */
export interface MarketplaceDomain {
  type: "marketplaceDomains";
  id: string;
  attributes?: {
    domain?: string;
    referenceName?: string;
    /** @format date-time */
    createdDate?: string;
  };
  links?: ResourceLinks;
}

/**
 * MarketplaceDomainsResponse
 * @deprecated
 */
export interface MarketplaceDomainsResponse {
  data: MarketplaceDomain[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/**
 * MarketplaceDomainResponse
 * @deprecated
 */
export interface MarketplaceDomainResponse {
  data: MarketplaceDomain;
  links: DocumentLinks;
}

/**
 * MarketplaceDomainCreateRequest
 * @deprecated
 */
export interface MarketplaceDomainCreateRequest {
  data: {
    type: "marketplaceDomains";
    attributes: {
      domain: string;
      referenceName: string;
    };
  };
}

/** MarketplaceSearchDetail */
export interface MarketplaceSearchDetail {
  type: "marketplaceSearchDetails";
  id: string;
  attributes?: {
    /** @format uri */
    catalogUrl?: string;
  };
  links?: ResourceLinks;
}

/** MarketplaceSearchDetailResponse */
export interface MarketplaceSearchDetailResponse {
  data: MarketplaceSearchDetail;
  links: DocumentLinks;
}

/** MarketplaceSearchDetailCreateRequest */
export interface MarketplaceSearchDetailCreateRequest {
  data: {
    type: "marketplaceSearchDetails";
    attributes: {
      /** @format uri */
      catalogUrl: string;
    };
    relationships: {
      app: {
        data: {
          type: "apps";
          id: string;
        };
      };
    };
  };
}

/** MarketplaceSearchDetailUpdateRequest */
export interface MarketplaceSearchDetailUpdateRequest {
  data: {
    type: "marketplaceSearchDetails";
    id: string;
    attributes?: {
      /** @format uri */
      catalogUrl?: string;
    };
  };
}

/** MarketplaceWebhook */
export interface MarketplaceWebhook {
  type: "marketplaceWebhooks";
  id: string;
  attributes?: {
    /** @format uri */
    endpointUrl?: string;
  };
  links?: ResourceLinks;
}

/** MarketplaceWebhooksResponse */
export interface MarketplaceWebhooksResponse {
  data: MarketplaceWebhook[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** MarketplaceWebhookResponse */
export interface MarketplaceWebhookResponse {
  data: MarketplaceWebhook;
  links: DocumentLinks;
}

/** MarketplaceWebhookCreateRequest */
export interface MarketplaceWebhookCreateRequest {
  data: {
    type: "marketplaceWebhooks";
    attributes: {
      /** @format uri */
      endpointUrl: string;
      secret: string;
    };
  };
}

/** MarketplaceWebhookUpdateRequest */
export interface MarketplaceWebhookUpdateRequest {
  data: {
    type: "marketplaceWebhooks";
    id: string;
    attributes?: {
      /** @format uri */
      endpointUrl?: string;
      secret?: string;
    };
  };
}

/** PerfPowerMetric */
export interface PerfPowerMetric {
  type: "perfPowerMetrics";
  id: string;
  attributes?: {
    platform?: "IOS";
    metricType?: "DISK" | "HANG" | "BATTERY" | "LAUNCH" | "MEMORY" | "ANIMATION" | "TERMINATION";
    deviceType?: string;
  };
  links?: ResourceLinks;
}

/** PrereleaseVersion */
export interface PrereleaseVersion {
  type: "preReleaseVersions";
  id: string;
  attributes?: {
    version?: string;
    platform?: Platform;
  };
  relationships?: {
    builds?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "builds";
        id: string;
      }[];
    };
    app?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "apps";
        id: string;
      };
    };
  };
  links?: ResourceLinks;
}

/** PreReleaseVersionsResponse */
export interface PreReleaseVersionsResponse {
  data: PrereleaseVersion[];
  included?: (Build | App)[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** PrereleaseVersionResponse */
export interface PrereleaseVersionResponse {
  data: PrereleaseVersion;
  included?: (Build | App)[];
  links: DocumentLinks;
}

/** Profile */
export interface Profile {
  type: "profiles";
  id: string;
  attributes?: {
    name?: string;
    platform?: BundleIdPlatform;
    profileType?:
      | "IOS_APP_DEVELOPMENT"
      | "IOS_APP_STORE"
      | "IOS_APP_ADHOC"
      | "IOS_APP_INHOUSE"
      | "MAC_APP_DEVELOPMENT"
      | "MAC_APP_STORE"
      | "MAC_APP_DIRECT"
      | "TVOS_APP_DEVELOPMENT"
      | "TVOS_APP_STORE"
      | "TVOS_APP_ADHOC"
      | "TVOS_APP_INHOUSE"
      | "MAC_CATALYST_APP_DEVELOPMENT"
      | "MAC_CATALYST_APP_STORE"
      | "MAC_CATALYST_APP_DIRECT";
    profileState?: "ACTIVE" | "INVALID";
    profileContent?: string;
    uuid?: string;
    /** @format date-time */
    createdDate?: string;
    /** @format date-time */
    expirationDate?: string;
  };
  relationships?: {
    bundleId?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "bundleIds";
        id: string;
      };
    };
    devices?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "devices";
        id: string;
      }[];
    };
    certificates?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "certificates";
        id: string;
      }[];
    };
  };
  links?: ResourceLinks;
}

/** ProfilesResponse */
export interface ProfilesResponse {
  data: Profile[];
  included?: (BundleId | Device | Certificate)[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** ProfileResponse */
export interface ProfileResponse {
  data: Profile;
  included?: (BundleId | Device | Certificate)[];
  links: DocumentLinks;
}

/** ProfileCreateRequest */
export interface ProfileCreateRequest {
  data: {
    type: "profiles";
    attributes: {
      name: string;
      profileType:
        | "IOS_APP_DEVELOPMENT"
        | "IOS_APP_STORE"
        | "IOS_APP_ADHOC"
        | "IOS_APP_INHOUSE"
        | "MAC_APP_DEVELOPMENT"
        | "MAC_APP_STORE"
        | "MAC_APP_DIRECT"
        | "TVOS_APP_DEVELOPMENT"
        | "TVOS_APP_STORE"
        | "TVOS_APP_ADHOC"
        | "TVOS_APP_INHOUSE"
        | "MAC_CATALYST_APP_DEVELOPMENT"
        | "MAC_CATALYST_APP_STORE"
        | "MAC_CATALYST_APP_DIRECT";
    };
    relationships: {
      bundleId: {
        data: {
          type: "bundleIds";
          id: string;
        };
      };
      devices?: {
        data?: {
          type: "devices";
          id: string;
        }[];
      };
      certificates: {
        data: {
          type: "certificates";
          id: string;
        }[];
      };
    };
  };
}

/** PromotedPurchaseImage */
export interface PromotedPurchaseImage {
  type: "promotedPurchaseImages";
  id: string;
  attributes?: {
    fileSize?: number;
    fileName?: string;
    sourceFileChecksum?: string;
    assetToken?: string;
    imageAsset?: ImageAsset;
    assetType?: string;
    uploadOperations?: UploadOperation[];
    state?:
      | "AWAITING_UPLOAD"
      | "UPLOAD_COMPLETE"
      | "FAILED"
      | "PREPARE_FOR_SUBMISSION"
      | "WAITING_FOR_REVIEW"
      | "APPROVED"
      | "REJECTED";
  };
  relationships?: {
    promotedPurchase?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "promotedPurchases";
        id: string;
      };
    };
  };
  links?: ResourceLinks;
}

/** PromotedPurchaseImagesResponse */
export interface PromotedPurchaseImagesResponse {
  data: PromotedPurchaseImage[];
  included?: PromotedPurchase[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** PromotedPurchaseImageResponse */
export interface PromotedPurchaseImageResponse {
  data: PromotedPurchaseImage;
  included?: PromotedPurchase[];
  links: DocumentLinks;
}

/** PromotedPurchaseImageCreateRequest */
export interface PromotedPurchaseImageCreateRequest {
  data: {
    type: "promotedPurchaseImages";
    attributes: {
      fileSize: number;
      fileName: string;
    };
    relationships: {
      promotedPurchase: {
        data: {
          type: "promotedPurchases";
          id: string;
        };
      };
    };
  };
}

/** PromotedPurchaseImageUpdateRequest */
export interface PromotedPurchaseImageUpdateRequest {
  data: {
    type: "promotedPurchaseImages";
    id: string;
    attributes?: {
      sourceFileChecksum?: string;
      uploaded?: boolean;
    };
  };
}

/** PromotedPurchase */
export interface PromotedPurchase {
  type: "promotedPurchases";
  id: string;
  attributes?: {
    visibleForAllUsers?: boolean;
    enabled?: boolean;
    state?: "APPROVED" | "IN_REVIEW" | "PREPARE_FOR_SUBMISSION" | "REJECTED";
  };
  relationships?: {
    inAppPurchaseV2?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "inAppPurchases";
        id: string;
      };
    };
    subscription?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "subscriptions";
        id: string;
      };
    };
    promotionImages?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "promotedPurchaseImages";
        id: string;
      }[];
    };
  };
  links?: ResourceLinks;
}

/** PromotedPurchasesResponse */
export interface PromotedPurchasesResponse {
  data: PromotedPurchase[];
  included?: (InAppPurchaseV2 | Subscription | PromotedPurchaseImage)[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** PromotedPurchaseResponse */
export interface PromotedPurchaseResponse {
  data: PromotedPurchase;
  included?: (InAppPurchaseV2 | Subscription | PromotedPurchaseImage)[];
  links: DocumentLinks;
}

/** PromotedPurchaseCreateRequest */
export interface PromotedPurchaseCreateRequest {
  data: {
    type: "promotedPurchases";
    attributes: {
      visibleForAllUsers: boolean;
      enabled?: boolean;
    };
    relationships: {
      app: {
        data: {
          type: "apps";
          id: string;
        };
      };
      inAppPurchaseV2?: {
        data?: {
          type: "inAppPurchases";
          id: string;
        };
      };
      subscription?: {
        data?: {
          type: "subscriptions";
          id: string;
        };
      };
    };
  };
}

/** PromotedPurchaseUpdateRequest */
export interface PromotedPurchaseUpdateRequest {
  data: {
    type: "promotedPurchases";
    id: string;
    attributes?: {
      visibleForAllUsers?: boolean;
      enabled?: boolean;
    };
  };
}

/** ReviewSubmissionItem */
export interface ReviewSubmissionItem {
  type: "reviewSubmissionItems";
  id: string;
  attributes?: {
    state?: "READY_FOR_REVIEW" | "ACCEPTED" | "APPROVED" | "REJECTED" | "REMOVED";
  };
  relationships?: {
    appStoreVersion?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "appStoreVersions";
        id: string;
      };
    };
    appCustomProductPageVersion?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "appCustomProductPageVersions";
        id: string;
      };
    };
    appStoreVersionExperiment?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "appStoreVersionExperiments";
        id: string;
      };
    };
    appStoreVersionExperimentV2?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "appStoreVersionExperiments";
        id: string;
      };
    };
    appEvent?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "appEvents";
        id: string;
      };
    };
  };
  links?: ResourceLinks;
}

/** ReviewSubmissionItemsResponse */
export interface ReviewSubmissionItemsResponse {
  data: ReviewSubmissionItem[];
  included?: (
    | AppStoreVersion
    | AppCustomProductPageVersion
    | AppStoreVersionExperiment
    | AppStoreVersionExperimentV2
    | AppEvent
  )[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** ReviewSubmissionItemResponse */
export interface ReviewSubmissionItemResponse {
  data: ReviewSubmissionItem;
  included?: (
    | AppStoreVersion
    | AppCustomProductPageVersion
    | AppStoreVersionExperiment
    | AppStoreVersionExperimentV2
    | AppEvent
  )[];
  links: DocumentLinks;
}

/** ReviewSubmissionItemCreateRequest */
export interface ReviewSubmissionItemCreateRequest {
  data: {
    type: "reviewSubmissionItems";
    relationships: {
      reviewSubmission: {
        data: {
          type: "reviewSubmissions";
          id: string;
        };
      };
      appStoreVersion?: {
        data?: {
          type: "appStoreVersions";
          id: string;
        };
      };
      appCustomProductPageVersion?: {
        data?: {
          type: "appCustomProductPageVersions";
          id: string;
        };
      };
      appStoreVersionExperiment?: {
        data?: {
          type: "appStoreVersionExperiments";
          id: string;
        };
      };
      appStoreVersionExperimentV2?: {
        data?: {
          type: "appStoreVersionExperiments";
          id: string;
        };
      };
      appEvent?: {
        data?: {
          type: "appEvents";
          id: string;
        };
      };
    };
  };
}

/** ReviewSubmissionItemUpdateRequest */
export interface ReviewSubmissionItemUpdateRequest {
  data: {
    type: "reviewSubmissionItems";
    id: string;
    attributes?: {
      resolved?: boolean;
      removed?: boolean;
    };
  };
}

/** ReviewSubmission */
export interface ReviewSubmission {
  type: "reviewSubmissions";
  id: string;
  attributes?: {
    platform?: Platform;
    /** @format date-time */
    submittedDate?: string;
    state?:
      | "READY_FOR_REVIEW"
      | "WAITING_FOR_REVIEW"
      | "IN_REVIEW"
      | "UNRESOLVED_ISSUES"
      | "CANCELING"
      | "COMPLETING"
      | "COMPLETE";
  };
  relationships?: {
    app?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "apps";
        id: string;
      };
    };
    items?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "reviewSubmissionItems";
        id: string;
      }[];
    };
    appStoreVersionForReview?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "appStoreVersions";
        id: string;
      };
    };
    submittedByActor?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "actors";
        id: string;
      };
    };
    lastUpdatedByActor?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "actors";
        id: string;
      };
    };
  };
  links?: ResourceLinks;
}

/** ReviewSubmissionsResponse */
export interface ReviewSubmissionsResponse {
  data: ReviewSubmission[];
  included?: (App | ReviewSubmissionItem | AppStoreVersion | Actor)[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** ReviewSubmissionResponse */
export interface ReviewSubmissionResponse {
  data: ReviewSubmission;
  included?: (App | ReviewSubmissionItem | AppStoreVersion | Actor)[];
  links: DocumentLinks;
}

/** ReviewSubmissionCreateRequest */
export interface ReviewSubmissionCreateRequest {
  data: {
    type: "reviewSubmissions";
    attributes: {
      platform: Platform;
    };
    relationships: {
      app: {
        data: {
          type: "apps";
          id: string;
        };
      };
    };
  };
}

/** ReviewSubmissionUpdateRequest */
export interface ReviewSubmissionUpdateRequest {
  data: {
    type: "reviewSubmissions";
    id: string;
    attributes?: {
      submitted?: boolean;
      canceled?: boolean;
    };
  };
}

/** RoutingAppCoverage */
export interface RoutingAppCoverage {
  type: "routingAppCoverages";
  id: string;
  attributes?: {
    fileSize?: number;
    fileName?: string;
    sourceFileChecksum?: string;
    uploadOperations?: UploadOperation[];
    assetDeliveryState?: AppMediaAssetState;
  };
  relationships?: {
    appStoreVersion?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "appStoreVersions";
        id: string;
      };
    };
  };
  links?: ResourceLinks;
}

/** RoutingAppCoverageResponse */
export interface RoutingAppCoverageResponse {
  data: RoutingAppCoverage;
  included?: AppStoreVersion[];
  links: DocumentLinks;
}

/** RoutingAppCoverageCreateRequest */
export interface RoutingAppCoverageCreateRequest {
  data: {
    type: "routingAppCoverages";
    attributes: {
      fileSize: number;
      fileName: string;
    };
    relationships: {
      appStoreVersion: {
        data: {
          type: "appStoreVersions";
          id: string;
        };
      };
    };
  };
}

/** RoutingAppCoverageUpdateRequest */
export interface RoutingAppCoverageUpdateRequest {
  data: {
    type: "routingAppCoverages";
    id: string;
    attributes?: {
      sourceFileChecksum?: string;
      uploaded?: boolean;
    };
  };
}

/** SandboxTesterV2 */
export interface SandboxTesterV2 {
  type: "sandboxTesters";
  id: string;
  attributes?: {
    firstName?: string;
    lastName?: string;
    acAccountName?: string;
    territory?: TerritoryCode;
    applePayCompatible?: boolean;
    interruptPurchases?: boolean;
    subscriptionRenewalRate?:
      | "MONTHLY_RENEWAL_EVERY_ONE_HOUR"
      | "MONTHLY_RENEWAL_EVERY_THIRTY_MINUTES"
      | "MONTHLY_RENEWAL_EVERY_FIFTEEN_MINUTES"
      | "MONTHLY_RENEWAL_EVERY_FIVE_MINUTES"
      | "MONTHLY_RENEWAL_EVERY_THREE_MINUTES";
  };
  links?: ResourceLinks;
}

/** SandboxTestersV2Response */
export interface SandboxTestersV2Response {
  data: SandboxTesterV2[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** SandboxTesterV2Response */
export interface SandboxTesterV2Response {
  data: SandboxTesterV2;
  links: DocumentLinks;
}

/** SandboxTesterV2UpdateRequest */
export interface SandboxTesterV2UpdateRequest {
  data: {
    type: "sandboxTesters";
    id: string;
    attributes?: {
      territory?: TerritoryCode;
      interruptPurchases?: boolean;
      subscriptionRenewalRate?:
        | "MONTHLY_RENEWAL_EVERY_ONE_HOUR"
        | "MONTHLY_RENEWAL_EVERY_THIRTY_MINUTES"
        | "MONTHLY_RENEWAL_EVERY_FIFTEEN_MINUTES"
        | "MONTHLY_RENEWAL_EVERY_FIVE_MINUTES"
        | "MONTHLY_RENEWAL_EVERY_THREE_MINUTES";
    };
  };
}

/** SandboxTestersClearPurchaseHistoryRequestV2 */
export interface SandboxTestersClearPurchaseHistoryRequestV2 {
  type: "sandboxTestersClearPurchaseHistoryRequest";
  id: string;
  links?: ResourceLinks;
}

/** SandboxTestersClearPurchaseHistoryRequestV2Response */
export interface SandboxTestersClearPurchaseHistoryRequestV2Response {
  data: SandboxTestersClearPurchaseHistoryRequestV2;
  links: DocumentLinks;
}

/** SandboxTestersClearPurchaseHistoryRequestV2CreateRequest */
export interface SandboxTestersClearPurchaseHistoryRequestV2CreateRequest {
  data: {
    type: "sandboxTestersClearPurchaseHistoryRequest";
    relationships: {
      sandboxTesters: {
        data: {
          type: "sandboxTesters";
          id: string;
        }[];
      };
    };
  };
}

/** ScmGitReference */
export interface ScmGitReference {
  type: "scmGitReferences";
  id: string;
  attributes?: {
    name?: string;
    canonicalName?: string;
    isDeleted?: boolean;
    kind?: CiGitRefKind;
  };
  relationships?: {
    repository?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "scmRepositories";
        id: string;
      };
    };
  };
  links?: ResourceLinks;
}

/** ScmGitReferencesResponse */
export interface ScmGitReferencesResponse {
  data: ScmGitReference[];
  included?: ScmRepository[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** ScmGitReferenceResponse */
export interface ScmGitReferenceResponse {
  data: ScmGitReference;
  included?: ScmRepository[];
  links: DocumentLinks;
}

/** ScmProvider */
export interface ScmProvider {
  type: "scmProviders";
  id: string;
  attributes?: {
    scmProviderType?: ScmProviderType;
    /** @format uri */
    url?: string;
  };
  links?: ResourceLinks;
}

/** ScmProvidersResponse */
export interface ScmProvidersResponse {
  data: ScmProvider[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** ScmProviderResponse */
export interface ScmProviderResponse {
  data: ScmProvider;
  links: DocumentLinks;
}

/** ScmPullRequest */
export interface ScmPullRequest {
  type: "scmPullRequests";
  id: string;
  attributes?: {
    title?: string;
    number?: number;
    /** @format uri */
    webUrl?: string;
    sourceRepositoryOwner?: string;
    sourceRepositoryName?: string;
    sourceBranchName?: string;
    destinationRepositoryOwner?: string;
    destinationRepositoryName?: string;
    destinationBranchName?: string;
    isClosed?: boolean;
    isCrossRepository?: boolean;
  };
  relationships?: {
    repository?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "scmRepositories";
        id: string;
      };
    };
  };
  links?: ResourceLinks;
}

/** ScmPullRequestsResponse */
export interface ScmPullRequestsResponse {
  data: ScmPullRequest[];
  included?: ScmRepository[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** ScmPullRequestResponse */
export interface ScmPullRequestResponse {
  data: ScmPullRequest;
  included?: ScmRepository[];
  links: DocumentLinks;
}

/** ScmRepository */
export interface ScmRepository {
  type: "scmRepositories";
  id: string;
  attributes?: {
    /** @format date-time */
    lastAccessedDate?: string;
    /** @format uri */
    httpCloneUrl?: string;
    /** @format uri */
    sshCloneUrl?: string;
    ownerName?: string;
    repositoryName?: string;
  };
  relationships?: {
    scmProvider?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "scmProviders";
        id: string;
      };
    };
    defaultBranch?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "scmGitReferences";
        id: string;
      };
    };
  };
  links?: ResourceLinks;
}

/** ScmRepositoriesResponse */
export interface ScmRepositoriesResponse {
  data: ScmRepository[];
  included?: (ScmProvider | ScmGitReference)[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** ScmRepositoryResponse */
export interface ScmRepositoryResponse {
  data: ScmRepository;
  included?: (ScmProvider | ScmGitReference)[];
  links: DocumentLinks;
}

/** SubscriptionAppStoreReviewScreenshot */
export interface SubscriptionAppStoreReviewScreenshot {
  type: "subscriptionAppStoreReviewScreenshots";
  id: string;
  attributes?: {
    fileSize?: number;
    fileName?: string;
    sourceFileChecksum?: string;
    imageAsset?: ImageAsset;
    assetToken?: string;
    assetType?: string;
    uploadOperations?: UploadOperation[];
    assetDeliveryState?: AppMediaAssetState;
  };
  relationships?: {
    subscription?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "subscriptions";
        id: string;
      };
    };
  };
  links?: ResourceLinks;
}

/** SubscriptionAppStoreReviewScreenshotResponse */
export interface SubscriptionAppStoreReviewScreenshotResponse {
  data: SubscriptionAppStoreReviewScreenshot;
  included?: Subscription[];
  links: DocumentLinks;
}

/** SubscriptionAppStoreReviewScreenshotCreateRequest */
export interface SubscriptionAppStoreReviewScreenshotCreateRequest {
  data: {
    type: "subscriptionAppStoreReviewScreenshots";
    attributes: {
      fileSize: number;
      fileName: string;
    };
    relationships: {
      subscription: {
        data: {
          type: "subscriptions";
          id: string;
        };
      };
    };
  };
}

/** SubscriptionAppStoreReviewScreenshotUpdateRequest */
export interface SubscriptionAppStoreReviewScreenshotUpdateRequest {
  data: {
    type: "subscriptionAppStoreReviewScreenshots";
    id: string;
    attributes?: {
      sourceFileChecksum?: string;
      uploaded?: boolean;
    };
  };
}

/** SubscriptionAvailability */
export interface SubscriptionAvailability {
  type: "subscriptionAvailabilities";
  id: string;
  attributes?: {
    availableInNewTerritories?: boolean;
  };
  relationships?: {
    subscription?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "subscriptions";
        id: string;
      };
    };
    availableTerritories?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "territories";
        id: string;
      }[];
    };
  };
  links?: ResourceLinks;
}

/** SubscriptionAvailabilityResponse */
export interface SubscriptionAvailabilityResponse {
  data: SubscriptionAvailability;
  included?: (Subscription | Territory)[];
  links: DocumentLinks;
}

/** SubscriptionAvailabilityCreateRequest */
export interface SubscriptionAvailabilityCreateRequest {
  data: {
    type: "subscriptionAvailabilities";
    attributes: {
      availableInNewTerritories: boolean;
    };
    relationships: {
      subscription: {
        data: {
          type: "subscriptions";
          id: string;
        };
      };
      availableTerritories: {
        data: {
          type: "territories";
          id: string;
        }[];
      };
    };
  };
}

/** SubscriptionGracePeriod */
export interface SubscriptionGracePeriod {
  type: "subscriptionGracePeriods";
  id: string;
  attributes?: {
    optIn?: boolean;
    sandboxOptIn?: boolean;
    duration?: SubscriptionGracePeriodDuration;
    renewalType?: "ALL_RENEWALS" | "PAID_TO_PAID_ONLY";
  };
  links?: ResourceLinks;
}

/** SubscriptionGracePeriodResponse */
export interface SubscriptionGracePeriodResponse {
  data: SubscriptionGracePeriod;
  links: DocumentLinks;
}

/** SubscriptionGracePeriodUpdateRequest */
export interface SubscriptionGracePeriodUpdateRequest {
  data: {
    type: "subscriptionGracePeriods";
    id: string;
    attributes?: {
      optIn?: boolean;
      sandboxOptIn?: boolean;
      duration?: SubscriptionGracePeriodDuration;
      renewalType?: "ALL_RENEWALS" | "PAID_TO_PAID_ONLY";
    };
  };
}

/** SubscriptionGroupLocalization */
export interface SubscriptionGroupLocalization {
  type: "subscriptionGroupLocalizations";
  id: string;
  attributes?: {
    name?: string;
    customAppName?: string;
    locale?: string;
    state?: "PREPARE_FOR_SUBMISSION" | "WAITING_FOR_REVIEW" | "APPROVED" | "REJECTED";
  };
  relationships?: {
    subscriptionGroup?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "subscriptionGroups";
        id: string;
      };
    };
  };
  links?: ResourceLinks;
}

/** SubscriptionGroupLocalizationsResponse */
export interface SubscriptionGroupLocalizationsResponse {
  data: SubscriptionGroupLocalization[];
  included?: SubscriptionGroup[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** SubscriptionGroupLocalizationResponse */
export interface SubscriptionGroupLocalizationResponse {
  data: SubscriptionGroupLocalization;
  included?: SubscriptionGroup[];
  links: DocumentLinks;
}

/** SubscriptionGroupLocalizationCreateRequest */
export interface SubscriptionGroupLocalizationCreateRequest {
  data: {
    type: "subscriptionGroupLocalizations";
    attributes: {
      name: string;
      customAppName?: string;
      locale: string;
    };
    relationships: {
      subscriptionGroup: {
        data: {
          type: "subscriptionGroups";
          id: string;
        };
      };
    };
  };
}

/** SubscriptionGroupLocalizationUpdateRequest */
export interface SubscriptionGroupLocalizationUpdateRequest {
  data: {
    type: "subscriptionGroupLocalizations";
    id: string;
    attributes?: {
      name?: string;
      customAppName?: string;
    };
  };
}

/** SubscriptionGroupSubmission */
export interface SubscriptionGroupSubmission {
  type: "subscriptionGroupSubmissions";
  id: string;
  links?: ResourceLinks;
}

/** SubscriptionGroupSubmissionResponse */
export interface SubscriptionGroupSubmissionResponse {
  data: SubscriptionGroupSubmission;
  links: DocumentLinks;
}

/** SubscriptionGroupSubmissionCreateRequest */
export interface SubscriptionGroupSubmissionCreateRequest {
  data: {
    type: "subscriptionGroupSubmissions";
    relationships: {
      subscriptionGroup: {
        data: {
          type: "subscriptionGroups";
          id: string;
        };
      };
    };
  };
}

/** SubscriptionGroup */
export interface SubscriptionGroup {
  type: "subscriptionGroups";
  id: string;
  attributes?: {
    referenceName?: string;
  };
  relationships?: {
    subscriptions?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "subscriptions";
        id: string;
      }[];
    };
    subscriptionGroupLocalizations?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "subscriptionGroupLocalizations";
        id: string;
      }[];
    };
  };
  links?: ResourceLinks;
}

/** SubscriptionGroupsResponse */
export interface SubscriptionGroupsResponse {
  data: SubscriptionGroup[];
  included?: (Subscription | SubscriptionGroupLocalization)[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** SubscriptionGroupResponse */
export interface SubscriptionGroupResponse {
  data: SubscriptionGroup;
  included?: (Subscription | SubscriptionGroupLocalization)[];
  links: DocumentLinks;
}

/** SubscriptionGroupCreateRequest */
export interface SubscriptionGroupCreateRequest {
  data: {
    type: "subscriptionGroups";
    attributes: {
      referenceName: string;
    };
    relationships: {
      app: {
        data: {
          type: "apps";
          id: string;
        };
      };
    };
  };
}

/** SubscriptionGroupUpdateRequest */
export interface SubscriptionGroupUpdateRequest {
  data: {
    type: "subscriptionGroups";
    id: string;
    attributes?: {
      referenceName?: string;
    };
  };
}

/** SubscriptionIntroductoryOffer */
export interface SubscriptionIntroductoryOffer {
  type: "subscriptionIntroductoryOffers";
  id: string;
  attributes?: {
    /** @format date */
    startDate?: string;
    /** @format date */
    endDate?: string;
    duration?: SubscriptionOfferDuration;
    offerMode?: SubscriptionOfferMode;
    numberOfPeriods?: number;
  };
  relationships?: {
    subscription?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "subscriptions";
        id: string;
      };
    };
    territory?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "territories";
        id: string;
      };
    };
    subscriptionPricePoint?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "subscriptionPricePoints";
        id: string;
      };
    };
  };
  links?: ResourceLinks;
}

export interface SubscriptionIntroductoryOfferInlineCreate {
  type: "subscriptionIntroductoryOffers";
  id?: string;
  attributes: {
    /** @format date */
    startDate?: string;
    /** @format date */
    endDate?: string;
    duration: SubscriptionOfferDuration;
    offerMode: SubscriptionOfferMode;
    numberOfPeriods: number;
  };
  relationships?: {
    subscription?: {
      data?: {
        type: "subscriptions";
        id: string;
      };
    };
    territory?: {
      data?: {
        type: "territories";
        id: string;
      };
    };
    subscriptionPricePoint?: {
      data?: {
        type: "subscriptionPricePoints";
        id: string;
      };
    };
  };
}

/** SubscriptionIntroductoryOffersResponse */
export interface SubscriptionIntroductoryOffersResponse {
  data: SubscriptionIntroductoryOffer[];
  included?: (Subscription | Territory | SubscriptionPricePoint)[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** SubscriptionIntroductoryOfferResponse */
export interface SubscriptionIntroductoryOfferResponse {
  data: SubscriptionIntroductoryOffer;
  included?: (Subscription | Territory | SubscriptionPricePoint)[];
  links: DocumentLinks;
}

/** SubscriptionIntroductoryOfferCreateRequest */
export interface SubscriptionIntroductoryOfferCreateRequest {
  data: {
    type: "subscriptionIntroductoryOffers";
    attributes: {
      /** @format date */
      startDate?: string;
      /** @format date */
      endDate?: string;
      duration: SubscriptionOfferDuration;
      offerMode: SubscriptionOfferMode;
      numberOfPeriods: number;
    };
    relationships: {
      subscription: {
        data: {
          type: "subscriptions";
          id: string;
        };
      };
      territory?: {
        data?: {
          type: "territories";
          id: string;
        };
      };
      subscriptionPricePoint?: {
        data?: {
          type: "subscriptionPricePoints";
          id: string;
        };
      };
    };
  };
  included?: SubscriptionPricePointInlineCreate[];
}

/** SubscriptionIntroductoryOfferUpdateRequest */
export interface SubscriptionIntroductoryOfferUpdateRequest {
  data: {
    type: "subscriptionIntroductoryOffers";
    id: string;
    attributes?: {
      /** @format date */
      endDate?: string;
    };
  };
}

/** SubscriptionLocalization */
export interface SubscriptionLocalization {
  type: "subscriptionLocalizations";
  id: string;
  attributes?: {
    name?: string;
    locale?: string;
    description?: string;
    state?: "PREPARE_FOR_SUBMISSION" | "WAITING_FOR_REVIEW" | "APPROVED" | "REJECTED";
  };
  relationships?: {
    subscription?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "subscriptions";
        id: string;
      };
    };
  };
  links?: ResourceLinks;
}

/** SubscriptionLocalizationsResponse */
export interface SubscriptionLocalizationsResponse {
  data: SubscriptionLocalization[];
  included?: Subscription[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** SubscriptionLocalizationResponse */
export interface SubscriptionLocalizationResponse {
  data: SubscriptionLocalization;
  included?: Subscription[];
  links: DocumentLinks;
}

/** SubscriptionLocalizationCreateRequest */
export interface SubscriptionLocalizationCreateRequest {
  data: {
    type: "subscriptionLocalizations";
    attributes: {
      name: string;
      locale: string;
      description?: string;
    };
    relationships: {
      subscription: {
        data: {
          type: "subscriptions";
          id: string;
        };
      };
    };
  };
}

/** SubscriptionLocalizationUpdateRequest */
export interface SubscriptionLocalizationUpdateRequest {
  data: {
    type: "subscriptionLocalizations";
    id: string;
    attributes?: {
      name?: string;
      description?: string;
    };
  };
}

/** SubscriptionOfferCodeCustomCode */
export interface SubscriptionOfferCodeCustomCode {
  type: "subscriptionOfferCodeCustomCodes";
  id: string;
  attributes?: {
    customCode?: string;
    numberOfCodes?: number;
    /** @format date-time */
    createdDate?: string;
    /** @format date */
    expirationDate?: string;
    active?: boolean;
  };
  relationships?: {
    offerCode?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "subscriptionOfferCodes";
        id: string;
      };
    };
  };
  links?: ResourceLinks;
}

/** SubscriptionOfferCodeCustomCodesResponse */
export interface SubscriptionOfferCodeCustomCodesResponse {
  data: SubscriptionOfferCodeCustomCode[];
  included?: SubscriptionOfferCode[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** SubscriptionOfferCodeCustomCodeResponse */
export interface SubscriptionOfferCodeCustomCodeResponse {
  data: SubscriptionOfferCodeCustomCode;
  included?: SubscriptionOfferCode[];
  links: DocumentLinks;
}

/** SubscriptionOfferCodeCustomCodeCreateRequest */
export interface SubscriptionOfferCodeCustomCodeCreateRequest {
  data: {
    type: "subscriptionOfferCodeCustomCodes";
    attributes: {
      customCode: string;
      numberOfCodes: number;
      /** @format date */
      expirationDate?: string;
    };
    relationships: {
      offerCode: {
        data: {
          type: "subscriptionOfferCodes";
          id: string;
        };
      };
    };
  };
}

/** SubscriptionOfferCodeCustomCodeUpdateRequest */
export interface SubscriptionOfferCodeCustomCodeUpdateRequest {
  data: {
    type: "subscriptionOfferCodeCustomCodes";
    id: string;
    attributes?: {
      active?: boolean;
    };
  };
}

/** SubscriptionOfferCodeOneTimeUseCodeValue */
export interface SubscriptionOfferCodeOneTimeUseCodeValue {
  type: "subscriptionOfferCodeOneTimeUseCodeValues";
  id: string;
  links?: ResourceLinks;
}

/** SubscriptionOfferCodeOneTimeUseCode */
export interface SubscriptionOfferCodeOneTimeUseCode {
  type: "subscriptionOfferCodeOneTimeUseCodes";
  id: string;
  attributes?: {
    numberOfCodes?: number;
    /** @format date-time */
    createdDate?: string;
    /** @format date */
    expirationDate?: string;
    active?: boolean;
  };
  relationships?: {
    offerCode?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "subscriptionOfferCodes";
        id: string;
      };
    };
  };
  links?: ResourceLinks;
}

/** SubscriptionOfferCodeOneTimeUseCodesResponse */
export interface SubscriptionOfferCodeOneTimeUseCodesResponse {
  data: SubscriptionOfferCodeOneTimeUseCode[];
  included?: SubscriptionOfferCode[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** SubscriptionOfferCodeOneTimeUseCodeResponse */
export interface SubscriptionOfferCodeOneTimeUseCodeResponse {
  data: SubscriptionOfferCodeOneTimeUseCode;
  included?: SubscriptionOfferCode[];
  links: DocumentLinks;
}

/** SubscriptionOfferCodeOneTimeUseCodeCreateRequest */
export interface SubscriptionOfferCodeOneTimeUseCodeCreateRequest {
  data: {
    type: "subscriptionOfferCodeOneTimeUseCodes";
    attributes: {
      numberOfCodes: number;
      /** @format date */
      expirationDate: string;
    };
    relationships: {
      offerCode: {
        data: {
          type: "subscriptionOfferCodes";
          id: string;
        };
      };
    };
  };
}

/** SubscriptionOfferCodeOneTimeUseCodeUpdateRequest */
export interface SubscriptionOfferCodeOneTimeUseCodeUpdateRequest {
  data: {
    type: "subscriptionOfferCodeOneTimeUseCodes";
    id: string;
    attributes?: {
      active?: boolean;
    };
  };
}

/** SubscriptionOfferCodePrice */
export interface SubscriptionOfferCodePrice {
  type: "subscriptionOfferCodePrices";
  id: string;
  relationships?: {
    territory?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "territories";
        id: string;
      };
    };
    subscriptionPricePoint?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "subscriptionPricePoints";
        id: string;
      };
    };
  };
  links?: ResourceLinks;
}

export interface SubscriptionOfferCodePriceInlineCreate {
  type: "subscriptionOfferCodePrices";
  id?: string;
  relationships?: {
    territory?: {
      data?: {
        type: "territories";
        id: string;
      };
    };
    subscriptionPricePoint?: {
      data?: {
        type: "subscriptionPricePoints";
        id: string;
      };
    };
  };
}

/** SubscriptionOfferCodePricesResponse */
export interface SubscriptionOfferCodePricesResponse {
  data: SubscriptionOfferCodePrice[];
  included?: (Territory | SubscriptionPricePoint)[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** SubscriptionOfferCode */
export interface SubscriptionOfferCode {
  type: "subscriptionOfferCodes";
  id: string;
  attributes?: {
    name?: string;
    customerEligibilities?: SubscriptionCustomerEligibility[];
    offerEligibility?: SubscriptionOfferEligibility;
    duration?: SubscriptionOfferDuration;
    offerMode?: SubscriptionOfferMode;
    numberOfPeriods?: number;
    totalNumberOfCodes?: number;
    active?: boolean;
  };
  relationships?: {
    subscription?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "subscriptions";
        id: string;
      };
    };
    oneTimeUseCodes?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "subscriptionOfferCodeOneTimeUseCodes";
        id: string;
      }[];
    };
    customCodes?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "subscriptionOfferCodeCustomCodes";
        id: string;
      }[];
    };
    prices?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "subscriptionOfferCodePrices";
        id: string;
      }[];
    };
  };
  links?: ResourceLinks;
}

/** SubscriptionOfferCodesResponse */
export interface SubscriptionOfferCodesResponse {
  data: SubscriptionOfferCode[];
  included?: (
    | Subscription
    | SubscriptionOfferCodeOneTimeUseCode
    | SubscriptionOfferCodeCustomCode
    | SubscriptionOfferCodePrice
  )[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** SubscriptionOfferCodeResponse */
export interface SubscriptionOfferCodeResponse {
  data: SubscriptionOfferCode;
  included?: (
    | Subscription
    | SubscriptionOfferCodeOneTimeUseCode
    | SubscriptionOfferCodeCustomCode
    | SubscriptionOfferCodePrice
  )[];
  links: DocumentLinks;
}

/** SubscriptionOfferCodeCreateRequest */
export interface SubscriptionOfferCodeCreateRequest {
  data: {
    type: "subscriptionOfferCodes";
    attributes: {
      name: string;
      customerEligibilities: SubscriptionCustomerEligibility[];
      offerEligibility: SubscriptionOfferEligibility;
      duration: SubscriptionOfferDuration;
      offerMode: SubscriptionOfferMode;
      numberOfPeriods: number;
    };
    relationships: {
      subscription: {
        data: {
          type: "subscriptions";
          id: string;
        };
      };
      prices: {
        data: {
          type: "subscriptionOfferCodePrices";
          id: string;
        }[];
      };
    };
  };
  included?: SubscriptionOfferCodePriceInlineCreate[];
}

/** SubscriptionOfferCodeUpdateRequest */
export interface SubscriptionOfferCodeUpdateRequest {
  data: {
    type: "subscriptionOfferCodes";
    id: string;
    attributes?: {
      active?: boolean;
    };
  };
}

/** SubscriptionPricePoint */
export interface SubscriptionPricePoint {
  type: "subscriptionPricePoints";
  id: string;
  attributes?: {
    customerPrice?: string;
    proceeds?: string;
    proceedsYear2?: string;
  };
  relationships?: {
    territory?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "territories";
        id: string;
      };
    };
  };
  links?: ResourceLinks;
}

export interface SubscriptionPricePointInlineCreate {
  type: "subscriptionPricePoints";
  id?: string;
}

/** SubscriptionPricePointsResponse */
export interface SubscriptionPricePointsResponse {
  data: SubscriptionPricePoint[];
  included?: Territory[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** SubscriptionPricePointResponse */
export interface SubscriptionPricePointResponse {
  data: SubscriptionPricePoint;
  included?: Territory[];
  links: DocumentLinks;
}

/** SubscriptionPrice */
export interface SubscriptionPrice {
  type: "subscriptionPrices";
  id: string;
  attributes?: {
    /** @format date */
    startDate?: string;
    preserved?: boolean;
  };
  relationships?: {
    territory?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "territories";
        id: string;
      };
    };
    subscriptionPricePoint?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "subscriptionPricePoints";
        id: string;
      };
    };
  };
  links?: ResourceLinks;
}

export interface SubscriptionPriceInlineCreate {
  type: "subscriptionPrices";
  id?: string;
  attributes?: {
    /** @format date */
    startDate?: string;
    preserveCurrentPrice?: boolean;
  };
  relationships?: {
    subscription?: {
      data?: {
        type: "subscriptions";
        id: string;
      };
    };
    territory?: {
      data?: {
        type: "territories";
        id: string;
      };
    };
    subscriptionPricePoint?: {
      data?: {
        type: "subscriptionPricePoints";
        id: string;
      };
    };
  };
}

/** SubscriptionPricesResponse */
export interface SubscriptionPricesResponse {
  data: SubscriptionPrice[];
  included?: (Territory | SubscriptionPricePoint)[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** SubscriptionPriceResponse */
export interface SubscriptionPriceResponse {
  data: SubscriptionPrice;
  included?: (Territory | SubscriptionPricePoint)[];
  links: DocumentLinks;
}

/** SubscriptionPriceCreateRequest */
export interface SubscriptionPriceCreateRequest {
  data: {
    type: "subscriptionPrices";
    attributes?: {
      /** @format date */
      startDate?: string;
      preserveCurrentPrice?: boolean;
    };
    relationships: {
      subscription: {
        data: {
          type: "subscriptions";
          id: string;
        };
      };
      territory?: {
        data?: {
          type: "territories";
          id: string;
        };
      };
      subscriptionPricePoint: {
        data: {
          type: "subscriptionPricePoints";
          id: string;
        };
      };
    };
  };
}

/** SubscriptionPromotionalOfferPrice */
export interface SubscriptionPromotionalOfferPrice {
  type: "subscriptionPromotionalOfferPrices";
  id: string;
  relationships?: {
    territory?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "territories";
        id: string;
      };
    };
    subscriptionPricePoint?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "subscriptionPricePoints";
        id: string;
      };
    };
  };
  links?: ResourceLinks;
}

export interface SubscriptionPromotionalOfferPriceInlineCreate {
  type: "subscriptionPromotionalOfferPrices";
  id?: string;
  relationships?: {
    territory?: {
      data?: {
        type: "territories";
        id: string;
      };
    };
    subscriptionPricePoint?: {
      data?: {
        type: "subscriptionPricePoints";
        id: string;
      };
    };
  };
}

/** SubscriptionPromotionalOfferPricesResponse */
export interface SubscriptionPromotionalOfferPricesResponse {
  data: SubscriptionPromotionalOfferPrice[];
  included?: (Territory | SubscriptionPricePoint)[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** SubscriptionPromotionalOffer */
export interface SubscriptionPromotionalOffer {
  type: "subscriptionPromotionalOffers";
  id: string;
  attributes?: {
    name?: string;
    offerCode?: string;
    duration?: SubscriptionOfferDuration;
    offerMode?: SubscriptionOfferMode;
    numberOfPeriods?: number;
  };
  relationships?: {
    subscription?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "subscriptions";
        id: string;
      };
    };
    prices?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "subscriptionPromotionalOfferPrices";
        id: string;
      }[];
    };
  };
  links?: ResourceLinks;
}

export interface SubscriptionPromotionalOfferInlineCreate {
  type: "subscriptionPromotionalOffers";
  id?: string;
  attributes: {
    name: string;
    offerCode: string;
    duration: SubscriptionOfferDuration;
    offerMode: SubscriptionOfferMode;
    numberOfPeriods: number;
  };
  relationships?: {
    subscription?: {
      data?: {
        type: "subscriptions";
        id: string;
      };
    };
    prices?: {
      data?: {
        type: "subscriptionPromotionalOfferPrices";
        id: string;
      }[];
    };
  };
}

/** SubscriptionPromotionalOffersResponse */
export interface SubscriptionPromotionalOffersResponse {
  data: SubscriptionPromotionalOffer[];
  included?: (Subscription | SubscriptionPromotionalOfferPrice)[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** SubscriptionPromotionalOfferResponse */
export interface SubscriptionPromotionalOfferResponse {
  data: SubscriptionPromotionalOffer;
  included?: (Subscription | SubscriptionPromotionalOfferPrice)[];
  links: DocumentLinks;
}

/** SubscriptionPromotionalOfferCreateRequest */
export interface SubscriptionPromotionalOfferCreateRequest {
  data: {
    type: "subscriptionPromotionalOffers";
    attributes: {
      name: string;
      offerCode: string;
      duration: SubscriptionOfferDuration;
      offerMode: SubscriptionOfferMode;
      numberOfPeriods: number;
    };
    relationships: {
      subscription: {
        data: {
          type: "subscriptions";
          id: string;
        };
      };
      prices: {
        data: {
          type: "subscriptionPromotionalOfferPrices";
          id: string;
        }[];
      };
    };
  };
  included?: SubscriptionPromotionalOfferPriceInlineCreate[];
}

/** SubscriptionPromotionalOfferUpdateRequest */
export interface SubscriptionPromotionalOfferUpdateRequest {
  data: {
    type: "subscriptionPromotionalOffers";
    id: string;
    relationships?: {
      prices?: {
        data?: {
          type: "subscriptionPromotionalOfferPrices";
          id: string;
        }[];
      };
    };
  };
  included?: SubscriptionPromotionalOfferPriceInlineCreate[];
}

/** SubscriptionSubmission */
export interface SubscriptionSubmission {
  type: "subscriptionSubmissions";
  id: string;
  relationships?: {
    subscription?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "subscriptions";
        id: string;
      };
    };
  };
  links?: ResourceLinks;
}

/** SubscriptionSubmissionResponse */
export interface SubscriptionSubmissionResponse {
  data: SubscriptionSubmission;
  included?: Subscription[];
  links: DocumentLinks;
}

/** SubscriptionSubmissionCreateRequest */
export interface SubscriptionSubmissionCreateRequest {
  data: {
    type: "subscriptionSubmissions";
    relationships: {
      subscription: {
        data: {
          type: "subscriptions";
          id: string;
        };
      };
    };
  };
}

/** Subscription */
export interface Subscription {
  type: "subscriptions";
  id: string;
  attributes?: {
    name?: string;
    productId?: string;
    familySharable?: boolean;
    state?:
      | "MISSING_METADATA"
      | "READY_TO_SUBMIT"
      | "WAITING_FOR_REVIEW"
      | "IN_REVIEW"
      | "DEVELOPER_ACTION_NEEDED"
      | "PENDING_BINARY_APPROVAL"
      | "APPROVED"
      | "DEVELOPER_REMOVED_FROM_SALE"
      | "REMOVED_FROM_SALE"
      | "REJECTED";
    subscriptionPeriod?: "ONE_WEEK" | "ONE_MONTH" | "TWO_MONTHS" | "THREE_MONTHS" | "SIX_MONTHS" | "ONE_YEAR";
    reviewNote?: string;
    groupLevel?: number;
  };
  relationships?: {
    subscriptionLocalizations?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "subscriptionLocalizations";
        id: string;
      }[];
    };
    appStoreReviewScreenshot?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "subscriptionAppStoreReviewScreenshots";
        id: string;
      };
    };
    group?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "subscriptionGroups";
        id: string;
      };
    };
    introductoryOffers?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "subscriptionIntroductoryOffers";
        id: string;
      }[];
    };
    promotionalOffers?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "subscriptionPromotionalOffers";
        id: string;
      }[];
    };
    offerCodes?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "subscriptionOfferCodes";
        id: string;
      }[];
    };
    prices?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "subscriptionPrices";
        id: string;
      }[];
    };
    promotedPurchase?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "promotedPurchases";
        id: string;
      };
    };
    subscriptionAvailability?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "subscriptionAvailabilities";
        id: string;
      };
    };
  };
  links?: ResourceLinks;
}

/** SubscriptionsResponse */
export interface SubscriptionsResponse {
  data: Subscription[];
  included?: (
    | SubscriptionLocalization
    | SubscriptionAppStoreReviewScreenshot
    | SubscriptionGroup
    | SubscriptionIntroductoryOffer
    | SubscriptionPromotionalOffer
    | SubscriptionOfferCode
    | SubscriptionPrice
    | PromotedPurchase
    | SubscriptionAvailability
  )[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** SubscriptionResponse */
export interface SubscriptionResponse {
  data: Subscription;
  included?: (
    | SubscriptionLocalization
    | SubscriptionAppStoreReviewScreenshot
    | SubscriptionGroup
    | SubscriptionIntroductoryOffer
    | SubscriptionPromotionalOffer
    | SubscriptionOfferCode
    | SubscriptionPrice
    | PromotedPurchase
    | SubscriptionAvailability
  )[];
  links: DocumentLinks;
}

/** SubscriptionCreateRequest */
export interface SubscriptionCreateRequest {
  data: {
    type: "subscriptions";
    attributes: {
      name: string;
      productId: string;
      familySharable?: boolean;
      subscriptionPeriod?: "ONE_WEEK" | "ONE_MONTH" | "TWO_MONTHS" | "THREE_MONTHS" | "SIX_MONTHS" | "ONE_YEAR";
      reviewNote?: string;
      groupLevel?: number;
    };
    relationships: {
      group: {
        data: {
          type: "subscriptionGroups";
          id: string;
        };
      };
    };
  };
}

/** SubscriptionUpdateRequest */
export interface SubscriptionUpdateRequest {
  data: {
    type: "subscriptions";
    id: string;
    attributes?: {
      name?: string;
      familySharable?: boolean;
      subscriptionPeriod?: "ONE_WEEK" | "ONE_MONTH" | "TWO_MONTHS" | "THREE_MONTHS" | "SIX_MONTHS" | "ONE_YEAR";
      reviewNote?: string;
      groupLevel?: number;
    };
    relationships?: {
      introductoryOffers?: {
        data?: {
          type: "subscriptionIntroductoryOffers";
          id: string;
        }[];
      };
      promotionalOffers?: {
        data?: {
          type: "subscriptionPromotionalOffers";
          id: string;
        }[];
      };
      prices?: {
        data?: {
          type: "subscriptionPrices";
          id: string;
        }[];
      };
    };
  };
  included?: (
    | SubscriptionPromotionalOfferInlineCreate
    | SubscriptionPriceInlineCreate
    | SubscriptionIntroductoryOfferInlineCreate
  )[];
}

/** Territory */
export interface Territory {
  type: "territories";
  id: string;
  attributes?: {
    currency?: string;
  };
  links?: ResourceLinks;
}

export interface TerritoryInlineCreate {
  type: "territories";
  id?: string;
}

/** TerritoriesResponse */
export interface TerritoriesResponse {
  data: Territory[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** TerritoryResponse */
export interface TerritoryResponse {
  data: Territory;
  links: DocumentLinks;
}

/** TerritoryAvailability */
export interface TerritoryAvailability {
  type: "territoryAvailabilities";
  id: string;
  attributes?: {
    available?: boolean;
    /** @format date */
    releaseDate?: string;
    preOrderEnabled?: boolean;
    /** @format date */
    preOrderPublishDate?: string;
    contentStatuses?: (
      | "AVAILABLE"
      | "AVAILABLE_FOR_PREORDER_ON_DATE"
      | "PROCESSING_TO_NOT_AVAILABLE"
      | "PROCESSING_TO_AVAILABLE"
      | "PROCESSING_TO_PRE_ORDER"
      | "AVAILABLE_FOR_SALE_UNRELEASED_APP"
      | "PREORDER_ON_UNRELEASED_APP"
      | "AVAILABLE_FOR_PREORDER"
      | "MISSING_RATING"
      | "CANNOT_SELL_RESTRICTED_RATING"
      | "BRAZIL_REQUIRED_TAX_ID"
      | "MISSING_GRN"
      | "UNVERIFIED_GRN"
      | "CANNOT_SELL_SEVENTEEN_PLUS_APPS"
      | "CANNOT_SELL_SEXUALLY_EXPLICIT"
      | "CANNOT_SELL_NON_IOS_GAMES"
      | "CANNOT_SELL_SEVENTEEN_PLUS_GAMES"
      | "CANNOT_SELL_FREQUENT_INTENSE_GAMBLING"
      | "CANNOT_SELL_CASINO"
      | "CANNOT_SELL_CASINO_WITHOUT_GRAC"
      | "CANNOT_SELL_CASINO_WITHOUT_AGE_VERIFICATION"
      | "CANNOT_SELL_FREQUENT_INTENSE_ALCOHOL_TOBACCO_DRUGS"
      | "CANNOT_SELL_FREQUENT_INTENSE_VIOLENCE"
      | "CANNOT_SELL_FREQUENT_INTENSE_SEXUAL_CONTENT_NUDITY"
      | "CANNOT_SELL_INFREQUENT_MILD_ALCOHOL_TOBACCO_DRUGS"
      | "CANNOT_SELL_INFREQUENT_MILD_SEXUAL_CONTENT_NUDITY"
      | "CANNOT_SELL_ADULT_ONLY"
      | "CANNOT_SELL_FREQUENT_INTENSE"
      | "CANNOT_SELL_FREQUENT_INTENSE_WITHOUT_GRAC"
      | "CANNOT_SELL_GAMBLING_CONTESTS"
      | "CANNOT_SELL_GAMBLING"
      | "CANNOT_SELL_CONTESTS"
      | "CANNOT_SELL"
    )[];
  };
  relationships?: {
    territory?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      data?: {
        type: "territories";
        id: string;
      };
    };
  };
  links?: ResourceLinks;
}

export interface TerritoryAvailabilityInlineCreate {
  type: "territoryAvailabilities";
  id?: string;
}

/** TerritoryAvailabilitiesResponse */
export interface TerritoryAvailabilitiesResponse {
  data: TerritoryAvailability[];
  included?: Territory[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** TerritoryAvailabilityResponse */
export interface TerritoryAvailabilityResponse {
  data: TerritoryAvailability;
  included?: Territory[];
  links: DocumentLinks;
}

/** TerritoryAvailabilityUpdateRequest */
export interface TerritoryAvailabilityUpdateRequest {
  data: {
    type: "territoryAvailabilities";
    id: string;
    attributes?: {
      available?: boolean;
      /** @format date */
      releaseDate?: string;
      preOrderEnabled?: boolean;
    };
  };
}

/** UserInvitation */
export interface UserInvitation {
  type: "userInvitations";
  id: string;
  attributes?: {
    /** @format email */
    email?: string;
    firstName?: string;
    lastName?: string;
    /** @format date-time */
    expirationDate?: string;
    roles?: UserRole[];
    allAppsVisible?: boolean;
    provisioningAllowed?: boolean;
  };
  relationships?: {
    visibleApps?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "apps";
        id: string;
      }[];
    };
  };
  links?: ResourceLinks;
}

/** UserInvitationsResponse */
export interface UserInvitationsResponse {
  data: UserInvitation[];
  included?: App[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** UserInvitationResponse */
export interface UserInvitationResponse {
  data: UserInvitation;
  included?: App[];
  links: DocumentLinks;
}

/** UserInvitationCreateRequest */
export interface UserInvitationCreateRequest {
  data: {
    type: "userInvitations";
    attributes: {
      /** @format email */
      email: string;
      firstName: string;
      lastName: string;
      roles: UserRole[];
      allAppsVisible?: boolean;
      provisioningAllowed?: boolean;
    };
    relationships?: {
      visibleApps?: {
        data?: {
          type: "apps";
          id: string;
        }[];
      };
    };
  };
}

/** User */
export interface User {
  type: "users";
  id: string;
  attributes?: {
    username?: string;
    firstName?: string;
    lastName?: string;
    roles?: UserRole[];
    allAppsVisible?: boolean;
    provisioningAllowed?: boolean;
  };
  relationships?: {
    visibleApps?: {
      links?: {
        /** @format uri-reference */
        self?: string;
        /** @format uri-reference */
        related?: string;
      };
      meta?: PagingInformation;
      data?: {
        type: "apps";
        id: string;
      }[];
    };
  };
  links?: ResourceLinks;
}

/** UsersResponse */
export interface UsersResponse {
  data: User[];
  included?: App[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** UserResponse */
export interface UserResponse {
  data: User;
  included?: App[];
  links: DocumentLinks;
}

/** UserUpdateRequest */
export interface UserUpdateRequest {
  data: {
    type: "users";
    id: string;
    attributes?: {
      roles?: UserRole[];
      allAppsVisible?: boolean;
      provisioningAllowed?: boolean;
    };
    relationships?: {
      visibleApps?: {
        data?: {
          type: "apps";
          id: string;
        }[];
      };
    };
  };
}

/** AppCategoryWithoutIncludesResponse */
export interface AppCategoryWithoutIncludesResponse {
  data: AppCategory;
  links: DocumentLinks;
}

/** AppCategoriesWithoutIncludesResponse */
export interface AppCategoriesWithoutIncludesResponse {
  data: AppCategory[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

export interface AppClipDefaultExperienceReleaseWithAppStoreVersionLinkageResponse {
  data: {
    type: "appStoreVersions";
    id: string;
  };
  links: DocumentLinks;
}

export interface AppClipDefaultExperienceReleaseWithAppStoreVersionLinkageRequest {
  data: {
    type: "appStoreVersions";
    id: string;
  };
}

/** AppWithoutIncludesResponse */
export interface AppWithoutIncludesResponse {
  data: PrereleaseVersion;
  links: DocumentLinks;
}

/** @deprecated */
export interface AppEncryptionDeclarationBuildsLinkagesRequest {
  data: {
    type: "builds";
    id: string;
  }[];
}

export interface AppPreviewSetAppPreviewsLinkagesResponse {
  data: {
    type: "appPreviews";
    id: string;
  }[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

export interface AppPreviewSetAppPreviewsLinkagesRequest {
  data: {
    type: "appPreviews";
    id: string;
  }[];
}

export interface AppScreenshotSetAppScreenshotsLinkagesResponse {
  data: {
    type: "appScreenshots";
    id: string;
  }[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

export interface AppScreenshotSetAppScreenshotsLinkagesRequest {
  data: {
    type: "appScreenshots";
    id: string;
  }[];
}

/** AgeRatingDeclarationWithoutIncludesResponse */
export interface AgeRatingDeclarationWithoutIncludesResponse {
  data: AppStoreVersion;
  links: DocumentLinks;
}

export interface AppStoreVersionAppClipDefaultExperienceLinkageResponse {
  data: {
    type: "appClipDefaultExperiences";
    id: string;
  };
  links: DocumentLinks;
}

export interface AppStoreVersionAppClipDefaultExperienceLinkageRequest {
  data: {
    type: "appClipDefaultExperiences";
    id: string;
  };
}

/** AppStoreVersionPhasedReleaseWithoutIncludesResponse */
export interface AppStoreVersionPhasedReleaseWithoutIncludesResponse {
  data: AppStoreVersion;
  links: DocumentLinks;
}

/** BuildWithoutIncludesResponse */
export interface BuildWithoutIncludesResponse {
  data: BuildBetaDetail;
  links: DocumentLinks;
}

export interface AppStoreVersionBuildLinkageResponse {
  data: {
    type: "builds";
    id: string;
  };
  links: DocumentLinks;
}

export interface AppStoreVersionBuildLinkageRequest {
  data: {
    type: "builds";
    id: string;
  };
}

/** RoutingAppCoverageWithoutIncludesResponse */
export interface RoutingAppCoverageWithoutIncludesResponse {
  data: AppStoreVersion;
  links: DocumentLinks;
}

/** BetaAppLocalizationsWithoutIncludesResponse */
export interface BetaAppLocalizationsWithoutIncludesResponse {
  data: App[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** BetaAppReviewDetailWithoutIncludesResponse */
export interface BetaAppReviewDetailWithoutIncludesResponse {
  data: App;
  links: DocumentLinks;
}

/** BetaGroupsWithoutIncludesResponse */
export interface BetaGroupsWithoutIncludesResponse {
  data: BetaTester[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** BetaLicenseAgreementWithoutIncludesResponse */
export interface BetaLicenseAgreementWithoutIncludesResponse {
  data: App;
  links: DocumentLinks;
}

export interface AppBetaTestersLinkagesRequest {
  data: {
    type: "betaTesters";
    id: string;
  }[];
}

/** BuildsWithoutIncludesResponse */
export interface BuildsWithoutIncludesResponse {
  data: PrereleaseVersion[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** EndUserLicenseAgreementWithoutIncludesResponse */
export interface EndUserLicenseAgreementWithoutIncludesResponse {
  data: App;
  links: DocumentLinks;
}

/** AppPreOrderWithoutIncludesResponse */
export interface AppPreOrderWithoutIncludesResponse {
  data: App;
  links: DocumentLinks;
}

/** PreReleaseVersionsWithoutIncludesResponse */
export interface PreReleaseVersionsWithoutIncludesResponse {
  data: App[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

export interface AppPromotedPurchasesLinkagesResponse {
  data: {
    type: "promotedPurchases";
    id: string;
  }[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

export interface AppPromotedPurchasesLinkagesRequest {
  data: {
    type: "promotedPurchases";
    id: string;
  }[];
}

/** BetaTestersWithoutIncludesResponse */
export interface BetaTestersWithoutIncludesResponse {
  data: Build[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

export interface BetaGroupBetaTestersLinkagesResponse {
  data: {
    type: "betaTesters";
    id: string;
  }[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

export interface BetaGroupBetaTestersLinkagesRequest {
  data: {
    type: "betaTesters";
    id: string;
  }[];
}

export interface BetaGroupBuildsLinkagesResponse {
  data: {
    type: "builds";
    id: string;
  }[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

export interface BetaGroupBuildsLinkagesRequest {
  data: {
    type: "builds";
    id: string;
  }[];
}

/** AppsWithoutIncludesResponse */
export interface AppsWithoutIncludesResponse {
  data: User[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

export interface BetaTesterAppsLinkagesResponse {
  data: {
    type: "apps";
    id: string;
  }[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

export interface BetaTesterAppsLinkagesRequest {
  data: {
    type: "apps";
    id: string;
  }[];
}

export interface BetaTesterBetaGroupsLinkagesResponse {
  data: {
    type: "betaGroups";
    id: string;
  }[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

export interface BetaTesterBetaGroupsLinkagesRequest {
  data: {
    type: "betaGroups";
    id: string;
  }[];
}

export interface BetaTesterBuildsLinkagesResponse {
  data: {
    type: "builds";
    id: string;
  }[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

export interface BetaTesterBuildsLinkagesRequest {
  data: {
    type: "builds";
    id: string;
  }[];
}

/** AppEncryptionDeclarationWithoutIncludesResponse */
export interface AppEncryptionDeclarationWithoutIncludesResponse {
  data: Build;
  links: DocumentLinks;
}

export interface BuildAppEncryptionDeclarationLinkageResponse {
  data: {
    type: "appEncryptionDeclarations";
    id: string;
  };
  links: DocumentLinks;
}

export interface BuildAppEncryptionDeclarationLinkageRequest {
  data: {
    type: "appEncryptionDeclarations";
    id: string;
  };
}

/** BetaAppReviewSubmissionWithoutIncludesResponse */
export interface BetaAppReviewSubmissionWithoutIncludesResponse {
  data: Build;
  links: DocumentLinks;
}

/** BetaBuildLocalizationsWithoutIncludesResponse */
export interface BetaBuildLocalizationsWithoutIncludesResponse {
  data: Build[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

export interface BuildBetaGroupsLinkagesRequest {
  data: {
    type: "betaGroups";
    id: string;
  }[];
}

/** BuildIconsWithoutIncludesResponse */
export interface BuildIconsWithoutIncludesResponse {
  data: Build[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

export interface BuildIndividualTestersLinkagesResponse {
  data: {
    type: "betaTesters";
    id: string;
  }[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

export interface BuildIndividualTestersLinkagesRequest {
  data: {
    type: "betaTesters";
    id: string;
  }[];
}

/** PrereleaseVersionWithoutIncludesResponse */
export interface PrereleaseVersionWithoutIncludesResponse {
  data: Build;
  links: DocumentLinks;
}

/** BundleIdCapabilitiesWithoutIncludesResponse */
export interface BundleIdCapabilitiesWithoutIncludesResponse {
  data: BundleId[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** ProfilesWithoutIncludesResponse */
export interface ProfilesWithoutIncludesResponse {
  data: BundleId[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** TerritoriesWithoutIncludesResponse */
export interface TerritoriesWithoutIncludesResponse {
  data: EndUserLicenseAgreement[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

export interface GameCenterAchievementGroupAchievementLinkageResponse {
  data: {
    type: "gameCenterAchievements";
    id: string;
  };
  links: DocumentLinks;
}

export interface GameCenterAchievementGroupAchievementLinkageRequest {
  data: {
    type: "gameCenterAchievements";
    id: string;
  };
}

export interface GameCenterAppVersionCompatibilityVersionsLinkagesResponse {
  data: {
    type: "gameCenterAppVersions";
    id: string;
  }[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

export interface GameCenterAppVersionCompatibilityVersionsLinkagesRequest {
  data: {
    type: "gameCenterAppVersions";
    id: string;
  }[];
}

export interface GameCenterDetailGameCenterAchievementsLinkagesResponse {
  data: {
    type: "gameCenterAchievements";
    id: string;
  }[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

export interface GameCenterDetailGameCenterAchievementsLinkagesRequest {
  data: {
    type: "gameCenterAchievements";
    id: string;
  }[];
}

export interface GameCenterDetailGameCenterLeaderboardSetsLinkagesResponse {
  data: {
    type: "gameCenterLeaderboardSets";
    id: string;
  }[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

export interface GameCenterDetailGameCenterLeaderboardSetsLinkagesRequest {
  data: {
    type: "gameCenterLeaderboardSets";
    id: string;
  }[];
}

export interface GameCenterDetailGameCenterLeaderboardsLinkagesResponse {
  data: {
    type: "gameCenterLeaderboards";
    id: string;
  }[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

export interface GameCenterDetailGameCenterLeaderboardsLinkagesRequest {
  data: {
    type: "gameCenterLeaderboards";
    id: string;
  }[];
}

/** @deprecated */
export interface GameCenterEnabledVersionCompatibleVersionsLinkagesResponse {
  data: {
    type: "gameCenterEnabledVersions";
    id: string;
  }[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** @deprecated */
export interface GameCenterEnabledVersionCompatibleVersionsLinkagesRequest {
  data: {
    type: "gameCenterEnabledVersions";
    id: string;
  }[];
}

export interface GameCenterGroupGameCenterAchievementsLinkagesResponse {
  data: {
    type: "gameCenterAchievements";
    id: string;
  }[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

export interface GameCenterGroupGameCenterAchievementsLinkagesRequest {
  data: {
    type: "gameCenterAchievements";
    id: string;
  }[];
}

export interface GameCenterGroupGameCenterLeaderboardSetsLinkagesResponse {
  data: {
    type: "gameCenterLeaderboardSets";
    id: string;
  }[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

export interface GameCenterGroupGameCenterLeaderboardSetsLinkagesRequest {
  data: {
    type: "gameCenterLeaderboardSets";
    id: string;
  }[];
}

export interface GameCenterGroupGameCenterLeaderboardsLinkagesResponse {
  data: {
    type: "gameCenterLeaderboards";
    id: string;
  }[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

export interface GameCenterGroupGameCenterLeaderboardsLinkagesRequest {
  data: {
    type: "gameCenterLeaderboards";
    id: string;
  }[];
}

export interface GameCenterLeaderboardSetGameCenterLeaderboardsLinkagesResponse {
  data: {
    type: "gameCenterLeaderboards";
    id: string;
  }[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

export interface GameCenterLeaderboardSetGameCenterLeaderboardsLinkagesRequest {
  data: {
    type: "gameCenterLeaderboards";
    id: string;
  }[];
}

export interface GameCenterLeaderboardSetGroupLeaderboardSetLinkageResponse {
  data: {
    type: "gameCenterLeaderboardSets";
    id: string;
  };
  links: DocumentLinks;
}

export interface GameCenterLeaderboardSetGroupLeaderboardSetLinkageRequest {
  data: {
    type: "gameCenterLeaderboardSets";
    id: string;
  };
}

export interface GameCenterLeaderboardGroupLeaderboardLinkageResponse {
  data: {
    type: "gameCenterLeaderboards";
    id: string;
  };
  links: DocumentLinks;
}

export interface GameCenterLeaderboardGroupLeaderboardLinkageRequest {
  data: {
    type: "gameCenterLeaderboards";
    id: string;
  };
}

/** BundleIdWithoutIncludesResponse */
export interface BundleIdWithoutIncludesResponse {
  data: Profile;
  links: DocumentLinks;
}

/** CertificatesWithoutIncludesResponse */
export interface CertificatesWithoutIncludesResponse {
  data: Profile[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

/** DevicesWithoutIncludesResponse */
export interface DevicesWithoutIncludesResponse {
  data: Profile[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

export interface SubscriptionIntroductoryOffersLinkagesResponse {
  data: {
    type: "subscriptionIntroductoryOffers";
    id: string;
  }[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

export interface SubscriptionIntroductoryOffersLinkagesRequest {
  data: {
    type: "subscriptionIntroductoryOffers";
    id: string;
  }[];
}

export interface SubscriptionPricesLinkagesResponse {
  data: {
    type: "subscriptionPrices";
    id: string;
  }[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

export interface SubscriptionPricesLinkagesRequest {
  data: {
    type: "subscriptionPrices";
    id: string;
  }[];
}

export interface UserVisibleAppsLinkagesResponse {
  data: {
    type: "apps";
    id: string;
  }[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

export interface UserVisibleAppsLinkagesRequest {
  data: {
    type: "apps";
    id: string;
  }[];
}

export interface AppsBetaTesterUsagesV1MetricResponse {
  data: {
    dataPoints?: {
      /** @format date-time */
      start?: string;
      /** @format date-time */
      end?: string;
      values?: {
        crashCount?: number;
        sessionCount?: number;
        feedbackCount?: number;
      };
    };
    dimensions?: {
      betaTesters?: {
        links?: {
          /** @format uri-reference */
          groupBy?: string;
          /** @format uri-reference */
          related?: string;
        };
      };
    };
  }[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
  included?: BetaTester[];
}

export interface BetaTesterUsagesV1MetricResponse {
  data: {
    dataPoints?: {
      /** @format date-time */
      start?: string;
      /** @format date-time */
      end?: string;
      values?: {
        crashCount?: number;
        sessionCount?: number;
        feedbackCount?: number;
      };
    };
    dimensions?: {
      apps?: {
        links?: {
          /** @format uri-reference */
          groupBy?: string;
          /** @format uri-reference */
          related?: string;
        };
      };
    };
  }[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

export interface BetaBuildUsagesV1MetricResponse {
  data: {
    dataPoints?: {
      /** @format date-time */
      start?: string;
      /** @format date-time */
      end?: string;
      values?: {
        crashCount?: number;
        installCount?: number;
        sessionCount?: number;
        feedbackCount?: number;
        inviteCount?: number;
      };
    };
    dimensions?: {
      bundleIds?: {
        links?: {
          /** @format uri-reference */
          groupBy?: string;
        };
      };
    };
  }[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

export interface GameCenterMatchmakingAppRequestsV1MetricResponse {
  data: {
    dataPoints?: {
      /** @format date-time */
      start?: string;
      /** @format date-time */
      end?: string;
      values?: {
        count?: number;
        averageSecondsInQueue?: number;
        p50SecondsInQueue?: number;
        p95SecondsInQueue?: number;
      };
    };
    dimensions?: {
      result?: {
        links?: {
          /** @format uri-reference */
          groupBy?: string;
        };
      };
    };
    granularity?: "P1D" | "PT1H" | "PT15M";
  }[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

export interface GameCenterMatchmakingQueueSizesV1MetricResponse {
  data: {
    dataPoints?: {
      /** @format date-time */
      start?: string;
      /** @format date-time */
      end?: string;
      values?: {
        count?: number;
        averageNumberOfRequests?: number;
        p50NumberOfRequests?: number;
        p95NumberOfRequests?: number;
      };
    };
    granularity?: "P1D" | "PT1H" | "PT15M";
  }[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

export interface GameCenterMatchmakingQueueRequestsV1MetricResponse {
  data: {
    dataPoints?: {
      /** @format date-time */
      start?: string;
      /** @format date-time */
      end?: string;
      values?: {
        count?: number;
        averageSecondsInQueue?: number;
        p50SecondsInQueue?: number;
        p95SecondsInQueue?: number;
      };
    };
    dimensions?: {
      result?: {
        links?: {
          /** @format uri-reference */
          groupBy?: string;
        };
      };
      gameCenterDetail?: {
        links?: {
          /** @format uri-reference */
          groupBy?: string;
          /** @format uri-reference */
          related?: string;
        };
      };
    };
    granularity?: "P1D" | "PT1H" | "PT15M";
  }[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

export interface GameCenterMatchmakingSessionsV1MetricResponse {
  data: {
    dataPoints?: {
      /** @format date-time */
      start?: string;
      /** @format date-time */
      end?: string;
      values?: {
        count?: number;
        averagePlayerCount?: number;
        p50PlayerCount?: number;
        p95PlayerCount?: number;
      };
    };
    granularity?: "P1D" | "PT1H" | "PT15M";
  }[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

export interface GameCenterMatchmakingBooleanRuleResultsV1MetricResponse {
  data: {
    dataPoints?: {
      /** @format date-time */
      start?: string;
      /** @format date-time */
      end?: string;
      values?: {
        count?: number;
      };
    };
    dimensions?: {
      result?: {
        links?: {
          /** @format uri-reference */
          groupBy?: string;
        };
      };
      gameCenterMatchmakingQueue?: {
        links?: {
          /** @format uri-reference */
          groupBy?: string;
          /** @format uri-reference */
          related?: string;
        };
      };
    };
    granularity?: "P1D" | "PT1H" | "PT15M";
  }[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

export interface GameCenterMatchmakingNumberRuleResultsV1MetricResponse {
  data: {
    dataPoints?: {
      /** @format date-time */
      start?: string;
      /** @format date-time */
      end?: string;
      values?: {
        count?: number;
        averageResult?: number;
        p50Result?: number;
        p95Result?: number;
      };
    };
    dimensions?: {
      gameCenterMatchmakingQueue?: {
        links?: {
          /** @format uri-reference */
          groupBy?: string;
          /** @format uri-reference */
          related?: string;
        };
      };
    };
    granularity?: "P1D" | "PT1H" | "PT15M";
  }[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

export interface GameCenterMatchmakingRuleErrorsV1MetricResponse {
  data: {
    dataPoints?: {
      /** @format date-time */
      start?: string;
      /** @format date-time */
      end?: string;
      values?: {
        count?: number;
      };
    };
    dimensions?: {
      gameCenterMatchmakingQueue?: {
        links?: {
          /** @format uri-reference */
          groupBy?: string;
          /** @format uri-reference */
          related?: string;
        };
      };
    };
    granularity?: "P1D" | "PT1H" | "PT15M";
  }[];
  links: PagedDocumentLinks;
  meta?: PagingInformation;
}

export interface ErrorResponse {
  errors?: {
    id?: string;
    status: string;
    code: string;
    title: string;
    detail: string;
    source?: ErrorSourcePointer | ErrorSourceParameter;
    meta?: Record<string, any>;
  }[];
}

/** Parameter */
export interface ErrorSourceParameter {
  parameter?: string;
}

/** JsonPointer */
export interface ErrorSourcePointer {
  pointer?: string;
}

export interface PagedDocumentLinks {
  /** @format uri-reference */
  self: string;
  /** @format uri-reference */
  first?: string;
  /** @format uri-reference */
  next?: string;
}

export interface PagingInformation {
  paging: {
    total?: number;
    limit: number;
  };
}

export interface DocumentLinks {
  /** @format uri-reference */
  self: string;
}

export interface ResourceLinks {
  /** @format uri-reference */
  self?: string;
}

export enum AppClipAction {
  OPEN = "OPEN",
  VIEW = "VIEW",
  PLAY = "PLAY",
}

export enum AppClipAdvancedExperienceLanguage {
  AR = "AR",
  CA = "CA",
  CS = "CS",
  DA = "DA",
  DE = "DE",
  EL = "EL",
  EN = "EN",
  ES = "ES",
  FI = "FI",
  FR = "FR",
  HE = "HE",
  HI = "HI",
  HR = "HR",
  HU = "HU",
  ID = "ID",
  IT = "IT",
  JA = "JA",
  KO = "KO",
  MS = "MS",
  NL = "NL",
  NO = "NO",
  PL = "PL",
  PT = "PT",
  RO = "RO",
  RU = "RU",
  SK = "SK",
  SV = "SV",
  TH = "TH",
  TR = "TR",
  UK = "UK",
  VI = "VI",
  ZH = "ZH",
}

export enum AppEncryptionDeclarationState {
  CREATED = "CREATED",
  IN_REVIEW = "IN_REVIEW",
  APPROVED = "APPROVED",
  REJECTED = "REJECTED",
  INVALID = "INVALID",
  EXPIRED = "EXPIRED",
}

export enum AppEventAssetType {
  EVENT_CARD = "EVENT_CARD",
  EVENT_DETAILS_PAGE = "EVENT_DETAILS_PAGE",
}

export interface AppMediaAssetState {
  errors?: AppMediaStateError[];
  warnings?: AppMediaStateError[];
  state?: "AWAITING_UPLOAD" | "UPLOAD_COMPLETE" | "COMPLETE" | "FAILED";
}

export interface AppMediaStateError {
  code?: string;
  description?: string;
}

export enum AppStoreAgeRating {
  FOUR_PLUS = "FOUR_PLUS",
  NINE_PLUS = "NINE_PLUS",
  TWELVE_PLUS = "TWELVE_PLUS",
  SEVENTEEN_PLUS = "SEVENTEEN_PLUS",
  UNRATED = "UNRATED",
}

export enum AppStoreVersionState {
  ACCEPTED = "ACCEPTED",
  DEVELOPER_REMOVED_FROM_SALE = "DEVELOPER_REMOVED_FROM_SALE",
  DEVELOPER_REJECTED = "DEVELOPER_REJECTED",
  IN_REVIEW = "IN_REVIEW",
  INVALID_BINARY = "INVALID_BINARY",
  METADATA_REJECTED = "METADATA_REJECTED",
  PENDING_APPLE_RELEASE = "PENDING_APPLE_RELEASE",
  PENDING_CONTRACT = "PENDING_CONTRACT",
  PENDING_DEVELOPER_RELEASE = "PENDING_DEVELOPER_RELEASE",
  PREPARE_FOR_SUBMISSION = "PREPARE_FOR_SUBMISSION",
  PREORDER_READY_FOR_SALE = "PREORDER_READY_FOR_SALE",
  PROCESSING_FOR_APP_STORE = "PROCESSING_FOR_APP_STORE",
  READY_FOR_REVIEW = "READY_FOR_REVIEW",
  READY_FOR_SALE = "READY_FOR_SALE",
  REJECTED = "REJECTED",
  REMOVED_FROM_SALE = "REMOVED_FROM_SALE",
  WAITING_FOR_EXPORT_COMPLIANCE = "WAITING_FOR_EXPORT_COMPLIANCE",
  WAITING_FOR_REVIEW = "WAITING_FOR_REVIEW",
  REPLACED_WITH_NEW_VERSION = "REPLACED_WITH_NEW_VERSION",
  NOT_APPLICABLE = "NOT_APPLICABLE",
}

export enum AppVersionState {
  ACCEPTED = "ACCEPTED",
  DEVELOPER_REJECTED = "DEVELOPER_REJECTED",
  IN_REVIEW = "IN_REVIEW",
  INVALID_BINARY = "INVALID_BINARY",
  METADATA_REJECTED = "METADATA_REJECTED",
  PENDING_APPLE_RELEASE = "PENDING_APPLE_RELEASE",
  PENDING_DEVELOPER_RELEASE = "PENDING_DEVELOPER_RELEASE",
  PREPARE_FOR_SUBMISSION = "PREPARE_FOR_SUBMISSION",
  PROCESSING_FOR_DISTRIBUTION = "PROCESSING_FOR_DISTRIBUTION",
  READY_FOR_DISTRIBUTION = "READY_FOR_DISTRIBUTION",
  READY_FOR_REVIEW = "READY_FOR_REVIEW",
  REJECTED = "REJECTED",
  REPLACED_WITH_NEW_VERSION = "REPLACED_WITH_NEW_VERSION",
  WAITING_FOR_EXPORT_COMPLIANCE = "WAITING_FOR_EXPORT_COMPLIANCE",
  WAITING_FOR_REVIEW = "WAITING_FOR_REVIEW",
}

export enum BetaInviteType {
  EMAIL = "EMAIL",
  PUBLIC_LINK = "PUBLIC_LINK",
}

export enum BetaReviewState {
  WAITING_FOR_REVIEW = "WAITING_FOR_REVIEW",
  IN_REVIEW = "IN_REVIEW",
  REJECTED = "REJECTED",
  APPROVED = "APPROVED",
}

export enum BrazilAgeRating {
  L = "L",
  TEN = "TEN",
  TWELVE = "TWELVE",
  FOURTEEN = "FOURTEEN",
  SIXTEEN = "SIXTEEN",
  EIGHTEEN = "EIGHTEEN",
}

export enum BuildAudienceType {
  INTERNAL_ONLY = "INTERNAL_ONLY",
  APP_STORE_ELIGIBLE = "APP_STORE_ELIGIBLE",
}

export enum BundleIdPlatform {
  IOS = "IOS",
  MAC_OS = "MAC_OS",
}

export interface CapabilityOption {
  key?:
    | "XCODE_5"
    | "XCODE_6"
    | "COMPLETE_PROTECTION"
    | "PROTECTED_UNLESS_OPEN"
    | "PROTECTED_UNTIL_FIRST_USER_AUTH"
    | "PRIMARY_APP_CONSENT";
  name?: string;
  description?: string;
  enabledByDefault?: boolean;
  enabled?: boolean;
  supportsWildcard?: boolean;
}

export interface CapabilitySetting {
  key?: "ICLOUD_VERSION" | "DATA_PROTECTION_PERMISSION_LEVEL" | "APPLE_ID_AUTH_APP_CONSENT";
  name?: string;
  description?: string;
  enabledByDefault?: boolean;
  visible?: boolean;
  allowedInstances?: "ENTRY" | "SINGLE" | "MULTIPLE";
  minInstances?: number;
  options?: CapabilityOption[];
}

export enum CapabilityType {
  ICLOUD = "ICLOUD",
  IN_APP_PURCHASE = "IN_APP_PURCHASE",
  GAME_CENTER = "GAME_CENTER",
  PUSH_NOTIFICATIONS = "PUSH_NOTIFICATIONS",
  WALLET = "WALLET",
  INTER_APP_AUDIO = "INTER_APP_AUDIO",
  MAPS = "MAPS",
  ASSOCIATED_DOMAINS = "ASSOCIATED_DOMAINS",
  PERSONAL_VPN = "PERSONAL_VPN",
  APP_GROUPS = "APP_GROUPS",
  HEALTHKIT = "HEALTHKIT",
  HOMEKIT = "HOMEKIT",
  WIRELESS_ACCESSORY_CONFIGURATION = "WIRELESS_ACCESSORY_CONFIGURATION",
  APPLE_PAY = "APPLE_PAY",
  DATA_PROTECTION = "DATA_PROTECTION",
  SIRIKIT = "SIRIKIT",
  NETWORK_EXTENSIONS = "NETWORK_EXTENSIONS",
  MULTIPATH = "MULTIPATH",
  HOT_SPOT = "HOT_SPOT",
  NFC_TAG_READING = "NFC_TAG_READING",
  CLASSKIT = "CLASSKIT",
  AUTOFILL_CREDENTIAL_PROVIDER = "AUTOFILL_CREDENTIAL_PROVIDER",
  ACCESS_WIFI_INFORMATION = "ACCESS_WIFI_INFORMATION",
  NETWORK_CUSTOM_PROTOCOL = "NETWORK_CUSTOM_PROTOCOL",
  COREMEDIA_HLS_LOW_LATENCY = "COREMEDIA_HLS_LOW_LATENCY",
  SYSTEM_EXTENSION_INSTALL = "SYSTEM_EXTENSION_INSTALL",
  USER_MANAGEMENT = "USER_MANAGEMENT",
  APPLE_ID_AUTH = "APPLE_ID_AUTH",
}

export enum CertificateType {
  IOS_DEVELOPMENT = "IOS_DEVELOPMENT",
  IOS_DISTRIBUTION = "IOS_DISTRIBUTION",
  MAC_APP_DISTRIBUTION = "MAC_APP_DISTRIBUTION",
  MAC_INSTALLER_DISTRIBUTION = "MAC_INSTALLER_DISTRIBUTION",
  MAC_APP_DEVELOPMENT = "MAC_APP_DEVELOPMENT",
  DEVELOPER_ID_KEXT = "DEVELOPER_ID_KEXT",
  DEVELOPER_ID_APPLICATION = "DEVELOPER_ID_APPLICATION",
  DEVELOPMENT = "DEVELOPMENT",
  DISTRIBUTION = "DISTRIBUTION",
  PASS_TYPE_ID = "PASS_TYPE_ID",
  PASS_TYPE_ID_WITH_NFC = "PASS_TYPE_ID_WITH_NFC",
}

export interface CiAction {
  name?: string;
  actionType?: CiActionType;
  destination?:
    | "ANY_IOS_DEVICE"
    | "ANY_IOS_SIMULATOR"
    | "ANY_TVOS_DEVICE"
    | "ANY_TVOS_SIMULATOR"
    | "ANY_WATCHOS_DEVICE"
    | "ANY_WATCHOS_SIMULATOR"
    | "ANY_MAC"
    | "ANY_MAC_CATALYST"
    | "ANY_VISIONOS_DEVICE"
    | "ANY_VISIONOS_SIMULATOR";
  buildDistributionAudience?: BuildAudienceType;
  testConfiguration?: {
    kind?: "USE_SCHEME_SETTINGS" | "SPECIFIC_TEST_PLANS";
    testPlanName?: string;
    testDestinations?: CiTestDestination[];
  };
  scheme?: string;
  platform?: "MACOS" | "IOS" | "TVOS" | "WATCHOS" | "VISIONOS";
  isRequiredToPass?: boolean;
}

export enum CiActionType {
  BUILD = "BUILD",
  ANALYZE = "ANALYZE",
  TEST = "TEST",
  ARCHIVE = "ARCHIVE",
}

export interface CiBranchPatterns {
  isAllMatch?: boolean;
  patterns?: {
    pattern?: string;
    isPrefix?: boolean;
  }[];
}

export interface CiBranchStartCondition {
  source?: CiBranchPatterns;
  filesAndFoldersRule?: CiFilesAndFoldersRule;
  autoCancel?: boolean;
}

export enum CiCompletionStatus {
  SUCCEEDED = "SUCCEEDED",
  FAILED = "FAILED",
  ERRORED = "ERRORED",
  CANCELED = "CANCELED",
  SKIPPED = "SKIPPED",
}

export enum CiExecutionProgress {
  PENDING = "PENDING",
  RUNNING = "RUNNING",
  COMPLETE = "COMPLETE",
}

export interface CiFilesAndFoldersRule {
  mode?: "START_IF_ANY_FILE_MATCHES" | "DO_NOT_START_IF_ALL_FILES_MATCH";
  matchers?: CiStartConditionFileMatcher[];
}

export enum CiGitRefKind {
  BRANCH = "BRANCH",
  TAG = "TAG",
}

export interface CiGitUser {
  displayName?: string;
  /** @format uri */
  avatarUrl?: string;
}

export interface CiIssueCounts {
  analyzerWarnings?: number;
  errors?: number;
  testFailures?: number;
  warnings?: number;
}

export interface CiManualBranchStartCondition {
  source?: CiBranchPatterns;
}

export interface CiManualPullRequestStartCondition {
  source?: CiBranchPatterns;
  destination?: CiBranchPatterns;
}

export interface CiManualTagStartCondition {
  source?: CiTagPatterns;
}

export interface CiPullRequestStartCondition {
  source?: CiBranchPatterns;
  destination?: CiBranchPatterns;
  filesAndFoldersRule?: CiFilesAndFoldersRule;
  autoCancel?: boolean;
}

export interface CiScheduledStartCondition {
  source?: CiBranchPatterns;
  schedule?: {
    frequency?: "WEEKLY" | "DAILY" | "HOURLY";
    days?: ("SUNDAY" | "MONDAY" | "TUESDAY" | "WEDNESDAY" | "THURSDAY" | "FRIDAY" | "SATURDAY")[];
    hour?: number;
    minute?: number;
    timezone?: string;
  };
}

export interface CiStartConditionFileMatcher {
  directory?: string;
  fileExtension?: string;
  fileName?: string;
}

export interface CiTagPatterns {
  isAllMatch?: boolean;
  patterns?: {
    pattern?: string;
    isPrefix?: boolean;
  }[];
}

export interface CiTagStartCondition {
  source?: CiTagPatterns;
  filesAndFoldersRule?: CiFilesAndFoldersRule;
  autoCancel?: boolean;
}

export interface CiTestDestination {
  deviceTypeName?: string;
  deviceTypeIdentifier?: string;
  runtimeName?: string;
  runtimeIdentifier?: string;
  kind?: CiTestDestinationKind;
}

export enum CiTestDestinationKind {
  SIMULATOR = "SIMULATOR",
  MAC = "MAC",
}

export enum CiTestStatus {
  SUCCESS = "SUCCESS",
  FAILURE = "FAILURE",
  MIXED = "MIXED",
  SKIPPED = "SKIPPED",
  EXPECTED_FAILURE = "EXPECTED_FAILURE",
}

export interface DiagnosticLogCallStackNode {
  sampleCount?: number;
  isBlameFrame?: boolean;
  symbolName?: string;
  insightsCategory?: string;
  offsetIntoSymbol?: string;
  binaryName?: string;
  fileName?: string;
  binaryUUID?: string;
  lineNumber?: string;
  address?: string;
  offsetIntoBinaryTextSegment?: string;
  rawFrame?: string;
  subFrames?: DiagnosticLogCallStackNode[];
}

export enum ExternalBetaState {
  PROCESSING = "PROCESSING",
  PROCESSING_EXCEPTION = "PROCESSING_EXCEPTION",
  MISSING_EXPORT_COMPLIANCE = "MISSING_EXPORT_COMPLIANCE",
  READY_FOR_BETA_TESTING = "READY_FOR_BETA_TESTING",
  IN_BETA_TESTING = "IN_BETA_TESTING",
  EXPIRED = "EXPIRED",
  READY_FOR_BETA_SUBMISSION = "READY_FOR_BETA_SUBMISSION",
  IN_EXPORT_COMPLIANCE_REVIEW = "IN_EXPORT_COMPLIANCE_REVIEW",
  WAITING_FOR_BETA_REVIEW = "WAITING_FOR_BETA_REVIEW",
  IN_BETA_REVIEW = "IN_BETA_REVIEW",
  BETA_REJECTED = "BETA_REJECTED",
  BETA_APPROVED = "BETA_APPROVED",
}

export interface FileLocation {
  path?: string;
  lineNumber?: number;
}

export enum GameCenterLeaderboardFormatter {
  INTEGER = "INTEGER",
  DECIMALPOINT1PLACE = "DECIMAL_POINT_1_PLACE",
  DECIMALPOINT2PLACE = "DECIMAL_POINT_2_PLACE",
  DECIMALPOINT3PLACE = "DECIMAL_POINT_3_PLACE",
  ELAPSED_TIME_MILLISECOND = "ELAPSED_TIME_MILLISECOND",
  ELAPSED_TIME_MINUTE = "ELAPSED_TIME_MINUTE",
  ELAPSED_TIME_SECOND = "ELAPSED_TIME_SECOND",
  MONEY_POUND_DECIMAL = "MONEY_POUND_DECIMAL",
  MONEY_POUND = "MONEY_POUND",
  MONEY_DOLLAR_DECIMAL = "MONEY_DOLLAR_DECIMAL",
  MONEY_DOLLAR = "MONEY_DOLLAR",
  MONEY_EURO_DECIMAL = "MONEY_EURO_DECIMAL",
  MONEY_EURO = "MONEY_EURO",
  MONEY_FRANC_DECIMAL = "MONEY_FRANC_DECIMAL",
  MONEY_FRANC = "MONEY_FRANC",
  MONEY_KRONER_DECIMAL = "MONEY_KRONER_DECIMAL",
  MONEY_KRONER = "MONEY_KRONER",
  MONEY_YEN = "MONEY_YEN",
}

export interface GameCenterMatchmakingTeamAssignment {
  playerId?: string;
  team?: string;
}

export interface HttpHeader {
  name?: string;
  value?: string;
}

export enum IconAssetType {
  APP_STORE = "APP_STORE",
  MESSAGES_APP_STORE = "MESSAGES_APP_STORE",
  WATCH_APP_STORE = "WATCH_APP_STORE",
  TV_OS_HOME_SCREEN = "TV_OS_HOME_SCREEN",
  TV_OS_TOP_SHELF = "TV_OS_TOP_SHELF",
  ALTERNATE_EXPERIMENT = "ALTERNATE_EXPERIMENT",
}

export interface ImageAsset {
  templateUrl?: string;
  width?: number;
  height?: number;
}

export enum InAppPurchaseState {
  MISSING_METADATA = "MISSING_METADATA",
  WAITING_FOR_UPLOAD = "WAITING_FOR_UPLOAD",
  PROCESSING_CONTENT = "PROCESSING_CONTENT",
  READY_TO_SUBMIT = "READY_TO_SUBMIT",
  WAITING_FOR_REVIEW = "WAITING_FOR_REVIEW",
  IN_REVIEW = "IN_REVIEW",
  DEVELOPER_ACTION_NEEDED = "DEVELOPER_ACTION_NEEDED",
  PENDING_BINARY_APPROVAL = "PENDING_BINARY_APPROVAL",
  APPROVED = "APPROVED",
  DEVELOPER_REMOVED_FROM_SALE = "DEVELOPER_REMOVED_FROM_SALE",
  REMOVED_FROM_SALE = "REMOVED_FROM_SALE",
  REJECTED = "REJECTED",
}

export enum InAppPurchaseType {
  CONSUMABLE = "CONSUMABLE",
  NON_CONSUMABLE = "NON_CONSUMABLE",
  NON_RENEWING_SUBSCRIPTION = "NON_RENEWING_SUBSCRIPTION",
}

export enum InternalBetaState {
  PROCESSING = "PROCESSING",
  PROCESSING_EXCEPTION = "PROCESSING_EXCEPTION",
  MISSING_EXPORT_COMPLIANCE = "MISSING_EXPORT_COMPLIANCE",
  READY_FOR_BETA_TESTING = "READY_FOR_BETA_TESTING",
  IN_BETA_TESTING = "IN_BETA_TESTING",
  EXPIRED = "EXPIRED",
  IN_EXPORT_COMPLIANCE_REVIEW = "IN_EXPORT_COMPLIANCE_REVIEW",
}

export enum KidsAgeBand {
  FIVE_AND_UNDER = "FIVE_AND_UNDER",
  SIX_TO_EIGHT = "SIX_TO_EIGHT",
  NINE_TO_ELEVEN = "NINE_TO_ELEVEN",
}

export interface Location {
  latitude?: number;
  longitude?: number;
}

export enum MetricCategory {
  HANG = "HANG",
  LAUNCH = "LAUNCH",
  MEMORY = "MEMORY",
  DISK = "DISK",
  BATTERY = "BATTERY",
  TERMINATION = "TERMINATION",
  ANIMATION = "ANIMATION",
}

export interface MetricsInsight {
  metricCategory?: MetricCategory;
  latestVersion?: string;
  metric?: string;
  summaryString?: string;
  referenceVersions?: string;
  maxLatestVersionValue?: number;
  subSystemLabel?: string;
  highImpact?: boolean;
  populations?: {
    deltaPercentage?: number;
    percentile?: string;
    summaryString?: string;
    referenceAverageValue?: number;
    latestVersionValue?: number;
    device?: string;
  }[];
}

export enum PhasedReleaseState {
  INACTIVE = "INACTIVE",
  ACTIVE = "ACTIVE",
  PAUSED = "PAUSED",
  COMPLETE = "COMPLETE",
}

export enum Platform {
  IOS = "IOS",
  MAC_OS = "MAC_OS",
  TV_OS = "TV_OS",
  VISION_OS = "VISION_OS",
}

export enum PreviewType {
  IPHONE67 = "IPHONE_67",
  IPHONE61 = "IPHONE_61",
  IPHONE65 = "IPHONE_65",
  IPHONE58 = "IPHONE_58",
  IPHONE55 = "IPHONE_55",
  IPHONE47 = "IPHONE_47",
  IPHONE40 = "IPHONE_40",
  IPHONE35 = "IPHONE_35",
  IPADPRO3GEN129 = "IPAD_PRO_3GEN_129",
  IPADPRO3GEN11 = "IPAD_PRO_3GEN_11",
  IPADPRO129 = "IPAD_PRO_129",
  IPAD105 = "IPAD_105",
  IPAD97 = "IPAD_97",
  DESKTOP = "DESKTOP",
  APPLE_TV = "APPLE_TV",
  APPLE_VISION_PRO = "APPLE_VISION_PRO",
}

export interface Property {
  key?: string;
  value?: string;
}

export interface ScmProviderType {
  kind?:
    | "BITBUCKET_CLOUD"
    | "BITBUCKET_SERVER"
    | "GITHUB_CLOUD"
    | "GITHUB_ENTERPRISE"
    | "GITLAB_CLOUD"
    | "GITLAB_SELF_MANAGED";
  displayName?: string;
  isOnPremise?: boolean;
}

export enum ScreenshotDisplayType {
  APPIPHONE67 = "APP_IPHONE_67",
  APPIPHONE61 = "APP_IPHONE_61",
  APPIPHONE65 = "APP_IPHONE_65",
  APPIPHONE58 = "APP_IPHONE_58",
  APPIPHONE55 = "APP_IPHONE_55",
  APPIPHONE47 = "APP_IPHONE_47",
  APPIPHONE40 = "APP_IPHONE_40",
  APPIPHONE35 = "APP_IPHONE_35",
  APPIPADPRO3GEN129 = "APP_IPAD_PRO_3GEN_129",
  APPIPADPRO3GEN11 = "APP_IPAD_PRO_3GEN_11",
  APPIPADPRO129 = "APP_IPAD_PRO_129",
  APPIPAD105 = "APP_IPAD_105",
  APPIPAD97 = "APP_IPAD_97",
  APP_DESKTOP = "APP_DESKTOP",
  APP_WATCH_ULTRA = "APP_WATCH_ULTRA",
  APPWATCHSERIES7 = "APP_WATCH_SERIES_7",
  APPWATCHSERIES4 = "APP_WATCH_SERIES_4",
  APPWATCHSERIES3 = "APP_WATCH_SERIES_3",
  APP_APPLE_TV = "APP_APPLE_TV",
  APP_APPLE_VISION_PRO = "APP_APPLE_VISION_PRO",
  IMESSAGEAPPIPHONE67 = "IMESSAGE_APP_IPHONE_67",
  IMESSAGEAPPIPHONE61 = "IMESSAGE_APP_IPHONE_61",
  IMESSAGEAPPIPHONE65 = "IMESSAGE_APP_IPHONE_65",
  IMESSAGEAPPIPHONE58 = "IMESSAGE_APP_IPHONE_58",
  IMESSAGEAPPIPHONE55 = "IMESSAGE_APP_IPHONE_55",
  IMESSAGEAPPIPHONE47 = "IMESSAGE_APP_IPHONE_47",
  IMESSAGEAPPIPHONE40 = "IMESSAGE_APP_IPHONE_40",
  IMESSAGEAPPIPADPRO3GEN129 = "IMESSAGE_APP_IPAD_PRO_3GEN_129",
  IMESSAGEAPPIPADPRO3GEN11 = "IMESSAGE_APP_IPAD_PRO_3GEN_11",
  IMESSAGEAPPIPADPRO129 = "IMESSAGE_APP_IPAD_PRO_129",
  IMESSAGEAPPIPAD105 = "IMESSAGE_APP_IPAD_105",
  IMESSAGEAPPIPAD97 = "IMESSAGE_APP_IPAD_97",
}

export enum SubscriptionCustomerEligibility {
  NEW = "NEW",
  EXISTING = "EXISTING",
  EXPIRED = "EXPIRED",
}

export enum SubscriptionGracePeriodDuration {
  THREE_DAYS = "THREE_DAYS",
  SIXTEEN_DAYS = "SIXTEEN_DAYS",
  TWENTY_EIGHT_DAYS = "TWENTY_EIGHT_DAYS",
}

export enum SubscriptionOfferDuration {
  ONE_DAY = "ONE_DAY",
  THREE_DAYS = "THREE_DAYS",
  ONE_WEEK = "ONE_WEEK",
  TWO_WEEKS = "TWO_WEEKS",
  ONE_MONTH = "ONE_MONTH",
  TWO_MONTHS = "TWO_MONTHS",
  THREE_MONTHS = "THREE_MONTHS",
  SIX_MONTHS = "SIX_MONTHS",
  ONE_YEAR = "ONE_YEAR",
}

export enum SubscriptionOfferEligibility {
  STACK_WITH_INTRO_OFFERS = "STACK_WITH_INTRO_OFFERS",
  REPLACE_INTRO_OFFERS = "REPLACE_INTRO_OFFERS",
}

export enum SubscriptionOfferMode {
  PAY_AS_YOU_GO = "PAY_AS_YOU_GO",
  PAY_UP_FRONT = "PAY_UP_FRONT",
  FREE_TRIAL = "FREE_TRIAL",
}

export enum SubscriptionStatusUrlVersion {
  V1 = "V1",
  V2 = "V2",
  V11 = "v1",
  V22 = "v2",
}

export enum TerritoryCode {
  ABW = "ABW",
  AFG = "AFG",
  AGO = "AGO",
  AIA = "AIA",
  ALB = "ALB",
  AND = "AND",
  ANT = "ANT",
  ARE = "ARE",
  ARG = "ARG",
  ARM = "ARM",
  ASM = "ASM",
  ATG = "ATG",
  AUS = "AUS",
  AUT = "AUT",
  AZE = "AZE",
  BDI = "BDI",
  BEL = "BEL",
  BEN = "BEN",
  BES = "BES",
  BFA = "BFA",
  BGD = "BGD",
  BGR = "BGR",
  BHR = "BHR",
  BHS = "BHS",
  BIH = "BIH",
  BLR = "BLR",
  BLZ = "BLZ",
  BMU = "BMU",
  BOL = "BOL",
  BRA = "BRA",
  BRB = "BRB",
  BRN = "BRN",
  BTN = "BTN",
  BWA = "BWA",
  CAF = "CAF",
  CAN = "CAN",
  CHE = "CHE",
  CHL = "CHL",
  CHN = "CHN",
  CIV = "CIV",
  CMR = "CMR",
  COD = "COD",
  COG = "COG",
  COK = "COK",
  COL = "COL",
  COM = "COM",
  CPV = "CPV",
  CRI = "CRI",
  CUB = "CUB",
  CUW = "CUW",
  CXR = "CXR",
  CYM = "CYM",
  CYP = "CYP",
  CZE = "CZE",
  DEU = "DEU",
  DJI = "DJI",
  DMA = "DMA",
  DNK = "DNK",
  DOM = "DOM",
  DZA = "DZA",
  ECU = "ECU",
  EGY = "EGY",
  ERI = "ERI",
  ESP = "ESP",
  EST = "EST",
  ETH = "ETH",
  FIN = "FIN",
  FJI = "FJI",
  FLK = "FLK",
  FRA = "FRA",
  FRO = "FRO",
  FSM = "FSM",
  GAB = "GAB",
  GBR = "GBR",
  GEO = "GEO",
  GGY = "GGY",
  GHA = "GHA",
  GIB = "GIB",
  GIN = "GIN",
  GLP = "GLP",
  GMB = "GMB",
  GNB = "GNB",
  GNQ = "GNQ",
  GRC = "GRC",
  GRD = "GRD",
  GRL = "GRL",
  GTM = "GTM",
  GUF = "GUF",
  GUM = "GUM",
  GUY = "GUY",
  HKG = "HKG",
  HND = "HND",
  HRV = "HRV",
  HTI = "HTI",
  HUN = "HUN",
  IDN = "IDN",
  IMN = "IMN",
  IND = "IND",
  IRL = "IRL",
  IRQ = "IRQ",
  ISL = "ISL",
  ISR = "ISR",
  ITA = "ITA",
  JAM = "JAM",
  JEY = "JEY",
  JOR = "JOR",
  JPN = "JPN",
  KAZ = "KAZ",
  KEN = "KEN",
  KGZ = "KGZ",
  KHM = "KHM",
  KIR = "KIR",
  KNA = "KNA",
  KOR = "KOR",
  KWT = "KWT",
  LAO = "LAO",
  LBN = "LBN",
  LBR = "LBR",
  LBY = "LBY",
  LCA = "LCA",
  LIE = "LIE",
  LKA = "LKA",
  LSO = "LSO",
  LTU = "LTU",
  LUX = "LUX",
  LVA = "LVA",
  MAC = "MAC",
  MAR = "MAR",
  MCO = "MCO",
  MDA = "MDA",
  MDG = "MDG",
  MDV = "MDV",
  MEX = "MEX",
  MHL = "MHL",
  MKD = "MKD",
  MLI = "MLI",
  MLT = "MLT",
  MMR = "MMR",
  MNE = "MNE",
  MNG = "MNG",
  MNP = "MNP",
  MOZ = "MOZ",
  MRT = "MRT",
  MSR = "MSR",
  MTQ = "MTQ",
  MUS = "MUS",
  MWI = "MWI",
  MYS = "MYS",
  MYT = "MYT",
  NAM = "NAM",
  NCL = "NCL",
  NER = "NER",
  NFK = "NFK",
  NGA = "NGA",
  NIC = "NIC",
  NIU = "NIU",
  NLD = "NLD",
  NOR = "NOR",
  NPL = "NPL",
  NRU = "NRU",
  NZL = "NZL",
  OMN = "OMN",
  PAK = "PAK",
  PAN = "PAN",
  PER = "PER",
  PHL = "PHL",
  PLW = "PLW",
  PNG = "PNG",
  POL = "POL",
  PRI = "PRI",
  PRT = "PRT",
  PRY = "PRY",
  PSE = "PSE",
  PYF = "PYF",
  QAT = "QAT",
  REU = "REU",
  ROU = "ROU",
  RUS = "RUS",
  RWA = "RWA",
  SAU = "SAU",
  SEN = "SEN",
  SGP = "SGP",
  SHN = "SHN",
  SLB = "SLB",
  SLE = "SLE",
  SLV = "SLV",
  SMR = "SMR",
  SOM = "SOM",
  SPM = "SPM",
  SRB = "SRB",
  SSD = "SSD",
  STP = "STP",
  SUR = "SUR",
  SVK = "SVK",
  SVN = "SVN",
  SWE = "SWE",
  SWZ = "SWZ",
  SXM = "SXM",
  SYC = "SYC",
  TCA = "TCA",
  TCD = "TCD",
  TGO = "TGO",
  THA = "THA",
  TJK = "TJK",
  TKM = "TKM",
  TLS = "TLS",
  TON = "TON",
  TTO = "TTO",
  TUN = "TUN",
  TUR = "TUR",
  TUV = "TUV",
  TWN = "TWN",
  TZA = "TZA",
  UGA = "UGA",
  UKR = "UKR",
  UMI = "UMI",
  URY = "URY",
  USA = "USA",
  UZB = "UZB",
  VAT = "VAT",
  VCT = "VCT",
  VEN = "VEN",
  VGB = "VGB",
  VIR = "VIR",
  VNM = "VNM",
  VUT = "VUT",
  WLF = "WLF",
  WSM = "WSM",
  YEM = "YEM",
  ZAF = "ZAF",
  ZMB = "ZMB",
  ZWE = "ZWE",
}

export interface UploadOperation {
  method?: string;
  url?: string;
  length?: number;
  offset?: number;
  requestHeaders?: HttpHeader[];
}

export enum UserRole {
  ADMIN = "ADMIN",
  FINANCE = "FINANCE",
  ACCOUNT_HOLDER = "ACCOUNT_HOLDER",
  SALES = "SALES",
  MARKETING = "MARKETING",
  APP_MANAGER = "APP_MANAGER",
  DEVELOPER = "DEVELOPER",
  ACCESS_TO_REPORTS = "ACCESS_TO_REPORTS",
  CUSTOMER_SUPPORT = "CUSTOMER_SUPPORT",
  IMAGE_MANAGER = "IMAGE_MANAGER",
  CREATE_APPS = "CREATE_APPS",
  CLOUD_MANAGED_DEVELOPER_ID = "CLOUD_MANAGED_DEVELOPER_ID",
  CLOUD_MANAGED_APP_DISTRIBUTION = "CLOUD_MANAGED_APP_DISTRIBUTION",
  GENERATE_INDIVIDUAL_KEYS = "GENERATE_INDIVIDUAL_KEYS",
}

export type Csv = string;

export interface DiagnosticLogs {
  productData?: {
    signatureId?: string;
    diagnosticInsights?: {
      insightsURL?: string;
      insightsCategory?: string;
      insightsString?: string;
    }[];
    diagnosticLogs?: {
      callStackTree?: {
        callStackPerThread?: boolean;
        callStacks?: {
          callStackRootFrames?: DiagnosticLogCallStackNode[];
        }[];
      }[];
      diagnosticMetaData?: {
        bundleId?: string;
        event?: string;
        osVersion?: string;
        appVersion?: string;
        writesCaused?: string;
        deviceType?: string;
        platformArchitecture?: string;
        eventDetail?: string;
        buildVersion?: string;
      };
    }[];
  }[];
  version?: string;
}

/** @format binary */
export type Gzip = File;

export interface XcodeMetrics {
  version?: string;
  insights?: {
    trendingUp?: MetricsInsight[];
    regressions?: MetricsInsight[];
  };
  productData?: {
    platform?: string;
    metricCategories?: {
      identifier?: MetricCategory;
      metrics?: {
        identifier?: string;
        goalKeys?: {
          goalKey?: string;
          lowerBound?: number;
          upperBound?: number;
        }[];
        unit?: {
          identifier?: string;
          displayName?: string;
        };
        datasets?: {
          filterCriteria?: {
            percentile?: string;
            device?: string;
            deviceMarketingName?: string;
          };
          points?: {
            version?: string;
            value?: number;
            errorMargin?: number;
            percentageBreakdown?: {
              value?: number;
              subSystemLabel?: string;
            };
            goal?: string;
          }[];
        }[];
      }[];
    }[];
  }[];
}

export type QueryParamsType = Record<string | number, any>;
export type ResponseFormat = keyof Omit<Body, "body" | "bodyUsed">;

export interface FullRequestParams extends Omit<RequestInit, "body"> {
  /** set parameter to `true` for call `securityWorker` for this request */
  secure?: boolean;
  /** request path */
  path: string;
  /** content type of request body */
  type?: ContentType;
  /** query params */
  query?: QueryParamsType;
  /** format of response (i.e. response.json() -> format: "json") */
  format?: ResponseFormat;
  /** request body */
  body?: unknown;
  /** base url */
  baseUrl?: string;
  /** request cancellation token */
  cancelToken?: CancelToken;
}

export type RequestParams = Omit<FullRequestParams, "body" | "method" | "query" | "path">;

export interface ApiConfig<SecurityDataType = unknown> {
  baseUrl?: string;
  baseApiParams?: Omit<RequestParams, "baseUrl" | "cancelToken" | "signal">;
  securityWorker?: (securityData: SecurityDataType | null) => Promise<RequestParams | void> | RequestParams | void;
  customFetch?: typeof fetch;
}

export interface HttpResponse<D extends unknown, E extends unknown = unknown> extends Response {
  data: D;
  error: E;
}

type CancelToken = Symbol | string | number;

export enum ContentType {
  Json = "application/json; charset=utf-8",
  FormData = "multipart/form-data",
  UrlEncoded = "application/x-www-form-urlencoded",
  Text = "text/plain",
}

export class HttpClient<SecurityDataType = unknown> {
  public baseUrl: string = "https://api.appstoreconnect.apple.com";
  private securityData: SecurityDataType | null = null;
  private securityWorker?: ApiConfig<SecurityDataType>["securityWorker"];
  private abortControllers = new Map<CancelToken, AbortController>();
  private customFetch = (...fetchParams: Parameters<typeof fetch>) => fetch(...fetchParams);

  private baseApiParams: RequestParams = {
    credentials: "same-origin",
    headers: {},
    redirect: "follow",
    referrerPolicy: "no-referrer",
  };

  constructor(apiConfig: ApiConfig<SecurityDataType> = {}) {
    Object.assign(this, apiConfig);
  }

  public setSecurityData = (data: SecurityDataType | null) => {
    this.securityData = data;
  };

  protected encodeQueryParam(key: string, value: any) {
    const encodedKey = encodeURIComponent(key);
    return `${encodedKey}=${encodeURIComponent(typeof value === "number" ? value : `${value}`)}`;
  }

  protected addQueryParam(query: QueryParamsType, key: string) {
    return this.encodeQueryParam(key, query[key]);
  }

  protected addArrayQueryParam(query: QueryParamsType, key: string) {
    const value = query[key];
    return value.map((v: any) => this.encodeQueryParam(key, v)).join("&");
  }

  protected toQueryString(rawQuery?: QueryParamsType): string {
    const query = rawQuery || {};
    const keys = Object.keys(query).filter((key) => "undefined" !== typeof query[key]);
    return keys
      .map((key) => (Array.isArray(query[key]) ? this.addArrayQueryParam(query, key) : this.addQueryParam(query, key)))
      .join("&");
  }

  protected addQueryParams(rawQuery?: QueryParamsType): string {
    const queryString = this.toQueryString(rawQuery);
    return queryString ? `?${queryString}` : "";
  }

  private contentFormatters: Record<ContentType, (input: any) => any> = {
    [ContentType.Json]: (input: any) =>
      input !== null && (typeof input === "object" || typeof input === "string") ? JSON.stringify(input) : input,
    [ContentType.Text]: (input: any) => (input !== null && typeof input !== "string" ? JSON.stringify(input) : input),
    [ContentType.FormData]: (input: any) =>
      Object.keys(input || {}).reduce((formData, key) => {
        const property = input[key];
        formData.append(
          key,
          property instanceof Blob
            ? property
            : typeof property === "object" && property !== null
            ? JSON.stringify(property)
            : `${property}`,
        );
        return formData;
      }, new FormData()),
    [ContentType.UrlEncoded]: (input: any) => this.toQueryString(input),
  };

  protected mergeRequestParams(params1: RequestParams, params2?: RequestParams): RequestParams {
    return {
      ...this.baseApiParams,
      ...params1,
      ...(params2 || {}),
      headers: {
        ...(this.baseApiParams.headers || {}),
        ...(params1.headers || {}),
        ...((params2 && params2.headers) || {}),
      },
    };
  }

  protected createAbortSignal = (cancelToken: CancelToken): AbortSignal | undefined => {
    if (this.abortControllers.has(cancelToken)) {
      const abortController = this.abortControllers.get(cancelToken);
      if (abortController) {
        return abortController.signal;
      }
      return void 0;
    }

    const abortController = new AbortController();
    this.abortControllers.set(cancelToken, abortController);
    return abortController.signal;
  };

  public abortRequest = (cancelToken: CancelToken) => {
    const abortController = this.abortControllers.get(cancelToken);

    if (abortController) {
      abortController.abort();
      this.abortControllers.delete(cancelToken);
    }
  };

  public request = async <T = any, E = any>({
    body,
    secure,
    path,
    type,
    query,
    format,
    baseUrl,
    cancelToken,
    ...params
  }: FullRequestParams): Promise<T> => {
    const secureParams =
      ((typeof secure === "boolean" ? secure : this.baseApiParams.secure) &&
        this.securityWorker &&
        (await this.securityWorker(this.securityData))) ||
      {};
    const requestParams = this.mergeRequestParams(params, secureParams);
    const queryString = query && this.toQueryString(query);
    const payloadFormatter = this.contentFormatters[type || ContentType.Json];
    const responseFormat = format || requestParams.format;

    return this.customFetch(`${baseUrl || this.baseUrl || ""}${path}${queryString ? `?${queryString}` : ""}`, {
      ...requestParams,
      headers: {
        ...(requestParams.headers || {}),
        ...(type && type !== ContentType.FormData ? { "Content-Type": type } : {}),
      },
      signal: (cancelToken ? this.createAbortSignal(cancelToken) : requestParams.signal) || null,
      body: typeof body === "undefined" || body === null ? null : payloadFormatter(body),
    }).then(async (response) => {
      const r = response as HttpResponse<T, E>;
      r.data = null as unknown as T;
      r.error = null as unknown as E;

      const data = !responseFormat
        ? r
        : await response[responseFormat]()
            .then((data) => {
              if (r.ok) {
                r.data = data;
              } else {
                r.error = data;
              }
              return r;
            })
            .catch((e) => {
              r.error = e;
              return r;
            });

      if (cancelToken) {
        this.abortControllers.delete(cancelToken);
      }

      if (!response.ok) throw data;
      return data.data;
    });
  };
}

/**
 * @title App Store Connect API
 * @version 3.4.1
 * @baseUrl https://api.appstoreconnect.apple.com/
 */
export class AppStoreConnectClient<SecurityDataType extends unknown> extends HttpClient<SecurityDataType> {
  actors = {
    /**
     * No description
     *
     * @tags Actors
     * @name ActorsGetCollection
     * @request GET:/v1/actors
     * @secure
     */
    getCollection: (
      query: {
        /** filter by id(s) */
        "filter[id]": string[];
        /** the fields to include for returned resources of type actors */
        "fields[actors]"?: ("actorType" | "apiKeyId" | "userEmail" | "userFirstName" | "userLastName")[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
      },
      params: RequestParams = {},
    ): Promise<ActorsResponse> =>
      this.request<ActorsResponse, ErrorResponse>({
        path: `/v1/actors`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Actors
     * @name ActorsGetInstance
     * @request GET:/v1/actors/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type actors */
        "fields[actors]"?: ("actorType" | "apiKeyId" | "userEmail" | "userFirstName" | "userLastName")[];
      },
      params: RequestParams = {},
    ): Promise<ActorResponse> =>
      this.request<ActorResponse, ErrorResponse>({
        path: `/v1/actors/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  ageRatingDeclarations = {
    /**
     * No description
     *
     * @tags AgeRatingDeclarations
     * @name AgeRatingDeclarationsUpdateInstance
     * @request PATCH:/v1/ageRatingDeclarations/{id}
     * @secure
     */
    updateInstance: (
      id: string,
      data: AgeRatingDeclarationUpdateRequest,
      params: RequestParams = {},
    ): Promise<AgeRatingDeclarationResponse> =>
      this.request<AgeRatingDeclarationResponse, ErrorResponse>({
        path: `/v1/ageRatingDeclarations/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),
  };
  alternativeDistributionDomains = {
    /**
     * No description
     *
     * @tags AlternativeDistributionDomains
     * @name AlternativeDistributionDomainsGetCollection
     * @request GET:/v1/alternativeDistributionDomains
     * @secure
     */
    getCollection: (
      query?: {
        /** the fields to include for returned resources of type alternativeDistributionDomains */
        "fields[alternativeDistributionDomains]"?: ("createdDate" | "domain" | "referenceName")[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
      },
      params: RequestParams = {},
    ): Promise<AlternativeDistributionDomainsResponse> =>
      this.request<AlternativeDistributionDomainsResponse, ErrorResponse>({
        path: `/v1/alternativeDistributionDomains`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AlternativeDistributionDomains
     * @name AlternativeDistributionDomainsCreateInstance
     * @request POST:/v1/alternativeDistributionDomains
     * @secure
     */
    createInstance: (
      data: AlternativeDistributionDomainCreateRequest,
      params: RequestParams = {},
    ): Promise<AlternativeDistributionDomainResponse> =>
      this.request<AlternativeDistributionDomainResponse, ErrorResponse>({
        path: `/v1/alternativeDistributionDomains`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AlternativeDistributionDomains
     * @name AlternativeDistributionDomainsGetInstance
     * @request GET:/v1/alternativeDistributionDomains/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type alternativeDistributionDomains */
        "fields[alternativeDistributionDomains]"?: ("createdDate" | "domain" | "referenceName")[];
      },
      params: RequestParams = {},
    ): Promise<AlternativeDistributionDomainResponse> =>
      this.request<AlternativeDistributionDomainResponse, ErrorResponse>({
        path: `/v1/alternativeDistributionDomains/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AlternativeDistributionDomains
     * @name AlternativeDistributionDomainsDeleteInstance
     * @request DELETE:/v1/alternativeDistributionDomains/{id}
     * @secure
     */
    deleteInstance: (id: string, params: RequestParams = {}): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/alternativeDistributionDomains/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),
  };
  alternativeDistributionKeys = {
    /**
     * No description
     *
     * @tags AlternativeDistributionKeys
     * @name AlternativeDistributionKeysCreateInstance
     * @request POST:/v1/alternativeDistributionKeys
     * @secure
     */
    createInstance: (
      data: AlternativeDistributionKeyCreateRequest,
      params: RequestParams = {},
    ): Promise<AlternativeDistributionKeyResponse> =>
      this.request<AlternativeDistributionKeyResponse, ErrorResponse>({
        path: `/v1/alternativeDistributionKeys`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AlternativeDistributionKeys
     * @name AlternativeDistributionKeysGetInstance
     * @request GET:/v1/alternativeDistributionKeys/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type alternativeDistributionKeys */
        "fields[alternativeDistributionKeys]"?: ("app" | "publicKey")[];
      },
      params: RequestParams = {},
    ): Promise<AlternativeDistributionKeyResponse> =>
      this.request<AlternativeDistributionKeyResponse, ErrorResponse>({
        path: `/v1/alternativeDistributionKeys/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AlternativeDistributionKeys
     * @name AlternativeDistributionKeysDeleteInstance
     * @request DELETE:/v1/alternativeDistributionKeys/{id}
     * @secure
     */
    deleteInstance: (id: string, params: RequestParams = {}): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/alternativeDistributionKeys/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),
  };
  alternativeDistributionPackageDeltas = {
    /**
     * No description
     *
     * @tags AlternativeDistributionPackageDeltas
     * @name AlternativeDistributionPackageDeltasGetInstance
     * @request GET:/v1/alternativeDistributionPackageDeltas/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type alternativeDistributionPackageDeltas */
        "fields[alternativeDistributionPackageDeltas]"?: (
          | "alternativeDistributionKeyBlob"
          | "fileChecksum"
          | "url"
          | "urlExpirationDate"
        )[];
      },
      params: RequestParams = {},
    ): Promise<AlternativeDistributionPackageDeltaResponse> =>
      this.request<AlternativeDistributionPackageDeltaResponse, ErrorResponse>({
        path: `/v1/alternativeDistributionPackageDeltas/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  alternativeDistributionPackageVariants = {
    /**
     * No description
     *
     * @tags AlternativeDistributionPackageVariants
     * @name AlternativeDistributionPackageVariantsGetInstance
     * @request GET:/v1/alternativeDistributionPackageVariants/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type alternativeDistributionPackageVariants */
        "fields[alternativeDistributionPackageVariants]"?: (
          | "alternativeDistributionKeyBlob"
          | "fileChecksum"
          | "url"
          | "urlExpirationDate"
        )[];
      },
      params: RequestParams = {},
    ): Promise<AlternativeDistributionPackageVariantResponse> =>
      this.request<AlternativeDistributionPackageVariantResponse, ErrorResponse>({
        path: `/v1/alternativeDistributionPackageVariants/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  alternativeDistributionPackageVersions = {
    /**
     * No description
     *
     * @tags AlternativeDistributionPackageVersions
     * @name AlternativeDistributionPackageVersionsGetInstance
     * @request GET:/v1/alternativeDistributionPackageVersions/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type alternativeDistributionPackageVersions */
        "fields[alternativeDistributionPackageVersions]"?: (
          | "alternativeDistributionPackage"
          | "deltas"
          | "fileChecksum"
          | "state"
          | "url"
          | "urlExpirationDate"
          | "variants"
          | "version"
        )[];
        /** comma-separated list of relationships to include */
        include?: ("alternativeDistributionPackage" | "deltas" | "variants")[];
        /** the fields to include for returned resources of type alternativeDistributionPackageVariants */
        "fields[alternativeDistributionPackageVariants]"?: (
          | "alternativeDistributionKeyBlob"
          | "fileChecksum"
          | "url"
          | "urlExpirationDate"
        )[];
        /** the fields to include for returned resources of type alternativeDistributionPackageDeltas */
        "fields[alternativeDistributionPackageDeltas]"?: (
          | "alternativeDistributionKeyBlob"
          | "fileChecksum"
          | "url"
          | "urlExpirationDate"
        )[];
        /**
         * maximum number of related deltas returned (when they are included)
         * @max 50
         */
        "limit[deltas]"?: number;
        /**
         * maximum number of related variants returned (when they are included)
         * @max 50
         */
        "limit[variants]"?: number;
      },
      params: RequestParams = {},
    ): Promise<AlternativeDistributionPackageVersionResponse> =>
      this.request<AlternativeDistributionPackageVersionResponse, ErrorResponse>({
        path: `/v1/alternativeDistributionPackageVersions/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AlternativeDistributionPackageVersions
     * @name AlternativeDistributionPackageVersionsDeltasGetToManyRelated
     * @request GET:/v1/alternativeDistributionPackageVersions/{id}/deltas
     * @secure
     */
    deltasGetToManyRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type alternativeDistributionPackageDeltas */
        "fields[alternativeDistributionPackageDeltas]"?: (
          | "alternativeDistributionKeyBlob"
          | "fileChecksum"
          | "url"
          | "urlExpirationDate"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
      },
      params: RequestParams = {},
    ): Promise<AlternativeDistributionPackageDeltasResponse> =>
      this.request<AlternativeDistributionPackageDeltasResponse, ErrorResponse>({
        path: `/v1/alternativeDistributionPackageVersions/${id}/deltas`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AlternativeDistributionPackageVersions
     * @name AlternativeDistributionPackageVersionsVariantsGetToManyRelated
     * @request GET:/v1/alternativeDistributionPackageVersions/{id}/variants
     * @secure
     */
    variantsGetToManyRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type alternativeDistributionPackageVariants */
        "fields[alternativeDistributionPackageVariants]"?: (
          | "alternativeDistributionKeyBlob"
          | "fileChecksum"
          | "url"
          | "urlExpirationDate"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
      },
      params: RequestParams = {},
    ): Promise<AlternativeDistributionPackageVariantsResponse> =>
      this.request<AlternativeDistributionPackageVariantsResponse, ErrorResponse>({
        path: `/v1/alternativeDistributionPackageVersions/${id}/variants`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  alternativeDistributionPackages = {
    /**
     * No description
     *
     * @tags AlternativeDistributionPackages
     * @name AlternativeDistributionPackagesCreateInstance
     * @request POST:/v1/alternativeDistributionPackages
     * @secure
     */
    createInstance: (
      data: AlternativeDistributionPackageCreateRequest,
      params: RequestParams = {},
    ): Promise<AlternativeDistributionPackageResponse> =>
      this.request<AlternativeDistributionPackageResponse, ErrorResponse>({
        path: `/v1/alternativeDistributionPackages`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AlternativeDistributionPackages
     * @name AlternativeDistributionPackagesGetInstance
     * @request GET:/v1/alternativeDistributionPackages/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type alternativeDistributionPackages */
        "fields[alternativeDistributionPackages]"?: ("appStoreVersion" | "versions")[];
        /** comma-separated list of relationships to include */
        include?: "versions"[];
        /** the fields to include for returned resources of type alternativeDistributionPackageVersions */
        "fields[alternativeDistributionPackageVersions]"?: (
          | "alternativeDistributionPackage"
          | "deltas"
          | "fileChecksum"
          | "state"
          | "url"
          | "urlExpirationDate"
          | "variants"
          | "version"
        )[];
        /**
         * maximum number of related versions returned (when they are included)
         * @max 50
         */
        "limit[versions]"?: number;
      },
      params: RequestParams = {},
    ): Promise<AlternativeDistributionPackageResponse> =>
      this.request<AlternativeDistributionPackageResponse, ErrorResponse>({
        path: `/v1/alternativeDistributionPackages/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AlternativeDistributionPackages
     * @name AlternativeDistributionPackagesVersionsGetToManyRelated
     * @request GET:/v1/alternativeDistributionPackages/{id}/versions
     * @secure
     */
    versionsGetToManyRelated: (
      id: string,
      query?: {
        /** filter by attribute 'state' */
        "filter[state]"?: ("COMPLETED" | "REPLACED")[];
        /** the fields to include for returned resources of type alternativeDistributionPackageVariants */
        "fields[alternativeDistributionPackageVariants]"?: (
          | "alternativeDistributionKeyBlob"
          | "fileChecksum"
          | "url"
          | "urlExpirationDate"
        )[];
        /** the fields to include for returned resources of type alternativeDistributionPackages */
        "fields[alternativeDistributionPackages]"?: ("appStoreVersion" | "versions")[];
        /** the fields to include for returned resources of type alternativeDistributionPackageVersions */
        "fields[alternativeDistributionPackageVersions]"?: (
          | "alternativeDistributionPackage"
          | "deltas"
          | "fileChecksum"
          | "state"
          | "url"
          | "urlExpirationDate"
          | "variants"
          | "version"
        )[];
        /** the fields to include for returned resources of type alternativeDistributionPackageDeltas */
        "fields[alternativeDistributionPackageDeltas]"?: (
          | "alternativeDistributionKeyBlob"
          | "fileChecksum"
          | "url"
          | "urlExpirationDate"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /**
         * maximum number of related variants returned (when they are included)
         * @max 50
         */
        "limit[variants]"?: number;
        /**
         * maximum number of related deltas returned (when they are included)
         * @max 50
         */
        "limit[deltas]"?: number;
        /** comma-separated list of relationships to include */
        include?: ("alternativeDistributionPackage" | "deltas" | "variants")[];
      },
      params: RequestParams = {},
    ): Promise<AlternativeDistributionPackageVersionsResponse> =>
      this.request<AlternativeDistributionPackageVersionsResponse, ErrorResponse>({
        path: `/v1/alternativeDistributionPackages/${id}/versions`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  analyticsReportInstances = {
    /**
     * No description
     *
     * @tags AnalyticsReportInstances
     * @name AnalyticsReportInstancesGetInstance
     * @request GET:/v1/analyticsReportInstances/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type analyticsReportInstances */
        "fields[analyticsReportInstances]"?: ("granularity" | "processingDate" | "segments")[];
        /** the fields to include for returned resources of type analyticsReportSegments */
        "fields[analyticsReportSegments]"?: ("checksum" | "sizeInBytes" | "url")[];
      },
      params: RequestParams = {},
    ): Promise<AnalyticsReportInstanceResponse> =>
      this.request<AnalyticsReportInstanceResponse, ErrorResponse>({
        path: `/v1/analyticsReportInstances/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AnalyticsReportInstances
     * @name AnalyticsReportInstancesSegmentsGetToManyRelated
     * @request GET:/v1/analyticsReportInstances/{id}/segments
     * @secure
     */
    segmentsGetToManyRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type analyticsReportSegments */
        "fields[analyticsReportSegments]"?: ("checksum" | "sizeInBytes" | "url")[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
      },
      params: RequestParams = {},
    ): Promise<AnalyticsReportSegmentsResponse> =>
      this.request<AnalyticsReportSegmentsResponse, ErrorResponse>({
        path: `/v1/analyticsReportInstances/${id}/segments`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  analyticsReportRequests = {
    /**
     * No description
     *
     * @tags AnalyticsReportRequests
     * @name AnalyticsReportRequestsCreateInstance
     * @request POST:/v1/analyticsReportRequests
     * @secure
     */
    createInstance: (
      data: AnalyticsReportRequestCreateRequest,
      params: RequestParams = {},
    ): Promise<AnalyticsReportRequestResponse> =>
      this.request<AnalyticsReportRequestResponse, ErrorResponse>({
        path: `/v1/analyticsReportRequests`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AnalyticsReportRequests
     * @name AnalyticsReportRequestsGetInstance
     * @request GET:/v1/analyticsReportRequests/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type analyticsReportRequests */
        "fields[analyticsReportRequests]"?: ("accessType" | "app" | "reports" | "stoppedDueToInactivity")[];
        /** comma-separated list of relationships to include */
        include?: "reports"[];
        /** the fields to include for returned resources of type analyticsReports */
        "fields[analyticsReports]"?: ("category" | "instances" | "name")[];
        /**
         * maximum number of related reports returned (when they are included)
         * @max 50
         */
        "limit[reports]"?: number;
      },
      params: RequestParams = {},
    ): Promise<AnalyticsReportRequestResponse> =>
      this.request<AnalyticsReportRequestResponse, ErrorResponse>({
        path: `/v1/analyticsReportRequests/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AnalyticsReportRequests
     * @name AnalyticsReportRequestsDeleteInstance
     * @request DELETE:/v1/analyticsReportRequests/{id}
     * @secure
     */
    deleteInstance: (id: string, params: RequestParams = {}): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/analyticsReportRequests/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),

    /**
     * No description
     *
     * @tags AnalyticsReportRequests
     * @name AnalyticsReportRequestsReportsGetToManyRelated
     * @request GET:/v1/analyticsReportRequests/{id}/reports
     * @secure
     */
    reportsGetToManyRelated: (
      id: string,
      query?: {
        /** filter by attribute 'category' */
        "filter[category]"?: ("APP_USAGE" | "APP_STORE_ENGAGEMENT" | "COMMERCE" | "FRAMEWORK_USAGE" | "PERFORMANCE")[];
        /** filter by attribute 'name' */
        "filter[name]"?: string[];
        /** the fields to include for returned resources of type analyticsReports */
        "fields[analyticsReports]"?: ("category" | "instances" | "name")[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
      },
      params: RequestParams = {},
    ): Promise<AnalyticsReportsResponse> =>
      this.request<AnalyticsReportsResponse, ErrorResponse>({
        path: `/v1/analyticsReportRequests/${id}/reports`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  analyticsReportSegments = {
    /**
     * No description
     *
     * @tags AnalyticsReportSegments
     * @name AnalyticsReportSegmentsGetInstance
     * @request GET:/v1/analyticsReportSegments/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type analyticsReportSegments */
        "fields[analyticsReportSegments]"?: ("checksum" | "sizeInBytes" | "url")[];
      },
      params: RequestParams = {},
    ): Promise<AnalyticsReportSegmentResponse> =>
      this.request<AnalyticsReportSegmentResponse, ErrorResponse>({
        path: `/v1/analyticsReportSegments/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  analyticsReports = {
    /**
     * No description
     *
     * @tags AnalyticsReports
     * @name AnalyticsReportsGetInstance
     * @request GET:/v1/analyticsReports/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type analyticsReports */
        "fields[analyticsReports]"?: ("category" | "instances" | "name")[];
        /** the fields to include for returned resources of type analyticsReportInstances */
        "fields[analyticsReportInstances]"?: ("granularity" | "processingDate" | "segments")[];
      },
      params: RequestParams = {},
    ): Promise<AnalyticsReportResponse> =>
      this.request<AnalyticsReportResponse, ErrorResponse>({
        path: `/v1/analyticsReports/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AnalyticsReports
     * @name AnalyticsReportsInstancesGetToManyRelated
     * @request GET:/v1/analyticsReports/{id}/instances
     * @secure
     */
    instancesGetToManyRelated: (
      id: string,
      query?: {
        /** filter by attribute 'granularity' */
        "filter[granularity]"?: ("DAILY" | "WEEKLY" | "MONTHLY")[];
        /** filter by attribute 'processingDate' */
        "filter[processingDate]"?: string[];
        /** the fields to include for returned resources of type analyticsReportInstances */
        "fields[analyticsReportInstances]"?: ("granularity" | "processingDate" | "segments")[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
      },
      params: RequestParams = {},
    ): Promise<AnalyticsReportInstancesResponse> =>
      this.request<AnalyticsReportInstancesResponse, ErrorResponse>({
        path: `/v1/analyticsReports/${id}/instances`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  appAvailabilities = {
    /**
     * No description
     *
     * @tags AppAvailabilities
     * @name AppAvailabilitiesV2CreateInstance
     * @request POST:/v2/appAvailabilities
     * @secure
     */
    v2CreateInstance: (
      data: AppAvailabilityV2CreateRequest,
      params: RequestParams = {},
    ): Promise<AppAvailabilityV2Response> =>
      this.request<AppAvailabilityV2Response, ErrorResponse>({
        path: `/v2/appAvailabilities`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppAvailabilities
     * @name AppAvailabilitiesV2GetInstance
     * @request GET:/v2/appAvailabilities/{id}
     * @secure
     */
    v2GetInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type appAvailabilities */
        "fields[appAvailabilities]"?: ("app" | "availableInNewTerritories" | "territoryAvailabilities")[];
        /** comma-separated list of relationships to include */
        include?: "territoryAvailabilities"[];
        /** the fields to include for returned resources of type territoryAvailabilities */
        "fields[territoryAvailabilities]"?: (
          | "available"
          | "contentStatuses"
          | "preOrderEnabled"
          | "preOrderPublishDate"
          | "releaseDate"
          | "territory"
        )[];
        /**
         * maximum number of related territoryAvailabilities returned (when they are included)
         * @max 50
         */
        "limit[territoryAvailabilities]"?: number;
      },
      params: RequestParams = {},
    ): Promise<AppAvailabilityV2Response> =>
      this.request<AppAvailabilityV2Response, ErrorResponse>({
        path: `/v2/appAvailabilities/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppAvailabilities
     * @name AppAvailabilitiesCreateInstance
     * @request POST:/v1/appAvailabilities
     * @deprecated
     * @secure
     */
    createInstance: (
      data: AppAvailabilityCreateRequest,
      params: RequestParams = {},
    ): Promise<AppAvailabilityResponse> =>
      this.request<AppAvailabilityResponse, ErrorResponse>({
        path: `/v1/appAvailabilities`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppAvailabilities
     * @name AppAvailabilitiesGetInstance
     * @request GET:/v1/appAvailabilities/{id}
     * @deprecated
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type appAvailabilities */
        "fields[appAvailabilities]"?: ("app" | "availableInNewTerritories" | "availableTerritories")[];
        /** comma-separated list of relationships to include */
        include?: ("app" | "availableTerritories")[];
        /** the fields to include for returned resources of type territories */
        "fields[territories]"?: "currency"[];
        /**
         * maximum number of related availableTerritories returned (when they are included)
         * @max 50
         */
        "limit[availableTerritories]"?: number;
      },
      params: RequestParams = {},
    ): Promise<AppAvailabilityResponse> =>
      this.request<AppAvailabilityResponse, ErrorResponse>({
        path: `/v1/appAvailabilities/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppAvailabilities
     * @name AppAvailabilitiesV2TerritoryAvailabilitiesGetToManyRelated
     * @request GET:/v2/appAvailabilities/{id}/territoryAvailabilities
     * @secure
     */
    v2TerritoryAvailabilitiesGetToManyRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type territoryAvailabilities */
        "fields[territoryAvailabilities]"?: (
          | "available"
          | "contentStatuses"
          | "preOrderEnabled"
          | "preOrderPublishDate"
          | "releaseDate"
          | "territory"
        )[];
        /** the fields to include for returned resources of type territories */
        "fields[territories]"?: "currency"[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /** comma-separated list of relationships to include */
        include?: "territory"[];
      },
      params: RequestParams = {},
    ): Promise<TerritoryAvailabilitiesResponse> =>
      this.request<TerritoryAvailabilitiesResponse, ErrorResponse>({
        path: `/v2/appAvailabilities/${id}/territoryAvailabilities`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppAvailabilities
     * @name AppAvailabilitiesAvailableTerritoriesGetToManyRelated
     * @request GET:/v1/appAvailabilities/{id}/availableTerritories
     * @deprecated
     * @secure
     */
    availableTerritoriesGetToManyRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type territories */
        "fields[territories]"?: "currency"[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
      },
      params: RequestParams = {},
    ): Promise<TerritoriesResponse> =>
      this.request<TerritoriesResponse, ErrorResponse>({
        path: `/v1/appAvailabilities/${id}/availableTerritories`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  appCategories = {
    /**
     * No description
     *
     * @tags AppCategories
     * @name AppCategoriesGetCollection
     * @request GET:/v1/appCategories
     * @secure
     */
    getCollection: (
      query?: {
        /** filter by attribute 'platforms' */
        "filter[platforms]"?: ("IOS" | "MAC_OS" | "TV_OS" | "VISION_OS")[];
        /** filter by existence or non-existence of related 'parent' */
        "exists[parent]"?: boolean;
        /** the fields to include for returned resources of type appCategories */
        "fields[appCategories]"?: ("parent" | "platforms" | "subcategories")[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /** comma-separated list of relationships to include */
        include?: ("parent" | "subcategories")[];
        /**
         * maximum number of related subcategories returned (when they are included)
         * @max 50
         */
        "limit[subcategories]"?: number;
      },
      params: RequestParams = {},
    ): Promise<AppCategoriesResponse> =>
      this.request<AppCategoriesResponse, ErrorResponse>({
        path: `/v1/appCategories`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppCategories
     * @name AppCategoriesGetInstance
     * @request GET:/v1/appCategories/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type appCategories */
        "fields[appCategories]"?: ("parent" | "platforms" | "subcategories")[];
        /** comma-separated list of relationships to include */
        include?: ("parent" | "subcategories")[];
        /**
         * maximum number of related subcategories returned (when they are included)
         * @max 50
         */
        "limit[subcategories]"?: number;
      },
      params: RequestParams = {},
    ): Promise<AppCategoryResponse> =>
      this.request<AppCategoryResponse, ErrorResponse>({
        path: `/v1/appCategories/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppCategories
     * @name AppCategoriesParentGetToOneRelated
     * @request GET:/v1/appCategories/{id}/parent
     * @secure
     */
    parentGetToOneRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type appCategories */
        "fields[appCategories]"?: ("parent" | "platforms" | "subcategories")[];
      },
      params: RequestParams = {},
    ): Promise<AppCategoryWithoutIncludesResponse> =>
      this.request<AppCategoryWithoutIncludesResponse, ErrorResponse>({
        path: `/v1/appCategories/${id}/parent`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppCategories
     * @name AppCategoriesSubcategoriesGetToManyRelated
     * @request GET:/v1/appCategories/{id}/subcategories
     * @secure
     */
    subcategoriesGetToManyRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type appCategories */
        "fields[appCategories]"?: ("parent" | "platforms" | "subcategories")[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
      },
      params: RequestParams = {},
    ): Promise<AppCategoriesWithoutIncludesResponse> =>
      this.request<AppCategoriesWithoutIncludesResponse, ErrorResponse>({
        path: `/v1/appCategories/${id}/subcategories`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  appClipAdvancedExperienceImages = {
    /**
     * No description
     *
     * @tags AppClipAdvancedExperienceImages
     * @name AppClipAdvancedExperienceImagesCreateInstance
     * @request POST:/v1/appClipAdvancedExperienceImages
     * @secure
     */
    createInstance: (
      data: AppClipAdvancedExperienceImageCreateRequest,
      params: RequestParams = {},
    ): Promise<AppClipAdvancedExperienceImageResponse> =>
      this.request<AppClipAdvancedExperienceImageResponse, ErrorResponse>({
        path: `/v1/appClipAdvancedExperienceImages`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppClipAdvancedExperienceImages
     * @name AppClipAdvancedExperienceImagesGetInstance
     * @request GET:/v1/appClipAdvancedExperienceImages/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type appClipAdvancedExperienceImages */
        "fields[appClipAdvancedExperienceImages]"?: (
          | "assetDeliveryState"
          | "fileName"
          | "fileSize"
          | "imageAsset"
          | "sourceFileChecksum"
          | "uploadOperations"
          | "uploaded"
        )[];
      },
      params: RequestParams = {},
    ): Promise<AppClipAdvancedExperienceImageResponse> =>
      this.request<AppClipAdvancedExperienceImageResponse, ErrorResponse>({
        path: `/v1/appClipAdvancedExperienceImages/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppClipAdvancedExperienceImages
     * @name AppClipAdvancedExperienceImagesUpdateInstance
     * @request PATCH:/v1/appClipAdvancedExperienceImages/{id}
     * @secure
     */
    updateInstance: (
      id: string,
      data: AppClipAdvancedExperienceImageUpdateRequest,
      params: RequestParams = {},
    ): Promise<AppClipAdvancedExperienceImageResponse> =>
      this.request<AppClipAdvancedExperienceImageResponse, ErrorResponse>({
        path: `/v1/appClipAdvancedExperienceImages/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),
  };
  appClipAdvancedExperiences = {
    /**
     * No description
     *
     * @tags AppClipAdvancedExperiences
     * @name AppClipAdvancedExperiencesCreateInstance
     * @request POST:/v1/appClipAdvancedExperiences
     * @secure
     */
    createInstance: (
      data: AppClipAdvancedExperienceCreateRequest,
      params: RequestParams = {},
    ): Promise<AppClipAdvancedExperienceResponse> =>
      this.request<AppClipAdvancedExperienceResponse, ErrorResponse>({
        path: `/v1/appClipAdvancedExperiences`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppClipAdvancedExperiences
     * @name AppClipAdvancedExperiencesGetInstance
     * @request GET:/v1/appClipAdvancedExperiences/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type appClipAdvancedExperiences */
        "fields[appClipAdvancedExperiences]"?: (
          | "action"
          | "appClip"
          | "businessCategory"
          | "defaultLanguage"
          | "headerImage"
          | "isPoweredBy"
          | "link"
          | "localizations"
          | "place"
          | "placeStatus"
          | "removed"
          | "status"
          | "version"
        )[];
        /** comma-separated list of relationships to include */
        include?: ("appClip" | "headerImage" | "localizations")[];
        /**
         * maximum number of related localizations returned (when they are included)
         * @max 50
         */
        "limit[localizations]"?: number;
      },
      params: RequestParams = {},
    ): Promise<AppClipAdvancedExperienceResponse> =>
      this.request<AppClipAdvancedExperienceResponse, ErrorResponse>({
        path: `/v1/appClipAdvancedExperiences/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppClipAdvancedExperiences
     * @name AppClipAdvancedExperiencesUpdateInstance
     * @request PATCH:/v1/appClipAdvancedExperiences/{id}
     * @secure
     */
    updateInstance: (
      id: string,
      data: AppClipAdvancedExperienceUpdateRequest,
      params: RequestParams = {},
    ): Promise<AppClipAdvancedExperienceResponse> =>
      this.request<AppClipAdvancedExperienceResponse, ErrorResponse>({
        path: `/v1/appClipAdvancedExperiences/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),
  };
  appClipAppStoreReviewDetails = {
    /**
     * No description
     *
     * @tags AppClipAppStoreReviewDetails
     * @name AppClipAppStoreReviewDetailsCreateInstance
     * @request POST:/v1/appClipAppStoreReviewDetails
     * @secure
     */
    createInstance: (
      data: AppClipAppStoreReviewDetailCreateRequest,
      params: RequestParams = {},
    ): Promise<AppClipAppStoreReviewDetailResponse> =>
      this.request<AppClipAppStoreReviewDetailResponse, ErrorResponse>({
        path: `/v1/appClipAppStoreReviewDetails`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppClipAppStoreReviewDetails
     * @name AppClipAppStoreReviewDetailsGetInstance
     * @request GET:/v1/appClipAppStoreReviewDetails/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type appClipAppStoreReviewDetails */
        "fields[appClipAppStoreReviewDetails]"?: ("appClipDefaultExperience" | "invocationUrls")[];
        /** comma-separated list of relationships to include */
        include?: "appClipDefaultExperience"[];
      },
      params: RequestParams = {},
    ): Promise<AppClipAppStoreReviewDetailResponse> =>
      this.request<AppClipAppStoreReviewDetailResponse, ErrorResponse>({
        path: `/v1/appClipAppStoreReviewDetails/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppClipAppStoreReviewDetails
     * @name AppClipAppStoreReviewDetailsUpdateInstance
     * @request PATCH:/v1/appClipAppStoreReviewDetails/{id}
     * @secure
     */
    updateInstance: (
      id: string,
      data: AppClipAppStoreReviewDetailUpdateRequest,
      params: RequestParams = {},
    ): Promise<AppClipAppStoreReviewDetailResponse> =>
      this.request<AppClipAppStoreReviewDetailResponse, ErrorResponse>({
        path: `/v1/appClipAppStoreReviewDetails/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),
  };
  appClipDefaultExperienceLocalizations = {
    /**
     * No description
     *
     * @tags AppClipDefaultExperienceLocalizations
     * @name AppClipDefaultExperienceLocalizationsCreateInstance
     * @request POST:/v1/appClipDefaultExperienceLocalizations
     * @secure
     */
    createInstance: (
      data: AppClipDefaultExperienceLocalizationCreateRequest,
      params: RequestParams = {},
    ): Promise<AppClipDefaultExperienceLocalizationResponse> =>
      this.request<AppClipDefaultExperienceLocalizationResponse, ErrorResponse>({
        path: `/v1/appClipDefaultExperienceLocalizations`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppClipDefaultExperienceLocalizations
     * @name AppClipDefaultExperienceLocalizationsGetInstance
     * @request GET:/v1/appClipDefaultExperienceLocalizations/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type appClipDefaultExperienceLocalizations */
        "fields[appClipDefaultExperienceLocalizations]"?: (
          | "appClipDefaultExperience"
          | "appClipHeaderImage"
          | "locale"
          | "subtitle"
        )[];
        /** comma-separated list of relationships to include */
        include?: ("appClipDefaultExperience" | "appClipHeaderImage")[];
        /** the fields to include for returned resources of type appClipHeaderImages */
        "fields[appClipHeaderImages]"?: (
          | "appClipDefaultExperienceLocalization"
          | "assetDeliveryState"
          | "fileName"
          | "fileSize"
          | "imageAsset"
          | "sourceFileChecksum"
          | "uploadOperations"
          | "uploaded"
        )[];
      },
      params: RequestParams = {},
    ): Promise<AppClipDefaultExperienceLocalizationResponse> =>
      this.request<AppClipDefaultExperienceLocalizationResponse, ErrorResponse>({
        path: `/v1/appClipDefaultExperienceLocalizations/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppClipDefaultExperienceLocalizations
     * @name AppClipDefaultExperienceLocalizationsUpdateInstance
     * @request PATCH:/v1/appClipDefaultExperienceLocalizations/{id}
     * @secure
     */
    updateInstance: (
      id: string,
      data: AppClipDefaultExperienceLocalizationUpdateRequest,
      params: RequestParams = {},
    ): Promise<AppClipDefaultExperienceLocalizationResponse> =>
      this.request<AppClipDefaultExperienceLocalizationResponse, ErrorResponse>({
        path: `/v1/appClipDefaultExperienceLocalizations/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppClipDefaultExperienceLocalizations
     * @name AppClipDefaultExperienceLocalizationsDeleteInstance
     * @request DELETE:/v1/appClipDefaultExperienceLocalizations/{id}
     * @secure
     */
    deleteInstance: (id: string, params: RequestParams = {}): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/appClipDefaultExperienceLocalizations/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppClipDefaultExperienceLocalizations
     * @name AppClipDefaultExperienceLocalizationsAppClipHeaderImageGetToOneRelated
     * @request GET:/v1/appClipDefaultExperienceLocalizations/{id}/appClipHeaderImage
     * @secure
     */
    appClipHeaderImageGetToOneRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type appClipHeaderImages */
        "fields[appClipHeaderImages]"?: (
          | "appClipDefaultExperienceLocalization"
          | "assetDeliveryState"
          | "fileName"
          | "fileSize"
          | "imageAsset"
          | "sourceFileChecksum"
          | "uploadOperations"
          | "uploaded"
        )[];
        /** the fields to include for returned resources of type appClipDefaultExperienceLocalizations */
        "fields[appClipDefaultExperienceLocalizations]"?: (
          | "appClipDefaultExperience"
          | "appClipHeaderImage"
          | "locale"
          | "subtitle"
        )[];
        /** comma-separated list of relationships to include */
        include?: "appClipDefaultExperienceLocalization"[];
      },
      params: RequestParams = {},
    ): Promise<AppClipHeaderImageResponse> =>
      this.request<AppClipHeaderImageResponse, ErrorResponse>({
        path: `/v1/appClipDefaultExperienceLocalizations/${id}/appClipHeaderImage`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  appClipDefaultExperiences = {
    /**
     * No description
     *
     * @tags AppClipDefaultExperiences
     * @name AppClipDefaultExperiencesCreateInstance
     * @request POST:/v1/appClipDefaultExperiences
     * @secure
     */
    createInstance: (
      data: AppClipDefaultExperienceCreateRequest,
      params: RequestParams = {},
    ): Promise<AppClipDefaultExperienceResponse> =>
      this.request<AppClipDefaultExperienceResponse, ErrorResponse>({
        path: `/v1/appClipDefaultExperiences`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppClipDefaultExperiences
     * @name AppClipDefaultExperiencesGetInstance
     * @request GET:/v1/appClipDefaultExperiences/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type appClipDefaultExperiences */
        "fields[appClipDefaultExperiences]"?: (
          | "action"
          | "appClip"
          | "appClipAppStoreReviewDetail"
          | "appClipDefaultExperienceLocalizations"
          | "appClipDefaultExperienceTemplate"
          | "releaseWithAppStoreVersion"
        )[];
        /** comma-separated list of relationships to include */
        include?: (
          | "appClip"
          | "appClipAppStoreReviewDetail"
          | "appClipDefaultExperienceLocalizations"
          | "releaseWithAppStoreVersion"
        )[];
        /** the fields to include for returned resources of type appClipAppStoreReviewDetails */
        "fields[appClipAppStoreReviewDetails]"?: ("appClipDefaultExperience" | "invocationUrls")[];
        /** the fields to include for returned resources of type appStoreVersions */
        "fields[appStoreVersions]"?: (
          | "ageRatingDeclaration"
          | "alternativeDistributionPackage"
          | "app"
          | "appClipDefaultExperience"
          | "appStoreReviewDetail"
          | "appStoreState"
          | "appStoreVersionExperiments"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersionLocalizations"
          | "appStoreVersionPhasedRelease"
          | "appStoreVersionSubmission"
          | "appVersionState"
          | "build"
          | "copyright"
          | "createdDate"
          | "customerReviews"
          | "downloadable"
          | "earliestReleaseDate"
          | "platform"
          | "releaseType"
          | "reviewType"
          | "routingAppCoverage"
          | "versionString"
        )[];
        /** the fields to include for returned resources of type appClipDefaultExperienceLocalizations */
        "fields[appClipDefaultExperienceLocalizations]"?: (
          | "appClipDefaultExperience"
          | "appClipHeaderImage"
          | "locale"
          | "subtitle"
        )[];
        /**
         * maximum number of related appClipDefaultExperienceLocalizations returned (when they are included)
         * @max 50
         */
        "limit[appClipDefaultExperienceLocalizations]"?: number;
      },
      params: RequestParams = {},
    ): Promise<AppClipDefaultExperienceResponse> =>
      this.request<AppClipDefaultExperienceResponse, ErrorResponse>({
        path: `/v1/appClipDefaultExperiences/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppClipDefaultExperiences
     * @name AppClipDefaultExperiencesUpdateInstance
     * @request PATCH:/v1/appClipDefaultExperiences/{id}
     * @secure
     */
    updateInstance: (
      id: string,
      data: AppClipDefaultExperienceUpdateRequest,
      params: RequestParams = {},
    ): Promise<AppClipDefaultExperienceResponse> =>
      this.request<AppClipDefaultExperienceResponse, ErrorResponse>({
        path: `/v1/appClipDefaultExperiences/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppClipDefaultExperiences
     * @name AppClipDefaultExperiencesDeleteInstance
     * @request DELETE:/v1/appClipDefaultExperiences/{id}
     * @secure
     */
    deleteInstance: (id: string, params: RequestParams = {}): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/appClipDefaultExperiences/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppClipDefaultExperiences
     * @name AppClipDefaultExperiencesAppClipAppStoreReviewDetailGetToOneRelated
     * @request GET:/v1/appClipDefaultExperiences/{id}/appClipAppStoreReviewDetail
     * @secure
     */
    appClipAppStoreReviewDetailGetToOneRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type appClipAppStoreReviewDetails */
        "fields[appClipAppStoreReviewDetails]"?: ("appClipDefaultExperience" | "invocationUrls")[];
        /** the fields to include for returned resources of type appClipDefaultExperiences */
        "fields[appClipDefaultExperiences]"?: (
          | "action"
          | "appClip"
          | "appClipAppStoreReviewDetail"
          | "appClipDefaultExperienceLocalizations"
          | "appClipDefaultExperienceTemplate"
          | "releaseWithAppStoreVersion"
        )[];
        /** comma-separated list of relationships to include */
        include?: "appClipDefaultExperience"[];
      },
      params: RequestParams = {},
    ): Promise<AppClipAppStoreReviewDetailResponse> =>
      this.request<AppClipAppStoreReviewDetailResponse, ErrorResponse>({
        path: `/v1/appClipDefaultExperiences/${id}/appClipAppStoreReviewDetail`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppClipDefaultExperiences
     * @name AppClipDefaultExperiencesAppClipDefaultExperienceLocalizationsGetToManyRelated
     * @request GET:/v1/appClipDefaultExperiences/{id}/appClipDefaultExperienceLocalizations
     * @secure
     */
    appClipDefaultExperienceLocalizationsGetToManyRelated: (
      id: string,
      query?: {
        /** filter by attribute 'locale' */
        "filter[locale]"?: string[];
        /** the fields to include for returned resources of type appClipDefaultExperiences */
        "fields[appClipDefaultExperiences]"?: (
          | "action"
          | "appClip"
          | "appClipAppStoreReviewDetail"
          | "appClipDefaultExperienceLocalizations"
          | "appClipDefaultExperienceTemplate"
          | "releaseWithAppStoreVersion"
        )[];
        /** the fields to include for returned resources of type appClipDefaultExperienceLocalizations */
        "fields[appClipDefaultExperienceLocalizations]"?: (
          | "appClipDefaultExperience"
          | "appClipHeaderImage"
          | "locale"
          | "subtitle"
        )[];
        /** the fields to include for returned resources of type appClipHeaderImages */
        "fields[appClipHeaderImages]"?: (
          | "appClipDefaultExperienceLocalization"
          | "assetDeliveryState"
          | "fileName"
          | "fileSize"
          | "imageAsset"
          | "sourceFileChecksum"
          | "uploadOperations"
          | "uploaded"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /** comma-separated list of relationships to include */
        include?: ("appClipDefaultExperience" | "appClipHeaderImage")[];
      },
      params: RequestParams = {},
    ): Promise<AppClipDefaultExperienceLocalizationsResponse> =>
      this.request<AppClipDefaultExperienceLocalizationsResponse, ErrorResponse>({
        path: `/v1/appClipDefaultExperiences/${id}/appClipDefaultExperienceLocalizations`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppClipDefaultExperiences
     * @name AppClipDefaultExperiencesReleaseWithAppStoreVersionGetToOneRelationship
     * @request GET:/v1/appClipDefaultExperiences/{id}/relationships/releaseWithAppStoreVersion
     * @secure
     */
    releaseWithAppStoreVersionGetToOneRelationship: (
      id: string,
      params: RequestParams = {},
    ): Promise<AppClipDefaultExperienceReleaseWithAppStoreVersionLinkageResponse> =>
      this.request<AppClipDefaultExperienceReleaseWithAppStoreVersionLinkageResponse, ErrorResponse>({
        path: `/v1/appClipDefaultExperiences/${id}/relationships/releaseWithAppStoreVersion`,
        method: "GET",
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppClipDefaultExperiences
     * @name AppClipDefaultExperiencesReleaseWithAppStoreVersionUpdateToOneRelationship
     * @request PATCH:/v1/appClipDefaultExperiences/{id}/relationships/releaseWithAppStoreVersion
     * @secure
     */
    releaseWithAppStoreVersionUpdateToOneRelationship: (
      id: string,
      data: AppClipDefaultExperienceReleaseWithAppStoreVersionLinkageRequest,
      params: RequestParams = {},
    ): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/appClipDefaultExperiences/${id}/relationships/releaseWithAppStoreVersion`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppClipDefaultExperiences
     * @name AppClipDefaultExperiencesReleaseWithAppStoreVersionGetToOneRelated
     * @request GET:/v1/appClipDefaultExperiences/{id}/releaseWithAppStoreVersion
     * @secure
     */
    releaseWithAppStoreVersionGetToOneRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type ageRatingDeclarations */
        "fields[ageRatingDeclarations]"?: (
          | "ageRatingOverride"
          | "alcoholTobaccoOrDrugUseOrReferences"
          | "contests"
          | "gambling"
          | "gamblingAndContests"
          | "gamblingSimulated"
          | "horrorOrFearThemes"
          | "kidsAgeBand"
          | "matureOrSuggestiveThemes"
          | "medicalOrTreatmentInformation"
          | "profanityOrCrudeHumor"
          | "seventeenPlus"
          | "sexualContentGraphicAndNudity"
          | "sexualContentOrNudity"
          | "unrestrictedWebAccess"
          | "violenceCartoonOrFantasy"
          | "violenceRealistic"
          | "violenceRealisticProlongedGraphicOrSadistic"
        )[];
        /** the fields to include for returned resources of type appStoreReviewDetails */
        "fields[appStoreReviewDetails]"?: (
          | "appStoreReviewAttachments"
          | "appStoreVersion"
          | "contactEmail"
          | "contactFirstName"
          | "contactLastName"
          | "contactPhone"
          | "demoAccountName"
          | "demoAccountPassword"
          | "demoAccountRequired"
          | "notes"
        )[];
        /** the fields to include for returned resources of type appStoreVersionLocalizations */
        "fields[appStoreVersionLocalizations]"?: (
          | "appPreviewSets"
          | "appScreenshotSets"
          | "appStoreVersion"
          | "description"
          | "keywords"
          | "locale"
          | "marketingUrl"
          | "promotionalText"
          | "supportUrl"
          | "whatsNew"
        )[];
        /** the fields to include for returned resources of type appStoreVersionExperiments */
        "fields[appStoreVersionExperiments]"?: (
          | "app"
          | "appStoreVersion"
          | "appStoreVersionExperimentTreatments"
          | "controlVersions"
          | "endDate"
          | "latestControlVersion"
          | "name"
          | "platform"
          | "reviewRequired"
          | "startDate"
          | "started"
          | "state"
          | "trafficProportion"
        )[];
        /** the fields to include for returned resources of type appStoreVersionSubmissions */
        "fields[appStoreVersionSubmissions]"?: "appStoreVersion"[];
        /** the fields to include for returned resources of type alternativeDistributionPackages */
        "fields[alternativeDistributionPackages]"?: ("appStoreVersion" | "versions")[];
        /** the fields to include for returned resources of type appStoreVersions */
        "fields[appStoreVersions]"?: (
          | "ageRatingDeclaration"
          | "alternativeDistributionPackage"
          | "app"
          | "appClipDefaultExperience"
          | "appStoreReviewDetail"
          | "appStoreState"
          | "appStoreVersionExperiments"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersionLocalizations"
          | "appStoreVersionPhasedRelease"
          | "appStoreVersionSubmission"
          | "appVersionState"
          | "build"
          | "copyright"
          | "createdDate"
          | "customerReviews"
          | "downloadable"
          | "earliestReleaseDate"
          | "platform"
          | "releaseType"
          | "reviewType"
          | "routingAppCoverage"
          | "versionString"
        )[];
        /** the fields to include for returned resources of type apps */
        "fields[apps]"?: (
          | "alternativeDistributionKey"
          | "analyticsReportRequests"
          | "appAvailability"
          | "appClips"
          | "appCustomProductPages"
          | "appEncryptionDeclarations"
          | "appEvents"
          | "appInfos"
          | "appPricePoints"
          | "appPriceSchedule"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersions"
          | "availableInNewTerritories"
          | "availableTerritories"
          | "betaAppLocalizations"
          | "betaAppReviewDetail"
          | "betaGroups"
          | "betaLicenseAgreement"
          | "betaTesters"
          | "builds"
          | "bundleId"
          | "ciProduct"
          | "contentRightsDeclaration"
          | "customerReviews"
          | "endUserLicenseAgreement"
          | "gameCenterDetail"
          | "gameCenterEnabledVersions"
          | "inAppPurchases"
          | "inAppPurchasesV2"
          | "isOrEverWasMadeForKids"
          | "marketplaceSearchDetail"
          | "name"
          | "perfPowerMetrics"
          | "preOrder"
          | "preReleaseVersions"
          | "pricePoints"
          | "prices"
          | "primaryLocale"
          | "promotedPurchases"
          | "reviewSubmissions"
          | "sku"
          | "subscriptionGracePeriod"
          | "subscriptionGroups"
          | "subscriptionStatusUrl"
          | "subscriptionStatusUrlForSandbox"
          | "subscriptionStatusUrlVersion"
          | "subscriptionStatusUrlVersionForSandbox"
        )[];
        /** the fields to include for returned resources of type routingAppCoverages */
        "fields[routingAppCoverages]"?: (
          | "appStoreVersion"
          | "assetDeliveryState"
          | "fileName"
          | "fileSize"
          | "sourceFileChecksum"
          | "uploadOperations"
          | "uploaded"
        )[];
        /** the fields to include for returned resources of type appClipDefaultExperiences */
        "fields[appClipDefaultExperiences]"?: (
          | "action"
          | "appClip"
          | "appClipAppStoreReviewDetail"
          | "appClipDefaultExperienceLocalizations"
          | "appClipDefaultExperienceTemplate"
          | "releaseWithAppStoreVersion"
        )[];
        /** the fields to include for returned resources of type appStoreVersionPhasedReleases */
        "fields[appStoreVersionPhasedReleases]"?: (
          | "appStoreVersion"
          | "currentDayNumber"
          | "phasedReleaseState"
          | "startDate"
          | "totalPauseDuration"
        )[];
        /** the fields to include for returned resources of type builds */
        "fields[builds]"?: (
          | "app"
          | "appEncryptionDeclaration"
          | "appStoreVersion"
          | "betaAppReviewSubmission"
          | "betaBuildLocalizations"
          | "betaGroups"
          | "buildAudienceType"
          | "buildBetaDetail"
          | "buildBundles"
          | "computedMinMacOsVersion"
          | "diagnosticSignatures"
          | "expirationDate"
          | "expired"
          | "iconAssetToken"
          | "icons"
          | "individualTesters"
          | "lsMinimumSystemVersion"
          | "minOsVersion"
          | "perfPowerMetrics"
          | "preReleaseVersion"
          | "processingState"
          | "uploadedDate"
          | "usesNonExemptEncryption"
          | "version"
        )[];
        /**
         * maximum number of related appStoreVersionLocalizations returned (when they are included)
         * @max 50
         */
        "limit[appStoreVersionLocalizations]"?: number;
        /**
         * maximum number of related appStoreVersionExperiments returned (when they are included)
         * @deprecated
         * @max 50
         */
        "limit[appStoreVersionExperiments]"?: number;
        /**
         * maximum number of related appStoreVersionExperimentsV2 returned (when they are included)
         * @max 50
         */
        "limit[appStoreVersionExperimentsV2]"?: number;
        /** comma-separated list of relationships to include */
        include?: (
          | "ageRatingDeclaration"
          | "alternativeDistributionPackage"
          | "app"
          | "appClipDefaultExperience"
          | "appStoreReviewDetail"
          | "appStoreVersionExperiments"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersionLocalizations"
          | "appStoreVersionPhasedRelease"
          | "appStoreVersionSubmission"
          | "build"
          | "routingAppCoverage"
        )[];
      },
      params: RequestParams = {},
    ): Promise<AppStoreVersionResponse> =>
      this.request<AppStoreVersionResponse, ErrorResponse>({
        path: `/v1/appClipDefaultExperiences/${id}/releaseWithAppStoreVersion`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  appClipHeaderImages = {
    /**
     * No description
     *
     * @tags AppClipHeaderImages
     * @name AppClipHeaderImagesCreateInstance
     * @request POST:/v1/appClipHeaderImages
     * @secure
     */
    createInstance: (
      data: AppClipHeaderImageCreateRequest,
      params: RequestParams = {},
    ): Promise<AppClipHeaderImageResponse> =>
      this.request<AppClipHeaderImageResponse, ErrorResponse>({
        path: `/v1/appClipHeaderImages`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppClipHeaderImages
     * @name AppClipHeaderImagesGetInstance
     * @request GET:/v1/appClipHeaderImages/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type appClipHeaderImages */
        "fields[appClipHeaderImages]"?: (
          | "appClipDefaultExperienceLocalization"
          | "assetDeliveryState"
          | "fileName"
          | "fileSize"
          | "imageAsset"
          | "sourceFileChecksum"
          | "uploadOperations"
          | "uploaded"
        )[];
        /** comma-separated list of relationships to include */
        include?: "appClipDefaultExperienceLocalization"[];
      },
      params: RequestParams = {},
    ): Promise<AppClipHeaderImageResponse> =>
      this.request<AppClipHeaderImageResponse, ErrorResponse>({
        path: `/v1/appClipHeaderImages/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppClipHeaderImages
     * @name AppClipHeaderImagesUpdateInstance
     * @request PATCH:/v1/appClipHeaderImages/{id}
     * @secure
     */
    updateInstance: (
      id: string,
      data: AppClipHeaderImageUpdateRequest,
      params: RequestParams = {},
    ): Promise<AppClipHeaderImageResponse> =>
      this.request<AppClipHeaderImageResponse, ErrorResponse>({
        path: `/v1/appClipHeaderImages/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppClipHeaderImages
     * @name AppClipHeaderImagesDeleteInstance
     * @request DELETE:/v1/appClipHeaderImages/{id}
     * @secure
     */
    deleteInstance: (id: string, params: RequestParams = {}): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/appClipHeaderImages/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),
  };
  appClips = {
    /**
     * No description
     *
     * @tags AppClips
     * @name AppClipsGetInstance
     * @request GET:/v1/appClips/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type appClips */
        "fields[appClips]"?: ("app" | "appClipAdvancedExperiences" | "appClipDefaultExperiences" | "bundleId")[];
        /** comma-separated list of relationships to include */
        include?: ("app" | "appClipDefaultExperiences")[];
        /** the fields to include for returned resources of type appClipAdvancedExperiences */
        "fields[appClipAdvancedExperiences]"?: (
          | "action"
          | "appClip"
          | "businessCategory"
          | "defaultLanguage"
          | "headerImage"
          | "isPoweredBy"
          | "link"
          | "localizations"
          | "place"
          | "placeStatus"
          | "removed"
          | "status"
          | "version"
        )[];
        /** the fields to include for returned resources of type appClipDefaultExperiences */
        "fields[appClipDefaultExperiences]"?: (
          | "action"
          | "appClip"
          | "appClipAppStoreReviewDetail"
          | "appClipDefaultExperienceLocalizations"
          | "appClipDefaultExperienceTemplate"
          | "releaseWithAppStoreVersion"
        )[];
        /**
         * maximum number of related appClipDefaultExperiences returned (when they are included)
         * @max 50
         */
        "limit[appClipDefaultExperiences]"?: number;
      },
      params: RequestParams = {},
    ): Promise<AppClipResponse> =>
      this.request<AppClipResponse, ErrorResponse>({
        path: `/v1/appClips/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppClips
     * @name AppClipsAppClipAdvancedExperiencesGetToManyRelated
     * @request GET:/v1/appClips/{id}/appClipAdvancedExperiences
     * @secure
     */
    appClipAdvancedExperiencesGetToManyRelated: (
      id: string,
      query?: {
        /** filter by attribute 'action' */
        "filter[action]"?: ("OPEN" | "VIEW" | "PLAY")[];
        /** filter by attribute 'placeStatus' */
        "filter[placeStatus]"?: ("PENDING" | "MATCHED" | "NO_MATCH")[];
        /** filter by attribute 'status' */
        "filter[status]"?: ("RECEIVED" | "DEACTIVATED" | "APP_TRANSFER_IN_PROGRESS")[];
        /** the fields to include for returned resources of type appClipAdvancedExperiences */
        "fields[appClipAdvancedExperiences]"?: (
          | "action"
          | "appClip"
          | "businessCategory"
          | "defaultLanguage"
          | "headerImage"
          | "isPoweredBy"
          | "link"
          | "localizations"
          | "place"
          | "placeStatus"
          | "removed"
          | "status"
          | "version"
        )[];
        /** the fields to include for returned resources of type appClips */
        "fields[appClips]"?: ("app" | "appClipAdvancedExperiences" | "appClipDefaultExperiences" | "bundleId")[];
        /** the fields to include for returned resources of type appClipAdvancedExperienceImages */
        "fields[appClipAdvancedExperienceImages]"?: (
          | "assetDeliveryState"
          | "fileName"
          | "fileSize"
          | "imageAsset"
          | "sourceFileChecksum"
          | "uploadOperations"
          | "uploaded"
        )[];
        /** the fields to include for returned resources of type appClipAdvancedExperienceLocalizations */
        "fields[appClipAdvancedExperienceLocalizations]"?: ("language" | "subtitle" | "title")[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /**
         * maximum number of related localizations returned (when they are included)
         * @max 50
         */
        "limit[localizations]"?: number;
        /** comma-separated list of relationships to include */
        include?: ("appClip" | "headerImage" | "localizations")[];
      },
      params: RequestParams = {},
    ): Promise<AppClipAdvancedExperiencesResponse> =>
      this.request<AppClipAdvancedExperiencesResponse, ErrorResponse>({
        path: `/v1/appClips/${id}/appClipAdvancedExperiences`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppClips
     * @name AppClipsAppClipDefaultExperiencesGetToManyRelated
     * @request GET:/v1/appClips/{id}/appClipDefaultExperiences
     * @secure
     */
    appClipDefaultExperiencesGetToManyRelated: (
      id: string,
      query?: {
        /** filter by existence or non-existence of related 'releaseWithAppStoreVersion' */
        "exists[releaseWithAppStoreVersion]"?: boolean;
        /** the fields to include for returned resources of type appClips */
        "fields[appClips]"?: ("app" | "appClipAdvancedExperiences" | "appClipDefaultExperiences" | "bundleId")[];
        /** the fields to include for returned resources of type appClipAppStoreReviewDetails */
        "fields[appClipAppStoreReviewDetails]"?: ("appClipDefaultExperience" | "invocationUrls")[];
        /** the fields to include for returned resources of type appStoreVersions */
        "fields[appStoreVersions]"?: (
          | "ageRatingDeclaration"
          | "alternativeDistributionPackage"
          | "app"
          | "appClipDefaultExperience"
          | "appStoreReviewDetail"
          | "appStoreState"
          | "appStoreVersionExperiments"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersionLocalizations"
          | "appStoreVersionPhasedRelease"
          | "appStoreVersionSubmission"
          | "appVersionState"
          | "build"
          | "copyright"
          | "createdDate"
          | "customerReviews"
          | "downloadable"
          | "earliestReleaseDate"
          | "platform"
          | "releaseType"
          | "reviewType"
          | "routingAppCoverage"
          | "versionString"
        )[];
        /** the fields to include for returned resources of type appClipDefaultExperiences */
        "fields[appClipDefaultExperiences]"?: (
          | "action"
          | "appClip"
          | "appClipAppStoreReviewDetail"
          | "appClipDefaultExperienceLocalizations"
          | "appClipDefaultExperienceTemplate"
          | "releaseWithAppStoreVersion"
        )[];
        /** the fields to include for returned resources of type appClipDefaultExperienceLocalizations */
        "fields[appClipDefaultExperienceLocalizations]"?: (
          | "appClipDefaultExperience"
          | "appClipHeaderImage"
          | "locale"
          | "subtitle"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /**
         * maximum number of related appClipDefaultExperienceLocalizations returned (when they are included)
         * @max 50
         */
        "limit[appClipDefaultExperienceLocalizations]"?: number;
        /** comma-separated list of relationships to include */
        include?: (
          | "appClip"
          | "appClipAppStoreReviewDetail"
          | "appClipDefaultExperienceLocalizations"
          | "releaseWithAppStoreVersion"
        )[];
      },
      params: RequestParams = {},
    ): Promise<AppClipDefaultExperiencesResponse> =>
      this.request<AppClipDefaultExperiencesResponse, ErrorResponse>({
        path: `/v1/appClips/${id}/appClipDefaultExperiences`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  appCustomProductPageLocalizations = {
    /**
     * No description
     *
     * @tags AppCustomProductPageLocalizations
     * @name AppCustomProductPageLocalizationsCreateInstance
     * @request POST:/v1/appCustomProductPageLocalizations
     * @secure
     */
    createInstance: (
      data: AppCustomProductPageLocalizationCreateRequest,
      params: RequestParams = {},
    ): Promise<AppCustomProductPageLocalizationResponse> =>
      this.request<AppCustomProductPageLocalizationResponse, ErrorResponse>({
        path: `/v1/appCustomProductPageLocalizations`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppCustomProductPageLocalizations
     * @name AppCustomProductPageLocalizationsGetInstance
     * @request GET:/v1/appCustomProductPageLocalizations/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type appCustomProductPageLocalizations */
        "fields[appCustomProductPageLocalizations]"?: (
          | "appCustomProductPageVersion"
          | "appPreviewSets"
          | "appScreenshotSets"
          | "locale"
          | "promotionalText"
        )[];
        /** comma-separated list of relationships to include */
        include?: ("appCustomProductPageVersion" | "appPreviewSets" | "appScreenshotSets")[];
        /** the fields to include for returned resources of type appScreenshotSets */
        "fields[appScreenshotSets]"?: (
          | "appCustomProductPageLocalization"
          | "appScreenshots"
          | "appStoreVersionExperimentTreatmentLocalization"
          | "appStoreVersionLocalization"
          | "screenshotDisplayType"
        )[];
        /** the fields to include for returned resources of type appPreviewSets */
        "fields[appPreviewSets]"?: (
          | "appCustomProductPageLocalization"
          | "appPreviews"
          | "appStoreVersionExperimentTreatmentLocalization"
          | "appStoreVersionLocalization"
          | "previewType"
        )[];
        /**
         * maximum number of related appPreviewSets returned (when they are included)
         * @max 50
         */
        "limit[appPreviewSets]"?: number;
        /**
         * maximum number of related appScreenshotSets returned (when they are included)
         * @max 50
         */
        "limit[appScreenshotSets]"?: number;
      },
      params: RequestParams = {},
    ): Promise<AppCustomProductPageLocalizationResponse> =>
      this.request<AppCustomProductPageLocalizationResponse, ErrorResponse>({
        path: `/v1/appCustomProductPageLocalizations/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppCustomProductPageLocalizations
     * @name AppCustomProductPageLocalizationsUpdateInstance
     * @request PATCH:/v1/appCustomProductPageLocalizations/{id}
     * @secure
     */
    updateInstance: (
      id: string,
      data: AppCustomProductPageLocalizationUpdateRequest,
      params: RequestParams = {},
    ): Promise<AppCustomProductPageLocalizationResponse> =>
      this.request<AppCustomProductPageLocalizationResponse, ErrorResponse>({
        path: `/v1/appCustomProductPageLocalizations/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppCustomProductPageLocalizations
     * @name AppCustomProductPageLocalizationsDeleteInstance
     * @request DELETE:/v1/appCustomProductPageLocalizations/{id}
     * @secure
     */
    deleteInstance: (id: string, params: RequestParams = {}): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/appCustomProductPageLocalizations/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppCustomProductPageLocalizations
     * @name AppCustomProductPageLocalizationsAppPreviewSetsGetToManyRelated
     * @request GET:/v1/appCustomProductPageLocalizations/{id}/appPreviewSets
     * @secure
     */
    appPreviewSetsGetToManyRelated: (
      id: string,
      query?: {
        /** filter by attribute 'previewType' */
        "filter[previewType]"?: (
          | "IPHONE_67"
          | "IPHONE_61"
          | "IPHONE_65"
          | "IPHONE_58"
          | "IPHONE_55"
          | "IPHONE_47"
          | "IPHONE_40"
          | "IPHONE_35"
          | "IPAD_PRO_3GEN_129"
          | "IPAD_PRO_3GEN_11"
          | "IPAD_PRO_129"
          | "IPAD_105"
          | "IPAD_97"
          | "DESKTOP"
          | "APPLE_TV"
          | "APPLE_VISION_PRO"
        )[];
        /** filter by id(s) of related 'appStoreVersionExperimentTreatmentLocalization' */
        "filter[appStoreVersionExperimentTreatmentLocalization]"?: string[];
        /** filter by id(s) of related 'appStoreVersionLocalization' */
        "filter[appStoreVersionLocalization]"?: string[];
        /** the fields to include for returned resources of type appCustomProductPageLocalizations */
        "fields[appCustomProductPageLocalizations]"?: (
          | "appCustomProductPageVersion"
          | "appPreviewSets"
          | "appScreenshotSets"
          | "locale"
          | "promotionalText"
        )[];
        /** the fields to include for returned resources of type appStoreVersionExperimentTreatmentLocalizations */
        "fields[appStoreVersionExperimentTreatmentLocalizations]"?: (
          | "appPreviewSets"
          | "appScreenshotSets"
          | "appStoreVersionExperimentTreatment"
          | "locale"
        )[];
        /** the fields to include for returned resources of type appPreviews */
        "fields[appPreviews]"?: (
          | "appPreviewSet"
          | "assetDeliveryState"
          | "fileName"
          | "fileSize"
          | "mimeType"
          | "previewFrameTimeCode"
          | "previewImage"
          | "sourceFileChecksum"
          | "uploadOperations"
          | "uploaded"
          | "videoUrl"
        )[];
        /** the fields to include for returned resources of type appPreviewSets */
        "fields[appPreviewSets]"?: (
          | "appCustomProductPageLocalization"
          | "appPreviews"
          | "appStoreVersionExperimentTreatmentLocalization"
          | "appStoreVersionLocalization"
          | "previewType"
        )[];
        /** the fields to include for returned resources of type appStoreVersionLocalizations */
        "fields[appStoreVersionLocalizations]"?: (
          | "appPreviewSets"
          | "appScreenshotSets"
          | "appStoreVersion"
          | "description"
          | "keywords"
          | "locale"
          | "marketingUrl"
          | "promotionalText"
          | "supportUrl"
          | "whatsNew"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /**
         * maximum number of related appPreviews returned (when they are included)
         * @max 50
         */
        "limit[appPreviews]"?: number;
        /** comma-separated list of relationships to include */
        include?: (
          | "appCustomProductPageLocalization"
          | "appPreviews"
          | "appStoreVersionExperimentTreatmentLocalization"
          | "appStoreVersionLocalization"
        )[];
      },
      params: RequestParams = {},
    ): Promise<AppPreviewSetsResponse> =>
      this.request<AppPreviewSetsResponse, ErrorResponse>({
        path: `/v1/appCustomProductPageLocalizations/${id}/appPreviewSets`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppCustomProductPageLocalizations
     * @name AppCustomProductPageLocalizationsAppScreenshotSetsGetToManyRelated
     * @request GET:/v1/appCustomProductPageLocalizations/{id}/appScreenshotSets
     * @secure
     */
    appScreenshotSetsGetToManyRelated: (
      id: string,
      query?: {
        /** filter by attribute 'screenshotDisplayType' */
        "filter[screenshotDisplayType]"?: (
          | "APP_IPHONE_67"
          | "APP_IPHONE_61"
          | "APP_IPHONE_65"
          | "APP_IPHONE_58"
          | "APP_IPHONE_55"
          | "APP_IPHONE_47"
          | "APP_IPHONE_40"
          | "APP_IPHONE_35"
          | "APP_IPAD_PRO_3GEN_129"
          | "APP_IPAD_PRO_3GEN_11"
          | "APP_IPAD_PRO_129"
          | "APP_IPAD_105"
          | "APP_IPAD_97"
          | "APP_DESKTOP"
          | "APP_WATCH_ULTRA"
          | "APP_WATCH_SERIES_7"
          | "APP_WATCH_SERIES_4"
          | "APP_WATCH_SERIES_3"
          | "APP_APPLE_TV"
          | "APP_APPLE_VISION_PRO"
          | "IMESSAGE_APP_IPHONE_67"
          | "IMESSAGE_APP_IPHONE_61"
          | "IMESSAGE_APP_IPHONE_65"
          | "IMESSAGE_APP_IPHONE_58"
          | "IMESSAGE_APP_IPHONE_55"
          | "IMESSAGE_APP_IPHONE_47"
          | "IMESSAGE_APP_IPHONE_40"
          | "IMESSAGE_APP_IPAD_PRO_3GEN_129"
          | "IMESSAGE_APP_IPAD_PRO_3GEN_11"
          | "IMESSAGE_APP_IPAD_PRO_129"
          | "IMESSAGE_APP_IPAD_105"
          | "IMESSAGE_APP_IPAD_97"
        )[];
        /** filter by id(s) of related 'appStoreVersionExperimentTreatmentLocalization' */
        "filter[appStoreVersionExperimentTreatmentLocalization]"?: string[];
        /** filter by id(s) of related 'appStoreVersionLocalization' */
        "filter[appStoreVersionLocalization]"?: string[];
        /** the fields to include for returned resources of type appScreenshotSets */
        "fields[appScreenshotSets]"?: (
          | "appCustomProductPageLocalization"
          | "appScreenshots"
          | "appStoreVersionExperimentTreatmentLocalization"
          | "appStoreVersionLocalization"
          | "screenshotDisplayType"
        )[];
        /** the fields to include for returned resources of type appCustomProductPageLocalizations */
        "fields[appCustomProductPageLocalizations]"?: (
          | "appCustomProductPageVersion"
          | "appPreviewSets"
          | "appScreenshotSets"
          | "locale"
          | "promotionalText"
        )[];
        /** the fields to include for returned resources of type appStoreVersionExperimentTreatmentLocalizations */
        "fields[appStoreVersionExperimentTreatmentLocalizations]"?: (
          | "appPreviewSets"
          | "appScreenshotSets"
          | "appStoreVersionExperimentTreatment"
          | "locale"
        )[];
        /** the fields to include for returned resources of type appScreenshots */
        "fields[appScreenshots]"?: (
          | "appScreenshotSet"
          | "assetDeliveryState"
          | "assetToken"
          | "assetType"
          | "fileName"
          | "fileSize"
          | "imageAsset"
          | "sourceFileChecksum"
          | "uploadOperations"
          | "uploaded"
        )[];
        /** the fields to include for returned resources of type appStoreVersionLocalizations */
        "fields[appStoreVersionLocalizations]"?: (
          | "appPreviewSets"
          | "appScreenshotSets"
          | "appStoreVersion"
          | "description"
          | "keywords"
          | "locale"
          | "marketingUrl"
          | "promotionalText"
          | "supportUrl"
          | "whatsNew"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /**
         * maximum number of related appScreenshots returned (when they are included)
         * @max 50
         */
        "limit[appScreenshots]"?: number;
        /** comma-separated list of relationships to include */
        include?: (
          | "appCustomProductPageLocalization"
          | "appScreenshots"
          | "appStoreVersionExperimentTreatmentLocalization"
          | "appStoreVersionLocalization"
        )[];
      },
      params: RequestParams = {},
    ): Promise<AppScreenshotSetsResponse> =>
      this.request<AppScreenshotSetsResponse, ErrorResponse>({
        path: `/v1/appCustomProductPageLocalizations/${id}/appScreenshotSets`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  appCustomProductPageVersions = {
    /**
     * No description
     *
     * @tags AppCustomProductPageVersions
     * @name AppCustomProductPageVersionsCreateInstance
     * @request POST:/v1/appCustomProductPageVersions
     * @secure
     */
    createInstance: (
      data: AppCustomProductPageVersionCreateRequest,
      params: RequestParams = {},
    ): Promise<AppCustomProductPageVersionResponse> =>
      this.request<AppCustomProductPageVersionResponse, ErrorResponse>({
        path: `/v1/appCustomProductPageVersions`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppCustomProductPageVersions
     * @name AppCustomProductPageVersionsGetInstance
     * @request GET:/v1/appCustomProductPageVersions/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type appCustomProductPageVersions */
        "fields[appCustomProductPageVersions]"?: (
          | "appCustomProductPage"
          | "appCustomProductPageLocalizations"
          | "state"
          | "version"
        )[];
        /** comma-separated list of relationships to include */
        include?: ("appCustomProductPage" | "appCustomProductPageLocalizations")[];
        /** the fields to include for returned resources of type appCustomProductPageLocalizations */
        "fields[appCustomProductPageLocalizations]"?: (
          | "appCustomProductPageVersion"
          | "appPreviewSets"
          | "appScreenshotSets"
          | "locale"
          | "promotionalText"
        )[];
        /**
         * maximum number of related appCustomProductPageLocalizations returned (when they are included)
         * @max 50
         */
        "limit[appCustomProductPageLocalizations]"?: number;
      },
      params: RequestParams = {},
    ): Promise<AppCustomProductPageVersionResponse> =>
      this.request<AppCustomProductPageVersionResponse, ErrorResponse>({
        path: `/v1/appCustomProductPageVersions/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppCustomProductPageVersions
     * @name AppCustomProductPageVersionsAppCustomProductPageLocalizationsGetToManyRelated
     * @request GET:/v1/appCustomProductPageVersions/{id}/appCustomProductPageLocalizations
     * @secure
     */
    appCustomProductPageLocalizationsGetToManyRelated: (
      id: string,
      query?: {
        /** filter by attribute 'locale' */
        "filter[locale]"?: string[];
        /** the fields to include for returned resources of type appScreenshotSets */
        "fields[appScreenshotSets]"?: (
          | "appCustomProductPageLocalization"
          | "appScreenshots"
          | "appStoreVersionExperimentTreatmentLocalization"
          | "appStoreVersionLocalization"
          | "screenshotDisplayType"
        )[];
        /** the fields to include for returned resources of type appCustomProductPageLocalizations */
        "fields[appCustomProductPageLocalizations]"?: (
          | "appCustomProductPageVersion"
          | "appPreviewSets"
          | "appScreenshotSets"
          | "locale"
          | "promotionalText"
        )[];
        /** the fields to include for returned resources of type appCustomProductPageVersions */
        "fields[appCustomProductPageVersions]"?: (
          | "appCustomProductPage"
          | "appCustomProductPageLocalizations"
          | "state"
          | "version"
        )[];
        /** the fields to include for returned resources of type appPreviewSets */
        "fields[appPreviewSets]"?: (
          | "appCustomProductPageLocalization"
          | "appPreviews"
          | "appStoreVersionExperimentTreatmentLocalization"
          | "appStoreVersionLocalization"
          | "previewType"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /**
         * maximum number of related appScreenshotSets returned (when they are included)
         * @max 50
         */
        "limit[appScreenshotSets]"?: number;
        /**
         * maximum number of related appPreviewSets returned (when they are included)
         * @max 50
         */
        "limit[appPreviewSets]"?: number;
        /** comma-separated list of relationships to include */
        include?: ("appCustomProductPageVersion" | "appPreviewSets" | "appScreenshotSets")[];
      },
      params: RequestParams = {},
    ): Promise<AppCustomProductPageLocalizationsResponse> =>
      this.request<AppCustomProductPageLocalizationsResponse, ErrorResponse>({
        path: `/v1/appCustomProductPageVersions/${id}/appCustomProductPageLocalizations`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  appCustomProductPages = {
    /**
     * No description
     *
     * @tags AppCustomProductPages
     * @name AppCustomProductPagesCreateInstance
     * @request POST:/v1/appCustomProductPages
     * @secure
     */
    createInstance: (
      data: AppCustomProductPageCreateRequest,
      params: RequestParams = {},
    ): Promise<AppCustomProductPageResponse> =>
      this.request<AppCustomProductPageResponse, ErrorResponse>({
        path: `/v1/appCustomProductPages`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppCustomProductPages
     * @name AppCustomProductPagesGetInstance
     * @request GET:/v1/appCustomProductPages/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type appCustomProductPages */
        "fields[appCustomProductPages]"?: (
          | "app"
          | "appCustomProductPageVersions"
          | "appStoreVersionTemplate"
          | "customProductPageTemplate"
          | "name"
          | "url"
          | "visible"
        )[];
        /** comma-separated list of relationships to include */
        include?: ("app" | "appCustomProductPageVersions")[];
        /** the fields to include for returned resources of type appCustomProductPageVersions */
        "fields[appCustomProductPageVersions]"?: (
          | "appCustomProductPage"
          | "appCustomProductPageLocalizations"
          | "state"
          | "version"
        )[];
        /**
         * maximum number of related appCustomProductPageVersions returned (when they are included)
         * @max 50
         */
        "limit[appCustomProductPageVersions]"?: number;
      },
      params: RequestParams = {},
    ): Promise<AppCustomProductPageResponse> =>
      this.request<AppCustomProductPageResponse, ErrorResponse>({
        path: `/v1/appCustomProductPages/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppCustomProductPages
     * @name AppCustomProductPagesUpdateInstance
     * @request PATCH:/v1/appCustomProductPages/{id}
     * @secure
     */
    updateInstance: (
      id: string,
      data: AppCustomProductPageUpdateRequest,
      params: RequestParams = {},
    ): Promise<AppCustomProductPageResponse> =>
      this.request<AppCustomProductPageResponse, ErrorResponse>({
        path: `/v1/appCustomProductPages/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppCustomProductPages
     * @name AppCustomProductPagesDeleteInstance
     * @request DELETE:/v1/appCustomProductPages/{id}
     * @secure
     */
    deleteInstance: (id: string, params: RequestParams = {}): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/appCustomProductPages/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppCustomProductPages
     * @name AppCustomProductPagesAppCustomProductPageVersionsGetToManyRelated
     * @request GET:/v1/appCustomProductPages/{id}/appCustomProductPageVersions
     * @secure
     */
    appCustomProductPageVersionsGetToManyRelated: (
      id: string,
      query?: {
        /** filter by attribute 'state' */
        "filter[state]"?: (
          | "PREPARE_FOR_SUBMISSION"
          | "READY_FOR_REVIEW"
          | "WAITING_FOR_REVIEW"
          | "IN_REVIEW"
          | "ACCEPTED"
          | "APPROVED"
          | "REPLACED_WITH_NEW_VERSION"
          | "REJECTED"
        )[];
        /** the fields to include for returned resources of type appCustomProductPageLocalizations */
        "fields[appCustomProductPageLocalizations]"?: (
          | "appCustomProductPageVersion"
          | "appPreviewSets"
          | "appScreenshotSets"
          | "locale"
          | "promotionalText"
        )[];
        /** the fields to include for returned resources of type appCustomProductPageVersions */
        "fields[appCustomProductPageVersions]"?: (
          | "appCustomProductPage"
          | "appCustomProductPageLocalizations"
          | "state"
          | "version"
        )[];
        /** the fields to include for returned resources of type appCustomProductPages */
        "fields[appCustomProductPages]"?: (
          | "app"
          | "appCustomProductPageVersions"
          | "appStoreVersionTemplate"
          | "customProductPageTemplate"
          | "name"
          | "url"
          | "visible"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /**
         * maximum number of related appCustomProductPageLocalizations returned (when they are included)
         * @max 50
         */
        "limit[appCustomProductPageLocalizations]"?: number;
        /** comma-separated list of relationships to include */
        include?: ("appCustomProductPage" | "appCustomProductPageLocalizations")[];
      },
      params: RequestParams = {},
    ): Promise<AppCustomProductPageVersionsResponse> =>
      this.request<AppCustomProductPageVersionsResponse, ErrorResponse>({
        path: `/v1/appCustomProductPages/${id}/appCustomProductPageVersions`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  appEncryptionDeclarationDocuments = {
    /**
     * No description
     *
     * @tags AppEncryptionDeclarationDocuments
     * @name AppEncryptionDeclarationDocumentsCreateInstance
     * @request POST:/v1/appEncryptionDeclarationDocuments
     * @secure
     */
    createInstance: (
      data: AppEncryptionDeclarationDocumentCreateRequest,
      params: RequestParams = {},
    ): Promise<AppEncryptionDeclarationDocumentResponse> =>
      this.request<AppEncryptionDeclarationDocumentResponse, ErrorResponse>({
        path: `/v1/appEncryptionDeclarationDocuments`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppEncryptionDeclarationDocuments
     * @name AppEncryptionDeclarationDocumentsGetInstance
     * @request GET:/v1/appEncryptionDeclarationDocuments/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type appEncryptionDeclarationDocuments */
        "fields[appEncryptionDeclarationDocuments]"?: (
          | "appEncryptionDeclaration"
          | "assetDeliveryState"
          | "assetToken"
          | "downloadUrl"
          | "fileName"
          | "fileSize"
          | "sourceFileChecksum"
          | "uploadOperations"
          | "uploaded"
        )[];
      },
      params: RequestParams = {},
    ): Promise<AppEncryptionDeclarationDocumentResponse> =>
      this.request<AppEncryptionDeclarationDocumentResponse, ErrorResponse>({
        path: `/v1/appEncryptionDeclarationDocuments/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppEncryptionDeclarationDocuments
     * @name AppEncryptionDeclarationDocumentsUpdateInstance
     * @request PATCH:/v1/appEncryptionDeclarationDocuments/{id}
     * @secure
     */
    updateInstance: (
      id: string,
      data: AppEncryptionDeclarationDocumentUpdateRequest,
      params: RequestParams = {},
    ): Promise<AppEncryptionDeclarationDocumentResponse> =>
      this.request<AppEncryptionDeclarationDocumentResponse, ErrorResponse>({
        path: `/v1/appEncryptionDeclarationDocuments/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),
  };
  appEncryptionDeclarations = {
    /**
     * No description
     *
     * @tags AppEncryptionDeclarations
     * @name AppEncryptionDeclarationsGetCollection
     * @request GET:/v1/appEncryptionDeclarations
     * @secure
     */
    getCollection: (
      query?: {
        /** filter by attribute 'platform' */
        "filter[platform]"?: ("IOS" | "MAC_OS" | "TV_OS" | "VISION_OS")[];
        /** filter by id(s) of related 'app' */
        "filter[app]"?: string[];
        /** filter by id(s) of related 'builds' */
        "filter[builds]"?: string[];
        /** the fields to include for returned resources of type appEncryptionDeclarations */
        "fields[appEncryptionDeclarations]"?: (
          | "app"
          | "appDescription"
          | "appEncryptionDeclarationDocument"
          | "appEncryptionDeclarationState"
          | "availableOnFrenchStore"
          | "builds"
          | "codeValue"
          | "containsProprietaryCryptography"
          | "containsThirdPartyCryptography"
          | "createdDate"
          | "documentName"
          | "documentType"
          | "documentUrl"
          | "exempt"
          | "platform"
          | "uploadedDate"
          | "usesEncryption"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /** comma-separated list of relationships to include */
        include?: ("app" | "appEncryptionDeclarationDocument" | "builds")[];
        /** the fields to include for returned resources of type appEncryptionDeclarationDocuments */
        "fields[appEncryptionDeclarationDocuments]"?: (
          | "appEncryptionDeclaration"
          | "assetDeliveryState"
          | "assetToken"
          | "downloadUrl"
          | "fileName"
          | "fileSize"
          | "sourceFileChecksum"
          | "uploadOperations"
          | "uploaded"
        )[];
        /** the fields to include for returned resources of type apps */
        "fields[apps]"?: (
          | "alternativeDistributionKey"
          | "analyticsReportRequests"
          | "appAvailability"
          | "appClips"
          | "appCustomProductPages"
          | "appEncryptionDeclarations"
          | "appEvents"
          | "appInfos"
          | "appPricePoints"
          | "appPriceSchedule"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersions"
          | "availableInNewTerritories"
          | "availableTerritories"
          | "betaAppLocalizations"
          | "betaAppReviewDetail"
          | "betaGroups"
          | "betaLicenseAgreement"
          | "betaTesters"
          | "builds"
          | "bundleId"
          | "ciProduct"
          | "contentRightsDeclaration"
          | "customerReviews"
          | "endUserLicenseAgreement"
          | "gameCenterDetail"
          | "gameCenterEnabledVersions"
          | "inAppPurchases"
          | "inAppPurchasesV2"
          | "isOrEverWasMadeForKids"
          | "marketplaceSearchDetail"
          | "name"
          | "perfPowerMetrics"
          | "preOrder"
          | "preReleaseVersions"
          | "pricePoints"
          | "prices"
          | "primaryLocale"
          | "promotedPurchases"
          | "reviewSubmissions"
          | "sku"
          | "subscriptionGracePeriod"
          | "subscriptionGroups"
          | "subscriptionStatusUrl"
          | "subscriptionStatusUrlForSandbox"
          | "subscriptionStatusUrlVersion"
          | "subscriptionStatusUrlVersionForSandbox"
        )[];
        /**
         * maximum number of related builds returned (when they are included)
         * @max 50
         */
        "limit[builds]"?: number;
      },
      params: RequestParams = {},
    ): Promise<AppEncryptionDeclarationsResponse> =>
      this.request<AppEncryptionDeclarationsResponse, ErrorResponse>({
        path: `/v1/appEncryptionDeclarations`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppEncryptionDeclarations
     * @name AppEncryptionDeclarationsGetInstance
     * @request GET:/v1/appEncryptionDeclarations/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type appEncryptionDeclarations */
        "fields[appEncryptionDeclarations]"?: (
          | "app"
          | "appDescription"
          | "appEncryptionDeclarationDocument"
          | "appEncryptionDeclarationState"
          | "availableOnFrenchStore"
          | "builds"
          | "codeValue"
          | "containsProprietaryCryptography"
          | "containsThirdPartyCryptography"
          | "createdDate"
          | "documentName"
          | "documentType"
          | "documentUrl"
          | "exempt"
          | "platform"
          | "uploadedDate"
          | "usesEncryption"
        )[];
        /** comma-separated list of relationships to include */
        include?: ("app" | "appEncryptionDeclarationDocument" | "builds")[];
        /** the fields to include for returned resources of type appEncryptionDeclarationDocuments */
        "fields[appEncryptionDeclarationDocuments]"?: (
          | "appEncryptionDeclaration"
          | "assetDeliveryState"
          | "assetToken"
          | "downloadUrl"
          | "fileName"
          | "fileSize"
          | "sourceFileChecksum"
          | "uploadOperations"
          | "uploaded"
        )[];
        /** the fields to include for returned resources of type apps */
        "fields[apps]"?: (
          | "alternativeDistributionKey"
          | "analyticsReportRequests"
          | "appAvailability"
          | "appClips"
          | "appCustomProductPages"
          | "appEncryptionDeclarations"
          | "appEvents"
          | "appInfos"
          | "appPricePoints"
          | "appPriceSchedule"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersions"
          | "availableInNewTerritories"
          | "availableTerritories"
          | "betaAppLocalizations"
          | "betaAppReviewDetail"
          | "betaGroups"
          | "betaLicenseAgreement"
          | "betaTesters"
          | "builds"
          | "bundleId"
          | "ciProduct"
          | "contentRightsDeclaration"
          | "customerReviews"
          | "endUserLicenseAgreement"
          | "gameCenterDetail"
          | "gameCenterEnabledVersions"
          | "inAppPurchases"
          | "inAppPurchasesV2"
          | "isOrEverWasMadeForKids"
          | "marketplaceSearchDetail"
          | "name"
          | "perfPowerMetrics"
          | "preOrder"
          | "preReleaseVersions"
          | "pricePoints"
          | "prices"
          | "primaryLocale"
          | "promotedPurchases"
          | "reviewSubmissions"
          | "sku"
          | "subscriptionGracePeriod"
          | "subscriptionGroups"
          | "subscriptionStatusUrl"
          | "subscriptionStatusUrlForSandbox"
          | "subscriptionStatusUrlVersion"
          | "subscriptionStatusUrlVersionForSandbox"
        )[];
        /**
         * maximum number of related builds returned (when they are included)
         * @max 50
         */
        "limit[builds]"?: number;
      },
      params: RequestParams = {},
    ): Promise<AppEncryptionDeclarationResponse> =>
      this.request<AppEncryptionDeclarationResponse, ErrorResponse>({
        path: `/v1/appEncryptionDeclarations/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppEncryptionDeclarations
     * @name AppEncryptionDeclarationsAppGetToOneRelated
     * @request GET:/v1/appEncryptionDeclarations/{id}/app
     * @secure
     */
    appGetToOneRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type apps */
        "fields[apps]"?: (
          | "alternativeDistributionKey"
          | "analyticsReportRequests"
          | "appAvailability"
          | "appClips"
          | "appCustomProductPages"
          | "appEncryptionDeclarations"
          | "appEvents"
          | "appInfos"
          | "appPricePoints"
          | "appPriceSchedule"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersions"
          | "availableInNewTerritories"
          | "availableTerritories"
          | "betaAppLocalizations"
          | "betaAppReviewDetail"
          | "betaGroups"
          | "betaLicenseAgreement"
          | "betaTesters"
          | "builds"
          | "bundleId"
          | "ciProduct"
          | "contentRightsDeclaration"
          | "customerReviews"
          | "endUserLicenseAgreement"
          | "gameCenterDetail"
          | "gameCenterEnabledVersions"
          | "inAppPurchases"
          | "inAppPurchasesV2"
          | "isOrEverWasMadeForKids"
          | "marketplaceSearchDetail"
          | "name"
          | "perfPowerMetrics"
          | "preOrder"
          | "preReleaseVersions"
          | "pricePoints"
          | "prices"
          | "primaryLocale"
          | "promotedPurchases"
          | "reviewSubmissions"
          | "sku"
          | "subscriptionGracePeriod"
          | "subscriptionGroups"
          | "subscriptionStatusUrl"
          | "subscriptionStatusUrlForSandbox"
          | "subscriptionStatusUrlVersion"
          | "subscriptionStatusUrlVersionForSandbox"
        )[];
      },
      params: RequestParams = {},
    ): Promise<AppWithoutIncludesResponse> =>
      this.request<AppWithoutIncludesResponse, ErrorResponse>({
        path: `/v1/appEncryptionDeclarations/${id}/app`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppEncryptionDeclarations
     * @name AppEncryptionDeclarationsAppEncryptionDeclarationDocumentGetToOneRelated
     * @request GET:/v1/appEncryptionDeclarations/{id}/appEncryptionDeclarationDocument
     * @secure
     */
    appEncryptionDeclarationDocumentGetToOneRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type appEncryptionDeclarationDocuments */
        "fields[appEncryptionDeclarationDocuments]"?: (
          | "appEncryptionDeclaration"
          | "assetDeliveryState"
          | "assetToken"
          | "downloadUrl"
          | "fileName"
          | "fileSize"
          | "sourceFileChecksum"
          | "uploadOperations"
          | "uploaded"
        )[];
      },
      params: RequestParams = {},
    ): Promise<AppEncryptionDeclarationDocumentResponse> =>
      this.request<AppEncryptionDeclarationDocumentResponse, ErrorResponse>({
        path: `/v1/appEncryptionDeclarations/${id}/appEncryptionDeclarationDocument`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppEncryptionDeclarations
     * @name AppEncryptionDeclarationsBuildsCreateToManyRelationship
     * @request POST:/v1/appEncryptionDeclarations/{id}/relationships/builds
     * @deprecated
     * @secure
     */
    buildsCreateToManyRelationship: (
      id: string,
      data: AppEncryptionDeclarationBuildsLinkagesRequest,
      params: RequestParams = {},
    ): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/appEncryptionDeclarations/${id}/relationships/builds`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),
  };
  appEventLocalizations = {
    /**
     * No description
     *
     * @tags AppEventLocalizations
     * @name AppEventLocalizationsCreateInstance
     * @request POST:/v1/appEventLocalizations
     * @secure
     */
    createInstance: (
      data: AppEventLocalizationCreateRequest,
      params: RequestParams = {},
    ): Promise<AppEventLocalizationResponse> =>
      this.request<AppEventLocalizationResponse, ErrorResponse>({
        path: `/v1/appEventLocalizations`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppEventLocalizations
     * @name AppEventLocalizationsGetInstance
     * @request GET:/v1/appEventLocalizations/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type appEventLocalizations */
        "fields[appEventLocalizations]"?: (
          | "appEvent"
          | "appEventScreenshots"
          | "appEventVideoClips"
          | "locale"
          | "longDescription"
          | "name"
          | "shortDescription"
        )[];
        /** comma-separated list of relationships to include */
        include?: ("appEvent" | "appEventScreenshots" | "appEventVideoClips")[];
        /** the fields to include for returned resources of type appEventScreenshots */
        "fields[appEventScreenshots]"?: (
          | "appEventAssetType"
          | "appEventLocalization"
          | "assetDeliveryState"
          | "assetToken"
          | "fileName"
          | "fileSize"
          | "imageAsset"
          | "uploadOperations"
          | "uploaded"
        )[];
        /** the fields to include for returned resources of type appEventVideoClips */
        "fields[appEventVideoClips]"?: (
          | "appEventAssetType"
          | "appEventLocalization"
          | "assetDeliveryState"
          | "fileName"
          | "fileSize"
          | "previewFrameTimeCode"
          | "previewImage"
          | "uploadOperations"
          | "uploaded"
          | "videoUrl"
        )[];
        /**
         * maximum number of related appEventScreenshots returned (when they are included)
         * @max 50
         */
        "limit[appEventScreenshots]"?: number;
        /**
         * maximum number of related appEventVideoClips returned (when they are included)
         * @max 50
         */
        "limit[appEventVideoClips]"?: number;
      },
      params: RequestParams = {},
    ): Promise<AppEventLocalizationResponse> =>
      this.request<AppEventLocalizationResponse, ErrorResponse>({
        path: `/v1/appEventLocalizations/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppEventLocalizations
     * @name AppEventLocalizationsUpdateInstance
     * @request PATCH:/v1/appEventLocalizations/{id}
     * @secure
     */
    updateInstance: (
      id: string,
      data: AppEventLocalizationUpdateRequest,
      params: RequestParams = {},
    ): Promise<AppEventLocalizationResponse> =>
      this.request<AppEventLocalizationResponse, ErrorResponse>({
        path: `/v1/appEventLocalizations/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppEventLocalizations
     * @name AppEventLocalizationsDeleteInstance
     * @request DELETE:/v1/appEventLocalizations/{id}
     * @secure
     */
    deleteInstance: (id: string, params: RequestParams = {}): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/appEventLocalizations/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppEventLocalizations
     * @name AppEventLocalizationsAppEventScreenshotsGetToManyRelated
     * @request GET:/v1/appEventLocalizations/{id}/appEventScreenshots
     * @secure
     */
    appEventScreenshotsGetToManyRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type appEventScreenshots */
        "fields[appEventScreenshots]"?: (
          | "appEventAssetType"
          | "appEventLocalization"
          | "assetDeliveryState"
          | "assetToken"
          | "fileName"
          | "fileSize"
          | "imageAsset"
          | "uploadOperations"
          | "uploaded"
        )[];
        /** the fields to include for returned resources of type appEventLocalizations */
        "fields[appEventLocalizations]"?: (
          | "appEvent"
          | "appEventScreenshots"
          | "appEventVideoClips"
          | "locale"
          | "longDescription"
          | "name"
          | "shortDescription"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /** comma-separated list of relationships to include */
        include?: "appEventLocalization"[];
      },
      params: RequestParams = {},
    ): Promise<AppEventScreenshotsResponse> =>
      this.request<AppEventScreenshotsResponse, ErrorResponse>({
        path: `/v1/appEventLocalizations/${id}/appEventScreenshots`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppEventLocalizations
     * @name AppEventLocalizationsAppEventVideoClipsGetToManyRelated
     * @request GET:/v1/appEventLocalizations/{id}/appEventVideoClips
     * @secure
     */
    appEventVideoClipsGetToManyRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type appEventVideoClips */
        "fields[appEventVideoClips]"?: (
          | "appEventAssetType"
          | "appEventLocalization"
          | "assetDeliveryState"
          | "fileName"
          | "fileSize"
          | "previewFrameTimeCode"
          | "previewImage"
          | "uploadOperations"
          | "uploaded"
          | "videoUrl"
        )[];
        /** the fields to include for returned resources of type appEventLocalizations */
        "fields[appEventLocalizations]"?: (
          | "appEvent"
          | "appEventScreenshots"
          | "appEventVideoClips"
          | "locale"
          | "longDescription"
          | "name"
          | "shortDescription"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /** comma-separated list of relationships to include */
        include?: "appEventLocalization"[];
      },
      params: RequestParams = {},
    ): Promise<AppEventVideoClipsResponse> =>
      this.request<AppEventVideoClipsResponse, ErrorResponse>({
        path: `/v1/appEventLocalizations/${id}/appEventVideoClips`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  appEventScreenshots = {
    /**
     * No description
     *
     * @tags AppEventScreenshots
     * @name AppEventScreenshotsCreateInstance
     * @request POST:/v1/appEventScreenshots
     * @secure
     */
    createInstance: (
      data: AppEventScreenshotCreateRequest,
      params: RequestParams = {},
    ): Promise<AppEventScreenshotResponse> =>
      this.request<AppEventScreenshotResponse, ErrorResponse>({
        path: `/v1/appEventScreenshots`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppEventScreenshots
     * @name AppEventScreenshotsGetInstance
     * @request GET:/v1/appEventScreenshots/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type appEventScreenshots */
        "fields[appEventScreenshots]"?: (
          | "appEventAssetType"
          | "appEventLocalization"
          | "assetDeliveryState"
          | "assetToken"
          | "fileName"
          | "fileSize"
          | "imageAsset"
          | "uploadOperations"
          | "uploaded"
        )[];
        /** comma-separated list of relationships to include */
        include?: "appEventLocalization"[];
      },
      params: RequestParams = {},
    ): Promise<AppEventScreenshotResponse> =>
      this.request<AppEventScreenshotResponse, ErrorResponse>({
        path: `/v1/appEventScreenshots/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppEventScreenshots
     * @name AppEventScreenshotsUpdateInstance
     * @request PATCH:/v1/appEventScreenshots/{id}
     * @secure
     */
    updateInstance: (
      id: string,
      data: AppEventScreenshotUpdateRequest,
      params: RequestParams = {},
    ): Promise<AppEventScreenshotResponse> =>
      this.request<AppEventScreenshotResponse, ErrorResponse>({
        path: `/v1/appEventScreenshots/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppEventScreenshots
     * @name AppEventScreenshotsDeleteInstance
     * @request DELETE:/v1/appEventScreenshots/{id}
     * @secure
     */
    deleteInstance: (id: string, params: RequestParams = {}): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/appEventScreenshots/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),
  };
  appEventVideoClips = {
    /**
     * No description
     *
     * @tags AppEventVideoClips
     * @name AppEventVideoClipsCreateInstance
     * @request POST:/v1/appEventVideoClips
     * @secure
     */
    createInstance: (
      data: AppEventVideoClipCreateRequest,
      params: RequestParams = {},
    ): Promise<AppEventVideoClipResponse> =>
      this.request<AppEventVideoClipResponse, ErrorResponse>({
        path: `/v1/appEventVideoClips`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppEventVideoClips
     * @name AppEventVideoClipsGetInstance
     * @request GET:/v1/appEventVideoClips/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type appEventVideoClips */
        "fields[appEventVideoClips]"?: (
          | "appEventAssetType"
          | "appEventLocalization"
          | "assetDeliveryState"
          | "fileName"
          | "fileSize"
          | "previewFrameTimeCode"
          | "previewImage"
          | "uploadOperations"
          | "uploaded"
          | "videoUrl"
        )[];
        /** comma-separated list of relationships to include */
        include?: "appEventLocalization"[];
      },
      params: RequestParams = {},
    ): Promise<AppEventVideoClipResponse> =>
      this.request<AppEventVideoClipResponse, ErrorResponse>({
        path: `/v1/appEventVideoClips/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppEventVideoClips
     * @name AppEventVideoClipsUpdateInstance
     * @request PATCH:/v1/appEventVideoClips/{id}
     * @secure
     */
    updateInstance: (
      id: string,
      data: AppEventVideoClipUpdateRequest,
      params: RequestParams = {},
    ): Promise<AppEventVideoClipResponse> =>
      this.request<AppEventVideoClipResponse, ErrorResponse>({
        path: `/v1/appEventVideoClips/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppEventVideoClips
     * @name AppEventVideoClipsDeleteInstance
     * @request DELETE:/v1/appEventVideoClips/{id}
     * @secure
     */
    deleteInstance: (id: string, params: RequestParams = {}): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/appEventVideoClips/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),
  };
  appEvents = {
    /**
     * No description
     *
     * @tags AppEvents
     * @name AppEventsCreateInstance
     * @request POST:/v1/appEvents
     * @secure
     */
    createInstance: (data: AppEventCreateRequest, params: RequestParams = {}): Promise<AppEventResponse> =>
      this.request<AppEventResponse, ErrorResponse>({
        path: `/v1/appEvents`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppEvents
     * @name AppEventsGetInstance
     * @request GET:/v1/appEvents/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type appEvents */
        "fields[appEvents]"?: (
          | "app"
          | "archivedTerritorySchedules"
          | "badge"
          | "deepLink"
          | "eventState"
          | "localizations"
          | "primaryLocale"
          | "priority"
          | "purchaseRequirement"
          | "purpose"
          | "referenceName"
          | "territorySchedules"
        )[];
        /** comma-separated list of relationships to include */
        include?: "localizations"[];
        /** the fields to include for returned resources of type appEventLocalizations */
        "fields[appEventLocalizations]"?: (
          | "appEvent"
          | "appEventScreenshots"
          | "appEventVideoClips"
          | "locale"
          | "longDescription"
          | "name"
          | "shortDescription"
        )[];
        /**
         * maximum number of related localizations returned (when they are included)
         * @max 50
         */
        "limit[localizations]"?: number;
      },
      params: RequestParams = {},
    ): Promise<AppEventResponse> =>
      this.request<AppEventResponse, ErrorResponse>({
        path: `/v1/appEvents/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppEvents
     * @name AppEventsUpdateInstance
     * @request PATCH:/v1/appEvents/{id}
     * @secure
     */
    updateInstance: (id: string, data: AppEventUpdateRequest, params: RequestParams = {}): Promise<AppEventResponse> =>
      this.request<AppEventResponse, ErrorResponse>({
        path: `/v1/appEvents/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppEvents
     * @name AppEventsDeleteInstance
     * @request DELETE:/v1/appEvents/{id}
     * @secure
     */
    deleteInstance: (id: string, params: RequestParams = {}): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/appEvents/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppEvents
     * @name AppEventsLocalizationsGetToManyRelated
     * @request GET:/v1/appEvents/{id}/localizations
     * @secure
     */
    localizationsGetToManyRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type appEventScreenshots */
        "fields[appEventScreenshots]"?: (
          | "appEventAssetType"
          | "appEventLocalization"
          | "assetDeliveryState"
          | "assetToken"
          | "fileName"
          | "fileSize"
          | "imageAsset"
          | "uploadOperations"
          | "uploaded"
        )[];
        /** the fields to include for returned resources of type appEventVideoClips */
        "fields[appEventVideoClips]"?: (
          | "appEventAssetType"
          | "appEventLocalization"
          | "assetDeliveryState"
          | "fileName"
          | "fileSize"
          | "previewFrameTimeCode"
          | "previewImage"
          | "uploadOperations"
          | "uploaded"
          | "videoUrl"
        )[];
        /** the fields to include for returned resources of type appEventLocalizations */
        "fields[appEventLocalizations]"?: (
          | "appEvent"
          | "appEventScreenshots"
          | "appEventVideoClips"
          | "locale"
          | "longDescription"
          | "name"
          | "shortDescription"
        )[];
        /** the fields to include for returned resources of type appEvents */
        "fields[appEvents]"?: (
          | "app"
          | "archivedTerritorySchedules"
          | "badge"
          | "deepLink"
          | "eventState"
          | "localizations"
          | "primaryLocale"
          | "priority"
          | "purchaseRequirement"
          | "purpose"
          | "referenceName"
          | "territorySchedules"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /**
         * maximum number of related appEventScreenshots returned (when they are included)
         * @max 50
         */
        "limit[appEventScreenshots]"?: number;
        /**
         * maximum number of related appEventVideoClips returned (when they are included)
         * @max 50
         */
        "limit[appEventVideoClips]"?: number;
        /** comma-separated list of relationships to include */
        include?: ("appEvent" | "appEventScreenshots" | "appEventVideoClips")[];
      },
      params: RequestParams = {},
    ): Promise<AppEventLocalizationsResponse> =>
      this.request<AppEventLocalizationsResponse, ErrorResponse>({
        path: `/v1/appEvents/${id}/localizations`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  appInfoLocalizations = {
    /**
     * No description
     *
     * @tags AppInfoLocalizations
     * @name AppInfoLocalizationsCreateInstance
     * @request POST:/v1/appInfoLocalizations
     * @secure
     */
    createInstance: (
      data: AppInfoLocalizationCreateRequest,
      params: RequestParams = {},
    ): Promise<AppInfoLocalizationResponse> =>
      this.request<AppInfoLocalizationResponse, ErrorResponse>({
        path: `/v1/appInfoLocalizations`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppInfoLocalizations
     * @name AppInfoLocalizationsGetInstance
     * @request GET:/v1/appInfoLocalizations/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type appInfoLocalizations */
        "fields[appInfoLocalizations]"?: (
          | "appInfo"
          | "locale"
          | "name"
          | "privacyChoicesUrl"
          | "privacyPolicyText"
          | "privacyPolicyUrl"
          | "subtitle"
        )[];
        /** comma-separated list of relationships to include */
        include?: "appInfo"[];
      },
      params: RequestParams = {},
    ): Promise<AppInfoLocalizationResponse> =>
      this.request<AppInfoLocalizationResponse, ErrorResponse>({
        path: `/v1/appInfoLocalizations/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppInfoLocalizations
     * @name AppInfoLocalizationsUpdateInstance
     * @request PATCH:/v1/appInfoLocalizations/{id}
     * @secure
     */
    updateInstance: (
      id: string,
      data: AppInfoLocalizationUpdateRequest,
      params: RequestParams = {},
    ): Promise<AppInfoLocalizationResponse> =>
      this.request<AppInfoLocalizationResponse, ErrorResponse>({
        path: `/v1/appInfoLocalizations/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppInfoLocalizations
     * @name AppInfoLocalizationsDeleteInstance
     * @request DELETE:/v1/appInfoLocalizations/{id}
     * @secure
     */
    deleteInstance: (id: string, params: RequestParams = {}): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/appInfoLocalizations/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),
  };
  appInfos = {
    /**
     * No description
     *
     * @tags AppInfos
     * @name AppInfosGetInstance
     * @request GET:/v1/appInfos/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type appInfos */
        "fields[appInfos]"?: (
          | "ageRatingDeclaration"
          | "app"
          | "appInfoLocalizations"
          | "appStoreAgeRating"
          | "appStoreState"
          | "brazilAgeRating"
          | "brazilAgeRatingV2"
          | "kidsAgeBand"
          | "primaryCategory"
          | "primarySubcategoryOne"
          | "primarySubcategoryTwo"
          | "secondaryCategory"
          | "secondarySubcategoryOne"
          | "secondarySubcategoryTwo"
          | "state"
        )[];
        /** comma-separated list of relationships to include */
        include?: (
          | "ageRatingDeclaration"
          | "app"
          | "appInfoLocalizations"
          | "primaryCategory"
          | "primarySubcategoryOne"
          | "primarySubcategoryTwo"
          | "secondaryCategory"
          | "secondarySubcategoryOne"
          | "secondarySubcategoryTwo"
        )[];
        /** the fields to include for returned resources of type ageRatingDeclarations */
        "fields[ageRatingDeclarations]"?: (
          | "ageRatingOverride"
          | "alcoholTobaccoOrDrugUseOrReferences"
          | "contests"
          | "gambling"
          | "gamblingAndContests"
          | "gamblingSimulated"
          | "horrorOrFearThemes"
          | "kidsAgeBand"
          | "matureOrSuggestiveThemes"
          | "medicalOrTreatmentInformation"
          | "profanityOrCrudeHumor"
          | "seventeenPlus"
          | "sexualContentGraphicAndNudity"
          | "sexualContentOrNudity"
          | "unrestrictedWebAccess"
          | "violenceCartoonOrFantasy"
          | "violenceRealistic"
          | "violenceRealisticProlongedGraphicOrSadistic"
        )[];
        /** the fields to include for returned resources of type appInfoLocalizations */
        "fields[appInfoLocalizations]"?: (
          | "appInfo"
          | "locale"
          | "name"
          | "privacyChoicesUrl"
          | "privacyPolicyText"
          | "privacyPolicyUrl"
          | "subtitle"
        )[];
        /** the fields to include for returned resources of type appCategories */
        "fields[appCategories]"?: ("parent" | "platforms" | "subcategories")[];
        /**
         * maximum number of related appInfoLocalizations returned (when they are included)
         * @max 50
         */
        "limit[appInfoLocalizations]"?: number;
      },
      params: RequestParams = {},
    ): Promise<AppInfoResponse> =>
      this.request<AppInfoResponse, ErrorResponse>({
        path: `/v1/appInfos/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppInfos
     * @name AppInfosUpdateInstance
     * @request PATCH:/v1/appInfos/{id}
     * @secure
     */
    updateInstance: (id: string, data: AppInfoUpdateRequest, params: RequestParams = {}): Promise<AppInfoResponse> =>
      this.request<AppInfoResponse, ErrorResponse>({
        path: `/v1/appInfos/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppInfos
     * @name AppInfosAgeRatingDeclarationGetToOneRelated
     * @request GET:/v1/appInfos/{id}/ageRatingDeclaration
     * @secure
     */
    ageRatingDeclarationGetToOneRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type ageRatingDeclarations */
        "fields[ageRatingDeclarations]"?: (
          | "ageRatingOverride"
          | "alcoholTobaccoOrDrugUseOrReferences"
          | "contests"
          | "gambling"
          | "gamblingAndContests"
          | "gamblingSimulated"
          | "horrorOrFearThemes"
          | "kidsAgeBand"
          | "matureOrSuggestiveThemes"
          | "medicalOrTreatmentInformation"
          | "profanityOrCrudeHumor"
          | "seventeenPlus"
          | "sexualContentGraphicAndNudity"
          | "sexualContentOrNudity"
          | "unrestrictedWebAccess"
          | "violenceCartoonOrFantasy"
          | "violenceRealistic"
          | "violenceRealisticProlongedGraphicOrSadistic"
        )[];
      },
      params: RequestParams = {},
    ): Promise<AgeRatingDeclarationResponse> =>
      this.request<AgeRatingDeclarationResponse, ErrorResponse>({
        path: `/v1/appInfos/${id}/ageRatingDeclaration`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppInfos
     * @name AppInfosAppInfoLocalizationsGetToManyRelated
     * @request GET:/v1/appInfos/{id}/appInfoLocalizations
     * @secure
     */
    appInfoLocalizationsGetToManyRelated: (
      id: string,
      query?: {
        /** filter by attribute 'locale' */
        "filter[locale]"?: string[];
        /** the fields to include for returned resources of type appInfos */
        "fields[appInfos]"?: (
          | "ageRatingDeclaration"
          | "app"
          | "appInfoLocalizations"
          | "appStoreAgeRating"
          | "appStoreState"
          | "brazilAgeRating"
          | "brazilAgeRatingV2"
          | "kidsAgeBand"
          | "primaryCategory"
          | "primarySubcategoryOne"
          | "primarySubcategoryTwo"
          | "secondaryCategory"
          | "secondarySubcategoryOne"
          | "secondarySubcategoryTwo"
          | "state"
        )[];
        /** the fields to include for returned resources of type appInfoLocalizations */
        "fields[appInfoLocalizations]"?: (
          | "appInfo"
          | "locale"
          | "name"
          | "privacyChoicesUrl"
          | "privacyPolicyText"
          | "privacyPolicyUrl"
          | "subtitle"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /** comma-separated list of relationships to include */
        include?: "appInfo"[];
      },
      params: RequestParams = {},
    ): Promise<AppInfoLocalizationsResponse> =>
      this.request<AppInfoLocalizationsResponse, ErrorResponse>({
        path: `/v1/appInfos/${id}/appInfoLocalizations`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppInfos
     * @name AppInfosPrimaryCategoryGetToOneRelated
     * @request GET:/v1/appInfos/{id}/primaryCategory
     * @secure
     */
    primaryCategoryGetToOneRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type appCategories */
        "fields[appCategories]"?: ("parent" | "platforms" | "subcategories")[];
        /**
         * maximum number of related subcategories returned (when they are included)
         * @max 50
         */
        "limit[subcategories]"?: number;
        /** comma-separated list of relationships to include */
        include?: ("parent" | "subcategories")[];
      },
      params: RequestParams = {},
    ): Promise<AppCategoryResponse> =>
      this.request<AppCategoryResponse, ErrorResponse>({
        path: `/v1/appInfos/${id}/primaryCategory`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppInfos
     * @name AppInfosPrimarySubcategoryOneGetToOneRelated
     * @request GET:/v1/appInfos/{id}/primarySubcategoryOne
     * @secure
     */
    primarySubcategoryOneGetToOneRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type appCategories */
        "fields[appCategories]"?: ("parent" | "platforms" | "subcategories")[];
        /**
         * maximum number of related subcategories returned (when they are included)
         * @max 50
         */
        "limit[subcategories]"?: number;
        /** comma-separated list of relationships to include */
        include?: ("parent" | "subcategories")[];
      },
      params: RequestParams = {},
    ): Promise<AppCategoryResponse> =>
      this.request<AppCategoryResponse, ErrorResponse>({
        path: `/v1/appInfos/${id}/primarySubcategoryOne`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppInfos
     * @name AppInfosPrimarySubcategoryTwoGetToOneRelated
     * @request GET:/v1/appInfos/{id}/primarySubcategoryTwo
     * @secure
     */
    primarySubcategoryTwoGetToOneRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type appCategories */
        "fields[appCategories]"?: ("parent" | "platforms" | "subcategories")[];
        /**
         * maximum number of related subcategories returned (when they are included)
         * @max 50
         */
        "limit[subcategories]"?: number;
        /** comma-separated list of relationships to include */
        include?: ("parent" | "subcategories")[];
      },
      params: RequestParams = {},
    ): Promise<AppCategoryResponse> =>
      this.request<AppCategoryResponse, ErrorResponse>({
        path: `/v1/appInfos/${id}/primarySubcategoryTwo`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppInfos
     * @name AppInfosSecondaryCategoryGetToOneRelated
     * @request GET:/v1/appInfos/{id}/secondaryCategory
     * @secure
     */
    secondaryCategoryGetToOneRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type appCategories */
        "fields[appCategories]"?: ("parent" | "platforms" | "subcategories")[];
        /**
         * maximum number of related subcategories returned (when they are included)
         * @max 50
         */
        "limit[subcategories]"?: number;
        /** comma-separated list of relationships to include */
        include?: ("parent" | "subcategories")[];
      },
      params: RequestParams = {},
    ): Promise<AppCategoryResponse> =>
      this.request<AppCategoryResponse, ErrorResponse>({
        path: `/v1/appInfos/${id}/secondaryCategory`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppInfos
     * @name AppInfosSecondarySubcategoryOneGetToOneRelated
     * @request GET:/v1/appInfos/{id}/secondarySubcategoryOne
     * @secure
     */
    secondarySubcategoryOneGetToOneRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type appCategories */
        "fields[appCategories]"?: ("parent" | "platforms" | "subcategories")[];
        /**
         * maximum number of related subcategories returned (when they are included)
         * @max 50
         */
        "limit[subcategories]"?: number;
        /** comma-separated list of relationships to include */
        include?: ("parent" | "subcategories")[];
      },
      params: RequestParams = {},
    ): Promise<AppCategoryResponse> =>
      this.request<AppCategoryResponse, ErrorResponse>({
        path: `/v1/appInfos/${id}/secondarySubcategoryOne`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppInfos
     * @name AppInfosSecondarySubcategoryTwoGetToOneRelated
     * @request GET:/v1/appInfos/{id}/secondarySubcategoryTwo
     * @secure
     */
    secondarySubcategoryTwoGetToOneRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type appCategories */
        "fields[appCategories]"?: ("parent" | "platforms" | "subcategories")[];
        /**
         * maximum number of related subcategories returned (when they are included)
         * @max 50
         */
        "limit[subcategories]"?: number;
        /** comma-separated list of relationships to include */
        include?: ("parent" | "subcategories")[];
      },
      params: RequestParams = {},
    ): Promise<AppCategoryResponse> =>
      this.request<AppCategoryResponse, ErrorResponse>({
        path: `/v1/appInfos/${id}/secondarySubcategoryTwo`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  appPreOrders = {
    /**
     * No description
     *
     * @tags AppPreOrders
     * @name AppPreOrdersCreateInstance
     * @request POST:/v1/appPreOrders
     * @deprecated
     * @secure
     */
    createInstance: (data: AppPreOrderCreateRequest, params: RequestParams = {}): Promise<AppPreOrderResponse> =>
      this.request<AppPreOrderResponse, ErrorResponse>({
        path: `/v1/appPreOrders`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppPreOrders
     * @name AppPreOrdersGetInstance
     * @request GET:/v1/appPreOrders/{id}
     * @deprecated
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type appPreOrders */
        "fields[appPreOrders]"?: ("app" | "appReleaseDate" | "preOrderAvailableDate")[];
        /** comma-separated list of relationships to include */
        include?: "app"[];
      },
      params: RequestParams = {},
    ): Promise<AppPreOrderResponse> =>
      this.request<AppPreOrderResponse, ErrorResponse>({
        path: `/v1/appPreOrders/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppPreOrders
     * @name AppPreOrdersUpdateInstance
     * @request PATCH:/v1/appPreOrders/{id}
     * @deprecated
     * @secure
     */
    updateInstance: (
      id: string,
      data: AppPreOrderUpdateRequest,
      params: RequestParams = {},
    ): Promise<AppPreOrderResponse> =>
      this.request<AppPreOrderResponse, ErrorResponse>({
        path: `/v1/appPreOrders/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppPreOrders
     * @name AppPreOrdersDeleteInstance
     * @request DELETE:/v1/appPreOrders/{id}
     * @deprecated
     * @secure
     */
    deleteInstance: (id: string, params: RequestParams = {}): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/appPreOrders/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),
  };
  appPreviewSets = {
    /**
     * No description
     *
     * @tags AppPreviewSets
     * @name AppPreviewSetsCreateInstance
     * @request POST:/v1/appPreviewSets
     * @secure
     */
    createInstance: (data: AppPreviewSetCreateRequest, params: RequestParams = {}): Promise<AppPreviewSetResponse> =>
      this.request<AppPreviewSetResponse, ErrorResponse>({
        path: `/v1/appPreviewSets`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppPreviewSets
     * @name AppPreviewSetsGetInstance
     * @request GET:/v1/appPreviewSets/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type appPreviewSets */
        "fields[appPreviewSets]"?: (
          | "appCustomProductPageLocalization"
          | "appPreviews"
          | "appStoreVersionExperimentTreatmentLocalization"
          | "appStoreVersionLocalization"
          | "previewType"
        )[];
        /** comma-separated list of relationships to include */
        include?: (
          | "appCustomProductPageLocalization"
          | "appPreviews"
          | "appStoreVersionExperimentTreatmentLocalization"
          | "appStoreVersionLocalization"
        )[];
        /** the fields to include for returned resources of type appPreviews */
        "fields[appPreviews]"?: (
          | "appPreviewSet"
          | "assetDeliveryState"
          | "fileName"
          | "fileSize"
          | "mimeType"
          | "previewFrameTimeCode"
          | "previewImage"
          | "sourceFileChecksum"
          | "uploadOperations"
          | "uploaded"
          | "videoUrl"
        )[];
        /**
         * maximum number of related appPreviews returned (when they are included)
         * @max 50
         */
        "limit[appPreviews]"?: number;
      },
      params: RequestParams = {},
    ): Promise<AppPreviewSetResponse> =>
      this.request<AppPreviewSetResponse, ErrorResponse>({
        path: `/v1/appPreviewSets/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppPreviewSets
     * @name AppPreviewSetsDeleteInstance
     * @request DELETE:/v1/appPreviewSets/{id}
     * @secure
     */
    deleteInstance: (id: string, params: RequestParams = {}): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/appPreviewSets/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppPreviewSets
     * @name AppPreviewSetsAppPreviewsGetToManyRelationship
     * @request GET:/v1/appPreviewSets/{id}/relationships/appPreviews
     * @secure
     */
    appPreviewsGetToManyRelationship: (
      id: string,
      query?: {
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
      },
      params: RequestParams = {},
    ): Promise<AppPreviewSetAppPreviewsLinkagesResponse> =>
      this.request<AppPreviewSetAppPreviewsLinkagesResponse, ErrorResponse>({
        path: `/v1/appPreviewSets/${id}/relationships/appPreviews`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppPreviewSets
     * @name AppPreviewSetsAppPreviewsReplaceToManyRelationship
     * @request PATCH:/v1/appPreviewSets/{id}/relationships/appPreviews
     * @secure
     */
    appPreviewsReplaceToManyRelationship: (
      id: string,
      data: AppPreviewSetAppPreviewsLinkagesRequest,
      params: RequestParams = {},
    ): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/appPreviewSets/${id}/relationships/appPreviews`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppPreviewSets
     * @name AppPreviewSetsAppPreviewsGetToManyRelated
     * @request GET:/v1/appPreviewSets/{id}/appPreviews
     * @secure
     */
    appPreviewsGetToManyRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type appPreviews */
        "fields[appPreviews]"?: (
          | "appPreviewSet"
          | "assetDeliveryState"
          | "fileName"
          | "fileSize"
          | "mimeType"
          | "previewFrameTimeCode"
          | "previewImage"
          | "sourceFileChecksum"
          | "uploadOperations"
          | "uploaded"
          | "videoUrl"
        )[];
        /** the fields to include for returned resources of type appPreviewSets */
        "fields[appPreviewSets]"?: (
          | "appCustomProductPageLocalization"
          | "appPreviews"
          | "appStoreVersionExperimentTreatmentLocalization"
          | "appStoreVersionLocalization"
          | "previewType"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /** comma-separated list of relationships to include */
        include?: "appPreviewSet"[];
      },
      params: RequestParams = {},
    ): Promise<AppPreviewsResponse> =>
      this.request<AppPreviewsResponse, ErrorResponse>({
        path: `/v1/appPreviewSets/${id}/appPreviews`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  appPreviews = {
    /**
     * No description
     *
     * @tags AppPreviews
     * @name AppPreviewsCreateInstance
     * @request POST:/v1/appPreviews
     * @secure
     */
    createInstance: (data: AppPreviewCreateRequest, params: RequestParams = {}): Promise<AppPreviewResponse> =>
      this.request<AppPreviewResponse, ErrorResponse>({
        path: `/v1/appPreviews`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppPreviews
     * @name AppPreviewsGetInstance
     * @request GET:/v1/appPreviews/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type appPreviews */
        "fields[appPreviews]"?: (
          | "appPreviewSet"
          | "assetDeliveryState"
          | "fileName"
          | "fileSize"
          | "mimeType"
          | "previewFrameTimeCode"
          | "previewImage"
          | "sourceFileChecksum"
          | "uploadOperations"
          | "uploaded"
          | "videoUrl"
        )[];
        /** comma-separated list of relationships to include */
        include?: "appPreviewSet"[];
      },
      params: RequestParams = {},
    ): Promise<AppPreviewResponse> =>
      this.request<AppPreviewResponse, ErrorResponse>({
        path: `/v1/appPreviews/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppPreviews
     * @name AppPreviewsUpdateInstance
     * @request PATCH:/v1/appPreviews/{id}
     * @secure
     */
    updateInstance: (
      id: string,
      data: AppPreviewUpdateRequest,
      params: RequestParams = {},
    ): Promise<AppPreviewResponse> =>
      this.request<AppPreviewResponse, ErrorResponse>({
        path: `/v1/appPreviews/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppPreviews
     * @name AppPreviewsDeleteInstance
     * @request DELETE:/v1/appPreviews/{id}
     * @secure
     */
    deleteInstance: (id: string, params: RequestParams = {}): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/appPreviews/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),
  };
  appPricePoints = {
    /**
     * No description
     *
     * @tags AppPricePoints
     * @name AppPricePointsV3GetInstance
     * @request GET:/v3/appPricePoints/{id}
     * @secure
     */
    v3GetInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type appPricePoints */
        "fields[appPricePoints]"?: ("app" | "customerPrice" | "equalizations" | "proceeds" | "territory")[];
        /** comma-separated list of relationships to include */
        include?: ("app" | "territory")[];
      },
      params: RequestParams = {},
    ): Promise<AppPricePointV3Response> =>
      this.request<AppPricePointV3Response, ErrorResponse>({
        path: `/v3/appPricePoints/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppPricePoints
     * @name AppPricePointsGetCollection
     * @request GET:/v1/appPricePoints
     * @deprecated
     * @secure
     */
    getCollection: (
      query?: {
        /**
         * filter by id(s) of related 'priceTier'
         * @deprecated
         */
        "filter[priceTier]"?: string[];
        /** filter by id(s) of related 'territory' */
        "filter[territory]"?: string[];
        /** the fields to include for returned resources of type appPricePoints */
        "fields[appPricePoints]"?: ("customerPrice" | "priceTier" | "proceeds" | "territory")[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /** comma-separated list of relationships to include */
        include?: ("priceTier" | "territory")[];
        /** the fields to include for returned resources of type territories */
        "fields[territories]"?: "currency"[];
      },
      params: RequestParams = {},
    ): Promise<AppPricePointsResponse> =>
      this.request<AppPricePointsResponse, ErrorResponse>({
        path: `/v1/appPricePoints`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppPricePoints
     * @name AppPricePointsGetInstance
     * @request GET:/v1/appPricePoints/{id}
     * @deprecated
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type appPricePoints */
        "fields[appPricePoints]"?: ("customerPrice" | "priceTier" | "proceeds" | "territory")[];
        /** comma-separated list of relationships to include */
        include?: ("priceTier" | "territory")[];
        /** the fields to include for returned resources of type territories */
        "fields[territories]"?: "currency"[];
      },
      params: RequestParams = {},
    ): Promise<AppPricePointResponse> =>
      this.request<AppPricePointResponse, ErrorResponse>({
        path: `/v1/appPricePoints/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppPricePoints
     * @name AppPricePointsV3EqualizationsGetToManyRelated
     * @request GET:/v3/appPricePoints/{id}/equalizations
     * @secure
     */
    v3EqualizationsGetToManyRelated: (
      id: string,
      query?: {
        /** filter by id(s) of related 'territory' */
        "filter[territory]"?: string[];
        /** the fields to include for returned resources of type appPricePoints */
        "fields[appPricePoints]"?: ("app" | "customerPrice" | "equalizations" | "proceeds" | "territory")[];
        /** the fields to include for returned resources of type apps */
        "fields[apps]"?: (
          | "alternativeDistributionKey"
          | "analyticsReportRequests"
          | "appAvailability"
          | "appClips"
          | "appCustomProductPages"
          | "appEncryptionDeclarations"
          | "appEvents"
          | "appInfos"
          | "appPricePoints"
          | "appPriceSchedule"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersions"
          | "availableInNewTerritories"
          | "availableTerritories"
          | "betaAppLocalizations"
          | "betaAppReviewDetail"
          | "betaGroups"
          | "betaLicenseAgreement"
          | "betaTesters"
          | "builds"
          | "bundleId"
          | "ciProduct"
          | "contentRightsDeclaration"
          | "customerReviews"
          | "endUserLicenseAgreement"
          | "gameCenterDetail"
          | "gameCenterEnabledVersions"
          | "inAppPurchases"
          | "inAppPurchasesV2"
          | "isOrEverWasMadeForKids"
          | "marketplaceSearchDetail"
          | "name"
          | "perfPowerMetrics"
          | "preOrder"
          | "preReleaseVersions"
          | "pricePoints"
          | "prices"
          | "primaryLocale"
          | "promotedPurchases"
          | "reviewSubmissions"
          | "sku"
          | "subscriptionGracePeriod"
          | "subscriptionGroups"
          | "subscriptionStatusUrl"
          | "subscriptionStatusUrlForSandbox"
          | "subscriptionStatusUrlVersion"
          | "subscriptionStatusUrlVersionForSandbox"
        )[];
        /** the fields to include for returned resources of type territories */
        "fields[territories]"?: "currency"[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /** comma-separated list of relationships to include */
        include?: ("app" | "territory")[];
      },
      params: RequestParams = {},
    ): Promise<AppPricePointsV3Response> =>
      this.request<AppPricePointsV3Response, ErrorResponse>({
        path: `/v3/appPricePoints/${id}/equalizations`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppPricePoints
     * @name AppPricePointsTerritoryGetToOneRelated
     * @request GET:/v1/appPricePoints/{id}/territory
     * @deprecated
     * @secure
     */
    territoryGetToOneRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type territories */
        "fields[territories]"?: "currency"[];
      },
      params: RequestParams = {},
    ): Promise<TerritoryResponse> =>
      this.request<TerritoryResponse, ErrorResponse>({
        path: `/v1/appPricePoints/${id}/territory`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  appPriceSchedules = {
    /**
     * No description
     *
     * @tags AppPriceSchedules
     * @name AppPriceSchedulesCreateInstance
     * @request POST:/v1/appPriceSchedules
     * @secure
     */
    createInstance: (
      data: AppPriceScheduleCreateRequest,
      params: RequestParams = {},
    ): Promise<AppPriceScheduleResponse> =>
      this.request<AppPriceScheduleResponse, ErrorResponse>({
        path: `/v1/appPriceSchedules`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppPriceSchedules
     * @name AppPriceSchedulesGetInstance
     * @request GET:/v1/appPriceSchedules/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type appPriceSchedules */
        "fields[appPriceSchedules]"?: ("app" | "automaticPrices" | "baseTerritory" | "manualPrices")[];
        /** comma-separated list of relationships to include */
        include?: ("app" | "automaticPrices" | "baseTerritory" | "manualPrices")[];
        /** the fields to include for returned resources of type appPrices */
        "fields[appPrices]"?: ("appPricePoint" | "endDate" | "manual" | "startDate" | "territory")[];
        /** the fields to include for returned resources of type territories */
        "fields[territories]"?: "currency"[];
        /**
         * maximum number of related automaticPrices returned (when they are included)
         * @max 50
         */
        "limit[automaticPrices]"?: number;
        /**
         * maximum number of related manualPrices returned (when they are included)
         * @max 50
         */
        "limit[manualPrices]"?: number;
      },
      params: RequestParams = {},
    ): Promise<AppPriceScheduleResponse> =>
      this.request<AppPriceScheduleResponse, ErrorResponse>({
        path: `/v1/appPriceSchedules/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppPriceSchedules
     * @name AppPriceSchedulesAutomaticPricesGetToManyRelated
     * @request GET:/v1/appPriceSchedules/{id}/automaticPrices
     * @secure
     */
    automaticPricesGetToManyRelated: (
      id: string,
      query?: {
        /** filter by attribute 'endDate' */
        "filter[endDate]"?: string[];
        /** filter by attribute 'startDate' */
        "filter[startDate]"?: string[];
        /** filter by id(s) of related 'territory' */
        "filter[territory]"?: string[];
        /** the fields to include for returned resources of type appPrices */
        "fields[appPrices]"?: ("appPricePoint" | "endDate" | "manual" | "startDate" | "territory")[];
        /** the fields to include for returned resources of type appPricePoints */
        "fields[appPricePoints]"?: ("app" | "customerPrice" | "equalizations" | "proceeds" | "territory")[];
        /** the fields to include for returned resources of type territories */
        "fields[territories]"?: "currency"[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /** comma-separated list of relationships to include */
        include?: ("appPricePoint" | "territory")[];
      },
      params: RequestParams = {},
    ): Promise<AppPricesV2Response> =>
      this.request<AppPricesV2Response, ErrorResponse>({
        path: `/v1/appPriceSchedules/${id}/automaticPrices`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppPriceSchedules
     * @name AppPriceSchedulesBaseTerritoryGetToOneRelated
     * @request GET:/v1/appPriceSchedules/{id}/baseTerritory
     * @secure
     */
    baseTerritoryGetToOneRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type territories */
        "fields[territories]"?: "currency"[];
      },
      params: RequestParams = {},
    ): Promise<TerritoryResponse> =>
      this.request<TerritoryResponse, ErrorResponse>({
        path: `/v1/appPriceSchedules/${id}/baseTerritory`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppPriceSchedules
     * @name AppPriceSchedulesManualPricesGetToManyRelated
     * @request GET:/v1/appPriceSchedules/{id}/manualPrices
     * @secure
     */
    manualPricesGetToManyRelated: (
      id: string,
      query?: {
        /** filter by attribute 'endDate' */
        "filter[endDate]"?: string[];
        /** filter by attribute 'startDate' */
        "filter[startDate]"?: string[];
        /** filter by id(s) of related 'territory' */
        "filter[territory]"?: string[];
        /** the fields to include for returned resources of type appPrices */
        "fields[appPrices]"?: ("appPricePoint" | "endDate" | "manual" | "startDate" | "territory")[];
        /** the fields to include for returned resources of type appPricePoints */
        "fields[appPricePoints]"?: ("app" | "customerPrice" | "equalizations" | "proceeds" | "territory")[];
        /** the fields to include for returned resources of type territories */
        "fields[territories]"?: "currency"[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /** comma-separated list of relationships to include */
        include?: ("appPricePoint" | "territory")[];
      },
      params: RequestParams = {},
    ): Promise<AppPricesV2Response> =>
      this.request<AppPricesV2Response, ErrorResponse>({
        path: `/v1/appPriceSchedules/${id}/manualPrices`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  appPriceTiers = {
    /**
     * No description
     *
     * @tags AppPriceTiers
     * @name AppPriceTiersGetCollection
     * @request GET:/v1/appPriceTiers
     * @deprecated
     * @secure
     */
    getCollection: (
      query?: {
        /** filter by id(s) */
        "filter[id]"?: string[];
        /** the fields to include for returned resources of type appPriceTiers */
        "fields[appPriceTiers]"?: "pricePoints"[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /** comma-separated list of relationships to include */
        include?: "pricePoints"[];
        /**
         * the fields to include for returned resources of type appPricePoints
         * @deprecated
         */
        "fields[appPricePoints]"?: ("customerPrice" | "priceTier" | "proceeds" | "territory")[];
        /**
         * maximum number of related pricePoints returned (when they are included)
         * @deprecated
         * @max 50
         */
        "limit[pricePoints]"?: number;
      },
      params: RequestParams = {},
    ): Promise<AppPriceTiersResponse> =>
      this.request<AppPriceTiersResponse, ErrorResponse>({
        path: `/v1/appPriceTiers`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppPriceTiers
     * @name AppPriceTiersGetInstance
     * @request GET:/v1/appPriceTiers/{id}
     * @deprecated
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type appPriceTiers */
        "fields[appPriceTiers]"?: "pricePoints"[];
        /** comma-separated list of relationships to include */
        include?: "pricePoints"[];
        /**
         * the fields to include for returned resources of type appPricePoints
         * @deprecated
         */
        "fields[appPricePoints]"?: ("customerPrice" | "priceTier" | "proceeds" | "territory")[];
        /**
         * maximum number of related pricePoints returned (when they are included)
         * @deprecated
         * @max 50
         */
        "limit[pricePoints]"?: number;
      },
      params: RequestParams = {},
    ): Promise<AppPriceTierResponse> =>
      this.request<AppPriceTierResponse, ErrorResponse>({
        path: `/v1/appPriceTiers/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppPriceTiers
     * @name AppPriceTiersPricePointsGetToManyRelated
     * @request GET:/v1/appPriceTiers/{id}/pricePoints
     * @deprecated
     * @secure
     */
    pricePointsGetToManyRelated: (
      id: string,
      query?: {
        /** filter by id(s) of related 'territory' */
        "filter[territory]"?: string[];
        /** the fields to include for returned resources of type appPriceTiers */
        "fields[appPriceTiers]"?: "pricePoints"[];
        /** the fields to include for returned resources of type appPricePoints */
        "fields[appPricePoints]"?: ("customerPrice" | "priceTier" | "proceeds" | "territory")[];
        /** the fields to include for returned resources of type territories */
        "fields[territories]"?: "currency"[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /** comma-separated list of relationships to include */
        include?: ("priceTier" | "territory")[];
      },
      params: RequestParams = {},
    ): Promise<AppPricePointsResponse> =>
      this.request<AppPricePointsResponse, ErrorResponse>({
        path: `/v1/appPriceTiers/${id}/pricePoints`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  appPrices = {
    /**
     * No description
     *
     * @tags AppPrices
     * @name AppPricesGetInstance
     * @request GET:/v1/appPrices/{id}
     * @deprecated
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type appPrices */
        "fields[appPrices]"?: ("app" | "priceTier")[];
        /** comma-separated list of relationships to include */
        include?: ("app" | "priceTier")[];
      },
      params: RequestParams = {},
    ): Promise<AppPriceResponse> =>
      this.request<AppPriceResponse, ErrorResponse>({
        path: `/v1/appPrices/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  appScreenshotSets = {
    /**
     * No description
     *
     * @tags AppScreenshotSets
     * @name AppScreenshotSetsCreateInstance
     * @request POST:/v1/appScreenshotSets
     * @secure
     */
    createInstance: (
      data: AppScreenshotSetCreateRequest,
      params: RequestParams = {},
    ): Promise<AppScreenshotSetResponse> =>
      this.request<AppScreenshotSetResponse, ErrorResponse>({
        path: `/v1/appScreenshotSets`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppScreenshotSets
     * @name AppScreenshotSetsGetInstance
     * @request GET:/v1/appScreenshotSets/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type appScreenshotSets */
        "fields[appScreenshotSets]"?: (
          | "appCustomProductPageLocalization"
          | "appScreenshots"
          | "appStoreVersionExperimentTreatmentLocalization"
          | "appStoreVersionLocalization"
          | "screenshotDisplayType"
        )[];
        /** comma-separated list of relationships to include */
        include?: (
          | "appCustomProductPageLocalization"
          | "appScreenshots"
          | "appStoreVersionExperimentTreatmentLocalization"
          | "appStoreVersionLocalization"
        )[];
        /** the fields to include for returned resources of type appScreenshots */
        "fields[appScreenshots]"?: (
          | "appScreenshotSet"
          | "assetDeliveryState"
          | "assetToken"
          | "assetType"
          | "fileName"
          | "fileSize"
          | "imageAsset"
          | "sourceFileChecksum"
          | "uploadOperations"
          | "uploaded"
        )[];
        /**
         * maximum number of related appScreenshots returned (when they are included)
         * @max 50
         */
        "limit[appScreenshots]"?: number;
      },
      params: RequestParams = {},
    ): Promise<AppScreenshotSetResponse> =>
      this.request<AppScreenshotSetResponse, ErrorResponse>({
        path: `/v1/appScreenshotSets/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppScreenshotSets
     * @name AppScreenshotSetsDeleteInstance
     * @request DELETE:/v1/appScreenshotSets/{id}
     * @secure
     */
    deleteInstance: (id: string, params: RequestParams = {}): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/appScreenshotSets/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppScreenshotSets
     * @name AppScreenshotSetsAppScreenshotsGetToManyRelationship
     * @request GET:/v1/appScreenshotSets/{id}/relationships/appScreenshots
     * @secure
     */
    appScreenshotsGetToManyRelationship: (
      id: string,
      query?: {
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
      },
      params: RequestParams = {},
    ): Promise<AppScreenshotSetAppScreenshotsLinkagesResponse> =>
      this.request<AppScreenshotSetAppScreenshotsLinkagesResponse, ErrorResponse>({
        path: `/v1/appScreenshotSets/${id}/relationships/appScreenshots`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppScreenshotSets
     * @name AppScreenshotSetsAppScreenshotsReplaceToManyRelationship
     * @request PATCH:/v1/appScreenshotSets/{id}/relationships/appScreenshots
     * @secure
     */
    appScreenshotsReplaceToManyRelationship: (
      id: string,
      data: AppScreenshotSetAppScreenshotsLinkagesRequest,
      params: RequestParams = {},
    ): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/appScreenshotSets/${id}/relationships/appScreenshots`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppScreenshotSets
     * @name AppScreenshotSetsAppScreenshotsGetToManyRelated
     * @request GET:/v1/appScreenshotSets/{id}/appScreenshots
     * @secure
     */
    appScreenshotsGetToManyRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type appScreenshotSets */
        "fields[appScreenshotSets]"?: (
          | "appCustomProductPageLocalization"
          | "appScreenshots"
          | "appStoreVersionExperimentTreatmentLocalization"
          | "appStoreVersionLocalization"
          | "screenshotDisplayType"
        )[];
        /** the fields to include for returned resources of type appScreenshots */
        "fields[appScreenshots]"?: (
          | "appScreenshotSet"
          | "assetDeliveryState"
          | "assetToken"
          | "assetType"
          | "fileName"
          | "fileSize"
          | "imageAsset"
          | "sourceFileChecksum"
          | "uploadOperations"
          | "uploaded"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /** comma-separated list of relationships to include */
        include?: "appScreenshotSet"[];
      },
      params: RequestParams = {},
    ): Promise<AppScreenshotsResponse> =>
      this.request<AppScreenshotsResponse, ErrorResponse>({
        path: `/v1/appScreenshotSets/${id}/appScreenshots`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  appScreenshots = {
    /**
     * No description
     *
     * @tags AppScreenshots
     * @name AppScreenshotsCreateInstance
     * @request POST:/v1/appScreenshots
     * @secure
     */
    createInstance: (data: AppScreenshotCreateRequest, params: RequestParams = {}): Promise<AppScreenshotResponse> =>
      this.request<AppScreenshotResponse, ErrorResponse>({
        path: `/v1/appScreenshots`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppScreenshots
     * @name AppScreenshotsGetInstance
     * @request GET:/v1/appScreenshots/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type appScreenshots */
        "fields[appScreenshots]"?: (
          | "appScreenshotSet"
          | "assetDeliveryState"
          | "assetToken"
          | "assetType"
          | "fileName"
          | "fileSize"
          | "imageAsset"
          | "sourceFileChecksum"
          | "uploadOperations"
          | "uploaded"
        )[];
        /** comma-separated list of relationships to include */
        include?: "appScreenshotSet"[];
      },
      params: RequestParams = {},
    ): Promise<AppScreenshotResponse> =>
      this.request<AppScreenshotResponse, ErrorResponse>({
        path: `/v1/appScreenshots/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppScreenshots
     * @name AppScreenshotsUpdateInstance
     * @request PATCH:/v1/appScreenshots/{id}
     * @secure
     */
    updateInstance: (
      id: string,
      data: AppScreenshotUpdateRequest,
      params: RequestParams = {},
    ): Promise<AppScreenshotResponse> =>
      this.request<AppScreenshotResponse, ErrorResponse>({
        path: `/v1/appScreenshots/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppScreenshots
     * @name AppScreenshotsDeleteInstance
     * @request DELETE:/v1/appScreenshots/{id}
     * @secure
     */
    deleteInstance: (id: string, params: RequestParams = {}): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/appScreenshots/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),
  };
  appStoreReviewAttachments = {
    /**
     * No description
     *
     * @tags AppStoreReviewAttachments
     * @name AppStoreReviewAttachmentsCreateInstance
     * @request POST:/v1/appStoreReviewAttachments
     * @secure
     */
    createInstance: (
      data: AppStoreReviewAttachmentCreateRequest,
      params: RequestParams = {},
    ): Promise<AppStoreReviewAttachmentResponse> =>
      this.request<AppStoreReviewAttachmentResponse, ErrorResponse>({
        path: `/v1/appStoreReviewAttachments`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppStoreReviewAttachments
     * @name AppStoreReviewAttachmentsGetInstance
     * @request GET:/v1/appStoreReviewAttachments/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type appStoreReviewAttachments */
        "fields[appStoreReviewAttachments]"?: (
          | "appStoreReviewDetail"
          | "assetDeliveryState"
          | "fileName"
          | "fileSize"
          | "sourceFileChecksum"
          | "uploadOperations"
          | "uploaded"
        )[];
        /** comma-separated list of relationships to include */
        include?: "appStoreReviewDetail"[];
      },
      params: RequestParams = {},
    ): Promise<AppStoreReviewAttachmentResponse> =>
      this.request<AppStoreReviewAttachmentResponse, ErrorResponse>({
        path: `/v1/appStoreReviewAttachments/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppStoreReviewAttachments
     * @name AppStoreReviewAttachmentsUpdateInstance
     * @request PATCH:/v1/appStoreReviewAttachments/{id}
     * @secure
     */
    updateInstance: (
      id: string,
      data: AppStoreReviewAttachmentUpdateRequest,
      params: RequestParams = {},
    ): Promise<AppStoreReviewAttachmentResponse> =>
      this.request<AppStoreReviewAttachmentResponse, ErrorResponse>({
        path: `/v1/appStoreReviewAttachments/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppStoreReviewAttachments
     * @name AppStoreReviewAttachmentsDeleteInstance
     * @request DELETE:/v1/appStoreReviewAttachments/{id}
     * @secure
     */
    deleteInstance: (id: string, params: RequestParams = {}): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/appStoreReviewAttachments/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),
  };
  appStoreReviewDetails = {
    /**
     * No description
     *
     * @tags AppStoreReviewDetails
     * @name AppStoreReviewDetailsCreateInstance
     * @request POST:/v1/appStoreReviewDetails
     * @secure
     */
    createInstance: (
      data: AppStoreReviewDetailCreateRequest,
      params: RequestParams = {},
    ): Promise<AppStoreReviewDetailResponse> =>
      this.request<AppStoreReviewDetailResponse, ErrorResponse>({
        path: `/v1/appStoreReviewDetails`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppStoreReviewDetails
     * @name AppStoreReviewDetailsGetInstance
     * @request GET:/v1/appStoreReviewDetails/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type appStoreReviewDetails */
        "fields[appStoreReviewDetails]"?: (
          | "appStoreReviewAttachments"
          | "appStoreVersion"
          | "contactEmail"
          | "contactFirstName"
          | "contactLastName"
          | "contactPhone"
          | "demoAccountName"
          | "demoAccountPassword"
          | "demoAccountRequired"
          | "notes"
        )[];
        /** comma-separated list of relationships to include */
        include?: ("appStoreReviewAttachments" | "appStoreVersion")[];
        /** the fields to include for returned resources of type appStoreReviewAttachments */
        "fields[appStoreReviewAttachments]"?: (
          | "appStoreReviewDetail"
          | "assetDeliveryState"
          | "fileName"
          | "fileSize"
          | "sourceFileChecksum"
          | "uploadOperations"
          | "uploaded"
        )[];
        /**
         * maximum number of related appStoreReviewAttachments returned (when they are included)
         * @max 50
         */
        "limit[appStoreReviewAttachments]"?: number;
      },
      params: RequestParams = {},
    ): Promise<AppStoreReviewDetailResponse> =>
      this.request<AppStoreReviewDetailResponse, ErrorResponse>({
        path: `/v1/appStoreReviewDetails/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppStoreReviewDetails
     * @name AppStoreReviewDetailsUpdateInstance
     * @request PATCH:/v1/appStoreReviewDetails/{id}
     * @secure
     */
    updateInstance: (
      id: string,
      data: AppStoreReviewDetailUpdateRequest,
      params: RequestParams = {},
    ): Promise<AppStoreReviewDetailResponse> =>
      this.request<AppStoreReviewDetailResponse, ErrorResponse>({
        path: `/v1/appStoreReviewDetails/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppStoreReviewDetails
     * @name AppStoreReviewDetailsAppStoreReviewAttachmentsGetToManyRelated
     * @request GET:/v1/appStoreReviewDetails/{id}/appStoreReviewAttachments
     * @secure
     */
    appStoreReviewAttachmentsGetToManyRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type appStoreReviewDetails */
        "fields[appStoreReviewDetails]"?: (
          | "appStoreReviewAttachments"
          | "appStoreVersion"
          | "contactEmail"
          | "contactFirstName"
          | "contactLastName"
          | "contactPhone"
          | "demoAccountName"
          | "demoAccountPassword"
          | "demoAccountRequired"
          | "notes"
        )[];
        /** the fields to include for returned resources of type appStoreReviewAttachments */
        "fields[appStoreReviewAttachments]"?: (
          | "appStoreReviewDetail"
          | "assetDeliveryState"
          | "fileName"
          | "fileSize"
          | "sourceFileChecksum"
          | "uploadOperations"
          | "uploaded"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /** comma-separated list of relationships to include */
        include?: "appStoreReviewDetail"[];
      },
      params: RequestParams = {},
    ): Promise<AppStoreReviewAttachmentsResponse> =>
      this.request<AppStoreReviewAttachmentsResponse, ErrorResponse>({
        path: `/v1/appStoreReviewDetails/${id}/appStoreReviewAttachments`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  appStoreVersionExperimentTreatmentLocalizations = {
    /**
     * No description
     *
     * @tags AppStoreVersionExperimentTreatmentLocalizations
     * @name AppStoreVersionExperimentTreatmentLocalizationsCreateInstance
     * @request POST:/v1/appStoreVersionExperimentTreatmentLocalizations
     * @secure
     */
    createInstance: (
      data: AppStoreVersionExperimentTreatmentLocalizationCreateRequest,
      params: RequestParams = {},
    ): Promise<AppStoreVersionExperimentTreatmentLocalizationResponse> =>
      this.request<AppStoreVersionExperimentTreatmentLocalizationResponse, ErrorResponse>({
        path: `/v1/appStoreVersionExperimentTreatmentLocalizations`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppStoreVersionExperimentTreatmentLocalizations
     * @name AppStoreVersionExperimentTreatmentLocalizationsGetInstance
     * @request GET:/v1/appStoreVersionExperimentTreatmentLocalizations/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type appStoreVersionExperimentTreatmentLocalizations */
        "fields[appStoreVersionExperimentTreatmentLocalizations]"?: (
          | "appPreviewSets"
          | "appScreenshotSets"
          | "appStoreVersionExperimentTreatment"
          | "locale"
        )[];
        /** comma-separated list of relationships to include */
        include?: ("appPreviewSets" | "appScreenshotSets" | "appStoreVersionExperimentTreatment")[];
        /** the fields to include for returned resources of type appScreenshotSets */
        "fields[appScreenshotSets]"?: (
          | "appCustomProductPageLocalization"
          | "appScreenshots"
          | "appStoreVersionExperimentTreatmentLocalization"
          | "appStoreVersionLocalization"
          | "screenshotDisplayType"
        )[];
        /** the fields to include for returned resources of type appPreviewSets */
        "fields[appPreviewSets]"?: (
          | "appCustomProductPageLocalization"
          | "appPreviews"
          | "appStoreVersionExperimentTreatmentLocalization"
          | "appStoreVersionLocalization"
          | "previewType"
        )[];
        /**
         * maximum number of related appPreviewSets returned (when they are included)
         * @max 50
         */
        "limit[appPreviewSets]"?: number;
        /**
         * maximum number of related appScreenshotSets returned (when they are included)
         * @max 50
         */
        "limit[appScreenshotSets]"?: number;
      },
      params: RequestParams = {},
    ): Promise<AppStoreVersionExperimentTreatmentLocalizationResponse> =>
      this.request<AppStoreVersionExperimentTreatmentLocalizationResponse, ErrorResponse>({
        path: `/v1/appStoreVersionExperimentTreatmentLocalizations/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppStoreVersionExperimentTreatmentLocalizations
     * @name AppStoreVersionExperimentTreatmentLocalizationsDeleteInstance
     * @request DELETE:/v1/appStoreVersionExperimentTreatmentLocalizations/{id}
     * @secure
     */
    deleteInstance: (id: string, params: RequestParams = {}): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/appStoreVersionExperimentTreatmentLocalizations/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppStoreVersionExperimentTreatmentLocalizations
     * @name AppStoreVersionExperimentTreatmentLocalizationsAppPreviewSetsGetToManyRelated
     * @request GET:/v1/appStoreVersionExperimentTreatmentLocalizations/{id}/appPreviewSets
     * @secure
     */
    appPreviewSetsGetToManyRelated: (
      id: string,
      query?: {
        /** filter by attribute 'previewType' */
        "filter[previewType]"?: (
          | "IPHONE_67"
          | "IPHONE_61"
          | "IPHONE_65"
          | "IPHONE_58"
          | "IPHONE_55"
          | "IPHONE_47"
          | "IPHONE_40"
          | "IPHONE_35"
          | "IPAD_PRO_3GEN_129"
          | "IPAD_PRO_3GEN_11"
          | "IPAD_PRO_129"
          | "IPAD_105"
          | "IPAD_97"
          | "DESKTOP"
          | "APPLE_TV"
          | "APPLE_VISION_PRO"
        )[];
        /** filter by id(s) of related 'appCustomProductPageLocalization' */
        "filter[appCustomProductPageLocalization]"?: string[];
        /** filter by id(s) of related 'appStoreVersionLocalization' */
        "filter[appStoreVersionLocalization]"?: string[];
        /** the fields to include for returned resources of type appCustomProductPageLocalizations */
        "fields[appCustomProductPageLocalizations]"?: (
          | "appCustomProductPageVersion"
          | "appPreviewSets"
          | "appScreenshotSets"
          | "locale"
          | "promotionalText"
        )[];
        /** the fields to include for returned resources of type appStoreVersionExperimentTreatmentLocalizations */
        "fields[appStoreVersionExperimentTreatmentLocalizations]"?: (
          | "appPreviewSets"
          | "appScreenshotSets"
          | "appStoreVersionExperimentTreatment"
          | "locale"
        )[];
        /** the fields to include for returned resources of type appPreviews */
        "fields[appPreviews]"?: (
          | "appPreviewSet"
          | "assetDeliveryState"
          | "fileName"
          | "fileSize"
          | "mimeType"
          | "previewFrameTimeCode"
          | "previewImage"
          | "sourceFileChecksum"
          | "uploadOperations"
          | "uploaded"
          | "videoUrl"
        )[];
        /** the fields to include for returned resources of type appPreviewSets */
        "fields[appPreviewSets]"?: (
          | "appCustomProductPageLocalization"
          | "appPreviews"
          | "appStoreVersionExperimentTreatmentLocalization"
          | "appStoreVersionLocalization"
          | "previewType"
        )[];
        /** the fields to include for returned resources of type appStoreVersionLocalizations */
        "fields[appStoreVersionLocalizations]"?: (
          | "appPreviewSets"
          | "appScreenshotSets"
          | "appStoreVersion"
          | "description"
          | "keywords"
          | "locale"
          | "marketingUrl"
          | "promotionalText"
          | "supportUrl"
          | "whatsNew"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /**
         * maximum number of related appPreviews returned (when they are included)
         * @max 50
         */
        "limit[appPreviews]"?: number;
        /** comma-separated list of relationships to include */
        include?: (
          | "appCustomProductPageLocalization"
          | "appPreviews"
          | "appStoreVersionExperimentTreatmentLocalization"
          | "appStoreVersionLocalization"
        )[];
      },
      params: RequestParams = {},
    ): Promise<AppPreviewSetsResponse> =>
      this.request<AppPreviewSetsResponse, ErrorResponse>({
        path: `/v1/appStoreVersionExperimentTreatmentLocalizations/${id}/appPreviewSets`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppStoreVersionExperimentTreatmentLocalizations
     * @name AppStoreVersionExperimentTreatmentLocalizationsAppScreenshotSetsGetToManyRelated
     * @request GET:/v1/appStoreVersionExperimentTreatmentLocalizations/{id}/appScreenshotSets
     * @secure
     */
    appScreenshotSetsGetToManyRelated: (
      id: string,
      query?: {
        /** filter by attribute 'screenshotDisplayType' */
        "filter[screenshotDisplayType]"?: (
          | "APP_IPHONE_67"
          | "APP_IPHONE_61"
          | "APP_IPHONE_65"
          | "APP_IPHONE_58"
          | "APP_IPHONE_55"
          | "APP_IPHONE_47"
          | "APP_IPHONE_40"
          | "APP_IPHONE_35"
          | "APP_IPAD_PRO_3GEN_129"
          | "APP_IPAD_PRO_3GEN_11"
          | "APP_IPAD_PRO_129"
          | "APP_IPAD_105"
          | "APP_IPAD_97"
          | "APP_DESKTOP"
          | "APP_WATCH_ULTRA"
          | "APP_WATCH_SERIES_7"
          | "APP_WATCH_SERIES_4"
          | "APP_WATCH_SERIES_3"
          | "APP_APPLE_TV"
          | "APP_APPLE_VISION_PRO"
          | "IMESSAGE_APP_IPHONE_67"
          | "IMESSAGE_APP_IPHONE_61"
          | "IMESSAGE_APP_IPHONE_65"
          | "IMESSAGE_APP_IPHONE_58"
          | "IMESSAGE_APP_IPHONE_55"
          | "IMESSAGE_APP_IPHONE_47"
          | "IMESSAGE_APP_IPHONE_40"
          | "IMESSAGE_APP_IPAD_PRO_3GEN_129"
          | "IMESSAGE_APP_IPAD_PRO_3GEN_11"
          | "IMESSAGE_APP_IPAD_PRO_129"
          | "IMESSAGE_APP_IPAD_105"
          | "IMESSAGE_APP_IPAD_97"
        )[];
        /** filter by id(s) of related 'appCustomProductPageLocalization' */
        "filter[appCustomProductPageLocalization]"?: string[];
        /** filter by id(s) of related 'appStoreVersionLocalization' */
        "filter[appStoreVersionLocalization]"?: string[];
        /** the fields to include for returned resources of type appScreenshotSets */
        "fields[appScreenshotSets]"?: (
          | "appCustomProductPageLocalization"
          | "appScreenshots"
          | "appStoreVersionExperimentTreatmentLocalization"
          | "appStoreVersionLocalization"
          | "screenshotDisplayType"
        )[];
        /** the fields to include for returned resources of type appCustomProductPageLocalizations */
        "fields[appCustomProductPageLocalizations]"?: (
          | "appCustomProductPageVersion"
          | "appPreviewSets"
          | "appScreenshotSets"
          | "locale"
          | "promotionalText"
        )[];
        /** the fields to include for returned resources of type appStoreVersionExperimentTreatmentLocalizations */
        "fields[appStoreVersionExperimentTreatmentLocalizations]"?: (
          | "appPreviewSets"
          | "appScreenshotSets"
          | "appStoreVersionExperimentTreatment"
          | "locale"
        )[];
        /** the fields to include for returned resources of type appScreenshots */
        "fields[appScreenshots]"?: (
          | "appScreenshotSet"
          | "assetDeliveryState"
          | "assetToken"
          | "assetType"
          | "fileName"
          | "fileSize"
          | "imageAsset"
          | "sourceFileChecksum"
          | "uploadOperations"
          | "uploaded"
        )[];
        /** the fields to include for returned resources of type appStoreVersionLocalizations */
        "fields[appStoreVersionLocalizations]"?: (
          | "appPreviewSets"
          | "appScreenshotSets"
          | "appStoreVersion"
          | "description"
          | "keywords"
          | "locale"
          | "marketingUrl"
          | "promotionalText"
          | "supportUrl"
          | "whatsNew"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /**
         * maximum number of related appScreenshots returned (when they are included)
         * @max 50
         */
        "limit[appScreenshots]"?: number;
        /** comma-separated list of relationships to include */
        include?: (
          | "appCustomProductPageLocalization"
          | "appScreenshots"
          | "appStoreVersionExperimentTreatmentLocalization"
          | "appStoreVersionLocalization"
        )[];
      },
      params: RequestParams = {},
    ): Promise<AppScreenshotSetsResponse> =>
      this.request<AppScreenshotSetsResponse, ErrorResponse>({
        path: `/v1/appStoreVersionExperimentTreatmentLocalizations/${id}/appScreenshotSets`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  appStoreVersionExperimentTreatments = {
    /**
     * No description
     *
     * @tags AppStoreVersionExperimentTreatments
     * @name AppStoreVersionExperimentTreatmentsCreateInstance
     * @request POST:/v1/appStoreVersionExperimentTreatments
     * @secure
     */
    createInstance: (
      data: AppStoreVersionExperimentTreatmentCreateRequest,
      params: RequestParams = {},
    ): Promise<AppStoreVersionExperimentTreatmentResponse> =>
      this.request<AppStoreVersionExperimentTreatmentResponse, ErrorResponse>({
        path: `/v1/appStoreVersionExperimentTreatments`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppStoreVersionExperimentTreatments
     * @name AppStoreVersionExperimentTreatmentsGetInstance
     * @request GET:/v1/appStoreVersionExperimentTreatments/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type appStoreVersionExperimentTreatments */
        "fields[appStoreVersionExperimentTreatments]"?: (
          | "appIcon"
          | "appIconName"
          | "appStoreVersionExperiment"
          | "appStoreVersionExperimentTreatmentLocalizations"
          | "appStoreVersionExperimentV2"
          | "name"
          | "promotedDate"
        )[];
        /** comma-separated list of relationships to include */
        include?: (
          | "appStoreVersionExperiment"
          | "appStoreVersionExperimentTreatmentLocalizations"
          | "appStoreVersionExperimentV2"
        )[];
        /** the fields to include for returned resources of type appStoreVersionExperimentTreatmentLocalizations */
        "fields[appStoreVersionExperimentTreatmentLocalizations]"?: (
          | "appPreviewSets"
          | "appScreenshotSets"
          | "appStoreVersionExperimentTreatment"
          | "locale"
        )[];
        /**
         * maximum number of related appStoreVersionExperimentTreatmentLocalizations returned (when they are included)
         * @max 50
         */
        "limit[appStoreVersionExperimentTreatmentLocalizations]"?: number;
      },
      params: RequestParams = {},
    ): Promise<AppStoreVersionExperimentTreatmentResponse> =>
      this.request<AppStoreVersionExperimentTreatmentResponse, ErrorResponse>({
        path: `/v1/appStoreVersionExperimentTreatments/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppStoreVersionExperimentTreatments
     * @name AppStoreVersionExperimentTreatmentsUpdateInstance
     * @request PATCH:/v1/appStoreVersionExperimentTreatments/{id}
     * @secure
     */
    updateInstance: (
      id: string,
      data: AppStoreVersionExperimentTreatmentUpdateRequest,
      params: RequestParams = {},
    ): Promise<AppStoreVersionExperimentTreatmentResponse> =>
      this.request<AppStoreVersionExperimentTreatmentResponse, ErrorResponse>({
        path: `/v1/appStoreVersionExperimentTreatments/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppStoreVersionExperimentTreatments
     * @name AppStoreVersionExperimentTreatmentsDeleteInstance
     * @request DELETE:/v1/appStoreVersionExperimentTreatments/{id}
     * @secure
     */
    deleteInstance: (id: string, params: RequestParams = {}): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/appStoreVersionExperimentTreatments/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppStoreVersionExperimentTreatments
     * @name AppStoreVersionExperimentTreatmentsAppStoreVersionExperimentTreatmentLocalizationsGetToManyRelated
     * @request GET:/v1/appStoreVersionExperimentTreatments/{id}/appStoreVersionExperimentTreatmentLocalizations
     * @secure
     */
    appStoreVersionExperimentTreatmentLocalizationsGetToManyRelated: (
      id: string,
      query?: {
        /** filter by attribute 'locale' */
        "filter[locale]"?: string[];
        /** the fields to include for returned resources of type appScreenshotSets */
        "fields[appScreenshotSets]"?: (
          | "appCustomProductPageLocalization"
          | "appScreenshots"
          | "appStoreVersionExperimentTreatmentLocalization"
          | "appStoreVersionLocalization"
          | "screenshotDisplayType"
        )[];
        /** the fields to include for returned resources of type appStoreVersionExperimentTreatments */
        "fields[appStoreVersionExperimentTreatments]"?: (
          | "appIcon"
          | "appIconName"
          | "appStoreVersionExperiment"
          | "appStoreVersionExperimentTreatmentLocalizations"
          | "appStoreVersionExperimentV2"
          | "name"
          | "promotedDate"
        )[];
        /** the fields to include for returned resources of type appStoreVersionExperimentTreatmentLocalizations */
        "fields[appStoreVersionExperimentTreatmentLocalizations]"?: (
          | "appPreviewSets"
          | "appScreenshotSets"
          | "appStoreVersionExperimentTreatment"
          | "locale"
        )[];
        /** the fields to include for returned resources of type appPreviewSets */
        "fields[appPreviewSets]"?: (
          | "appCustomProductPageLocalization"
          | "appPreviews"
          | "appStoreVersionExperimentTreatmentLocalization"
          | "appStoreVersionLocalization"
          | "previewType"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /**
         * maximum number of related appScreenshotSets returned (when they are included)
         * @max 50
         */
        "limit[appScreenshotSets]"?: number;
        /**
         * maximum number of related appPreviewSets returned (when they are included)
         * @max 50
         */
        "limit[appPreviewSets]"?: number;
        /** comma-separated list of relationships to include */
        include?: ("appPreviewSets" | "appScreenshotSets" | "appStoreVersionExperimentTreatment")[];
      },
      params: RequestParams = {},
    ): Promise<AppStoreVersionExperimentTreatmentLocalizationsResponse> =>
      this.request<AppStoreVersionExperimentTreatmentLocalizationsResponse, ErrorResponse>({
        path: `/v1/appStoreVersionExperimentTreatments/${id}/appStoreVersionExperimentTreatmentLocalizations`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  appStoreVersionExperiments = {
    /**
     * No description
     *
     * @tags AppStoreVersionExperiments
     * @name AppStoreVersionExperimentsV2CreateInstance
     * @request POST:/v2/appStoreVersionExperiments
     * @secure
     */
    v2CreateInstance: (
      data: AppStoreVersionExperimentV2CreateRequest,
      params: RequestParams = {},
    ): Promise<AppStoreVersionExperimentV2Response> =>
      this.request<AppStoreVersionExperimentV2Response, ErrorResponse>({
        path: `/v2/appStoreVersionExperiments`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppStoreVersionExperiments
     * @name AppStoreVersionExperimentsV2GetInstance
     * @request GET:/v2/appStoreVersionExperiments/{id}
     * @secure
     */
    v2GetInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type appStoreVersionExperiments */
        "fields[appStoreVersionExperiments]"?: (
          | "app"
          | "appStoreVersionExperimentTreatments"
          | "controlVersions"
          | "endDate"
          | "latestControlVersion"
          | "name"
          | "platform"
          | "reviewRequired"
          | "startDate"
          | "started"
          | "state"
          | "trafficProportion"
        )[];
        /** comma-separated list of relationships to include */
        include?: ("app" | "appStoreVersionExperimentTreatments" | "controlVersions" | "latestControlVersion")[];
        /** the fields to include for returned resources of type appStoreVersionExperimentTreatments */
        "fields[appStoreVersionExperimentTreatments]"?: (
          | "appIcon"
          | "appIconName"
          | "appStoreVersionExperiment"
          | "appStoreVersionExperimentTreatmentLocalizations"
          | "appStoreVersionExperimentV2"
          | "name"
          | "promotedDate"
        )[];
        /**
         * maximum number of related appStoreVersionExperimentTreatments returned (when they are included)
         * @max 50
         */
        "limit[appStoreVersionExperimentTreatments]"?: number;
        /**
         * maximum number of related controlVersions returned (when they are included)
         * @max 50
         */
        "limit[controlVersions]"?: number;
      },
      params: RequestParams = {},
    ): Promise<AppStoreVersionExperimentV2Response> =>
      this.request<AppStoreVersionExperimentV2Response, ErrorResponse>({
        path: `/v2/appStoreVersionExperiments/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppStoreVersionExperiments
     * @name AppStoreVersionExperimentsV2UpdateInstance
     * @request PATCH:/v2/appStoreVersionExperiments/{id}
     * @secure
     */
    v2UpdateInstance: (
      id: string,
      data: AppStoreVersionExperimentV2UpdateRequest,
      params: RequestParams = {},
    ): Promise<AppStoreVersionExperimentV2Response> =>
      this.request<AppStoreVersionExperimentV2Response, ErrorResponse>({
        path: `/v2/appStoreVersionExperiments/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppStoreVersionExperiments
     * @name AppStoreVersionExperimentsV2DeleteInstance
     * @request DELETE:/v2/appStoreVersionExperiments/{id}
     * @secure
     */
    v2DeleteInstance: (id: string, params: RequestParams = {}): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v2/appStoreVersionExperiments/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppStoreVersionExperiments
     * @name AppStoreVersionExperimentsCreateInstance
     * @request POST:/v1/appStoreVersionExperiments
     * @deprecated
     * @secure
     */
    createInstance: (
      data: AppStoreVersionExperimentCreateRequest,
      params: RequestParams = {},
    ): Promise<AppStoreVersionExperimentResponse> =>
      this.request<AppStoreVersionExperimentResponse, ErrorResponse>({
        path: `/v1/appStoreVersionExperiments`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppStoreVersionExperiments
     * @name AppStoreVersionExperimentsGetInstance
     * @request GET:/v1/appStoreVersionExperiments/{id}
     * @deprecated
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type appStoreVersionExperiments */
        "fields[appStoreVersionExperiments]"?: (
          | "appStoreVersion"
          | "appStoreVersionExperimentTreatments"
          | "endDate"
          | "name"
          | "reviewRequired"
          | "startDate"
          | "started"
          | "state"
          | "trafficProportion"
        )[];
        /** comma-separated list of relationships to include */
        include?: ("appStoreVersion" | "appStoreVersionExperimentTreatments")[];
        /** the fields to include for returned resources of type appStoreVersionExperimentTreatments */
        "fields[appStoreVersionExperimentTreatments]"?: (
          | "appIcon"
          | "appIconName"
          | "appStoreVersionExperiment"
          | "appStoreVersionExperimentTreatmentLocalizations"
          | "appStoreVersionExperimentV2"
          | "name"
          | "promotedDate"
        )[];
        /**
         * maximum number of related appStoreVersionExperimentTreatments returned (when they are included)
         * @max 50
         */
        "limit[appStoreVersionExperimentTreatments]"?: number;
      },
      params: RequestParams = {},
    ): Promise<AppStoreVersionExperimentResponse> =>
      this.request<AppStoreVersionExperimentResponse, ErrorResponse>({
        path: `/v1/appStoreVersionExperiments/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppStoreVersionExperiments
     * @name AppStoreVersionExperimentsUpdateInstance
     * @request PATCH:/v1/appStoreVersionExperiments/{id}
     * @deprecated
     * @secure
     */
    updateInstance: (
      id: string,
      data: AppStoreVersionExperimentUpdateRequest,
      params: RequestParams = {},
    ): Promise<AppStoreVersionExperimentResponse> =>
      this.request<AppStoreVersionExperimentResponse, ErrorResponse>({
        path: `/v1/appStoreVersionExperiments/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppStoreVersionExperiments
     * @name AppStoreVersionExperimentsDeleteInstance
     * @request DELETE:/v1/appStoreVersionExperiments/{id}
     * @deprecated
     * @secure
     */
    deleteInstance: (id: string, params: RequestParams = {}): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/appStoreVersionExperiments/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppStoreVersionExperiments
     * @name AppStoreVersionExperimentsV2AppStoreVersionExperimentTreatmentsGetToManyRelated
     * @request GET:/v2/appStoreVersionExperiments/{id}/appStoreVersionExperimentTreatments
     * @secure
     */
    v2AppStoreVersionExperimentTreatmentsGetToManyRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type appStoreVersionExperiments */
        "fields[appStoreVersionExperiments]"?: (
          | "app"
          | "appStoreVersion"
          | "appStoreVersionExperimentTreatments"
          | "controlVersions"
          | "endDate"
          | "latestControlVersion"
          | "name"
          | "platform"
          | "reviewRequired"
          | "startDate"
          | "started"
          | "state"
          | "trafficProportion"
        )[];
        /** the fields to include for returned resources of type appStoreVersionExperimentTreatments */
        "fields[appStoreVersionExperimentTreatments]"?: (
          | "appIcon"
          | "appIconName"
          | "appStoreVersionExperiment"
          | "appStoreVersionExperimentTreatmentLocalizations"
          | "appStoreVersionExperimentV2"
          | "name"
          | "promotedDate"
        )[];
        /** the fields to include for returned resources of type appStoreVersionExperimentTreatmentLocalizations */
        "fields[appStoreVersionExperimentTreatmentLocalizations]"?: (
          | "appPreviewSets"
          | "appScreenshotSets"
          | "appStoreVersionExperimentTreatment"
          | "locale"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /**
         * maximum number of related appStoreVersionExperimentTreatmentLocalizations returned (when they are included)
         * @max 50
         */
        "limit[appStoreVersionExperimentTreatmentLocalizations]"?: number;
        /** comma-separated list of relationships to include */
        include?: (
          | "appStoreVersionExperiment"
          | "appStoreVersionExperimentTreatmentLocalizations"
          | "appStoreVersionExperimentV2"
        )[];
      },
      params: RequestParams = {},
    ): Promise<AppStoreVersionExperimentTreatmentsResponse> =>
      this.request<AppStoreVersionExperimentTreatmentsResponse, ErrorResponse>({
        path: `/v2/appStoreVersionExperiments/${id}/appStoreVersionExperimentTreatments`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppStoreVersionExperiments
     * @name AppStoreVersionExperimentsAppStoreVersionExperimentTreatmentsGetToManyRelated
     * @request GET:/v1/appStoreVersionExperiments/{id}/appStoreVersionExperimentTreatments
     * @deprecated
     * @secure
     */
    appStoreVersionExperimentTreatmentsGetToManyRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type appStoreVersionExperiments */
        "fields[appStoreVersionExperiments]"?: (
          | "app"
          | "appStoreVersion"
          | "appStoreVersionExperimentTreatments"
          | "controlVersions"
          | "endDate"
          | "latestControlVersion"
          | "name"
          | "platform"
          | "reviewRequired"
          | "startDate"
          | "started"
          | "state"
          | "trafficProportion"
        )[];
        /** the fields to include for returned resources of type appStoreVersionExperimentTreatments */
        "fields[appStoreVersionExperimentTreatments]"?: (
          | "appIcon"
          | "appIconName"
          | "appStoreVersionExperiment"
          | "appStoreVersionExperimentTreatmentLocalizations"
          | "appStoreVersionExperimentV2"
          | "name"
          | "promotedDate"
        )[];
        /** the fields to include for returned resources of type appStoreVersionExperimentTreatmentLocalizations */
        "fields[appStoreVersionExperimentTreatmentLocalizations]"?: (
          | "appPreviewSets"
          | "appScreenshotSets"
          | "appStoreVersionExperimentTreatment"
          | "locale"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /**
         * maximum number of related appStoreVersionExperimentTreatmentLocalizations returned (when they are included)
         * @max 50
         */
        "limit[appStoreVersionExperimentTreatmentLocalizations]"?: number;
        /** comma-separated list of relationships to include */
        include?: (
          | "appStoreVersionExperiment"
          | "appStoreVersionExperimentTreatmentLocalizations"
          | "appStoreVersionExperimentV2"
        )[];
      },
      params: RequestParams = {},
    ): Promise<AppStoreVersionExperimentTreatmentsResponse> =>
      this.request<AppStoreVersionExperimentTreatmentsResponse, ErrorResponse>({
        path: `/v1/appStoreVersionExperiments/${id}/appStoreVersionExperimentTreatments`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  appStoreVersionLocalizations = {
    /**
     * No description
     *
     * @tags AppStoreVersionLocalizations
     * @name AppStoreVersionLocalizationsCreateInstance
     * @request POST:/v1/appStoreVersionLocalizations
     * @secure
     */
    createInstance: (
      data: AppStoreVersionLocalizationCreateRequest,
      params: RequestParams = {},
    ): Promise<AppStoreVersionLocalizationResponse> =>
      this.request<AppStoreVersionLocalizationResponse, ErrorResponse>({
        path: `/v1/appStoreVersionLocalizations`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppStoreVersionLocalizations
     * @name AppStoreVersionLocalizationsGetInstance
     * @request GET:/v1/appStoreVersionLocalizations/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type appStoreVersionLocalizations */
        "fields[appStoreVersionLocalizations]"?: (
          | "appPreviewSets"
          | "appScreenshotSets"
          | "appStoreVersion"
          | "description"
          | "keywords"
          | "locale"
          | "marketingUrl"
          | "promotionalText"
          | "supportUrl"
          | "whatsNew"
        )[];
        /** comma-separated list of relationships to include */
        include?: ("appPreviewSets" | "appScreenshotSets" | "appStoreVersion")[];
        /** the fields to include for returned resources of type appScreenshotSets */
        "fields[appScreenshotSets]"?: (
          | "appCustomProductPageLocalization"
          | "appScreenshots"
          | "appStoreVersionExperimentTreatmentLocalization"
          | "appStoreVersionLocalization"
          | "screenshotDisplayType"
        )[];
        /** the fields to include for returned resources of type appPreviewSets */
        "fields[appPreviewSets]"?: (
          | "appCustomProductPageLocalization"
          | "appPreviews"
          | "appStoreVersionExperimentTreatmentLocalization"
          | "appStoreVersionLocalization"
          | "previewType"
        )[];
        /**
         * maximum number of related appPreviewSets returned (when they are included)
         * @max 50
         */
        "limit[appPreviewSets]"?: number;
        /**
         * maximum number of related appScreenshotSets returned (when they are included)
         * @max 50
         */
        "limit[appScreenshotSets]"?: number;
      },
      params: RequestParams = {},
    ): Promise<AppStoreVersionLocalizationResponse> =>
      this.request<AppStoreVersionLocalizationResponse, ErrorResponse>({
        path: `/v1/appStoreVersionLocalizations/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppStoreVersionLocalizations
     * @name AppStoreVersionLocalizationsUpdateInstance
     * @request PATCH:/v1/appStoreVersionLocalizations/{id}
     * @secure
     */
    updateInstance: (
      id: string,
      data: AppStoreVersionLocalizationUpdateRequest,
      params: RequestParams = {},
    ): Promise<AppStoreVersionLocalizationResponse> =>
      this.request<AppStoreVersionLocalizationResponse, ErrorResponse>({
        path: `/v1/appStoreVersionLocalizations/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppStoreVersionLocalizations
     * @name AppStoreVersionLocalizationsDeleteInstance
     * @request DELETE:/v1/appStoreVersionLocalizations/{id}
     * @secure
     */
    deleteInstance: (id: string, params: RequestParams = {}): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/appStoreVersionLocalizations/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppStoreVersionLocalizations
     * @name AppStoreVersionLocalizationsAppPreviewSetsGetToManyRelated
     * @request GET:/v1/appStoreVersionLocalizations/{id}/appPreviewSets
     * @secure
     */
    appPreviewSetsGetToManyRelated: (
      id: string,
      query?: {
        /** filter by attribute 'previewType' */
        "filter[previewType]"?: (
          | "IPHONE_67"
          | "IPHONE_61"
          | "IPHONE_65"
          | "IPHONE_58"
          | "IPHONE_55"
          | "IPHONE_47"
          | "IPHONE_40"
          | "IPHONE_35"
          | "IPAD_PRO_3GEN_129"
          | "IPAD_PRO_3GEN_11"
          | "IPAD_PRO_129"
          | "IPAD_105"
          | "IPAD_97"
          | "DESKTOP"
          | "APPLE_TV"
          | "APPLE_VISION_PRO"
        )[];
        /** filter by id(s) of related 'appCustomProductPageLocalization' */
        "filter[appCustomProductPageLocalization]"?: string[];
        /** filter by id(s) of related 'appStoreVersionExperimentTreatmentLocalization' */
        "filter[appStoreVersionExperimentTreatmentLocalization]"?: string[];
        /** the fields to include for returned resources of type appCustomProductPageLocalizations */
        "fields[appCustomProductPageLocalizations]"?: (
          | "appCustomProductPageVersion"
          | "appPreviewSets"
          | "appScreenshotSets"
          | "locale"
          | "promotionalText"
        )[];
        /** the fields to include for returned resources of type appStoreVersionExperimentTreatmentLocalizations */
        "fields[appStoreVersionExperimentTreatmentLocalizations]"?: (
          | "appPreviewSets"
          | "appScreenshotSets"
          | "appStoreVersionExperimentTreatment"
          | "locale"
        )[];
        /** the fields to include for returned resources of type appPreviews */
        "fields[appPreviews]"?: (
          | "appPreviewSet"
          | "assetDeliveryState"
          | "fileName"
          | "fileSize"
          | "mimeType"
          | "previewFrameTimeCode"
          | "previewImage"
          | "sourceFileChecksum"
          | "uploadOperations"
          | "uploaded"
          | "videoUrl"
        )[];
        /** the fields to include for returned resources of type appPreviewSets */
        "fields[appPreviewSets]"?: (
          | "appCustomProductPageLocalization"
          | "appPreviews"
          | "appStoreVersionExperimentTreatmentLocalization"
          | "appStoreVersionLocalization"
          | "previewType"
        )[];
        /** the fields to include for returned resources of type appStoreVersionLocalizations */
        "fields[appStoreVersionLocalizations]"?: (
          | "appPreviewSets"
          | "appScreenshotSets"
          | "appStoreVersion"
          | "description"
          | "keywords"
          | "locale"
          | "marketingUrl"
          | "promotionalText"
          | "supportUrl"
          | "whatsNew"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /**
         * maximum number of related appPreviews returned (when they are included)
         * @max 50
         */
        "limit[appPreviews]"?: number;
        /** comma-separated list of relationships to include */
        include?: (
          | "appCustomProductPageLocalization"
          | "appPreviews"
          | "appStoreVersionExperimentTreatmentLocalization"
          | "appStoreVersionLocalization"
        )[];
      },
      params: RequestParams = {},
    ): Promise<AppPreviewSetsResponse> =>
      this.request<AppPreviewSetsResponse, ErrorResponse>({
        path: `/v1/appStoreVersionLocalizations/${id}/appPreviewSets`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppStoreVersionLocalizations
     * @name AppStoreVersionLocalizationsAppScreenshotSetsGetToManyRelated
     * @request GET:/v1/appStoreVersionLocalizations/{id}/appScreenshotSets
     * @secure
     */
    appScreenshotSetsGetToManyRelated: (
      id: string,
      query?: {
        /** filter by attribute 'screenshotDisplayType' */
        "filter[screenshotDisplayType]"?: (
          | "APP_IPHONE_67"
          | "APP_IPHONE_61"
          | "APP_IPHONE_65"
          | "APP_IPHONE_58"
          | "APP_IPHONE_55"
          | "APP_IPHONE_47"
          | "APP_IPHONE_40"
          | "APP_IPHONE_35"
          | "APP_IPAD_PRO_3GEN_129"
          | "APP_IPAD_PRO_3GEN_11"
          | "APP_IPAD_PRO_129"
          | "APP_IPAD_105"
          | "APP_IPAD_97"
          | "APP_DESKTOP"
          | "APP_WATCH_ULTRA"
          | "APP_WATCH_SERIES_7"
          | "APP_WATCH_SERIES_4"
          | "APP_WATCH_SERIES_3"
          | "APP_APPLE_TV"
          | "APP_APPLE_VISION_PRO"
          | "IMESSAGE_APP_IPHONE_67"
          | "IMESSAGE_APP_IPHONE_61"
          | "IMESSAGE_APP_IPHONE_65"
          | "IMESSAGE_APP_IPHONE_58"
          | "IMESSAGE_APP_IPHONE_55"
          | "IMESSAGE_APP_IPHONE_47"
          | "IMESSAGE_APP_IPHONE_40"
          | "IMESSAGE_APP_IPAD_PRO_3GEN_129"
          | "IMESSAGE_APP_IPAD_PRO_3GEN_11"
          | "IMESSAGE_APP_IPAD_PRO_129"
          | "IMESSAGE_APP_IPAD_105"
          | "IMESSAGE_APP_IPAD_97"
        )[];
        /** filter by id(s) of related 'appCustomProductPageLocalization' */
        "filter[appCustomProductPageLocalization]"?: string[];
        /** filter by id(s) of related 'appStoreVersionExperimentTreatmentLocalization' */
        "filter[appStoreVersionExperimentTreatmentLocalization]"?: string[];
        /** the fields to include for returned resources of type appScreenshotSets */
        "fields[appScreenshotSets]"?: (
          | "appCustomProductPageLocalization"
          | "appScreenshots"
          | "appStoreVersionExperimentTreatmentLocalization"
          | "appStoreVersionLocalization"
          | "screenshotDisplayType"
        )[];
        /** the fields to include for returned resources of type appCustomProductPageLocalizations */
        "fields[appCustomProductPageLocalizations]"?: (
          | "appCustomProductPageVersion"
          | "appPreviewSets"
          | "appScreenshotSets"
          | "locale"
          | "promotionalText"
        )[];
        /** the fields to include for returned resources of type appStoreVersionExperimentTreatmentLocalizations */
        "fields[appStoreVersionExperimentTreatmentLocalizations]"?: (
          | "appPreviewSets"
          | "appScreenshotSets"
          | "appStoreVersionExperimentTreatment"
          | "locale"
        )[];
        /** the fields to include for returned resources of type appScreenshots */
        "fields[appScreenshots]"?: (
          | "appScreenshotSet"
          | "assetDeliveryState"
          | "assetToken"
          | "assetType"
          | "fileName"
          | "fileSize"
          | "imageAsset"
          | "sourceFileChecksum"
          | "uploadOperations"
          | "uploaded"
        )[];
        /** the fields to include for returned resources of type appStoreVersionLocalizations */
        "fields[appStoreVersionLocalizations]"?: (
          | "appPreviewSets"
          | "appScreenshotSets"
          | "appStoreVersion"
          | "description"
          | "keywords"
          | "locale"
          | "marketingUrl"
          | "promotionalText"
          | "supportUrl"
          | "whatsNew"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /**
         * maximum number of related appScreenshots returned (when they are included)
         * @max 50
         */
        "limit[appScreenshots]"?: number;
        /** comma-separated list of relationships to include */
        include?: (
          | "appCustomProductPageLocalization"
          | "appScreenshots"
          | "appStoreVersionExperimentTreatmentLocalization"
          | "appStoreVersionLocalization"
        )[];
      },
      params: RequestParams = {},
    ): Promise<AppScreenshotSetsResponse> =>
      this.request<AppScreenshotSetsResponse, ErrorResponse>({
        path: `/v1/appStoreVersionLocalizations/${id}/appScreenshotSets`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  appStoreVersionPhasedReleases = {
    /**
     * No description
     *
     * @tags AppStoreVersionPhasedReleases
     * @name AppStoreVersionPhasedReleasesCreateInstance
     * @request POST:/v1/appStoreVersionPhasedReleases
     * @secure
     */
    createInstance: (
      data: AppStoreVersionPhasedReleaseCreateRequest,
      params: RequestParams = {},
    ): Promise<AppStoreVersionPhasedReleaseResponse> =>
      this.request<AppStoreVersionPhasedReleaseResponse, ErrorResponse>({
        path: `/v1/appStoreVersionPhasedReleases`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppStoreVersionPhasedReleases
     * @name AppStoreVersionPhasedReleasesUpdateInstance
     * @request PATCH:/v1/appStoreVersionPhasedReleases/{id}
     * @secure
     */
    updateInstance: (
      id: string,
      data: AppStoreVersionPhasedReleaseUpdateRequest,
      params: RequestParams = {},
    ): Promise<AppStoreVersionPhasedReleaseResponse> =>
      this.request<AppStoreVersionPhasedReleaseResponse, ErrorResponse>({
        path: `/v1/appStoreVersionPhasedReleases/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppStoreVersionPhasedReleases
     * @name AppStoreVersionPhasedReleasesDeleteInstance
     * @request DELETE:/v1/appStoreVersionPhasedReleases/{id}
     * @secure
     */
    deleteInstance: (id: string, params: RequestParams = {}): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/appStoreVersionPhasedReleases/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),
  };
  appStoreVersionPromotions = {
    /**
     * No description
     *
     * @tags AppStoreVersionPromotions
     * @name AppStoreVersionPromotionsCreateInstance
     * @request POST:/v1/appStoreVersionPromotions
     * @secure
     */
    createInstance: (
      data: AppStoreVersionPromotionCreateRequest,
      params: RequestParams = {},
    ): Promise<AppStoreVersionPromotionResponse> =>
      this.request<AppStoreVersionPromotionResponse, ErrorResponse>({
        path: `/v1/appStoreVersionPromotions`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),
  };
  appStoreVersionReleaseRequests = {
    /**
     * No description
     *
     * @tags AppStoreVersionReleaseRequests
     * @name AppStoreVersionReleaseRequestsCreateInstance
     * @request POST:/v1/appStoreVersionReleaseRequests
     * @secure
     */
    createInstance: (
      data: AppStoreVersionReleaseRequestCreateRequest,
      params: RequestParams = {},
    ): Promise<AppStoreVersionReleaseRequestResponse> =>
      this.request<AppStoreVersionReleaseRequestResponse, ErrorResponse>({
        path: `/v1/appStoreVersionReleaseRequests`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),
  };
  appStoreVersionSubmissions = {
    /**
     * No description
     *
     * @tags AppStoreVersionSubmissions
     * @name AppStoreVersionSubmissionsCreateInstance
     * @request POST:/v1/appStoreVersionSubmissions
     * @deprecated
     * @secure
     */
    createInstance: (
      data: AppStoreVersionSubmissionCreateRequest,
      params: RequestParams = {},
    ): Promise<AppStoreVersionSubmissionResponse> =>
      this.request<AppStoreVersionSubmissionResponse, ErrorResponse>({
        path: `/v1/appStoreVersionSubmissions`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppStoreVersionSubmissions
     * @name AppStoreVersionSubmissionsDeleteInstance
     * @request DELETE:/v1/appStoreVersionSubmissions/{id}
     * @deprecated
     * @secure
     */
    deleteInstance: (id: string, params: RequestParams = {}): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/appStoreVersionSubmissions/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),
  };
  appStoreVersions = {
    /**
     * No description
     *
     * @tags AppStoreVersions
     * @name AppStoreVersionsCreateInstance
     * @request POST:/v1/appStoreVersions
     * @secure
     */
    createInstance: (
      data: AppStoreVersionCreateRequest,
      params: RequestParams = {},
    ): Promise<AppStoreVersionResponse> =>
      this.request<AppStoreVersionResponse, ErrorResponse>({
        path: `/v1/appStoreVersions`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppStoreVersions
     * @name AppStoreVersionsGetInstance
     * @request GET:/v1/appStoreVersions/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type appStoreVersions */
        "fields[appStoreVersions]"?: (
          | "ageRatingDeclaration"
          | "alternativeDistributionPackage"
          | "app"
          | "appClipDefaultExperience"
          | "appStoreReviewDetail"
          | "appStoreState"
          | "appStoreVersionExperiments"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersionLocalizations"
          | "appStoreVersionPhasedRelease"
          | "appStoreVersionSubmission"
          | "appVersionState"
          | "build"
          | "copyright"
          | "createdDate"
          | "customerReviews"
          | "downloadable"
          | "earliestReleaseDate"
          | "platform"
          | "releaseType"
          | "reviewType"
          | "routingAppCoverage"
          | "versionString"
        )[];
        /** comma-separated list of relationships to include */
        include?: (
          | "ageRatingDeclaration"
          | "alternativeDistributionPackage"
          | "app"
          | "appClipDefaultExperience"
          | "appStoreReviewDetail"
          | "appStoreVersionExperiments"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersionLocalizations"
          | "appStoreVersionPhasedRelease"
          | "appStoreVersionSubmission"
          | "build"
          | "routingAppCoverage"
        )[];
        /** the fields to include for returned resources of type appStoreVersionExperiments */
        "fields[appStoreVersionExperiments]"?: (
          | "app"
          | "appStoreVersion"
          | "appStoreVersionExperimentTreatments"
          | "controlVersions"
          | "endDate"
          | "latestControlVersion"
          | "name"
          | "platform"
          | "reviewRequired"
          | "startDate"
          | "started"
          | "state"
          | "trafficProportion"
        )[];
        /**
         * the fields to include for returned resources of type appStoreVersionSubmissions
         * @deprecated
         */
        "fields[appStoreVersionSubmissions]"?: "appStoreVersion"[];
        /**
         * the fields to include for returned resources of type ageRatingDeclarations
         * @deprecated
         */
        "fields[ageRatingDeclarations]"?: (
          | "ageRatingOverride"
          | "alcoholTobaccoOrDrugUseOrReferences"
          | "contests"
          | "gambling"
          | "gamblingAndContests"
          | "gamblingSimulated"
          | "horrorOrFearThemes"
          | "kidsAgeBand"
          | "matureOrSuggestiveThemes"
          | "medicalOrTreatmentInformation"
          | "profanityOrCrudeHumor"
          | "seventeenPlus"
          | "sexualContentGraphicAndNudity"
          | "sexualContentOrNudity"
          | "unrestrictedWebAccess"
          | "violenceCartoonOrFantasy"
          | "violenceRealistic"
          | "violenceRealisticProlongedGraphicOrSadistic"
        )[];
        /** the fields to include for returned resources of type alternativeDistributionPackages */
        "fields[alternativeDistributionPackages]"?: ("appStoreVersion" | "versions")[];
        /** the fields to include for returned resources of type customerReviews */
        "fields[customerReviews]"?: (
          | "body"
          | "createdDate"
          | "rating"
          | "response"
          | "reviewerNickname"
          | "territory"
          | "title"
        )[];
        /** the fields to include for returned resources of type appStoreReviewDetails */
        "fields[appStoreReviewDetails]"?: (
          | "appStoreReviewAttachments"
          | "appStoreVersion"
          | "contactEmail"
          | "contactFirstName"
          | "contactLastName"
          | "contactPhone"
          | "demoAccountName"
          | "demoAccountPassword"
          | "demoAccountRequired"
          | "notes"
        )[];
        /** the fields to include for returned resources of type appClipDefaultExperiences */
        "fields[appClipDefaultExperiences]"?: (
          | "action"
          | "appClip"
          | "appClipAppStoreReviewDetail"
          | "appClipDefaultExperienceLocalizations"
          | "appClipDefaultExperienceTemplate"
          | "releaseWithAppStoreVersion"
        )[];
        /** the fields to include for returned resources of type routingAppCoverages */
        "fields[routingAppCoverages]"?: (
          | "appStoreVersion"
          | "assetDeliveryState"
          | "fileName"
          | "fileSize"
          | "sourceFileChecksum"
          | "uploadOperations"
          | "uploaded"
        )[];
        /** the fields to include for returned resources of type appStoreVersionPhasedReleases */
        "fields[appStoreVersionPhasedReleases]"?: (
          | "appStoreVersion"
          | "currentDayNumber"
          | "phasedReleaseState"
          | "startDate"
          | "totalPauseDuration"
        )[];
        /** the fields to include for returned resources of type builds */
        "fields[builds]"?: (
          | "app"
          | "appEncryptionDeclaration"
          | "appStoreVersion"
          | "betaAppReviewSubmission"
          | "betaBuildLocalizations"
          | "betaGroups"
          | "buildAudienceType"
          | "buildBetaDetail"
          | "buildBundles"
          | "computedMinMacOsVersion"
          | "diagnosticSignatures"
          | "expirationDate"
          | "expired"
          | "iconAssetToken"
          | "icons"
          | "individualTesters"
          | "lsMinimumSystemVersion"
          | "minOsVersion"
          | "perfPowerMetrics"
          | "preReleaseVersion"
          | "processingState"
          | "uploadedDate"
          | "usesNonExemptEncryption"
          | "version"
        )[];
        /** the fields to include for returned resources of type appStoreVersionLocalizations */
        "fields[appStoreVersionLocalizations]"?: (
          | "appPreviewSets"
          | "appScreenshotSets"
          | "appStoreVersion"
          | "description"
          | "keywords"
          | "locale"
          | "marketingUrl"
          | "promotionalText"
          | "supportUrl"
          | "whatsNew"
        )[];
        /**
         * maximum number of related appStoreVersionExperiments returned (when they are included)
         * @deprecated
         * @max 50
         */
        "limit[appStoreVersionExperiments]"?: number;
        /**
         * maximum number of related appStoreVersionExperimentsV2 returned (when they are included)
         * @max 50
         */
        "limit[appStoreVersionExperimentsV2]"?: number;
        /**
         * maximum number of related appStoreVersionLocalizations returned (when they are included)
         * @max 50
         */
        "limit[appStoreVersionLocalizations]"?: number;
      },
      params: RequestParams = {},
    ): Promise<AppStoreVersionResponse> =>
      this.request<AppStoreVersionResponse, ErrorResponse>({
        path: `/v1/appStoreVersions/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppStoreVersions
     * @name AppStoreVersionsUpdateInstance
     * @request PATCH:/v1/appStoreVersions/{id}
     * @secure
     */
    updateInstance: (
      id: string,
      data: AppStoreVersionUpdateRequest,
      params: RequestParams = {},
    ): Promise<AppStoreVersionResponse> =>
      this.request<AppStoreVersionResponse, ErrorResponse>({
        path: `/v1/appStoreVersions/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppStoreVersions
     * @name AppStoreVersionsDeleteInstance
     * @request DELETE:/v1/appStoreVersions/{id}
     * @secure
     */
    deleteInstance: (id: string, params: RequestParams = {}): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/appStoreVersions/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppStoreVersions
     * @name AppStoreVersionsAgeRatingDeclarationGetToOneRelated
     * @request GET:/v1/appStoreVersions/{id}/ageRatingDeclaration
     * @deprecated
     * @secure
     */
    ageRatingDeclarationGetToOneRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type ageRatingDeclarations */
        "fields[ageRatingDeclarations]"?: (
          | "ageRatingOverride"
          | "alcoholTobaccoOrDrugUseOrReferences"
          | "contests"
          | "gambling"
          | "gamblingAndContests"
          | "gamblingSimulated"
          | "horrorOrFearThemes"
          | "kidsAgeBand"
          | "matureOrSuggestiveThemes"
          | "medicalOrTreatmentInformation"
          | "profanityOrCrudeHumor"
          | "seventeenPlus"
          | "sexualContentGraphicAndNudity"
          | "sexualContentOrNudity"
          | "unrestrictedWebAccess"
          | "violenceCartoonOrFantasy"
          | "violenceRealistic"
          | "violenceRealisticProlongedGraphicOrSadistic"
        )[];
      },
      params: RequestParams = {},
    ): Promise<AgeRatingDeclarationWithoutIncludesResponse> =>
      this.request<AgeRatingDeclarationWithoutIncludesResponse, ErrorResponse>({
        path: `/v1/appStoreVersions/${id}/ageRatingDeclaration`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppStoreVersions
     * @name AppStoreVersionsAlternativeDistributionPackageGetToOneRelated
     * @request GET:/v1/appStoreVersions/{id}/alternativeDistributionPackage
     * @secure
     */
    alternativeDistributionPackageGetToOneRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type alternativeDistributionPackages */
        "fields[alternativeDistributionPackages]"?: ("appStoreVersion" | "versions")[];
        /** the fields to include for returned resources of type alternativeDistributionPackageVersions */
        "fields[alternativeDistributionPackageVersions]"?: (
          | "alternativeDistributionPackage"
          | "deltas"
          | "fileChecksum"
          | "state"
          | "url"
          | "urlExpirationDate"
          | "variants"
          | "version"
        )[];
        /**
         * maximum number of related versions returned (when they are included)
         * @max 50
         */
        "limit[versions]"?: number;
        /** comma-separated list of relationships to include */
        include?: "versions"[];
      },
      params: RequestParams = {},
    ): Promise<AlternativeDistributionPackageResponse> =>
      this.request<AlternativeDistributionPackageResponse, ErrorResponse>({
        path: `/v1/appStoreVersions/${id}/alternativeDistributionPackage`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppStoreVersions
     * @name AppStoreVersionsAppClipDefaultExperienceGetToOneRelationship
     * @request GET:/v1/appStoreVersions/{id}/relationships/appClipDefaultExperience
     * @secure
     */
    appClipDefaultExperienceGetToOneRelationship: (
      id: string,
      params: RequestParams = {},
    ): Promise<AppStoreVersionAppClipDefaultExperienceLinkageResponse> =>
      this.request<AppStoreVersionAppClipDefaultExperienceLinkageResponse, ErrorResponse>({
        path: `/v1/appStoreVersions/${id}/relationships/appClipDefaultExperience`,
        method: "GET",
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppStoreVersions
     * @name AppStoreVersionsAppClipDefaultExperienceUpdateToOneRelationship
     * @request PATCH:/v1/appStoreVersions/{id}/relationships/appClipDefaultExperience
     * @secure
     */
    appClipDefaultExperienceUpdateToOneRelationship: (
      id: string,
      data: AppStoreVersionAppClipDefaultExperienceLinkageRequest,
      params: RequestParams = {},
    ): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/appStoreVersions/${id}/relationships/appClipDefaultExperience`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppStoreVersions
     * @name AppStoreVersionsAppClipDefaultExperienceGetToOneRelated
     * @request GET:/v1/appStoreVersions/{id}/appClipDefaultExperience
     * @secure
     */
    appClipDefaultExperienceGetToOneRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type appClips */
        "fields[appClips]"?: ("app" | "appClipAdvancedExperiences" | "appClipDefaultExperiences" | "bundleId")[];
        /** the fields to include for returned resources of type appClipAppStoreReviewDetails */
        "fields[appClipAppStoreReviewDetails]"?: ("appClipDefaultExperience" | "invocationUrls")[];
        /** the fields to include for returned resources of type appStoreVersions */
        "fields[appStoreVersions]"?: (
          | "ageRatingDeclaration"
          | "alternativeDistributionPackage"
          | "app"
          | "appClipDefaultExperience"
          | "appStoreReviewDetail"
          | "appStoreState"
          | "appStoreVersionExperiments"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersionLocalizations"
          | "appStoreVersionPhasedRelease"
          | "appStoreVersionSubmission"
          | "appVersionState"
          | "build"
          | "copyright"
          | "createdDate"
          | "customerReviews"
          | "downloadable"
          | "earliestReleaseDate"
          | "platform"
          | "releaseType"
          | "reviewType"
          | "routingAppCoverage"
          | "versionString"
        )[];
        /** the fields to include for returned resources of type appClipDefaultExperiences */
        "fields[appClipDefaultExperiences]"?: (
          | "action"
          | "appClip"
          | "appClipAppStoreReviewDetail"
          | "appClipDefaultExperienceLocalizations"
          | "appClipDefaultExperienceTemplate"
          | "releaseWithAppStoreVersion"
        )[];
        /** the fields to include for returned resources of type appClipDefaultExperienceLocalizations */
        "fields[appClipDefaultExperienceLocalizations]"?: (
          | "appClipDefaultExperience"
          | "appClipHeaderImage"
          | "locale"
          | "subtitle"
        )[];
        /**
         * maximum number of related appClipDefaultExperienceLocalizations returned (when they are included)
         * @max 50
         */
        "limit[appClipDefaultExperienceLocalizations]"?: number;
        /** comma-separated list of relationships to include */
        include?: (
          | "appClip"
          | "appClipAppStoreReviewDetail"
          | "appClipDefaultExperienceLocalizations"
          | "releaseWithAppStoreVersion"
        )[];
      },
      params: RequestParams = {},
    ): Promise<AppClipDefaultExperienceResponse> =>
      this.request<AppClipDefaultExperienceResponse, ErrorResponse>({
        path: `/v1/appStoreVersions/${id}/appClipDefaultExperience`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppStoreVersions
     * @name AppStoreVersionsAppStoreReviewDetailGetToOneRelated
     * @request GET:/v1/appStoreVersions/{id}/appStoreReviewDetail
     * @secure
     */
    appStoreReviewDetailGetToOneRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type appStoreReviewDetails */
        "fields[appStoreReviewDetails]"?: (
          | "appStoreReviewAttachments"
          | "appStoreVersion"
          | "contactEmail"
          | "contactFirstName"
          | "contactLastName"
          | "contactPhone"
          | "demoAccountName"
          | "demoAccountPassword"
          | "demoAccountRequired"
          | "notes"
        )[];
        /** the fields to include for returned resources of type appStoreVersions */
        "fields[appStoreVersions]"?: (
          | "ageRatingDeclaration"
          | "alternativeDistributionPackage"
          | "app"
          | "appClipDefaultExperience"
          | "appStoreReviewDetail"
          | "appStoreState"
          | "appStoreVersionExperiments"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersionLocalizations"
          | "appStoreVersionPhasedRelease"
          | "appStoreVersionSubmission"
          | "appVersionState"
          | "build"
          | "copyright"
          | "createdDate"
          | "customerReviews"
          | "downloadable"
          | "earliestReleaseDate"
          | "platform"
          | "releaseType"
          | "reviewType"
          | "routingAppCoverage"
          | "versionString"
        )[];
        /** the fields to include for returned resources of type appStoreReviewAttachments */
        "fields[appStoreReviewAttachments]"?: (
          | "appStoreReviewDetail"
          | "assetDeliveryState"
          | "fileName"
          | "fileSize"
          | "sourceFileChecksum"
          | "uploadOperations"
          | "uploaded"
        )[];
        /**
         * maximum number of related appStoreReviewAttachments returned (when they are included)
         * @max 50
         */
        "limit[appStoreReviewAttachments]"?: number;
        /** comma-separated list of relationships to include */
        include?: ("appStoreReviewAttachments" | "appStoreVersion")[];
      },
      params: RequestParams = {},
    ): Promise<AppStoreReviewDetailResponse> =>
      this.request<AppStoreReviewDetailResponse, ErrorResponse>({
        path: `/v1/appStoreVersions/${id}/appStoreReviewDetail`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppStoreVersions
     * @name AppStoreVersionsAppStoreVersionExperimentsGetToManyRelated
     * @request GET:/v1/appStoreVersions/{id}/appStoreVersionExperiments
     * @deprecated
     * @secure
     */
    appStoreVersionExperimentsGetToManyRelated: (
      id: string,
      query?: {
        /** filter by attribute 'state' */
        "filter[state]"?: (
          | "PREPARE_FOR_SUBMISSION"
          | "READY_FOR_REVIEW"
          | "WAITING_FOR_REVIEW"
          | "IN_REVIEW"
          | "ACCEPTED"
          | "APPROVED"
          | "REJECTED"
          | "COMPLETED"
          | "STOPPED"
        )[];
        /** the fields to include for returned resources of type appStoreVersionExperiments */
        "fields[appStoreVersionExperiments]"?: (
          | "appStoreVersion"
          | "appStoreVersionExperimentTreatments"
          | "endDate"
          | "name"
          | "reviewRequired"
          | "startDate"
          | "started"
          | "state"
          | "trafficProportion"
        )[];
        /** the fields to include for returned resources of type appStoreVersionExperimentTreatments */
        "fields[appStoreVersionExperimentTreatments]"?: (
          | "appIcon"
          | "appIconName"
          | "appStoreVersionExperiment"
          | "appStoreVersionExperimentTreatmentLocalizations"
          | "appStoreVersionExperimentV2"
          | "name"
          | "promotedDate"
        )[];
        /** the fields to include for returned resources of type appStoreVersions */
        "fields[appStoreVersions]"?: (
          | "ageRatingDeclaration"
          | "alternativeDistributionPackage"
          | "app"
          | "appClipDefaultExperience"
          | "appStoreReviewDetail"
          | "appStoreState"
          | "appStoreVersionExperiments"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersionLocalizations"
          | "appStoreVersionPhasedRelease"
          | "appStoreVersionSubmission"
          | "appVersionState"
          | "build"
          | "copyright"
          | "createdDate"
          | "customerReviews"
          | "downloadable"
          | "earliestReleaseDate"
          | "platform"
          | "releaseType"
          | "reviewType"
          | "routingAppCoverage"
          | "versionString"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /**
         * maximum number of related appStoreVersionExperimentTreatments returned (when they are included)
         * @max 50
         */
        "limit[appStoreVersionExperimentTreatments]"?: number;
        /** comma-separated list of relationships to include */
        include?: ("appStoreVersion" | "appStoreVersionExperimentTreatments")[];
      },
      params: RequestParams = {},
    ): Promise<AppStoreVersionExperimentsResponse> =>
      this.request<AppStoreVersionExperimentsResponse, ErrorResponse>({
        path: `/v1/appStoreVersions/${id}/appStoreVersionExperiments`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppStoreVersions
     * @name AppStoreVersionsAppStoreVersionExperimentsV2GetToManyRelated
     * @request GET:/v1/appStoreVersions/{id}/appStoreVersionExperimentsV2
     * @secure
     */
    appStoreVersionExperimentsV2GetToManyRelated: (
      id: string,
      query?: {
        /** filter by attribute 'state' */
        "filter[state]"?: (
          | "PREPARE_FOR_SUBMISSION"
          | "READY_FOR_REVIEW"
          | "WAITING_FOR_REVIEW"
          | "IN_REVIEW"
          | "ACCEPTED"
          | "APPROVED"
          | "REJECTED"
          | "COMPLETED"
          | "STOPPED"
        )[];
        /** the fields to include for returned resources of type appStoreVersionExperiments */
        "fields[appStoreVersionExperiments]"?: (
          | "app"
          | "appStoreVersionExperimentTreatments"
          | "controlVersions"
          | "endDate"
          | "latestControlVersion"
          | "name"
          | "platform"
          | "reviewRequired"
          | "startDate"
          | "started"
          | "state"
          | "trafficProportion"
        )[];
        /** the fields to include for returned resources of type appStoreVersionExperimentTreatments */
        "fields[appStoreVersionExperimentTreatments]"?: (
          | "appIcon"
          | "appIconName"
          | "appStoreVersionExperiment"
          | "appStoreVersionExperimentTreatmentLocalizations"
          | "appStoreVersionExperimentV2"
          | "name"
          | "promotedDate"
        )[];
        /** the fields to include for returned resources of type appStoreVersions */
        "fields[appStoreVersions]"?: (
          | "ageRatingDeclaration"
          | "alternativeDistributionPackage"
          | "app"
          | "appClipDefaultExperience"
          | "appStoreReviewDetail"
          | "appStoreState"
          | "appStoreVersionExperiments"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersionLocalizations"
          | "appStoreVersionPhasedRelease"
          | "appStoreVersionSubmission"
          | "appVersionState"
          | "build"
          | "copyright"
          | "createdDate"
          | "customerReviews"
          | "downloadable"
          | "earliestReleaseDate"
          | "platform"
          | "releaseType"
          | "reviewType"
          | "routingAppCoverage"
          | "versionString"
        )[];
        /** the fields to include for returned resources of type apps */
        "fields[apps]"?: (
          | "alternativeDistributionKey"
          | "analyticsReportRequests"
          | "appAvailability"
          | "appClips"
          | "appCustomProductPages"
          | "appEncryptionDeclarations"
          | "appEvents"
          | "appInfos"
          | "appPricePoints"
          | "appPriceSchedule"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersions"
          | "availableInNewTerritories"
          | "availableTerritories"
          | "betaAppLocalizations"
          | "betaAppReviewDetail"
          | "betaGroups"
          | "betaLicenseAgreement"
          | "betaTesters"
          | "builds"
          | "bundleId"
          | "ciProduct"
          | "contentRightsDeclaration"
          | "customerReviews"
          | "endUserLicenseAgreement"
          | "gameCenterDetail"
          | "gameCenterEnabledVersions"
          | "inAppPurchases"
          | "inAppPurchasesV2"
          | "isOrEverWasMadeForKids"
          | "marketplaceSearchDetail"
          | "name"
          | "perfPowerMetrics"
          | "preOrder"
          | "preReleaseVersions"
          | "pricePoints"
          | "prices"
          | "primaryLocale"
          | "promotedPurchases"
          | "reviewSubmissions"
          | "sku"
          | "subscriptionGracePeriod"
          | "subscriptionGroups"
          | "subscriptionStatusUrl"
          | "subscriptionStatusUrlForSandbox"
          | "subscriptionStatusUrlVersion"
          | "subscriptionStatusUrlVersionForSandbox"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /**
         * maximum number of related controlVersions returned (when they are included)
         * @max 50
         */
        "limit[controlVersions]"?: number;
        /**
         * maximum number of related appStoreVersionExperimentTreatments returned (when they are included)
         * @max 50
         */
        "limit[appStoreVersionExperimentTreatments]"?: number;
        /** comma-separated list of relationships to include */
        include?: ("app" | "appStoreVersionExperimentTreatments" | "controlVersions" | "latestControlVersion")[];
      },
      params: RequestParams = {},
    ): Promise<AppStoreVersionExperimentsV2Response> =>
      this.request<AppStoreVersionExperimentsV2Response, ErrorResponse>({
        path: `/v1/appStoreVersions/${id}/appStoreVersionExperimentsV2`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppStoreVersions
     * @name AppStoreVersionsAppStoreVersionLocalizationsGetToManyRelated
     * @request GET:/v1/appStoreVersions/{id}/appStoreVersionLocalizations
     * @secure
     */
    appStoreVersionLocalizationsGetToManyRelated: (
      id: string,
      query?: {
        /** filter by attribute 'locale' */
        "filter[locale]"?: string[];
        /** the fields to include for returned resources of type appScreenshotSets */
        "fields[appScreenshotSets]"?: (
          | "appCustomProductPageLocalization"
          | "appScreenshots"
          | "appStoreVersionExperimentTreatmentLocalization"
          | "appStoreVersionLocalization"
          | "screenshotDisplayType"
        )[];
        /** the fields to include for returned resources of type appStoreVersions */
        "fields[appStoreVersions]"?: (
          | "ageRatingDeclaration"
          | "alternativeDistributionPackage"
          | "app"
          | "appClipDefaultExperience"
          | "appStoreReviewDetail"
          | "appStoreState"
          | "appStoreVersionExperiments"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersionLocalizations"
          | "appStoreVersionPhasedRelease"
          | "appStoreVersionSubmission"
          | "appVersionState"
          | "build"
          | "copyright"
          | "createdDate"
          | "customerReviews"
          | "downloadable"
          | "earliestReleaseDate"
          | "platform"
          | "releaseType"
          | "reviewType"
          | "routingAppCoverage"
          | "versionString"
        )[];
        /** the fields to include for returned resources of type appPreviewSets */
        "fields[appPreviewSets]"?: (
          | "appCustomProductPageLocalization"
          | "appPreviews"
          | "appStoreVersionExperimentTreatmentLocalization"
          | "appStoreVersionLocalization"
          | "previewType"
        )[];
        /** the fields to include for returned resources of type appStoreVersionLocalizations */
        "fields[appStoreVersionLocalizations]"?: (
          | "appPreviewSets"
          | "appScreenshotSets"
          | "appStoreVersion"
          | "description"
          | "keywords"
          | "locale"
          | "marketingUrl"
          | "promotionalText"
          | "supportUrl"
          | "whatsNew"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /**
         * maximum number of related appScreenshotSets returned (when they are included)
         * @max 50
         */
        "limit[appScreenshotSets]"?: number;
        /**
         * maximum number of related appPreviewSets returned (when they are included)
         * @max 50
         */
        "limit[appPreviewSets]"?: number;
        /** comma-separated list of relationships to include */
        include?: ("appPreviewSets" | "appScreenshotSets" | "appStoreVersion")[];
      },
      params: RequestParams = {},
    ): Promise<AppStoreVersionLocalizationsResponse> =>
      this.request<AppStoreVersionLocalizationsResponse, ErrorResponse>({
        path: `/v1/appStoreVersions/${id}/appStoreVersionLocalizations`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppStoreVersions
     * @name AppStoreVersionsAppStoreVersionPhasedReleaseGetToOneRelated
     * @request GET:/v1/appStoreVersions/{id}/appStoreVersionPhasedRelease
     * @secure
     */
    appStoreVersionPhasedReleaseGetToOneRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type appStoreVersionPhasedReleases */
        "fields[appStoreVersionPhasedReleases]"?: (
          | "appStoreVersion"
          | "currentDayNumber"
          | "phasedReleaseState"
          | "startDate"
          | "totalPauseDuration"
        )[];
      },
      params: RequestParams = {},
    ): Promise<AppStoreVersionPhasedReleaseWithoutIncludesResponse> =>
      this.request<AppStoreVersionPhasedReleaseWithoutIncludesResponse, ErrorResponse>({
        path: `/v1/appStoreVersions/${id}/appStoreVersionPhasedRelease`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppStoreVersions
     * @name AppStoreVersionsAppStoreVersionSubmissionGetToOneRelated
     * @request GET:/v1/appStoreVersions/{id}/appStoreVersionSubmission
     * @deprecated
     * @secure
     */
    appStoreVersionSubmissionGetToOneRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type appStoreVersionSubmissions */
        "fields[appStoreVersionSubmissions]"?: "appStoreVersion"[];
        /** the fields to include for returned resources of type appStoreVersions */
        "fields[appStoreVersions]"?: (
          | "ageRatingDeclaration"
          | "alternativeDistributionPackage"
          | "app"
          | "appClipDefaultExperience"
          | "appStoreReviewDetail"
          | "appStoreState"
          | "appStoreVersionExperiments"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersionLocalizations"
          | "appStoreVersionPhasedRelease"
          | "appStoreVersionSubmission"
          | "appVersionState"
          | "build"
          | "copyright"
          | "createdDate"
          | "customerReviews"
          | "downloadable"
          | "earliestReleaseDate"
          | "platform"
          | "releaseType"
          | "reviewType"
          | "routingAppCoverage"
          | "versionString"
        )[];
        /** comma-separated list of relationships to include */
        include?: "appStoreVersion"[];
      },
      params: RequestParams = {},
    ): Promise<AppStoreVersionSubmissionResponse> =>
      this.request<AppStoreVersionSubmissionResponse, ErrorResponse>({
        path: `/v1/appStoreVersions/${id}/appStoreVersionSubmission`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppStoreVersions
     * @name AppStoreVersionsBuildGetToOneRelationship
     * @request GET:/v1/appStoreVersions/{id}/relationships/build
     * @secure
     */
    buildGetToOneRelationship: (id: string, params: RequestParams = {}): Promise<AppStoreVersionBuildLinkageResponse> =>
      this.request<AppStoreVersionBuildLinkageResponse, ErrorResponse>({
        path: `/v1/appStoreVersions/${id}/relationships/build`,
        method: "GET",
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppStoreVersions
     * @name AppStoreVersionsBuildUpdateToOneRelationship
     * @request PATCH:/v1/appStoreVersions/{id}/relationships/build
     * @secure
     */
    buildUpdateToOneRelationship: (
      id: string,
      data: AppStoreVersionBuildLinkageRequest,
      params: RequestParams = {},
    ): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/appStoreVersions/${id}/relationships/build`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppStoreVersions
     * @name AppStoreVersionsBuildGetToOneRelated
     * @request GET:/v1/appStoreVersions/{id}/build
     * @secure
     */
    buildGetToOneRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type builds */
        "fields[builds]"?: (
          | "app"
          | "appEncryptionDeclaration"
          | "appStoreVersion"
          | "betaAppReviewSubmission"
          | "betaBuildLocalizations"
          | "betaGroups"
          | "buildAudienceType"
          | "buildBetaDetail"
          | "buildBundles"
          | "computedMinMacOsVersion"
          | "diagnosticSignatures"
          | "expirationDate"
          | "expired"
          | "iconAssetToken"
          | "icons"
          | "individualTesters"
          | "lsMinimumSystemVersion"
          | "minOsVersion"
          | "perfPowerMetrics"
          | "preReleaseVersion"
          | "processingState"
          | "uploadedDate"
          | "usesNonExemptEncryption"
          | "version"
        )[];
      },
      params: RequestParams = {},
    ): Promise<BuildWithoutIncludesResponse> =>
      this.request<BuildWithoutIncludesResponse, ErrorResponse>({
        path: `/v1/appStoreVersions/${id}/build`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppStoreVersions
     * @name AppStoreVersionsCustomerReviewsGetToManyRelated
     * @request GET:/v1/appStoreVersions/{id}/customerReviews
     * @secure
     */
    customerReviewsGetToManyRelated: (
      id: string,
      query?: {
        /** filter by attribute 'rating' */
        "filter[rating]"?: string[];
        /** filter by attribute 'territory' */
        "filter[territory]"?: (
          | "ABW"
          | "AFG"
          | "AGO"
          | "AIA"
          | "ALB"
          | "AND"
          | "ANT"
          | "ARE"
          | "ARG"
          | "ARM"
          | "ASM"
          | "ATG"
          | "AUS"
          | "AUT"
          | "AZE"
          | "BDI"
          | "BEL"
          | "BEN"
          | "BES"
          | "BFA"
          | "BGD"
          | "BGR"
          | "BHR"
          | "BHS"
          | "BIH"
          | "BLR"
          | "BLZ"
          | "BMU"
          | "BOL"
          | "BRA"
          | "BRB"
          | "BRN"
          | "BTN"
          | "BWA"
          | "CAF"
          | "CAN"
          | "CHE"
          | "CHL"
          | "CHN"
          | "CIV"
          | "CMR"
          | "COD"
          | "COG"
          | "COK"
          | "COL"
          | "COM"
          | "CPV"
          | "CRI"
          | "CUB"
          | "CUW"
          | "CXR"
          | "CYM"
          | "CYP"
          | "CZE"
          | "DEU"
          | "DJI"
          | "DMA"
          | "DNK"
          | "DOM"
          | "DZA"
          | "ECU"
          | "EGY"
          | "ERI"
          | "ESP"
          | "EST"
          | "ETH"
          | "FIN"
          | "FJI"
          | "FLK"
          | "FRA"
          | "FRO"
          | "FSM"
          | "GAB"
          | "GBR"
          | "GEO"
          | "GGY"
          | "GHA"
          | "GIB"
          | "GIN"
          | "GLP"
          | "GMB"
          | "GNB"
          | "GNQ"
          | "GRC"
          | "GRD"
          | "GRL"
          | "GTM"
          | "GUF"
          | "GUM"
          | "GUY"
          | "HKG"
          | "HND"
          | "HRV"
          | "HTI"
          | "HUN"
          | "IDN"
          | "IMN"
          | "IND"
          | "IRL"
          | "IRQ"
          | "ISL"
          | "ISR"
          | "ITA"
          | "JAM"
          | "JEY"
          | "JOR"
          | "JPN"
          | "KAZ"
          | "KEN"
          | "KGZ"
          | "KHM"
          | "KIR"
          | "KNA"
          | "KOR"
          | "KWT"
          | "LAO"
          | "LBN"
          | "LBR"
          | "LBY"
          | "LCA"
          | "LIE"
          | "LKA"
          | "LSO"
          | "LTU"
          | "LUX"
          | "LVA"
          | "MAC"
          | "MAR"
          | "MCO"
          | "MDA"
          | "MDG"
          | "MDV"
          | "MEX"
          | "MHL"
          | "MKD"
          | "MLI"
          | "MLT"
          | "MMR"
          | "MNE"
          | "MNG"
          | "MNP"
          | "MOZ"
          | "MRT"
          | "MSR"
          | "MTQ"
          | "MUS"
          | "MWI"
          | "MYS"
          | "MYT"
          | "NAM"
          | "NCL"
          | "NER"
          | "NFK"
          | "NGA"
          | "NIC"
          | "NIU"
          | "NLD"
          | "NOR"
          | "NPL"
          | "NRU"
          | "NZL"
          | "OMN"
          | "PAK"
          | "PAN"
          | "PER"
          | "PHL"
          | "PLW"
          | "PNG"
          | "POL"
          | "PRI"
          | "PRT"
          | "PRY"
          | "PSE"
          | "PYF"
          | "QAT"
          | "REU"
          | "ROU"
          | "RUS"
          | "RWA"
          | "SAU"
          | "SEN"
          | "SGP"
          | "SHN"
          | "SLB"
          | "SLE"
          | "SLV"
          | "SMR"
          | "SOM"
          | "SPM"
          | "SRB"
          | "SSD"
          | "STP"
          | "SUR"
          | "SVK"
          | "SVN"
          | "SWE"
          | "SWZ"
          | "SXM"
          | "SYC"
          | "TCA"
          | "TCD"
          | "TGO"
          | "THA"
          | "TJK"
          | "TKM"
          | "TLS"
          | "TON"
          | "TTO"
          | "TUN"
          | "TUR"
          | "TUV"
          | "TWN"
          | "TZA"
          | "UGA"
          | "UKR"
          | "UMI"
          | "URY"
          | "USA"
          | "UZB"
          | "VAT"
          | "VCT"
          | "VEN"
          | "VGB"
          | "VIR"
          | "VNM"
          | "VUT"
          | "WLF"
          | "WSM"
          | "YEM"
          | "ZAF"
          | "ZMB"
          | "ZWE"
        )[];
        /** filter by publishedResponse */
        "exists[publishedResponse]"?: boolean;
        /** comma-separated list of sort expressions; resources will be sorted as specified */
        sort?: ("createdDate" | "-createdDate" | "rating" | "-rating")[];
        /** the fields to include for returned resources of type customerReviews */
        "fields[customerReviews]"?: (
          | "body"
          | "createdDate"
          | "rating"
          | "response"
          | "reviewerNickname"
          | "territory"
          | "title"
        )[];
        /** the fields to include for returned resources of type customerReviewResponses */
        "fields[customerReviewResponses]"?: ("lastModifiedDate" | "responseBody" | "review" | "state")[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /** comma-separated list of relationships to include */
        include?: "response"[];
      },
      params: RequestParams = {},
    ): Promise<CustomerReviewsResponse> =>
      this.request<CustomerReviewsResponse, ErrorResponse>({
        path: `/v1/appStoreVersions/${id}/customerReviews`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags AppStoreVersions
     * @name AppStoreVersionsRoutingAppCoverageGetToOneRelated
     * @request GET:/v1/appStoreVersions/{id}/routingAppCoverage
     * @secure
     */
    routingAppCoverageGetToOneRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type routingAppCoverages */
        "fields[routingAppCoverages]"?: (
          | "appStoreVersion"
          | "assetDeliveryState"
          | "fileName"
          | "fileSize"
          | "sourceFileChecksum"
          | "uploadOperations"
          | "uploaded"
        )[];
      },
      params: RequestParams = {},
    ): Promise<RoutingAppCoverageWithoutIncludesResponse> =>
      this.request<RoutingAppCoverageWithoutIncludesResponse, ErrorResponse>({
        path: `/v1/appStoreVersions/${id}/routingAppCoverage`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  apps = {
    /**
     * No description
     *
     * @tags Apps
     * @name AppsGetCollection
     * @request GET:/v1/apps
     * @secure
     */
    getCollection: (
      query?: {
        /** filter by attribute 'appStoreVersions.appStoreState' */
        filterAppStoreVersionsAppStoreState?: (
          | "ACCEPTED"
          | "DEVELOPER_REMOVED_FROM_SALE"
          | "DEVELOPER_REJECTED"
          | "IN_REVIEW"
          | "INVALID_BINARY"
          | "METADATA_REJECTED"
          | "PENDING_APPLE_RELEASE"
          | "PENDING_CONTRACT"
          | "PENDING_DEVELOPER_RELEASE"
          | "PREPARE_FOR_SUBMISSION"
          | "PREORDER_READY_FOR_SALE"
          | "PROCESSING_FOR_APP_STORE"
          | "READY_FOR_REVIEW"
          | "READY_FOR_SALE"
          | "REJECTED"
          | "REMOVED_FROM_SALE"
          | "WAITING_FOR_EXPORT_COMPLIANCE"
          | "WAITING_FOR_REVIEW"
          | "REPLACED_WITH_NEW_VERSION"
          | "NOT_APPLICABLE"
        )[];
        /** filter by attribute 'appStoreVersions.appVersionState' */
        filterAppStoreVersionsAppVersionState?: (
          | "ACCEPTED"
          | "DEVELOPER_REJECTED"
          | "IN_REVIEW"
          | "INVALID_BINARY"
          | "METADATA_REJECTED"
          | "PENDING_APPLE_RELEASE"
          | "PENDING_DEVELOPER_RELEASE"
          | "PREPARE_FOR_SUBMISSION"
          | "PROCESSING_FOR_DISTRIBUTION"
          | "READY_FOR_DISTRIBUTION"
          | "READY_FOR_REVIEW"
          | "REJECTED"
          | "REPLACED_WITH_NEW_VERSION"
          | "WAITING_FOR_EXPORT_COMPLIANCE"
          | "WAITING_FOR_REVIEW"
        )[];
        /** filter by attribute 'appStoreVersions.platform' */
        filterAppStoreVersionsPlatform?: ("IOS" | "MAC_OS" | "TV_OS" | "VISION_OS")[];
        /** filter by attribute 'bundleId' */
        "filter[bundleId]"?: string[];
        /** filter by attribute 'name' */
        "filter[name]"?: string[];
        /** filter by attribute 'sku' */
        "filter[sku]"?: string[];
        /** filter by id(s) of related 'appStoreVersions' */
        "filter[appStoreVersions]"?: string[];
        /** filter by id(s) */
        "filter[id]"?: string[];
        /**
         * filter by existence or non-existence of related 'gameCenterEnabledVersions'
         * @deprecated
         */
        "exists[gameCenterEnabledVersions]"?: boolean;
        /** comma-separated list of sort expressions; resources will be sorted as specified */
        sort?: ("bundleId" | "-bundleId" | "name" | "-name" | "sku" | "-sku")[];
        /** the fields to include for returned resources of type apps */
        "fields[apps]"?: (
          | "alternativeDistributionKey"
          | "analyticsReportRequests"
          | "appAvailability"
          | "appClips"
          | "appCustomProductPages"
          | "appEncryptionDeclarations"
          | "appEvents"
          | "appInfos"
          | "appPricePoints"
          | "appPriceSchedule"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersions"
          | "availableInNewTerritories"
          | "availableTerritories"
          | "betaAppLocalizations"
          | "betaAppReviewDetail"
          | "betaGroups"
          | "betaLicenseAgreement"
          | "betaTesters"
          | "builds"
          | "bundleId"
          | "ciProduct"
          | "contentRightsDeclaration"
          | "customerReviews"
          | "endUserLicenseAgreement"
          | "gameCenterDetail"
          | "gameCenterEnabledVersions"
          | "inAppPurchases"
          | "inAppPurchasesV2"
          | "isOrEverWasMadeForKids"
          | "marketplaceSearchDetail"
          | "name"
          | "perfPowerMetrics"
          | "preOrder"
          | "preReleaseVersions"
          | "pricePoints"
          | "prices"
          | "primaryLocale"
          | "promotedPurchases"
          | "reviewSubmissions"
          | "sku"
          | "subscriptionGracePeriod"
          | "subscriptionGroups"
          | "subscriptionStatusUrl"
          | "subscriptionStatusUrlForSandbox"
          | "subscriptionStatusUrlVersion"
          | "subscriptionStatusUrlVersionForSandbox"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /** comma-separated list of relationships to include */
        include?: (
          | "appClips"
          | "appCustomProductPages"
          | "appEncryptionDeclarations"
          | "appEvents"
          | "appInfos"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersions"
          | "availableTerritories"
          | "betaAppLocalizations"
          | "betaAppReviewDetail"
          | "betaGroups"
          | "betaLicenseAgreement"
          | "builds"
          | "ciProduct"
          | "endUserLicenseAgreement"
          | "gameCenterDetail"
          | "gameCenterEnabledVersions"
          | "inAppPurchases"
          | "inAppPurchasesV2"
          | "preOrder"
          | "preReleaseVersions"
          | "prices"
          | "promotedPurchases"
          | "reviewSubmissions"
          | "subscriptionGracePeriod"
          | "subscriptionGroups"
        )[];
        /** the fields to include for returned resources of type betaAppReviewDetails */
        "fields[betaAppReviewDetails]"?: (
          | "app"
          | "contactEmail"
          | "contactFirstName"
          | "contactLastName"
          | "contactPhone"
          | "demoAccountName"
          | "demoAccountPassword"
          | "demoAccountRequired"
          | "notes"
        )[];
        /** the fields to include for returned resources of type gameCenterDetails */
        "fields[gameCenterDetails]"?: (
          | "achievementReleases"
          | "app"
          | "arcadeEnabled"
          | "challengeEnabled"
          | "defaultGroupLeaderboard"
          | "defaultLeaderboard"
          | "gameCenterAchievements"
          | "gameCenterAppVersions"
          | "gameCenterGroup"
          | "gameCenterLeaderboardSets"
          | "gameCenterLeaderboards"
          | "leaderboardReleases"
          | "leaderboardSetReleases"
        )[];
        /** the fields to include for returned resources of type appPriceSchedules */
        "fields[appPriceSchedules]"?: ("app" | "automaticPrices" | "baseTerritory" | "manualPrices")[];
        /** the fields to include for returned resources of type ciProducts */
        "fields[ciProducts]"?: (
          | "additionalRepositories"
          | "app"
          | "buildRuns"
          | "bundleId"
          | "createdDate"
          | "name"
          | "primaryRepositories"
          | "productType"
          | "workflows"
        )[];
        /** the fields to include for returned resources of type alternativeDistributionKeys */
        "fields[alternativeDistributionKeys]"?: ("app" | "publicKey")[];
        /** the fields to include for returned resources of type reviewSubmissions */
        "fields[reviewSubmissions]"?: (
          | "app"
          | "appStoreVersionForReview"
          | "canceled"
          | "items"
          | "lastUpdatedByActor"
          | "platform"
          | "state"
          | "submitted"
          | "submittedByActor"
          | "submittedDate"
        )[];
        /** the fields to include for returned resources of type betaGroups */
        "fields[betaGroups]"?: (
          | "app"
          | "betaTesters"
          | "builds"
          | "createdDate"
          | "feedbackEnabled"
          | "hasAccessToAllBuilds"
          | "iosBuildsAvailableForAppleSiliconMac"
          | "isInternalGroup"
          | "name"
          | "publicLink"
          | "publicLinkEnabled"
          | "publicLinkId"
          | "publicLinkLimit"
          | "publicLinkLimitEnabled"
        )[];
        /** the fields to include for returned resources of type promotedPurchases */
        "fields[promotedPurchases]"?: (
          | "app"
          | "enabled"
          | "inAppPurchaseV2"
          | "promotionImages"
          | "state"
          | "subscription"
          | "visibleForAllUsers"
        )[];
        /**
         * the fields to include for returned resources of type appAvailabilities
         * @deprecated
         */
        "fields[appAvailabilities]"?: ("app" | "availableInNewTerritories" | "availableTerritories")[];
        /** the fields to include for returned resources of type customerReviews */
        "fields[customerReviews]"?: (
          | "body"
          | "createdDate"
          | "rating"
          | "response"
          | "reviewerNickname"
          | "territory"
          | "title"
        )[];
        /** the fields to include for returned resources of type appEvents */
        "fields[appEvents]"?: (
          | "app"
          | "archivedTerritorySchedules"
          | "badge"
          | "deepLink"
          | "eventState"
          | "localizations"
          | "primaryLocale"
          | "priority"
          | "purchaseRequirement"
          | "purpose"
          | "referenceName"
          | "territorySchedules"
        )[];
        /** the fields to include for returned resources of type builds */
        "fields[builds]"?: (
          | "app"
          | "appEncryptionDeclaration"
          | "appStoreVersion"
          | "betaAppReviewSubmission"
          | "betaBuildLocalizations"
          | "betaGroups"
          | "buildAudienceType"
          | "buildBetaDetail"
          | "buildBundles"
          | "computedMinMacOsVersion"
          | "diagnosticSignatures"
          | "expirationDate"
          | "expired"
          | "iconAssetToken"
          | "icons"
          | "individualTesters"
          | "lsMinimumSystemVersion"
          | "minOsVersion"
          | "perfPowerMetrics"
          | "preReleaseVersion"
          | "processingState"
          | "uploadedDate"
          | "usesNonExemptEncryption"
          | "version"
        )[];
        /** the fields to include for returned resources of type betaLicenseAgreements */
        "fields[betaLicenseAgreements]"?: ("agreementText" | "app")[];
        /** the fields to include for returned resources of type marketplaceSearchDetails */
        "fields[marketplaceSearchDetails]"?: ("app" | "catalogUrl")[];
        /** the fields to include for returned resources of type appClips */
        "fields[appClips]"?: ("app" | "appClipAdvancedExperiences" | "appClipDefaultExperiences" | "bundleId")[];
        /** the fields to include for returned resources of type appInfos */
        "fields[appInfos]"?: (
          | "ageRatingDeclaration"
          | "app"
          | "appInfoLocalizations"
          | "appStoreAgeRating"
          | "appStoreState"
          | "brazilAgeRating"
          | "brazilAgeRatingV2"
          | "kidsAgeBand"
          | "primaryCategory"
          | "primarySubcategoryOne"
          | "primarySubcategoryTwo"
          | "secondaryCategory"
          | "secondarySubcategoryOne"
          | "secondarySubcategoryTwo"
          | "state"
        )[];
        /** the fields to include for returned resources of type betaAppLocalizations */
        "fields[betaAppLocalizations]"?: (
          | "app"
          | "description"
          | "feedbackEmail"
          | "locale"
          | "marketingUrl"
          | "privacyPolicyUrl"
          | "tvOsPrivacyPolicy"
        )[];
        /** the fields to include for returned resources of type appPricePoints */
        "fields[appPricePoints]"?: (
          | "app"
          | "customerPrice"
          | "equalizations"
          | "priceTier"
          | "proceeds"
          | "territory"
        )[];
        /** the fields to include for returned resources of type inAppPurchases */
        "fields[inAppPurchases]"?: (
          | "app"
          | "appStoreReviewScreenshot"
          | "apps"
          | "content"
          | "contentHosting"
          | "familySharable"
          | "iapPriceSchedule"
          | "inAppPurchaseAvailability"
          | "inAppPurchaseLocalizations"
          | "inAppPurchaseType"
          | "name"
          | "pricePoints"
          | "productId"
          | "promotedPurchase"
          | "referenceName"
          | "reviewNote"
          | "state"
        )[];
        /** the fields to include for returned resources of type preReleaseVersions */
        "fields[preReleaseVersions]"?: ("app" | "builds" | "platform" | "version")[];
        /** the fields to include for returned resources of type subscriptionGroups */
        "fields[subscriptionGroups]"?: ("app" | "referenceName" | "subscriptionGroupLocalizations" | "subscriptions")[];
        /** the fields to include for returned resources of type analyticsReportRequests */
        "fields[analyticsReportRequests]"?: ("accessType" | "app" | "reports" | "stoppedDueToInactivity")[];
        /**
         * the fields to include for returned resources of type appPrices
         * @deprecated
         */
        "fields[appPrices]"?: ("app" | "priceTier")[];
        /**
         * the fields to include for returned resources of type appPreOrders
         * @deprecated
         */
        "fields[appPreOrders]"?: ("app" | "appReleaseDate" | "preOrderAvailableDate")[];
        /** the fields to include for returned resources of type appStoreVersionExperiments */
        "fields[appStoreVersionExperiments]"?: (
          | "app"
          | "appStoreVersionExperimentTreatments"
          | "controlVersions"
          | "endDate"
          | "latestControlVersion"
          | "name"
          | "platform"
          | "reviewRequired"
          | "startDate"
          | "started"
          | "state"
          | "trafficProportion"
        )[];
        /**
         * the fields to include for returned resources of type gameCenterEnabledVersions
         * @deprecated
         */
        "fields[gameCenterEnabledVersions]"?: (
          | "app"
          | "compatibleVersions"
          | "iconAsset"
          | "platform"
          | "versionString"
        )[];
        /** the fields to include for returned resources of type subscriptionGracePeriods */
        "fields[subscriptionGracePeriods]"?: ("duration" | "optIn" | "renewalType" | "sandboxOptIn")[];
        /** the fields to include for returned resources of type endUserLicenseAgreements */
        "fields[endUserLicenseAgreements]"?: ("agreementText" | "app" | "territories")[];
        /** the fields to include for returned resources of type appStoreVersions */
        "fields[appStoreVersions]"?: (
          | "ageRatingDeclaration"
          | "alternativeDistributionPackage"
          | "app"
          | "appClipDefaultExperience"
          | "appStoreReviewDetail"
          | "appStoreState"
          | "appStoreVersionExperiments"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersionLocalizations"
          | "appStoreVersionPhasedRelease"
          | "appStoreVersionSubmission"
          | "appVersionState"
          | "build"
          | "copyright"
          | "createdDate"
          | "customerReviews"
          | "downloadable"
          | "earliestReleaseDate"
          | "platform"
          | "releaseType"
          | "reviewType"
          | "routingAppCoverage"
          | "versionString"
        )[];
        /** the fields to include for returned resources of type appCustomProductPages */
        "fields[appCustomProductPages]"?: (
          | "app"
          | "appCustomProductPageVersions"
          | "appStoreVersionTemplate"
          | "customProductPageTemplate"
          | "name"
          | "url"
          | "visible"
        )[];
        /** the fields to include for returned resources of type appEncryptionDeclarations */
        "fields[appEncryptionDeclarations]"?: (
          | "app"
          | "appDescription"
          | "appEncryptionDeclarationDocument"
          | "appEncryptionDeclarationState"
          | "availableOnFrenchStore"
          | "builds"
          | "codeValue"
          | "containsProprietaryCryptography"
          | "containsThirdPartyCryptography"
          | "createdDate"
          | "documentName"
          | "documentType"
          | "documentUrl"
          | "exempt"
          | "platform"
          | "uploadedDate"
          | "usesEncryption"
        )[];
        /**
         * the fields to include for returned resources of type territories
         * @deprecated
         */
        "fields[territories]"?: "currency"[];
        /** the fields to include for returned resources of type perfPowerMetrics */
        "fields[perfPowerMetrics]"?: ("deviceType" | "metricType" | "platform")[];
        /**
         * maximum number of related appClips returned (when they are included)
         * @max 50
         */
        "limit[appClips]"?: number;
        /**
         * maximum number of related appCustomProductPages returned (when they are included)
         * @max 50
         */
        "limit[appCustomProductPages]"?: number;
        /**
         * maximum number of related appEncryptionDeclarations returned (when they are included)
         * @max 50
         */
        "limit[appEncryptionDeclarations]"?: number;
        /**
         * maximum number of related appEvents returned (when they are included)
         * @max 50
         */
        "limit[appEvents]"?: number;
        /**
         * maximum number of related appInfos returned (when they are included)
         * @max 50
         */
        "limit[appInfos]"?: number;
        /**
         * maximum number of related appStoreVersionExperimentsV2 returned (when they are included)
         * @max 50
         */
        "limit[appStoreVersionExperimentsV2]"?: number;
        /**
         * maximum number of related appStoreVersions returned (when they are included)
         * @max 50
         */
        "limit[appStoreVersions]"?: number;
        /**
         * maximum number of related availableTerritories returned (when they are included)
         * @max 50
         */
        "limit[availableTerritories]"?: number;
        /**
         * maximum number of related betaAppLocalizations returned (when they are included)
         * @max 50
         */
        "limit[betaAppLocalizations]"?: number;
        /**
         * maximum number of related betaGroups returned (when they are included)
         * @max 50
         */
        "limit[betaGroups]"?: number;
        /**
         * maximum number of related builds returned (when they are included)
         * @max 50
         */
        "limit[builds]"?: number;
        /**
         * maximum number of related gameCenterEnabledVersions returned (when they are included)
         * @deprecated
         * @max 50
         */
        "limit[gameCenterEnabledVersions]"?: number;
        /**
         * maximum number of related inAppPurchases returned (when they are included)
         * @deprecated
         * @max 50
         */
        "limit[inAppPurchases]"?: number;
        /**
         * maximum number of related inAppPurchasesV2 returned (when they are included)
         * @max 50
         */
        "limit[inAppPurchasesV2]"?: number;
        /**
         * maximum number of related preReleaseVersions returned (when they are included)
         * @max 50
         */
        "limit[preReleaseVersions]"?: number;
        /**
         * maximum number of related prices returned (when they are included)
         * @deprecated
         * @max 50
         */
        "limit[prices]"?: number;
        /**
         * maximum number of related promotedPurchases returned (when they are included)
         * @max 50
         */
        "limit[promotedPurchases]"?: number;
        /**
         * maximum number of related reviewSubmissions returned (when they are included)
         * @max 50
         */
        "limit[reviewSubmissions]"?: number;
        /**
         * maximum number of related subscriptionGroups returned (when they are included)
         * @max 50
         */
        "limit[subscriptionGroups]"?: number;
      },
      params: RequestParams = {},
    ): Promise<AppsResponse> =>
      this.request<AppsResponse, ErrorResponse>({
        path: `/v1/apps`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Apps
     * @name AppsGetInstance
     * @request GET:/v1/apps/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type apps */
        "fields[apps]"?: (
          | "alternativeDistributionKey"
          | "analyticsReportRequests"
          | "appAvailability"
          | "appClips"
          | "appCustomProductPages"
          | "appEncryptionDeclarations"
          | "appEvents"
          | "appInfos"
          | "appPricePoints"
          | "appPriceSchedule"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersions"
          | "availableInNewTerritories"
          | "availableTerritories"
          | "betaAppLocalizations"
          | "betaAppReviewDetail"
          | "betaGroups"
          | "betaLicenseAgreement"
          | "betaTesters"
          | "builds"
          | "bundleId"
          | "ciProduct"
          | "contentRightsDeclaration"
          | "customerReviews"
          | "endUserLicenseAgreement"
          | "gameCenterDetail"
          | "gameCenterEnabledVersions"
          | "inAppPurchases"
          | "inAppPurchasesV2"
          | "isOrEverWasMadeForKids"
          | "marketplaceSearchDetail"
          | "name"
          | "perfPowerMetrics"
          | "preOrder"
          | "preReleaseVersions"
          | "pricePoints"
          | "prices"
          | "primaryLocale"
          | "promotedPurchases"
          | "reviewSubmissions"
          | "sku"
          | "subscriptionGracePeriod"
          | "subscriptionGroups"
          | "subscriptionStatusUrl"
          | "subscriptionStatusUrlForSandbox"
          | "subscriptionStatusUrlVersion"
          | "subscriptionStatusUrlVersionForSandbox"
        )[];
        /** comma-separated list of relationships to include */
        include?: (
          | "appClips"
          | "appCustomProductPages"
          | "appEncryptionDeclarations"
          | "appEvents"
          | "appInfos"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersions"
          | "availableTerritories"
          | "betaAppLocalizations"
          | "betaAppReviewDetail"
          | "betaGroups"
          | "betaLicenseAgreement"
          | "builds"
          | "ciProduct"
          | "endUserLicenseAgreement"
          | "gameCenterDetail"
          | "gameCenterEnabledVersions"
          | "inAppPurchases"
          | "inAppPurchasesV2"
          | "preOrder"
          | "preReleaseVersions"
          | "prices"
          | "promotedPurchases"
          | "reviewSubmissions"
          | "subscriptionGracePeriod"
          | "subscriptionGroups"
        )[];
        /** the fields to include for returned resources of type betaAppReviewDetails */
        "fields[betaAppReviewDetails]"?: (
          | "app"
          | "contactEmail"
          | "contactFirstName"
          | "contactLastName"
          | "contactPhone"
          | "demoAccountName"
          | "demoAccountPassword"
          | "demoAccountRequired"
          | "notes"
        )[];
        /** the fields to include for returned resources of type gameCenterDetails */
        "fields[gameCenterDetails]"?: (
          | "achievementReleases"
          | "app"
          | "arcadeEnabled"
          | "challengeEnabled"
          | "defaultGroupLeaderboard"
          | "defaultLeaderboard"
          | "gameCenterAchievements"
          | "gameCenterAppVersions"
          | "gameCenterGroup"
          | "gameCenterLeaderboardSets"
          | "gameCenterLeaderboards"
          | "leaderboardReleases"
          | "leaderboardSetReleases"
        )[];
        /** the fields to include for returned resources of type appPriceSchedules */
        "fields[appPriceSchedules]"?: ("app" | "automaticPrices" | "baseTerritory" | "manualPrices")[];
        /** the fields to include for returned resources of type ciProducts */
        "fields[ciProducts]"?: (
          | "additionalRepositories"
          | "app"
          | "buildRuns"
          | "bundleId"
          | "createdDate"
          | "name"
          | "primaryRepositories"
          | "productType"
          | "workflows"
        )[];
        /** the fields to include for returned resources of type alternativeDistributionKeys */
        "fields[alternativeDistributionKeys]"?: ("app" | "publicKey")[];
        /** the fields to include for returned resources of type reviewSubmissions */
        "fields[reviewSubmissions]"?: (
          | "app"
          | "appStoreVersionForReview"
          | "canceled"
          | "items"
          | "lastUpdatedByActor"
          | "platform"
          | "state"
          | "submitted"
          | "submittedByActor"
          | "submittedDate"
        )[];
        /** the fields to include for returned resources of type betaGroups */
        "fields[betaGroups]"?: (
          | "app"
          | "betaTesters"
          | "builds"
          | "createdDate"
          | "feedbackEnabled"
          | "hasAccessToAllBuilds"
          | "iosBuildsAvailableForAppleSiliconMac"
          | "isInternalGroup"
          | "name"
          | "publicLink"
          | "publicLinkEnabled"
          | "publicLinkId"
          | "publicLinkLimit"
          | "publicLinkLimitEnabled"
        )[];
        /** the fields to include for returned resources of type promotedPurchases */
        "fields[promotedPurchases]"?: (
          | "app"
          | "enabled"
          | "inAppPurchaseV2"
          | "promotionImages"
          | "state"
          | "subscription"
          | "visibleForAllUsers"
        )[];
        /**
         * the fields to include for returned resources of type appAvailabilities
         * @deprecated
         */
        "fields[appAvailabilities]"?: ("app" | "availableInNewTerritories" | "availableTerritories")[];
        /** the fields to include for returned resources of type customerReviews */
        "fields[customerReviews]"?: (
          | "body"
          | "createdDate"
          | "rating"
          | "response"
          | "reviewerNickname"
          | "territory"
          | "title"
        )[];
        /** the fields to include for returned resources of type appEvents */
        "fields[appEvents]"?: (
          | "app"
          | "archivedTerritorySchedules"
          | "badge"
          | "deepLink"
          | "eventState"
          | "localizations"
          | "primaryLocale"
          | "priority"
          | "purchaseRequirement"
          | "purpose"
          | "referenceName"
          | "territorySchedules"
        )[];
        /** the fields to include for returned resources of type builds */
        "fields[builds]"?: (
          | "app"
          | "appEncryptionDeclaration"
          | "appStoreVersion"
          | "betaAppReviewSubmission"
          | "betaBuildLocalizations"
          | "betaGroups"
          | "buildAudienceType"
          | "buildBetaDetail"
          | "buildBundles"
          | "computedMinMacOsVersion"
          | "diagnosticSignatures"
          | "expirationDate"
          | "expired"
          | "iconAssetToken"
          | "icons"
          | "individualTesters"
          | "lsMinimumSystemVersion"
          | "minOsVersion"
          | "perfPowerMetrics"
          | "preReleaseVersion"
          | "processingState"
          | "uploadedDate"
          | "usesNonExemptEncryption"
          | "version"
        )[];
        /** the fields to include for returned resources of type betaLicenseAgreements */
        "fields[betaLicenseAgreements]"?: ("agreementText" | "app")[];
        /** the fields to include for returned resources of type marketplaceSearchDetails */
        "fields[marketplaceSearchDetails]"?: ("app" | "catalogUrl")[];
        /** the fields to include for returned resources of type appClips */
        "fields[appClips]"?: ("app" | "appClipAdvancedExperiences" | "appClipDefaultExperiences" | "bundleId")[];
        /** the fields to include for returned resources of type appInfos */
        "fields[appInfos]"?: (
          | "ageRatingDeclaration"
          | "app"
          | "appInfoLocalizations"
          | "appStoreAgeRating"
          | "appStoreState"
          | "brazilAgeRating"
          | "brazilAgeRatingV2"
          | "kidsAgeBand"
          | "primaryCategory"
          | "primarySubcategoryOne"
          | "primarySubcategoryTwo"
          | "secondaryCategory"
          | "secondarySubcategoryOne"
          | "secondarySubcategoryTwo"
          | "state"
        )[];
        /** the fields to include for returned resources of type betaAppLocalizations */
        "fields[betaAppLocalizations]"?: (
          | "app"
          | "description"
          | "feedbackEmail"
          | "locale"
          | "marketingUrl"
          | "privacyPolicyUrl"
          | "tvOsPrivacyPolicy"
        )[];
        /** the fields to include for returned resources of type appPricePoints */
        "fields[appPricePoints]"?: (
          | "app"
          | "customerPrice"
          | "equalizations"
          | "priceTier"
          | "proceeds"
          | "territory"
        )[];
        /** the fields to include for returned resources of type inAppPurchases */
        "fields[inAppPurchases]"?: (
          | "app"
          | "appStoreReviewScreenshot"
          | "apps"
          | "content"
          | "contentHosting"
          | "familySharable"
          | "iapPriceSchedule"
          | "inAppPurchaseAvailability"
          | "inAppPurchaseLocalizations"
          | "inAppPurchaseType"
          | "name"
          | "pricePoints"
          | "productId"
          | "promotedPurchase"
          | "referenceName"
          | "reviewNote"
          | "state"
        )[];
        /** the fields to include for returned resources of type preReleaseVersions */
        "fields[preReleaseVersions]"?: ("app" | "builds" | "platform" | "version")[];
        /** the fields to include for returned resources of type subscriptionGroups */
        "fields[subscriptionGroups]"?: ("app" | "referenceName" | "subscriptionGroupLocalizations" | "subscriptions")[];
        /** the fields to include for returned resources of type analyticsReportRequests */
        "fields[analyticsReportRequests]"?: ("accessType" | "app" | "reports" | "stoppedDueToInactivity")[];
        /**
         * the fields to include for returned resources of type appPrices
         * @deprecated
         */
        "fields[appPrices]"?: ("app" | "priceTier")[];
        /**
         * the fields to include for returned resources of type appPreOrders
         * @deprecated
         */
        "fields[appPreOrders]"?: ("app" | "appReleaseDate" | "preOrderAvailableDate")[];
        /** the fields to include for returned resources of type appStoreVersionExperiments */
        "fields[appStoreVersionExperiments]"?: (
          | "app"
          | "appStoreVersionExperimentTreatments"
          | "controlVersions"
          | "endDate"
          | "latestControlVersion"
          | "name"
          | "platform"
          | "reviewRequired"
          | "startDate"
          | "started"
          | "state"
          | "trafficProportion"
        )[];
        /**
         * the fields to include for returned resources of type gameCenterEnabledVersions
         * @deprecated
         */
        "fields[gameCenterEnabledVersions]"?: (
          | "app"
          | "compatibleVersions"
          | "iconAsset"
          | "platform"
          | "versionString"
        )[];
        /** the fields to include for returned resources of type subscriptionGracePeriods */
        "fields[subscriptionGracePeriods]"?: ("duration" | "optIn" | "renewalType" | "sandboxOptIn")[];
        /** the fields to include for returned resources of type endUserLicenseAgreements */
        "fields[endUserLicenseAgreements]"?: ("agreementText" | "app" | "territories")[];
        /** the fields to include for returned resources of type appStoreVersions */
        "fields[appStoreVersions]"?: (
          | "ageRatingDeclaration"
          | "alternativeDistributionPackage"
          | "app"
          | "appClipDefaultExperience"
          | "appStoreReviewDetail"
          | "appStoreState"
          | "appStoreVersionExperiments"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersionLocalizations"
          | "appStoreVersionPhasedRelease"
          | "appStoreVersionSubmission"
          | "appVersionState"
          | "build"
          | "copyright"
          | "createdDate"
          | "customerReviews"
          | "downloadable"
          | "earliestReleaseDate"
          | "platform"
          | "releaseType"
          | "reviewType"
          | "routingAppCoverage"
          | "versionString"
        )[];
        /** the fields to include for returned resources of type appCustomProductPages */
        "fields[appCustomProductPages]"?: (
          | "app"
          | "appCustomProductPageVersions"
          | "appStoreVersionTemplate"
          | "customProductPageTemplate"
          | "name"
          | "url"
          | "visible"
        )[];
        /** the fields to include for returned resources of type appEncryptionDeclarations */
        "fields[appEncryptionDeclarations]"?: (
          | "app"
          | "appDescription"
          | "appEncryptionDeclarationDocument"
          | "appEncryptionDeclarationState"
          | "availableOnFrenchStore"
          | "builds"
          | "codeValue"
          | "containsProprietaryCryptography"
          | "containsThirdPartyCryptography"
          | "createdDate"
          | "documentName"
          | "documentType"
          | "documentUrl"
          | "exempt"
          | "platform"
          | "uploadedDate"
          | "usesEncryption"
        )[];
        /**
         * the fields to include for returned resources of type territories
         * @deprecated
         */
        "fields[territories]"?: "currency"[];
        /** the fields to include for returned resources of type perfPowerMetrics */
        "fields[perfPowerMetrics]"?: ("deviceType" | "metricType" | "platform")[];
        /**
         * maximum number of related appClips returned (when they are included)
         * @max 50
         */
        "limit[appClips]"?: number;
        /**
         * maximum number of related appCustomProductPages returned (when they are included)
         * @max 50
         */
        "limit[appCustomProductPages]"?: number;
        /**
         * maximum number of related appEncryptionDeclarations returned (when they are included)
         * @max 50
         */
        "limit[appEncryptionDeclarations]"?: number;
        /**
         * maximum number of related appEvents returned (when they are included)
         * @max 50
         */
        "limit[appEvents]"?: number;
        /**
         * maximum number of related appInfos returned (when they are included)
         * @max 50
         */
        "limit[appInfos]"?: number;
        /**
         * maximum number of related appStoreVersionExperimentsV2 returned (when they are included)
         * @max 50
         */
        "limit[appStoreVersionExperimentsV2]"?: number;
        /**
         * maximum number of related appStoreVersions returned (when they are included)
         * @max 50
         */
        "limit[appStoreVersions]"?: number;
        /**
         * maximum number of related availableTerritories returned (when they are included)
         * @max 50
         */
        "limit[availableTerritories]"?: number;
        /**
         * maximum number of related betaAppLocalizations returned (when they are included)
         * @max 50
         */
        "limit[betaAppLocalizations]"?: number;
        /**
         * maximum number of related betaGroups returned (when they are included)
         * @max 50
         */
        "limit[betaGroups]"?: number;
        /**
         * maximum number of related builds returned (when they are included)
         * @max 50
         */
        "limit[builds]"?: number;
        /**
         * maximum number of related gameCenterEnabledVersions returned (when they are included)
         * @deprecated
         * @max 50
         */
        "limit[gameCenterEnabledVersions]"?: number;
        /**
         * maximum number of related inAppPurchases returned (when they are included)
         * @deprecated
         * @max 50
         */
        "limit[inAppPurchases]"?: number;
        /**
         * maximum number of related inAppPurchasesV2 returned (when they are included)
         * @max 50
         */
        "limit[inAppPurchasesV2]"?: number;
        /**
         * maximum number of related preReleaseVersions returned (when they are included)
         * @max 50
         */
        "limit[preReleaseVersions]"?: number;
        /**
         * maximum number of related prices returned (when they are included)
         * @deprecated
         * @max 50
         */
        "limit[prices]"?: number;
        /**
         * maximum number of related promotedPurchases returned (when they are included)
         * @max 50
         */
        "limit[promotedPurchases]"?: number;
        /**
         * maximum number of related reviewSubmissions returned (when they are included)
         * @max 50
         */
        "limit[reviewSubmissions]"?: number;
        /**
         * maximum number of related subscriptionGroups returned (when they are included)
         * @max 50
         */
        "limit[subscriptionGroups]"?: number;
      },
      params: RequestParams = {},
    ): Promise<AppResponse> =>
      this.request<AppResponse, ErrorResponse>({
        path: `/v1/apps/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Apps
     * @name AppsUpdateInstance
     * @request PATCH:/v1/apps/{id}
     * @secure
     */
    updateInstance: (id: string, data: AppUpdateRequest, params: RequestParams = {}): Promise<AppResponse> =>
      this.request<AppResponse, ErrorResponse>({
        path: `/v1/apps/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Apps
     * @name AppsAlternativeDistributionKeyGetToOneRelated
     * @request GET:/v1/apps/{id}/alternativeDistributionKey
     * @secure
     */
    alternativeDistributionKeyGetToOneRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type alternativeDistributionKeys */
        "fields[alternativeDistributionKeys]"?: ("app" | "publicKey")[];
      },
      params: RequestParams = {},
    ): Promise<AlternativeDistributionKeyResponse> =>
      this.request<AlternativeDistributionKeyResponse, ErrorResponse>({
        path: `/v1/apps/${id}/alternativeDistributionKey`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Apps
     * @name AppsAnalyticsReportRequestsGetToManyRelated
     * @request GET:/v1/apps/{id}/analyticsReportRequests
     * @secure
     */
    analyticsReportRequestsGetToManyRelated: (
      id: string,
      query?: {
        /** filter by attribute 'accessType' */
        "filter[accessType]"?: ("ONE_TIME_SNAPSHOT" | "ONGOING")[];
        /** the fields to include for returned resources of type analyticsReportRequests */
        "fields[analyticsReportRequests]"?: ("accessType" | "app" | "reports" | "stoppedDueToInactivity")[];
        /** the fields to include for returned resources of type analyticsReports */
        "fields[analyticsReports]"?: ("category" | "instances" | "name")[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /**
         * maximum number of related reports returned (when they are included)
         * @max 50
         */
        "limit[reports]"?: number;
        /** comma-separated list of relationships to include */
        include?: "reports"[];
      },
      params: RequestParams = {},
    ): Promise<AnalyticsReportRequestsResponse> =>
      this.request<AnalyticsReportRequestsResponse, ErrorResponse>({
        path: `/v1/apps/${id}/analyticsReportRequests`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Apps
     * @name AppsAppAvailabilityGetToOneRelated
     * @request GET:/v1/apps/{id}/appAvailability
     * @deprecated
     * @secure
     */
    appAvailabilityGetToOneRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type appAvailabilities */
        "fields[appAvailabilities]"?: ("app" | "availableInNewTerritories" | "availableTerritories")[];
        /** the fields to include for returned resources of type apps */
        "fields[apps]"?: (
          | "alternativeDistributionKey"
          | "analyticsReportRequests"
          | "appAvailability"
          | "appClips"
          | "appCustomProductPages"
          | "appEncryptionDeclarations"
          | "appEvents"
          | "appInfos"
          | "appPricePoints"
          | "appPriceSchedule"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersions"
          | "availableInNewTerritories"
          | "availableTerritories"
          | "betaAppLocalizations"
          | "betaAppReviewDetail"
          | "betaGroups"
          | "betaLicenseAgreement"
          | "betaTesters"
          | "builds"
          | "bundleId"
          | "ciProduct"
          | "contentRightsDeclaration"
          | "customerReviews"
          | "endUserLicenseAgreement"
          | "gameCenterDetail"
          | "gameCenterEnabledVersions"
          | "inAppPurchases"
          | "inAppPurchasesV2"
          | "isOrEverWasMadeForKids"
          | "marketplaceSearchDetail"
          | "name"
          | "perfPowerMetrics"
          | "preOrder"
          | "preReleaseVersions"
          | "pricePoints"
          | "prices"
          | "primaryLocale"
          | "promotedPurchases"
          | "reviewSubmissions"
          | "sku"
          | "subscriptionGracePeriod"
          | "subscriptionGroups"
          | "subscriptionStatusUrl"
          | "subscriptionStatusUrlForSandbox"
          | "subscriptionStatusUrlVersion"
          | "subscriptionStatusUrlVersionForSandbox"
        )[];
        /** the fields to include for returned resources of type territories */
        "fields[territories]"?: "currency"[];
        /**
         * maximum number of related availableTerritories returned (when they are included)
         * @max 50
         */
        "limit[availableTerritories]"?: number;
        /** comma-separated list of relationships to include */
        include?: ("app" | "availableTerritories")[];
      },
      params: RequestParams = {},
    ): Promise<AppAvailabilityResponse> =>
      this.request<AppAvailabilityResponse, ErrorResponse>({
        path: `/v1/apps/${id}/appAvailability`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Apps
     * @name AppsAppClipsGetToManyRelated
     * @request GET:/v1/apps/{id}/appClips
     * @secure
     */
    appClipsGetToManyRelated: (
      id: string,
      query?: {
        /** filter by attribute 'bundleId' */
        "filter[bundleId]"?: string[];
        /** the fields to include for returned resources of type appClips */
        "fields[appClips]"?: ("app" | "appClipAdvancedExperiences" | "appClipDefaultExperiences" | "bundleId")[];
        /** the fields to include for returned resources of type apps */
        "fields[apps]"?: (
          | "alternativeDistributionKey"
          | "analyticsReportRequests"
          | "appAvailability"
          | "appClips"
          | "appCustomProductPages"
          | "appEncryptionDeclarations"
          | "appEvents"
          | "appInfos"
          | "appPricePoints"
          | "appPriceSchedule"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersions"
          | "availableInNewTerritories"
          | "availableTerritories"
          | "betaAppLocalizations"
          | "betaAppReviewDetail"
          | "betaGroups"
          | "betaLicenseAgreement"
          | "betaTesters"
          | "builds"
          | "bundleId"
          | "ciProduct"
          | "contentRightsDeclaration"
          | "customerReviews"
          | "endUserLicenseAgreement"
          | "gameCenterDetail"
          | "gameCenterEnabledVersions"
          | "inAppPurchases"
          | "inAppPurchasesV2"
          | "isOrEverWasMadeForKids"
          | "marketplaceSearchDetail"
          | "name"
          | "perfPowerMetrics"
          | "preOrder"
          | "preReleaseVersions"
          | "pricePoints"
          | "prices"
          | "primaryLocale"
          | "promotedPurchases"
          | "reviewSubmissions"
          | "sku"
          | "subscriptionGracePeriod"
          | "subscriptionGroups"
          | "subscriptionStatusUrl"
          | "subscriptionStatusUrlForSandbox"
          | "subscriptionStatusUrlVersion"
          | "subscriptionStatusUrlVersionForSandbox"
        )[];
        /** the fields to include for returned resources of type appClipDefaultExperiences */
        "fields[appClipDefaultExperiences]"?: (
          | "action"
          | "appClip"
          | "appClipAppStoreReviewDetail"
          | "appClipDefaultExperienceLocalizations"
          | "appClipDefaultExperienceTemplate"
          | "releaseWithAppStoreVersion"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /**
         * maximum number of related appClipDefaultExperiences returned (when they are included)
         * @max 50
         */
        "limit[appClipDefaultExperiences]"?: number;
        /** comma-separated list of relationships to include */
        include?: ("app" | "appClipDefaultExperiences")[];
      },
      params: RequestParams = {},
    ): Promise<AppClipsResponse> =>
      this.request<AppClipsResponse, ErrorResponse>({
        path: `/v1/apps/${id}/appClips`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Apps
     * @name AppsAppCustomProductPagesGetToManyRelated
     * @request GET:/v1/apps/{id}/appCustomProductPages
     * @secure
     */
    appCustomProductPagesGetToManyRelated: (
      id: string,
      query?: {
        /** filter by attribute 'visible' */
        "filter[visible]"?: string[];
        /** the fields to include for returned resources of type appCustomProductPages */
        "fields[appCustomProductPages]"?: (
          | "app"
          | "appCustomProductPageVersions"
          | "appStoreVersionTemplate"
          | "customProductPageTemplate"
          | "name"
          | "url"
          | "visible"
        )[];
        /** the fields to include for returned resources of type appCustomProductPageVersions */
        "fields[appCustomProductPageVersions]"?: (
          | "appCustomProductPage"
          | "appCustomProductPageLocalizations"
          | "state"
          | "version"
        )[];
        /** the fields to include for returned resources of type apps */
        "fields[apps]"?: (
          | "alternativeDistributionKey"
          | "analyticsReportRequests"
          | "appAvailability"
          | "appClips"
          | "appCustomProductPages"
          | "appEncryptionDeclarations"
          | "appEvents"
          | "appInfos"
          | "appPricePoints"
          | "appPriceSchedule"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersions"
          | "availableInNewTerritories"
          | "availableTerritories"
          | "betaAppLocalizations"
          | "betaAppReviewDetail"
          | "betaGroups"
          | "betaLicenseAgreement"
          | "betaTesters"
          | "builds"
          | "bundleId"
          | "ciProduct"
          | "contentRightsDeclaration"
          | "customerReviews"
          | "endUserLicenseAgreement"
          | "gameCenterDetail"
          | "gameCenterEnabledVersions"
          | "inAppPurchases"
          | "inAppPurchasesV2"
          | "isOrEverWasMadeForKids"
          | "marketplaceSearchDetail"
          | "name"
          | "perfPowerMetrics"
          | "preOrder"
          | "preReleaseVersions"
          | "pricePoints"
          | "prices"
          | "primaryLocale"
          | "promotedPurchases"
          | "reviewSubmissions"
          | "sku"
          | "subscriptionGracePeriod"
          | "subscriptionGroups"
          | "subscriptionStatusUrl"
          | "subscriptionStatusUrlForSandbox"
          | "subscriptionStatusUrlVersion"
          | "subscriptionStatusUrlVersionForSandbox"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /**
         * maximum number of related appCustomProductPageVersions returned (when they are included)
         * @max 50
         */
        "limit[appCustomProductPageVersions]"?: number;
        /** comma-separated list of relationships to include */
        include?: ("app" | "appCustomProductPageVersions")[];
      },
      params: RequestParams = {},
    ): Promise<AppCustomProductPagesResponse> =>
      this.request<AppCustomProductPagesResponse, ErrorResponse>({
        path: `/v1/apps/${id}/appCustomProductPages`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Apps
     * @name AppsAppEncryptionDeclarationsGetToManyRelated
     * @request GET:/v1/apps/{id}/appEncryptionDeclarations
     * @secure
     */
    appEncryptionDeclarationsGetToManyRelated: (
      id: string,
      query?: {
        /** filter by attribute 'platform' */
        "filter[platform]"?: ("IOS" | "MAC_OS" | "TV_OS" | "VISION_OS")[];
        /** filter by id(s) of related 'builds' */
        "filter[builds]"?: string[];
        /** the fields to include for returned resources of type appEncryptionDeclarations */
        "fields[appEncryptionDeclarations]"?: (
          | "app"
          | "appDescription"
          | "appEncryptionDeclarationDocument"
          | "appEncryptionDeclarationState"
          | "availableOnFrenchStore"
          | "builds"
          | "codeValue"
          | "containsProprietaryCryptography"
          | "containsThirdPartyCryptography"
          | "createdDate"
          | "documentName"
          | "documentType"
          | "documentUrl"
          | "exempt"
          | "platform"
          | "uploadedDate"
          | "usesEncryption"
        )[];
        /** the fields to include for returned resources of type apps */
        "fields[apps]"?: (
          | "alternativeDistributionKey"
          | "analyticsReportRequests"
          | "appAvailability"
          | "appClips"
          | "appCustomProductPages"
          | "appEncryptionDeclarations"
          | "appEvents"
          | "appInfos"
          | "appPricePoints"
          | "appPriceSchedule"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersions"
          | "availableInNewTerritories"
          | "availableTerritories"
          | "betaAppLocalizations"
          | "betaAppReviewDetail"
          | "betaGroups"
          | "betaLicenseAgreement"
          | "betaTesters"
          | "builds"
          | "bundleId"
          | "ciProduct"
          | "contentRightsDeclaration"
          | "customerReviews"
          | "endUserLicenseAgreement"
          | "gameCenterDetail"
          | "gameCenterEnabledVersions"
          | "inAppPurchases"
          | "inAppPurchasesV2"
          | "isOrEverWasMadeForKids"
          | "marketplaceSearchDetail"
          | "name"
          | "perfPowerMetrics"
          | "preOrder"
          | "preReleaseVersions"
          | "pricePoints"
          | "prices"
          | "primaryLocale"
          | "promotedPurchases"
          | "reviewSubmissions"
          | "sku"
          | "subscriptionGracePeriod"
          | "subscriptionGroups"
          | "subscriptionStatusUrl"
          | "subscriptionStatusUrlForSandbox"
          | "subscriptionStatusUrlVersion"
          | "subscriptionStatusUrlVersionForSandbox"
        )[];
        /** the fields to include for returned resources of type appEncryptionDeclarationDocuments */
        "fields[appEncryptionDeclarationDocuments]"?: (
          | "appEncryptionDeclaration"
          | "assetDeliveryState"
          | "assetToken"
          | "downloadUrl"
          | "fileName"
          | "fileSize"
          | "sourceFileChecksum"
          | "uploadOperations"
          | "uploaded"
        )[];
        /** the fields to include for returned resources of type builds */
        "fields[builds]"?: (
          | "app"
          | "appEncryptionDeclaration"
          | "appStoreVersion"
          | "betaAppReviewSubmission"
          | "betaBuildLocalizations"
          | "betaGroups"
          | "buildAudienceType"
          | "buildBetaDetail"
          | "buildBundles"
          | "computedMinMacOsVersion"
          | "diagnosticSignatures"
          | "expirationDate"
          | "expired"
          | "iconAssetToken"
          | "icons"
          | "individualTesters"
          | "lsMinimumSystemVersion"
          | "minOsVersion"
          | "perfPowerMetrics"
          | "preReleaseVersion"
          | "processingState"
          | "uploadedDate"
          | "usesNonExemptEncryption"
          | "version"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /**
         * maximum number of related builds returned (when they are included)
         * @max 50
         */
        "limit[builds]"?: number;
        /** comma-separated list of relationships to include */
        include?: ("app" | "appEncryptionDeclarationDocument" | "builds")[];
      },
      params: RequestParams = {},
    ): Promise<AppEncryptionDeclarationsResponse> =>
      this.request<AppEncryptionDeclarationsResponse, ErrorResponse>({
        path: `/v1/apps/${id}/appEncryptionDeclarations`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Apps
     * @name AppsAppEventsGetToManyRelated
     * @request GET:/v1/apps/{id}/appEvents
     * @secure
     */
    appEventsGetToManyRelated: (
      id: string,
      query?: {
        /** filter by attribute 'eventState' */
        "filter[eventState]"?: (
          | "DRAFT"
          | "READY_FOR_REVIEW"
          | "WAITING_FOR_REVIEW"
          | "IN_REVIEW"
          | "REJECTED"
          | "ACCEPTED"
          | "APPROVED"
          | "PUBLISHED"
          | "PAST"
          | "ARCHIVED"
        )[];
        /** filter by id(s) */
        "filter[id]"?: string[];
        /** the fields to include for returned resources of type appEventLocalizations */
        "fields[appEventLocalizations]"?: (
          | "appEvent"
          | "appEventScreenshots"
          | "appEventVideoClips"
          | "locale"
          | "longDescription"
          | "name"
          | "shortDescription"
        )[];
        /** the fields to include for returned resources of type appEvents */
        "fields[appEvents]"?: (
          | "app"
          | "archivedTerritorySchedules"
          | "badge"
          | "deepLink"
          | "eventState"
          | "localizations"
          | "primaryLocale"
          | "priority"
          | "purchaseRequirement"
          | "purpose"
          | "referenceName"
          | "territorySchedules"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /**
         * maximum number of related localizations returned (when they are included)
         * @max 50
         */
        "limit[localizations]"?: number;
        /** comma-separated list of relationships to include */
        include?: "localizations"[];
      },
      params: RequestParams = {},
    ): Promise<AppEventsResponse> =>
      this.request<AppEventsResponse, ErrorResponse>({
        path: `/v1/apps/${id}/appEvents`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Apps
     * @name AppsAppInfosGetToManyRelated
     * @request GET:/v1/apps/{id}/appInfos
     * @secure
     */
    appInfosGetToManyRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type ageRatingDeclarations */
        "fields[ageRatingDeclarations]"?: (
          | "ageRatingOverride"
          | "alcoholTobaccoOrDrugUseOrReferences"
          | "contests"
          | "gambling"
          | "gamblingAndContests"
          | "gamblingSimulated"
          | "horrorOrFearThemes"
          | "kidsAgeBand"
          | "matureOrSuggestiveThemes"
          | "medicalOrTreatmentInformation"
          | "profanityOrCrudeHumor"
          | "seventeenPlus"
          | "sexualContentGraphicAndNudity"
          | "sexualContentOrNudity"
          | "unrestrictedWebAccess"
          | "violenceCartoonOrFantasy"
          | "violenceRealistic"
          | "violenceRealisticProlongedGraphicOrSadistic"
        )[];
        /** the fields to include for returned resources of type appInfos */
        "fields[appInfos]"?: (
          | "ageRatingDeclaration"
          | "app"
          | "appInfoLocalizations"
          | "appStoreAgeRating"
          | "appStoreState"
          | "brazilAgeRating"
          | "brazilAgeRatingV2"
          | "kidsAgeBand"
          | "primaryCategory"
          | "primarySubcategoryOne"
          | "primarySubcategoryTwo"
          | "secondaryCategory"
          | "secondarySubcategoryOne"
          | "secondarySubcategoryTwo"
          | "state"
        )[];
        /** the fields to include for returned resources of type appInfoLocalizations */
        "fields[appInfoLocalizations]"?: (
          | "appInfo"
          | "locale"
          | "name"
          | "privacyChoicesUrl"
          | "privacyPolicyText"
          | "privacyPolicyUrl"
          | "subtitle"
        )[];
        /** the fields to include for returned resources of type appCategories */
        "fields[appCategories]"?: ("parent" | "platforms" | "subcategories")[];
        /** the fields to include for returned resources of type apps */
        "fields[apps]"?: (
          | "alternativeDistributionKey"
          | "analyticsReportRequests"
          | "appAvailability"
          | "appClips"
          | "appCustomProductPages"
          | "appEncryptionDeclarations"
          | "appEvents"
          | "appInfos"
          | "appPricePoints"
          | "appPriceSchedule"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersions"
          | "availableInNewTerritories"
          | "availableTerritories"
          | "betaAppLocalizations"
          | "betaAppReviewDetail"
          | "betaGroups"
          | "betaLicenseAgreement"
          | "betaTesters"
          | "builds"
          | "bundleId"
          | "ciProduct"
          | "contentRightsDeclaration"
          | "customerReviews"
          | "endUserLicenseAgreement"
          | "gameCenterDetail"
          | "gameCenterEnabledVersions"
          | "inAppPurchases"
          | "inAppPurchasesV2"
          | "isOrEverWasMadeForKids"
          | "marketplaceSearchDetail"
          | "name"
          | "perfPowerMetrics"
          | "preOrder"
          | "preReleaseVersions"
          | "pricePoints"
          | "prices"
          | "primaryLocale"
          | "promotedPurchases"
          | "reviewSubmissions"
          | "sku"
          | "subscriptionGracePeriod"
          | "subscriptionGroups"
          | "subscriptionStatusUrl"
          | "subscriptionStatusUrlForSandbox"
          | "subscriptionStatusUrlVersion"
          | "subscriptionStatusUrlVersionForSandbox"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /**
         * maximum number of related appInfoLocalizations returned (when they are included)
         * @max 50
         */
        "limit[appInfoLocalizations]"?: number;
        /** comma-separated list of relationships to include */
        include?: (
          | "ageRatingDeclaration"
          | "app"
          | "appInfoLocalizations"
          | "primaryCategory"
          | "primarySubcategoryOne"
          | "primarySubcategoryTwo"
          | "secondaryCategory"
          | "secondarySubcategoryOne"
          | "secondarySubcategoryTwo"
        )[];
      },
      params: RequestParams = {},
    ): Promise<AppInfosResponse> =>
      this.request<AppInfosResponse, ErrorResponse>({
        path: `/v1/apps/${id}/appInfos`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Apps
     * @name AppsAppPricePointsGetToManyRelated
     * @request GET:/v1/apps/{id}/appPricePoints
     * @secure
     */
    appPricePointsGetToManyRelated: (
      id: string,
      query?: {
        /** filter by id(s) of related 'territory' */
        "filter[territory]"?: string[];
        /** the fields to include for returned resources of type appPricePoints */
        "fields[appPricePoints]"?: ("app" | "customerPrice" | "equalizations" | "proceeds" | "territory")[];
        /** the fields to include for returned resources of type apps */
        "fields[apps]"?: (
          | "alternativeDistributionKey"
          | "analyticsReportRequests"
          | "appAvailability"
          | "appClips"
          | "appCustomProductPages"
          | "appEncryptionDeclarations"
          | "appEvents"
          | "appInfos"
          | "appPricePoints"
          | "appPriceSchedule"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersions"
          | "availableInNewTerritories"
          | "availableTerritories"
          | "betaAppLocalizations"
          | "betaAppReviewDetail"
          | "betaGroups"
          | "betaLicenseAgreement"
          | "betaTesters"
          | "builds"
          | "bundleId"
          | "ciProduct"
          | "contentRightsDeclaration"
          | "customerReviews"
          | "endUserLicenseAgreement"
          | "gameCenterDetail"
          | "gameCenterEnabledVersions"
          | "inAppPurchases"
          | "inAppPurchasesV2"
          | "isOrEverWasMadeForKids"
          | "marketplaceSearchDetail"
          | "name"
          | "perfPowerMetrics"
          | "preOrder"
          | "preReleaseVersions"
          | "pricePoints"
          | "prices"
          | "primaryLocale"
          | "promotedPurchases"
          | "reviewSubmissions"
          | "sku"
          | "subscriptionGracePeriod"
          | "subscriptionGroups"
          | "subscriptionStatusUrl"
          | "subscriptionStatusUrlForSandbox"
          | "subscriptionStatusUrlVersion"
          | "subscriptionStatusUrlVersionForSandbox"
        )[];
        /** the fields to include for returned resources of type territories */
        "fields[territories]"?: "currency"[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /** comma-separated list of relationships to include */
        include?: ("app" | "territory")[];
      },
      params: RequestParams = {},
    ): Promise<AppPricePointsV3Response> =>
      this.request<AppPricePointsV3Response, ErrorResponse>({
        path: `/v1/apps/${id}/appPricePoints`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Apps
     * @name AppsAppPriceScheduleGetToOneRelated
     * @request GET:/v1/apps/{id}/appPriceSchedule
     * @secure
     */
    appPriceScheduleGetToOneRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type appPrices */
        "fields[appPrices]"?: ("appPricePoint" | "endDate" | "manual" | "startDate" | "territory")[];
        /** the fields to include for returned resources of type appPriceSchedules */
        "fields[appPriceSchedules]"?: ("app" | "automaticPrices" | "baseTerritory" | "manualPrices")[];
        /** the fields to include for returned resources of type apps */
        "fields[apps]"?: (
          | "alternativeDistributionKey"
          | "analyticsReportRequests"
          | "appAvailability"
          | "appClips"
          | "appCustomProductPages"
          | "appEncryptionDeclarations"
          | "appEvents"
          | "appInfos"
          | "appPricePoints"
          | "appPriceSchedule"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersions"
          | "availableInNewTerritories"
          | "availableTerritories"
          | "betaAppLocalizations"
          | "betaAppReviewDetail"
          | "betaGroups"
          | "betaLicenseAgreement"
          | "betaTesters"
          | "builds"
          | "bundleId"
          | "ciProduct"
          | "contentRightsDeclaration"
          | "customerReviews"
          | "endUserLicenseAgreement"
          | "gameCenterDetail"
          | "gameCenterEnabledVersions"
          | "inAppPurchases"
          | "inAppPurchasesV2"
          | "isOrEverWasMadeForKids"
          | "marketplaceSearchDetail"
          | "name"
          | "perfPowerMetrics"
          | "preOrder"
          | "preReleaseVersions"
          | "pricePoints"
          | "prices"
          | "primaryLocale"
          | "promotedPurchases"
          | "reviewSubmissions"
          | "sku"
          | "subscriptionGracePeriod"
          | "subscriptionGroups"
          | "subscriptionStatusUrl"
          | "subscriptionStatusUrlForSandbox"
          | "subscriptionStatusUrlVersion"
          | "subscriptionStatusUrlVersionForSandbox"
        )[];
        /** the fields to include for returned resources of type territories */
        "fields[territories]"?: "currency"[];
        /**
         * maximum number of related manualPrices returned (when they are included)
         * @max 50
         */
        "limit[manualPrices]"?: number;
        /**
         * maximum number of related automaticPrices returned (when they are included)
         * @max 50
         */
        "limit[automaticPrices]"?: number;
        /** comma-separated list of relationships to include */
        include?: ("app" | "automaticPrices" | "baseTerritory" | "manualPrices")[];
      },
      params: RequestParams = {},
    ): Promise<AppPriceScheduleResponse> =>
      this.request<AppPriceScheduleResponse, ErrorResponse>({
        path: `/v1/apps/${id}/appPriceSchedule`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Apps
     * @name AppsAppStoreVersionExperimentsV2GetToManyRelated
     * @request GET:/v1/apps/{id}/appStoreVersionExperimentsV2
     * @secure
     */
    appStoreVersionExperimentsV2GetToManyRelated: (
      id: string,
      query?: {
        /** filter by attribute 'state' */
        "filter[state]"?: (
          | "PREPARE_FOR_SUBMISSION"
          | "READY_FOR_REVIEW"
          | "WAITING_FOR_REVIEW"
          | "IN_REVIEW"
          | "ACCEPTED"
          | "APPROVED"
          | "REJECTED"
          | "COMPLETED"
          | "STOPPED"
        )[];
        /** the fields to include for returned resources of type appStoreVersionExperiments */
        "fields[appStoreVersionExperiments]"?: (
          | "app"
          | "appStoreVersionExperimentTreatments"
          | "controlVersions"
          | "endDate"
          | "latestControlVersion"
          | "name"
          | "platform"
          | "reviewRequired"
          | "startDate"
          | "started"
          | "state"
          | "trafficProportion"
        )[];
        /** the fields to include for returned resources of type appStoreVersionExperimentTreatments */
        "fields[appStoreVersionExperimentTreatments]"?: (
          | "appIcon"
          | "appIconName"
          | "appStoreVersionExperiment"
          | "appStoreVersionExperimentTreatmentLocalizations"
          | "appStoreVersionExperimentV2"
          | "name"
          | "promotedDate"
        )[];
        /** the fields to include for returned resources of type appStoreVersions */
        "fields[appStoreVersions]"?: (
          | "ageRatingDeclaration"
          | "alternativeDistributionPackage"
          | "app"
          | "appClipDefaultExperience"
          | "appStoreReviewDetail"
          | "appStoreState"
          | "appStoreVersionExperiments"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersionLocalizations"
          | "appStoreVersionPhasedRelease"
          | "appStoreVersionSubmission"
          | "appVersionState"
          | "build"
          | "copyright"
          | "createdDate"
          | "customerReviews"
          | "downloadable"
          | "earliestReleaseDate"
          | "platform"
          | "releaseType"
          | "reviewType"
          | "routingAppCoverage"
          | "versionString"
        )[];
        /** the fields to include for returned resources of type apps */
        "fields[apps]"?: (
          | "alternativeDistributionKey"
          | "analyticsReportRequests"
          | "appAvailability"
          | "appClips"
          | "appCustomProductPages"
          | "appEncryptionDeclarations"
          | "appEvents"
          | "appInfos"
          | "appPricePoints"
          | "appPriceSchedule"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersions"
          | "availableInNewTerritories"
          | "availableTerritories"
          | "betaAppLocalizations"
          | "betaAppReviewDetail"
          | "betaGroups"
          | "betaLicenseAgreement"
          | "betaTesters"
          | "builds"
          | "bundleId"
          | "ciProduct"
          | "contentRightsDeclaration"
          | "customerReviews"
          | "endUserLicenseAgreement"
          | "gameCenterDetail"
          | "gameCenterEnabledVersions"
          | "inAppPurchases"
          | "inAppPurchasesV2"
          | "isOrEverWasMadeForKids"
          | "marketplaceSearchDetail"
          | "name"
          | "perfPowerMetrics"
          | "preOrder"
          | "preReleaseVersions"
          | "pricePoints"
          | "prices"
          | "primaryLocale"
          | "promotedPurchases"
          | "reviewSubmissions"
          | "sku"
          | "subscriptionGracePeriod"
          | "subscriptionGroups"
          | "subscriptionStatusUrl"
          | "subscriptionStatusUrlForSandbox"
          | "subscriptionStatusUrlVersion"
          | "subscriptionStatusUrlVersionForSandbox"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /**
         * maximum number of related controlVersions returned (when they are included)
         * @max 50
         */
        "limit[controlVersions]"?: number;
        /**
         * maximum number of related appStoreVersionExperimentTreatments returned (when they are included)
         * @max 50
         */
        "limit[appStoreVersionExperimentTreatments]"?: number;
        /** comma-separated list of relationships to include */
        include?: ("app" | "appStoreVersionExperimentTreatments" | "controlVersions" | "latestControlVersion")[];
      },
      params: RequestParams = {},
    ): Promise<AppStoreVersionExperimentsV2Response> =>
      this.request<AppStoreVersionExperimentsV2Response, ErrorResponse>({
        path: `/v1/apps/${id}/appStoreVersionExperimentsV2`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Apps
     * @name AppsAppStoreVersionsGetToManyRelated
     * @request GET:/v1/apps/{id}/appStoreVersions
     * @secure
     */
    appStoreVersionsGetToManyRelated: (
      id: string,
      query?: {
        /** filter by attribute 'appStoreState' */
        "filter[appStoreState]"?: (
          | "ACCEPTED"
          | "DEVELOPER_REMOVED_FROM_SALE"
          | "DEVELOPER_REJECTED"
          | "IN_REVIEW"
          | "INVALID_BINARY"
          | "METADATA_REJECTED"
          | "PENDING_APPLE_RELEASE"
          | "PENDING_CONTRACT"
          | "PENDING_DEVELOPER_RELEASE"
          | "PREPARE_FOR_SUBMISSION"
          | "PREORDER_READY_FOR_SALE"
          | "PROCESSING_FOR_APP_STORE"
          | "READY_FOR_REVIEW"
          | "READY_FOR_SALE"
          | "REJECTED"
          | "REMOVED_FROM_SALE"
          | "WAITING_FOR_EXPORT_COMPLIANCE"
          | "WAITING_FOR_REVIEW"
          | "REPLACED_WITH_NEW_VERSION"
          | "NOT_APPLICABLE"
        )[];
        /** filter by attribute 'appVersionState' */
        "filter[appVersionState]"?: (
          | "ACCEPTED"
          | "DEVELOPER_REJECTED"
          | "IN_REVIEW"
          | "INVALID_BINARY"
          | "METADATA_REJECTED"
          | "PENDING_APPLE_RELEASE"
          | "PENDING_DEVELOPER_RELEASE"
          | "PREPARE_FOR_SUBMISSION"
          | "PROCESSING_FOR_DISTRIBUTION"
          | "READY_FOR_DISTRIBUTION"
          | "READY_FOR_REVIEW"
          | "REJECTED"
          | "REPLACED_WITH_NEW_VERSION"
          | "WAITING_FOR_EXPORT_COMPLIANCE"
          | "WAITING_FOR_REVIEW"
        )[];
        /** filter by attribute 'platform' */
        "filter[platform]"?: ("IOS" | "MAC_OS" | "TV_OS" | "VISION_OS")[];
        /** filter by attribute 'versionString' */
        "filter[versionString]"?: string[];
        /** filter by id(s) */
        "filter[id]"?: string[];
        /** the fields to include for returned resources of type ageRatingDeclarations */
        "fields[ageRatingDeclarations]"?: (
          | "ageRatingOverride"
          | "alcoholTobaccoOrDrugUseOrReferences"
          | "contests"
          | "gambling"
          | "gamblingAndContests"
          | "gamblingSimulated"
          | "horrorOrFearThemes"
          | "kidsAgeBand"
          | "matureOrSuggestiveThemes"
          | "medicalOrTreatmentInformation"
          | "profanityOrCrudeHumor"
          | "seventeenPlus"
          | "sexualContentGraphicAndNudity"
          | "sexualContentOrNudity"
          | "unrestrictedWebAccess"
          | "violenceCartoonOrFantasy"
          | "violenceRealistic"
          | "violenceRealisticProlongedGraphicOrSadistic"
        )[];
        /** the fields to include for returned resources of type appStoreReviewDetails */
        "fields[appStoreReviewDetails]"?: (
          | "appStoreReviewAttachments"
          | "appStoreVersion"
          | "contactEmail"
          | "contactFirstName"
          | "contactLastName"
          | "contactPhone"
          | "demoAccountName"
          | "demoAccountPassword"
          | "demoAccountRequired"
          | "notes"
        )[];
        /** the fields to include for returned resources of type appStoreVersionLocalizations */
        "fields[appStoreVersionLocalizations]"?: (
          | "appPreviewSets"
          | "appScreenshotSets"
          | "appStoreVersion"
          | "description"
          | "keywords"
          | "locale"
          | "marketingUrl"
          | "promotionalText"
          | "supportUrl"
          | "whatsNew"
        )[];
        /** the fields to include for returned resources of type appStoreVersionExperiments */
        "fields[appStoreVersionExperiments]"?: (
          | "app"
          | "appStoreVersion"
          | "appStoreVersionExperimentTreatments"
          | "controlVersions"
          | "endDate"
          | "latestControlVersion"
          | "name"
          | "platform"
          | "reviewRequired"
          | "startDate"
          | "started"
          | "state"
          | "trafficProportion"
        )[];
        /** the fields to include for returned resources of type appStoreVersionSubmissions */
        "fields[appStoreVersionSubmissions]"?: "appStoreVersion"[];
        /** the fields to include for returned resources of type alternativeDistributionPackages */
        "fields[alternativeDistributionPackages]"?: ("appStoreVersion" | "versions")[];
        /** the fields to include for returned resources of type appStoreVersions */
        "fields[appStoreVersions]"?: (
          | "ageRatingDeclaration"
          | "alternativeDistributionPackage"
          | "app"
          | "appClipDefaultExperience"
          | "appStoreReviewDetail"
          | "appStoreState"
          | "appStoreVersionExperiments"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersionLocalizations"
          | "appStoreVersionPhasedRelease"
          | "appStoreVersionSubmission"
          | "appVersionState"
          | "build"
          | "copyright"
          | "createdDate"
          | "customerReviews"
          | "downloadable"
          | "earliestReleaseDate"
          | "platform"
          | "releaseType"
          | "reviewType"
          | "routingAppCoverage"
          | "versionString"
        )[];
        /** the fields to include for returned resources of type apps */
        "fields[apps]"?: (
          | "alternativeDistributionKey"
          | "analyticsReportRequests"
          | "appAvailability"
          | "appClips"
          | "appCustomProductPages"
          | "appEncryptionDeclarations"
          | "appEvents"
          | "appInfos"
          | "appPricePoints"
          | "appPriceSchedule"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersions"
          | "availableInNewTerritories"
          | "availableTerritories"
          | "betaAppLocalizations"
          | "betaAppReviewDetail"
          | "betaGroups"
          | "betaLicenseAgreement"
          | "betaTesters"
          | "builds"
          | "bundleId"
          | "ciProduct"
          | "contentRightsDeclaration"
          | "customerReviews"
          | "endUserLicenseAgreement"
          | "gameCenterDetail"
          | "gameCenterEnabledVersions"
          | "inAppPurchases"
          | "inAppPurchasesV2"
          | "isOrEverWasMadeForKids"
          | "marketplaceSearchDetail"
          | "name"
          | "perfPowerMetrics"
          | "preOrder"
          | "preReleaseVersions"
          | "pricePoints"
          | "prices"
          | "primaryLocale"
          | "promotedPurchases"
          | "reviewSubmissions"
          | "sku"
          | "subscriptionGracePeriod"
          | "subscriptionGroups"
          | "subscriptionStatusUrl"
          | "subscriptionStatusUrlForSandbox"
          | "subscriptionStatusUrlVersion"
          | "subscriptionStatusUrlVersionForSandbox"
        )[];
        /** the fields to include for returned resources of type routingAppCoverages */
        "fields[routingAppCoverages]"?: (
          | "appStoreVersion"
          | "assetDeliveryState"
          | "fileName"
          | "fileSize"
          | "sourceFileChecksum"
          | "uploadOperations"
          | "uploaded"
        )[];
        /** the fields to include for returned resources of type appClipDefaultExperiences */
        "fields[appClipDefaultExperiences]"?: (
          | "action"
          | "appClip"
          | "appClipAppStoreReviewDetail"
          | "appClipDefaultExperienceLocalizations"
          | "appClipDefaultExperienceTemplate"
          | "releaseWithAppStoreVersion"
        )[];
        /** the fields to include for returned resources of type appStoreVersionPhasedReleases */
        "fields[appStoreVersionPhasedReleases]"?: (
          | "appStoreVersion"
          | "currentDayNumber"
          | "phasedReleaseState"
          | "startDate"
          | "totalPauseDuration"
        )[];
        /** the fields to include for returned resources of type builds */
        "fields[builds]"?: (
          | "app"
          | "appEncryptionDeclaration"
          | "appStoreVersion"
          | "betaAppReviewSubmission"
          | "betaBuildLocalizations"
          | "betaGroups"
          | "buildAudienceType"
          | "buildBetaDetail"
          | "buildBundles"
          | "computedMinMacOsVersion"
          | "diagnosticSignatures"
          | "expirationDate"
          | "expired"
          | "iconAssetToken"
          | "icons"
          | "individualTesters"
          | "lsMinimumSystemVersion"
          | "minOsVersion"
          | "perfPowerMetrics"
          | "preReleaseVersion"
          | "processingState"
          | "uploadedDate"
          | "usesNonExemptEncryption"
          | "version"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /**
         * maximum number of related appStoreVersionLocalizations returned (when they are included)
         * @max 50
         */
        "limit[appStoreVersionLocalizations]"?: number;
        /**
         * maximum number of related appStoreVersionExperiments returned (when they are included)
         * @deprecated
         * @max 50
         */
        "limit[appStoreVersionExperiments]"?: number;
        /**
         * maximum number of related appStoreVersionExperimentsV2 returned (when they are included)
         * @max 50
         */
        "limit[appStoreVersionExperimentsV2]"?: number;
        /** comma-separated list of relationships to include */
        include?: (
          | "ageRatingDeclaration"
          | "alternativeDistributionPackage"
          | "app"
          | "appClipDefaultExperience"
          | "appStoreReviewDetail"
          | "appStoreVersionExperiments"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersionLocalizations"
          | "appStoreVersionPhasedRelease"
          | "appStoreVersionSubmission"
          | "build"
          | "routingAppCoverage"
        )[];
      },
      params: RequestParams = {},
    ): Promise<AppStoreVersionsResponse> =>
      this.request<AppStoreVersionsResponse, ErrorResponse>({
        path: `/v1/apps/${id}/appStoreVersions`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Apps
     * @name AppsAvailableTerritoriesGetToManyRelated
     * @request GET:/v1/apps/{id}/availableTerritories
     * @deprecated
     * @secure
     */
    availableTerritoriesGetToManyRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type territories */
        "fields[territories]"?: "currency"[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
      },
      params: RequestParams = {},
    ): Promise<TerritoriesResponse> =>
      this.request<TerritoriesResponse, ErrorResponse>({
        path: `/v1/apps/${id}/availableTerritories`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Apps
     * @name AppsBetaAppLocalizationsGetToManyRelated
     * @request GET:/v1/apps/{id}/betaAppLocalizations
     * @secure
     */
    betaAppLocalizationsGetToManyRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type betaAppLocalizations */
        "fields[betaAppLocalizations]"?: (
          | "app"
          | "description"
          | "feedbackEmail"
          | "locale"
          | "marketingUrl"
          | "privacyPolicyUrl"
          | "tvOsPrivacyPolicy"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
      },
      params: RequestParams = {},
    ): Promise<BetaAppLocalizationsWithoutIncludesResponse> =>
      this.request<BetaAppLocalizationsWithoutIncludesResponse, ErrorResponse>({
        path: `/v1/apps/${id}/betaAppLocalizations`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Apps
     * @name AppsBetaAppReviewDetailGetToOneRelated
     * @request GET:/v1/apps/{id}/betaAppReviewDetail
     * @secure
     */
    betaAppReviewDetailGetToOneRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type betaAppReviewDetails */
        "fields[betaAppReviewDetails]"?: (
          | "app"
          | "contactEmail"
          | "contactFirstName"
          | "contactLastName"
          | "contactPhone"
          | "demoAccountName"
          | "demoAccountPassword"
          | "demoAccountRequired"
          | "notes"
        )[];
      },
      params: RequestParams = {},
    ): Promise<BetaAppReviewDetailWithoutIncludesResponse> =>
      this.request<BetaAppReviewDetailWithoutIncludesResponse, ErrorResponse>({
        path: `/v1/apps/${id}/betaAppReviewDetail`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Apps
     * @name AppsBetaGroupsGetToManyRelated
     * @request GET:/v1/apps/{id}/betaGroups
     * @secure
     */
    betaGroupsGetToManyRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type betaGroups */
        "fields[betaGroups]"?: (
          | "app"
          | "betaTesters"
          | "builds"
          | "createdDate"
          | "feedbackEnabled"
          | "hasAccessToAllBuilds"
          | "iosBuildsAvailableForAppleSiliconMac"
          | "isInternalGroup"
          | "name"
          | "publicLink"
          | "publicLinkEnabled"
          | "publicLinkId"
          | "publicLinkLimit"
          | "publicLinkLimitEnabled"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
      },
      params: RequestParams = {},
    ): Promise<BetaGroupsWithoutIncludesResponse> =>
      this.request<BetaGroupsWithoutIncludesResponse, ErrorResponse>({
        path: `/v1/apps/${id}/betaGroups`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Apps
     * @name AppsBetaLicenseAgreementGetToOneRelated
     * @request GET:/v1/apps/{id}/betaLicenseAgreement
     * @secure
     */
    betaLicenseAgreementGetToOneRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type betaLicenseAgreements */
        "fields[betaLicenseAgreements]"?: ("agreementText" | "app")[];
      },
      params: RequestParams = {},
    ): Promise<BetaLicenseAgreementWithoutIncludesResponse> =>
      this.request<BetaLicenseAgreementWithoutIncludesResponse, ErrorResponse>({
        path: `/v1/apps/${id}/betaLicenseAgreement`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Apps
     * @name AppsBetaTestersDeleteToManyRelationship
     * @request DELETE:/v1/apps/{id}/relationships/betaTesters
     * @secure
     */
    betaTestersDeleteToManyRelationship: (
      id: string,
      data: AppBetaTestersLinkagesRequest,
      params: RequestParams = {},
    ): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/apps/${id}/relationships/betaTesters`,
        method: "DELETE",
        body: data,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * No description
     *
     * @tags Apps
     * @name AppsBuildsGetToManyRelated
     * @request GET:/v1/apps/{id}/builds
     * @secure
     */
    buildsGetToManyRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type builds */
        "fields[builds]"?: (
          | "app"
          | "appEncryptionDeclaration"
          | "appStoreVersion"
          | "betaAppReviewSubmission"
          | "betaBuildLocalizations"
          | "betaGroups"
          | "buildAudienceType"
          | "buildBetaDetail"
          | "buildBundles"
          | "computedMinMacOsVersion"
          | "diagnosticSignatures"
          | "expirationDate"
          | "expired"
          | "iconAssetToken"
          | "icons"
          | "individualTesters"
          | "lsMinimumSystemVersion"
          | "minOsVersion"
          | "perfPowerMetrics"
          | "preReleaseVersion"
          | "processingState"
          | "uploadedDate"
          | "usesNonExemptEncryption"
          | "version"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
      },
      params: RequestParams = {},
    ): Promise<BuildsWithoutIncludesResponse> =>
      this.request<BuildsWithoutIncludesResponse, ErrorResponse>({
        path: `/v1/apps/${id}/builds`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Apps
     * @name AppsCiProductGetToOneRelated
     * @request GET:/v1/apps/{id}/ciProduct
     * @secure
     */
    ciProductGetToOneRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type ciProducts */
        "fields[ciProducts]"?: (
          | "additionalRepositories"
          | "app"
          | "buildRuns"
          | "bundleId"
          | "createdDate"
          | "name"
          | "primaryRepositories"
          | "productType"
          | "workflows"
        )[];
        /** the fields to include for returned resources of type apps */
        "fields[apps]"?: (
          | "alternativeDistributionKey"
          | "analyticsReportRequests"
          | "appAvailability"
          | "appClips"
          | "appCustomProductPages"
          | "appEncryptionDeclarations"
          | "appEvents"
          | "appInfos"
          | "appPricePoints"
          | "appPriceSchedule"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersions"
          | "availableInNewTerritories"
          | "availableTerritories"
          | "betaAppLocalizations"
          | "betaAppReviewDetail"
          | "betaGroups"
          | "betaLicenseAgreement"
          | "betaTesters"
          | "builds"
          | "bundleId"
          | "ciProduct"
          | "contentRightsDeclaration"
          | "customerReviews"
          | "endUserLicenseAgreement"
          | "gameCenterDetail"
          | "gameCenterEnabledVersions"
          | "inAppPurchases"
          | "inAppPurchasesV2"
          | "isOrEverWasMadeForKids"
          | "marketplaceSearchDetail"
          | "name"
          | "perfPowerMetrics"
          | "preOrder"
          | "preReleaseVersions"
          | "pricePoints"
          | "prices"
          | "primaryLocale"
          | "promotedPurchases"
          | "reviewSubmissions"
          | "sku"
          | "subscriptionGracePeriod"
          | "subscriptionGroups"
          | "subscriptionStatusUrl"
          | "subscriptionStatusUrlForSandbox"
          | "subscriptionStatusUrlVersion"
          | "subscriptionStatusUrlVersionForSandbox"
        )[];
        /** the fields to include for returned resources of type scmRepositories */
        "fields[scmRepositories]"?: (
          | "defaultBranch"
          | "gitReferences"
          | "httpCloneUrl"
          | "lastAccessedDate"
          | "ownerName"
          | "pullRequests"
          | "repositoryName"
          | "scmProvider"
          | "sshCloneUrl"
        )[];
        /** the fields to include for returned resources of type bundleIds */
        "fields[bundleIds]"?: (
          | "app"
          | "bundleIdCapabilities"
          | "identifier"
          | "name"
          | "platform"
          | "profiles"
          | "seedId"
        )[];
        /**
         * maximum number of related primaryRepositories returned (when they are included)
         * @max 50
         */
        "limit[primaryRepositories]"?: number;
        /** comma-separated list of relationships to include */
        include?: ("app" | "bundleId" | "primaryRepositories")[];
      },
      params: RequestParams = {},
    ): Promise<CiProductResponse> =>
      this.request<CiProductResponse, ErrorResponse>({
        path: `/v1/apps/${id}/ciProduct`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Apps
     * @name AppsCustomerReviewsGetToManyRelated
     * @request GET:/v1/apps/{id}/customerReviews
     * @secure
     */
    customerReviewsGetToManyRelated: (
      id: string,
      query?: {
        /** filter by attribute 'rating' */
        "filter[rating]"?: string[];
        /** filter by attribute 'territory' */
        "filter[territory]"?: (
          | "ABW"
          | "AFG"
          | "AGO"
          | "AIA"
          | "ALB"
          | "AND"
          | "ANT"
          | "ARE"
          | "ARG"
          | "ARM"
          | "ASM"
          | "ATG"
          | "AUS"
          | "AUT"
          | "AZE"
          | "BDI"
          | "BEL"
          | "BEN"
          | "BES"
          | "BFA"
          | "BGD"
          | "BGR"
          | "BHR"
          | "BHS"
          | "BIH"
          | "BLR"
          | "BLZ"
          | "BMU"
          | "BOL"
          | "BRA"
          | "BRB"
          | "BRN"
          | "BTN"
          | "BWA"
          | "CAF"
          | "CAN"
          | "CHE"
          | "CHL"
          | "CHN"
          | "CIV"
          | "CMR"
          | "COD"
          | "COG"
          | "COK"
          | "COL"
          | "COM"
          | "CPV"
          | "CRI"
          | "CUB"
          | "CUW"
          | "CXR"
          | "CYM"
          | "CYP"
          | "CZE"
          | "DEU"
          | "DJI"
          | "DMA"
          | "DNK"
          | "DOM"
          | "DZA"
          | "ECU"
          | "EGY"
          | "ERI"
          | "ESP"
          | "EST"
          | "ETH"
          | "FIN"
          | "FJI"
          | "FLK"
          | "FRA"
          | "FRO"
          | "FSM"
          | "GAB"
          | "GBR"
          | "GEO"
          | "GGY"
          | "GHA"
          | "GIB"
          | "GIN"
          | "GLP"
          | "GMB"
          | "GNB"
          | "GNQ"
          | "GRC"
          | "GRD"
          | "GRL"
          | "GTM"
          | "GUF"
          | "GUM"
          | "GUY"
          | "HKG"
          | "HND"
          | "HRV"
          | "HTI"
          | "HUN"
          | "IDN"
          | "IMN"
          | "IND"
          | "IRL"
          | "IRQ"
          | "ISL"
          | "ISR"
          | "ITA"
          | "JAM"
          | "JEY"
          | "JOR"
          | "JPN"
          | "KAZ"
          | "KEN"
          | "KGZ"
          | "KHM"
          | "KIR"
          | "KNA"
          | "KOR"
          | "KWT"
          | "LAO"
          | "LBN"
          | "LBR"
          | "LBY"
          | "LCA"
          | "LIE"
          | "LKA"
          | "LSO"
          | "LTU"
          | "LUX"
          | "LVA"
          | "MAC"
          | "MAR"
          | "MCO"
          | "MDA"
          | "MDG"
          | "MDV"
          | "MEX"
          | "MHL"
          | "MKD"
          | "MLI"
          | "MLT"
          | "MMR"
          | "MNE"
          | "MNG"
          | "MNP"
          | "MOZ"
          | "MRT"
          | "MSR"
          | "MTQ"
          | "MUS"
          | "MWI"
          | "MYS"
          | "MYT"
          | "NAM"
          | "NCL"
          | "NER"
          | "NFK"
          | "NGA"
          | "NIC"
          | "NIU"
          | "NLD"
          | "NOR"
          | "NPL"
          | "NRU"
          | "NZL"
          | "OMN"
          | "PAK"
          | "PAN"
          | "PER"
          | "PHL"
          | "PLW"
          | "PNG"
          | "POL"
          | "PRI"
          | "PRT"
          | "PRY"
          | "PSE"
          | "PYF"
          | "QAT"
          | "REU"
          | "ROU"
          | "RUS"
          | "RWA"
          | "SAU"
          | "SEN"
          | "SGP"
          | "SHN"
          | "SLB"
          | "SLE"
          | "SLV"
          | "SMR"
          | "SOM"
          | "SPM"
          | "SRB"
          | "SSD"
          | "STP"
          | "SUR"
          | "SVK"
          | "SVN"
          | "SWE"
          | "SWZ"
          | "SXM"
          | "SYC"
          | "TCA"
          | "TCD"
          | "TGO"
          | "THA"
          | "TJK"
          | "TKM"
          | "TLS"
          | "TON"
          | "TTO"
          | "TUN"
          | "TUR"
          | "TUV"
          | "TWN"
          | "TZA"
          | "UGA"
          | "UKR"
          | "UMI"
          | "URY"
          | "USA"
          | "UZB"
          | "VAT"
          | "VCT"
          | "VEN"
          | "VGB"
          | "VIR"
          | "VNM"
          | "VUT"
          | "WLF"
          | "WSM"
          | "YEM"
          | "ZAF"
          | "ZMB"
          | "ZWE"
        )[];
        /** filter by publishedResponse */
        "exists[publishedResponse]"?: boolean;
        /** comma-separated list of sort expressions; resources will be sorted as specified */
        sort?: ("createdDate" | "-createdDate" | "rating" | "-rating")[];
        /** the fields to include for returned resources of type customerReviews */
        "fields[customerReviews]"?: (
          | "body"
          | "createdDate"
          | "rating"
          | "response"
          | "reviewerNickname"
          | "territory"
          | "title"
        )[];
        /** the fields to include for returned resources of type customerReviewResponses */
        "fields[customerReviewResponses]"?: ("lastModifiedDate" | "responseBody" | "review" | "state")[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /** comma-separated list of relationships to include */
        include?: "response"[];
      },
      params: RequestParams = {},
    ): Promise<CustomerReviewsResponse> =>
      this.request<CustomerReviewsResponse, ErrorResponse>({
        path: `/v1/apps/${id}/customerReviews`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Apps
     * @name AppsEndUserLicenseAgreementGetToOneRelated
     * @request GET:/v1/apps/{id}/endUserLicenseAgreement
     * @secure
     */
    endUserLicenseAgreementGetToOneRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type endUserLicenseAgreements */
        "fields[endUserLicenseAgreements]"?: ("agreementText" | "app" | "territories")[];
      },
      params: RequestParams = {},
    ): Promise<EndUserLicenseAgreementWithoutIncludesResponse> =>
      this.request<EndUserLicenseAgreementWithoutIncludesResponse, ErrorResponse>({
        path: `/v1/apps/${id}/endUserLicenseAgreement`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Apps
     * @name AppsGameCenterDetailGetToOneRelated
     * @request GET:/v1/apps/{id}/gameCenterDetail
     * @secure
     */
    gameCenterDetailGetToOneRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type gameCenterAchievementReleases */
        "fields[gameCenterAchievementReleases]"?: ("gameCenterAchievement" | "gameCenterDetail" | "live")[];
        /** the fields to include for returned resources of type gameCenterLeaderboardSetReleases */
        "fields[gameCenterLeaderboardSetReleases]"?: ("gameCenterDetail" | "gameCenterLeaderboardSet" | "live")[];
        /** the fields to include for returned resources of type gameCenterLeaderboardSets */
        "fields[gameCenterLeaderboardSets]"?: (
          | "gameCenterDetail"
          | "gameCenterGroup"
          | "gameCenterLeaderboards"
          | "groupLeaderboardSet"
          | "localizations"
          | "referenceName"
          | "releases"
          | "vendorIdentifier"
        )[];
        /** the fields to include for returned resources of type gameCenterGroups */
        "fields[gameCenterGroups]"?: (
          | "gameCenterAchievements"
          | "gameCenterDetails"
          | "gameCenterLeaderboardSets"
          | "gameCenterLeaderboards"
          | "referenceName"
        )[];
        /** the fields to include for returned resources of type gameCenterDetails */
        "fields[gameCenterDetails]"?: (
          | "achievementReleases"
          | "app"
          | "arcadeEnabled"
          | "challengeEnabled"
          | "defaultGroupLeaderboard"
          | "defaultLeaderboard"
          | "gameCenterAchievements"
          | "gameCenterAppVersions"
          | "gameCenterGroup"
          | "gameCenterLeaderboardSets"
          | "gameCenterLeaderboards"
          | "leaderboardReleases"
          | "leaderboardSetReleases"
        )[];
        /** the fields to include for returned resources of type gameCenterLeaderboards */
        "fields[gameCenterLeaderboards]"?: (
          | "archived"
          | "defaultFormatter"
          | "gameCenterDetail"
          | "gameCenterGroup"
          | "gameCenterLeaderboardSets"
          | "groupLeaderboard"
          | "localizations"
          | "recurrenceDuration"
          | "recurrenceRule"
          | "recurrenceStartDate"
          | "referenceName"
          | "releases"
          | "scoreRangeEnd"
          | "scoreRangeStart"
          | "scoreSortType"
          | "submissionType"
          | "vendorIdentifier"
        )[];
        /** the fields to include for returned resources of type gameCenterAppVersions */
        "fields[gameCenterAppVersions]"?: ("appStoreVersion" | "compatibilityVersions" | "enabled")[];
        /** the fields to include for returned resources of type gameCenterAchievements */
        "fields[gameCenterAchievements]"?: (
          | "archived"
          | "gameCenterDetail"
          | "gameCenterGroup"
          | "groupAchievement"
          | "localizations"
          | "points"
          | "referenceName"
          | "releases"
          | "repeatable"
          | "showBeforeEarned"
          | "vendorIdentifier"
        )[];
        /** the fields to include for returned resources of type apps */
        "fields[apps]"?: (
          | "alternativeDistributionKey"
          | "analyticsReportRequests"
          | "appAvailability"
          | "appClips"
          | "appCustomProductPages"
          | "appEncryptionDeclarations"
          | "appEvents"
          | "appInfos"
          | "appPricePoints"
          | "appPriceSchedule"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersions"
          | "availableInNewTerritories"
          | "availableTerritories"
          | "betaAppLocalizations"
          | "betaAppReviewDetail"
          | "betaGroups"
          | "betaLicenseAgreement"
          | "betaTesters"
          | "builds"
          | "bundleId"
          | "ciProduct"
          | "contentRightsDeclaration"
          | "customerReviews"
          | "endUserLicenseAgreement"
          | "gameCenterDetail"
          | "gameCenterEnabledVersions"
          | "inAppPurchases"
          | "inAppPurchasesV2"
          | "isOrEverWasMadeForKids"
          | "marketplaceSearchDetail"
          | "name"
          | "perfPowerMetrics"
          | "preOrder"
          | "preReleaseVersions"
          | "pricePoints"
          | "prices"
          | "primaryLocale"
          | "promotedPurchases"
          | "reviewSubmissions"
          | "sku"
          | "subscriptionGracePeriod"
          | "subscriptionGroups"
          | "subscriptionStatusUrl"
          | "subscriptionStatusUrlForSandbox"
          | "subscriptionStatusUrlVersion"
          | "subscriptionStatusUrlVersionForSandbox"
        )[];
        /** the fields to include for returned resources of type gameCenterLeaderboardReleases */
        "fields[gameCenterLeaderboardReleases]"?: ("gameCenterDetail" | "gameCenterLeaderboard" | "live")[];
        /**
         * maximum number of related gameCenterAppVersions returned (when they are included)
         * @max 50
         */
        "limit[gameCenterAppVersions]"?: number;
        /**
         * maximum number of related gameCenterLeaderboards returned (when they are included)
         * @max 50
         */
        "limit[gameCenterLeaderboards]"?: number;
        /**
         * maximum number of related gameCenterLeaderboardSets returned (when they are included)
         * @max 50
         */
        "limit[gameCenterLeaderboardSets]"?: number;
        /**
         * maximum number of related gameCenterAchievements returned (when they are included)
         * @max 50
         */
        "limit[gameCenterAchievements]"?: number;
        /**
         * maximum number of related achievementReleases returned (when they are included)
         * @max 50
         */
        "limit[achievementReleases]"?: number;
        /**
         * maximum number of related leaderboardReleases returned (when they are included)
         * @max 50
         */
        "limit[leaderboardReleases]"?: number;
        /**
         * maximum number of related leaderboardSetReleases returned (when they are included)
         * @max 50
         */
        "limit[leaderboardSetReleases]"?: number;
        /** comma-separated list of relationships to include */
        include?: (
          | "achievementReleases"
          | "app"
          | "defaultGroupLeaderboard"
          | "defaultLeaderboard"
          | "gameCenterAchievements"
          | "gameCenterAppVersions"
          | "gameCenterGroup"
          | "gameCenterLeaderboardSets"
          | "gameCenterLeaderboards"
          | "leaderboardReleases"
          | "leaderboardSetReleases"
        )[];
      },
      params: RequestParams = {},
    ): Promise<GameCenterDetailResponse> =>
      this.request<GameCenterDetailResponse, ErrorResponse>({
        path: `/v1/apps/${id}/gameCenterDetail`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Apps
     * @name AppsGameCenterEnabledVersionsGetToManyRelated
     * @request GET:/v1/apps/{id}/gameCenterEnabledVersions
     * @deprecated
     * @secure
     */
    gameCenterEnabledVersionsGetToManyRelated: (
      id: string,
      query?: {
        /** filter by attribute 'platform' */
        "filter[platform]"?: ("IOS" | "MAC_OS" | "TV_OS" | "VISION_OS")[];
        /** filter by attribute 'versionString' */
        "filter[versionString]"?: string[];
        /** filter by id(s) */
        "filter[id]"?: string[];
        /** comma-separated list of sort expressions; resources will be sorted as specified */
        sort?: ("versionString" | "-versionString")[];
        /** the fields to include for returned resources of type gameCenterEnabledVersions */
        "fields[gameCenterEnabledVersions]"?: (
          | "app"
          | "compatibleVersions"
          | "iconAsset"
          | "platform"
          | "versionString"
        )[];
        /** the fields to include for returned resources of type apps */
        "fields[apps]"?: (
          | "alternativeDistributionKey"
          | "analyticsReportRequests"
          | "appAvailability"
          | "appClips"
          | "appCustomProductPages"
          | "appEncryptionDeclarations"
          | "appEvents"
          | "appInfos"
          | "appPricePoints"
          | "appPriceSchedule"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersions"
          | "availableInNewTerritories"
          | "availableTerritories"
          | "betaAppLocalizations"
          | "betaAppReviewDetail"
          | "betaGroups"
          | "betaLicenseAgreement"
          | "betaTesters"
          | "builds"
          | "bundleId"
          | "ciProduct"
          | "contentRightsDeclaration"
          | "customerReviews"
          | "endUserLicenseAgreement"
          | "gameCenterDetail"
          | "gameCenterEnabledVersions"
          | "inAppPurchases"
          | "inAppPurchasesV2"
          | "isOrEverWasMadeForKids"
          | "marketplaceSearchDetail"
          | "name"
          | "perfPowerMetrics"
          | "preOrder"
          | "preReleaseVersions"
          | "pricePoints"
          | "prices"
          | "primaryLocale"
          | "promotedPurchases"
          | "reviewSubmissions"
          | "sku"
          | "subscriptionGracePeriod"
          | "subscriptionGroups"
          | "subscriptionStatusUrl"
          | "subscriptionStatusUrlForSandbox"
          | "subscriptionStatusUrlVersion"
          | "subscriptionStatusUrlVersionForSandbox"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /**
         * maximum number of related compatibleVersions returned (when they are included)
         * @deprecated
         * @max 50
         */
        "limit[compatibleVersions]"?: number;
        /** comma-separated list of relationships to include */
        include?: ("app" | "compatibleVersions")[];
      },
      params: RequestParams = {},
    ): Promise<GameCenterEnabledVersionsResponse> =>
      this.request<GameCenterEnabledVersionsResponse, ErrorResponse>({
        path: `/v1/apps/${id}/gameCenterEnabledVersions`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Apps
     * @name AppsInAppPurchasesGetToManyRelated
     * @request GET:/v1/apps/{id}/inAppPurchases
     * @deprecated
     * @secure
     */
    inAppPurchasesGetToManyRelated: (
      id: string,
      query?: {
        /** filter by attribute 'inAppPurchaseType' */
        "filter[inAppPurchaseType]"?: (
          | "AUTOMATICALLY_RENEWABLE_SUBSCRIPTION"
          | "NON_CONSUMABLE"
          | "CONSUMABLE"
          | "NON_RENEWING_SUBSCRIPTION"
          | "FREE_SUBSCRIPTION"
        )[];
        /** filter by canBeSubmitted */
        "filter[canBeSubmitted]"?: string[];
        /** comma-separated list of sort expressions; resources will be sorted as specified */
        sort?: (
          | "inAppPurchaseType"
          | "-inAppPurchaseType"
          | "productId"
          | "-productId"
          | "referenceName"
          | "-referenceName"
        )[];
        /** the fields to include for returned resources of type inAppPurchases */
        "fields[inAppPurchases]"?: ("apps" | "inAppPurchaseType" | "productId" | "referenceName" | "state")[];
        /** the fields to include for returned resources of type apps */
        "fields[apps]"?: (
          | "alternativeDistributionKey"
          | "analyticsReportRequests"
          | "appAvailability"
          | "appClips"
          | "appCustomProductPages"
          | "appEncryptionDeclarations"
          | "appEvents"
          | "appInfos"
          | "appPricePoints"
          | "appPriceSchedule"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersions"
          | "availableInNewTerritories"
          | "availableTerritories"
          | "betaAppLocalizations"
          | "betaAppReviewDetail"
          | "betaGroups"
          | "betaLicenseAgreement"
          | "betaTesters"
          | "builds"
          | "bundleId"
          | "ciProduct"
          | "contentRightsDeclaration"
          | "customerReviews"
          | "endUserLicenseAgreement"
          | "gameCenterDetail"
          | "gameCenterEnabledVersions"
          | "inAppPurchases"
          | "inAppPurchasesV2"
          | "isOrEverWasMadeForKids"
          | "marketplaceSearchDetail"
          | "name"
          | "perfPowerMetrics"
          | "preOrder"
          | "preReleaseVersions"
          | "pricePoints"
          | "prices"
          | "primaryLocale"
          | "promotedPurchases"
          | "reviewSubmissions"
          | "sku"
          | "subscriptionGracePeriod"
          | "subscriptionGroups"
          | "subscriptionStatusUrl"
          | "subscriptionStatusUrlForSandbox"
          | "subscriptionStatusUrlVersion"
          | "subscriptionStatusUrlVersionForSandbox"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /**
         * maximum number of related apps returned (when they are included)
         * @max 50
         */
        "limit[apps]"?: number;
        /** comma-separated list of relationships to include */
        include?: "apps"[];
      },
      params: RequestParams = {},
    ): Promise<InAppPurchasesResponse> =>
      this.request<InAppPurchasesResponse, ErrorResponse>({
        path: `/v1/apps/${id}/inAppPurchases`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Apps
     * @name AppsInAppPurchasesV2GetToManyRelated
     * @request GET:/v1/apps/{id}/inAppPurchasesV2
     * @secure
     */
    inAppPurchasesV2GetToManyRelated: (
      id: string,
      query?: {
        /** filter by attribute 'inAppPurchaseType' */
        "filter[inAppPurchaseType]"?: ("CONSUMABLE" | "NON_CONSUMABLE" | "NON_RENEWING_SUBSCRIPTION")[];
        /** filter by attribute 'name' */
        "filter[name]"?: string[];
        /** filter by attribute 'productId' */
        "filter[productId]"?: string[];
        /** filter by attribute 'state' */
        "filter[state]"?: (
          | "MISSING_METADATA"
          | "WAITING_FOR_UPLOAD"
          | "PROCESSING_CONTENT"
          | "READY_TO_SUBMIT"
          | "WAITING_FOR_REVIEW"
          | "IN_REVIEW"
          | "DEVELOPER_ACTION_NEEDED"
          | "PENDING_BINARY_APPROVAL"
          | "APPROVED"
          | "DEVELOPER_REMOVED_FROM_SALE"
          | "REMOVED_FROM_SALE"
          | "REJECTED"
        )[];
        /** comma-separated list of sort expressions; resources will be sorted as specified */
        sort?: ("inAppPurchaseType" | "-inAppPurchaseType" | "name" | "-name")[];
        /** the fields to include for returned resources of type inAppPurchaseAppStoreReviewScreenshots */
        "fields[inAppPurchaseAppStoreReviewScreenshots]"?: (
          | "assetDeliveryState"
          | "assetToken"
          | "assetType"
          | "fileName"
          | "fileSize"
          | "imageAsset"
          | "inAppPurchaseV2"
          | "sourceFileChecksum"
          | "uploadOperations"
          | "uploaded"
        )[];
        /** the fields to include for returned resources of type inAppPurchaseAvailabilities */
        "fields[inAppPurchaseAvailabilities]"?: (
          | "availableInNewTerritories"
          | "availableTerritories"
          | "inAppPurchase"
        )[];
        /** the fields to include for returned resources of type promotedPurchases */
        "fields[promotedPurchases]"?: (
          | "app"
          | "enabled"
          | "inAppPurchaseV2"
          | "promotionImages"
          | "state"
          | "subscription"
          | "visibleForAllUsers"
        )[];
        /** the fields to include for returned resources of type inAppPurchaseLocalizations */
        "fields[inAppPurchaseLocalizations]"?: ("description" | "inAppPurchaseV2" | "locale" | "name" | "state")[];
        /** the fields to include for returned resources of type inAppPurchases */
        "fields[inAppPurchases]"?: (
          | "app"
          | "appStoreReviewScreenshot"
          | "content"
          | "contentHosting"
          | "familySharable"
          | "iapPriceSchedule"
          | "inAppPurchaseAvailability"
          | "inAppPurchaseLocalizations"
          | "inAppPurchaseType"
          | "name"
          | "productId"
          | "promotedPurchase"
          | "reviewNote"
          | "state"
        )[];
        /** the fields to include for returned resources of type inAppPurchasePriceSchedules */
        "fields[inAppPurchasePriceSchedules]"?: (
          | "automaticPrices"
          | "baseTerritory"
          | "inAppPurchase"
          | "manualPrices"
        )[];
        /** the fields to include for returned resources of type inAppPurchaseContents */
        "fields[inAppPurchaseContents]"?: ("fileName" | "fileSize" | "inAppPurchaseV2" | "lastModifiedDate" | "url")[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /**
         * maximum number of related inAppPurchaseLocalizations returned (when they are included)
         * @max 50
         */
        "limit[inAppPurchaseLocalizations]"?: number;
        /** comma-separated list of relationships to include */
        include?: (
          | "appStoreReviewScreenshot"
          | "content"
          | "iapPriceSchedule"
          | "inAppPurchaseAvailability"
          | "inAppPurchaseLocalizations"
          | "promotedPurchase"
        )[];
      },
      params: RequestParams = {},
    ): Promise<InAppPurchasesV2Response> =>
      this.request<InAppPurchasesV2Response, ErrorResponse>({
        path: `/v1/apps/${id}/inAppPurchasesV2`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Apps
     * @name AppsMarketplaceSearchDetailGetToOneRelated
     * @request GET:/v1/apps/{id}/marketplaceSearchDetail
     * @secure
     */
    marketplaceSearchDetailGetToOneRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type marketplaceSearchDetails */
        "fields[marketplaceSearchDetails]"?: ("app" | "catalogUrl")[];
      },
      params: RequestParams = {},
    ): Promise<MarketplaceSearchDetailResponse> =>
      this.request<MarketplaceSearchDetailResponse, ErrorResponse>({
        path: `/v1/apps/${id}/marketplaceSearchDetail`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Apps
     * @name AppsPerfPowerMetricsGetToManyRelated
     * @request GET:/v1/apps/{id}/perfPowerMetrics
     * @secure
     */
    perfPowerMetricsGetToManyRelated: (
      id: string,
      query?: {
        /** filter by attribute 'deviceType' */
        "filter[deviceType]"?: string[];
        /** filter by attribute 'metricType' */
        "filter[metricType]"?: ("DISK" | "HANG" | "BATTERY" | "LAUNCH" | "MEMORY" | "ANIMATION" | "TERMINATION")[];
        /** filter by attribute 'platform' */
        "filter[platform]"?: "IOS"[];
      },
      params: RequestParams = {},
    ): Promise<XcodeMetrics> =>
      this.request<XcodeMetrics, ErrorResponse>({
        path: `/v1/apps/${id}/perfPowerMetrics`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Apps
     * @name AppsPreOrderGetToOneRelated
     * @request GET:/v1/apps/{id}/preOrder
     * @deprecated
     * @secure
     */
    preOrderGetToOneRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type appPreOrders */
        "fields[appPreOrders]"?: ("app" | "appReleaseDate" | "preOrderAvailableDate")[];
      },
      params: RequestParams = {},
    ): Promise<AppPreOrderWithoutIncludesResponse> =>
      this.request<AppPreOrderWithoutIncludesResponse, ErrorResponse>({
        path: `/v1/apps/${id}/preOrder`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Apps
     * @name AppsPreReleaseVersionsGetToManyRelated
     * @request GET:/v1/apps/{id}/preReleaseVersions
     * @secure
     */
    preReleaseVersionsGetToManyRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type preReleaseVersions */
        "fields[preReleaseVersions]"?: ("app" | "builds" | "platform" | "version")[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
      },
      params: RequestParams = {},
    ): Promise<PreReleaseVersionsWithoutIncludesResponse> =>
      this.request<PreReleaseVersionsWithoutIncludesResponse, ErrorResponse>({
        path: `/v1/apps/${id}/preReleaseVersions`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Apps
     * @name AppsPricePointsGetToManyRelated
     * @request GET:/v1/apps/{id}/pricePoints
     * @deprecated
     * @secure
     */
    pricePointsGetToManyRelated: (
      id: string,
      query?: {
        /**
         * filter by id(s) of related 'priceTier'
         * @deprecated
         */
        "filter[priceTier]"?: string[];
        /** filter by id(s) of related 'territory' */
        "filter[territory]"?: string[];
        /** the fields to include for returned resources of type appPriceTiers */
        "fields[appPriceTiers]"?: "pricePoints"[];
        /** the fields to include for returned resources of type appPricePoints */
        "fields[appPricePoints]"?: ("app" | "customerPrice" | "priceTier" | "proceeds" | "territory")[];
        /** the fields to include for returned resources of type apps */
        "fields[apps]"?: (
          | "alternativeDistributionKey"
          | "analyticsReportRequests"
          | "appAvailability"
          | "appClips"
          | "appCustomProductPages"
          | "appEncryptionDeclarations"
          | "appEvents"
          | "appInfos"
          | "appPricePoints"
          | "appPriceSchedule"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersions"
          | "availableInNewTerritories"
          | "availableTerritories"
          | "betaAppLocalizations"
          | "betaAppReviewDetail"
          | "betaGroups"
          | "betaLicenseAgreement"
          | "betaTesters"
          | "builds"
          | "bundleId"
          | "ciProduct"
          | "contentRightsDeclaration"
          | "customerReviews"
          | "endUserLicenseAgreement"
          | "gameCenterDetail"
          | "gameCenterEnabledVersions"
          | "inAppPurchases"
          | "inAppPurchasesV2"
          | "isOrEverWasMadeForKids"
          | "marketplaceSearchDetail"
          | "name"
          | "perfPowerMetrics"
          | "preOrder"
          | "preReleaseVersions"
          | "pricePoints"
          | "prices"
          | "primaryLocale"
          | "promotedPurchases"
          | "reviewSubmissions"
          | "sku"
          | "subscriptionGracePeriod"
          | "subscriptionGroups"
          | "subscriptionStatusUrl"
          | "subscriptionStatusUrlForSandbox"
          | "subscriptionStatusUrlVersion"
          | "subscriptionStatusUrlVersionForSandbox"
        )[];
        /** the fields to include for returned resources of type territories */
        "fields[territories]"?: "currency"[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /** comma-separated list of relationships to include */
        include?: ("app" | "priceTier" | "territory")[];
      },
      params: RequestParams = {},
    ): Promise<AppPricePointsV2Response> =>
      this.request<AppPricePointsV2Response, ErrorResponse>({
        path: `/v1/apps/${id}/pricePoints`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Apps
     * @name AppsPricesGetToManyRelated
     * @request GET:/v1/apps/{id}/prices
     * @deprecated
     * @secure
     */
    pricesGetToManyRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type appPriceTiers */
        "fields[appPriceTiers]"?: "pricePoints"[];
        /** the fields to include for returned resources of type apps */
        "fields[apps]"?: (
          | "alternativeDistributionKey"
          | "analyticsReportRequests"
          | "appAvailability"
          | "appClips"
          | "appCustomProductPages"
          | "appEncryptionDeclarations"
          | "appEvents"
          | "appInfos"
          | "appPricePoints"
          | "appPriceSchedule"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersions"
          | "availableInNewTerritories"
          | "availableTerritories"
          | "betaAppLocalizations"
          | "betaAppReviewDetail"
          | "betaGroups"
          | "betaLicenseAgreement"
          | "betaTesters"
          | "builds"
          | "bundleId"
          | "ciProduct"
          | "contentRightsDeclaration"
          | "customerReviews"
          | "endUserLicenseAgreement"
          | "gameCenterDetail"
          | "gameCenterEnabledVersions"
          | "inAppPurchases"
          | "inAppPurchasesV2"
          | "isOrEverWasMadeForKids"
          | "marketplaceSearchDetail"
          | "name"
          | "perfPowerMetrics"
          | "preOrder"
          | "preReleaseVersions"
          | "pricePoints"
          | "prices"
          | "primaryLocale"
          | "promotedPurchases"
          | "reviewSubmissions"
          | "sku"
          | "subscriptionGracePeriod"
          | "subscriptionGroups"
          | "subscriptionStatusUrl"
          | "subscriptionStatusUrlForSandbox"
          | "subscriptionStatusUrlVersion"
          | "subscriptionStatusUrlVersionForSandbox"
        )[];
        /** the fields to include for returned resources of type appPrices */
        "fields[appPrices]"?: ("app" | "priceTier")[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /** comma-separated list of relationships to include */
        include?: ("app" | "priceTier")[];
      },
      params: RequestParams = {},
    ): Promise<AppPricesResponse> =>
      this.request<AppPricesResponse, ErrorResponse>({
        path: `/v1/apps/${id}/prices`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Apps
     * @name AppsPromotedPurchasesGetToManyRelationship
     * @request GET:/v1/apps/{id}/relationships/promotedPurchases
     * @secure
     */
    promotedPurchasesGetToManyRelationship: (
      id: string,
      query?: {
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
      },
      params: RequestParams = {},
    ): Promise<AppPromotedPurchasesLinkagesResponse> =>
      this.request<AppPromotedPurchasesLinkagesResponse, ErrorResponse>({
        path: `/v1/apps/${id}/relationships/promotedPurchases`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Apps
     * @name AppsPromotedPurchasesReplaceToManyRelationship
     * @request PATCH:/v1/apps/{id}/relationships/promotedPurchases
     * @secure
     */
    promotedPurchasesReplaceToManyRelationship: (
      id: string,
      data: AppPromotedPurchasesLinkagesRequest,
      params: RequestParams = {},
    ): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/apps/${id}/relationships/promotedPurchases`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * No description
     *
     * @tags Apps
     * @name AppsPromotedPurchasesGetToManyRelated
     * @request GET:/v1/apps/{id}/promotedPurchases
     * @secure
     */
    promotedPurchasesGetToManyRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type promotedPurchases */
        "fields[promotedPurchases]"?: (
          | "app"
          | "enabled"
          | "inAppPurchaseV2"
          | "promotionImages"
          | "state"
          | "subscription"
          | "visibleForAllUsers"
        )[];
        /** the fields to include for returned resources of type subscriptions */
        "fields[subscriptions]"?: (
          | "appStoreReviewScreenshot"
          | "familySharable"
          | "group"
          | "groupLevel"
          | "introductoryOffers"
          | "name"
          | "offerCodes"
          | "pricePoints"
          | "prices"
          | "productId"
          | "promotedPurchase"
          | "promotionalOffers"
          | "reviewNote"
          | "state"
          | "subscriptionAvailability"
          | "subscriptionLocalizations"
          | "subscriptionPeriod"
        )[];
        /** the fields to include for returned resources of type inAppPurchases */
        "fields[inAppPurchases]"?: (
          | "app"
          | "appStoreReviewScreenshot"
          | "content"
          | "contentHosting"
          | "familySharable"
          | "iapPriceSchedule"
          | "inAppPurchaseAvailability"
          | "inAppPurchaseLocalizations"
          | "inAppPurchaseType"
          | "name"
          | "pricePoints"
          | "productId"
          | "promotedPurchase"
          | "reviewNote"
          | "state"
        )[];
        /** the fields to include for returned resources of type promotedPurchaseImages */
        "fields[promotedPurchaseImages]"?: (
          | "assetToken"
          | "assetType"
          | "fileName"
          | "fileSize"
          | "imageAsset"
          | "promotedPurchase"
          | "sourceFileChecksum"
          | "state"
          | "uploadOperations"
          | "uploaded"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /**
         * maximum number of related promotionImages returned (when they are included)
         * @max 50
         */
        "limit[promotionImages]"?: number;
        /** comma-separated list of relationships to include */
        include?: ("inAppPurchaseV2" | "promotionImages" | "subscription")[];
      },
      params: RequestParams = {},
    ): Promise<PromotedPurchasesResponse> =>
      this.request<PromotedPurchasesResponse, ErrorResponse>({
        path: `/v1/apps/${id}/promotedPurchases`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Apps
     * @name AppsReviewSubmissionsGetToManyRelated
     * @request GET:/v1/apps/{id}/reviewSubmissions
     * @secure
     */
    reviewSubmissionsGetToManyRelated: (
      id: string,
      query?: {
        /** filter by attribute 'platform' */
        "filter[platform]"?: ("IOS" | "MAC_OS" | "TV_OS" | "VISION_OS")[];
        /** filter by attribute 'state' */
        "filter[state]"?: (
          | "READY_FOR_REVIEW"
          | "WAITING_FOR_REVIEW"
          | "IN_REVIEW"
          | "UNRESOLVED_ISSUES"
          | "CANCELING"
          | "COMPLETING"
          | "COMPLETE"
        )[];
        /** the fields to include for returned resources of type reviewSubmissionItems */
        "fields[reviewSubmissionItems]"?: (
          | "appCustomProductPageVersion"
          | "appEvent"
          | "appStoreVersion"
          | "appStoreVersionExperiment"
          | "appStoreVersionExperimentV2"
          | "removed"
          | "resolved"
          | "reviewSubmission"
          | "state"
        )[];
        /** the fields to include for returned resources of type actors */
        "fields[actors]"?: ("actorType" | "apiKeyId" | "userEmail" | "userFirstName" | "userLastName")[];
        /** the fields to include for returned resources of type appStoreVersions */
        "fields[appStoreVersions]"?: (
          | "ageRatingDeclaration"
          | "alternativeDistributionPackage"
          | "app"
          | "appClipDefaultExperience"
          | "appStoreReviewDetail"
          | "appStoreState"
          | "appStoreVersionExperiments"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersionLocalizations"
          | "appStoreVersionPhasedRelease"
          | "appStoreVersionSubmission"
          | "appVersionState"
          | "build"
          | "copyright"
          | "createdDate"
          | "customerReviews"
          | "downloadable"
          | "earliestReleaseDate"
          | "platform"
          | "releaseType"
          | "reviewType"
          | "routingAppCoverage"
          | "versionString"
        )[];
        /** the fields to include for returned resources of type apps */
        "fields[apps]"?: (
          | "alternativeDistributionKey"
          | "analyticsReportRequests"
          | "appAvailability"
          | "appClips"
          | "appCustomProductPages"
          | "appEncryptionDeclarations"
          | "appEvents"
          | "appInfos"
          | "appPricePoints"
          | "appPriceSchedule"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersions"
          | "availableInNewTerritories"
          | "availableTerritories"
          | "betaAppLocalizations"
          | "betaAppReviewDetail"
          | "betaGroups"
          | "betaLicenseAgreement"
          | "betaTesters"
          | "builds"
          | "bundleId"
          | "ciProduct"
          | "contentRightsDeclaration"
          | "customerReviews"
          | "endUserLicenseAgreement"
          | "gameCenterDetail"
          | "gameCenterEnabledVersions"
          | "inAppPurchases"
          | "inAppPurchasesV2"
          | "isOrEverWasMadeForKids"
          | "marketplaceSearchDetail"
          | "name"
          | "perfPowerMetrics"
          | "preOrder"
          | "preReleaseVersions"
          | "pricePoints"
          | "prices"
          | "primaryLocale"
          | "promotedPurchases"
          | "reviewSubmissions"
          | "sku"
          | "subscriptionGracePeriod"
          | "subscriptionGroups"
          | "subscriptionStatusUrl"
          | "subscriptionStatusUrlForSandbox"
          | "subscriptionStatusUrlVersion"
          | "subscriptionStatusUrlVersionForSandbox"
        )[];
        /** the fields to include for returned resources of type reviewSubmissions */
        "fields[reviewSubmissions]"?: (
          | "app"
          | "appStoreVersionForReview"
          | "canceled"
          | "items"
          | "lastUpdatedByActor"
          | "platform"
          | "state"
          | "submitted"
          | "submittedByActor"
          | "submittedDate"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /**
         * maximum number of related items returned (when they are included)
         * @max 50
         */
        "limit[items]"?: number;
        /** comma-separated list of relationships to include */
        include?: ("app" | "appStoreVersionForReview" | "items" | "lastUpdatedByActor" | "submittedByActor")[];
      },
      params: RequestParams = {},
    ): Promise<ReviewSubmissionsResponse> =>
      this.request<ReviewSubmissionsResponse, ErrorResponse>({
        path: `/v1/apps/${id}/reviewSubmissions`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Apps
     * @name AppsSubscriptionGracePeriodGetToOneRelated
     * @request GET:/v1/apps/{id}/subscriptionGracePeriod
     * @secure
     */
    subscriptionGracePeriodGetToOneRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type subscriptionGracePeriods */
        "fields[subscriptionGracePeriods]"?: ("duration" | "optIn" | "renewalType" | "sandboxOptIn")[];
      },
      params: RequestParams = {},
    ): Promise<SubscriptionGracePeriodResponse> =>
      this.request<SubscriptionGracePeriodResponse, ErrorResponse>({
        path: `/v1/apps/${id}/subscriptionGracePeriod`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Apps
     * @name AppsSubscriptionGroupsGetToManyRelated
     * @request GET:/v1/apps/{id}/subscriptionGroups
     * @secure
     */
    subscriptionGroupsGetToManyRelated: (
      id: string,
      query?: {
        /** filter by attribute 'referenceName' */
        "filter[referenceName]"?: string[];
        /** filter by attribute 'subscriptions.state' */
        filterSubscriptionsState?: (
          | "MISSING_METADATA"
          | "READY_TO_SUBMIT"
          | "WAITING_FOR_REVIEW"
          | "IN_REVIEW"
          | "DEVELOPER_ACTION_NEEDED"
          | "PENDING_BINARY_APPROVAL"
          | "APPROVED"
          | "DEVELOPER_REMOVED_FROM_SALE"
          | "REMOVED_FROM_SALE"
          | "REJECTED"
        )[];
        /** comma-separated list of sort expressions; resources will be sorted as specified */
        sort?: ("referenceName" | "-referenceName")[];
        /** the fields to include for returned resources of type subscriptions */
        "fields[subscriptions]"?: (
          | "appStoreReviewScreenshot"
          | "familySharable"
          | "group"
          | "groupLevel"
          | "introductoryOffers"
          | "name"
          | "offerCodes"
          | "pricePoints"
          | "prices"
          | "productId"
          | "promotedPurchase"
          | "promotionalOffers"
          | "reviewNote"
          | "state"
          | "subscriptionAvailability"
          | "subscriptionLocalizations"
          | "subscriptionPeriod"
        )[];
        /** the fields to include for returned resources of type subscriptionGroups */
        "fields[subscriptionGroups]"?: ("app" | "referenceName" | "subscriptionGroupLocalizations" | "subscriptions")[];
        /** the fields to include for returned resources of type subscriptionGroupLocalizations */
        "fields[subscriptionGroupLocalizations]"?: (
          | "customAppName"
          | "locale"
          | "name"
          | "state"
          | "subscriptionGroup"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /**
         * maximum number of related subscriptions returned (when they are included)
         * @max 50
         */
        "limit[subscriptions]"?: number;
        /**
         * maximum number of related subscriptionGroupLocalizations returned (when they are included)
         * @max 50
         */
        "limit[subscriptionGroupLocalizations]"?: number;
        /** comma-separated list of relationships to include */
        include?: ("subscriptionGroupLocalizations" | "subscriptions")[];
      },
      params: RequestParams = {},
    ): Promise<SubscriptionGroupsResponse> =>
      this.request<SubscriptionGroupsResponse, ErrorResponse>({
        path: `/v1/apps/${id}/subscriptionGroups`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Apps, Metrics
     * @name AppsBetaTesterUsagesGetMetrics
     * @request GET:/v1/apps/{id}/metrics/betaTesterUsages
     * @secure
     */
    betaTesterUsagesGetMetrics: (
      id: string,
      query?: {
        /**
         * maximum number of groups to return per page
         * @max 200
         */
        limit?: number;
        /** the dimension by which to group the results */
        groupBy?: "betaTesters"[];
        /** filter by 'betaTesters' relationship dimension */
        "filter[betaTesters]"?: string;
        /** the duration of the reporting period */
        period?: "P7D" | "P30D" | "P90D" | "P365D";
      },
      params: RequestParams = {},
    ): Promise<AppsBetaTesterUsagesV1MetricResponse> =>
      this.request<AppsBetaTesterUsagesV1MetricResponse, ErrorResponse>({
        path: `/v1/apps/${id}/metrics/betaTesterUsages`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  betaAppClipInvocationLocalizations = {
    /**
     * No description
     *
     * @tags BetaAppClipInvocationLocalizations
     * @name BetaAppClipInvocationLocalizationsCreateInstance
     * @request POST:/v1/betaAppClipInvocationLocalizations
     * @secure
     */
    createInstance: (
      data: BetaAppClipInvocationLocalizationCreateRequest,
      params: RequestParams = {},
    ): Promise<BetaAppClipInvocationLocalizationResponse> =>
      this.request<BetaAppClipInvocationLocalizationResponse, ErrorResponse>({
        path: `/v1/betaAppClipInvocationLocalizations`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags BetaAppClipInvocationLocalizations
     * @name BetaAppClipInvocationLocalizationsUpdateInstance
     * @request PATCH:/v1/betaAppClipInvocationLocalizations/{id}
     * @secure
     */
    updateInstance: (
      id: string,
      data: BetaAppClipInvocationLocalizationUpdateRequest,
      params: RequestParams = {},
    ): Promise<BetaAppClipInvocationLocalizationResponse> =>
      this.request<BetaAppClipInvocationLocalizationResponse, ErrorResponse>({
        path: `/v1/betaAppClipInvocationLocalizations/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags BetaAppClipInvocationLocalizations
     * @name BetaAppClipInvocationLocalizationsDeleteInstance
     * @request DELETE:/v1/betaAppClipInvocationLocalizations/{id}
     * @secure
     */
    deleteInstance: (id: string, params: RequestParams = {}): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/betaAppClipInvocationLocalizations/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),
  };
  betaAppClipInvocations = {
    /**
     * No description
     *
     * @tags BetaAppClipInvocations
     * @name BetaAppClipInvocationsCreateInstance
     * @request POST:/v1/betaAppClipInvocations
     * @secure
     */
    createInstance: (
      data: BetaAppClipInvocationCreateRequest,
      params: RequestParams = {},
    ): Promise<BetaAppClipInvocationResponse> =>
      this.request<BetaAppClipInvocationResponse, ErrorResponse>({
        path: `/v1/betaAppClipInvocations`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags BetaAppClipInvocations
     * @name BetaAppClipInvocationsGetInstance
     * @request GET:/v1/betaAppClipInvocations/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type betaAppClipInvocations */
        "fields[betaAppClipInvocations]"?: ("betaAppClipInvocationLocalizations" | "buildBundle" | "url")[];
        /** comma-separated list of relationships to include */
        include?: "betaAppClipInvocationLocalizations"[];
        /**
         * maximum number of related betaAppClipInvocationLocalizations returned (when they are included)
         * @max 50
         */
        "limit[betaAppClipInvocationLocalizations]"?: number;
      },
      params: RequestParams = {},
    ): Promise<BetaAppClipInvocationResponse> =>
      this.request<BetaAppClipInvocationResponse, ErrorResponse>({
        path: `/v1/betaAppClipInvocations/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags BetaAppClipInvocations
     * @name BetaAppClipInvocationsUpdateInstance
     * @request PATCH:/v1/betaAppClipInvocations/{id}
     * @secure
     */
    updateInstance: (
      id: string,
      data: BetaAppClipInvocationUpdateRequest,
      params: RequestParams = {},
    ): Promise<BetaAppClipInvocationResponse> =>
      this.request<BetaAppClipInvocationResponse, ErrorResponse>({
        path: `/v1/betaAppClipInvocations/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags BetaAppClipInvocations
     * @name BetaAppClipInvocationsDeleteInstance
     * @request DELETE:/v1/betaAppClipInvocations/{id}
     * @secure
     */
    deleteInstance: (id: string, params: RequestParams = {}): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/betaAppClipInvocations/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),
  };
  betaAppLocalizations = {
    /**
     * No description
     *
     * @tags BetaAppLocalizations
     * @name BetaAppLocalizationsGetCollection
     * @request GET:/v1/betaAppLocalizations
     * @secure
     */
    getCollection: (
      query?: {
        /** filter by attribute 'locale' */
        "filter[locale]"?: string[];
        /** filter by id(s) of related 'app' */
        "filter[app]"?: string[];
        /** the fields to include for returned resources of type betaAppLocalizations */
        "fields[betaAppLocalizations]"?: (
          | "app"
          | "description"
          | "feedbackEmail"
          | "locale"
          | "marketingUrl"
          | "privacyPolicyUrl"
          | "tvOsPrivacyPolicy"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /** comma-separated list of relationships to include */
        include?: "app"[];
        /** the fields to include for returned resources of type apps */
        "fields[apps]"?: (
          | "alternativeDistributionKey"
          | "analyticsReportRequests"
          | "appAvailability"
          | "appClips"
          | "appCustomProductPages"
          | "appEncryptionDeclarations"
          | "appEvents"
          | "appInfos"
          | "appPricePoints"
          | "appPriceSchedule"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersions"
          | "availableInNewTerritories"
          | "availableTerritories"
          | "betaAppLocalizations"
          | "betaAppReviewDetail"
          | "betaGroups"
          | "betaLicenseAgreement"
          | "betaTesters"
          | "builds"
          | "bundleId"
          | "ciProduct"
          | "contentRightsDeclaration"
          | "customerReviews"
          | "endUserLicenseAgreement"
          | "gameCenterDetail"
          | "gameCenterEnabledVersions"
          | "inAppPurchases"
          | "inAppPurchasesV2"
          | "isOrEverWasMadeForKids"
          | "marketplaceSearchDetail"
          | "name"
          | "perfPowerMetrics"
          | "preOrder"
          | "preReleaseVersions"
          | "pricePoints"
          | "prices"
          | "primaryLocale"
          | "promotedPurchases"
          | "reviewSubmissions"
          | "sku"
          | "subscriptionGracePeriod"
          | "subscriptionGroups"
          | "subscriptionStatusUrl"
          | "subscriptionStatusUrlForSandbox"
          | "subscriptionStatusUrlVersion"
          | "subscriptionStatusUrlVersionForSandbox"
        )[];
      },
      params: RequestParams = {},
    ): Promise<BetaAppLocalizationsResponse> =>
      this.request<BetaAppLocalizationsResponse, ErrorResponse>({
        path: `/v1/betaAppLocalizations`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags BetaAppLocalizations
     * @name BetaAppLocalizationsCreateInstance
     * @request POST:/v1/betaAppLocalizations
     * @secure
     */
    createInstance: (
      data: BetaAppLocalizationCreateRequest,
      params: RequestParams = {},
    ): Promise<BetaAppLocalizationResponse> =>
      this.request<BetaAppLocalizationResponse, ErrorResponse>({
        path: `/v1/betaAppLocalizations`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags BetaAppLocalizations
     * @name BetaAppLocalizationsGetInstance
     * @request GET:/v1/betaAppLocalizations/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type betaAppLocalizations */
        "fields[betaAppLocalizations]"?: (
          | "app"
          | "description"
          | "feedbackEmail"
          | "locale"
          | "marketingUrl"
          | "privacyPolicyUrl"
          | "tvOsPrivacyPolicy"
        )[];
        /** comma-separated list of relationships to include */
        include?: "app"[];
        /** the fields to include for returned resources of type apps */
        "fields[apps]"?: (
          | "alternativeDistributionKey"
          | "analyticsReportRequests"
          | "appAvailability"
          | "appClips"
          | "appCustomProductPages"
          | "appEncryptionDeclarations"
          | "appEvents"
          | "appInfos"
          | "appPricePoints"
          | "appPriceSchedule"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersions"
          | "availableInNewTerritories"
          | "availableTerritories"
          | "betaAppLocalizations"
          | "betaAppReviewDetail"
          | "betaGroups"
          | "betaLicenseAgreement"
          | "betaTesters"
          | "builds"
          | "bundleId"
          | "ciProduct"
          | "contentRightsDeclaration"
          | "customerReviews"
          | "endUserLicenseAgreement"
          | "gameCenterDetail"
          | "gameCenterEnabledVersions"
          | "inAppPurchases"
          | "inAppPurchasesV2"
          | "isOrEverWasMadeForKids"
          | "marketplaceSearchDetail"
          | "name"
          | "perfPowerMetrics"
          | "preOrder"
          | "preReleaseVersions"
          | "pricePoints"
          | "prices"
          | "primaryLocale"
          | "promotedPurchases"
          | "reviewSubmissions"
          | "sku"
          | "subscriptionGracePeriod"
          | "subscriptionGroups"
          | "subscriptionStatusUrl"
          | "subscriptionStatusUrlForSandbox"
          | "subscriptionStatusUrlVersion"
          | "subscriptionStatusUrlVersionForSandbox"
        )[];
      },
      params: RequestParams = {},
    ): Promise<BetaAppLocalizationResponse> =>
      this.request<BetaAppLocalizationResponse, ErrorResponse>({
        path: `/v1/betaAppLocalizations/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags BetaAppLocalizations
     * @name BetaAppLocalizationsUpdateInstance
     * @request PATCH:/v1/betaAppLocalizations/{id}
     * @secure
     */
    updateInstance: (
      id: string,
      data: BetaAppLocalizationUpdateRequest,
      params: RequestParams = {},
    ): Promise<BetaAppLocalizationResponse> =>
      this.request<BetaAppLocalizationResponse, ErrorResponse>({
        path: `/v1/betaAppLocalizations/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags BetaAppLocalizations
     * @name BetaAppLocalizationsDeleteInstance
     * @request DELETE:/v1/betaAppLocalizations/{id}
     * @secure
     */
    deleteInstance: (id: string, params: RequestParams = {}): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/betaAppLocalizations/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),

    /**
     * No description
     *
     * @tags BetaAppLocalizations
     * @name BetaAppLocalizationsAppGetToOneRelated
     * @request GET:/v1/betaAppLocalizations/{id}/app
     * @secure
     */
    appGetToOneRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type apps */
        "fields[apps]"?: (
          | "alternativeDistributionKey"
          | "analyticsReportRequests"
          | "appAvailability"
          | "appClips"
          | "appCustomProductPages"
          | "appEncryptionDeclarations"
          | "appEvents"
          | "appInfos"
          | "appPricePoints"
          | "appPriceSchedule"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersions"
          | "availableInNewTerritories"
          | "availableTerritories"
          | "betaAppLocalizations"
          | "betaAppReviewDetail"
          | "betaGroups"
          | "betaLicenseAgreement"
          | "betaTesters"
          | "builds"
          | "bundleId"
          | "ciProduct"
          | "contentRightsDeclaration"
          | "customerReviews"
          | "endUserLicenseAgreement"
          | "gameCenterDetail"
          | "gameCenterEnabledVersions"
          | "inAppPurchases"
          | "inAppPurchasesV2"
          | "isOrEverWasMadeForKids"
          | "marketplaceSearchDetail"
          | "name"
          | "perfPowerMetrics"
          | "preOrder"
          | "preReleaseVersions"
          | "pricePoints"
          | "prices"
          | "primaryLocale"
          | "promotedPurchases"
          | "reviewSubmissions"
          | "sku"
          | "subscriptionGracePeriod"
          | "subscriptionGroups"
          | "subscriptionStatusUrl"
          | "subscriptionStatusUrlForSandbox"
          | "subscriptionStatusUrlVersion"
          | "subscriptionStatusUrlVersionForSandbox"
        )[];
      },
      params: RequestParams = {},
    ): Promise<AppWithoutIncludesResponse> =>
      this.request<AppWithoutIncludesResponse, ErrorResponse>({
        path: `/v1/betaAppLocalizations/${id}/app`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  betaAppReviewDetails = {
    /**
     * No description
     *
     * @tags BetaAppReviewDetails
     * @name BetaAppReviewDetailsGetCollection
     * @request GET:/v1/betaAppReviewDetails
     * @secure
     */
    getCollection: (
      query: {
        /** filter by id(s) of related 'app' */
        "filter[app]": string[];
        /** the fields to include for returned resources of type betaAppReviewDetails */
        "fields[betaAppReviewDetails]"?: (
          | "app"
          | "contactEmail"
          | "contactFirstName"
          | "contactLastName"
          | "contactPhone"
          | "demoAccountName"
          | "demoAccountPassword"
          | "demoAccountRequired"
          | "notes"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /** comma-separated list of relationships to include */
        include?: "app"[];
        /** the fields to include for returned resources of type apps */
        "fields[apps]"?: (
          | "alternativeDistributionKey"
          | "analyticsReportRequests"
          | "appAvailability"
          | "appClips"
          | "appCustomProductPages"
          | "appEncryptionDeclarations"
          | "appEvents"
          | "appInfos"
          | "appPricePoints"
          | "appPriceSchedule"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersions"
          | "availableInNewTerritories"
          | "availableTerritories"
          | "betaAppLocalizations"
          | "betaAppReviewDetail"
          | "betaGroups"
          | "betaLicenseAgreement"
          | "betaTesters"
          | "builds"
          | "bundleId"
          | "ciProduct"
          | "contentRightsDeclaration"
          | "customerReviews"
          | "endUserLicenseAgreement"
          | "gameCenterDetail"
          | "gameCenterEnabledVersions"
          | "inAppPurchases"
          | "inAppPurchasesV2"
          | "isOrEverWasMadeForKids"
          | "marketplaceSearchDetail"
          | "name"
          | "perfPowerMetrics"
          | "preOrder"
          | "preReleaseVersions"
          | "pricePoints"
          | "prices"
          | "primaryLocale"
          | "promotedPurchases"
          | "reviewSubmissions"
          | "sku"
          | "subscriptionGracePeriod"
          | "subscriptionGroups"
          | "subscriptionStatusUrl"
          | "subscriptionStatusUrlForSandbox"
          | "subscriptionStatusUrlVersion"
          | "subscriptionStatusUrlVersionForSandbox"
        )[];
      },
      params: RequestParams = {},
    ): Promise<BetaAppReviewDetailsResponse> =>
      this.request<BetaAppReviewDetailsResponse, ErrorResponse>({
        path: `/v1/betaAppReviewDetails`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags BetaAppReviewDetails
     * @name BetaAppReviewDetailsGetInstance
     * @request GET:/v1/betaAppReviewDetails/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type betaAppReviewDetails */
        "fields[betaAppReviewDetails]"?: (
          | "app"
          | "contactEmail"
          | "contactFirstName"
          | "contactLastName"
          | "contactPhone"
          | "demoAccountName"
          | "demoAccountPassword"
          | "demoAccountRequired"
          | "notes"
        )[];
        /** comma-separated list of relationships to include */
        include?: "app"[];
        /** the fields to include for returned resources of type apps */
        "fields[apps]"?: (
          | "alternativeDistributionKey"
          | "analyticsReportRequests"
          | "appAvailability"
          | "appClips"
          | "appCustomProductPages"
          | "appEncryptionDeclarations"
          | "appEvents"
          | "appInfos"
          | "appPricePoints"
          | "appPriceSchedule"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersions"
          | "availableInNewTerritories"
          | "availableTerritories"
          | "betaAppLocalizations"
          | "betaAppReviewDetail"
          | "betaGroups"
          | "betaLicenseAgreement"
          | "betaTesters"
          | "builds"
          | "bundleId"
          | "ciProduct"
          | "contentRightsDeclaration"
          | "customerReviews"
          | "endUserLicenseAgreement"
          | "gameCenterDetail"
          | "gameCenterEnabledVersions"
          | "inAppPurchases"
          | "inAppPurchasesV2"
          | "isOrEverWasMadeForKids"
          | "marketplaceSearchDetail"
          | "name"
          | "perfPowerMetrics"
          | "preOrder"
          | "preReleaseVersions"
          | "pricePoints"
          | "prices"
          | "primaryLocale"
          | "promotedPurchases"
          | "reviewSubmissions"
          | "sku"
          | "subscriptionGracePeriod"
          | "subscriptionGroups"
          | "subscriptionStatusUrl"
          | "subscriptionStatusUrlForSandbox"
          | "subscriptionStatusUrlVersion"
          | "subscriptionStatusUrlVersionForSandbox"
        )[];
      },
      params: RequestParams = {},
    ): Promise<BetaAppReviewDetailResponse> =>
      this.request<BetaAppReviewDetailResponse, ErrorResponse>({
        path: `/v1/betaAppReviewDetails/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags BetaAppReviewDetails
     * @name BetaAppReviewDetailsUpdateInstance
     * @request PATCH:/v1/betaAppReviewDetails/{id}
     * @secure
     */
    updateInstance: (
      id: string,
      data: BetaAppReviewDetailUpdateRequest,
      params: RequestParams = {},
    ): Promise<BetaAppReviewDetailResponse> =>
      this.request<BetaAppReviewDetailResponse, ErrorResponse>({
        path: `/v1/betaAppReviewDetails/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags BetaAppReviewDetails
     * @name BetaAppReviewDetailsAppGetToOneRelated
     * @request GET:/v1/betaAppReviewDetails/{id}/app
     * @secure
     */
    appGetToOneRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type apps */
        "fields[apps]"?: (
          | "alternativeDistributionKey"
          | "analyticsReportRequests"
          | "appAvailability"
          | "appClips"
          | "appCustomProductPages"
          | "appEncryptionDeclarations"
          | "appEvents"
          | "appInfos"
          | "appPricePoints"
          | "appPriceSchedule"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersions"
          | "availableInNewTerritories"
          | "availableTerritories"
          | "betaAppLocalizations"
          | "betaAppReviewDetail"
          | "betaGroups"
          | "betaLicenseAgreement"
          | "betaTesters"
          | "builds"
          | "bundleId"
          | "ciProduct"
          | "contentRightsDeclaration"
          | "customerReviews"
          | "endUserLicenseAgreement"
          | "gameCenterDetail"
          | "gameCenterEnabledVersions"
          | "inAppPurchases"
          | "inAppPurchasesV2"
          | "isOrEverWasMadeForKids"
          | "marketplaceSearchDetail"
          | "name"
          | "perfPowerMetrics"
          | "preOrder"
          | "preReleaseVersions"
          | "pricePoints"
          | "prices"
          | "primaryLocale"
          | "promotedPurchases"
          | "reviewSubmissions"
          | "sku"
          | "subscriptionGracePeriod"
          | "subscriptionGroups"
          | "subscriptionStatusUrl"
          | "subscriptionStatusUrlForSandbox"
          | "subscriptionStatusUrlVersion"
          | "subscriptionStatusUrlVersionForSandbox"
        )[];
      },
      params: RequestParams = {},
    ): Promise<AppWithoutIncludesResponse> =>
      this.request<AppWithoutIncludesResponse, ErrorResponse>({
        path: `/v1/betaAppReviewDetails/${id}/app`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  betaAppReviewSubmissions = {
    /**
     * No description
     *
     * @tags BetaAppReviewSubmissions
     * @name BetaAppReviewSubmissionsGetCollection
     * @request GET:/v1/betaAppReviewSubmissions
     * @secure
     */
    getCollection: (
      query: {
        /** filter by attribute 'betaReviewState' */
        "filter[betaReviewState]"?: ("WAITING_FOR_REVIEW" | "IN_REVIEW" | "REJECTED" | "APPROVED")[];
        /** filter by id(s) of related 'build' */
        "filter[build]": string[];
        /** the fields to include for returned resources of type betaAppReviewSubmissions */
        "fields[betaAppReviewSubmissions]"?: ("betaReviewState" | "build" | "submittedDate")[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /** comma-separated list of relationships to include */
        include?: "build"[];
        /** the fields to include for returned resources of type builds */
        "fields[builds]"?: (
          | "app"
          | "appEncryptionDeclaration"
          | "appStoreVersion"
          | "betaAppReviewSubmission"
          | "betaBuildLocalizations"
          | "betaGroups"
          | "buildAudienceType"
          | "buildBetaDetail"
          | "buildBundles"
          | "computedMinMacOsVersion"
          | "diagnosticSignatures"
          | "expirationDate"
          | "expired"
          | "iconAssetToken"
          | "icons"
          | "individualTesters"
          | "lsMinimumSystemVersion"
          | "minOsVersion"
          | "perfPowerMetrics"
          | "preReleaseVersion"
          | "processingState"
          | "uploadedDate"
          | "usesNonExemptEncryption"
          | "version"
        )[];
      },
      params: RequestParams = {},
    ): Promise<BetaAppReviewSubmissionsResponse> =>
      this.request<BetaAppReviewSubmissionsResponse, ErrorResponse>({
        path: `/v1/betaAppReviewSubmissions`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags BetaAppReviewSubmissions
     * @name BetaAppReviewSubmissionsCreateInstance
     * @request POST:/v1/betaAppReviewSubmissions
     * @secure
     */
    createInstance: (
      data: BetaAppReviewSubmissionCreateRequest,
      params: RequestParams = {},
    ): Promise<BetaAppReviewSubmissionResponse> =>
      this.request<BetaAppReviewSubmissionResponse, ErrorResponse>({
        path: `/v1/betaAppReviewSubmissions`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags BetaAppReviewSubmissions
     * @name BetaAppReviewSubmissionsGetInstance
     * @request GET:/v1/betaAppReviewSubmissions/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type betaAppReviewSubmissions */
        "fields[betaAppReviewSubmissions]"?: ("betaReviewState" | "build" | "submittedDate")[];
        /** comma-separated list of relationships to include */
        include?: "build"[];
        /** the fields to include for returned resources of type builds */
        "fields[builds]"?: (
          | "app"
          | "appEncryptionDeclaration"
          | "appStoreVersion"
          | "betaAppReviewSubmission"
          | "betaBuildLocalizations"
          | "betaGroups"
          | "buildAudienceType"
          | "buildBetaDetail"
          | "buildBundles"
          | "computedMinMacOsVersion"
          | "diagnosticSignatures"
          | "expirationDate"
          | "expired"
          | "iconAssetToken"
          | "icons"
          | "individualTesters"
          | "lsMinimumSystemVersion"
          | "minOsVersion"
          | "perfPowerMetrics"
          | "preReleaseVersion"
          | "processingState"
          | "uploadedDate"
          | "usesNonExemptEncryption"
          | "version"
        )[];
      },
      params: RequestParams = {},
    ): Promise<BetaAppReviewSubmissionResponse> =>
      this.request<BetaAppReviewSubmissionResponse, ErrorResponse>({
        path: `/v1/betaAppReviewSubmissions/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags BetaAppReviewSubmissions
     * @name BetaAppReviewSubmissionsBuildGetToOneRelated
     * @request GET:/v1/betaAppReviewSubmissions/{id}/build
     * @secure
     */
    buildGetToOneRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type builds */
        "fields[builds]"?: (
          | "app"
          | "appEncryptionDeclaration"
          | "appStoreVersion"
          | "betaAppReviewSubmission"
          | "betaBuildLocalizations"
          | "betaGroups"
          | "buildAudienceType"
          | "buildBetaDetail"
          | "buildBundles"
          | "computedMinMacOsVersion"
          | "diagnosticSignatures"
          | "expirationDate"
          | "expired"
          | "iconAssetToken"
          | "icons"
          | "individualTesters"
          | "lsMinimumSystemVersion"
          | "minOsVersion"
          | "perfPowerMetrics"
          | "preReleaseVersion"
          | "processingState"
          | "uploadedDate"
          | "usesNonExemptEncryption"
          | "version"
        )[];
      },
      params: RequestParams = {},
    ): Promise<BuildWithoutIncludesResponse> =>
      this.request<BuildWithoutIncludesResponse, ErrorResponse>({
        path: `/v1/betaAppReviewSubmissions/${id}/build`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  betaBuildLocalizations = {
    /**
     * No description
     *
     * @tags BetaBuildLocalizations
     * @name BetaBuildLocalizationsGetCollection
     * @request GET:/v1/betaBuildLocalizations
     * @secure
     */
    getCollection: (
      query?: {
        /** filter by attribute 'locale' */
        "filter[locale]"?: string[];
        /** filter by id(s) of related 'build' */
        "filter[build]"?: string[];
        /** the fields to include for returned resources of type betaBuildLocalizations */
        "fields[betaBuildLocalizations]"?: ("build" | "locale" | "whatsNew")[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /** comma-separated list of relationships to include */
        include?: "build"[];
        /** the fields to include for returned resources of type builds */
        "fields[builds]"?: (
          | "app"
          | "appEncryptionDeclaration"
          | "appStoreVersion"
          | "betaAppReviewSubmission"
          | "betaBuildLocalizations"
          | "betaGroups"
          | "buildAudienceType"
          | "buildBetaDetail"
          | "buildBundles"
          | "computedMinMacOsVersion"
          | "diagnosticSignatures"
          | "expirationDate"
          | "expired"
          | "iconAssetToken"
          | "icons"
          | "individualTesters"
          | "lsMinimumSystemVersion"
          | "minOsVersion"
          | "perfPowerMetrics"
          | "preReleaseVersion"
          | "processingState"
          | "uploadedDate"
          | "usesNonExemptEncryption"
          | "version"
        )[];
      },
      params: RequestParams = {},
    ): Promise<BetaBuildLocalizationsResponse> =>
      this.request<BetaBuildLocalizationsResponse, ErrorResponse>({
        path: `/v1/betaBuildLocalizations`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags BetaBuildLocalizations
     * @name BetaBuildLocalizationsCreateInstance
     * @request POST:/v1/betaBuildLocalizations
     * @secure
     */
    createInstance: (
      data: BetaBuildLocalizationCreateRequest,
      params: RequestParams = {},
    ): Promise<BetaBuildLocalizationResponse> =>
      this.request<BetaBuildLocalizationResponse, ErrorResponse>({
        path: `/v1/betaBuildLocalizations`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags BetaBuildLocalizations
     * @name BetaBuildLocalizationsGetInstance
     * @request GET:/v1/betaBuildLocalizations/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type betaBuildLocalizations */
        "fields[betaBuildLocalizations]"?: ("build" | "locale" | "whatsNew")[];
        /** comma-separated list of relationships to include */
        include?: "build"[];
        /** the fields to include for returned resources of type builds */
        "fields[builds]"?: (
          | "app"
          | "appEncryptionDeclaration"
          | "appStoreVersion"
          | "betaAppReviewSubmission"
          | "betaBuildLocalizations"
          | "betaGroups"
          | "buildAudienceType"
          | "buildBetaDetail"
          | "buildBundles"
          | "computedMinMacOsVersion"
          | "diagnosticSignatures"
          | "expirationDate"
          | "expired"
          | "iconAssetToken"
          | "icons"
          | "individualTesters"
          | "lsMinimumSystemVersion"
          | "minOsVersion"
          | "perfPowerMetrics"
          | "preReleaseVersion"
          | "processingState"
          | "uploadedDate"
          | "usesNonExemptEncryption"
          | "version"
        )[];
      },
      params: RequestParams = {},
    ): Promise<BetaBuildLocalizationResponse> =>
      this.request<BetaBuildLocalizationResponse, ErrorResponse>({
        path: `/v1/betaBuildLocalizations/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags BetaBuildLocalizations
     * @name BetaBuildLocalizationsUpdateInstance
     * @request PATCH:/v1/betaBuildLocalizations/{id}
     * @secure
     */
    updateInstance: (
      id: string,
      data: BetaBuildLocalizationUpdateRequest,
      params: RequestParams = {},
    ): Promise<BetaBuildLocalizationResponse> =>
      this.request<BetaBuildLocalizationResponse, ErrorResponse>({
        path: `/v1/betaBuildLocalizations/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags BetaBuildLocalizations
     * @name BetaBuildLocalizationsDeleteInstance
     * @request DELETE:/v1/betaBuildLocalizations/{id}
     * @secure
     */
    deleteInstance: (id: string, params: RequestParams = {}): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/betaBuildLocalizations/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),

    /**
     * No description
     *
     * @tags BetaBuildLocalizations
     * @name BetaBuildLocalizationsBuildGetToOneRelated
     * @request GET:/v1/betaBuildLocalizations/{id}/build
     * @secure
     */
    buildGetToOneRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type builds */
        "fields[builds]"?: (
          | "app"
          | "appEncryptionDeclaration"
          | "appStoreVersion"
          | "betaAppReviewSubmission"
          | "betaBuildLocalizations"
          | "betaGroups"
          | "buildAudienceType"
          | "buildBetaDetail"
          | "buildBundles"
          | "computedMinMacOsVersion"
          | "diagnosticSignatures"
          | "expirationDate"
          | "expired"
          | "iconAssetToken"
          | "icons"
          | "individualTesters"
          | "lsMinimumSystemVersion"
          | "minOsVersion"
          | "perfPowerMetrics"
          | "preReleaseVersion"
          | "processingState"
          | "uploadedDate"
          | "usesNonExemptEncryption"
          | "version"
        )[];
      },
      params: RequestParams = {},
    ): Promise<BuildWithoutIncludesResponse> =>
      this.request<BuildWithoutIncludesResponse, ErrorResponse>({
        path: `/v1/betaBuildLocalizations/${id}/build`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  betaGroups = {
    /**
     * No description
     *
     * @tags BetaGroups
     * @name BetaGroupsGetCollection
     * @request GET:/v1/betaGroups
     * @secure
     */
    getCollection: (
      query?: {
        /** filter by attribute 'isInternalGroup' */
        "filter[isInternalGroup]"?: string[];
        /** filter by attribute 'name' */
        "filter[name]"?: string[];
        /** filter by attribute 'publicLink' */
        "filter[publicLink]"?: string[];
        /** filter by attribute 'publicLinkEnabled' */
        "filter[publicLinkEnabled]"?: string[];
        /** filter by attribute 'publicLinkLimitEnabled' */
        "filter[publicLinkLimitEnabled]"?: string[];
        /** filter by id(s) of related 'app' */
        "filter[app]"?: string[];
        /** filter by id(s) of related 'builds' */
        "filter[builds]"?: string[];
        /** filter by id(s) */
        "filter[id]"?: string[];
        /** comma-separated list of sort expressions; resources will be sorted as specified */
        sort?: (
          | "createdDate"
          | "-createdDate"
          | "name"
          | "-name"
          | "publicLinkEnabled"
          | "-publicLinkEnabled"
          | "publicLinkLimit"
          | "-publicLinkLimit"
        )[];
        /** the fields to include for returned resources of type betaGroups */
        "fields[betaGroups]"?: (
          | "app"
          | "betaTesters"
          | "builds"
          | "createdDate"
          | "feedbackEnabled"
          | "hasAccessToAllBuilds"
          | "iosBuildsAvailableForAppleSiliconMac"
          | "isInternalGroup"
          | "name"
          | "publicLink"
          | "publicLinkEnabled"
          | "publicLinkId"
          | "publicLinkLimit"
          | "publicLinkLimitEnabled"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /** comma-separated list of relationships to include */
        include?: ("app" | "betaTesters" | "builds")[];
        /** the fields to include for returned resources of type betaTesters */
        "fields[betaTesters]"?: (
          | "apps"
          | "betaGroups"
          | "builds"
          | "email"
          | "firstName"
          | "inviteType"
          | "lastName"
        )[];
        /** the fields to include for returned resources of type apps */
        "fields[apps]"?: (
          | "alternativeDistributionKey"
          | "analyticsReportRequests"
          | "appAvailability"
          | "appClips"
          | "appCustomProductPages"
          | "appEncryptionDeclarations"
          | "appEvents"
          | "appInfos"
          | "appPricePoints"
          | "appPriceSchedule"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersions"
          | "availableInNewTerritories"
          | "availableTerritories"
          | "betaAppLocalizations"
          | "betaAppReviewDetail"
          | "betaGroups"
          | "betaLicenseAgreement"
          | "betaTesters"
          | "builds"
          | "bundleId"
          | "ciProduct"
          | "contentRightsDeclaration"
          | "customerReviews"
          | "endUserLicenseAgreement"
          | "gameCenterDetail"
          | "gameCenterEnabledVersions"
          | "inAppPurchases"
          | "inAppPurchasesV2"
          | "isOrEverWasMadeForKids"
          | "marketplaceSearchDetail"
          | "name"
          | "perfPowerMetrics"
          | "preOrder"
          | "preReleaseVersions"
          | "pricePoints"
          | "prices"
          | "primaryLocale"
          | "promotedPurchases"
          | "reviewSubmissions"
          | "sku"
          | "subscriptionGracePeriod"
          | "subscriptionGroups"
          | "subscriptionStatusUrl"
          | "subscriptionStatusUrlForSandbox"
          | "subscriptionStatusUrlVersion"
          | "subscriptionStatusUrlVersionForSandbox"
        )[];
        /** the fields to include for returned resources of type builds */
        "fields[builds]"?: (
          | "app"
          | "appEncryptionDeclaration"
          | "appStoreVersion"
          | "betaAppReviewSubmission"
          | "betaBuildLocalizations"
          | "betaGroups"
          | "buildAudienceType"
          | "buildBetaDetail"
          | "buildBundles"
          | "computedMinMacOsVersion"
          | "diagnosticSignatures"
          | "expirationDate"
          | "expired"
          | "iconAssetToken"
          | "icons"
          | "individualTesters"
          | "lsMinimumSystemVersion"
          | "minOsVersion"
          | "perfPowerMetrics"
          | "preReleaseVersion"
          | "processingState"
          | "uploadedDate"
          | "usesNonExemptEncryption"
          | "version"
        )[];
        /**
         * maximum number of related betaTesters returned (when they are included)
         * @max 50
         */
        "limit[betaTesters]"?: number;
        /**
         * maximum number of related builds returned (when they are included)
         * @max 1000
         */
        "limit[builds]"?: number;
      },
      params: RequestParams = {},
    ): Promise<BetaGroupsResponse> =>
      this.request<BetaGroupsResponse, ErrorResponse>({
        path: `/v1/betaGroups`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags BetaGroups
     * @name BetaGroupsCreateInstance
     * @request POST:/v1/betaGroups
     * @secure
     */
    createInstance: (data: BetaGroupCreateRequest, params: RequestParams = {}): Promise<BetaGroupResponse> =>
      this.request<BetaGroupResponse, ErrorResponse>({
        path: `/v1/betaGroups`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags BetaGroups
     * @name BetaGroupsGetInstance
     * @request GET:/v1/betaGroups/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type betaGroups */
        "fields[betaGroups]"?: (
          | "app"
          | "betaTesters"
          | "builds"
          | "createdDate"
          | "feedbackEnabled"
          | "hasAccessToAllBuilds"
          | "iosBuildsAvailableForAppleSiliconMac"
          | "isInternalGroup"
          | "name"
          | "publicLink"
          | "publicLinkEnabled"
          | "publicLinkId"
          | "publicLinkLimit"
          | "publicLinkLimitEnabled"
        )[];
        /** comma-separated list of relationships to include */
        include?: ("app" | "betaTesters" | "builds")[];
        /** the fields to include for returned resources of type betaTesters */
        "fields[betaTesters]"?: (
          | "apps"
          | "betaGroups"
          | "builds"
          | "email"
          | "firstName"
          | "inviteType"
          | "lastName"
        )[];
        /** the fields to include for returned resources of type apps */
        "fields[apps]"?: (
          | "alternativeDistributionKey"
          | "analyticsReportRequests"
          | "appAvailability"
          | "appClips"
          | "appCustomProductPages"
          | "appEncryptionDeclarations"
          | "appEvents"
          | "appInfos"
          | "appPricePoints"
          | "appPriceSchedule"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersions"
          | "availableInNewTerritories"
          | "availableTerritories"
          | "betaAppLocalizations"
          | "betaAppReviewDetail"
          | "betaGroups"
          | "betaLicenseAgreement"
          | "betaTesters"
          | "builds"
          | "bundleId"
          | "ciProduct"
          | "contentRightsDeclaration"
          | "customerReviews"
          | "endUserLicenseAgreement"
          | "gameCenterDetail"
          | "gameCenterEnabledVersions"
          | "inAppPurchases"
          | "inAppPurchasesV2"
          | "isOrEverWasMadeForKids"
          | "marketplaceSearchDetail"
          | "name"
          | "perfPowerMetrics"
          | "preOrder"
          | "preReleaseVersions"
          | "pricePoints"
          | "prices"
          | "primaryLocale"
          | "promotedPurchases"
          | "reviewSubmissions"
          | "sku"
          | "subscriptionGracePeriod"
          | "subscriptionGroups"
          | "subscriptionStatusUrl"
          | "subscriptionStatusUrlForSandbox"
          | "subscriptionStatusUrlVersion"
          | "subscriptionStatusUrlVersionForSandbox"
        )[];
        /** the fields to include for returned resources of type builds */
        "fields[builds]"?: (
          | "app"
          | "appEncryptionDeclaration"
          | "appStoreVersion"
          | "betaAppReviewSubmission"
          | "betaBuildLocalizations"
          | "betaGroups"
          | "buildAudienceType"
          | "buildBetaDetail"
          | "buildBundles"
          | "computedMinMacOsVersion"
          | "diagnosticSignatures"
          | "expirationDate"
          | "expired"
          | "iconAssetToken"
          | "icons"
          | "individualTesters"
          | "lsMinimumSystemVersion"
          | "minOsVersion"
          | "perfPowerMetrics"
          | "preReleaseVersion"
          | "processingState"
          | "uploadedDate"
          | "usesNonExemptEncryption"
          | "version"
        )[];
        /**
         * maximum number of related betaTesters returned (when they are included)
         * @max 50
         */
        "limit[betaTesters]"?: number;
        /**
         * maximum number of related builds returned (when they are included)
         * @max 1000
         */
        "limit[builds]"?: number;
      },
      params: RequestParams = {},
    ): Promise<BetaGroupResponse> =>
      this.request<BetaGroupResponse, ErrorResponse>({
        path: `/v1/betaGroups/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags BetaGroups
     * @name BetaGroupsUpdateInstance
     * @request PATCH:/v1/betaGroups/{id}
     * @secure
     */
    updateInstance: (
      id: string,
      data: BetaGroupUpdateRequest,
      params: RequestParams = {},
    ): Promise<BetaGroupResponse> =>
      this.request<BetaGroupResponse, ErrorResponse>({
        path: `/v1/betaGroups/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags BetaGroups
     * @name BetaGroupsDeleteInstance
     * @request DELETE:/v1/betaGroups/{id}
     * @secure
     */
    deleteInstance: (id: string, params: RequestParams = {}): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/betaGroups/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),

    /**
     * No description
     *
     * @tags BetaGroups
     * @name BetaGroupsAppGetToOneRelated
     * @request GET:/v1/betaGroups/{id}/app
     * @secure
     */
    appGetToOneRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type apps */
        "fields[apps]"?: (
          | "alternativeDistributionKey"
          | "analyticsReportRequests"
          | "appAvailability"
          | "appClips"
          | "appCustomProductPages"
          | "appEncryptionDeclarations"
          | "appEvents"
          | "appInfos"
          | "appPricePoints"
          | "appPriceSchedule"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersions"
          | "availableInNewTerritories"
          | "availableTerritories"
          | "betaAppLocalizations"
          | "betaAppReviewDetail"
          | "betaGroups"
          | "betaLicenseAgreement"
          | "betaTesters"
          | "builds"
          | "bundleId"
          | "ciProduct"
          | "contentRightsDeclaration"
          | "customerReviews"
          | "endUserLicenseAgreement"
          | "gameCenterDetail"
          | "gameCenterEnabledVersions"
          | "inAppPurchases"
          | "inAppPurchasesV2"
          | "isOrEverWasMadeForKids"
          | "marketplaceSearchDetail"
          | "name"
          | "perfPowerMetrics"
          | "preOrder"
          | "preReleaseVersions"
          | "pricePoints"
          | "prices"
          | "primaryLocale"
          | "promotedPurchases"
          | "reviewSubmissions"
          | "sku"
          | "subscriptionGracePeriod"
          | "subscriptionGroups"
          | "subscriptionStatusUrl"
          | "subscriptionStatusUrlForSandbox"
          | "subscriptionStatusUrlVersion"
          | "subscriptionStatusUrlVersionForSandbox"
        )[];
      },
      params: RequestParams = {},
    ): Promise<AppWithoutIncludesResponse> =>
      this.request<AppWithoutIncludesResponse, ErrorResponse>({
        path: `/v1/betaGroups/${id}/app`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags BetaGroups
     * @name BetaGroupsBetaTestersGetToManyRelationship
     * @request GET:/v1/betaGroups/{id}/relationships/betaTesters
     * @secure
     */
    betaTestersGetToManyRelationship: (
      id: string,
      query?: {
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
      },
      params: RequestParams = {},
    ): Promise<BetaGroupBetaTestersLinkagesResponse> =>
      this.request<BetaGroupBetaTestersLinkagesResponse, ErrorResponse>({
        path: `/v1/betaGroups/${id}/relationships/betaTesters`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags BetaGroups
     * @name BetaGroupsBetaTestersCreateToManyRelationship
     * @request POST:/v1/betaGroups/{id}/relationships/betaTesters
     * @secure
     */
    betaTestersCreateToManyRelationship: (
      id: string,
      data: BetaGroupBetaTestersLinkagesRequest,
      params: RequestParams = {},
    ): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/betaGroups/${id}/relationships/betaTesters`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * No description
     *
     * @tags BetaGroups
     * @name BetaGroupsBetaTestersDeleteToManyRelationship
     * @request DELETE:/v1/betaGroups/{id}/relationships/betaTesters
     * @secure
     */
    betaTestersDeleteToManyRelationship: (
      id: string,
      data: BetaGroupBetaTestersLinkagesRequest,
      params: RequestParams = {},
    ): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/betaGroups/${id}/relationships/betaTesters`,
        method: "DELETE",
        body: data,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * No description
     *
     * @tags BetaGroups
     * @name BetaGroupsBetaTestersGetToManyRelated
     * @request GET:/v1/betaGroups/{id}/betaTesters
     * @secure
     */
    betaTestersGetToManyRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type betaTesters */
        "fields[betaTesters]"?: (
          | "apps"
          | "betaGroups"
          | "builds"
          | "email"
          | "firstName"
          | "inviteType"
          | "lastName"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
      },
      params: RequestParams = {},
    ): Promise<BetaTestersWithoutIncludesResponse> =>
      this.request<BetaTestersWithoutIncludesResponse, ErrorResponse>({
        path: `/v1/betaGroups/${id}/betaTesters`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags BetaGroups
     * @name BetaGroupsBuildsGetToManyRelationship
     * @request GET:/v1/betaGroups/{id}/relationships/builds
     * @secure
     */
    buildsGetToManyRelationship: (
      id: string,
      query?: {
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
      },
      params: RequestParams = {},
    ): Promise<BetaGroupBuildsLinkagesResponse> =>
      this.request<BetaGroupBuildsLinkagesResponse, ErrorResponse>({
        path: `/v1/betaGroups/${id}/relationships/builds`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags BetaGroups
     * @name BetaGroupsBuildsCreateToManyRelationship
     * @request POST:/v1/betaGroups/{id}/relationships/builds
     * @secure
     */
    buildsCreateToManyRelationship: (
      id: string,
      data: BetaGroupBuildsLinkagesRequest,
      params: RequestParams = {},
    ): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/betaGroups/${id}/relationships/builds`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * No description
     *
     * @tags BetaGroups
     * @name BetaGroupsBuildsDeleteToManyRelationship
     * @request DELETE:/v1/betaGroups/{id}/relationships/builds
     * @secure
     */
    buildsDeleteToManyRelationship: (
      id: string,
      data: BetaGroupBuildsLinkagesRequest,
      params: RequestParams = {},
    ): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/betaGroups/${id}/relationships/builds`,
        method: "DELETE",
        body: data,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * No description
     *
     * @tags BetaGroups
     * @name BetaGroupsBuildsGetToManyRelated
     * @request GET:/v1/betaGroups/{id}/builds
     * @secure
     */
    buildsGetToManyRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type builds */
        "fields[builds]"?: (
          | "app"
          | "appEncryptionDeclaration"
          | "appStoreVersion"
          | "betaAppReviewSubmission"
          | "betaBuildLocalizations"
          | "betaGroups"
          | "buildAudienceType"
          | "buildBetaDetail"
          | "buildBundles"
          | "computedMinMacOsVersion"
          | "diagnosticSignatures"
          | "expirationDate"
          | "expired"
          | "iconAssetToken"
          | "icons"
          | "individualTesters"
          | "lsMinimumSystemVersion"
          | "minOsVersion"
          | "perfPowerMetrics"
          | "preReleaseVersion"
          | "processingState"
          | "uploadedDate"
          | "usesNonExemptEncryption"
          | "version"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
      },
      params: RequestParams = {},
    ): Promise<BuildsWithoutIncludesResponse> =>
      this.request<BuildsWithoutIncludesResponse, ErrorResponse>({
        path: `/v1/betaGroups/${id}/builds`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags BetaGroups, Metrics
     * @name BetaGroupsBetaTesterUsagesGetMetrics
     * @request GET:/v1/betaGroups/{id}/metrics/betaTesterUsages
     * @secure
     */
    betaTesterUsagesGetMetrics: (
      id: string,
      query?: {
        /**
         * maximum number of groups to return per page
         * @max 200
         */
        limit?: number;
        /** the dimension by which to group the results */
        groupBy?: "betaTesters"[];
        /** filter by 'betaTesters' relationship dimension */
        "filter[betaTesters]"?: string;
        /** the duration of the reporting period */
        period?: "P7D" | "P30D" | "P90D" | "P365D";
      },
      params: RequestParams = {},
    ): Promise<AppsBetaTesterUsagesV1MetricResponse> =>
      this.request<AppsBetaTesterUsagesV1MetricResponse, ErrorResponse>({
        path: `/v1/betaGroups/${id}/metrics/betaTesterUsages`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  betaLicenseAgreements = {
    /**
     * No description
     *
     * @tags BetaLicenseAgreements
     * @name BetaLicenseAgreementsGetCollection
     * @request GET:/v1/betaLicenseAgreements
     * @secure
     */
    getCollection: (
      query?: {
        /** filter by id(s) of related 'app' */
        "filter[app]"?: string[];
        /** the fields to include for returned resources of type betaLicenseAgreements */
        "fields[betaLicenseAgreements]"?: ("agreementText" | "app")[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /** comma-separated list of relationships to include */
        include?: "app"[];
        /** the fields to include for returned resources of type apps */
        "fields[apps]"?: (
          | "alternativeDistributionKey"
          | "analyticsReportRequests"
          | "appAvailability"
          | "appClips"
          | "appCustomProductPages"
          | "appEncryptionDeclarations"
          | "appEvents"
          | "appInfos"
          | "appPricePoints"
          | "appPriceSchedule"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersions"
          | "availableInNewTerritories"
          | "availableTerritories"
          | "betaAppLocalizations"
          | "betaAppReviewDetail"
          | "betaGroups"
          | "betaLicenseAgreement"
          | "betaTesters"
          | "builds"
          | "bundleId"
          | "ciProduct"
          | "contentRightsDeclaration"
          | "customerReviews"
          | "endUserLicenseAgreement"
          | "gameCenterDetail"
          | "gameCenterEnabledVersions"
          | "inAppPurchases"
          | "inAppPurchasesV2"
          | "isOrEverWasMadeForKids"
          | "marketplaceSearchDetail"
          | "name"
          | "perfPowerMetrics"
          | "preOrder"
          | "preReleaseVersions"
          | "pricePoints"
          | "prices"
          | "primaryLocale"
          | "promotedPurchases"
          | "reviewSubmissions"
          | "sku"
          | "subscriptionGracePeriod"
          | "subscriptionGroups"
          | "subscriptionStatusUrl"
          | "subscriptionStatusUrlForSandbox"
          | "subscriptionStatusUrlVersion"
          | "subscriptionStatusUrlVersionForSandbox"
        )[];
      },
      params: RequestParams = {},
    ): Promise<BetaLicenseAgreementsResponse> =>
      this.request<BetaLicenseAgreementsResponse, ErrorResponse>({
        path: `/v1/betaLicenseAgreements`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags BetaLicenseAgreements
     * @name BetaLicenseAgreementsGetInstance
     * @request GET:/v1/betaLicenseAgreements/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type betaLicenseAgreements */
        "fields[betaLicenseAgreements]"?: ("agreementText" | "app")[];
        /** comma-separated list of relationships to include */
        include?: "app"[];
        /** the fields to include for returned resources of type apps */
        "fields[apps]"?: (
          | "alternativeDistributionKey"
          | "analyticsReportRequests"
          | "appAvailability"
          | "appClips"
          | "appCustomProductPages"
          | "appEncryptionDeclarations"
          | "appEvents"
          | "appInfos"
          | "appPricePoints"
          | "appPriceSchedule"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersions"
          | "availableInNewTerritories"
          | "availableTerritories"
          | "betaAppLocalizations"
          | "betaAppReviewDetail"
          | "betaGroups"
          | "betaLicenseAgreement"
          | "betaTesters"
          | "builds"
          | "bundleId"
          | "ciProduct"
          | "contentRightsDeclaration"
          | "customerReviews"
          | "endUserLicenseAgreement"
          | "gameCenterDetail"
          | "gameCenterEnabledVersions"
          | "inAppPurchases"
          | "inAppPurchasesV2"
          | "isOrEverWasMadeForKids"
          | "marketplaceSearchDetail"
          | "name"
          | "perfPowerMetrics"
          | "preOrder"
          | "preReleaseVersions"
          | "pricePoints"
          | "prices"
          | "primaryLocale"
          | "promotedPurchases"
          | "reviewSubmissions"
          | "sku"
          | "subscriptionGracePeriod"
          | "subscriptionGroups"
          | "subscriptionStatusUrl"
          | "subscriptionStatusUrlForSandbox"
          | "subscriptionStatusUrlVersion"
          | "subscriptionStatusUrlVersionForSandbox"
        )[];
      },
      params: RequestParams = {},
    ): Promise<BetaLicenseAgreementResponse> =>
      this.request<BetaLicenseAgreementResponse, ErrorResponse>({
        path: `/v1/betaLicenseAgreements/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags BetaLicenseAgreements
     * @name BetaLicenseAgreementsUpdateInstance
     * @request PATCH:/v1/betaLicenseAgreements/{id}
     * @secure
     */
    updateInstance: (
      id: string,
      data: BetaLicenseAgreementUpdateRequest,
      params: RequestParams = {},
    ): Promise<BetaLicenseAgreementResponse> =>
      this.request<BetaLicenseAgreementResponse, ErrorResponse>({
        path: `/v1/betaLicenseAgreements/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags BetaLicenseAgreements
     * @name BetaLicenseAgreementsAppGetToOneRelated
     * @request GET:/v1/betaLicenseAgreements/{id}/app
     * @secure
     */
    appGetToOneRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type apps */
        "fields[apps]"?: (
          | "alternativeDistributionKey"
          | "analyticsReportRequests"
          | "appAvailability"
          | "appClips"
          | "appCustomProductPages"
          | "appEncryptionDeclarations"
          | "appEvents"
          | "appInfos"
          | "appPricePoints"
          | "appPriceSchedule"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersions"
          | "availableInNewTerritories"
          | "availableTerritories"
          | "betaAppLocalizations"
          | "betaAppReviewDetail"
          | "betaGroups"
          | "betaLicenseAgreement"
          | "betaTesters"
          | "builds"
          | "bundleId"
          | "ciProduct"
          | "contentRightsDeclaration"
          | "customerReviews"
          | "endUserLicenseAgreement"
          | "gameCenterDetail"
          | "gameCenterEnabledVersions"
          | "inAppPurchases"
          | "inAppPurchasesV2"
          | "isOrEverWasMadeForKids"
          | "marketplaceSearchDetail"
          | "name"
          | "perfPowerMetrics"
          | "preOrder"
          | "preReleaseVersions"
          | "pricePoints"
          | "prices"
          | "primaryLocale"
          | "promotedPurchases"
          | "reviewSubmissions"
          | "sku"
          | "subscriptionGracePeriod"
          | "subscriptionGroups"
          | "subscriptionStatusUrl"
          | "subscriptionStatusUrlForSandbox"
          | "subscriptionStatusUrlVersion"
          | "subscriptionStatusUrlVersionForSandbox"
        )[];
      },
      params: RequestParams = {},
    ): Promise<AppWithoutIncludesResponse> =>
      this.request<AppWithoutIncludesResponse, ErrorResponse>({
        path: `/v1/betaLicenseAgreements/${id}/app`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  betaTesterInvitations = {
    /**
     * No description
     *
     * @tags BetaTesterInvitations
     * @name BetaTesterInvitationsCreateInstance
     * @request POST:/v1/betaTesterInvitations
     * @secure
     */
    createInstance: (
      data: BetaTesterInvitationCreateRequest,
      params: RequestParams = {},
    ): Promise<BetaTesterInvitationResponse> =>
      this.request<BetaTesterInvitationResponse, ErrorResponse>({
        path: `/v1/betaTesterInvitations`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),
  };
  betaTesters = {
    /**
     * No description
     *
     * @tags BetaTesters
     * @name BetaTestersGetCollection
     * @request GET:/v1/betaTesters
     * @secure
     */
    getCollection: (
      query?: {
        /** filter by attribute 'email' */
        "filter[email]"?: string[];
        /** filter by attribute 'firstName' */
        "filter[firstName]"?: string[];
        /** filter by attribute 'inviteType' */
        "filter[inviteType]"?: ("EMAIL" | "PUBLIC_LINK")[];
        /** filter by attribute 'lastName' */
        "filter[lastName]"?: string[];
        /** filter by id(s) of related 'apps' */
        "filter[apps]"?: string[];
        /** filter by id(s) of related 'betaGroups' */
        "filter[betaGroups]"?: string[];
        /** filter by id(s) of related 'builds' */
        "filter[builds]"?: string[];
        /** filter by id(s) */
        "filter[id]"?: string[];
        /** comma-separated list of sort expressions; resources will be sorted as specified */
        sort?: (
          | "email"
          | "-email"
          | "firstName"
          | "-firstName"
          | "inviteType"
          | "-inviteType"
          | "lastName"
          | "-lastName"
        )[];
        /** the fields to include for returned resources of type betaTesters */
        "fields[betaTesters]"?: (
          | "apps"
          | "betaGroups"
          | "builds"
          | "email"
          | "firstName"
          | "inviteType"
          | "lastName"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /** comma-separated list of relationships to include */
        include?: ("apps" | "betaGroups" | "builds")[];
        /** the fields to include for returned resources of type apps */
        "fields[apps]"?: (
          | "alternativeDistributionKey"
          | "analyticsReportRequests"
          | "appAvailability"
          | "appClips"
          | "appCustomProductPages"
          | "appEncryptionDeclarations"
          | "appEvents"
          | "appInfos"
          | "appPricePoints"
          | "appPriceSchedule"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersions"
          | "availableInNewTerritories"
          | "availableTerritories"
          | "betaAppLocalizations"
          | "betaAppReviewDetail"
          | "betaGroups"
          | "betaLicenseAgreement"
          | "betaTesters"
          | "builds"
          | "bundleId"
          | "ciProduct"
          | "contentRightsDeclaration"
          | "customerReviews"
          | "endUserLicenseAgreement"
          | "gameCenterDetail"
          | "gameCenterEnabledVersions"
          | "inAppPurchases"
          | "inAppPurchasesV2"
          | "isOrEverWasMadeForKids"
          | "marketplaceSearchDetail"
          | "name"
          | "perfPowerMetrics"
          | "preOrder"
          | "preReleaseVersions"
          | "pricePoints"
          | "prices"
          | "primaryLocale"
          | "promotedPurchases"
          | "reviewSubmissions"
          | "sku"
          | "subscriptionGracePeriod"
          | "subscriptionGroups"
          | "subscriptionStatusUrl"
          | "subscriptionStatusUrlForSandbox"
          | "subscriptionStatusUrlVersion"
          | "subscriptionStatusUrlVersionForSandbox"
        )[];
        /** the fields to include for returned resources of type builds */
        "fields[builds]"?: (
          | "app"
          | "appEncryptionDeclaration"
          | "appStoreVersion"
          | "betaAppReviewSubmission"
          | "betaBuildLocalizations"
          | "betaGroups"
          | "buildAudienceType"
          | "buildBetaDetail"
          | "buildBundles"
          | "computedMinMacOsVersion"
          | "diagnosticSignatures"
          | "expirationDate"
          | "expired"
          | "iconAssetToken"
          | "icons"
          | "individualTesters"
          | "lsMinimumSystemVersion"
          | "minOsVersion"
          | "perfPowerMetrics"
          | "preReleaseVersion"
          | "processingState"
          | "uploadedDate"
          | "usesNonExemptEncryption"
          | "version"
        )[];
        /** the fields to include for returned resources of type betaGroups */
        "fields[betaGroups]"?: (
          | "app"
          | "betaTesters"
          | "builds"
          | "createdDate"
          | "feedbackEnabled"
          | "hasAccessToAllBuilds"
          | "iosBuildsAvailableForAppleSiliconMac"
          | "isInternalGroup"
          | "name"
          | "publicLink"
          | "publicLinkEnabled"
          | "publicLinkId"
          | "publicLinkLimit"
          | "publicLinkLimitEnabled"
        )[];
        /**
         * maximum number of related apps returned (when they are included)
         * @max 50
         */
        "limit[apps]"?: number;
        /**
         * maximum number of related betaGroups returned (when they are included)
         * @max 50
         */
        "limit[betaGroups]"?: number;
        /**
         * maximum number of related builds returned (when they are included)
         * @max 50
         */
        "limit[builds]"?: number;
      },
      params: RequestParams = {},
    ): Promise<BetaTestersResponse> =>
      this.request<BetaTestersResponse, ErrorResponse>({
        path: `/v1/betaTesters`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags BetaTesters
     * @name BetaTestersCreateInstance
     * @request POST:/v1/betaTesters
     * @secure
     */
    createInstance: (data: BetaTesterCreateRequest, params: RequestParams = {}): Promise<BetaTesterResponse> =>
      this.request<BetaTesterResponse, ErrorResponse>({
        path: `/v1/betaTesters`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags BetaTesters
     * @name BetaTestersGetInstance
     * @request GET:/v1/betaTesters/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type betaTesters */
        "fields[betaTesters]"?: (
          | "apps"
          | "betaGroups"
          | "builds"
          | "email"
          | "firstName"
          | "inviteType"
          | "lastName"
        )[];
        /** comma-separated list of relationships to include */
        include?: ("apps" | "betaGroups" | "builds")[];
        /** the fields to include for returned resources of type apps */
        "fields[apps]"?: (
          | "alternativeDistributionKey"
          | "analyticsReportRequests"
          | "appAvailability"
          | "appClips"
          | "appCustomProductPages"
          | "appEncryptionDeclarations"
          | "appEvents"
          | "appInfos"
          | "appPricePoints"
          | "appPriceSchedule"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersions"
          | "availableInNewTerritories"
          | "availableTerritories"
          | "betaAppLocalizations"
          | "betaAppReviewDetail"
          | "betaGroups"
          | "betaLicenseAgreement"
          | "betaTesters"
          | "builds"
          | "bundleId"
          | "ciProduct"
          | "contentRightsDeclaration"
          | "customerReviews"
          | "endUserLicenseAgreement"
          | "gameCenterDetail"
          | "gameCenterEnabledVersions"
          | "inAppPurchases"
          | "inAppPurchasesV2"
          | "isOrEverWasMadeForKids"
          | "marketplaceSearchDetail"
          | "name"
          | "perfPowerMetrics"
          | "preOrder"
          | "preReleaseVersions"
          | "pricePoints"
          | "prices"
          | "primaryLocale"
          | "promotedPurchases"
          | "reviewSubmissions"
          | "sku"
          | "subscriptionGracePeriod"
          | "subscriptionGroups"
          | "subscriptionStatusUrl"
          | "subscriptionStatusUrlForSandbox"
          | "subscriptionStatusUrlVersion"
          | "subscriptionStatusUrlVersionForSandbox"
        )[];
        /** the fields to include for returned resources of type builds */
        "fields[builds]"?: (
          | "app"
          | "appEncryptionDeclaration"
          | "appStoreVersion"
          | "betaAppReviewSubmission"
          | "betaBuildLocalizations"
          | "betaGroups"
          | "buildAudienceType"
          | "buildBetaDetail"
          | "buildBundles"
          | "computedMinMacOsVersion"
          | "diagnosticSignatures"
          | "expirationDate"
          | "expired"
          | "iconAssetToken"
          | "icons"
          | "individualTesters"
          | "lsMinimumSystemVersion"
          | "minOsVersion"
          | "perfPowerMetrics"
          | "preReleaseVersion"
          | "processingState"
          | "uploadedDate"
          | "usesNonExemptEncryption"
          | "version"
        )[];
        /** the fields to include for returned resources of type betaGroups */
        "fields[betaGroups]"?: (
          | "app"
          | "betaTesters"
          | "builds"
          | "createdDate"
          | "feedbackEnabled"
          | "hasAccessToAllBuilds"
          | "iosBuildsAvailableForAppleSiliconMac"
          | "isInternalGroup"
          | "name"
          | "publicLink"
          | "publicLinkEnabled"
          | "publicLinkId"
          | "publicLinkLimit"
          | "publicLinkLimitEnabled"
        )[];
        /**
         * maximum number of related apps returned (when they are included)
         * @max 50
         */
        "limit[apps]"?: number;
        /**
         * maximum number of related betaGroups returned (when they are included)
         * @max 50
         */
        "limit[betaGroups]"?: number;
        /**
         * maximum number of related builds returned (when they are included)
         * @max 50
         */
        "limit[builds]"?: number;
      },
      params: RequestParams = {},
    ): Promise<BetaTesterResponse> =>
      this.request<BetaTesterResponse, ErrorResponse>({
        path: `/v1/betaTesters/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags BetaTesters
     * @name BetaTestersDeleteInstance
     * @request DELETE:/v1/betaTesters/{id}
     * @secure
     */
    deleteInstance: (id: string, params: RequestParams = {}): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/betaTesters/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),

    /**
     * No description
     *
     * @tags BetaTesters
     * @name BetaTestersAppsGetToManyRelationship
     * @request GET:/v1/betaTesters/{id}/relationships/apps
     * @secure
     */
    appsGetToManyRelationship: (
      id: string,
      query?: {
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
      },
      params: RequestParams = {},
    ): Promise<BetaTesterAppsLinkagesResponse> =>
      this.request<BetaTesterAppsLinkagesResponse, ErrorResponse>({
        path: `/v1/betaTesters/${id}/relationships/apps`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags BetaTesters
     * @name BetaTestersAppsDeleteToManyRelationship
     * @request DELETE:/v1/betaTesters/{id}/relationships/apps
     * @secure
     */
    appsDeleteToManyRelationship: (
      id: string,
      data: BetaTesterAppsLinkagesRequest,
      params: RequestParams = {},
    ): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/betaTesters/${id}/relationships/apps`,
        method: "DELETE",
        body: data,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * No description
     *
     * @tags BetaTesters
     * @name BetaTestersAppsGetToManyRelated
     * @request GET:/v1/betaTesters/{id}/apps
     * @secure
     */
    appsGetToManyRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type apps */
        "fields[apps]"?: (
          | "alternativeDistributionKey"
          | "analyticsReportRequests"
          | "appAvailability"
          | "appClips"
          | "appCustomProductPages"
          | "appEncryptionDeclarations"
          | "appEvents"
          | "appInfos"
          | "appPricePoints"
          | "appPriceSchedule"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersions"
          | "availableInNewTerritories"
          | "availableTerritories"
          | "betaAppLocalizations"
          | "betaAppReviewDetail"
          | "betaGroups"
          | "betaLicenseAgreement"
          | "betaTesters"
          | "builds"
          | "bundleId"
          | "ciProduct"
          | "contentRightsDeclaration"
          | "customerReviews"
          | "endUserLicenseAgreement"
          | "gameCenterDetail"
          | "gameCenterEnabledVersions"
          | "inAppPurchases"
          | "inAppPurchasesV2"
          | "isOrEverWasMadeForKids"
          | "marketplaceSearchDetail"
          | "name"
          | "perfPowerMetrics"
          | "preOrder"
          | "preReleaseVersions"
          | "pricePoints"
          | "prices"
          | "primaryLocale"
          | "promotedPurchases"
          | "reviewSubmissions"
          | "sku"
          | "subscriptionGracePeriod"
          | "subscriptionGroups"
          | "subscriptionStatusUrl"
          | "subscriptionStatusUrlForSandbox"
          | "subscriptionStatusUrlVersion"
          | "subscriptionStatusUrlVersionForSandbox"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
      },
      params: RequestParams = {},
    ): Promise<AppsWithoutIncludesResponse> =>
      this.request<AppsWithoutIncludesResponse, ErrorResponse>({
        path: `/v1/betaTesters/${id}/apps`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags BetaTesters
     * @name BetaTestersBetaGroupsGetToManyRelationship
     * @request GET:/v1/betaTesters/{id}/relationships/betaGroups
     * @secure
     */
    betaGroupsGetToManyRelationship: (
      id: string,
      query?: {
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
      },
      params: RequestParams = {},
    ): Promise<BetaTesterBetaGroupsLinkagesResponse> =>
      this.request<BetaTesterBetaGroupsLinkagesResponse, ErrorResponse>({
        path: `/v1/betaTesters/${id}/relationships/betaGroups`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags BetaTesters
     * @name BetaTestersBetaGroupsCreateToManyRelationship
     * @request POST:/v1/betaTesters/{id}/relationships/betaGroups
     * @secure
     */
    betaGroupsCreateToManyRelationship: (
      id: string,
      data: BetaTesterBetaGroupsLinkagesRequest,
      params: RequestParams = {},
    ): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/betaTesters/${id}/relationships/betaGroups`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * No description
     *
     * @tags BetaTesters
     * @name BetaTestersBetaGroupsDeleteToManyRelationship
     * @request DELETE:/v1/betaTesters/{id}/relationships/betaGroups
     * @secure
     */
    betaGroupsDeleteToManyRelationship: (
      id: string,
      data: BetaTesterBetaGroupsLinkagesRequest,
      params: RequestParams = {},
    ): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/betaTesters/${id}/relationships/betaGroups`,
        method: "DELETE",
        body: data,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * No description
     *
     * @tags BetaTesters
     * @name BetaTestersBetaGroupsGetToManyRelated
     * @request GET:/v1/betaTesters/{id}/betaGroups
     * @secure
     */
    betaGroupsGetToManyRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type betaGroups */
        "fields[betaGroups]"?: (
          | "app"
          | "betaTesters"
          | "builds"
          | "createdDate"
          | "feedbackEnabled"
          | "hasAccessToAllBuilds"
          | "iosBuildsAvailableForAppleSiliconMac"
          | "isInternalGroup"
          | "name"
          | "publicLink"
          | "publicLinkEnabled"
          | "publicLinkId"
          | "publicLinkLimit"
          | "publicLinkLimitEnabled"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
      },
      params: RequestParams = {},
    ): Promise<BetaGroupsWithoutIncludesResponse> =>
      this.request<BetaGroupsWithoutIncludesResponse, ErrorResponse>({
        path: `/v1/betaTesters/${id}/betaGroups`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags BetaTesters
     * @name BetaTestersBuildsGetToManyRelationship
     * @request GET:/v1/betaTesters/{id}/relationships/builds
     * @secure
     */
    buildsGetToManyRelationship: (
      id: string,
      query?: {
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
      },
      params: RequestParams = {},
    ): Promise<BetaTesterBuildsLinkagesResponse> =>
      this.request<BetaTesterBuildsLinkagesResponse, ErrorResponse>({
        path: `/v1/betaTesters/${id}/relationships/builds`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags BetaTesters
     * @name BetaTestersBuildsCreateToManyRelationship
     * @request POST:/v1/betaTesters/{id}/relationships/builds
     * @secure
     */
    buildsCreateToManyRelationship: (
      id: string,
      data: BetaTesterBuildsLinkagesRequest,
      params: RequestParams = {},
    ): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/betaTesters/${id}/relationships/builds`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * No description
     *
     * @tags BetaTesters
     * @name BetaTestersBuildsDeleteToManyRelationship
     * @request DELETE:/v1/betaTesters/{id}/relationships/builds
     * @secure
     */
    buildsDeleteToManyRelationship: (
      id: string,
      data: BetaTesterBuildsLinkagesRequest,
      params: RequestParams = {},
    ): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/betaTesters/${id}/relationships/builds`,
        method: "DELETE",
        body: data,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * No description
     *
     * @tags BetaTesters
     * @name BetaTestersBuildsGetToManyRelated
     * @request GET:/v1/betaTesters/{id}/builds
     * @secure
     */
    buildsGetToManyRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type builds */
        "fields[builds]"?: (
          | "app"
          | "appEncryptionDeclaration"
          | "appStoreVersion"
          | "betaAppReviewSubmission"
          | "betaBuildLocalizations"
          | "betaGroups"
          | "buildAudienceType"
          | "buildBetaDetail"
          | "buildBundles"
          | "computedMinMacOsVersion"
          | "diagnosticSignatures"
          | "expirationDate"
          | "expired"
          | "iconAssetToken"
          | "icons"
          | "individualTesters"
          | "lsMinimumSystemVersion"
          | "minOsVersion"
          | "perfPowerMetrics"
          | "preReleaseVersion"
          | "processingState"
          | "uploadedDate"
          | "usesNonExemptEncryption"
          | "version"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
      },
      params: RequestParams = {},
    ): Promise<BuildsWithoutIncludesResponse> =>
      this.request<BuildsWithoutIncludesResponse, ErrorResponse>({
        path: `/v1/betaTesters/${id}/builds`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags BetaTesters, Metrics
     * @name BetaTestersBetaTesterUsagesGetMetrics
     * @request GET:/v1/betaTesters/{id}/metrics/betaTesterUsages
     * @secure
     */
    betaTesterUsagesGetMetrics: (
      id: string,
      query: {
        /**
         * maximum number of groups to return per page
         * @max 200
         */
        limit?: number;
        /** filter by 'apps' relationship dimension */
        "filter[apps]": string;
        /** the duration of the reporting period */
        period?: "P7D" | "P30D" | "P90D" | "P365D";
      },
      params: RequestParams = {},
    ): Promise<BetaTesterUsagesV1MetricResponse> =>
      this.request<BetaTesterUsagesV1MetricResponse, ErrorResponse>({
        path: `/v1/betaTesters/${id}/metrics/betaTesterUsages`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  buildBetaDetails = {
    /**
     * No description
     *
     * @tags BuildBetaDetails
     * @name BuildBetaDetailsGetCollection
     * @request GET:/v1/buildBetaDetails
     * @secure
     */
    getCollection: (
      query?: {
        /** filter by id(s) of related 'build' */
        "filter[build]"?: string[];
        /** filter by id(s) */
        "filter[id]"?: string[];
        /** the fields to include for returned resources of type buildBetaDetails */
        "fields[buildBetaDetails]"?: ("autoNotifyEnabled" | "build" | "externalBuildState" | "internalBuildState")[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /** comma-separated list of relationships to include */
        include?: "build"[];
        /** the fields to include for returned resources of type builds */
        "fields[builds]"?: (
          | "app"
          | "appEncryptionDeclaration"
          | "appStoreVersion"
          | "betaAppReviewSubmission"
          | "betaBuildLocalizations"
          | "betaGroups"
          | "buildAudienceType"
          | "buildBetaDetail"
          | "buildBundles"
          | "computedMinMacOsVersion"
          | "diagnosticSignatures"
          | "expirationDate"
          | "expired"
          | "iconAssetToken"
          | "icons"
          | "individualTesters"
          | "lsMinimumSystemVersion"
          | "minOsVersion"
          | "perfPowerMetrics"
          | "preReleaseVersion"
          | "processingState"
          | "uploadedDate"
          | "usesNonExemptEncryption"
          | "version"
        )[];
      },
      params: RequestParams = {},
    ): Promise<BuildBetaDetailsResponse> =>
      this.request<BuildBetaDetailsResponse, ErrorResponse>({
        path: `/v1/buildBetaDetails`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags BuildBetaDetails
     * @name BuildBetaDetailsGetInstance
     * @request GET:/v1/buildBetaDetails/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type buildBetaDetails */
        "fields[buildBetaDetails]"?: ("autoNotifyEnabled" | "build" | "externalBuildState" | "internalBuildState")[];
        /** comma-separated list of relationships to include */
        include?: "build"[];
        /** the fields to include for returned resources of type builds */
        "fields[builds]"?: (
          | "app"
          | "appEncryptionDeclaration"
          | "appStoreVersion"
          | "betaAppReviewSubmission"
          | "betaBuildLocalizations"
          | "betaGroups"
          | "buildAudienceType"
          | "buildBetaDetail"
          | "buildBundles"
          | "computedMinMacOsVersion"
          | "diagnosticSignatures"
          | "expirationDate"
          | "expired"
          | "iconAssetToken"
          | "icons"
          | "individualTesters"
          | "lsMinimumSystemVersion"
          | "minOsVersion"
          | "perfPowerMetrics"
          | "preReleaseVersion"
          | "processingState"
          | "uploadedDate"
          | "usesNonExemptEncryption"
          | "version"
        )[];
      },
      params: RequestParams = {},
    ): Promise<BuildBetaDetailResponse> =>
      this.request<BuildBetaDetailResponse, ErrorResponse>({
        path: `/v1/buildBetaDetails/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags BuildBetaDetails
     * @name BuildBetaDetailsUpdateInstance
     * @request PATCH:/v1/buildBetaDetails/{id}
     * @secure
     */
    updateInstance: (
      id: string,
      data: BuildBetaDetailUpdateRequest,
      params: RequestParams = {},
    ): Promise<BuildBetaDetailResponse> =>
      this.request<BuildBetaDetailResponse, ErrorResponse>({
        path: `/v1/buildBetaDetails/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags BuildBetaDetails
     * @name BuildBetaDetailsBuildGetToOneRelated
     * @request GET:/v1/buildBetaDetails/{id}/build
     * @secure
     */
    buildGetToOneRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type builds */
        "fields[builds]"?: (
          | "app"
          | "appEncryptionDeclaration"
          | "appStoreVersion"
          | "betaAppReviewSubmission"
          | "betaBuildLocalizations"
          | "betaGroups"
          | "buildAudienceType"
          | "buildBetaDetail"
          | "buildBundles"
          | "computedMinMacOsVersion"
          | "diagnosticSignatures"
          | "expirationDate"
          | "expired"
          | "iconAssetToken"
          | "icons"
          | "individualTesters"
          | "lsMinimumSystemVersion"
          | "minOsVersion"
          | "perfPowerMetrics"
          | "preReleaseVersion"
          | "processingState"
          | "uploadedDate"
          | "usesNonExemptEncryption"
          | "version"
        )[];
      },
      params: RequestParams = {},
    ): Promise<BuildWithoutIncludesResponse> =>
      this.request<BuildWithoutIncludesResponse, ErrorResponse>({
        path: `/v1/buildBetaDetails/${id}/build`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  buildBetaNotifications = {
    /**
     * No description
     *
     * @tags BuildBetaNotifications
     * @name BuildBetaNotificationsCreateInstance
     * @request POST:/v1/buildBetaNotifications
     * @secure
     */
    createInstance: (
      data: BuildBetaNotificationCreateRequest,
      params: RequestParams = {},
    ): Promise<BuildBetaNotificationResponse> =>
      this.request<BuildBetaNotificationResponse, ErrorResponse>({
        path: `/v1/buildBetaNotifications`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),
  };
  builds = {
    /**
     * No description
     *
     * @tags Builds
     * @name BuildsGetCollection
     * @request GET:/v1/builds
     * @secure
     */
    getCollection: (
      query?: {
        /** filter by attribute 'betaAppReviewSubmission.betaReviewState' */
        filterBetaAppReviewSubmissionBetaReviewState?: ("WAITING_FOR_REVIEW" | "IN_REVIEW" | "REJECTED" | "APPROVED")[];
        /** filter by attribute 'buildAudienceType' */
        "filter[buildAudienceType]"?: ("INTERNAL_ONLY" | "APP_STORE_ELIGIBLE")[];
        /** filter by attribute 'expired' */
        "filter[expired]"?: string[];
        /** filter by attribute 'preReleaseVersion.platform' */
        filterPreReleaseVersionPlatform?: ("IOS" | "MAC_OS" | "TV_OS" | "VISION_OS")[];
        /** filter by attribute 'preReleaseVersion.version' */
        filterPreReleaseVersionVersion?: string[];
        /** filter by attribute 'processingState' */
        "filter[processingState]"?: ("PROCESSING" | "FAILED" | "INVALID" | "VALID")[];
        /** filter by attribute 'usesNonExemptEncryption' */
        "filter[usesNonExemptEncryption]"?: string[];
        /** filter by attribute 'version' */
        "filter[version]"?: string[];
        /** filter by id(s) of related 'app' */
        "filter[app]"?: string[];
        /** filter by id(s) of related 'appStoreVersion' */
        "filter[appStoreVersion]"?: string[];
        /** filter by id(s) of related 'betaGroups' */
        "filter[betaGroups]"?: string[];
        /** filter by id(s) of related 'preReleaseVersion' */
        "filter[preReleaseVersion]"?: string[];
        /** filter by id(s) */
        "filter[id]"?: string[];
        /** comma-separated list of sort expressions; resources will be sorted as specified */
        sort?: (
          | "preReleaseVersion"
          | "-preReleaseVersion"
          | "uploadedDate"
          | "-uploadedDate"
          | "version"
          | "-version"
        )[];
        /** the fields to include for returned resources of type builds */
        "fields[builds]"?: (
          | "app"
          | "appEncryptionDeclaration"
          | "appStoreVersion"
          | "betaAppReviewSubmission"
          | "betaBuildLocalizations"
          | "betaGroups"
          | "buildAudienceType"
          | "buildBetaDetail"
          | "buildBundles"
          | "computedMinMacOsVersion"
          | "diagnosticSignatures"
          | "expirationDate"
          | "expired"
          | "iconAssetToken"
          | "icons"
          | "individualTesters"
          | "lsMinimumSystemVersion"
          | "minOsVersion"
          | "perfPowerMetrics"
          | "preReleaseVersion"
          | "processingState"
          | "uploadedDate"
          | "usesNonExemptEncryption"
          | "version"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /** comma-separated list of relationships to include */
        include?: (
          | "app"
          | "appEncryptionDeclaration"
          | "appStoreVersion"
          | "betaAppReviewSubmission"
          | "betaBuildLocalizations"
          | "betaGroups"
          | "buildBetaDetail"
          | "buildBundles"
          | "icons"
          | "individualTesters"
          | "preReleaseVersion"
        )[];
        /** the fields to include for returned resources of type diagnosticSignatures */
        "fields[diagnosticSignatures]"?: ("diagnosticType" | "logs" | "signature" | "weight")[];
        /** the fields to include for returned resources of type buildIcons */
        "fields[buildIcons]"?: ("iconAsset" | "iconType" | "name")[];
        /** the fields to include for returned resources of type buildBetaDetails */
        "fields[buildBetaDetails]"?: ("autoNotifyEnabled" | "build" | "externalBuildState" | "internalBuildState")[];
        /** the fields to include for returned resources of type betaAppReviewSubmissions */
        "fields[betaAppReviewSubmissions]"?: ("betaReviewState" | "build" | "submittedDate")[];
        /** the fields to include for returned resources of type betaTesters */
        "fields[betaTesters]"?: (
          | "apps"
          | "betaGroups"
          | "builds"
          | "email"
          | "firstName"
          | "inviteType"
          | "lastName"
        )[];
        /** the fields to include for returned resources of type appStoreVersions */
        "fields[appStoreVersions]"?: (
          | "ageRatingDeclaration"
          | "alternativeDistributionPackage"
          | "app"
          | "appClipDefaultExperience"
          | "appStoreReviewDetail"
          | "appStoreState"
          | "appStoreVersionExperiments"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersionLocalizations"
          | "appStoreVersionPhasedRelease"
          | "appStoreVersionSubmission"
          | "appVersionState"
          | "build"
          | "copyright"
          | "createdDate"
          | "customerReviews"
          | "downloadable"
          | "earliestReleaseDate"
          | "platform"
          | "releaseType"
          | "reviewType"
          | "routingAppCoverage"
          | "versionString"
        )[];
        /** the fields to include for returned resources of type betaBuildLocalizations */
        "fields[betaBuildLocalizations]"?: ("build" | "locale" | "whatsNew")[];
        /** the fields to include for returned resources of type preReleaseVersions */
        "fields[preReleaseVersions]"?: ("app" | "builds" | "platform" | "version")[];
        /** the fields to include for returned resources of type appEncryptionDeclarations */
        "fields[appEncryptionDeclarations]"?: (
          | "app"
          | "appDescription"
          | "appEncryptionDeclarationDocument"
          | "appEncryptionDeclarationState"
          | "availableOnFrenchStore"
          | "builds"
          | "codeValue"
          | "containsProprietaryCryptography"
          | "containsThirdPartyCryptography"
          | "createdDate"
          | "documentName"
          | "documentType"
          | "documentUrl"
          | "exempt"
          | "platform"
          | "uploadedDate"
          | "usesEncryption"
        )[];
        /** the fields to include for returned resources of type apps */
        "fields[apps]"?: (
          | "alternativeDistributionKey"
          | "analyticsReportRequests"
          | "appAvailability"
          | "appClips"
          | "appCustomProductPages"
          | "appEncryptionDeclarations"
          | "appEvents"
          | "appInfos"
          | "appPricePoints"
          | "appPriceSchedule"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersions"
          | "availableInNewTerritories"
          | "availableTerritories"
          | "betaAppLocalizations"
          | "betaAppReviewDetail"
          | "betaGroups"
          | "betaLicenseAgreement"
          | "betaTesters"
          | "builds"
          | "bundleId"
          | "ciProduct"
          | "contentRightsDeclaration"
          | "customerReviews"
          | "endUserLicenseAgreement"
          | "gameCenterDetail"
          | "gameCenterEnabledVersions"
          | "inAppPurchases"
          | "inAppPurchasesV2"
          | "isOrEverWasMadeForKids"
          | "marketplaceSearchDetail"
          | "name"
          | "perfPowerMetrics"
          | "preOrder"
          | "preReleaseVersions"
          | "pricePoints"
          | "prices"
          | "primaryLocale"
          | "promotedPurchases"
          | "reviewSubmissions"
          | "sku"
          | "subscriptionGracePeriod"
          | "subscriptionGroups"
          | "subscriptionStatusUrl"
          | "subscriptionStatusUrlForSandbox"
          | "subscriptionStatusUrlVersion"
          | "subscriptionStatusUrlVersionForSandbox"
        )[];
        /** the fields to include for returned resources of type perfPowerMetrics */
        "fields[perfPowerMetrics]"?: ("deviceType" | "metricType" | "platform")[];
        /**
         * maximum number of related betaBuildLocalizations returned (when they are included)
         * @max 50
         */
        "limit[betaBuildLocalizations]"?: number;
        /**
         * maximum number of related betaGroups returned (when they are included)
         * @max 50
         */
        "limit[betaGroups]"?: number;
        /**
         * maximum number of related buildBundles returned (when they are included)
         * @max 50
         */
        "limit[buildBundles]"?: number;
        /**
         * maximum number of related icons returned (when they are included)
         * @max 50
         */
        "limit[icons]"?: number;
        /**
         * maximum number of related individualTesters returned (when they are included)
         * @max 50
         */
        "limit[individualTesters]"?: number;
      },
      params: RequestParams = {},
    ): Promise<BuildsResponse> =>
      this.request<BuildsResponse, ErrorResponse>({
        path: `/v1/builds`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Builds
     * @name BuildsGetInstance
     * @request GET:/v1/builds/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type builds */
        "fields[builds]"?: (
          | "app"
          | "appEncryptionDeclaration"
          | "appStoreVersion"
          | "betaAppReviewSubmission"
          | "betaBuildLocalizations"
          | "betaGroups"
          | "buildAudienceType"
          | "buildBetaDetail"
          | "buildBundles"
          | "computedMinMacOsVersion"
          | "diagnosticSignatures"
          | "expirationDate"
          | "expired"
          | "iconAssetToken"
          | "icons"
          | "individualTesters"
          | "lsMinimumSystemVersion"
          | "minOsVersion"
          | "perfPowerMetrics"
          | "preReleaseVersion"
          | "processingState"
          | "uploadedDate"
          | "usesNonExemptEncryption"
          | "version"
        )[];
        /** comma-separated list of relationships to include */
        include?: (
          | "app"
          | "appEncryptionDeclaration"
          | "appStoreVersion"
          | "betaAppReviewSubmission"
          | "betaBuildLocalizations"
          | "betaGroups"
          | "buildBetaDetail"
          | "buildBundles"
          | "icons"
          | "individualTesters"
          | "preReleaseVersion"
        )[];
        /** the fields to include for returned resources of type diagnosticSignatures */
        "fields[diagnosticSignatures]"?: ("diagnosticType" | "logs" | "signature" | "weight")[];
        /** the fields to include for returned resources of type buildIcons */
        "fields[buildIcons]"?: ("iconAsset" | "iconType" | "name")[];
        /** the fields to include for returned resources of type buildBetaDetails */
        "fields[buildBetaDetails]"?: ("autoNotifyEnabled" | "build" | "externalBuildState" | "internalBuildState")[];
        /** the fields to include for returned resources of type betaAppReviewSubmissions */
        "fields[betaAppReviewSubmissions]"?: ("betaReviewState" | "build" | "submittedDate")[];
        /** the fields to include for returned resources of type betaTesters */
        "fields[betaTesters]"?: (
          | "apps"
          | "betaGroups"
          | "builds"
          | "email"
          | "firstName"
          | "inviteType"
          | "lastName"
        )[];
        /** the fields to include for returned resources of type appStoreVersions */
        "fields[appStoreVersions]"?: (
          | "ageRatingDeclaration"
          | "alternativeDistributionPackage"
          | "app"
          | "appClipDefaultExperience"
          | "appStoreReviewDetail"
          | "appStoreState"
          | "appStoreVersionExperiments"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersionLocalizations"
          | "appStoreVersionPhasedRelease"
          | "appStoreVersionSubmission"
          | "appVersionState"
          | "build"
          | "copyright"
          | "createdDate"
          | "customerReviews"
          | "downloadable"
          | "earliestReleaseDate"
          | "platform"
          | "releaseType"
          | "reviewType"
          | "routingAppCoverage"
          | "versionString"
        )[];
        /** the fields to include for returned resources of type betaBuildLocalizations */
        "fields[betaBuildLocalizations]"?: ("build" | "locale" | "whatsNew")[];
        /** the fields to include for returned resources of type preReleaseVersions */
        "fields[preReleaseVersions]"?: ("app" | "builds" | "platform" | "version")[];
        /** the fields to include for returned resources of type appEncryptionDeclarations */
        "fields[appEncryptionDeclarations]"?: (
          | "app"
          | "appDescription"
          | "appEncryptionDeclarationDocument"
          | "appEncryptionDeclarationState"
          | "availableOnFrenchStore"
          | "builds"
          | "codeValue"
          | "containsProprietaryCryptography"
          | "containsThirdPartyCryptography"
          | "createdDate"
          | "documentName"
          | "documentType"
          | "documentUrl"
          | "exempt"
          | "platform"
          | "uploadedDate"
          | "usesEncryption"
        )[];
        /** the fields to include for returned resources of type apps */
        "fields[apps]"?: (
          | "alternativeDistributionKey"
          | "analyticsReportRequests"
          | "appAvailability"
          | "appClips"
          | "appCustomProductPages"
          | "appEncryptionDeclarations"
          | "appEvents"
          | "appInfos"
          | "appPricePoints"
          | "appPriceSchedule"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersions"
          | "availableInNewTerritories"
          | "availableTerritories"
          | "betaAppLocalizations"
          | "betaAppReviewDetail"
          | "betaGroups"
          | "betaLicenseAgreement"
          | "betaTesters"
          | "builds"
          | "bundleId"
          | "ciProduct"
          | "contentRightsDeclaration"
          | "customerReviews"
          | "endUserLicenseAgreement"
          | "gameCenterDetail"
          | "gameCenterEnabledVersions"
          | "inAppPurchases"
          | "inAppPurchasesV2"
          | "isOrEverWasMadeForKids"
          | "marketplaceSearchDetail"
          | "name"
          | "perfPowerMetrics"
          | "preOrder"
          | "preReleaseVersions"
          | "pricePoints"
          | "prices"
          | "primaryLocale"
          | "promotedPurchases"
          | "reviewSubmissions"
          | "sku"
          | "subscriptionGracePeriod"
          | "subscriptionGroups"
          | "subscriptionStatusUrl"
          | "subscriptionStatusUrlForSandbox"
          | "subscriptionStatusUrlVersion"
          | "subscriptionStatusUrlVersionForSandbox"
        )[];
        /** the fields to include for returned resources of type perfPowerMetrics */
        "fields[perfPowerMetrics]"?: ("deviceType" | "metricType" | "platform")[];
        /**
         * maximum number of related betaBuildLocalizations returned (when they are included)
         * @max 50
         */
        "limit[betaBuildLocalizations]"?: number;
        /**
         * maximum number of related betaGroups returned (when they are included)
         * @max 50
         */
        "limit[betaGroups]"?: number;
        /**
         * maximum number of related buildBundles returned (when they are included)
         * @max 50
         */
        "limit[buildBundles]"?: number;
        /**
         * maximum number of related icons returned (when they are included)
         * @max 50
         */
        "limit[icons]"?: number;
        /**
         * maximum number of related individualTesters returned (when they are included)
         * @max 50
         */
        "limit[individualTesters]"?: number;
      },
      params: RequestParams = {},
    ): Promise<BuildResponse> =>
      this.request<BuildResponse, ErrorResponse>({
        path: `/v1/builds/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Builds
     * @name BuildsUpdateInstance
     * @request PATCH:/v1/builds/{id}
     * @secure
     */
    updateInstance: (id: string, data: BuildUpdateRequest, params: RequestParams = {}): Promise<BuildResponse> =>
      this.request<BuildResponse, ErrorResponse>({
        path: `/v1/builds/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Builds
     * @name BuildsAppGetToOneRelated
     * @request GET:/v1/builds/{id}/app
     * @secure
     */
    appGetToOneRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type apps */
        "fields[apps]"?: (
          | "alternativeDistributionKey"
          | "analyticsReportRequests"
          | "appAvailability"
          | "appClips"
          | "appCustomProductPages"
          | "appEncryptionDeclarations"
          | "appEvents"
          | "appInfos"
          | "appPricePoints"
          | "appPriceSchedule"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersions"
          | "availableInNewTerritories"
          | "availableTerritories"
          | "betaAppLocalizations"
          | "betaAppReviewDetail"
          | "betaGroups"
          | "betaLicenseAgreement"
          | "betaTesters"
          | "builds"
          | "bundleId"
          | "ciProduct"
          | "contentRightsDeclaration"
          | "customerReviews"
          | "endUserLicenseAgreement"
          | "gameCenterDetail"
          | "gameCenterEnabledVersions"
          | "inAppPurchases"
          | "inAppPurchasesV2"
          | "isOrEverWasMadeForKids"
          | "marketplaceSearchDetail"
          | "name"
          | "perfPowerMetrics"
          | "preOrder"
          | "preReleaseVersions"
          | "pricePoints"
          | "prices"
          | "primaryLocale"
          | "promotedPurchases"
          | "reviewSubmissions"
          | "sku"
          | "subscriptionGracePeriod"
          | "subscriptionGroups"
          | "subscriptionStatusUrl"
          | "subscriptionStatusUrlForSandbox"
          | "subscriptionStatusUrlVersion"
          | "subscriptionStatusUrlVersionForSandbox"
        )[];
      },
      params: RequestParams = {},
    ): Promise<AppWithoutIncludesResponse> =>
      this.request<AppWithoutIncludesResponse, ErrorResponse>({
        path: `/v1/builds/${id}/app`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Builds
     * @name BuildsAppEncryptionDeclarationGetToOneRelationship
     * @request GET:/v1/builds/{id}/relationships/appEncryptionDeclaration
     * @secure
     */
    appEncryptionDeclarationGetToOneRelationship: (
      id: string,
      params: RequestParams = {},
    ): Promise<BuildAppEncryptionDeclarationLinkageResponse> =>
      this.request<BuildAppEncryptionDeclarationLinkageResponse, ErrorResponse>({
        path: `/v1/builds/${id}/relationships/appEncryptionDeclaration`,
        method: "GET",
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Builds
     * @name BuildsAppEncryptionDeclarationUpdateToOneRelationship
     * @request PATCH:/v1/builds/{id}/relationships/appEncryptionDeclaration
     * @secure
     */
    appEncryptionDeclarationUpdateToOneRelationship: (
      id: string,
      data: BuildAppEncryptionDeclarationLinkageRequest,
      params: RequestParams = {},
    ): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/builds/${id}/relationships/appEncryptionDeclaration`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * No description
     *
     * @tags Builds
     * @name BuildsAppEncryptionDeclarationGetToOneRelated
     * @request GET:/v1/builds/{id}/appEncryptionDeclaration
     * @secure
     */
    appEncryptionDeclarationGetToOneRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type appEncryptionDeclarations */
        "fields[appEncryptionDeclarations]"?: (
          | "app"
          | "appDescription"
          | "appEncryptionDeclarationDocument"
          | "appEncryptionDeclarationState"
          | "availableOnFrenchStore"
          | "builds"
          | "codeValue"
          | "containsProprietaryCryptography"
          | "containsThirdPartyCryptography"
          | "createdDate"
          | "documentName"
          | "documentType"
          | "documentUrl"
          | "exempt"
          | "platform"
          | "uploadedDate"
          | "usesEncryption"
        )[];
      },
      params: RequestParams = {},
    ): Promise<AppEncryptionDeclarationWithoutIncludesResponse> =>
      this.request<AppEncryptionDeclarationWithoutIncludesResponse, ErrorResponse>({
        path: `/v1/builds/${id}/appEncryptionDeclaration`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Builds
     * @name BuildsAppStoreVersionGetToOneRelated
     * @request GET:/v1/builds/{id}/appStoreVersion
     * @secure
     */
    appStoreVersionGetToOneRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type ageRatingDeclarations */
        "fields[ageRatingDeclarations]"?: (
          | "ageRatingOverride"
          | "alcoholTobaccoOrDrugUseOrReferences"
          | "contests"
          | "gambling"
          | "gamblingAndContests"
          | "gamblingSimulated"
          | "horrorOrFearThemes"
          | "kidsAgeBand"
          | "matureOrSuggestiveThemes"
          | "medicalOrTreatmentInformation"
          | "profanityOrCrudeHumor"
          | "seventeenPlus"
          | "sexualContentGraphicAndNudity"
          | "sexualContentOrNudity"
          | "unrestrictedWebAccess"
          | "violenceCartoonOrFantasy"
          | "violenceRealistic"
          | "violenceRealisticProlongedGraphicOrSadistic"
        )[];
        /** the fields to include for returned resources of type appStoreReviewDetails */
        "fields[appStoreReviewDetails]"?: (
          | "appStoreReviewAttachments"
          | "appStoreVersion"
          | "contactEmail"
          | "contactFirstName"
          | "contactLastName"
          | "contactPhone"
          | "demoAccountName"
          | "demoAccountPassword"
          | "demoAccountRequired"
          | "notes"
        )[];
        /** the fields to include for returned resources of type appStoreVersionLocalizations */
        "fields[appStoreVersionLocalizations]"?: (
          | "appPreviewSets"
          | "appScreenshotSets"
          | "appStoreVersion"
          | "description"
          | "keywords"
          | "locale"
          | "marketingUrl"
          | "promotionalText"
          | "supportUrl"
          | "whatsNew"
        )[];
        /** the fields to include for returned resources of type appStoreVersionExperiments */
        "fields[appStoreVersionExperiments]"?: (
          | "app"
          | "appStoreVersion"
          | "appStoreVersionExperimentTreatments"
          | "controlVersions"
          | "endDate"
          | "latestControlVersion"
          | "name"
          | "platform"
          | "reviewRequired"
          | "startDate"
          | "started"
          | "state"
          | "trafficProportion"
        )[];
        /** the fields to include for returned resources of type appStoreVersionSubmissions */
        "fields[appStoreVersionSubmissions]"?: "appStoreVersion"[];
        /** the fields to include for returned resources of type alternativeDistributionPackages */
        "fields[alternativeDistributionPackages]"?: ("appStoreVersion" | "versions")[];
        /** the fields to include for returned resources of type appStoreVersions */
        "fields[appStoreVersions]"?: (
          | "ageRatingDeclaration"
          | "alternativeDistributionPackage"
          | "app"
          | "appClipDefaultExperience"
          | "appStoreReviewDetail"
          | "appStoreState"
          | "appStoreVersionExperiments"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersionLocalizations"
          | "appStoreVersionPhasedRelease"
          | "appStoreVersionSubmission"
          | "appVersionState"
          | "build"
          | "copyright"
          | "createdDate"
          | "customerReviews"
          | "downloadable"
          | "earliestReleaseDate"
          | "platform"
          | "releaseType"
          | "reviewType"
          | "routingAppCoverage"
          | "versionString"
        )[];
        /** the fields to include for returned resources of type apps */
        "fields[apps]"?: (
          | "alternativeDistributionKey"
          | "analyticsReportRequests"
          | "appAvailability"
          | "appClips"
          | "appCustomProductPages"
          | "appEncryptionDeclarations"
          | "appEvents"
          | "appInfos"
          | "appPricePoints"
          | "appPriceSchedule"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersions"
          | "availableInNewTerritories"
          | "availableTerritories"
          | "betaAppLocalizations"
          | "betaAppReviewDetail"
          | "betaGroups"
          | "betaLicenseAgreement"
          | "betaTesters"
          | "builds"
          | "bundleId"
          | "ciProduct"
          | "contentRightsDeclaration"
          | "customerReviews"
          | "endUserLicenseAgreement"
          | "gameCenterDetail"
          | "gameCenterEnabledVersions"
          | "inAppPurchases"
          | "inAppPurchasesV2"
          | "isOrEverWasMadeForKids"
          | "marketplaceSearchDetail"
          | "name"
          | "perfPowerMetrics"
          | "preOrder"
          | "preReleaseVersions"
          | "pricePoints"
          | "prices"
          | "primaryLocale"
          | "promotedPurchases"
          | "reviewSubmissions"
          | "sku"
          | "subscriptionGracePeriod"
          | "subscriptionGroups"
          | "subscriptionStatusUrl"
          | "subscriptionStatusUrlForSandbox"
          | "subscriptionStatusUrlVersion"
          | "subscriptionStatusUrlVersionForSandbox"
        )[];
        /** the fields to include for returned resources of type routingAppCoverages */
        "fields[routingAppCoverages]"?: (
          | "appStoreVersion"
          | "assetDeliveryState"
          | "fileName"
          | "fileSize"
          | "sourceFileChecksum"
          | "uploadOperations"
          | "uploaded"
        )[];
        /** the fields to include for returned resources of type appClipDefaultExperiences */
        "fields[appClipDefaultExperiences]"?: (
          | "action"
          | "appClip"
          | "appClipAppStoreReviewDetail"
          | "appClipDefaultExperienceLocalizations"
          | "appClipDefaultExperienceTemplate"
          | "releaseWithAppStoreVersion"
        )[];
        /** the fields to include for returned resources of type appStoreVersionPhasedReleases */
        "fields[appStoreVersionPhasedReleases]"?: (
          | "appStoreVersion"
          | "currentDayNumber"
          | "phasedReleaseState"
          | "startDate"
          | "totalPauseDuration"
        )[];
        /** the fields to include for returned resources of type builds */
        "fields[builds]"?: (
          | "app"
          | "appEncryptionDeclaration"
          | "appStoreVersion"
          | "betaAppReviewSubmission"
          | "betaBuildLocalizations"
          | "betaGroups"
          | "buildAudienceType"
          | "buildBetaDetail"
          | "buildBundles"
          | "computedMinMacOsVersion"
          | "diagnosticSignatures"
          | "expirationDate"
          | "expired"
          | "iconAssetToken"
          | "icons"
          | "individualTesters"
          | "lsMinimumSystemVersion"
          | "minOsVersion"
          | "perfPowerMetrics"
          | "preReleaseVersion"
          | "processingState"
          | "uploadedDate"
          | "usesNonExemptEncryption"
          | "version"
        )[];
        /**
         * maximum number of related appStoreVersionLocalizations returned (when they are included)
         * @max 50
         */
        "limit[appStoreVersionLocalizations]"?: number;
        /**
         * maximum number of related appStoreVersionExperiments returned (when they are included)
         * @deprecated
         * @max 50
         */
        "limit[appStoreVersionExperiments]"?: number;
        /**
         * maximum number of related appStoreVersionExperimentsV2 returned (when they are included)
         * @max 50
         */
        "limit[appStoreVersionExperimentsV2]"?: number;
        /** comma-separated list of relationships to include */
        include?: (
          | "ageRatingDeclaration"
          | "alternativeDistributionPackage"
          | "app"
          | "appClipDefaultExperience"
          | "appStoreReviewDetail"
          | "appStoreVersionExperiments"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersionLocalizations"
          | "appStoreVersionPhasedRelease"
          | "appStoreVersionSubmission"
          | "build"
          | "routingAppCoverage"
        )[];
      },
      params: RequestParams = {},
    ): Promise<AppStoreVersionResponse> =>
      this.request<AppStoreVersionResponse, ErrorResponse>({
        path: `/v1/builds/${id}/appStoreVersion`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Builds
     * @name BuildsBetaAppReviewSubmissionGetToOneRelated
     * @request GET:/v1/builds/{id}/betaAppReviewSubmission
     * @secure
     */
    betaAppReviewSubmissionGetToOneRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type betaAppReviewSubmissions */
        "fields[betaAppReviewSubmissions]"?: ("betaReviewState" | "build" | "submittedDate")[];
      },
      params: RequestParams = {},
    ): Promise<BetaAppReviewSubmissionWithoutIncludesResponse> =>
      this.request<BetaAppReviewSubmissionWithoutIncludesResponse, ErrorResponse>({
        path: `/v1/builds/${id}/betaAppReviewSubmission`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Builds
     * @name BuildsBetaBuildLocalizationsGetToManyRelated
     * @request GET:/v1/builds/{id}/betaBuildLocalizations
     * @secure
     */
    betaBuildLocalizationsGetToManyRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type betaBuildLocalizations */
        "fields[betaBuildLocalizations]"?: ("build" | "locale" | "whatsNew")[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
      },
      params: RequestParams = {},
    ): Promise<BetaBuildLocalizationsWithoutIncludesResponse> =>
      this.request<BetaBuildLocalizationsWithoutIncludesResponse, ErrorResponse>({
        path: `/v1/builds/${id}/betaBuildLocalizations`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Builds
     * @name BuildsBetaGroupsCreateToManyRelationship
     * @request POST:/v1/builds/{id}/relationships/betaGroups
     * @secure
     */
    betaGroupsCreateToManyRelationship: (
      id: string,
      data: BuildBetaGroupsLinkagesRequest,
      params: RequestParams = {},
    ): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/builds/${id}/relationships/betaGroups`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * No description
     *
     * @tags Builds
     * @name BuildsBetaGroupsDeleteToManyRelationship
     * @request DELETE:/v1/builds/{id}/relationships/betaGroups
     * @secure
     */
    betaGroupsDeleteToManyRelationship: (
      id: string,
      data: BuildBetaGroupsLinkagesRequest,
      params: RequestParams = {},
    ): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/builds/${id}/relationships/betaGroups`,
        method: "DELETE",
        body: data,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * No description
     *
     * @tags Builds
     * @name BuildsBuildBetaDetailGetToOneRelated
     * @request GET:/v1/builds/{id}/buildBetaDetail
     * @secure
     */
    buildBetaDetailGetToOneRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type buildBetaDetails */
        "fields[buildBetaDetails]"?: ("autoNotifyEnabled" | "build" | "externalBuildState" | "internalBuildState")[];
        /** the fields to include for returned resources of type builds */
        "fields[builds]"?: (
          | "app"
          | "appEncryptionDeclaration"
          | "appStoreVersion"
          | "betaAppReviewSubmission"
          | "betaBuildLocalizations"
          | "betaGroups"
          | "buildAudienceType"
          | "buildBetaDetail"
          | "buildBundles"
          | "computedMinMacOsVersion"
          | "diagnosticSignatures"
          | "expirationDate"
          | "expired"
          | "iconAssetToken"
          | "icons"
          | "individualTesters"
          | "lsMinimumSystemVersion"
          | "minOsVersion"
          | "perfPowerMetrics"
          | "preReleaseVersion"
          | "processingState"
          | "uploadedDate"
          | "usesNonExemptEncryption"
          | "version"
        )[];
        /** comma-separated list of relationships to include */
        include?: "build"[];
      },
      params: RequestParams = {},
    ): Promise<BuildBetaDetailResponse> =>
      this.request<BuildBetaDetailResponse, ErrorResponse>({
        path: `/v1/builds/${id}/buildBetaDetail`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Builds
     * @name BuildsDiagnosticSignaturesGetToManyRelated
     * @request GET:/v1/builds/{id}/diagnosticSignatures
     * @secure
     */
    diagnosticSignaturesGetToManyRelated: (
      id: string,
      query?: {
        /** filter by attribute 'diagnosticType' */
        "filter[diagnosticType]"?: ("DISK_WRITES" | "HANGS")[];
        /** the fields to include for returned resources of type diagnosticSignatures */
        "fields[diagnosticSignatures]"?: ("diagnosticType" | "logs" | "signature" | "weight")[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
      },
      params: RequestParams = {},
    ): Promise<DiagnosticSignaturesResponse> =>
      this.request<DiagnosticSignaturesResponse, ErrorResponse>({
        path: `/v1/builds/${id}/diagnosticSignatures`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Builds
     * @name BuildsIconsGetToManyRelated
     * @request GET:/v1/builds/{id}/icons
     * @secure
     */
    iconsGetToManyRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type buildIcons */
        "fields[buildIcons]"?: ("iconAsset" | "iconType" | "name")[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
      },
      params: RequestParams = {},
    ): Promise<BuildIconsWithoutIncludesResponse> =>
      this.request<BuildIconsWithoutIncludesResponse, ErrorResponse>({
        path: `/v1/builds/${id}/icons`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Builds
     * @name BuildsIndividualTestersGetToManyRelationship
     * @request GET:/v1/builds/{id}/relationships/individualTesters
     * @secure
     */
    individualTestersGetToManyRelationship: (
      id: string,
      query?: {
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
      },
      params: RequestParams = {},
    ): Promise<BuildIndividualTestersLinkagesResponse> =>
      this.request<BuildIndividualTestersLinkagesResponse, ErrorResponse>({
        path: `/v1/builds/${id}/relationships/individualTesters`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Builds
     * @name BuildsIndividualTestersCreateToManyRelationship
     * @request POST:/v1/builds/{id}/relationships/individualTesters
     * @secure
     */
    individualTestersCreateToManyRelationship: (
      id: string,
      data: BuildIndividualTestersLinkagesRequest,
      params: RequestParams = {},
    ): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/builds/${id}/relationships/individualTesters`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * No description
     *
     * @tags Builds
     * @name BuildsIndividualTestersDeleteToManyRelationship
     * @request DELETE:/v1/builds/{id}/relationships/individualTesters
     * @secure
     */
    individualTestersDeleteToManyRelationship: (
      id: string,
      data: BuildIndividualTestersLinkagesRequest,
      params: RequestParams = {},
    ): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/builds/${id}/relationships/individualTesters`,
        method: "DELETE",
        body: data,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * No description
     *
     * @tags Builds
     * @name BuildsIndividualTestersGetToManyRelated
     * @request GET:/v1/builds/{id}/individualTesters
     * @secure
     */
    individualTestersGetToManyRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type betaTesters */
        "fields[betaTesters]"?: (
          | "apps"
          | "betaGroups"
          | "builds"
          | "email"
          | "firstName"
          | "inviteType"
          | "lastName"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
      },
      params: RequestParams = {},
    ): Promise<BetaTestersWithoutIncludesResponse> =>
      this.request<BetaTestersWithoutIncludesResponse, ErrorResponse>({
        path: `/v1/builds/${id}/individualTesters`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Builds
     * @name BuildsPerfPowerMetricsGetToManyRelated
     * @request GET:/v1/builds/{id}/perfPowerMetrics
     * @secure
     */
    perfPowerMetricsGetToManyRelated: (
      id: string,
      query?: {
        /** filter by attribute 'deviceType' */
        "filter[deviceType]"?: string[];
        /** filter by attribute 'metricType' */
        "filter[metricType]"?: ("DISK" | "HANG" | "BATTERY" | "LAUNCH" | "MEMORY" | "ANIMATION" | "TERMINATION")[];
        /** filter by attribute 'platform' */
        "filter[platform]"?: "IOS"[];
      },
      params: RequestParams = {},
    ): Promise<XcodeMetrics> =>
      this.request<XcodeMetrics, ErrorResponse>({
        path: `/v1/builds/${id}/perfPowerMetrics`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Builds
     * @name BuildsPreReleaseVersionGetToOneRelated
     * @request GET:/v1/builds/{id}/preReleaseVersion
     * @secure
     */
    preReleaseVersionGetToOneRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type preReleaseVersions */
        "fields[preReleaseVersions]"?: ("app" | "builds" | "platform" | "version")[];
      },
      params: RequestParams = {},
    ): Promise<PrereleaseVersionWithoutIncludesResponse> =>
      this.request<PrereleaseVersionWithoutIncludesResponse, ErrorResponse>({
        path: `/v1/builds/${id}/preReleaseVersion`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Builds, Metrics
     * @name BuildsBetaBuildUsagesGetMetrics
     * @request GET:/v1/builds/{id}/metrics/betaBuildUsages
     * @secure
     */
    betaBuildUsagesGetMetrics: (
      id: string,
      query?: {
        /**
         * maximum number of groups to return per page
         * @max 200
         */
        limit?: number;
      },
      params: RequestParams = {},
    ): Promise<BetaBuildUsagesV1MetricResponse> =>
      this.request<BetaBuildUsagesV1MetricResponse, ErrorResponse>({
        path: `/v1/builds/${id}/metrics/betaBuildUsages`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  bundleIdCapabilities = {
    /**
     * No description
     *
     * @tags BundleIdCapabilities
     * @name BundleIdCapabilitiesCreateInstance
     * @request POST:/v1/bundleIdCapabilities
     * @secure
     */
    createInstance: (
      data: BundleIdCapabilityCreateRequest,
      params: RequestParams = {},
    ): Promise<BundleIdCapabilityResponse> =>
      this.request<BundleIdCapabilityResponse, ErrorResponse>({
        path: `/v1/bundleIdCapabilities`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags BundleIdCapabilities
     * @name BundleIdCapabilitiesUpdateInstance
     * @request PATCH:/v1/bundleIdCapabilities/{id}
     * @secure
     */
    updateInstance: (
      id: string,
      data: BundleIdCapabilityUpdateRequest,
      params: RequestParams = {},
    ): Promise<BundleIdCapabilityResponse> =>
      this.request<BundleIdCapabilityResponse, ErrorResponse>({
        path: `/v1/bundleIdCapabilities/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags BundleIdCapabilities
     * @name BundleIdCapabilitiesDeleteInstance
     * @request DELETE:/v1/bundleIdCapabilities/{id}
     * @secure
     */
    deleteInstance: (id: string, params: RequestParams = {}): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/bundleIdCapabilities/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),
  };
  bundleIds = {
    /**
     * No description
     *
     * @tags BundleIds
     * @name BundleIdsGetCollection
     * @request GET:/v1/bundleIds
     * @secure
     */
    getCollection: (
      query?: {
        /** filter by attribute 'identifier' */
        "filter[identifier]"?: string[];
        /** filter by attribute 'name' */
        "filter[name]"?: string[];
        /** filter by attribute 'platform' */
        "filter[platform]"?: ("IOS" | "MAC_OS")[];
        /** filter by attribute 'seedId' */
        "filter[seedId]"?: string[];
        /** filter by id(s) */
        "filter[id]"?: string[];
        /** comma-separated list of sort expressions; resources will be sorted as specified */
        sort?: (
          | "id"
          | "-id"
          | "identifier"
          | "-identifier"
          | "name"
          | "-name"
          | "platform"
          | "-platform"
          | "seedId"
          | "-seedId"
        )[];
        /** the fields to include for returned resources of type bundleIds */
        "fields[bundleIds]"?: (
          | "app"
          | "bundleIdCapabilities"
          | "identifier"
          | "name"
          | "platform"
          | "profiles"
          | "seedId"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /** comma-separated list of relationships to include */
        include?: ("app" | "bundleIdCapabilities" | "profiles")[];
        /** the fields to include for returned resources of type bundleIdCapabilities */
        "fields[bundleIdCapabilities]"?: ("bundleId" | "capabilityType" | "settings")[];
        /** the fields to include for returned resources of type profiles */
        "fields[profiles]"?: (
          | "bundleId"
          | "certificates"
          | "createdDate"
          | "devices"
          | "expirationDate"
          | "name"
          | "platform"
          | "profileContent"
          | "profileState"
          | "profileType"
          | "uuid"
        )[];
        /** the fields to include for returned resources of type apps */
        "fields[apps]"?: (
          | "alternativeDistributionKey"
          | "analyticsReportRequests"
          | "appAvailability"
          | "appClips"
          | "appCustomProductPages"
          | "appEncryptionDeclarations"
          | "appEvents"
          | "appInfos"
          | "appPricePoints"
          | "appPriceSchedule"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersions"
          | "availableInNewTerritories"
          | "availableTerritories"
          | "betaAppLocalizations"
          | "betaAppReviewDetail"
          | "betaGroups"
          | "betaLicenseAgreement"
          | "betaTesters"
          | "builds"
          | "bundleId"
          | "ciProduct"
          | "contentRightsDeclaration"
          | "customerReviews"
          | "endUserLicenseAgreement"
          | "gameCenterDetail"
          | "gameCenterEnabledVersions"
          | "inAppPurchases"
          | "inAppPurchasesV2"
          | "isOrEverWasMadeForKids"
          | "marketplaceSearchDetail"
          | "name"
          | "perfPowerMetrics"
          | "preOrder"
          | "preReleaseVersions"
          | "pricePoints"
          | "prices"
          | "primaryLocale"
          | "promotedPurchases"
          | "reviewSubmissions"
          | "sku"
          | "subscriptionGracePeriod"
          | "subscriptionGroups"
          | "subscriptionStatusUrl"
          | "subscriptionStatusUrlForSandbox"
          | "subscriptionStatusUrlVersion"
          | "subscriptionStatusUrlVersionForSandbox"
        )[];
        /**
         * maximum number of related bundleIdCapabilities returned (when they are included)
         * @max 50
         */
        "limit[bundleIdCapabilities]"?: number;
        /**
         * maximum number of related profiles returned (when they are included)
         * @max 50
         */
        "limit[profiles]"?: number;
      },
      params: RequestParams = {},
    ): Promise<BundleIdsResponse> =>
      this.request<BundleIdsResponse, ErrorResponse>({
        path: `/v1/bundleIds`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags BundleIds
     * @name BundleIdsCreateInstance
     * @request POST:/v1/bundleIds
     * @secure
     */
    createInstance: (data: BundleIdCreateRequest, params: RequestParams = {}): Promise<BundleIdResponse> =>
      this.request<BundleIdResponse, ErrorResponse>({
        path: `/v1/bundleIds`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags BundleIds
     * @name BundleIdsGetInstance
     * @request GET:/v1/bundleIds/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type bundleIds */
        "fields[bundleIds]"?: (
          | "app"
          | "bundleIdCapabilities"
          | "identifier"
          | "name"
          | "platform"
          | "profiles"
          | "seedId"
        )[];
        /** comma-separated list of relationships to include */
        include?: ("app" | "bundleIdCapabilities" | "profiles")[];
        /** the fields to include for returned resources of type bundleIdCapabilities */
        "fields[bundleIdCapabilities]"?: ("bundleId" | "capabilityType" | "settings")[];
        /** the fields to include for returned resources of type profiles */
        "fields[profiles]"?: (
          | "bundleId"
          | "certificates"
          | "createdDate"
          | "devices"
          | "expirationDate"
          | "name"
          | "platform"
          | "profileContent"
          | "profileState"
          | "profileType"
          | "uuid"
        )[];
        /** the fields to include for returned resources of type apps */
        "fields[apps]"?: (
          | "alternativeDistributionKey"
          | "analyticsReportRequests"
          | "appAvailability"
          | "appClips"
          | "appCustomProductPages"
          | "appEncryptionDeclarations"
          | "appEvents"
          | "appInfos"
          | "appPricePoints"
          | "appPriceSchedule"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersions"
          | "availableInNewTerritories"
          | "availableTerritories"
          | "betaAppLocalizations"
          | "betaAppReviewDetail"
          | "betaGroups"
          | "betaLicenseAgreement"
          | "betaTesters"
          | "builds"
          | "bundleId"
          | "ciProduct"
          | "contentRightsDeclaration"
          | "customerReviews"
          | "endUserLicenseAgreement"
          | "gameCenterDetail"
          | "gameCenterEnabledVersions"
          | "inAppPurchases"
          | "inAppPurchasesV2"
          | "isOrEverWasMadeForKids"
          | "marketplaceSearchDetail"
          | "name"
          | "perfPowerMetrics"
          | "preOrder"
          | "preReleaseVersions"
          | "pricePoints"
          | "prices"
          | "primaryLocale"
          | "promotedPurchases"
          | "reviewSubmissions"
          | "sku"
          | "subscriptionGracePeriod"
          | "subscriptionGroups"
          | "subscriptionStatusUrl"
          | "subscriptionStatusUrlForSandbox"
          | "subscriptionStatusUrlVersion"
          | "subscriptionStatusUrlVersionForSandbox"
        )[];
        /**
         * maximum number of related bundleIdCapabilities returned (when they are included)
         * @max 50
         */
        "limit[bundleIdCapabilities]"?: number;
        /**
         * maximum number of related profiles returned (when they are included)
         * @max 50
         */
        "limit[profiles]"?: number;
      },
      params: RequestParams = {},
    ): Promise<BundleIdResponse> =>
      this.request<BundleIdResponse, ErrorResponse>({
        path: `/v1/bundleIds/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags BundleIds
     * @name BundleIdsUpdateInstance
     * @request PATCH:/v1/bundleIds/{id}
     * @secure
     */
    updateInstance: (id: string, data: BundleIdUpdateRequest, params: RequestParams = {}): Promise<BundleIdResponse> =>
      this.request<BundleIdResponse, ErrorResponse>({
        path: `/v1/bundleIds/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags BundleIds
     * @name BundleIdsDeleteInstance
     * @request DELETE:/v1/bundleIds/{id}
     * @secure
     */
    deleteInstance: (id: string, params: RequestParams = {}): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/bundleIds/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),

    /**
     * No description
     *
     * @tags BundleIds
     * @name BundleIdsAppGetToOneRelated
     * @request GET:/v1/bundleIds/{id}/app
     * @secure
     */
    appGetToOneRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type apps */
        "fields[apps]"?: (
          | "alternativeDistributionKey"
          | "analyticsReportRequests"
          | "appAvailability"
          | "appClips"
          | "appCustomProductPages"
          | "appEncryptionDeclarations"
          | "appEvents"
          | "appInfos"
          | "appPricePoints"
          | "appPriceSchedule"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersions"
          | "availableInNewTerritories"
          | "availableTerritories"
          | "betaAppLocalizations"
          | "betaAppReviewDetail"
          | "betaGroups"
          | "betaLicenseAgreement"
          | "betaTesters"
          | "builds"
          | "bundleId"
          | "ciProduct"
          | "contentRightsDeclaration"
          | "customerReviews"
          | "endUserLicenseAgreement"
          | "gameCenterDetail"
          | "gameCenterEnabledVersions"
          | "inAppPurchases"
          | "inAppPurchasesV2"
          | "isOrEverWasMadeForKids"
          | "marketplaceSearchDetail"
          | "name"
          | "perfPowerMetrics"
          | "preOrder"
          | "preReleaseVersions"
          | "pricePoints"
          | "prices"
          | "primaryLocale"
          | "promotedPurchases"
          | "reviewSubmissions"
          | "sku"
          | "subscriptionGracePeriod"
          | "subscriptionGroups"
          | "subscriptionStatusUrl"
          | "subscriptionStatusUrlForSandbox"
          | "subscriptionStatusUrlVersion"
          | "subscriptionStatusUrlVersionForSandbox"
        )[];
      },
      params: RequestParams = {},
    ): Promise<AppWithoutIncludesResponse> =>
      this.request<AppWithoutIncludesResponse, ErrorResponse>({
        path: `/v1/bundleIds/${id}/app`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags BundleIds
     * @name BundleIdsBundleIdCapabilitiesGetToManyRelated
     * @request GET:/v1/bundleIds/{id}/bundleIdCapabilities
     * @secure
     */
    bundleIdCapabilitiesGetToManyRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type bundleIdCapabilities */
        "fields[bundleIdCapabilities]"?: ("bundleId" | "capabilityType" | "settings")[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
      },
      params: RequestParams = {},
    ): Promise<BundleIdCapabilitiesWithoutIncludesResponse> =>
      this.request<BundleIdCapabilitiesWithoutIncludesResponse, ErrorResponse>({
        path: `/v1/bundleIds/${id}/bundleIdCapabilities`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags BundleIds
     * @name BundleIdsProfilesGetToManyRelated
     * @request GET:/v1/bundleIds/{id}/profiles
     * @secure
     */
    profilesGetToManyRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type profiles */
        "fields[profiles]"?: (
          | "bundleId"
          | "certificates"
          | "createdDate"
          | "devices"
          | "expirationDate"
          | "name"
          | "platform"
          | "profileContent"
          | "profileState"
          | "profileType"
          | "uuid"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
      },
      params: RequestParams = {},
    ): Promise<ProfilesWithoutIncludesResponse> =>
      this.request<ProfilesWithoutIncludesResponse, ErrorResponse>({
        path: `/v1/bundleIds/${id}/profiles`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  certificates = {
    /**
     * No description
     *
     * @tags Certificates
     * @name CertificatesGetCollection
     * @request GET:/v1/certificates
     * @secure
     */
    getCollection: (
      query?: {
        /** filter by attribute 'certificateType' */
        "filter[certificateType]"?: (
          | "IOS_DEVELOPMENT"
          | "IOS_DISTRIBUTION"
          | "MAC_APP_DISTRIBUTION"
          | "MAC_INSTALLER_DISTRIBUTION"
          | "MAC_APP_DEVELOPMENT"
          | "DEVELOPER_ID_KEXT"
          | "DEVELOPER_ID_APPLICATION"
          | "DEVELOPMENT"
          | "DISTRIBUTION"
          | "PASS_TYPE_ID"
          | "PASS_TYPE_ID_WITH_NFC"
        )[];
        /** filter by attribute 'displayName' */
        "filter[displayName]"?: string[];
        /** filter by attribute 'serialNumber' */
        "filter[serialNumber]"?: string[];
        /** filter by id(s) */
        "filter[id]"?: string[];
        /** comma-separated list of sort expressions; resources will be sorted as specified */
        sort?: (
          | "certificateType"
          | "-certificateType"
          | "displayName"
          | "-displayName"
          | "id"
          | "-id"
          | "serialNumber"
          | "-serialNumber"
        )[];
        /** the fields to include for returned resources of type certificates */
        "fields[certificates]"?: (
          | "certificateContent"
          | "certificateType"
          | "csrContent"
          | "displayName"
          | "expirationDate"
          | "name"
          | "platform"
          | "serialNumber"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
      },
      params: RequestParams = {},
    ): Promise<CertificatesResponse> =>
      this.request<CertificatesResponse, ErrorResponse>({
        path: `/v1/certificates`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Certificates
     * @name CertificatesCreateInstance
     * @request POST:/v1/certificates
     * @secure
     */
    createInstance: (data: CertificateCreateRequest, params: RequestParams = {}): Promise<CertificateResponse> =>
      this.request<CertificateResponse, ErrorResponse>({
        path: `/v1/certificates`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Certificates
     * @name CertificatesGetInstance
     * @request GET:/v1/certificates/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type certificates */
        "fields[certificates]"?: (
          | "certificateContent"
          | "certificateType"
          | "csrContent"
          | "displayName"
          | "expirationDate"
          | "name"
          | "platform"
          | "serialNumber"
        )[];
      },
      params: RequestParams = {},
    ): Promise<CertificateResponse> =>
      this.request<CertificateResponse, ErrorResponse>({
        path: `/v1/certificates/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Certificates
     * @name CertificatesDeleteInstance
     * @request DELETE:/v1/certificates/{id}
     * @secure
     */
    deleteInstance: (id: string, params: RequestParams = {}): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/certificates/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),
  };
  ciArtifacts = {
    /**
     * No description
     *
     * @tags CiArtifacts
     * @name CiArtifactsGetInstance
     * @request GET:/v1/ciArtifacts/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type ciArtifacts */
        "fields[ciArtifacts]"?: ("downloadUrl" | "fileName" | "fileSize" | "fileType")[];
      },
      params: RequestParams = {},
    ): Promise<CiArtifactResponse> =>
      this.request<CiArtifactResponse, ErrorResponse>({
        path: `/v1/ciArtifacts/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  ciBuildActions = {
    /**
     * No description
     *
     * @tags CiBuildActions
     * @name CiBuildActionsGetInstance
     * @request GET:/v1/ciBuildActions/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type ciBuildActions */
        "fields[ciBuildActions]"?: (
          | "actionType"
          | "artifacts"
          | "buildRun"
          | "completionStatus"
          | "executionProgress"
          | "finishedDate"
          | "isRequiredToPass"
          | "issueCounts"
          | "issues"
          | "name"
          | "startedDate"
          | "testResults"
        )[];
        /** comma-separated list of relationships to include */
        include?: "buildRun"[];
        /** the fields to include for returned resources of type ciIssues */
        "fields[ciIssues]"?: ("category" | "fileSource" | "issueType" | "message")[];
        /** the fields to include for returned resources of type ciBuildRuns */
        "fields[ciBuildRuns]"?: (
          | "actions"
          | "buildRun"
          | "builds"
          | "cancelReason"
          | "clean"
          | "completionStatus"
          | "createdDate"
          | "destinationBranch"
          | "destinationCommit"
          | "executionProgress"
          | "finishedDate"
          | "isPullRequestBuild"
          | "issueCounts"
          | "number"
          | "product"
          | "pullRequest"
          | "sourceBranchOrTag"
          | "sourceCommit"
          | "startReason"
          | "startedDate"
          | "workflow"
        )[];
        /** the fields to include for returned resources of type ciTestResults */
        "fields[ciTestResults]"?: (
          | "className"
          | "destinationTestResults"
          | "fileSource"
          | "message"
          | "name"
          | "status"
        )[];
        /** the fields to include for returned resources of type ciArtifacts */
        "fields[ciArtifacts]"?: ("downloadUrl" | "fileName" | "fileSize" | "fileType")[];
      },
      params: RequestParams = {},
    ): Promise<CiBuildActionResponse> =>
      this.request<CiBuildActionResponse, ErrorResponse>({
        path: `/v1/ciBuildActions/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags CiBuildActions
     * @name CiBuildActionsArtifactsGetToManyRelated
     * @request GET:/v1/ciBuildActions/{id}/artifacts
     * @secure
     */
    artifactsGetToManyRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type ciArtifacts */
        "fields[ciArtifacts]"?: ("downloadUrl" | "fileName" | "fileSize" | "fileType")[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
      },
      params: RequestParams = {},
    ): Promise<CiArtifactsResponse> =>
      this.request<CiArtifactsResponse, ErrorResponse>({
        path: `/v1/ciBuildActions/${id}/artifacts`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags CiBuildActions
     * @name CiBuildActionsBuildRunGetToOneRelated
     * @request GET:/v1/ciBuildActions/{id}/buildRun
     * @secure
     */
    buildRunGetToOneRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type scmGitReferences */
        "fields[scmGitReferences]"?: ("canonicalName" | "isDeleted" | "kind" | "name" | "repository")[];
        /** the fields to include for returned resources of type ciBuildRuns */
        "fields[ciBuildRuns]"?: (
          | "actions"
          | "buildRun"
          | "builds"
          | "cancelReason"
          | "clean"
          | "completionStatus"
          | "createdDate"
          | "destinationBranch"
          | "destinationCommit"
          | "executionProgress"
          | "finishedDate"
          | "isPullRequestBuild"
          | "issueCounts"
          | "number"
          | "product"
          | "pullRequest"
          | "sourceBranchOrTag"
          | "sourceCommit"
          | "startReason"
          | "startedDate"
          | "workflow"
        )[];
        /** the fields to include for returned resources of type ciWorkflows */
        "fields[ciWorkflows]"?: (
          | "actions"
          | "branchStartCondition"
          | "buildRuns"
          | "clean"
          | "containerFilePath"
          | "description"
          | "isEnabled"
          | "isLockedForEditing"
          | "lastModifiedDate"
          | "macOsVersion"
          | "manualBranchStartCondition"
          | "manualPullRequestStartCondition"
          | "manualTagStartCondition"
          | "name"
          | "product"
          | "pullRequestStartCondition"
          | "repository"
          | "scheduledStartCondition"
          | "tagStartCondition"
          | "xcodeVersion"
        )[];
        /** the fields to include for returned resources of type scmPullRequests */
        "fields[scmPullRequests]"?: (
          | "destinationBranchName"
          | "destinationRepositoryName"
          | "destinationRepositoryOwner"
          | "isClosed"
          | "isCrossRepository"
          | "number"
          | "repository"
          | "sourceBranchName"
          | "sourceRepositoryName"
          | "sourceRepositoryOwner"
          | "title"
          | "webUrl"
        )[];
        /** the fields to include for returned resources of type ciProducts */
        "fields[ciProducts]"?: (
          | "additionalRepositories"
          | "app"
          | "buildRuns"
          | "bundleId"
          | "createdDate"
          | "name"
          | "primaryRepositories"
          | "productType"
          | "workflows"
        )[];
        /** the fields to include for returned resources of type builds */
        "fields[builds]"?: (
          | "app"
          | "appEncryptionDeclaration"
          | "appStoreVersion"
          | "betaAppReviewSubmission"
          | "betaBuildLocalizations"
          | "betaGroups"
          | "buildAudienceType"
          | "buildBetaDetail"
          | "buildBundles"
          | "computedMinMacOsVersion"
          | "diagnosticSignatures"
          | "expirationDate"
          | "expired"
          | "iconAssetToken"
          | "icons"
          | "individualTesters"
          | "lsMinimumSystemVersion"
          | "minOsVersion"
          | "perfPowerMetrics"
          | "preReleaseVersion"
          | "processingState"
          | "uploadedDate"
          | "usesNonExemptEncryption"
          | "version"
        )[];
        /**
         * maximum number of related builds returned (when they are included)
         * @max 50
         */
        "limit[builds]"?: number;
        /** comma-separated list of relationships to include */
        include?: ("builds" | "destinationBranch" | "product" | "pullRequest" | "sourceBranchOrTag" | "workflow")[];
      },
      params: RequestParams = {},
    ): Promise<CiBuildRunResponse> =>
      this.request<CiBuildRunResponse, ErrorResponse>({
        path: `/v1/ciBuildActions/${id}/buildRun`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags CiBuildActions
     * @name CiBuildActionsIssuesGetToManyRelated
     * @request GET:/v1/ciBuildActions/{id}/issues
     * @secure
     */
    issuesGetToManyRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type ciIssues */
        "fields[ciIssues]"?: ("category" | "fileSource" | "issueType" | "message")[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
      },
      params: RequestParams = {},
    ): Promise<CiIssuesResponse> =>
      this.request<CiIssuesResponse, ErrorResponse>({
        path: `/v1/ciBuildActions/${id}/issues`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags CiBuildActions
     * @name CiBuildActionsTestResultsGetToManyRelated
     * @request GET:/v1/ciBuildActions/{id}/testResults
     * @secure
     */
    testResultsGetToManyRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type ciTestResults */
        "fields[ciTestResults]"?: (
          | "className"
          | "destinationTestResults"
          | "fileSource"
          | "message"
          | "name"
          | "status"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
      },
      params: RequestParams = {},
    ): Promise<CiTestResultsResponse> =>
      this.request<CiTestResultsResponse, ErrorResponse>({
        path: `/v1/ciBuildActions/${id}/testResults`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  ciBuildRuns = {
    /**
     * No description
     *
     * @tags CiBuildRuns
     * @name CiBuildRunsCreateInstance
     * @request POST:/v1/ciBuildRuns
     * @secure
     */
    createInstance: (data: CiBuildRunCreateRequest, params: RequestParams = {}): Promise<CiBuildRunResponse> =>
      this.request<CiBuildRunResponse, ErrorResponse>({
        path: `/v1/ciBuildRuns`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags CiBuildRuns
     * @name CiBuildRunsGetInstance
     * @request GET:/v1/ciBuildRuns/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type ciBuildRuns */
        "fields[ciBuildRuns]"?: (
          | "actions"
          | "buildRun"
          | "builds"
          | "cancelReason"
          | "clean"
          | "completionStatus"
          | "createdDate"
          | "destinationBranch"
          | "destinationCommit"
          | "executionProgress"
          | "finishedDate"
          | "isPullRequestBuild"
          | "issueCounts"
          | "number"
          | "product"
          | "pullRequest"
          | "sourceBranchOrTag"
          | "sourceCommit"
          | "startReason"
          | "startedDate"
          | "workflow"
        )[];
        /** comma-separated list of relationships to include */
        include?: ("builds" | "destinationBranch" | "product" | "pullRequest" | "sourceBranchOrTag" | "workflow")[];
        /** the fields to include for returned resources of type ciBuildActions */
        "fields[ciBuildActions]"?: (
          | "actionType"
          | "artifacts"
          | "buildRun"
          | "completionStatus"
          | "executionProgress"
          | "finishedDate"
          | "isRequiredToPass"
          | "issueCounts"
          | "issues"
          | "name"
          | "startedDate"
          | "testResults"
        )[];
        /** the fields to include for returned resources of type builds */
        "fields[builds]"?: (
          | "app"
          | "appEncryptionDeclaration"
          | "appStoreVersion"
          | "betaAppReviewSubmission"
          | "betaBuildLocalizations"
          | "betaGroups"
          | "buildAudienceType"
          | "buildBetaDetail"
          | "buildBundles"
          | "computedMinMacOsVersion"
          | "diagnosticSignatures"
          | "expirationDate"
          | "expired"
          | "iconAssetToken"
          | "icons"
          | "individualTesters"
          | "lsMinimumSystemVersion"
          | "minOsVersion"
          | "perfPowerMetrics"
          | "preReleaseVersion"
          | "processingState"
          | "uploadedDate"
          | "usesNonExemptEncryption"
          | "version"
        )[];
        /**
         * maximum number of related builds returned (when they are included)
         * @max 50
         */
        "limit[builds]"?: number;
      },
      params: RequestParams = {},
    ): Promise<CiBuildRunResponse> =>
      this.request<CiBuildRunResponse, ErrorResponse>({
        path: `/v1/ciBuildRuns/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags CiBuildRuns
     * @name CiBuildRunsActionsGetToManyRelated
     * @request GET:/v1/ciBuildRuns/{id}/actions
     * @secure
     */
    actionsGetToManyRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type ciBuildRuns */
        "fields[ciBuildRuns]"?: (
          | "actions"
          | "buildRun"
          | "builds"
          | "cancelReason"
          | "clean"
          | "completionStatus"
          | "createdDate"
          | "destinationBranch"
          | "destinationCommit"
          | "executionProgress"
          | "finishedDate"
          | "isPullRequestBuild"
          | "issueCounts"
          | "number"
          | "product"
          | "pullRequest"
          | "sourceBranchOrTag"
          | "sourceCommit"
          | "startReason"
          | "startedDate"
          | "workflow"
        )[];
        /** the fields to include for returned resources of type ciBuildActions */
        "fields[ciBuildActions]"?: (
          | "actionType"
          | "artifacts"
          | "buildRun"
          | "completionStatus"
          | "executionProgress"
          | "finishedDate"
          | "isRequiredToPass"
          | "issueCounts"
          | "issues"
          | "name"
          | "startedDate"
          | "testResults"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /** comma-separated list of relationships to include */
        include?: "buildRun"[];
      },
      params: RequestParams = {},
    ): Promise<CiBuildActionsResponse> =>
      this.request<CiBuildActionsResponse, ErrorResponse>({
        path: `/v1/ciBuildRuns/${id}/actions`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags CiBuildRuns
     * @name CiBuildRunsBuildsGetToManyRelated
     * @request GET:/v1/ciBuildRuns/{id}/builds
     * @secure
     */
    buildsGetToManyRelated: (
      id: string,
      query?: {
        /** filter by attribute 'betaAppReviewSubmission.betaReviewState' */
        filterBetaAppReviewSubmissionBetaReviewState?: ("WAITING_FOR_REVIEW" | "IN_REVIEW" | "REJECTED" | "APPROVED")[];
        /** filter by attribute 'buildAudienceType' */
        "filter[buildAudienceType]"?: ("INTERNAL_ONLY" | "APP_STORE_ELIGIBLE")[];
        /** filter by attribute 'expired' */
        "filter[expired]"?: string[];
        /** filter by attribute 'preReleaseVersion.platform' */
        filterPreReleaseVersionPlatform?: ("IOS" | "MAC_OS" | "TV_OS" | "VISION_OS")[];
        /** filter by attribute 'preReleaseVersion.version' */
        filterPreReleaseVersionVersion?: string[];
        /** filter by attribute 'processingState' */
        "filter[processingState]"?: ("PROCESSING" | "FAILED" | "INVALID" | "VALID")[];
        /** filter by attribute 'usesNonExemptEncryption' */
        "filter[usesNonExemptEncryption]"?: string[];
        /** filter by attribute 'version' */
        "filter[version]"?: string[];
        /** filter by id(s) of related 'app' */
        "filter[app]"?: string[];
        /** filter by id(s) of related 'appStoreVersion' */
        "filter[appStoreVersion]"?: string[];
        /** filter by id(s) of related 'betaGroups' */
        "filter[betaGroups]"?: string[];
        /** filter by id(s) of related 'preReleaseVersion' */
        "filter[preReleaseVersion]"?: string[];
        /** filter by id(s) */
        "filter[id]"?: string[];
        /** comma-separated list of sort expressions; resources will be sorted as specified */
        sort?: (
          | "preReleaseVersion"
          | "-preReleaseVersion"
          | "uploadedDate"
          | "-uploadedDate"
          | "version"
          | "-version"
        )[];
        /** the fields to include for returned resources of type buildBundles */
        "fields[buildBundles]"?: (
          | "appClipDomainCacheStatus"
          | "appClipDomainDebugStatus"
          | "betaAppClipInvocations"
          | "buildBundleFileSizes"
          | "bundleId"
          | "bundleType"
          | "dSYMUrl"
          | "deviceProtocols"
          | "entitlements"
          | "fileName"
          | "hasOnDemandResources"
          | "hasPrerenderedIcon"
          | "hasSirikit"
          | "includesSymbols"
          | "isIosBuildMacAppStoreCompatible"
          | "locales"
          | "platformBuild"
          | "requiredCapabilities"
          | "sdkBuild"
          | "supportedArchitectures"
          | "usesLocationServices"
        )[];
        /** the fields to include for returned resources of type buildIcons */
        "fields[buildIcons]"?: ("iconAsset" | "iconType" | "name")[];
        /** the fields to include for returned resources of type betaAppReviewSubmissions */
        "fields[betaAppReviewSubmissions]"?: ("betaReviewState" | "build" | "submittedDate")[];
        /** the fields to include for returned resources of type buildBetaDetails */
        "fields[buildBetaDetails]"?: ("autoNotifyEnabled" | "build" | "externalBuildState" | "internalBuildState")[];
        /** the fields to include for returned resources of type betaTesters */
        "fields[betaTesters]"?: (
          | "apps"
          | "betaGroups"
          | "builds"
          | "email"
          | "firstName"
          | "inviteType"
          | "lastName"
        )[];
        /** the fields to include for returned resources of type preReleaseVersions */
        "fields[preReleaseVersions]"?: ("app" | "builds" | "platform" | "version")[];
        /** the fields to include for returned resources of type betaBuildLocalizations */
        "fields[betaBuildLocalizations]"?: ("build" | "locale" | "whatsNew")[];
        /** the fields to include for returned resources of type appStoreVersions */
        "fields[appStoreVersions]"?: (
          | "ageRatingDeclaration"
          | "alternativeDistributionPackage"
          | "app"
          | "appClipDefaultExperience"
          | "appStoreReviewDetail"
          | "appStoreState"
          | "appStoreVersionExperiments"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersionLocalizations"
          | "appStoreVersionPhasedRelease"
          | "appStoreVersionSubmission"
          | "appVersionState"
          | "build"
          | "copyright"
          | "createdDate"
          | "customerReviews"
          | "downloadable"
          | "earliestReleaseDate"
          | "platform"
          | "releaseType"
          | "reviewType"
          | "routingAppCoverage"
          | "versionString"
        )[];
        /** the fields to include for returned resources of type appEncryptionDeclarations */
        "fields[appEncryptionDeclarations]"?: (
          | "app"
          | "appDescription"
          | "appEncryptionDeclarationDocument"
          | "appEncryptionDeclarationState"
          | "availableOnFrenchStore"
          | "builds"
          | "codeValue"
          | "containsProprietaryCryptography"
          | "containsThirdPartyCryptography"
          | "createdDate"
          | "documentName"
          | "documentType"
          | "documentUrl"
          | "exempt"
          | "platform"
          | "uploadedDate"
          | "usesEncryption"
        )[];
        /** the fields to include for returned resources of type apps */
        "fields[apps]"?: (
          | "alternativeDistributionKey"
          | "analyticsReportRequests"
          | "appAvailability"
          | "appClips"
          | "appCustomProductPages"
          | "appEncryptionDeclarations"
          | "appEvents"
          | "appInfos"
          | "appPricePoints"
          | "appPriceSchedule"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersions"
          | "availableInNewTerritories"
          | "availableTerritories"
          | "betaAppLocalizations"
          | "betaAppReviewDetail"
          | "betaGroups"
          | "betaLicenseAgreement"
          | "betaTesters"
          | "builds"
          | "bundleId"
          | "ciProduct"
          | "contentRightsDeclaration"
          | "customerReviews"
          | "endUserLicenseAgreement"
          | "gameCenterDetail"
          | "gameCenterEnabledVersions"
          | "inAppPurchases"
          | "inAppPurchasesV2"
          | "isOrEverWasMadeForKids"
          | "marketplaceSearchDetail"
          | "name"
          | "perfPowerMetrics"
          | "preOrder"
          | "preReleaseVersions"
          | "pricePoints"
          | "prices"
          | "primaryLocale"
          | "promotedPurchases"
          | "reviewSubmissions"
          | "sku"
          | "subscriptionGracePeriod"
          | "subscriptionGroups"
          | "subscriptionStatusUrl"
          | "subscriptionStatusUrlForSandbox"
          | "subscriptionStatusUrlVersion"
          | "subscriptionStatusUrlVersionForSandbox"
        )[];
        /** the fields to include for returned resources of type builds */
        "fields[builds]"?: (
          | "app"
          | "appEncryptionDeclaration"
          | "appStoreVersion"
          | "betaAppReviewSubmission"
          | "betaBuildLocalizations"
          | "betaGroups"
          | "buildAudienceType"
          | "buildBetaDetail"
          | "buildBundles"
          | "computedMinMacOsVersion"
          | "diagnosticSignatures"
          | "expirationDate"
          | "expired"
          | "iconAssetToken"
          | "icons"
          | "individualTesters"
          | "lsMinimumSystemVersion"
          | "minOsVersion"
          | "perfPowerMetrics"
          | "preReleaseVersion"
          | "processingState"
          | "uploadedDate"
          | "usesNonExemptEncryption"
          | "version"
        )[];
        /** the fields to include for returned resources of type betaGroups */
        "fields[betaGroups]"?: (
          | "app"
          | "betaTesters"
          | "builds"
          | "createdDate"
          | "feedbackEnabled"
          | "hasAccessToAllBuilds"
          | "iosBuildsAvailableForAppleSiliconMac"
          | "isInternalGroup"
          | "name"
          | "publicLink"
          | "publicLinkEnabled"
          | "publicLinkId"
          | "publicLinkLimit"
          | "publicLinkLimitEnabled"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /**
         * maximum number of related individualTesters returned (when they are included)
         * @max 50
         */
        "limit[individualTesters]"?: number;
        /**
         * maximum number of related betaGroups returned (when they are included)
         * @max 50
         */
        "limit[betaGroups]"?: number;
        /**
         * maximum number of related betaBuildLocalizations returned (when they are included)
         * @max 50
         */
        "limit[betaBuildLocalizations]"?: number;
        /**
         * maximum number of related icons returned (when they are included)
         * @max 50
         */
        "limit[icons]"?: number;
        /**
         * maximum number of related buildBundles returned (when they are included)
         * @max 50
         */
        "limit[buildBundles]"?: number;
        /** comma-separated list of relationships to include */
        include?: (
          | "app"
          | "appEncryptionDeclaration"
          | "appStoreVersion"
          | "betaAppReviewSubmission"
          | "betaBuildLocalizations"
          | "betaGroups"
          | "buildBetaDetail"
          | "buildBundles"
          | "icons"
          | "individualTesters"
          | "preReleaseVersion"
        )[];
      },
      params: RequestParams = {},
    ): Promise<BuildsResponse> =>
      this.request<BuildsResponse, ErrorResponse>({
        path: `/v1/ciBuildRuns/${id}/builds`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  ciIssues = {
    /**
     * No description
     *
     * @tags CiIssues
     * @name CiIssuesGetInstance
     * @request GET:/v1/ciIssues/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type ciIssues */
        "fields[ciIssues]"?: ("category" | "fileSource" | "issueType" | "message")[];
      },
      params: RequestParams = {},
    ): Promise<CiIssueResponse> =>
      this.request<CiIssueResponse, ErrorResponse>({
        path: `/v1/ciIssues/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  ciMacOsVersions = {
    /**
     * No description
     *
     * @tags CiMacOsVersions
     * @name CiMacOsVersionsGetCollection
     * @request GET:/v1/ciMacOsVersions
     * @secure
     */
    getCollection: (
      query?: {
        /** the fields to include for returned resources of type ciMacOsVersions */
        "fields[ciMacOsVersions]"?: ("name" | "version" | "xcodeVersions")[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /** comma-separated list of relationships to include */
        include?: "xcodeVersions"[];
        /** the fields to include for returned resources of type ciXcodeVersions */
        "fields[ciXcodeVersions]"?: ("macOsVersions" | "name" | "testDestinations" | "version")[];
        /**
         * maximum number of related xcodeVersions returned (when they are included)
         * @max 50
         */
        "limit[xcodeVersions]"?: number;
      },
      params: RequestParams = {},
    ): Promise<CiMacOsVersionsResponse> =>
      this.request<CiMacOsVersionsResponse, ErrorResponse>({
        path: `/v1/ciMacOsVersions`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags CiMacOsVersions
     * @name CiMacOsVersionsGetInstance
     * @request GET:/v1/ciMacOsVersions/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type ciMacOsVersions */
        "fields[ciMacOsVersions]"?: ("name" | "version" | "xcodeVersions")[];
        /** comma-separated list of relationships to include */
        include?: "xcodeVersions"[];
        /** the fields to include for returned resources of type ciXcodeVersions */
        "fields[ciXcodeVersions]"?: ("macOsVersions" | "name" | "testDestinations" | "version")[];
        /**
         * maximum number of related xcodeVersions returned (when they are included)
         * @max 50
         */
        "limit[xcodeVersions]"?: number;
      },
      params: RequestParams = {},
    ): Promise<CiMacOsVersionResponse> =>
      this.request<CiMacOsVersionResponse, ErrorResponse>({
        path: `/v1/ciMacOsVersions/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags CiMacOsVersions
     * @name CiMacOsVersionsXcodeVersionsGetToManyRelated
     * @request GET:/v1/ciMacOsVersions/{id}/xcodeVersions
     * @secure
     */
    xcodeVersionsGetToManyRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type ciXcodeVersions */
        "fields[ciXcodeVersions]"?: ("macOsVersions" | "name" | "testDestinations" | "version")[];
        /** the fields to include for returned resources of type ciMacOsVersions */
        "fields[ciMacOsVersions]"?: ("name" | "version" | "xcodeVersions")[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /**
         * maximum number of related macOsVersions returned (when they are included)
         * @max 50
         */
        "limit[macOsVersions]"?: number;
        /** comma-separated list of relationships to include */
        include?: "macOsVersions"[];
      },
      params: RequestParams = {},
    ): Promise<CiXcodeVersionsResponse> =>
      this.request<CiXcodeVersionsResponse, ErrorResponse>({
        path: `/v1/ciMacOsVersions/${id}/xcodeVersions`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  ciProducts = {
    /**
     * No description
     *
     * @tags CiProducts
     * @name CiProductsGetCollection
     * @request GET:/v1/ciProducts
     * @secure
     */
    getCollection: (
      query?: {
        /** filter by attribute 'productType' */
        "filter[productType]"?: ("APP" | "FRAMEWORK")[];
        /** filter by id(s) of related 'app' */
        "filter[app]"?: string[];
        /** the fields to include for returned resources of type ciProducts */
        "fields[ciProducts]"?: (
          | "additionalRepositories"
          | "app"
          | "buildRuns"
          | "bundleId"
          | "createdDate"
          | "name"
          | "primaryRepositories"
          | "productType"
          | "workflows"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /** comma-separated list of relationships to include */
        include?: ("app" | "bundleId" | "primaryRepositories")[];
        /** the fields to include for returned resources of type ciBuildRuns */
        "fields[ciBuildRuns]"?: (
          | "actions"
          | "buildRun"
          | "builds"
          | "cancelReason"
          | "clean"
          | "completionStatus"
          | "createdDate"
          | "destinationBranch"
          | "destinationCommit"
          | "executionProgress"
          | "finishedDate"
          | "isPullRequestBuild"
          | "issueCounts"
          | "number"
          | "product"
          | "pullRequest"
          | "sourceBranchOrTag"
          | "sourceCommit"
          | "startReason"
          | "startedDate"
          | "workflow"
        )[];
        /** the fields to include for returned resources of type ciWorkflows */
        "fields[ciWorkflows]"?: (
          | "actions"
          | "branchStartCondition"
          | "buildRuns"
          | "clean"
          | "containerFilePath"
          | "description"
          | "isEnabled"
          | "isLockedForEditing"
          | "lastModifiedDate"
          | "macOsVersion"
          | "manualBranchStartCondition"
          | "manualPullRequestStartCondition"
          | "manualTagStartCondition"
          | "name"
          | "product"
          | "pullRequestStartCondition"
          | "repository"
          | "scheduledStartCondition"
          | "tagStartCondition"
          | "xcodeVersion"
        )[];
        /** the fields to include for returned resources of type apps */
        "fields[apps]"?: (
          | "alternativeDistributionKey"
          | "analyticsReportRequests"
          | "appAvailability"
          | "appClips"
          | "appCustomProductPages"
          | "appEncryptionDeclarations"
          | "appEvents"
          | "appInfos"
          | "appPricePoints"
          | "appPriceSchedule"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersions"
          | "availableInNewTerritories"
          | "availableTerritories"
          | "betaAppLocalizations"
          | "betaAppReviewDetail"
          | "betaGroups"
          | "betaLicenseAgreement"
          | "betaTesters"
          | "builds"
          | "bundleId"
          | "ciProduct"
          | "contentRightsDeclaration"
          | "customerReviews"
          | "endUserLicenseAgreement"
          | "gameCenterDetail"
          | "gameCenterEnabledVersions"
          | "inAppPurchases"
          | "inAppPurchasesV2"
          | "isOrEverWasMadeForKids"
          | "marketplaceSearchDetail"
          | "name"
          | "perfPowerMetrics"
          | "preOrder"
          | "preReleaseVersions"
          | "pricePoints"
          | "prices"
          | "primaryLocale"
          | "promotedPurchases"
          | "reviewSubmissions"
          | "sku"
          | "subscriptionGracePeriod"
          | "subscriptionGroups"
          | "subscriptionStatusUrl"
          | "subscriptionStatusUrlForSandbox"
          | "subscriptionStatusUrlVersion"
          | "subscriptionStatusUrlVersionForSandbox"
        )[];
        /** the fields to include for returned resources of type scmRepositories */
        "fields[scmRepositories]"?: (
          | "defaultBranch"
          | "gitReferences"
          | "httpCloneUrl"
          | "lastAccessedDate"
          | "ownerName"
          | "pullRequests"
          | "repositoryName"
          | "scmProvider"
          | "sshCloneUrl"
        )[];
        /**
         * maximum number of related primaryRepositories returned (when they are included)
         * @max 50
         */
        "limit[primaryRepositories]"?: number;
      },
      params: RequestParams = {},
    ): Promise<CiProductsResponse> =>
      this.request<CiProductsResponse, ErrorResponse>({
        path: `/v1/ciProducts`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags CiProducts
     * @name CiProductsGetInstance
     * @request GET:/v1/ciProducts/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type ciProducts */
        "fields[ciProducts]"?: (
          | "additionalRepositories"
          | "app"
          | "buildRuns"
          | "bundleId"
          | "createdDate"
          | "name"
          | "primaryRepositories"
          | "productType"
          | "workflows"
        )[];
        /** comma-separated list of relationships to include */
        include?: ("app" | "bundleId" | "primaryRepositories")[];
        /** the fields to include for returned resources of type ciBuildRuns */
        "fields[ciBuildRuns]"?: (
          | "actions"
          | "buildRun"
          | "builds"
          | "cancelReason"
          | "clean"
          | "completionStatus"
          | "createdDate"
          | "destinationBranch"
          | "destinationCommit"
          | "executionProgress"
          | "finishedDate"
          | "isPullRequestBuild"
          | "issueCounts"
          | "number"
          | "product"
          | "pullRequest"
          | "sourceBranchOrTag"
          | "sourceCommit"
          | "startReason"
          | "startedDate"
          | "workflow"
        )[];
        /** the fields to include for returned resources of type ciWorkflows */
        "fields[ciWorkflows]"?: (
          | "actions"
          | "branchStartCondition"
          | "buildRuns"
          | "clean"
          | "containerFilePath"
          | "description"
          | "isEnabled"
          | "isLockedForEditing"
          | "lastModifiedDate"
          | "macOsVersion"
          | "manualBranchStartCondition"
          | "manualPullRequestStartCondition"
          | "manualTagStartCondition"
          | "name"
          | "product"
          | "pullRequestStartCondition"
          | "repository"
          | "scheduledStartCondition"
          | "tagStartCondition"
          | "xcodeVersion"
        )[];
        /** the fields to include for returned resources of type apps */
        "fields[apps]"?: (
          | "alternativeDistributionKey"
          | "analyticsReportRequests"
          | "appAvailability"
          | "appClips"
          | "appCustomProductPages"
          | "appEncryptionDeclarations"
          | "appEvents"
          | "appInfos"
          | "appPricePoints"
          | "appPriceSchedule"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersions"
          | "availableInNewTerritories"
          | "availableTerritories"
          | "betaAppLocalizations"
          | "betaAppReviewDetail"
          | "betaGroups"
          | "betaLicenseAgreement"
          | "betaTesters"
          | "builds"
          | "bundleId"
          | "ciProduct"
          | "contentRightsDeclaration"
          | "customerReviews"
          | "endUserLicenseAgreement"
          | "gameCenterDetail"
          | "gameCenterEnabledVersions"
          | "inAppPurchases"
          | "inAppPurchasesV2"
          | "isOrEverWasMadeForKids"
          | "marketplaceSearchDetail"
          | "name"
          | "perfPowerMetrics"
          | "preOrder"
          | "preReleaseVersions"
          | "pricePoints"
          | "prices"
          | "primaryLocale"
          | "promotedPurchases"
          | "reviewSubmissions"
          | "sku"
          | "subscriptionGracePeriod"
          | "subscriptionGroups"
          | "subscriptionStatusUrl"
          | "subscriptionStatusUrlForSandbox"
          | "subscriptionStatusUrlVersion"
          | "subscriptionStatusUrlVersionForSandbox"
        )[];
        /** the fields to include for returned resources of type scmRepositories */
        "fields[scmRepositories]"?: (
          | "defaultBranch"
          | "gitReferences"
          | "httpCloneUrl"
          | "lastAccessedDate"
          | "ownerName"
          | "pullRequests"
          | "repositoryName"
          | "scmProvider"
          | "sshCloneUrl"
        )[];
        /**
         * maximum number of related primaryRepositories returned (when they are included)
         * @max 50
         */
        "limit[primaryRepositories]"?: number;
      },
      params: RequestParams = {},
    ): Promise<CiProductResponse> =>
      this.request<CiProductResponse, ErrorResponse>({
        path: `/v1/ciProducts/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags CiProducts
     * @name CiProductsDeleteInstance
     * @request DELETE:/v1/ciProducts/{id}
     * @secure
     */
    deleteInstance: (id: string, params: RequestParams = {}): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/ciProducts/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),

    /**
     * No description
     *
     * @tags CiProducts
     * @name CiProductsAdditionalRepositoriesGetToManyRelated
     * @request GET:/v1/ciProducts/{id}/additionalRepositories
     * @secure
     */
    additionalRepositoriesGetToManyRelated: (
      id: string,
      query?: {
        /** filter by id(s) */
        "filter[id]"?: string[];
        /** the fields to include for returned resources of type scmGitReferences */
        "fields[scmGitReferences]"?: ("canonicalName" | "isDeleted" | "kind" | "name" | "repository")[];
        /** the fields to include for returned resources of type scmProviders */
        "fields[scmProviders]"?: ("repositories" | "scmProviderType" | "url")[];
        /** the fields to include for returned resources of type scmRepositories */
        "fields[scmRepositories]"?: (
          | "defaultBranch"
          | "gitReferences"
          | "httpCloneUrl"
          | "lastAccessedDate"
          | "ownerName"
          | "pullRequests"
          | "repositoryName"
          | "scmProvider"
          | "sshCloneUrl"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /** comma-separated list of relationships to include */
        include?: ("defaultBranch" | "scmProvider")[];
      },
      params: RequestParams = {},
    ): Promise<ScmRepositoriesResponse> =>
      this.request<ScmRepositoriesResponse, ErrorResponse>({
        path: `/v1/ciProducts/${id}/additionalRepositories`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags CiProducts
     * @name CiProductsAppGetToOneRelated
     * @request GET:/v1/ciProducts/{id}/app
     * @secure
     */
    appGetToOneRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type betaAppReviewDetails */
        "fields[betaAppReviewDetails]"?: (
          | "app"
          | "contactEmail"
          | "contactFirstName"
          | "contactLastName"
          | "contactPhone"
          | "demoAccountName"
          | "demoAccountPassword"
          | "demoAccountRequired"
          | "notes"
        )[];
        /** the fields to include for returned resources of type gameCenterDetails */
        "fields[gameCenterDetails]"?: (
          | "achievementReleases"
          | "app"
          | "arcadeEnabled"
          | "challengeEnabled"
          | "defaultGroupLeaderboard"
          | "defaultLeaderboard"
          | "gameCenterAchievements"
          | "gameCenterAppVersions"
          | "gameCenterGroup"
          | "gameCenterLeaderboardSets"
          | "gameCenterLeaderboards"
          | "leaderboardReleases"
          | "leaderboardSetReleases"
        )[];
        /** the fields to include for returned resources of type ciProducts */
        "fields[ciProducts]"?: (
          | "additionalRepositories"
          | "app"
          | "buildRuns"
          | "bundleId"
          | "createdDate"
          | "name"
          | "primaryRepositories"
          | "productType"
          | "workflows"
        )[];
        /** the fields to include for returned resources of type reviewSubmissions */
        "fields[reviewSubmissions]"?: (
          | "app"
          | "appStoreVersionForReview"
          | "canceled"
          | "items"
          | "lastUpdatedByActor"
          | "platform"
          | "state"
          | "submitted"
          | "submittedByActor"
          | "submittedDate"
        )[];
        /** the fields to include for returned resources of type betaGroups */
        "fields[betaGroups]"?: (
          | "app"
          | "betaTesters"
          | "builds"
          | "createdDate"
          | "feedbackEnabled"
          | "hasAccessToAllBuilds"
          | "iosBuildsAvailableForAppleSiliconMac"
          | "isInternalGroup"
          | "name"
          | "publicLink"
          | "publicLinkEnabled"
          | "publicLinkId"
          | "publicLinkLimit"
          | "publicLinkLimitEnabled"
        )[];
        /** the fields to include for returned resources of type promotedPurchases */
        "fields[promotedPurchases]"?: (
          | "app"
          | "enabled"
          | "inAppPurchaseV2"
          | "promotionImages"
          | "state"
          | "subscription"
          | "visibleForAllUsers"
        )[];
        /** the fields to include for returned resources of type apps */
        "fields[apps]"?: (
          | "alternativeDistributionKey"
          | "analyticsReportRequests"
          | "appAvailability"
          | "appClips"
          | "appCustomProductPages"
          | "appEncryptionDeclarations"
          | "appEvents"
          | "appInfos"
          | "appPricePoints"
          | "appPriceSchedule"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersions"
          | "availableInNewTerritories"
          | "availableTerritories"
          | "betaAppLocalizations"
          | "betaAppReviewDetail"
          | "betaGroups"
          | "betaLicenseAgreement"
          | "betaTesters"
          | "builds"
          | "bundleId"
          | "ciProduct"
          | "contentRightsDeclaration"
          | "customerReviews"
          | "endUserLicenseAgreement"
          | "gameCenterDetail"
          | "gameCenterEnabledVersions"
          | "inAppPurchases"
          | "inAppPurchasesV2"
          | "isOrEverWasMadeForKids"
          | "marketplaceSearchDetail"
          | "name"
          | "perfPowerMetrics"
          | "preOrder"
          | "preReleaseVersions"
          | "pricePoints"
          | "prices"
          | "primaryLocale"
          | "promotedPurchases"
          | "reviewSubmissions"
          | "sku"
          | "subscriptionGracePeriod"
          | "subscriptionGroups"
          | "subscriptionStatusUrl"
          | "subscriptionStatusUrlForSandbox"
          | "subscriptionStatusUrlVersion"
          | "subscriptionStatusUrlVersionForSandbox"
        )[];
        /** the fields to include for returned resources of type appEvents */
        "fields[appEvents]"?: (
          | "app"
          | "archivedTerritorySchedules"
          | "badge"
          | "deepLink"
          | "eventState"
          | "localizations"
          | "primaryLocale"
          | "priority"
          | "purchaseRequirement"
          | "purpose"
          | "referenceName"
          | "territorySchedules"
        )[];
        /** the fields to include for returned resources of type builds */
        "fields[builds]"?: (
          | "app"
          | "appEncryptionDeclaration"
          | "appStoreVersion"
          | "betaAppReviewSubmission"
          | "betaBuildLocalizations"
          | "betaGroups"
          | "buildAudienceType"
          | "buildBetaDetail"
          | "buildBundles"
          | "computedMinMacOsVersion"
          | "diagnosticSignatures"
          | "expirationDate"
          | "expired"
          | "iconAssetToken"
          | "icons"
          | "individualTesters"
          | "lsMinimumSystemVersion"
          | "minOsVersion"
          | "perfPowerMetrics"
          | "preReleaseVersion"
          | "processingState"
          | "uploadedDate"
          | "usesNonExemptEncryption"
          | "version"
        )[];
        /** the fields to include for returned resources of type betaLicenseAgreements */
        "fields[betaLicenseAgreements]"?: ("agreementText" | "app")[];
        /** the fields to include for returned resources of type appClips */
        "fields[appClips]"?: ("app" | "appClipAdvancedExperiences" | "appClipDefaultExperiences" | "bundleId")[];
        /** the fields to include for returned resources of type betaAppLocalizations */
        "fields[betaAppLocalizations]"?: (
          | "app"
          | "description"
          | "feedbackEmail"
          | "locale"
          | "marketingUrl"
          | "privacyPolicyUrl"
          | "tvOsPrivacyPolicy"
        )[];
        /** the fields to include for returned resources of type appInfos */
        "fields[appInfos]"?: (
          | "ageRatingDeclaration"
          | "app"
          | "appInfoLocalizations"
          | "appStoreAgeRating"
          | "appStoreState"
          | "brazilAgeRating"
          | "brazilAgeRatingV2"
          | "kidsAgeBand"
          | "primaryCategory"
          | "primarySubcategoryOne"
          | "primarySubcategoryTwo"
          | "secondaryCategory"
          | "secondarySubcategoryOne"
          | "secondarySubcategoryTwo"
          | "state"
        )[];
        /** the fields to include for returned resources of type preReleaseVersions */
        "fields[preReleaseVersions]"?: ("app" | "builds" | "platform" | "version")[];
        /** the fields to include for returned resources of type inAppPurchases */
        "fields[inAppPurchases]"?: (
          | "app"
          | "appStoreReviewScreenshot"
          | "apps"
          | "content"
          | "contentHosting"
          | "familySharable"
          | "iapPriceSchedule"
          | "inAppPurchaseAvailability"
          | "inAppPurchaseLocalizations"
          | "inAppPurchaseType"
          | "name"
          | "pricePoints"
          | "productId"
          | "promotedPurchase"
          | "referenceName"
          | "reviewNote"
          | "state"
        )[];
        /** the fields to include for returned resources of type subscriptionGroups */
        "fields[subscriptionGroups]"?: ("app" | "referenceName" | "subscriptionGroupLocalizations" | "subscriptions")[];
        /** the fields to include for returned resources of type appPreOrders */
        "fields[appPreOrders]"?: ("app" | "appReleaseDate" | "preOrderAvailableDate")[];
        /** the fields to include for returned resources of type appPrices */
        "fields[appPrices]"?: ("app" | "priceTier")[];
        /** the fields to include for returned resources of type gameCenterEnabledVersions */
        "fields[gameCenterEnabledVersions]"?: (
          | "app"
          | "compatibleVersions"
          | "iconAsset"
          | "platform"
          | "versionString"
        )[];
        /** the fields to include for returned resources of type appStoreVersionExperiments */
        "fields[appStoreVersionExperiments]"?: (
          | "app"
          | "appStoreVersionExperimentTreatments"
          | "controlVersions"
          | "endDate"
          | "latestControlVersion"
          | "name"
          | "platform"
          | "reviewRequired"
          | "startDate"
          | "started"
          | "state"
          | "trafficProportion"
        )[];
        /** the fields to include for returned resources of type subscriptionGracePeriods */
        "fields[subscriptionGracePeriods]"?: ("duration" | "optIn" | "renewalType" | "sandboxOptIn")[];
        /** the fields to include for returned resources of type endUserLicenseAgreements */
        "fields[endUserLicenseAgreements]"?: ("agreementText" | "app" | "territories")[];
        /** the fields to include for returned resources of type appStoreVersions */
        "fields[appStoreVersions]"?: (
          | "ageRatingDeclaration"
          | "alternativeDistributionPackage"
          | "app"
          | "appClipDefaultExperience"
          | "appStoreReviewDetail"
          | "appStoreState"
          | "appStoreVersionExperiments"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersionLocalizations"
          | "appStoreVersionPhasedRelease"
          | "appStoreVersionSubmission"
          | "appVersionState"
          | "build"
          | "copyright"
          | "createdDate"
          | "customerReviews"
          | "downloadable"
          | "earliestReleaseDate"
          | "platform"
          | "releaseType"
          | "reviewType"
          | "routingAppCoverage"
          | "versionString"
        )[];
        /** the fields to include for returned resources of type appEncryptionDeclarations */
        "fields[appEncryptionDeclarations]"?: (
          | "app"
          | "appDescription"
          | "appEncryptionDeclarationDocument"
          | "appEncryptionDeclarationState"
          | "availableOnFrenchStore"
          | "builds"
          | "codeValue"
          | "containsProprietaryCryptography"
          | "containsThirdPartyCryptography"
          | "createdDate"
          | "documentName"
          | "documentType"
          | "documentUrl"
          | "exempt"
          | "platform"
          | "uploadedDate"
          | "usesEncryption"
        )[];
        /** the fields to include for returned resources of type appCustomProductPages */
        "fields[appCustomProductPages]"?: (
          | "app"
          | "appCustomProductPageVersions"
          | "appStoreVersionTemplate"
          | "customProductPageTemplate"
          | "name"
          | "url"
          | "visible"
        )[];
        /** the fields to include for returned resources of type territories */
        "fields[territories]"?: "currency"[];
        /**
         * maximum number of related appEncryptionDeclarations returned (when they are included)
         * @max 50
         */
        "limit[appEncryptionDeclarations]"?: number;
        /**
         * maximum number of related betaGroups returned (when they are included)
         * @max 50
         */
        "limit[betaGroups]"?: number;
        /**
         * maximum number of related appStoreVersions returned (when they are included)
         * @max 50
         */
        "limit[appStoreVersions]"?: number;
        /**
         * maximum number of related preReleaseVersions returned (when they are included)
         * @max 50
         */
        "limit[preReleaseVersions]"?: number;
        /**
         * maximum number of related betaAppLocalizations returned (when they are included)
         * @max 50
         */
        "limit[betaAppLocalizations]"?: number;
        /**
         * maximum number of related builds returned (when they are included)
         * @max 50
         */
        "limit[builds]"?: number;
        /**
         * maximum number of related appInfos returned (when they are included)
         * @max 50
         */
        "limit[appInfos]"?: number;
        /**
         * maximum number of related appClips returned (when they are included)
         * @max 50
         */
        "limit[appClips]"?: number;
        /**
         * maximum number of related prices returned (when they are included)
         * @deprecated
         * @max 50
         */
        "limit[prices]"?: number;
        /**
         * maximum number of related availableTerritories returned (when they are included)
         * @max 50
         */
        "limit[availableTerritories]"?: number;
        /**
         * maximum number of related inAppPurchases returned (when they are included)
         * @deprecated
         * @max 50
         */
        "limit[inAppPurchases]"?: number;
        /**
         * maximum number of related subscriptionGroups returned (when they are included)
         * @max 50
         */
        "limit[subscriptionGroups]"?: number;
        /**
         * maximum number of related gameCenterEnabledVersions returned (when they are included)
         * @deprecated
         * @max 50
         */
        "limit[gameCenterEnabledVersions]"?: number;
        /**
         * maximum number of related appCustomProductPages returned (when they are included)
         * @max 50
         */
        "limit[appCustomProductPages]"?: number;
        /**
         * maximum number of related inAppPurchasesV2 returned (when they are included)
         * @max 50
         */
        "limit[inAppPurchasesV2]"?: number;
        /**
         * maximum number of related promotedPurchases returned (when they are included)
         * @max 50
         */
        "limit[promotedPurchases]"?: number;
        /**
         * maximum number of related appEvents returned (when they are included)
         * @max 50
         */
        "limit[appEvents]"?: number;
        /**
         * maximum number of related reviewSubmissions returned (when they are included)
         * @max 50
         */
        "limit[reviewSubmissions]"?: number;
        /**
         * maximum number of related appStoreVersionExperimentsV2 returned (when they are included)
         * @max 50
         */
        "limit[appStoreVersionExperimentsV2]"?: number;
        /** comma-separated list of relationships to include */
        include?: (
          | "appClips"
          | "appCustomProductPages"
          | "appEncryptionDeclarations"
          | "appEvents"
          | "appInfos"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersions"
          | "availableTerritories"
          | "betaAppLocalizations"
          | "betaAppReviewDetail"
          | "betaGroups"
          | "betaLicenseAgreement"
          | "builds"
          | "ciProduct"
          | "endUserLicenseAgreement"
          | "gameCenterDetail"
          | "gameCenterEnabledVersions"
          | "inAppPurchases"
          | "inAppPurchasesV2"
          | "preOrder"
          | "preReleaseVersions"
          | "prices"
          | "promotedPurchases"
          | "reviewSubmissions"
          | "subscriptionGracePeriod"
          | "subscriptionGroups"
        )[];
      },
      params: RequestParams = {},
    ): Promise<AppResponse> =>
      this.request<AppResponse, ErrorResponse>({
        path: `/v1/ciProducts/${id}/app`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags CiProducts
     * @name CiProductsBuildRunsGetToManyRelated
     * @request GET:/v1/ciProducts/{id}/buildRuns
     * @secure
     */
    buildRunsGetToManyRelated: (
      id: string,
      query?: {
        /** filter by id(s) of related 'builds' */
        "filter[builds]"?: string[];
        /** comma-separated list of sort expressions; resources will be sorted as specified */
        sort?: ("number" | "-number")[];
        /** the fields to include for returned resources of type scmGitReferences */
        "fields[scmGitReferences]"?: ("canonicalName" | "isDeleted" | "kind" | "name" | "repository")[];
        /** the fields to include for returned resources of type ciBuildRuns */
        "fields[ciBuildRuns]"?: (
          | "actions"
          | "buildRun"
          | "builds"
          | "cancelReason"
          | "clean"
          | "completionStatus"
          | "createdDate"
          | "destinationBranch"
          | "destinationCommit"
          | "executionProgress"
          | "finishedDate"
          | "isPullRequestBuild"
          | "issueCounts"
          | "number"
          | "product"
          | "pullRequest"
          | "sourceBranchOrTag"
          | "sourceCommit"
          | "startReason"
          | "startedDate"
          | "workflow"
        )[];
        /** the fields to include for returned resources of type ciWorkflows */
        "fields[ciWorkflows]"?: (
          | "actions"
          | "branchStartCondition"
          | "buildRuns"
          | "clean"
          | "containerFilePath"
          | "description"
          | "isEnabled"
          | "isLockedForEditing"
          | "lastModifiedDate"
          | "macOsVersion"
          | "manualBranchStartCondition"
          | "manualPullRequestStartCondition"
          | "manualTagStartCondition"
          | "name"
          | "product"
          | "pullRequestStartCondition"
          | "repository"
          | "scheduledStartCondition"
          | "tagStartCondition"
          | "xcodeVersion"
        )[];
        /** the fields to include for returned resources of type scmPullRequests */
        "fields[scmPullRequests]"?: (
          | "destinationBranchName"
          | "destinationRepositoryName"
          | "destinationRepositoryOwner"
          | "isClosed"
          | "isCrossRepository"
          | "number"
          | "repository"
          | "sourceBranchName"
          | "sourceRepositoryName"
          | "sourceRepositoryOwner"
          | "title"
          | "webUrl"
        )[];
        /** the fields to include for returned resources of type ciProducts */
        "fields[ciProducts]"?: (
          | "additionalRepositories"
          | "app"
          | "buildRuns"
          | "bundleId"
          | "createdDate"
          | "name"
          | "primaryRepositories"
          | "productType"
          | "workflows"
        )[];
        /** the fields to include for returned resources of type builds */
        "fields[builds]"?: (
          | "app"
          | "appEncryptionDeclaration"
          | "appStoreVersion"
          | "betaAppReviewSubmission"
          | "betaBuildLocalizations"
          | "betaGroups"
          | "buildAudienceType"
          | "buildBetaDetail"
          | "buildBundles"
          | "computedMinMacOsVersion"
          | "diagnosticSignatures"
          | "expirationDate"
          | "expired"
          | "iconAssetToken"
          | "icons"
          | "individualTesters"
          | "lsMinimumSystemVersion"
          | "minOsVersion"
          | "perfPowerMetrics"
          | "preReleaseVersion"
          | "processingState"
          | "uploadedDate"
          | "usesNonExemptEncryption"
          | "version"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /**
         * maximum number of related builds returned (when they are included)
         * @max 50
         */
        "limit[builds]"?: number;
        /** comma-separated list of relationships to include */
        include?: ("builds" | "destinationBranch" | "product" | "pullRequest" | "sourceBranchOrTag" | "workflow")[];
      },
      params: RequestParams = {},
    ): Promise<CiBuildRunsResponse> =>
      this.request<CiBuildRunsResponse, ErrorResponse>({
        path: `/v1/ciProducts/${id}/buildRuns`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags CiProducts
     * @name CiProductsPrimaryRepositoriesGetToManyRelated
     * @request GET:/v1/ciProducts/{id}/primaryRepositories
     * @secure
     */
    primaryRepositoriesGetToManyRelated: (
      id: string,
      query?: {
        /** filter by id(s) */
        "filter[id]"?: string[];
        /** the fields to include for returned resources of type scmGitReferences */
        "fields[scmGitReferences]"?: ("canonicalName" | "isDeleted" | "kind" | "name" | "repository")[];
        /** the fields to include for returned resources of type scmProviders */
        "fields[scmProviders]"?: ("repositories" | "scmProviderType" | "url")[];
        /** the fields to include for returned resources of type scmRepositories */
        "fields[scmRepositories]"?: (
          | "defaultBranch"
          | "gitReferences"
          | "httpCloneUrl"
          | "lastAccessedDate"
          | "ownerName"
          | "pullRequests"
          | "repositoryName"
          | "scmProvider"
          | "sshCloneUrl"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /** comma-separated list of relationships to include */
        include?: ("defaultBranch" | "scmProvider")[];
      },
      params: RequestParams = {},
    ): Promise<ScmRepositoriesResponse> =>
      this.request<ScmRepositoriesResponse, ErrorResponse>({
        path: `/v1/ciProducts/${id}/primaryRepositories`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags CiProducts
     * @name CiProductsWorkflowsGetToManyRelated
     * @request GET:/v1/ciProducts/{id}/workflows
     * @secure
     */
    workflowsGetToManyRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type ciXcodeVersions */
        "fields[ciXcodeVersions]"?: ("macOsVersions" | "name" | "testDestinations" | "version")[];
        /** the fields to include for returned resources of type ciWorkflows */
        "fields[ciWorkflows]"?: (
          | "actions"
          | "branchStartCondition"
          | "buildRuns"
          | "clean"
          | "containerFilePath"
          | "description"
          | "isEnabled"
          | "isLockedForEditing"
          | "lastModifiedDate"
          | "macOsVersion"
          | "manualBranchStartCondition"
          | "manualPullRequestStartCondition"
          | "manualTagStartCondition"
          | "name"
          | "product"
          | "pullRequestStartCondition"
          | "repository"
          | "scheduledStartCondition"
          | "tagStartCondition"
          | "xcodeVersion"
        )[];
        /** the fields to include for returned resources of type ciMacOsVersions */
        "fields[ciMacOsVersions]"?: ("name" | "version" | "xcodeVersions")[];
        /** the fields to include for returned resources of type ciProducts */
        "fields[ciProducts]"?: (
          | "additionalRepositories"
          | "app"
          | "buildRuns"
          | "bundleId"
          | "createdDate"
          | "name"
          | "primaryRepositories"
          | "productType"
          | "workflows"
        )[];
        /** the fields to include for returned resources of type scmRepositories */
        "fields[scmRepositories]"?: (
          | "defaultBranch"
          | "gitReferences"
          | "httpCloneUrl"
          | "lastAccessedDate"
          | "ownerName"
          | "pullRequests"
          | "repositoryName"
          | "scmProvider"
          | "sshCloneUrl"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /** comma-separated list of relationships to include */
        include?: ("macOsVersion" | "product" | "repository" | "xcodeVersion")[];
      },
      params: RequestParams = {},
    ): Promise<CiWorkflowsResponse> =>
      this.request<CiWorkflowsResponse, ErrorResponse>({
        path: `/v1/ciProducts/${id}/workflows`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  ciTestResults = {
    /**
     * No description
     *
     * @tags CiTestResults
     * @name CiTestResultsGetInstance
     * @request GET:/v1/ciTestResults/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type ciTestResults */
        "fields[ciTestResults]"?: (
          | "className"
          | "destinationTestResults"
          | "fileSource"
          | "message"
          | "name"
          | "status"
        )[];
      },
      params: RequestParams = {},
    ): Promise<CiTestResultResponse> =>
      this.request<CiTestResultResponse, ErrorResponse>({
        path: `/v1/ciTestResults/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  ciWorkflows = {
    /**
     * No description
     *
     * @tags CiWorkflows
     * @name CiWorkflowsCreateInstance
     * @request POST:/v1/ciWorkflows
     * @secure
     */
    createInstance: (data: CiWorkflowCreateRequest, params: RequestParams = {}): Promise<CiWorkflowResponse> =>
      this.request<CiWorkflowResponse, ErrorResponse>({
        path: `/v1/ciWorkflows`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags CiWorkflows
     * @name CiWorkflowsGetInstance
     * @request GET:/v1/ciWorkflows/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type ciWorkflows */
        "fields[ciWorkflows]"?: (
          | "actions"
          | "branchStartCondition"
          | "buildRuns"
          | "clean"
          | "containerFilePath"
          | "description"
          | "isEnabled"
          | "isLockedForEditing"
          | "lastModifiedDate"
          | "macOsVersion"
          | "manualBranchStartCondition"
          | "manualPullRequestStartCondition"
          | "manualTagStartCondition"
          | "name"
          | "product"
          | "pullRequestStartCondition"
          | "repository"
          | "scheduledStartCondition"
          | "tagStartCondition"
          | "xcodeVersion"
        )[];
        /** comma-separated list of relationships to include */
        include?: ("macOsVersion" | "product" | "repository" | "xcodeVersion")[];
        /** the fields to include for returned resources of type ciBuildRuns */
        "fields[ciBuildRuns]"?: (
          | "actions"
          | "buildRun"
          | "builds"
          | "cancelReason"
          | "clean"
          | "completionStatus"
          | "createdDate"
          | "destinationBranch"
          | "destinationCommit"
          | "executionProgress"
          | "finishedDate"
          | "isPullRequestBuild"
          | "issueCounts"
          | "number"
          | "product"
          | "pullRequest"
          | "sourceBranchOrTag"
          | "sourceCommit"
          | "startReason"
          | "startedDate"
          | "workflow"
        )[];
        /** the fields to include for returned resources of type scmRepositories */
        "fields[scmRepositories]"?: (
          | "defaultBranch"
          | "gitReferences"
          | "httpCloneUrl"
          | "lastAccessedDate"
          | "ownerName"
          | "pullRequests"
          | "repositoryName"
          | "scmProvider"
          | "sshCloneUrl"
        )[];
      },
      params: RequestParams = {},
    ): Promise<CiWorkflowResponse> =>
      this.request<CiWorkflowResponse, ErrorResponse>({
        path: `/v1/ciWorkflows/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags CiWorkflows
     * @name CiWorkflowsUpdateInstance
     * @request PATCH:/v1/ciWorkflows/{id}
     * @secure
     */
    updateInstance: (
      id: string,
      data: CiWorkflowUpdateRequest,
      params: RequestParams = {},
    ): Promise<CiWorkflowResponse> =>
      this.request<CiWorkflowResponse, ErrorResponse>({
        path: `/v1/ciWorkflows/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags CiWorkflows
     * @name CiWorkflowsDeleteInstance
     * @request DELETE:/v1/ciWorkflows/{id}
     * @secure
     */
    deleteInstance: (id: string, params: RequestParams = {}): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/ciWorkflows/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),

    /**
     * No description
     *
     * @tags CiWorkflows
     * @name CiWorkflowsBuildRunsGetToManyRelated
     * @request GET:/v1/ciWorkflows/{id}/buildRuns
     * @secure
     */
    buildRunsGetToManyRelated: (
      id: string,
      query?: {
        /** filter by id(s) of related 'builds' */
        "filter[builds]"?: string[];
        /** comma-separated list of sort expressions; resources will be sorted as specified */
        sort?: ("number" | "-number")[];
        /** the fields to include for returned resources of type scmGitReferences */
        "fields[scmGitReferences]"?: ("canonicalName" | "isDeleted" | "kind" | "name" | "repository")[];
        /** the fields to include for returned resources of type ciBuildRuns */
        "fields[ciBuildRuns]"?: (
          | "actions"
          | "buildRun"
          | "builds"
          | "cancelReason"
          | "clean"
          | "completionStatus"
          | "createdDate"
          | "destinationBranch"
          | "destinationCommit"
          | "executionProgress"
          | "finishedDate"
          | "isPullRequestBuild"
          | "issueCounts"
          | "number"
          | "product"
          | "pullRequest"
          | "sourceBranchOrTag"
          | "sourceCommit"
          | "startReason"
          | "startedDate"
          | "workflow"
        )[];
        /** the fields to include for returned resources of type ciWorkflows */
        "fields[ciWorkflows]"?: (
          | "actions"
          | "branchStartCondition"
          | "buildRuns"
          | "clean"
          | "containerFilePath"
          | "description"
          | "isEnabled"
          | "isLockedForEditing"
          | "lastModifiedDate"
          | "macOsVersion"
          | "manualBranchStartCondition"
          | "manualPullRequestStartCondition"
          | "manualTagStartCondition"
          | "name"
          | "product"
          | "pullRequestStartCondition"
          | "repository"
          | "scheduledStartCondition"
          | "tagStartCondition"
          | "xcodeVersion"
        )[];
        /** the fields to include for returned resources of type scmPullRequests */
        "fields[scmPullRequests]"?: (
          | "destinationBranchName"
          | "destinationRepositoryName"
          | "destinationRepositoryOwner"
          | "isClosed"
          | "isCrossRepository"
          | "number"
          | "repository"
          | "sourceBranchName"
          | "sourceRepositoryName"
          | "sourceRepositoryOwner"
          | "title"
          | "webUrl"
        )[];
        /** the fields to include for returned resources of type ciProducts */
        "fields[ciProducts]"?: (
          | "additionalRepositories"
          | "app"
          | "buildRuns"
          | "bundleId"
          | "createdDate"
          | "name"
          | "primaryRepositories"
          | "productType"
          | "workflows"
        )[];
        /** the fields to include for returned resources of type builds */
        "fields[builds]"?: (
          | "app"
          | "appEncryptionDeclaration"
          | "appStoreVersion"
          | "betaAppReviewSubmission"
          | "betaBuildLocalizations"
          | "betaGroups"
          | "buildAudienceType"
          | "buildBetaDetail"
          | "buildBundles"
          | "computedMinMacOsVersion"
          | "diagnosticSignatures"
          | "expirationDate"
          | "expired"
          | "iconAssetToken"
          | "icons"
          | "individualTesters"
          | "lsMinimumSystemVersion"
          | "minOsVersion"
          | "perfPowerMetrics"
          | "preReleaseVersion"
          | "processingState"
          | "uploadedDate"
          | "usesNonExemptEncryption"
          | "version"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /**
         * maximum number of related builds returned (when they are included)
         * @max 50
         */
        "limit[builds]"?: number;
        /** comma-separated list of relationships to include */
        include?: ("builds" | "destinationBranch" | "product" | "pullRequest" | "sourceBranchOrTag" | "workflow")[];
      },
      params: RequestParams = {},
    ): Promise<CiBuildRunsResponse> =>
      this.request<CiBuildRunsResponse, ErrorResponse>({
        path: `/v1/ciWorkflows/${id}/buildRuns`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags CiWorkflows
     * @name CiWorkflowsRepositoryGetToOneRelated
     * @request GET:/v1/ciWorkflows/{id}/repository
     * @secure
     */
    repositoryGetToOneRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type scmGitReferences */
        "fields[scmGitReferences]"?: ("canonicalName" | "isDeleted" | "kind" | "name" | "repository")[];
        /** the fields to include for returned resources of type scmProviders */
        "fields[scmProviders]"?: ("repositories" | "scmProviderType" | "url")[];
        /** the fields to include for returned resources of type scmRepositories */
        "fields[scmRepositories]"?: (
          | "defaultBranch"
          | "gitReferences"
          | "httpCloneUrl"
          | "lastAccessedDate"
          | "ownerName"
          | "pullRequests"
          | "repositoryName"
          | "scmProvider"
          | "sshCloneUrl"
        )[];
        /** comma-separated list of relationships to include */
        include?: ("defaultBranch" | "scmProvider")[];
      },
      params: RequestParams = {},
    ): Promise<ScmRepositoryResponse> =>
      this.request<ScmRepositoryResponse, ErrorResponse>({
        path: `/v1/ciWorkflows/${id}/repository`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  ciXcodeVersions = {
    /**
     * No description
     *
     * @tags CiXcodeVersions
     * @name CiXcodeVersionsGetCollection
     * @request GET:/v1/ciXcodeVersions
     * @secure
     */
    getCollection: (
      query?: {
        /** the fields to include for returned resources of type ciXcodeVersions */
        "fields[ciXcodeVersions]"?: ("macOsVersions" | "name" | "testDestinations" | "version")[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /** comma-separated list of relationships to include */
        include?: "macOsVersions"[];
        /** the fields to include for returned resources of type ciMacOsVersions */
        "fields[ciMacOsVersions]"?: ("name" | "version" | "xcodeVersions")[];
        /**
         * maximum number of related macOsVersions returned (when they are included)
         * @max 50
         */
        "limit[macOsVersions]"?: number;
      },
      params: RequestParams = {},
    ): Promise<CiXcodeVersionsResponse> =>
      this.request<CiXcodeVersionsResponse, ErrorResponse>({
        path: `/v1/ciXcodeVersions`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags CiXcodeVersions
     * @name CiXcodeVersionsGetInstance
     * @request GET:/v1/ciXcodeVersions/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type ciXcodeVersions */
        "fields[ciXcodeVersions]"?: ("macOsVersions" | "name" | "testDestinations" | "version")[];
        /** comma-separated list of relationships to include */
        include?: "macOsVersions"[];
        /** the fields to include for returned resources of type ciMacOsVersions */
        "fields[ciMacOsVersions]"?: ("name" | "version" | "xcodeVersions")[];
        /**
         * maximum number of related macOsVersions returned (when they are included)
         * @max 50
         */
        "limit[macOsVersions]"?: number;
      },
      params: RequestParams = {},
    ): Promise<CiXcodeVersionResponse> =>
      this.request<CiXcodeVersionResponse, ErrorResponse>({
        path: `/v1/ciXcodeVersions/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags CiXcodeVersions
     * @name CiXcodeVersionsMacOsVersionsGetToManyRelated
     * @request GET:/v1/ciXcodeVersions/{id}/macOsVersions
     * @secure
     */
    macOsVersionsGetToManyRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type ciXcodeVersions */
        "fields[ciXcodeVersions]"?: ("macOsVersions" | "name" | "testDestinations" | "version")[];
        /** the fields to include for returned resources of type ciMacOsVersions */
        "fields[ciMacOsVersions]"?: ("name" | "version" | "xcodeVersions")[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /**
         * maximum number of related xcodeVersions returned (when they are included)
         * @max 50
         */
        "limit[xcodeVersions]"?: number;
        /** comma-separated list of relationships to include */
        include?: "xcodeVersions"[];
      },
      params: RequestParams = {},
    ): Promise<CiMacOsVersionsResponse> =>
      this.request<CiMacOsVersionsResponse, ErrorResponse>({
        path: `/v1/ciXcodeVersions/${id}/macOsVersions`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  customerReviewResponses = {
    /**
     * No description
     *
     * @tags CustomerReviewResponses
     * @name CustomerReviewResponsesCreateInstance
     * @request POST:/v1/customerReviewResponses
     * @secure
     */
    createInstance: (
      data: CustomerReviewResponseV1CreateRequest,
      params: RequestParams = {},
    ): Promise<CustomerReviewResponseV1Response> =>
      this.request<CustomerReviewResponseV1Response, ErrorResponse>({
        path: `/v1/customerReviewResponses`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags CustomerReviewResponses
     * @name CustomerReviewResponsesGetInstance
     * @request GET:/v1/customerReviewResponses/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type customerReviewResponses */
        "fields[customerReviewResponses]"?: ("lastModifiedDate" | "responseBody" | "review" | "state")[];
        /** comma-separated list of relationships to include */
        include?: "review"[];
      },
      params: RequestParams = {},
    ): Promise<CustomerReviewResponseV1Response> =>
      this.request<CustomerReviewResponseV1Response, ErrorResponse>({
        path: `/v1/customerReviewResponses/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags CustomerReviewResponses
     * @name CustomerReviewResponsesDeleteInstance
     * @request DELETE:/v1/customerReviewResponses/{id}
     * @secure
     */
    deleteInstance: (id: string, params: RequestParams = {}): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/customerReviewResponses/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),
  };
  customerReviews = {
    /**
     * No description
     *
     * @tags CustomerReviews
     * @name CustomerReviewsGetInstance
     * @request GET:/v1/customerReviews/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type customerReviews */
        "fields[customerReviews]"?: (
          | "body"
          | "createdDate"
          | "rating"
          | "response"
          | "reviewerNickname"
          | "territory"
          | "title"
        )[];
        /** comma-separated list of relationships to include */
        include?: "response"[];
        /** the fields to include for returned resources of type customerReviewResponses */
        "fields[customerReviewResponses]"?: ("lastModifiedDate" | "responseBody" | "review" | "state")[];
      },
      params: RequestParams = {},
    ): Promise<CustomerReviewResponse> =>
      this.request<CustomerReviewResponse, ErrorResponse>({
        path: `/v1/customerReviews/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags CustomerReviews
     * @name CustomerReviewsResponseGetToOneRelated
     * @request GET:/v1/customerReviews/{id}/response
     * @secure
     */
    responseGetToOneRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type customerReviews */
        "fields[customerReviews]"?: (
          | "body"
          | "createdDate"
          | "rating"
          | "response"
          | "reviewerNickname"
          | "territory"
          | "title"
        )[];
        /** the fields to include for returned resources of type customerReviewResponses */
        "fields[customerReviewResponses]"?: ("lastModifiedDate" | "responseBody" | "review" | "state")[];
        /** comma-separated list of relationships to include */
        include?: "review"[];
      },
      params: RequestParams = {},
    ): Promise<CustomerReviewResponseV1Response> =>
      this.request<CustomerReviewResponseV1Response, ErrorResponse>({
        path: `/v1/customerReviews/${id}/response`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  devices = {
    /**
     * No description
     *
     * @tags Devices
     * @name DevicesGetCollection
     * @request GET:/v1/devices
     * @secure
     */
    getCollection: (
      query?: {
        /** filter by attribute 'name' */
        "filter[name]"?: string[];
        /** filter by attribute 'platform' */
        "filter[platform]"?: ("IOS" | "MAC_OS")[];
        /** filter by attribute 'status' */
        "filter[status]"?: ("ENABLED" | "DISABLED")[];
        /** filter by attribute 'udid' */
        "filter[udid]"?: string[];
        /** filter by id(s) */
        "filter[id]"?: string[];
        /** comma-separated list of sort expressions; resources will be sorted as specified */
        sort?: ("id" | "-id" | "name" | "-name" | "platform" | "-platform" | "status" | "-status" | "udid" | "-udid")[];
        /** the fields to include for returned resources of type devices */
        "fields[devices]"?: ("addedDate" | "deviceClass" | "model" | "name" | "platform" | "status" | "udid")[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
      },
      params: RequestParams = {},
    ): Promise<DevicesResponse> =>
      this.request<DevicesResponse, ErrorResponse>({
        path: `/v1/devices`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Devices
     * @name DevicesCreateInstance
     * @request POST:/v1/devices
     * @secure
     */
    createInstance: (data: DeviceCreateRequest, params: RequestParams = {}): Promise<DeviceResponse> =>
      this.request<DeviceResponse, ErrorResponse>({
        path: `/v1/devices`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Devices
     * @name DevicesGetInstance
     * @request GET:/v1/devices/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type devices */
        "fields[devices]"?: ("addedDate" | "deviceClass" | "model" | "name" | "platform" | "status" | "udid")[];
      },
      params: RequestParams = {},
    ): Promise<DeviceResponse> =>
      this.request<DeviceResponse, ErrorResponse>({
        path: `/v1/devices/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Devices
     * @name DevicesUpdateInstance
     * @request PATCH:/v1/devices/{id}
     * @secure
     */
    updateInstance: (id: string, data: DeviceUpdateRequest, params: RequestParams = {}): Promise<DeviceResponse> =>
      this.request<DeviceResponse, ErrorResponse>({
        path: `/v1/devices/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),
  };
  endAppAvailabilityPreOrders = {
    /**
     * No description
     *
     * @tags EndAppAvailabilityPreOrders
     * @name EndAppAvailabilityPreOrdersCreateInstance
     * @request POST:/v1/endAppAvailabilityPreOrders
     * @secure
     */
    createInstance: (
      data: EndAppAvailabilityPreOrderCreateRequest,
      params: RequestParams = {},
    ): Promise<EndAppAvailabilityPreOrderResponse> =>
      this.request<EndAppAvailabilityPreOrderResponse, ErrorResponse>({
        path: `/v1/endAppAvailabilityPreOrders`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),
  };
  endUserLicenseAgreements = {
    /**
     * No description
     *
     * @tags EndUserLicenseAgreements
     * @name EndUserLicenseAgreementsCreateInstance
     * @request POST:/v1/endUserLicenseAgreements
     * @secure
     */
    createInstance: (
      data: EndUserLicenseAgreementCreateRequest,
      params: RequestParams = {},
    ): Promise<EndUserLicenseAgreementResponse> =>
      this.request<EndUserLicenseAgreementResponse, ErrorResponse>({
        path: `/v1/endUserLicenseAgreements`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags EndUserLicenseAgreements
     * @name EndUserLicenseAgreementsGetInstance
     * @request GET:/v1/endUserLicenseAgreements/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type endUserLicenseAgreements */
        "fields[endUserLicenseAgreements]"?: ("agreementText" | "app" | "territories")[];
        /** comma-separated list of relationships to include */
        include?: ("app" | "territories")[];
        /** the fields to include for returned resources of type territories */
        "fields[territories]"?: "currency"[];
        /**
         * maximum number of related territories returned (when they are included)
         * @max 50
         */
        "limit[territories]"?: number;
      },
      params: RequestParams = {},
    ): Promise<EndUserLicenseAgreementResponse> =>
      this.request<EndUserLicenseAgreementResponse, ErrorResponse>({
        path: `/v1/endUserLicenseAgreements/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags EndUserLicenseAgreements
     * @name EndUserLicenseAgreementsUpdateInstance
     * @request PATCH:/v1/endUserLicenseAgreements/{id}
     * @secure
     */
    updateInstance: (
      id: string,
      data: EndUserLicenseAgreementUpdateRequest,
      params: RequestParams = {},
    ): Promise<EndUserLicenseAgreementResponse> =>
      this.request<EndUserLicenseAgreementResponse, ErrorResponse>({
        path: `/v1/endUserLicenseAgreements/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags EndUserLicenseAgreements
     * @name EndUserLicenseAgreementsDeleteInstance
     * @request DELETE:/v1/endUserLicenseAgreements/{id}
     * @secure
     */
    deleteInstance: (id: string, params: RequestParams = {}): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/endUserLicenseAgreements/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),

    /**
     * No description
     *
     * @tags EndUserLicenseAgreements
     * @name EndUserLicenseAgreementsTerritoriesGetToManyRelated
     * @request GET:/v1/endUserLicenseAgreements/{id}/territories
     * @secure
     */
    territoriesGetToManyRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type territories */
        "fields[territories]"?: "currency"[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
      },
      params: RequestParams = {},
    ): Promise<TerritoriesWithoutIncludesResponse> =>
      this.request<TerritoriesWithoutIncludesResponse, ErrorResponse>({
        path: `/v1/endUserLicenseAgreements/${id}/territories`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  financeReports = {
    /**
     * No description
     *
     * @tags FinanceReports
     * @name FinanceReportsGetCollection
     * @request GET:/v1/financeReports
     * @secure
     */
    getCollection: (
      query: {
        /** filter by attribute 'regionCode' */
        "filter[regionCode]": string[];
        /** filter by attribute 'reportDate' */
        "filter[reportDate]": string[];
        /** filter by attribute 'reportType' */
        "filter[reportType]": ("FINANCIAL" | "FINANCE_DETAIL")[];
        /** filter by attribute 'vendorNumber' */
        "filter[vendorNumber]": string[];
      },
      params: RequestParams = {},
    ): Promise<Gzip> =>
      this.request<Gzip, ErrorResponse>({
        path: `/v1/financeReports`,
        method: "GET",
        query: query,
        secure: true,
        ...params,
      }),
  };
  gameCenterAchievementImages = {
    /**
     * No description
     *
     * @tags GameCenterAchievementImages
     * @name GameCenterAchievementImagesCreateInstance
     * @request POST:/v1/gameCenterAchievementImages
     * @secure
     */
    createInstance: (
      data: GameCenterAchievementImageCreateRequest,
      params: RequestParams = {},
    ): Promise<GameCenterAchievementImageResponse> =>
      this.request<GameCenterAchievementImageResponse, ErrorResponse>({
        path: `/v1/gameCenterAchievementImages`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterAchievementImages
     * @name GameCenterAchievementImagesGetInstance
     * @request GET:/v1/gameCenterAchievementImages/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type gameCenterAchievementImages */
        "fields[gameCenterAchievementImages]"?: (
          | "assetDeliveryState"
          | "fileName"
          | "fileSize"
          | "gameCenterAchievementLocalization"
          | "imageAsset"
          | "uploadOperations"
          | "uploaded"
        )[];
        /** comma-separated list of relationships to include */
        include?: "gameCenterAchievementLocalization"[];
      },
      params: RequestParams = {},
    ): Promise<GameCenterAchievementImageResponse> =>
      this.request<GameCenterAchievementImageResponse, ErrorResponse>({
        path: `/v1/gameCenterAchievementImages/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterAchievementImages
     * @name GameCenterAchievementImagesUpdateInstance
     * @request PATCH:/v1/gameCenterAchievementImages/{id}
     * @secure
     */
    updateInstance: (
      id: string,
      data: GameCenterAchievementImageUpdateRequest,
      params: RequestParams = {},
    ): Promise<GameCenterAchievementImageResponse> =>
      this.request<GameCenterAchievementImageResponse, ErrorResponse>({
        path: `/v1/gameCenterAchievementImages/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterAchievementImages
     * @name GameCenterAchievementImagesDeleteInstance
     * @request DELETE:/v1/gameCenterAchievementImages/{id}
     * @secure
     */
    deleteInstance: (id: string, params: RequestParams = {}): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/gameCenterAchievementImages/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),
  };
  gameCenterAchievementLocalizations = {
    /**
     * No description
     *
     * @tags GameCenterAchievementLocalizations
     * @name GameCenterAchievementLocalizationsCreateInstance
     * @request POST:/v1/gameCenterAchievementLocalizations
     * @secure
     */
    createInstance: (
      data: GameCenterAchievementLocalizationCreateRequest,
      params: RequestParams = {},
    ): Promise<GameCenterAchievementLocalizationResponse> =>
      this.request<GameCenterAchievementLocalizationResponse, ErrorResponse>({
        path: `/v1/gameCenterAchievementLocalizations`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterAchievementLocalizations
     * @name GameCenterAchievementLocalizationsGetInstance
     * @request GET:/v1/gameCenterAchievementLocalizations/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type gameCenterAchievementLocalizations */
        "fields[gameCenterAchievementLocalizations]"?: (
          | "afterEarnedDescription"
          | "beforeEarnedDescription"
          | "gameCenterAchievement"
          | "gameCenterAchievementImage"
          | "locale"
          | "name"
        )[];
        /** comma-separated list of relationships to include */
        include?: ("gameCenterAchievement" | "gameCenterAchievementImage")[];
        /** the fields to include for returned resources of type gameCenterAchievementImages */
        "fields[gameCenterAchievementImages]"?: (
          | "assetDeliveryState"
          | "fileName"
          | "fileSize"
          | "gameCenterAchievementLocalization"
          | "imageAsset"
          | "uploadOperations"
          | "uploaded"
        )[];
        /** the fields to include for returned resources of type gameCenterAchievements */
        "fields[gameCenterAchievements]"?: (
          | "archived"
          | "gameCenterDetail"
          | "gameCenterGroup"
          | "groupAchievement"
          | "localizations"
          | "points"
          | "referenceName"
          | "releases"
          | "repeatable"
          | "showBeforeEarned"
          | "vendorIdentifier"
        )[];
      },
      params: RequestParams = {},
    ): Promise<GameCenterAchievementLocalizationResponse> =>
      this.request<GameCenterAchievementLocalizationResponse, ErrorResponse>({
        path: `/v1/gameCenterAchievementLocalizations/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterAchievementLocalizations
     * @name GameCenterAchievementLocalizationsUpdateInstance
     * @request PATCH:/v1/gameCenterAchievementLocalizations/{id}
     * @secure
     */
    updateInstance: (
      id: string,
      data: GameCenterAchievementLocalizationUpdateRequest,
      params: RequestParams = {},
    ): Promise<GameCenterAchievementLocalizationResponse> =>
      this.request<GameCenterAchievementLocalizationResponse, ErrorResponse>({
        path: `/v1/gameCenterAchievementLocalizations/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterAchievementLocalizations
     * @name GameCenterAchievementLocalizationsDeleteInstance
     * @request DELETE:/v1/gameCenterAchievementLocalizations/{id}
     * @secure
     */
    deleteInstance: (id: string, params: RequestParams = {}): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/gameCenterAchievementLocalizations/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterAchievementLocalizations
     * @name GameCenterAchievementLocalizationsGameCenterAchievementGetToOneRelated
     * @request GET:/v1/gameCenterAchievementLocalizations/{id}/gameCenterAchievement
     * @secure
     */
    gameCenterAchievementGetToOneRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type gameCenterAchievementReleases */
        "fields[gameCenterAchievementReleases]"?: ("gameCenterAchievement" | "gameCenterDetail" | "live")[];
        /** the fields to include for returned resources of type gameCenterGroups */
        "fields[gameCenterGroups]"?: (
          | "gameCenterAchievements"
          | "gameCenterDetails"
          | "gameCenterLeaderboardSets"
          | "gameCenterLeaderboards"
          | "referenceName"
        )[];
        /** the fields to include for returned resources of type gameCenterDetails */
        "fields[gameCenterDetails]"?: (
          | "achievementReleases"
          | "app"
          | "arcadeEnabled"
          | "challengeEnabled"
          | "defaultGroupLeaderboard"
          | "defaultLeaderboard"
          | "gameCenterAchievements"
          | "gameCenterAppVersions"
          | "gameCenterGroup"
          | "gameCenterLeaderboardSets"
          | "gameCenterLeaderboards"
          | "leaderboardReleases"
          | "leaderboardSetReleases"
        )[];
        /** the fields to include for returned resources of type gameCenterAchievementLocalizations */
        "fields[gameCenterAchievementLocalizations]"?: (
          | "afterEarnedDescription"
          | "beforeEarnedDescription"
          | "gameCenterAchievement"
          | "gameCenterAchievementImage"
          | "locale"
          | "name"
        )[];
        /** the fields to include for returned resources of type gameCenterAchievements */
        "fields[gameCenterAchievements]"?: (
          | "archived"
          | "gameCenterDetail"
          | "gameCenterGroup"
          | "groupAchievement"
          | "localizations"
          | "points"
          | "referenceName"
          | "releases"
          | "repeatable"
          | "showBeforeEarned"
          | "vendorIdentifier"
        )[];
        /**
         * maximum number of related localizations returned (when they are included)
         * @max 50
         */
        "limit[localizations]"?: number;
        /**
         * maximum number of related releases returned (when they are included)
         * @max 50
         */
        "limit[releases]"?: number;
        /** comma-separated list of relationships to include */
        include?: ("gameCenterDetail" | "gameCenterGroup" | "groupAchievement" | "localizations" | "releases")[];
      },
      params: RequestParams = {},
    ): Promise<GameCenterAchievementResponse> =>
      this.request<GameCenterAchievementResponse, ErrorResponse>({
        path: `/v1/gameCenterAchievementLocalizations/${id}/gameCenterAchievement`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterAchievementLocalizations
     * @name GameCenterAchievementLocalizationsGameCenterAchievementImageGetToOneRelated
     * @request GET:/v1/gameCenterAchievementLocalizations/{id}/gameCenterAchievementImage
     * @secure
     */
    gameCenterAchievementImageGetToOneRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type gameCenterAchievementImages */
        "fields[gameCenterAchievementImages]"?: (
          | "assetDeliveryState"
          | "fileName"
          | "fileSize"
          | "gameCenterAchievementLocalization"
          | "imageAsset"
          | "uploadOperations"
          | "uploaded"
        )[];
        /** the fields to include for returned resources of type gameCenterAchievementLocalizations */
        "fields[gameCenterAchievementLocalizations]"?: (
          | "afterEarnedDescription"
          | "beforeEarnedDescription"
          | "gameCenterAchievement"
          | "gameCenterAchievementImage"
          | "locale"
          | "name"
        )[];
        /** comma-separated list of relationships to include */
        include?: "gameCenterAchievementLocalization"[];
      },
      params: RequestParams = {},
    ): Promise<GameCenterAchievementImageResponse> =>
      this.request<GameCenterAchievementImageResponse, ErrorResponse>({
        path: `/v1/gameCenterAchievementLocalizations/${id}/gameCenterAchievementImage`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  gameCenterAchievementReleases = {
    /**
     * No description
     *
     * @tags GameCenterAchievementReleases
     * @name GameCenterAchievementReleasesCreateInstance
     * @request POST:/v1/gameCenterAchievementReleases
     * @secure
     */
    createInstance: (
      data: GameCenterAchievementReleaseCreateRequest,
      params: RequestParams = {},
    ): Promise<GameCenterAchievementReleaseResponse> =>
      this.request<GameCenterAchievementReleaseResponse, ErrorResponse>({
        path: `/v1/gameCenterAchievementReleases`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterAchievementReleases
     * @name GameCenterAchievementReleasesGetInstance
     * @request GET:/v1/gameCenterAchievementReleases/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type gameCenterAchievementReleases */
        "fields[gameCenterAchievementReleases]"?: ("gameCenterAchievement" | "gameCenterDetail" | "live")[];
        /** comma-separated list of relationships to include */
        include?: ("gameCenterAchievement" | "gameCenterDetail")[];
      },
      params: RequestParams = {},
    ): Promise<GameCenterAchievementReleaseResponse> =>
      this.request<GameCenterAchievementReleaseResponse, ErrorResponse>({
        path: `/v1/gameCenterAchievementReleases/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterAchievementReleases
     * @name GameCenterAchievementReleasesDeleteInstance
     * @request DELETE:/v1/gameCenterAchievementReleases/{id}
     * @secure
     */
    deleteInstance: (id: string, params: RequestParams = {}): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/gameCenterAchievementReleases/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),
  };
  gameCenterAchievements = {
    /**
     * No description
     *
     * @tags GameCenterAchievements
     * @name GameCenterAchievementsCreateInstance
     * @request POST:/v1/gameCenterAchievements
     * @secure
     */
    createInstance: (
      data: GameCenterAchievementCreateRequest,
      params: RequestParams = {},
    ): Promise<GameCenterAchievementResponse> =>
      this.request<GameCenterAchievementResponse, ErrorResponse>({
        path: `/v1/gameCenterAchievements`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterAchievements
     * @name GameCenterAchievementsGetInstance
     * @request GET:/v1/gameCenterAchievements/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type gameCenterAchievements */
        "fields[gameCenterAchievements]"?: (
          | "archived"
          | "gameCenterDetail"
          | "gameCenterGroup"
          | "groupAchievement"
          | "localizations"
          | "points"
          | "referenceName"
          | "releases"
          | "repeatable"
          | "showBeforeEarned"
          | "vendorIdentifier"
        )[];
        /** comma-separated list of relationships to include */
        include?: ("gameCenterDetail" | "gameCenterGroup" | "groupAchievement" | "localizations" | "releases")[];
        /** the fields to include for returned resources of type gameCenterAchievementReleases */
        "fields[gameCenterAchievementReleases]"?: ("gameCenterAchievement" | "gameCenterDetail" | "live")[];
        /** the fields to include for returned resources of type gameCenterAchievementLocalizations */
        "fields[gameCenterAchievementLocalizations]"?: (
          | "afterEarnedDescription"
          | "beforeEarnedDescription"
          | "gameCenterAchievement"
          | "gameCenterAchievementImage"
          | "locale"
          | "name"
        )[];
        /**
         * maximum number of related localizations returned (when they are included)
         * @max 50
         */
        "limit[localizations]"?: number;
        /**
         * maximum number of related releases returned (when they are included)
         * @max 50
         */
        "limit[releases]"?: number;
      },
      params: RequestParams = {},
    ): Promise<GameCenterAchievementResponse> =>
      this.request<GameCenterAchievementResponse, ErrorResponse>({
        path: `/v1/gameCenterAchievements/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterAchievements
     * @name GameCenterAchievementsUpdateInstance
     * @request PATCH:/v1/gameCenterAchievements/{id}
     * @secure
     */
    updateInstance: (
      id: string,
      data: GameCenterAchievementUpdateRequest,
      params: RequestParams = {},
    ): Promise<GameCenterAchievementResponse> =>
      this.request<GameCenterAchievementResponse, ErrorResponse>({
        path: `/v1/gameCenterAchievements/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterAchievements
     * @name GameCenterAchievementsDeleteInstance
     * @request DELETE:/v1/gameCenterAchievements/{id}
     * @secure
     */
    deleteInstance: (id: string, params: RequestParams = {}): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/gameCenterAchievements/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterAchievements
     * @name GameCenterAchievementsGroupAchievementGetToOneRelationship
     * @request GET:/v1/gameCenterAchievements/{id}/relationships/groupAchievement
     * @secure
     */
    groupAchievementGetToOneRelationship: (
      id: string,
      params: RequestParams = {},
    ): Promise<GameCenterAchievementGroupAchievementLinkageResponse> =>
      this.request<GameCenterAchievementGroupAchievementLinkageResponse, ErrorResponse>({
        path: `/v1/gameCenterAchievements/${id}/relationships/groupAchievement`,
        method: "GET",
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterAchievements
     * @name GameCenterAchievementsGroupAchievementUpdateToOneRelationship
     * @request PATCH:/v1/gameCenterAchievements/{id}/relationships/groupAchievement
     * @secure
     */
    groupAchievementUpdateToOneRelationship: (
      id: string,
      data: GameCenterAchievementGroupAchievementLinkageRequest,
      params: RequestParams = {},
    ): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/gameCenterAchievements/${id}/relationships/groupAchievement`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterAchievements
     * @name GameCenterAchievementsGroupAchievementGetToOneRelated
     * @request GET:/v1/gameCenterAchievements/{id}/groupAchievement
     * @secure
     */
    groupAchievementGetToOneRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type gameCenterAchievementReleases */
        "fields[gameCenterAchievementReleases]"?: ("gameCenterAchievement" | "gameCenterDetail" | "live")[];
        /** the fields to include for returned resources of type gameCenterGroups */
        "fields[gameCenterGroups]"?: (
          | "gameCenterAchievements"
          | "gameCenterDetails"
          | "gameCenterLeaderboardSets"
          | "gameCenterLeaderboards"
          | "referenceName"
        )[];
        /** the fields to include for returned resources of type gameCenterDetails */
        "fields[gameCenterDetails]"?: (
          | "achievementReleases"
          | "app"
          | "arcadeEnabled"
          | "challengeEnabled"
          | "defaultGroupLeaderboard"
          | "defaultLeaderboard"
          | "gameCenterAchievements"
          | "gameCenterAppVersions"
          | "gameCenterGroup"
          | "gameCenterLeaderboardSets"
          | "gameCenterLeaderboards"
          | "leaderboardReleases"
          | "leaderboardSetReleases"
        )[];
        /** the fields to include for returned resources of type gameCenterAchievementLocalizations */
        "fields[gameCenterAchievementLocalizations]"?: (
          | "afterEarnedDescription"
          | "beforeEarnedDescription"
          | "gameCenterAchievement"
          | "gameCenterAchievementImage"
          | "locale"
          | "name"
        )[];
        /** the fields to include for returned resources of type gameCenterAchievements */
        "fields[gameCenterAchievements]"?: (
          | "archived"
          | "gameCenterDetail"
          | "gameCenterGroup"
          | "groupAchievement"
          | "localizations"
          | "points"
          | "referenceName"
          | "releases"
          | "repeatable"
          | "showBeforeEarned"
          | "vendorIdentifier"
        )[];
        /**
         * maximum number of related localizations returned (when they are included)
         * @max 50
         */
        "limit[localizations]"?: number;
        /**
         * maximum number of related releases returned (when they are included)
         * @max 50
         */
        "limit[releases]"?: number;
        /** comma-separated list of relationships to include */
        include?: ("gameCenterDetail" | "gameCenterGroup" | "groupAchievement" | "localizations" | "releases")[];
      },
      params: RequestParams = {},
    ): Promise<GameCenterAchievementResponse> =>
      this.request<GameCenterAchievementResponse, ErrorResponse>({
        path: `/v1/gameCenterAchievements/${id}/groupAchievement`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterAchievements
     * @name GameCenterAchievementsLocalizationsGetToManyRelated
     * @request GET:/v1/gameCenterAchievements/{id}/localizations
     * @secure
     */
    localizationsGetToManyRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type gameCenterAchievementImages */
        "fields[gameCenterAchievementImages]"?: (
          | "assetDeliveryState"
          | "fileName"
          | "fileSize"
          | "gameCenterAchievementLocalization"
          | "imageAsset"
          | "uploadOperations"
          | "uploaded"
        )[];
        /** the fields to include for returned resources of type gameCenterAchievementLocalizations */
        "fields[gameCenterAchievementLocalizations]"?: (
          | "afterEarnedDescription"
          | "beforeEarnedDescription"
          | "gameCenterAchievement"
          | "gameCenterAchievementImage"
          | "locale"
          | "name"
        )[];
        /** the fields to include for returned resources of type gameCenterAchievements */
        "fields[gameCenterAchievements]"?: (
          | "archived"
          | "gameCenterDetail"
          | "gameCenterGroup"
          | "groupAchievement"
          | "localizations"
          | "points"
          | "referenceName"
          | "releases"
          | "repeatable"
          | "showBeforeEarned"
          | "vendorIdentifier"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /** comma-separated list of relationships to include */
        include?: ("gameCenterAchievement" | "gameCenterAchievementImage")[];
      },
      params: RequestParams = {},
    ): Promise<GameCenterAchievementLocalizationsResponse> =>
      this.request<GameCenterAchievementLocalizationsResponse, ErrorResponse>({
        path: `/v1/gameCenterAchievements/${id}/localizations`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterAchievements
     * @name GameCenterAchievementsReleasesGetToManyRelated
     * @request GET:/v1/gameCenterAchievements/{id}/releases
     * @secure
     */
    releasesGetToManyRelated: (
      id: string,
      query?: {
        /** filter by attribute 'live' */
        "filter[live]"?: string[];
        /** filter by id(s) of related 'gameCenterDetail' */
        "filter[gameCenterDetail]"?: string[];
        /** the fields to include for returned resources of type gameCenterAchievementReleases */
        "fields[gameCenterAchievementReleases]"?: ("gameCenterAchievement" | "gameCenterDetail" | "live")[];
        /** the fields to include for returned resources of type gameCenterDetails */
        "fields[gameCenterDetails]"?: (
          | "achievementReleases"
          | "app"
          | "arcadeEnabled"
          | "challengeEnabled"
          | "defaultGroupLeaderboard"
          | "defaultLeaderboard"
          | "gameCenterAchievements"
          | "gameCenterAppVersions"
          | "gameCenterGroup"
          | "gameCenterLeaderboardSets"
          | "gameCenterLeaderboards"
          | "leaderboardReleases"
          | "leaderboardSetReleases"
        )[];
        /** the fields to include for returned resources of type gameCenterAchievements */
        "fields[gameCenterAchievements]"?: (
          | "archived"
          | "gameCenterDetail"
          | "gameCenterGroup"
          | "groupAchievement"
          | "localizations"
          | "points"
          | "referenceName"
          | "releases"
          | "repeatable"
          | "showBeforeEarned"
          | "vendorIdentifier"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /** comma-separated list of relationships to include */
        include?: ("gameCenterAchievement" | "gameCenterDetail")[];
      },
      params: RequestParams = {},
    ): Promise<GameCenterAchievementReleasesResponse> =>
      this.request<GameCenterAchievementReleasesResponse, ErrorResponse>({
        path: `/v1/gameCenterAchievements/${id}/releases`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  gameCenterAppVersions = {
    /**
     * No description
     *
     * @tags GameCenterAppVersions
     * @name GameCenterAppVersionsCreateInstance
     * @request POST:/v1/gameCenterAppVersions
     * @secure
     */
    createInstance: (
      data: GameCenterAppVersionCreateRequest,
      params: RequestParams = {},
    ): Promise<GameCenterAppVersionResponse> =>
      this.request<GameCenterAppVersionResponse, ErrorResponse>({
        path: `/v1/gameCenterAppVersions`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterAppVersions
     * @name GameCenterAppVersionsGetInstance
     * @request GET:/v1/gameCenterAppVersions/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type gameCenterAppVersions */
        "fields[gameCenterAppVersions]"?: ("appStoreVersion" | "compatibilityVersions" | "enabled")[];
        /** comma-separated list of relationships to include */
        include?: ("appStoreVersion" | "compatibilityVersions")[];
        /** the fields to include for returned resources of type appStoreVersions */
        "fields[appStoreVersions]"?: (
          | "ageRatingDeclaration"
          | "alternativeDistributionPackage"
          | "app"
          | "appClipDefaultExperience"
          | "appStoreReviewDetail"
          | "appStoreState"
          | "appStoreVersionExperiments"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersionLocalizations"
          | "appStoreVersionPhasedRelease"
          | "appStoreVersionSubmission"
          | "appVersionState"
          | "build"
          | "copyright"
          | "createdDate"
          | "customerReviews"
          | "downloadable"
          | "earliestReleaseDate"
          | "platform"
          | "releaseType"
          | "reviewType"
          | "routingAppCoverage"
          | "versionString"
        )[];
        /**
         * maximum number of related compatibilityVersions returned (when they are included)
         * @max 50
         */
        "limit[compatibilityVersions]"?: number;
      },
      params: RequestParams = {},
    ): Promise<GameCenterAppVersionResponse> =>
      this.request<GameCenterAppVersionResponse, ErrorResponse>({
        path: `/v1/gameCenterAppVersions/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterAppVersions
     * @name GameCenterAppVersionsUpdateInstance
     * @request PATCH:/v1/gameCenterAppVersions/{id}
     * @secure
     */
    updateInstance: (
      id: string,
      data: GameCenterAppVersionUpdateRequest,
      params: RequestParams = {},
    ): Promise<GameCenterAppVersionResponse> =>
      this.request<GameCenterAppVersionResponse, ErrorResponse>({
        path: `/v1/gameCenterAppVersions/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterAppVersions
     * @name GameCenterAppVersionsAppStoreVersionGetToOneRelated
     * @request GET:/v1/gameCenterAppVersions/{id}/appStoreVersion
     * @secure
     */
    appStoreVersionGetToOneRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type ageRatingDeclarations */
        "fields[ageRatingDeclarations]"?: (
          | "ageRatingOverride"
          | "alcoholTobaccoOrDrugUseOrReferences"
          | "contests"
          | "gambling"
          | "gamblingAndContests"
          | "gamblingSimulated"
          | "horrorOrFearThemes"
          | "kidsAgeBand"
          | "matureOrSuggestiveThemes"
          | "medicalOrTreatmentInformation"
          | "profanityOrCrudeHumor"
          | "seventeenPlus"
          | "sexualContentGraphicAndNudity"
          | "sexualContentOrNudity"
          | "unrestrictedWebAccess"
          | "violenceCartoonOrFantasy"
          | "violenceRealistic"
          | "violenceRealisticProlongedGraphicOrSadistic"
        )[];
        /** the fields to include for returned resources of type appStoreReviewDetails */
        "fields[appStoreReviewDetails]"?: (
          | "appStoreReviewAttachments"
          | "appStoreVersion"
          | "contactEmail"
          | "contactFirstName"
          | "contactLastName"
          | "contactPhone"
          | "demoAccountName"
          | "demoAccountPassword"
          | "demoAccountRequired"
          | "notes"
        )[];
        /** the fields to include for returned resources of type appStoreVersionLocalizations */
        "fields[appStoreVersionLocalizations]"?: (
          | "appPreviewSets"
          | "appScreenshotSets"
          | "appStoreVersion"
          | "description"
          | "keywords"
          | "locale"
          | "marketingUrl"
          | "promotionalText"
          | "supportUrl"
          | "whatsNew"
        )[];
        /** the fields to include for returned resources of type appStoreVersionExperiments */
        "fields[appStoreVersionExperiments]"?: (
          | "app"
          | "appStoreVersion"
          | "appStoreVersionExperimentTreatments"
          | "controlVersions"
          | "endDate"
          | "latestControlVersion"
          | "name"
          | "platform"
          | "reviewRequired"
          | "startDate"
          | "started"
          | "state"
          | "trafficProportion"
        )[];
        /** the fields to include for returned resources of type appStoreVersionSubmissions */
        "fields[appStoreVersionSubmissions]"?: "appStoreVersion"[];
        /** the fields to include for returned resources of type alternativeDistributionPackages */
        "fields[alternativeDistributionPackages]"?: ("appStoreVersion" | "versions")[];
        /** the fields to include for returned resources of type appStoreVersions */
        "fields[appStoreVersions]"?: (
          | "ageRatingDeclaration"
          | "alternativeDistributionPackage"
          | "app"
          | "appClipDefaultExperience"
          | "appStoreReviewDetail"
          | "appStoreState"
          | "appStoreVersionExperiments"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersionLocalizations"
          | "appStoreVersionPhasedRelease"
          | "appStoreVersionSubmission"
          | "appVersionState"
          | "build"
          | "copyright"
          | "createdDate"
          | "customerReviews"
          | "downloadable"
          | "earliestReleaseDate"
          | "platform"
          | "releaseType"
          | "reviewType"
          | "routingAppCoverage"
          | "versionString"
        )[];
        /** the fields to include for returned resources of type apps */
        "fields[apps]"?: (
          | "alternativeDistributionKey"
          | "analyticsReportRequests"
          | "appAvailability"
          | "appClips"
          | "appCustomProductPages"
          | "appEncryptionDeclarations"
          | "appEvents"
          | "appInfos"
          | "appPricePoints"
          | "appPriceSchedule"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersions"
          | "availableInNewTerritories"
          | "availableTerritories"
          | "betaAppLocalizations"
          | "betaAppReviewDetail"
          | "betaGroups"
          | "betaLicenseAgreement"
          | "betaTesters"
          | "builds"
          | "bundleId"
          | "ciProduct"
          | "contentRightsDeclaration"
          | "customerReviews"
          | "endUserLicenseAgreement"
          | "gameCenterDetail"
          | "gameCenterEnabledVersions"
          | "inAppPurchases"
          | "inAppPurchasesV2"
          | "isOrEverWasMadeForKids"
          | "marketplaceSearchDetail"
          | "name"
          | "perfPowerMetrics"
          | "preOrder"
          | "preReleaseVersions"
          | "pricePoints"
          | "prices"
          | "primaryLocale"
          | "promotedPurchases"
          | "reviewSubmissions"
          | "sku"
          | "subscriptionGracePeriod"
          | "subscriptionGroups"
          | "subscriptionStatusUrl"
          | "subscriptionStatusUrlForSandbox"
          | "subscriptionStatusUrlVersion"
          | "subscriptionStatusUrlVersionForSandbox"
        )[];
        /** the fields to include for returned resources of type routingAppCoverages */
        "fields[routingAppCoverages]"?: (
          | "appStoreVersion"
          | "assetDeliveryState"
          | "fileName"
          | "fileSize"
          | "sourceFileChecksum"
          | "uploadOperations"
          | "uploaded"
        )[];
        /** the fields to include for returned resources of type appClipDefaultExperiences */
        "fields[appClipDefaultExperiences]"?: (
          | "action"
          | "appClip"
          | "appClipAppStoreReviewDetail"
          | "appClipDefaultExperienceLocalizations"
          | "appClipDefaultExperienceTemplate"
          | "releaseWithAppStoreVersion"
        )[];
        /** the fields to include for returned resources of type appStoreVersionPhasedReleases */
        "fields[appStoreVersionPhasedReleases]"?: (
          | "appStoreVersion"
          | "currentDayNumber"
          | "phasedReleaseState"
          | "startDate"
          | "totalPauseDuration"
        )[];
        /** the fields to include for returned resources of type builds */
        "fields[builds]"?: (
          | "app"
          | "appEncryptionDeclaration"
          | "appStoreVersion"
          | "betaAppReviewSubmission"
          | "betaBuildLocalizations"
          | "betaGroups"
          | "buildAudienceType"
          | "buildBetaDetail"
          | "buildBundles"
          | "computedMinMacOsVersion"
          | "diagnosticSignatures"
          | "expirationDate"
          | "expired"
          | "iconAssetToken"
          | "icons"
          | "individualTesters"
          | "lsMinimumSystemVersion"
          | "minOsVersion"
          | "perfPowerMetrics"
          | "preReleaseVersion"
          | "processingState"
          | "uploadedDate"
          | "usesNonExemptEncryption"
          | "version"
        )[];
        /**
         * maximum number of related appStoreVersionLocalizations returned (when they are included)
         * @max 50
         */
        "limit[appStoreVersionLocalizations]"?: number;
        /**
         * maximum number of related appStoreVersionExperiments returned (when they are included)
         * @deprecated
         * @max 50
         */
        "limit[appStoreVersionExperiments]"?: number;
        /**
         * maximum number of related appStoreVersionExperimentsV2 returned (when they are included)
         * @max 50
         */
        "limit[appStoreVersionExperimentsV2]"?: number;
        /** comma-separated list of relationships to include */
        include?: (
          | "ageRatingDeclaration"
          | "alternativeDistributionPackage"
          | "app"
          | "appClipDefaultExperience"
          | "appStoreReviewDetail"
          | "appStoreVersionExperiments"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersionLocalizations"
          | "appStoreVersionPhasedRelease"
          | "appStoreVersionSubmission"
          | "build"
          | "routingAppCoverage"
        )[];
      },
      params: RequestParams = {},
    ): Promise<AppStoreVersionResponse> =>
      this.request<AppStoreVersionResponse, ErrorResponse>({
        path: `/v1/gameCenterAppVersions/${id}/appStoreVersion`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterAppVersions
     * @name GameCenterAppVersionsCompatibilityVersionsGetToManyRelationship
     * @request GET:/v1/gameCenterAppVersions/{id}/relationships/compatibilityVersions
     * @secure
     */
    compatibilityVersionsGetToManyRelationship: (
      id: string,
      query?: {
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
      },
      params: RequestParams = {},
    ): Promise<GameCenterAppVersionCompatibilityVersionsLinkagesResponse> =>
      this.request<GameCenterAppVersionCompatibilityVersionsLinkagesResponse, ErrorResponse>({
        path: `/v1/gameCenterAppVersions/${id}/relationships/compatibilityVersions`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterAppVersions
     * @name GameCenterAppVersionsCompatibilityVersionsCreateToManyRelationship
     * @request POST:/v1/gameCenterAppVersions/{id}/relationships/compatibilityVersions
     * @secure
     */
    compatibilityVersionsCreateToManyRelationship: (
      id: string,
      data: GameCenterAppVersionCompatibilityVersionsLinkagesRequest,
      params: RequestParams = {},
    ): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/gameCenterAppVersions/${id}/relationships/compatibilityVersions`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterAppVersions
     * @name GameCenterAppVersionsCompatibilityVersionsDeleteToManyRelationship
     * @request DELETE:/v1/gameCenterAppVersions/{id}/relationships/compatibilityVersions
     * @secure
     */
    compatibilityVersionsDeleteToManyRelationship: (
      id: string,
      data: GameCenterAppVersionCompatibilityVersionsLinkagesRequest,
      params: RequestParams = {},
    ): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/gameCenterAppVersions/${id}/relationships/compatibilityVersions`,
        method: "DELETE",
        body: data,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterAppVersions
     * @name GameCenterAppVersionsCompatibilityVersionsGetToManyRelated
     * @request GET:/v1/gameCenterAppVersions/{id}/compatibilityVersions
     * @secure
     */
    compatibilityVersionsGetToManyRelated: (
      id: string,
      query?: {
        /** filter by attribute 'enabled' */
        "filter[enabled]"?: string[];
        /** the fields to include for returned resources of type appStoreVersions */
        "fields[appStoreVersions]"?: (
          | "ageRatingDeclaration"
          | "alternativeDistributionPackage"
          | "app"
          | "appClipDefaultExperience"
          | "appStoreReviewDetail"
          | "appStoreState"
          | "appStoreVersionExperiments"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersionLocalizations"
          | "appStoreVersionPhasedRelease"
          | "appStoreVersionSubmission"
          | "appVersionState"
          | "build"
          | "copyright"
          | "createdDate"
          | "customerReviews"
          | "downloadable"
          | "earliestReleaseDate"
          | "platform"
          | "releaseType"
          | "reviewType"
          | "routingAppCoverage"
          | "versionString"
        )[];
        /** the fields to include for returned resources of type gameCenterAppVersions */
        "fields[gameCenterAppVersions]"?: ("appStoreVersion" | "compatibilityVersions" | "enabled")[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /**
         * maximum number of related compatibilityVersions returned (when they are included)
         * @max 50
         */
        "limit[compatibilityVersions]"?: number;
        /** comma-separated list of relationships to include */
        include?: ("appStoreVersion" | "compatibilityVersions")[];
      },
      params: RequestParams = {},
    ): Promise<GameCenterAppVersionsResponse> =>
      this.request<GameCenterAppVersionsResponse, ErrorResponse>({
        path: `/v1/gameCenterAppVersions/${id}/compatibilityVersions`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  gameCenterDetails = {
    /**
     * No description
     *
     * @tags GameCenterDetails
     * @name GameCenterDetailsCreateInstance
     * @request POST:/v1/gameCenterDetails
     * @secure
     */
    createInstance: (
      data: GameCenterDetailCreateRequest,
      params: RequestParams = {},
    ): Promise<GameCenterDetailResponse> =>
      this.request<GameCenterDetailResponse, ErrorResponse>({
        path: `/v1/gameCenterDetails`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterDetails
     * @name GameCenterDetailsGetInstance
     * @request GET:/v1/gameCenterDetails/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type gameCenterDetails */
        "fields[gameCenterDetails]"?: (
          | "achievementReleases"
          | "app"
          | "arcadeEnabled"
          | "challengeEnabled"
          | "defaultGroupLeaderboard"
          | "defaultLeaderboard"
          | "gameCenterAchievements"
          | "gameCenterAppVersions"
          | "gameCenterGroup"
          | "gameCenterLeaderboardSets"
          | "gameCenterLeaderboards"
          | "leaderboardReleases"
          | "leaderboardSetReleases"
        )[];
        /** comma-separated list of relationships to include */
        include?: (
          | "achievementReleases"
          | "app"
          | "defaultGroupLeaderboard"
          | "defaultLeaderboard"
          | "gameCenterAchievements"
          | "gameCenterAppVersions"
          | "gameCenterGroup"
          | "gameCenterLeaderboardSets"
          | "gameCenterLeaderboards"
          | "leaderboardReleases"
          | "leaderboardSetReleases"
        )[];
        /** the fields to include for returned resources of type gameCenterAchievementReleases */
        "fields[gameCenterAchievementReleases]"?: ("gameCenterAchievement" | "gameCenterDetail" | "live")[];
        /** the fields to include for returned resources of type gameCenterLeaderboardSetReleases */
        "fields[gameCenterLeaderboardSetReleases]"?: ("gameCenterDetail" | "gameCenterLeaderboardSet" | "live")[];
        /** the fields to include for returned resources of type gameCenterLeaderboardSets */
        "fields[gameCenterLeaderboardSets]"?: (
          | "gameCenterDetail"
          | "gameCenterGroup"
          | "gameCenterLeaderboards"
          | "groupLeaderboardSet"
          | "localizations"
          | "referenceName"
          | "releases"
          | "vendorIdentifier"
        )[];
        /** the fields to include for returned resources of type gameCenterGroups */
        "fields[gameCenterGroups]"?: (
          | "gameCenterAchievements"
          | "gameCenterDetails"
          | "gameCenterLeaderboardSets"
          | "gameCenterLeaderboards"
          | "referenceName"
        )[];
        /** the fields to include for returned resources of type gameCenterLeaderboards */
        "fields[gameCenterLeaderboards]"?: (
          | "archived"
          | "defaultFormatter"
          | "gameCenterDetail"
          | "gameCenterGroup"
          | "gameCenterLeaderboardSets"
          | "groupLeaderboard"
          | "localizations"
          | "recurrenceDuration"
          | "recurrenceRule"
          | "recurrenceStartDate"
          | "referenceName"
          | "releases"
          | "scoreRangeEnd"
          | "scoreRangeStart"
          | "scoreSortType"
          | "submissionType"
          | "vendorIdentifier"
        )[];
        /** the fields to include for returned resources of type gameCenterAchievements */
        "fields[gameCenterAchievements]"?: (
          | "archived"
          | "gameCenterDetail"
          | "gameCenterGroup"
          | "groupAchievement"
          | "localizations"
          | "points"
          | "referenceName"
          | "releases"
          | "repeatable"
          | "showBeforeEarned"
          | "vendorIdentifier"
        )[];
        /** the fields to include for returned resources of type gameCenterAppVersions */
        "fields[gameCenterAppVersions]"?: ("appStoreVersion" | "compatibilityVersions" | "enabled")[];
        /** the fields to include for returned resources of type gameCenterLeaderboardReleases */
        "fields[gameCenterLeaderboardReleases]"?: ("gameCenterDetail" | "gameCenterLeaderboard" | "live")[];
        /**
         * maximum number of related achievementReleases returned (when they are included)
         * @max 50
         */
        "limit[achievementReleases]"?: number;
        /**
         * maximum number of related gameCenterAchievements returned (when they are included)
         * @max 50
         */
        "limit[gameCenterAchievements]"?: number;
        /**
         * maximum number of related gameCenterAppVersions returned (when they are included)
         * @max 50
         */
        "limit[gameCenterAppVersions]"?: number;
        /**
         * maximum number of related gameCenterLeaderboardSets returned (when they are included)
         * @max 50
         */
        "limit[gameCenterLeaderboardSets]"?: number;
        /**
         * maximum number of related gameCenterLeaderboards returned (when they are included)
         * @max 50
         */
        "limit[gameCenterLeaderboards]"?: number;
        /**
         * maximum number of related leaderboardReleases returned (when they are included)
         * @max 50
         */
        "limit[leaderboardReleases]"?: number;
        /**
         * maximum number of related leaderboardSetReleases returned (when they are included)
         * @max 50
         */
        "limit[leaderboardSetReleases]"?: number;
      },
      params: RequestParams = {},
    ): Promise<GameCenterDetailResponse> =>
      this.request<GameCenterDetailResponse, ErrorResponse>({
        path: `/v1/gameCenterDetails/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterDetails
     * @name GameCenterDetailsUpdateInstance
     * @request PATCH:/v1/gameCenterDetails/{id}
     * @secure
     */
    updateInstance: (
      id: string,
      data: GameCenterDetailUpdateRequest,
      params: RequestParams = {},
    ): Promise<GameCenterDetailResponse> =>
      this.request<GameCenterDetailResponse, ErrorResponse>({
        path: `/v1/gameCenterDetails/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterDetails
     * @name GameCenterDetailsAchievementReleasesGetToManyRelated
     * @request GET:/v1/gameCenterDetails/{id}/achievementReleases
     * @secure
     */
    achievementReleasesGetToManyRelated: (
      id: string,
      query?: {
        /** filter by attribute 'live' */
        "filter[live]"?: string[];
        /** filter by id(s) of related 'gameCenterAchievement' */
        "filter[gameCenterAchievement]"?: string[];
        /** the fields to include for returned resources of type gameCenterAchievementReleases */
        "fields[gameCenterAchievementReleases]"?: ("gameCenterAchievement" | "gameCenterDetail" | "live")[];
        /** the fields to include for returned resources of type gameCenterDetails */
        "fields[gameCenterDetails]"?: (
          | "achievementReleases"
          | "app"
          | "arcadeEnabled"
          | "challengeEnabled"
          | "defaultGroupLeaderboard"
          | "defaultLeaderboard"
          | "gameCenterAchievements"
          | "gameCenterAppVersions"
          | "gameCenterGroup"
          | "gameCenterLeaderboardSets"
          | "gameCenterLeaderboards"
          | "leaderboardReleases"
          | "leaderboardSetReleases"
        )[];
        /** the fields to include for returned resources of type gameCenterAchievements */
        "fields[gameCenterAchievements]"?: (
          | "archived"
          | "gameCenterDetail"
          | "gameCenterGroup"
          | "groupAchievement"
          | "localizations"
          | "points"
          | "referenceName"
          | "releases"
          | "repeatable"
          | "showBeforeEarned"
          | "vendorIdentifier"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /** comma-separated list of relationships to include */
        include?: ("gameCenterAchievement" | "gameCenterDetail")[];
      },
      params: RequestParams = {},
    ): Promise<GameCenterAchievementReleasesResponse> =>
      this.request<GameCenterAchievementReleasesResponse, ErrorResponse>({
        path: `/v1/gameCenterDetails/${id}/achievementReleases`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterDetails
     * @name GameCenterDetailsGameCenterAchievementsGetToManyRelationship
     * @request GET:/v1/gameCenterDetails/{id}/relationships/gameCenterAchievements
     * @secure
     */
    gameCenterAchievementsGetToManyRelationship: (
      id: string,
      query?: {
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
      },
      params: RequestParams = {},
    ): Promise<GameCenterDetailGameCenterAchievementsLinkagesResponse> =>
      this.request<GameCenterDetailGameCenterAchievementsLinkagesResponse, ErrorResponse>({
        path: `/v1/gameCenterDetails/${id}/relationships/gameCenterAchievements`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterDetails
     * @name GameCenterDetailsGameCenterAchievementsReplaceToManyRelationship
     * @request PATCH:/v1/gameCenterDetails/{id}/relationships/gameCenterAchievements
     * @secure
     */
    gameCenterAchievementsReplaceToManyRelationship: (
      id: string,
      data: GameCenterDetailGameCenterAchievementsLinkagesRequest,
      params: RequestParams = {},
    ): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/gameCenterDetails/${id}/relationships/gameCenterAchievements`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterDetails
     * @name GameCenterDetailsGameCenterAchievementsGetToManyRelated
     * @request GET:/v1/gameCenterDetails/{id}/gameCenterAchievements
     * @secure
     */
    gameCenterAchievementsGetToManyRelated: (
      id: string,
      query?: {
        /** filter by attribute 'archived' */
        "filter[archived]"?: string[];
        /** filter by attribute 'referenceName' */
        "filter[referenceName]"?: string[];
        /** filter by id(s) */
        "filter[id]"?: string[];
        /** the fields to include for returned resources of type gameCenterAchievementReleases */
        "fields[gameCenterAchievementReleases]"?: ("gameCenterAchievement" | "gameCenterDetail" | "live")[];
        /** the fields to include for returned resources of type gameCenterGroups */
        "fields[gameCenterGroups]"?: (
          | "gameCenterAchievements"
          | "gameCenterDetails"
          | "gameCenterLeaderboardSets"
          | "gameCenterLeaderboards"
          | "referenceName"
        )[];
        /** the fields to include for returned resources of type gameCenterDetails */
        "fields[gameCenterDetails]"?: (
          | "achievementReleases"
          | "app"
          | "arcadeEnabled"
          | "challengeEnabled"
          | "defaultGroupLeaderboard"
          | "defaultLeaderboard"
          | "gameCenterAchievements"
          | "gameCenterAppVersions"
          | "gameCenterGroup"
          | "gameCenterLeaderboardSets"
          | "gameCenterLeaderboards"
          | "leaderboardReleases"
          | "leaderboardSetReleases"
        )[];
        /** the fields to include for returned resources of type gameCenterAchievementLocalizations */
        "fields[gameCenterAchievementLocalizations]"?: (
          | "afterEarnedDescription"
          | "beforeEarnedDescription"
          | "gameCenterAchievement"
          | "gameCenterAchievementImage"
          | "locale"
          | "name"
        )[];
        /** the fields to include for returned resources of type gameCenterAchievements */
        "fields[gameCenterAchievements]"?: (
          | "archived"
          | "gameCenterDetail"
          | "gameCenterGroup"
          | "groupAchievement"
          | "localizations"
          | "points"
          | "referenceName"
          | "releases"
          | "repeatable"
          | "showBeforeEarned"
          | "vendorIdentifier"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /**
         * maximum number of related localizations returned (when they are included)
         * @max 50
         */
        "limit[localizations]"?: number;
        /**
         * maximum number of related releases returned (when they are included)
         * @max 50
         */
        "limit[releases]"?: number;
        /** comma-separated list of relationships to include */
        include?: ("gameCenterDetail" | "gameCenterGroup" | "groupAchievement" | "localizations" | "releases")[];
      },
      params: RequestParams = {},
    ): Promise<GameCenterAchievementsResponse> =>
      this.request<GameCenterAchievementsResponse, ErrorResponse>({
        path: `/v1/gameCenterDetails/${id}/gameCenterAchievements`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterDetails
     * @name GameCenterDetailsGameCenterAppVersionsGetToManyRelated
     * @request GET:/v1/gameCenterDetails/{id}/gameCenterAppVersions
     * @secure
     */
    gameCenterAppVersionsGetToManyRelated: (
      id: string,
      query?: {
        /** filter by attribute 'enabled' */
        "filter[enabled]"?: string[];
        /** the fields to include for returned resources of type appStoreVersions */
        "fields[appStoreVersions]"?: (
          | "ageRatingDeclaration"
          | "alternativeDistributionPackage"
          | "app"
          | "appClipDefaultExperience"
          | "appStoreReviewDetail"
          | "appStoreState"
          | "appStoreVersionExperiments"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersionLocalizations"
          | "appStoreVersionPhasedRelease"
          | "appStoreVersionSubmission"
          | "appVersionState"
          | "build"
          | "copyright"
          | "createdDate"
          | "customerReviews"
          | "downloadable"
          | "earliestReleaseDate"
          | "platform"
          | "releaseType"
          | "reviewType"
          | "routingAppCoverage"
          | "versionString"
        )[];
        /** the fields to include for returned resources of type gameCenterAppVersions */
        "fields[gameCenterAppVersions]"?: ("appStoreVersion" | "compatibilityVersions" | "enabled")[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /**
         * maximum number of related compatibilityVersions returned (when they are included)
         * @max 50
         */
        "limit[compatibilityVersions]"?: number;
        /** comma-separated list of relationships to include */
        include?: ("appStoreVersion" | "compatibilityVersions")[];
      },
      params: RequestParams = {},
    ): Promise<GameCenterAppVersionsResponse> =>
      this.request<GameCenterAppVersionsResponse, ErrorResponse>({
        path: `/v1/gameCenterDetails/${id}/gameCenterAppVersions`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterDetails
     * @name GameCenterDetailsGameCenterGroupGetToOneRelated
     * @request GET:/v1/gameCenterDetails/{id}/gameCenterGroup
     * @secure
     */
    gameCenterGroupGetToOneRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type gameCenterLeaderboardSets */
        "fields[gameCenterLeaderboardSets]"?: (
          | "gameCenterDetail"
          | "gameCenterGroup"
          | "gameCenterLeaderboards"
          | "groupLeaderboardSet"
          | "localizations"
          | "referenceName"
          | "releases"
          | "vendorIdentifier"
        )[];
        /** the fields to include for returned resources of type gameCenterGroups */
        "fields[gameCenterGroups]"?: (
          | "gameCenterAchievements"
          | "gameCenterDetails"
          | "gameCenterLeaderboardSets"
          | "gameCenterLeaderboards"
          | "referenceName"
        )[];
        /** the fields to include for returned resources of type gameCenterDetails */
        "fields[gameCenterDetails]"?: (
          | "achievementReleases"
          | "app"
          | "arcadeEnabled"
          | "challengeEnabled"
          | "defaultGroupLeaderboard"
          | "defaultLeaderboard"
          | "gameCenterAchievements"
          | "gameCenterAppVersions"
          | "gameCenterGroup"
          | "gameCenterLeaderboardSets"
          | "gameCenterLeaderboards"
          | "leaderboardReleases"
          | "leaderboardSetReleases"
        )[];
        /** the fields to include for returned resources of type gameCenterLeaderboards */
        "fields[gameCenterLeaderboards]"?: (
          | "archived"
          | "defaultFormatter"
          | "gameCenterDetail"
          | "gameCenterGroup"
          | "gameCenterLeaderboardSets"
          | "groupLeaderboard"
          | "localizations"
          | "recurrenceDuration"
          | "recurrenceRule"
          | "recurrenceStartDate"
          | "referenceName"
          | "releases"
          | "scoreRangeEnd"
          | "scoreRangeStart"
          | "scoreSortType"
          | "submissionType"
          | "vendorIdentifier"
        )[];
        /** the fields to include for returned resources of type gameCenterAchievements */
        "fields[gameCenterAchievements]"?: (
          | "archived"
          | "gameCenterDetail"
          | "gameCenterGroup"
          | "groupAchievement"
          | "localizations"
          | "points"
          | "referenceName"
          | "releases"
          | "repeatable"
          | "showBeforeEarned"
          | "vendorIdentifier"
        )[];
        /**
         * maximum number of related gameCenterDetails returned (when they are included)
         * @max 50
         */
        "limit[gameCenterDetails]"?: number;
        /**
         * maximum number of related gameCenterLeaderboards returned (when they are included)
         * @max 50
         */
        "limit[gameCenterLeaderboards]"?: number;
        /**
         * maximum number of related gameCenterLeaderboardSets returned (when they are included)
         * @max 50
         */
        "limit[gameCenterLeaderboardSets]"?: number;
        /**
         * maximum number of related gameCenterAchievements returned (when they are included)
         * @max 50
         */
        "limit[gameCenterAchievements]"?: number;
        /** comma-separated list of relationships to include */
        include?: (
          | "gameCenterAchievements"
          | "gameCenterDetails"
          | "gameCenterLeaderboardSets"
          | "gameCenterLeaderboards"
        )[];
      },
      params: RequestParams = {},
    ): Promise<GameCenterGroupResponse> =>
      this.request<GameCenterGroupResponse, ErrorResponse>({
        path: `/v1/gameCenterDetails/${id}/gameCenterGroup`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterDetails
     * @name GameCenterDetailsGameCenterLeaderboardSetsGetToManyRelationship
     * @request GET:/v1/gameCenterDetails/{id}/relationships/gameCenterLeaderboardSets
     * @secure
     */
    gameCenterLeaderboardSetsGetToManyRelationship: (
      id: string,
      query?: {
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
      },
      params: RequestParams = {},
    ): Promise<GameCenterDetailGameCenterLeaderboardSetsLinkagesResponse> =>
      this.request<GameCenterDetailGameCenterLeaderboardSetsLinkagesResponse, ErrorResponse>({
        path: `/v1/gameCenterDetails/${id}/relationships/gameCenterLeaderboardSets`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterDetails
     * @name GameCenterDetailsGameCenterLeaderboardSetsReplaceToManyRelationship
     * @request PATCH:/v1/gameCenterDetails/{id}/relationships/gameCenterLeaderboardSets
     * @secure
     */
    gameCenterLeaderboardSetsReplaceToManyRelationship: (
      id: string,
      data: GameCenterDetailGameCenterLeaderboardSetsLinkagesRequest,
      params: RequestParams = {},
    ): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/gameCenterDetails/${id}/relationships/gameCenterLeaderboardSets`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterDetails
     * @name GameCenterDetailsGameCenterLeaderboardSetsGetToManyRelated
     * @request GET:/v1/gameCenterDetails/{id}/gameCenterLeaderboardSets
     * @secure
     */
    gameCenterLeaderboardSetsGetToManyRelated: (
      id: string,
      query?: {
        /** filter by attribute 'referenceName' */
        "filter[referenceName]"?: string[];
        /** filter by id(s) */
        "filter[id]"?: string[];
        /** the fields to include for returned resources of type gameCenterLeaderboardSetLocalizations */
        "fields[gameCenterLeaderboardSetLocalizations]"?: (
          | "gameCenterLeaderboardSet"
          | "gameCenterLeaderboardSetImage"
          | "locale"
          | "name"
        )[];
        /** the fields to include for returned resources of type gameCenterLeaderboardSetReleases */
        "fields[gameCenterLeaderboardSetReleases]"?: ("gameCenterDetail" | "gameCenterLeaderboardSet" | "live")[];
        /** the fields to include for returned resources of type gameCenterLeaderboardSets */
        "fields[gameCenterLeaderboardSets]"?: (
          | "gameCenterDetail"
          | "gameCenterGroup"
          | "gameCenterLeaderboards"
          | "groupLeaderboardSet"
          | "localizations"
          | "referenceName"
          | "releases"
          | "vendorIdentifier"
        )[];
        /** the fields to include for returned resources of type gameCenterGroups */
        "fields[gameCenterGroups]"?: (
          | "gameCenterAchievements"
          | "gameCenterDetails"
          | "gameCenterLeaderboardSets"
          | "gameCenterLeaderboards"
          | "referenceName"
        )[];
        /** the fields to include for returned resources of type gameCenterDetails */
        "fields[gameCenterDetails]"?: (
          | "achievementReleases"
          | "app"
          | "arcadeEnabled"
          | "challengeEnabled"
          | "defaultGroupLeaderboard"
          | "defaultLeaderboard"
          | "gameCenterAchievements"
          | "gameCenterAppVersions"
          | "gameCenterGroup"
          | "gameCenterLeaderboardSets"
          | "gameCenterLeaderboards"
          | "leaderboardReleases"
          | "leaderboardSetReleases"
        )[];
        /** the fields to include for returned resources of type gameCenterLeaderboards */
        "fields[gameCenterLeaderboards]"?: (
          | "archived"
          | "defaultFormatter"
          | "gameCenterDetail"
          | "gameCenterGroup"
          | "gameCenterLeaderboardSets"
          | "groupLeaderboard"
          | "localizations"
          | "recurrenceDuration"
          | "recurrenceRule"
          | "recurrenceStartDate"
          | "referenceName"
          | "releases"
          | "scoreRangeEnd"
          | "scoreRangeStart"
          | "scoreSortType"
          | "submissionType"
          | "vendorIdentifier"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /**
         * maximum number of related localizations returned (when they are included)
         * @max 50
         */
        "limit[localizations]"?: number;
        /**
         * maximum number of related gameCenterLeaderboards returned (when they are included)
         * @max 50
         */
        "limit[gameCenterLeaderboards]"?: number;
        /**
         * maximum number of related releases returned (when they are included)
         * @max 50
         */
        "limit[releases]"?: number;
        /** comma-separated list of relationships to include */
        include?: (
          | "gameCenterDetail"
          | "gameCenterGroup"
          | "gameCenterLeaderboards"
          | "groupLeaderboardSet"
          | "localizations"
          | "releases"
        )[];
      },
      params: RequestParams = {},
    ): Promise<GameCenterLeaderboardSetsResponse> =>
      this.request<GameCenterLeaderboardSetsResponse, ErrorResponse>({
        path: `/v1/gameCenterDetails/${id}/gameCenterLeaderboardSets`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterDetails
     * @name GameCenterDetailsGameCenterLeaderboardsGetToManyRelationship
     * @request GET:/v1/gameCenterDetails/{id}/relationships/gameCenterLeaderboards
     * @secure
     */
    gameCenterLeaderboardsGetToManyRelationship: (
      id: string,
      query?: {
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
      },
      params: RequestParams = {},
    ): Promise<GameCenterDetailGameCenterLeaderboardsLinkagesResponse> =>
      this.request<GameCenterDetailGameCenterLeaderboardsLinkagesResponse, ErrorResponse>({
        path: `/v1/gameCenterDetails/${id}/relationships/gameCenterLeaderboards`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterDetails
     * @name GameCenterDetailsGameCenterLeaderboardsReplaceToManyRelationship
     * @request PATCH:/v1/gameCenterDetails/{id}/relationships/gameCenterLeaderboards
     * @secure
     */
    gameCenterLeaderboardsReplaceToManyRelationship: (
      id: string,
      data: GameCenterDetailGameCenterLeaderboardsLinkagesRequest,
      params: RequestParams = {},
    ): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/gameCenterDetails/${id}/relationships/gameCenterLeaderboards`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterDetails
     * @name GameCenterDetailsGameCenterLeaderboardsGetToManyRelated
     * @request GET:/v1/gameCenterDetails/{id}/gameCenterLeaderboards
     * @secure
     */
    gameCenterLeaderboardsGetToManyRelated: (
      id: string,
      query?: {
        /** filter by attribute 'archived' */
        "filter[archived]"?: string[];
        /** filter by attribute 'referenceName' */
        "filter[referenceName]"?: string[];
        /** filter by id(s) */
        "filter[id]"?: string[];
        /** the fields to include for returned resources of type gameCenterLeaderboardLocalizations */
        "fields[gameCenterLeaderboardLocalizations]"?: (
          | "formatterOverride"
          | "formatterSuffix"
          | "formatterSuffixSingular"
          | "gameCenterLeaderboard"
          | "gameCenterLeaderboardImage"
          | "locale"
          | "name"
        )[];
        /** the fields to include for returned resources of type gameCenterLeaderboardSets */
        "fields[gameCenterLeaderboardSets]"?: (
          | "gameCenterDetail"
          | "gameCenterGroup"
          | "gameCenterLeaderboards"
          | "groupLeaderboardSet"
          | "localizations"
          | "referenceName"
          | "releases"
          | "vendorIdentifier"
        )[];
        /** the fields to include for returned resources of type gameCenterGroups */
        "fields[gameCenterGroups]"?: (
          | "gameCenterAchievements"
          | "gameCenterDetails"
          | "gameCenterLeaderboardSets"
          | "gameCenterLeaderboards"
          | "referenceName"
        )[];
        /** the fields to include for returned resources of type gameCenterDetails */
        "fields[gameCenterDetails]"?: (
          | "achievementReleases"
          | "app"
          | "arcadeEnabled"
          | "challengeEnabled"
          | "defaultGroupLeaderboard"
          | "defaultLeaderboard"
          | "gameCenterAchievements"
          | "gameCenterAppVersions"
          | "gameCenterGroup"
          | "gameCenterLeaderboardSets"
          | "gameCenterLeaderboards"
          | "leaderboardReleases"
          | "leaderboardSetReleases"
        )[];
        /** the fields to include for returned resources of type gameCenterLeaderboards */
        "fields[gameCenterLeaderboards]"?: (
          | "archived"
          | "defaultFormatter"
          | "gameCenterDetail"
          | "gameCenterGroup"
          | "gameCenterLeaderboardSets"
          | "groupLeaderboard"
          | "localizations"
          | "recurrenceDuration"
          | "recurrenceRule"
          | "recurrenceStartDate"
          | "referenceName"
          | "releases"
          | "scoreRangeEnd"
          | "scoreRangeStart"
          | "scoreSortType"
          | "submissionType"
          | "vendorIdentifier"
        )[];
        /** the fields to include for returned resources of type gameCenterLeaderboardReleases */
        "fields[gameCenterLeaderboardReleases]"?: ("gameCenterDetail" | "gameCenterLeaderboard" | "live")[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /**
         * maximum number of related gameCenterLeaderboardSets returned (when they are included)
         * @max 50
         */
        "limit[gameCenterLeaderboardSets]"?: number;
        /**
         * maximum number of related localizations returned (when they are included)
         * @max 50
         */
        "limit[localizations]"?: number;
        /**
         * maximum number of related releases returned (when they are included)
         * @max 50
         */
        "limit[releases]"?: number;
        /** comma-separated list of relationships to include */
        include?: (
          | "gameCenterDetail"
          | "gameCenterGroup"
          | "gameCenterLeaderboardSets"
          | "groupLeaderboard"
          | "localizations"
          | "releases"
        )[];
      },
      params: RequestParams = {},
    ): Promise<GameCenterLeaderboardsResponse> =>
      this.request<GameCenterLeaderboardsResponse, ErrorResponse>({
        path: `/v1/gameCenterDetails/${id}/gameCenterLeaderboards`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterDetails
     * @name GameCenterDetailsLeaderboardReleasesGetToManyRelated
     * @request GET:/v1/gameCenterDetails/{id}/leaderboardReleases
     * @secure
     */
    leaderboardReleasesGetToManyRelated: (
      id: string,
      query?: {
        /** filter by attribute 'live' */
        "filter[live]"?: string[];
        /** filter by id(s) of related 'gameCenterLeaderboard' */
        "filter[gameCenterLeaderboard]"?: string[];
        /** the fields to include for returned resources of type gameCenterDetails */
        "fields[gameCenterDetails]"?: (
          | "achievementReleases"
          | "app"
          | "arcadeEnabled"
          | "challengeEnabled"
          | "defaultGroupLeaderboard"
          | "defaultLeaderboard"
          | "gameCenterAchievements"
          | "gameCenterAppVersions"
          | "gameCenterGroup"
          | "gameCenterLeaderboardSets"
          | "gameCenterLeaderboards"
          | "leaderboardReleases"
          | "leaderboardSetReleases"
        )[];
        /** the fields to include for returned resources of type gameCenterLeaderboards */
        "fields[gameCenterLeaderboards]"?: (
          | "archived"
          | "defaultFormatter"
          | "gameCenterDetail"
          | "gameCenterGroup"
          | "gameCenterLeaderboardSets"
          | "groupLeaderboard"
          | "localizations"
          | "recurrenceDuration"
          | "recurrenceRule"
          | "recurrenceStartDate"
          | "referenceName"
          | "releases"
          | "scoreRangeEnd"
          | "scoreRangeStart"
          | "scoreSortType"
          | "submissionType"
          | "vendorIdentifier"
        )[];
        /** the fields to include for returned resources of type gameCenterLeaderboardReleases */
        "fields[gameCenterLeaderboardReleases]"?: ("gameCenterDetail" | "gameCenterLeaderboard" | "live")[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /** comma-separated list of relationships to include */
        include?: ("gameCenterDetail" | "gameCenterLeaderboard")[];
      },
      params: RequestParams = {},
    ): Promise<GameCenterLeaderboardReleasesResponse> =>
      this.request<GameCenterLeaderboardReleasesResponse, ErrorResponse>({
        path: `/v1/gameCenterDetails/${id}/leaderboardReleases`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterDetails
     * @name GameCenterDetailsLeaderboardSetReleasesGetToManyRelated
     * @request GET:/v1/gameCenterDetails/{id}/leaderboardSetReleases
     * @secure
     */
    leaderboardSetReleasesGetToManyRelated: (
      id: string,
      query?: {
        /** filter by attribute 'live' */
        "filter[live]"?: string[];
        /** filter by id(s) of related 'gameCenterLeaderboardSet' */
        "filter[gameCenterLeaderboardSet]"?: string[];
        /** the fields to include for returned resources of type gameCenterLeaderboardSetReleases */
        "fields[gameCenterLeaderboardSetReleases]"?: ("gameCenterDetail" | "gameCenterLeaderboardSet" | "live")[];
        /** the fields to include for returned resources of type gameCenterLeaderboardSets */
        "fields[gameCenterLeaderboardSets]"?: (
          | "gameCenterDetail"
          | "gameCenterGroup"
          | "gameCenterLeaderboards"
          | "groupLeaderboardSet"
          | "localizations"
          | "referenceName"
          | "releases"
          | "vendorIdentifier"
        )[];
        /** the fields to include for returned resources of type gameCenterDetails */
        "fields[gameCenterDetails]"?: (
          | "achievementReleases"
          | "app"
          | "arcadeEnabled"
          | "challengeEnabled"
          | "defaultGroupLeaderboard"
          | "defaultLeaderboard"
          | "gameCenterAchievements"
          | "gameCenterAppVersions"
          | "gameCenterGroup"
          | "gameCenterLeaderboardSets"
          | "gameCenterLeaderboards"
          | "leaderboardReleases"
          | "leaderboardSetReleases"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /** comma-separated list of relationships to include */
        include?: ("gameCenterDetail" | "gameCenterLeaderboardSet")[];
      },
      params: RequestParams = {},
    ): Promise<GameCenterLeaderboardSetReleasesResponse> =>
      this.request<GameCenterLeaderboardSetReleasesResponse, ErrorResponse>({
        path: `/v1/gameCenterDetails/${id}/leaderboardSetReleases`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterDetails, Metrics
     * @name GameCenterDetailsClassicMatchmakingRequestsGetMetrics
     * @request GET:/v1/gameCenterDetails/{id}/metrics/classicMatchmakingRequests
     * @secure
     */
    classicMatchmakingRequestsGetMetrics: (
      id: string,
      query: {
        /**
         * maximum number of groups to return per page
         * @max 200
         */
        limit?: number;
        /** the granularity of the per-group dataset */
        granularity: "P1D" | "PT1H" | "PT15M";
        /** the dimension by which to group the results */
        groupBy?: "result"[];
        /** filter by 'result' attribute dimension */
        "filter[result]"?: "MATCHED" | "CANCELED" | "EXPIRED";
        /** comma-separated list of sort expressions; metrics will be sorted as specified */
        sort?: (
          | "averageSecondsInQueue"
          | "-averageSecondsInQueue"
          | "count"
          | "-count"
          | "p50SecondsInQueue"
          | "-p50SecondsInQueue"
          | "p95SecondsInQueue"
          | "-p95SecondsInQueue"
        )[];
      },
      params: RequestParams = {},
    ): Promise<GameCenterMatchmakingAppRequestsV1MetricResponse> =>
      this.request<GameCenterMatchmakingAppRequestsV1MetricResponse, ErrorResponse>({
        path: `/v1/gameCenterDetails/${id}/metrics/classicMatchmakingRequests`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterDetails, Metrics
     * @name GameCenterDetailsRuleBasedMatchmakingRequestsGetMetrics
     * @request GET:/v1/gameCenterDetails/{id}/metrics/ruleBasedMatchmakingRequests
     * @secure
     */
    ruleBasedMatchmakingRequestsGetMetrics: (
      id: string,
      query: {
        /**
         * maximum number of groups to return per page
         * @max 200
         */
        limit?: number;
        /** the granularity of the per-group dataset */
        granularity: "P1D" | "PT1H" | "PT15M";
        /** the dimension by which to group the results */
        groupBy?: "result"[];
        /** filter by 'result' attribute dimension */
        "filter[result]"?: "MATCHED" | "CANCELED" | "EXPIRED";
        /** comma-separated list of sort expressions; metrics will be sorted as specified */
        sort?: (
          | "averageSecondsInQueue"
          | "-averageSecondsInQueue"
          | "count"
          | "-count"
          | "p50SecondsInQueue"
          | "-p50SecondsInQueue"
          | "p95SecondsInQueue"
          | "-p95SecondsInQueue"
        )[];
      },
      params: RequestParams = {},
    ): Promise<GameCenterMatchmakingAppRequestsV1MetricResponse> =>
      this.request<GameCenterMatchmakingAppRequestsV1MetricResponse, ErrorResponse>({
        path: `/v1/gameCenterDetails/${id}/metrics/ruleBasedMatchmakingRequests`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  gameCenterGroups = {
    /**
     * No description
     *
     * @tags GameCenterGroups
     * @name GameCenterGroupsGetCollection
     * @request GET:/v1/gameCenterGroups
     * @secure
     */
    getCollection: (
      query?: {
        /** filter by id(s) of related 'gameCenterDetails' */
        "filter[gameCenterDetails]"?: string[];
        /** the fields to include for returned resources of type gameCenterGroups */
        "fields[gameCenterGroups]"?: (
          | "gameCenterAchievements"
          | "gameCenterDetails"
          | "gameCenterLeaderboardSets"
          | "gameCenterLeaderboards"
          | "referenceName"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /** comma-separated list of relationships to include */
        include?: (
          | "gameCenterAchievements"
          | "gameCenterDetails"
          | "gameCenterLeaderboardSets"
          | "gameCenterLeaderboards"
        )[];
        /** the fields to include for returned resources of type gameCenterLeaderboardSets */
        "fields[gameCenterLeaderboardSets]"?: (
          | "gameCenterDetail"
          | "gameCenterGroup"
          | "gameCenterLeaderboards"
          | "groupLeaderboardSet"
          | "localizations"
          | "referenceName"
          | "releases"
          | "vendorIdentifier"
        )[];
        /** the fields to include for returned resources of type gameCenterDetails */
        "fields[gameCenterDetails]"?: (
          | "achievementReleases"
          | "app"
          | "arcadeEnabled"
          | "challengeEnabled"
          | "defaultGroupLeaderboard"
          | "defaultLeaderboard"
          | "gameCenterAchievements"
          | "gameCenterAppVersions"
          | "gameCenterGroup"
          | "gameCenterLeaderboardSets"
          | "gameCenterLeaderboards"
          | "leaderboardReleases"
          | "leaderboardSetReleases"
        )[];
        /** the fields to include for returned resources of type gameCenterLeaderboards */
        "fields[gameCenterLeaderboards]"?: (
          | "archived"
          | "defaultFormatter"
          | "gameCenterDetail"
          | "gameCenterGroup"
          | "gameCenterLeaderboardSets"
          | "groupLeaderboard"
          | "localizations"
          | "recurrenceDuration"
          | "recurrenceRule"
          | "recurrenceStartDate"
          | "referenceName"
          | "releases"
          | "scoreRangeEnd"
          | "scoreRangeStart"
          | "scoreSortType"
          | "submissionType"
          | "vendorIdentifier"
        )[];
        /** the fields to include for returned resources of type gameCenterAchievements */
        "fields[gameCenterAchievements]"?: (
          | "archived"
          | "gameCenterDetail"
          | "gameCenterGroup"
          | "groupAchievement"
          | "localizations"
          | "points"
          | "referenceName"
          | "releases"
          | "repeatable"
          | "showBeforeEarned"
          | "vendorIdentifier"
        )[];
        /**
         * maximum number of related gameCenterAchievements returned (when they are included)
         * @max 50
         */
        "limit[gameCenterAchievements]"?: number;
        /**
         * maximum number of related gameCenterDetails returned (when they are included)
         * @max 50
         */
        "limit[gameCenterDetails]"?: number;
        /**
         * maximum number of related gameCenterLeaderboardSets returned (when they are included)
         * @max 50
         */
        "limit[gameCenterLeaderboardSets]"?: number;
        /**
         * maximum number of related gameCenterLeaderboards returned (when they are included)
         * @max 50
         */
        "limit[gameCenterLeaderboards]"?: number;
      },
      params: RequestParams = {},
    ): Promise<GameCenterGroupsResponse> =>
      this.request<GameCenterGroupsResponse, ErrorResponse>({
        path: `/v1/gameCenterGroups`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterGroups
     * @name GameCenterGroupsCreateInstance
     * @request POST:/v1/gameCenterGroups
     * @secure
     */
    createInstance: (
      data: GameCenterGroupCreateRequest,
      params: RequestParams = {},
    ): Promise<GameCenterGroupResponse> =>
      this.request<GameCenterGroupResponse, ErrorResponse>({
        path: `/v1/gameCenterGroups`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterGroups
     * @name GameCenterGroupsGetInstance
     * @request GET:/v1/gameCenterGroups/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type gameCenterGroups */
        "fields[gameCenterGroups]"?: (
          | "gameCenterAchievements"
          | "gameCenterDetails"
          | "gameCenterLeaderboardSets"
          | "gameCenterLeaderboards"
          | "referenceName"
        )[];
        /** comma-separated list of relationships to include */
        include?: (
          | "gameCenterAchievements"
          | "gameCenterDetails"
          | "gameCenterLeaderboardSets"
          | "gameCenterLeaderboards"
        )[];
        /** the fields to include for returned resources of type gameCenterLeaderboardSets */
        "fields[gameCenterLeaderboardSets]"?: (
          | "gameCenterDetail"
          | "gameCenterGroup"
          | "gameCenterLeaderboards"
          | "groupLeaderboardSet"
          | "localizations"
          | "referenceName"
          | "releases"
          | "vendorIdentifier"
        )[];
        /** the fields to include for returned resources of type gameCenterDetails */
        "fields[gameCenterDetails]"?: (
          | "achievementReleases"
          | "app"
          | "arcadeEnabled"
          | "challengeEnabled"
          | "defaultGroupLeaderboard"
          | "defaultLeaderboard"
          | "gameCenterAchievements"
          | "gameCenterAppVersions"
          | "gameCenterGroup"
          | "gameCenterLeaderboardSets"
          | "gameCenterLeaderboards"
          | "leaderboardReleases"
          | "leaderboardSetReleases"
        )[];
        /** the fields to include for returned resources of type gameCenterLeaderboards */
        "fields[gameCenterLeaderboards]"?: (
          | "archived"
          | "defaultFormatter"
          | "gameCenterDetail"
          | "gameCenterGroup"
          | "gameCenterLeaderboardSets"
          | "groupLeaderboard"
          | "localizations"
          | "recurrenceDuration"
          | "recurrenceRule"
          | "recurrenceStartDate"
          | "referenceName"
          | "releases"
          | "scoreRangeEnd"
          | "scoreRangeStart"
          | "scoreSortType"
          | "submissionType"
          | "vendorIdentifier"
        )[];
        /** the fields to include for returned resources of type gameCenterAchievements */
        "fields[gameCenterAchievements]"?: (
          | "archived"
          | "gameCenterDetail"
          | "gameCenterGroup"
          | "groupAchievement"
          | "localizations"
          | "points"
          | "referenceName"
          | "releases"
          | "repeatable"
          | "showBeforeEarned"
          | "vendorIdentifier"
        )[];
        /**
         * maximum number of related gameCenterAchievements returned (when they are included)
         * @max 50
         */
        "limit[gameCenterAchievements]"?: number;
        /**
         * maximum number of related gameCenterDetails returned (when they are included)
         * @max 50
         */
        "limit[gameCenterDetails]"?: number;
        /**
         * maximum number of related gameCenterLeaderboardSets returned (when they are included)
         * @max 50
         */
        "limit[gameCenterLeaderboardSets]"?: number;
        /**
         * maximum number of related gameCenterLeaderboards returned (when they are included)
         * @max 50
         */
        "limit[gameCenterLeaderboards]"?: number;
      },
      params: RequestParams = {},
    ): Promise<GameCenterGroupResponse> =>
      this.request<GameCenterGroupResponse, ErrorResponse>({
        path: `/v1/gameCenterGroups/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterGroups
     * @name GameCenterGroupsUpdateInstance
     * @request PATCH:/v1/gameCenterGroups/{id}
     * @secure
     */
    updateInstance: (
      id: string,
      data: GameCenterGroupUpdateRequest,
      params: RequestParams = {},
    ): Promise<GameCenterGroupResponse> =>
      this.request<GameCenterGroupResponse, ErrorResponse>({
        path: `/v1/gameCenterGroups/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterGroups
     * @name GameCenterGroupsDeleteInstance
     * @request DELETE:/v1/gameCenterGroups/{id}
     * @secure
     */
    deleteInstance: (id: string, params: RequestParams = {}): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/gameCenterGroups/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterGroups
     * @name GameCenterGroupsGameCenterAchievementsGetToManyRelationship
     * @request GET:/v1/gameCenterGroups/{id}/relationships/gameCenterAchievements
     * @secure
     */
    gameCenterAchievementsGetToManyRelationship: (
      id: string,
      query?: {
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
      },
      params: RequestParams = {},
    ): Promise<GameCenterGroupGameCenterAchievementsLinkagesResponse> =>
      this.request<GameCenterGroupGameCenterAchievementsLinkagesResponse, ErrorResponse>({
        path: `/v1/gameCenterGroups/${id}/relationships/gameCenterAchievements`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterGroups
     * @name GameCenterGroupsGameCenterAchievementsReplaceToManyRelationship
     * @request PATCH:/v1/gameCenterGroups/{id}/relationships/gameCenterAchievements
     * @secure
     */
    gameCenterAchievementsReplaceToManyRelationship: (
      id: string,
      data: GameCenterGroupGameCenterAchievementsLinkagesRequest,
      params: RequestParams = {},
    ): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/gameCenterGroups/${id}/relationships/gameCenterAchievements`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterGroups
     * @name GameCenterGroupsGameCenterAchievementsGetToManyRelated
     * @request GET:/v1/gameCenterGroups/{id}/gameCenterAchievements
     * @secure
     */
    gameCenterAchievementsGetToManyRelated: (
      id: string,
      query?: {
        /** filter by attribute 'archived' */
        "filter[archived]"?: string[];
        /** filter by attribute 'referenceName' */
        "filter[referenceName]"?: string[];
        /** filter by id(s) */
        "filter[id]"?: string[];
        /** the fields to include for returned resources of type gameCenterAchievementReleases */
        "fields[gameCenterAchievementReleases]"?: ("gameCenterAchievement" | "gameCenterDetail" | "live")[];
        /** the fields to include for returned resources of type gameCenterGroups */
        "fields[gameCenterGroups]"?: (
          | "gameCenterAchievements"
          | "gameCenterDetails"
          | "gameCenterLeaderboardSets"
          | "gameCenterLeaderboards"
          | "referenceName"
        )[];
        /** the fields to include for returned resources of type gameCenterDetails */
        "fields[gameCenterDetails]"?: (
          | "achievementReleases"
          | "app"
          | "arcadeEnabled"
          | "challengeEnabled"
          | "defaultGroupLeaderboard"
          | "defaultLeaderboard"
          | "gameCenterAchievements"
          | "gameCenterAppVersions"
          | "gameCenterGroup"
          | "gameCenterLeaderboardSets"
          | "gameCenterLeaderboards"
          | "leaderboardReleases"
          | "leaderboardSetReleases"
        )[];
        /** the fields to include for returned resources of type gameCenterAchievementLocalizations */
        "fields[gameCenterAchievementLocalizations]"?: (
          | "afterEarnedDescription"
          | "beforeEarnedDescription"
          | "gameCenterAchievement"
          | "gameCenterAchievementImage"
          | "locale"
          | "name"
        )[];
        /** the fields to include for returned resources of type gameCenterAchievements */
        "fields[gameCenterAchievements]"?: (
          | "archived"
          | "gameCenterDetail"
          | "gameCenterGroup"
          | "groupAchievement"
          | "localizations"
          | "points"
          | "referenceName"
          | "releases"
          | "repeatable"
          | "showBeforeEarned"
          | "vendorIdentifier"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /**
         * maximum number of related localizations returned (when they are included)
         * @max 50
         */
        "limit[localizations]"?: number;
        /**
         * maximum number of related releases returned (when they are included)
         * @max 50
         */
        "limit[releases]"?: number;
        /** comma-separated list of relationships to include */
        include?: ("gameCenterDetail" | "gameCenterGroup" | "groupAchievement" | "localizations" | "releases")[];
      },
      params: RequestParams = {},
    ): Promise<GameCenterAchievementsResponse> =>
      this.request<GameCenterAchievementsResponse, ErrorResponse>({
        path: `/v1/gameCenterGroups/${id}/gameCenterAchievements`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterGroups
     * @name GameCenterGroupsGameCenterDetailsGetToManyRelated
     * @request GET:/v1/gameCenterGroups/{id}/gameCenterDetails
     * @secure
     */
    gameCenterDetailsGetToManyRelated: (
      id: string,
      query?: {
        /** filter by attribute 'gameCenterAppVersions.enabled' */
        filterGameCenterAppVersionsEnabled?: string[];
        /** the fields to include for returned resources of type gameCenterAchievementReleases */
        "fields[gameCenterAchievementReleases]"?: ("gameCenterAchievement" | "gameCenterDetail" | "live")[];
        /** the fields to include for returned resources of type gameCenterLeaderboardSetReleases */
        "fields[gameCenterLeaderboardSetReleases]"?: ("gameCenterDetail" | "gameCenterLeaderboardSet" | "live")[];
        /** the fields to include for returned resources of type gameCenterLeaderboardSets */
        "fields[gameCenterLeaderboardSets]"?: (
          | "gameCenterDetail"
          | "gameCenterGroup"
          | "gameCenterLeaderboards"
          | "groupLeaderboardSet"
          | "localizations"
          | "referenceName"
          | "releases"
          | "vendorIdentifier"
        )[];
        /** the fields to include for returned resources of type gameCenterGroups */
        "fields[gameCenterGroups]"?: (
          | "gameCenterAchievements"
          | "gameCenterDetails"
          | "gameCenterLeaderboardSets"
          | "gameCenterLeaderboards"
          | "referenceName"
        )[];
        /** the fields to include for returned resources of type gameCenterDetails */
        "fields[gameCenterDetails]"?: (
          | "achievementReleases"
          | "app"
          | "arcadeEnabled"
          | "challengeEnabled"
          | "defaultGroupLeaderboard"
          | "defaultLeaderboard"
          | "gameCenterAchievements"
          | "gameCenterAppVersions"
          | "gameCenterGroup"
          | "gameCenterLeaderboardSets"
          | "gameCenterLeaderboards"
          | "leaderboardReleases"
          | "leaderboardSetReleases"
        )[];
        /** the fields to include for returned resources of type gameCenterLeaderboards */
        "fields[gameCenterLeaderboards]"?: (
          | "archived"
          | "defaultFormatter"
          | "gameCenterDetail"
          | "gameCenterGroup"
          | "gameCenterLeaderboardSets"
          | "groupLeaderboard"
          | "localizations"
          | "recurrenceDuration"
          | "recurrenceRule"
          | "recurrenceStartDate"
          | "referenceName"
          | "releases"
          | "scoreRangeEnd"
          | "scoreRangeStart"
          | "scoreSortType"
          | "submissionType"
          | "vendorIdentifier"
        )[];
        /** the fields to include for returned resources of type gameCenterAppVersions */
        "fields[gameCenterAppVersions]"?: ("appStoreVersion" | "compatibilityVersions" | "enabled")[];
        /** the fields to include for returned resources of type gameCenterAchievements */
        "fields[gameCenterAchievements]"?: (
          | "archived"
          | "gameCenterDetail"
          | "gameCenterGroup"
          | "groupAchievement"
          | "localizations"
          | "points"
          | "referenceName"
          | "releases"
          | "repeatable"
          | "showBeforeEarned"
          | "vendorIdentifier"
        )[];
        /** the fields to include for returned resources of type apps */
        "fields[apps]"?: (
          | "alternativeDistributionKey"
          | "analyticsReportRequests"
          | "appAvailability"
          | "appClips"
          | "appCustomProductPages"
          | "appEncryptionDeclarations"
          | "appEvents"
          | "appInfos"
          | "appPricePoints"
          | "appPriceSchedule"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersions"
          | "availableInNewTerritories"
          | "availableTerritories"
          | "betaAppLocalizations"
          | "betaAppReviewDetail"
          | "betaGroups"
          | "betaLicenseAgreement"
          | "betaTesters"
          | "builds"
          | "bundleId"
          | "ciProduct"
          | "contentRightsDeclaration"
          | "customerReviews"
          | "endUserLicenseAgreement"
          | "gameCenterDetail"
          | "gameCenterEnabledVersions"
          | "inAppPurchases"
          | "inAppPurchasesV2"
          | "isOrEverWasMadeForKids"
          | "marketplaceSearchDetail"
          | "name"
          | "perfPowerMetrics"
          | "preOrder"
          | "preReleaseVersions"
          | "pricePoints"
          | "prices"
          | "primaryLocale"
          | "promotedPurchases"
          | "reviewSubmissions"
          | "sku"
          | "subscriptionGracePeriod"
          | "subscriptionGroups"
          | "subscriptionStatusUrl"
          | "subscriptionStatusUrlForSandbox"
          | "subscriptionStatusUrlVersion"
          | "subscriptionStatusUrlVersionForSandbox"
        )[];
        /** the fields to include for returned resources of type gameCenterLeaderboardReleases */
        "fields[gameCenterLeaderboardReleases]"?: ("gameCenterDetail" | "gameCenterLeaderboard" | "live")[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /**
         * maximum number of related gameCenterAppVersions returned (when they are included)
         * @max 50
         */
        "limit[gameCenterAppVersions]"?: number;
        /**
         * maximum number of related gameCenterLeaderboards returned (when they are included)
         * @max 50
         */
        "limit[gameCenterLeaderboards]"?: number;
        /**
         * maximum number of related gameCenterLeaderboardSets returned (when they are included)
         * @max 50
         */
        "limit[gameCenterLeaderboardSets]"?: number;
        /**
         * maximum number of related gameCenterAchievements returned (when they are included)
         * @max 50
         */
        "limit[gameCenterAchievements]"?: number;
        /**
         * maximum number of related achievementReleases returned (when they are included)
         * @max 50
         */
        "limit[achievementReleases]"?: number;
        /**
         * maximum number of related leaderboardReleases returned (when they are included)
         * @max 50
         */
        "limit[leaderboardReleases]"?: number;
        /**
         * maximum number of related leaderboardSetReleases returned (when they are included)
         * @max 50
         */
        "limit[leaderboardSetReleases]"?: number;
        /** comma-separated list of relationships to include */
        include?: (
          | "achievementReleases"
          | "app"
          | "defaultGroupLeaderboard"
          | "defaultLeaderboard"
          | "gameCenterAchievements"
          | "gameCenterAppVersions"
          | "gameCenterGroup"
          | "gameCenterLeaderboardSets"
          | "gameCenterLeaderboards"
          | "leaderboardReleases"
          | "leaderboardSetReleases"
        )[];
      },
      params: RequestParams = {},
    ): Promise<GameCenterDetailsResponse> =>
      this.request<GameCenterDetailsResponse, ErrorResponse>({
        path: `/v1/gameCenterGroups/${id}/gameCenterDetails`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterGroups
     * @name GameCenterGroupsGameCenterLeaderboardSetsGetToManyRelationship
     * @request GET:/v1/gameCenterGroups/{id}/relationships/gameCenterLeaderboardSets
     * @secure
     */
    gameCenterLeaderboardSetsGetToManyRelationship: (
      id: string,
      query?: {
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
      },
      params: RequestParams = {},
    ): Promise<GameCenterGroupGameCenterLeaderboardSetsLinkagesResponse> =>
      this.request<GameCenterGroupGameCenterLeaderboardSetsLinkagesResponse, ErrorResponse>({
        path: `/v1/gameCenterGroups/${id}/relationships/gameCenterLeaderboardSets`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterGroups
     * @name GameCenterGroupsGameCenterLeaderboardSetsReplaceToManyRelationship
     * @request PATCH:/v1/gameCenterGroups/{id}/relationships/gameCenterLeaderboardSets
     * @secure
     */
    gameCenterLeaderboardSetsReplaceToManyRelationship: (
      id: string,
      data: GameCenterGroupGameCenterLeaderboardSetsLinkagesRequest,
      params: RequestParams = {},
    ): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/gameCenterGroups/${id}/relationships/gameCenterLeaderboardSets`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterGroups
     * @name GameCenterGroupsGameCenterLeaderboardSetsGetToManyRelated
     * @request GET:/v1/gameCenterGroups/{id}/gameCenterLeaderboardSets
     * @secure
     */
    gameCenterLeaderboardSetsGetToManyRelated: (
      id: string,
      query?: {
        /** filter by attribute 'referenceName' */
        "filter[referenceName]"?: string[];
        /** filter by id(s) */
        "filter[id]"?: string[];
        /** the fields to include for returned resources of type gameCenterLeaderboardSetLocalizations */
        "fields[gameCenterLeaderboardSetLocalizations]"?: (
          | "gameCenterLeaderboardSet"
          | "gameCenterLeaderboardSetImage"
          | "locale"
          | "name"
        )[];
        /** the fields to include for returned resources of type gameCenterLeaderboardSetReleases */
        "fields[gameCenterLeaderboardSetReleases]"?: ("gameCenterDetail" | "gameCenterLeaderboardSet" | "live")[];
        /** the fields to include for returned resources of type gameCenterLeaderboardSets */
        "fields[gameCenterLeaderboardSets]"?: (
          | "gameCenterDetail"
          | "gameCenterGroup"
          | "gameCenterLeaderboards"
          | "groupLeaderboardSet"
          | "localizations"
          | "referenceName"
          | "releases"
          | "vendorIdentifier"
        )[];
        /** the fields to include for returned resources of type gameCenterGroups */
        "fields[gameCenterGroups]"?: (
          | "gameCenterAchievements"
          | "gameCenterDetails"
          | "gameCenterLeaderboardSets"
          | "gameCenterLeaderboards"
          | "referenceName"
        )[];
        /** the fields to include for returned resources of type gameCenterDetails */
        "fields[gameCenterDetails]"?: (
          | "achievementReleases"
          | "app"
          | "arcadeEnabled"
          | "challengeEnabled"
          | "defaultGroupLeaderboard"
          | "defaultLeaderboard"
          | "gameCenterAchievements"
          | "gameCenterAppVersions"
          | "gameCenterGroup"
          | "gameCenterLeaderboardSets"
          | "gameCenterLeaderboards"
          | "leaderboardReleases"
          | "leaderboardSetReleases"
        )[];
        /** the fields to include for returned resources of type gameCenterLeaderboards */
        "fields[gameCenterLeaderboards]"?: (
          | "archived"
          | "defaultFormatter"
          | "gameCenterDetail"
          | "gameCenterGroup"
          | "gameCenterLeaderboardSets"
          | "groupLeaderboard"
          | "localizations"
          | "recurrenceDuration"
          | "recurrenceRule"
          | "recurrenceStartDate"
          | "referenceName"
          | "releases"
          | "scoreRangeEnd"
          | "scoreRangeStart"
          | "scoreSortType"
          | "submissionType"
          | "vendorIdentifier"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /**
         * maximum number of related localizations returned (when they are included)
         * @max 50
         */
        "limit[localizations]"?: number;
        /**
         * maximum number of related gameCenterLeaderboards returned (when they are included)
         * @max 50
         */
        "limit[gameCenterLeaderboards]"?: number;
        /**
         * maximum number of related releases returned (when they are included)
         * @max 50
         */
        "limit[releases]"?: number;
        /** comma-separated list of relationships to include */
        include?: (
          | "gameCenterDetail"
          | "gameCenterGroup"
          | "gameCenterLeaderboards"
          | "groupLeaderboardSet"
          | "localizations"
          | "releases"
        )[];
      },
      params: RequestParams = {},
    ): Promise<GameCenterLeaderboardSetsResponse> =>
      this.request<GameCenterLeaderboardSetsResponse, ErrorResponse>({
        path: `/v1/gameCenterGroups/${id}/gameCenterLeaderboardSets`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterGroups
     * @name GameCenterGroupsGameCenterLeaderboardsGetToManyRelationship
     * @request GET:/v1/gameCenterGroups/{id}/relationships/gameCenterLeaderboards
     * @secure
     */
    gameCenterLeaderboardsGetToManyRelationship: (
      id: string,
      query?: {
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
      },
      params: RequestParams = {},
    ): Promise<GameCenterGroupGameCenterLeaderboardsLinkagesResponse> =>
      this.request<GameCenterGroupGameCenterLeaderboardsLinkagesResponse, ErrorResponse>({
        path: `/v1/gameCenterGroups/${id}/relationships/gameCenterLeaderboards`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterGroups
     * @name GameCenterGroupsGameCenterLeaderboardsReplaceToManyRelationship
     * @request PATCH:/v1/gameCenterGroups/{id}/relationships/gameCenterLeaderboards
     * @secure
     */
    gameCenterLeaderboardsReplaceToManyRelationship: (
      id: string,
      data: GameCenterGroupGameCenterLeaderboardsLinkagesRequest,
      params: RequestParams = {},
    ): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/gameCenterGroups/${id}/relationships/gameCenterLeaderboards`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterGroups
     * @name GameCenterGroupsGameCenterLeaderboardsGetToManyRelated
     * @request GET:/v1/gameCenterGroups/{id}/gameCenterLeaderboards
     * @secure
     */
    gameCenterLeaderboardsGetToManyRelated: (
      id: string,
      query?: {
        /** filter by attribute 'archived' */
        "filter[archived]"?: string[];
        /** filter by attribute 'referenceName' */
        "filter[referenceName]"?: string[];
        /** filter by id(s) */
        "filter[id]"?: string[];
        /** the fields to include for returned resources of type gameCenterLeaderboardLocalizations */
        "fields[gameCenterLeaderboardLocalizations]"?: (
          | "formatterOverride"
          | "formatterSuffix"
          | "formatterSuffixSingular"
          | "gameCenterLeaderboard"
          | "gameCenterLeaderboardImage"
          | "locale"
          | "name"
        )[];
        /** the fields to include for returned resources of type gameCenterLeaderboardSets */
        "fields[gameCenterLeaderboardSets]"?: (
          | "gameCenterDetail"
          | "gameCenterGroup"
          | "gameCenterLeaderboards"
          | "groupLeaderboardSet"
          | "localizations"
          | "referenceName"
          | "releases"
          | "vendorIdentifier"
        )[];
        /** the fields to include for returned resources of type gameCenterGroups */
        "fields[gameCenterGroups]"?: (
          | "gameCenterAchievements"
          | "gameCenterDetails"
          | "gameCenterLeaderboardSets"
          | "gameCenterLeaderboards"
          | "referenceName"
        )[];
        /** the fields to include for returned resources of type gameCenterDetails */
        "fields[gameCenterDetails]"?: (
          | "achievementReleases"
          | "app"
          | "arcadeEnabled"
          | "challengeEnabled"
          | "defaultGroupLeaderboard"
          | "defaultLeaderboard"
          | "gameCenterAchievements"
          | "gameCenterAppVersions"
          | "gameCenterGroup"
          | "gameCenterLeaderboardSets"
          | "gameCenterLeaderboards"
          | "leaderboardReleases"
          | "leaderboardSetReleases"
        )[];
        /** the fields to include for returned resources of type gameCenterLeaderboards */
        "fields[gameCenterLeaderboards]"?: (
          | "archived"
          | "defaultFormatter"
          | "gameCenterDetail"
          | "gameCenterGroup"
          | "gameCenterLeaderboardSets"
          | "groupLeaderboard"
          | "localizations"
          | "recurrenceDuration"
          | "recurrenceRule"
          | "recurrenceStartDate"
          | "referenceName"
          | "releases"
          | "scoreRangeEnd"
          | "scoreRangeStart"
          | "scoreSortType"
          | "submissionType"
          | "vendorIdentifier"
        )[];
        /** the fields to include for returned resources of type gameCenterLeaderboardReleases */
        "fields[gameCenterLeaderboardReleases]"?: ("gameCenterDetail" | "gameCenterLeaderboard" | "live")[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /**
         * maximum number of related gameCenterLeaderboardSets returned (when they are included)
         * @max 50
         */
        "limit[gameCenterLeaderboardSets]"?: number;
        /**
         * maximum number of related localizations returned (when they are included)
         * @max 50
         */
        "limit[localizations]"?: number;
        /**
         * maximum number of related releases returned (when they are included)
         * @max 50
         */
        "limit[releases]"?: number;
        /** comma-separated list of relationships to include */
        include?: (
          | "gameCenterDetail"
          | "gameCenterGroup"
          | "gameCenterLeaderboardSets"
          | "groupLeaderboard"
          | "localizations"
          | "releases"
        )[];
      },
      params: RequestParams = {},
    ): Promise<GameCenterLeaderboardsResponse> =>
      this.request<GameCenterLeaderboardsResponse, ErrorResponse>({
        path: `/v1/gameCenterGroups/${id}/gameCenterLeaderboards`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  gameCenterLeaderboardEntrySubmissions = {
    /**
     * No description
     *
     * @tags GameCenterLeaderboardEntrySubmissions
     * @name GameCenterLeaderboardEntrySubmissionsCreateInstance
     * @request POST:/v1/gameCenterLeaderboardEntrySubmissions
     * @secure
     */
    createInstance: (
      data: GameCenterLeaderboardEntrySubmissionCreateRequest,
      params: RequestParams = {},
    ): Promise<GameCenterLeaderboardEntrySubmissionResponse> =>
      this.request<GameCenterLeaderboardEntrySubmissionResponse, ErrorResponse>({
        path: `/v1/gameCenterLeaderboardEntrySubmissions`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),
  };
  gameCenterLeaderboardImages = {
    /**
     * No description
     *
     * @tags GameCenterLeaderboardImages
     * @name GameCenterLeaderboardImagesCreateInstance
     * @request POST:/v1/gameCenterLeaderboardImages
     * @secure
     */
    createInstance: (
      data: GameCenterLeaderboardImageCreateRequest,
      params: RequestParams = {},
    ): Promise<GameCenterLeaderboardImageResponse> =>
      this.request<GameCenterLeaderboardImageResponse, ErrorResponse>({
        path: `/v1/gameCenterLeaderboardImages`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterLeaderboardImages
     * @name GameCenterLeaderboardImagesGetInstance
     * @request GET:/v1/gameCenterLeaderboardImages/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type gameCenterLeaderboardImages */
        "fields[gameCenterLeaderboardImages]"?: (
          | "assetDeliveryState"
          | "fileName"
          | "fileSize"
          | "gameCenterLeaderboardLocalization"
          | "imageAsset"
          | "uploadOperations"
          | "uploaded"
        )[];
        /** comma-separated list of relationships to include */
        include?: "gameCenterLeaderboardLocalization"[];
      },
      params: RequestParams = {},
    ): Promise<GameCenterLeaderboardImageResponse> =>
      this.request<GameCenterLeaderboardImageResponse, ErrorResponse>({
        path: `/v1/gameCenterLeaderboardImages/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterLeaderboardImages
     * @name GameCenterLeaderboardImagesUpdateInstance
     * @request PATCH:/v1/gameCenterLeaderboardImages/{id}
     * @secure
     */
    updateInstance: (
      id: string,
      data: GameCenterLeaderboardImageUpdateRequest,
      params: RequestParams = {},
    ): Promise<GameCenterLeaderboardImageResponse> =>
      this.request<GameCenterLeaderboardImageResponse, ErrorResponse>({
        path: `/v1/gameCenterLeaderboardImages/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterLeaderboardImages
     * @name GameCenterLeaderboardImagesDeleteInstance
     * @request DELETE:/v1/gameCenterLeaderboardImages/{id}
     * @secure
     */
    deleteInstance: (id: string, params: RequestParams = {}): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/gameCenterLeaderboardImages/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),
  };
  gameCenterLeaderboardLocalizations = {
    /**
     * No description
     *
     * @tags GameCenterLeaderboardLocalizations
     * @name GameCenterLeaderboardLocalizationsCreateInstance
     * @request POST:/v1/gameCenterLeaderboardLocalizations
     * @secure
     */
    createInstance: (
      data: GameCenterLeaderboardLocalizationCreateRequest,
      params: RequestParams = {},
    ): Promise<GameCenterLeaderboardLocalizationResponse> =>
      this.request<GameCenterLeaderboardLocalizationResponse, ErrorResponse>({
        path: `/v1/gameCenterLeaderboardLocalizations`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterLeaderboardLocalizations
     * @name GameCenterLeaderboardLocalizationsGetInstance
     * @request GET:/v1/gameCenterLeaderboardLocalizations/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type gameCenterLeaderboardLocalizations */
        "fields[gameCenterLeaderboardLocalizations]"?: (
          | "formatterOverride"
          | "formatterSuffix"
          | "formatterSuffixSingular"
          | "gameCenterLeaderboard"
          | "gameCenterLeaderboardImage"
          | "locale"
          | "name"
        )[];
        /** comma-separated list of relationships to include */
        include?: ("gameCenterLeaderboard" | "gameCenterLeaderboardImage")[];
        /** the fields to include for returned resources of type gameCenterLeaderboardImages */
        "fields[gameCenterLeaderboardImages]"?: (
          | "assetDeliveryState"
          | "fileName"
          | "fileSize"
          | "gameCenterLeaderboardLocalization"
          | "imageAsset"
          | "uploadOperations"
          | "uploaded"
        )[];
      },
      params: RequestParams = {},
    ): Promise<GameCenterLeaderboardLocalizationResponse> =>
      this.request<GameCenterLeaderboardLocalizationResponse, ErrorResponse>({
        path: `/v1/gameCenterLeaderboardLocalizations/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterLeaderboardLocalizations
     * @name GameCenterLeaderboardLocalizationsUpdateInstance
     * @request PATCH:/v1/gameCenterLeaderboardLocalizations/{id}
     * @secure
     */
    updateInstance: (
      id: string,
      data: GameCenterLeaderboardLocalizationUpdateRequest,
      params: RequestParams = {},
    ): Promise<GameCenterLeaderboardLocalizationResponse> =>
      this.request<GameCenterLeaderboardLocalizationResponse, ErrorResponse>({
        path: `/v1/gameCenterLeaderboardLocalizations/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterLeaderboardLocalizations
     * @name GameCenterLeaderboardLocalizationsDeleteInstance
     * @request DELETE:/v1/gameCenterLeaderboardLocalizations/{id}
     * @secure
     */
    deleteInstance: (id: string, params: RequestParams = {}): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/gameCenterLeaderboardLocalizations/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterLeaderboardLocalizations
     * @name GameCenterLeaderboardLocalizationsGameCenterLeaderboardImageGetToOneRelated
     * @request GET:/v1/gameCenterLeaderboardLocalizations/{id}/gameCenterLeaderboardImage
     * @secure
     */
    gameCenterLeaderboardImageGetToOneRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type gameCenterLeaderboardImages */
        "fields[gameCenterLeaderboardImages]"?: (
          | "assetDeliveryState"
          | "fileName"
          | "fileSize"
          | "gameCenterLeaderboardLocalization"
          | "imageAsset"
          | "uploadOperations"
          | "uploaded"
        )[];
        /** the fields to include for returned resources of type gameCenterLeaderboardLocalizations */
        "fields[gameCenterLeaderboardLocalizations]"?: (
          | "formatterOverride"
          | "formatterSuffix"
          | "formatterSuffixSingular"
          | "gameCenterLeaderboard"
          | "gameCenterLeaderboardImage"
          | "locale"
          | "name"
        )[];
        /** comma-separated list of relationships to include */
        include?: "gameCenterLeaderboardLocalization"[];
      },
      params: RequestParams = {},
    ): Promise<GameCenterLeaderboardImageResponse> =>
      this.request<GameCenterLeaderboardImageResponse, ErrorResponse>({
        path: `/v1/gameCenterLeaderboardLocalizations/${id}/gameCenterLeaderboardImage`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  gameCenterLeaderboardReleases = {
    /**
     * No description
     *
     * @tags GameCenterLeaderboardReleases
     * @name GameCenterLeaderboardReleasesCreateInstance
     * @request POST:/v1/gameCenterLeaderboardReleases
     * @secure
     */
    createInstance: (
      data: GameCenterLeaderboardReleaseCreateRequest,
      params: RequestParams = {},
    ): Promise<GameCenterLeaderboardReleaseResponse> =>
      this.request<GameCenterLeaderboardReleaseResponse, ErrorResponse>({
        path: `/v1/gameCenterLeaderboardReleases`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterLeaderboardReleases
     * @name GameCenterLeaderboardReleasesGetInstance
     * @request GET:/v1/gameCenterLeaderboardReleases/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type gameCenterLeaderboardReleases */
        "fields[gameCenterLeaderboardReleases]"?: ("gameCenterDetail" | "gameCenterLeaderboard" | "live")[];
        /** comma-separated list of relationships to include */
        include?: ("gameCenterDetail" | "gameCenterLeaderboard")[];
      },
      params: RequestParams = {},
    ): Promise<GameCenterLeaderboardReleaseResponse> =>
      this.request<GameCenterLeaderboardReleaseResponse, ErrorResponse>({
        path: `/v1/gameCenterLeaderboardReleases/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterLeaderboardReleases
     * @name GameCenterLeaderboardReleasesDeleteInstance
     * @request DELETE:/v1/gameCenterLeaderboardReleases/{id}
     * @secure
     */
    deleteInstance: (id: string, params: RequestParams = {}): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/gameCenterLeaderboardReleases/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),
  };
  gameCenterLeaderboardSetImages = {
    /**
     * No description
     *
     * @tags GameCenterLeaderboardSetImages
     * @name GameCenterLeaderboardSetImagesCreateInstance
     * @request POST:/v1/gameCenterLeaderboardSetImages
     * @secure
     */
    createInstance: (
      data: GameCenterLeaderboardSetImageCreateRequest,
      params: RequestParams = {},
    ): Promise<GameCenterLeaderboardSetImageResponse> =>
      this.request<GameCenterLeaderboardSetImageResponse, ErrorResponse>({
        path: `/v1/gameCenterLeaderboardSetImages`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterLeaderboardSetImages
     * @name GameCenterLeaderboardSetImagesGetInstance
     * @request GET:/v1/gameCenterLeaderboardSetImages/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type gameCenterLeaderboardSetImages */
        "fields[gameCenterLeaderboardSetImages]"?: (
          | "assetDeliveryState"
          | "fileName"
          | "fileSize"
          | "gameCenterLeaderboardSetLocalization"
          | "imageAsset"
          | "uploadOperations"
          | "uploaded"
        )[];
        /** comma-separated list of relationships to include */
        include?: "gameCenterLeaderboardSetLocalization"[];
      },
      params: RequestParams = {},
    ): Promise<GameCenterLeaderboardSetImageResponse> =>
      this.request<GameCenterLeaderboardSetImageResponse, ErrorResponse>({
        path: `/v1/gameCenterLeaderboardSetImages/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterLeaderboardSetImages
     * @name GameCenterLeaderboardSetImagesUpdateInstance
     * @request PATCH:/v1/gameCenterLeaderboardSetImages/{id}
     * @secure
     */
    updateInstance: (
      id: string,
      data: GameCenterLeaderboardSetImageUpdateRequest,
      params: RequestParams = {},
    ): Promise<GameCenterLeaderboardSetImageResponse> =>
      this.request<GameCenterLeaderboardSetImageResponse, ErrorResponse>({
        path: `/v1/gameCenterLeaderboardSetImages/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterLeaderboardSetImages
     * @name GameCenterLeaderboardSetImagesDeleteInstance
     * @request DELETE:/v1/gameCenterLeaderboardSetImages/{id}
     * @secure
     */
    deleteInstance: (id: string, params: RequestParams = {}): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/gameCenterLeaderboardSetImages/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),
  };
  gameCenterLeaderboardSetLocalizations = {
    /**
     * No description
     *
     * @tags GameCenterLeaderboardSetLocalizations
     * @name GameCenterLeaderboardSetLocalizationsCreateInstance
     * @request POST:/v1/gameCenterLeaderboardSetLocalizations
     * @secure
     */
    createInstance: (
      data: GameCenterLeaderboardSetLocalizationCreateRequest,
      params: RequestParams = {},
    ): Promise<GameCenterLeaderboardSetLocalizationResponse> =>
      this.request<GameCenterLeaderboardSetLocalizationResponse, ErrorResponse>({
        path: `/v1/gameCenterLeaderboardSetLocalizations`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterLeaderboardSetLocalizations
     * @name GameCenterLeaderboardSetLocalizationsGetInstance
     * @request GET:/v1/gameCenterLeaderboardSetLocalizations/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type gameCenterLeaderboardSetLocalizations */
        "fields[gameCenterLeaderboardSetLocalizations]"?: (
          | "gameCenterLeaderboardSet"
          | "gameCenterLeaderboardSetImage"
          | "locale"
          | "name"
        )[];
        /** comma-separated list of relationships to include */
        include?: ("gameCenterLeaderboardSet" | "gameCenterLeaderboardSetImage")[];
        /** the fields to include for returned resources of type gameCenterLeaderboardSetImages */
        "fields[gameCenterLeaderboardSetImages]"?: (
          | "assetDeliveryState"
          | "fileName"
          | "fileSize"
          | "gameCenterLeaderboardSetLocalization"
          | "imageAsset"
          | "uploadOperations"
          | "uploaded"
        )[];
      },
      params: RequestParams = {},
    ): Promise<GameCenterLeaderboardSetLocalizationResponse> =>
      this.request<GameCenterLeaderboardSetLocalizationResponse, ErrorResponse>({
        path: `/v1/gameCenterLeaderboardSetLocalizations/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterLeaderboardSetLocalizations
     * @name GameCenterLeaderboardSetLocalizationsUpdateInstance
     * @request PATCH:/v1/gameCenterLeaderboardSetLocalizations/{id}
     * @secure
     */
    updateInstance: (
      id: string,
      data: GameCenterLeaderboardSetLocalizationUpdateRequest,
      params: RequestParams = {},
    ): Promise<GameCenterLeaderboardSetLocalizationResponse> =>
      this.request<GameCenterLeaderboardSetLocalizationResponse, ErrorResponse>({
        path: `/v1/gameCenterLeaderboardSetLocalizations/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterLeaderboardSetLocalizations
     * @name GameCenterLeaderboardSetLocalizationsDeleteInstance
     * @request DELETE:/v1/gameCenterLeaderboardSetLocalizations/{id}
     * @secure
     */
    deleteInstance: (id: string, params: RequestParams = {}): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/gameCenterLeaderboardSetLocalizations/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterLeaderboardSetLocalizations
     * @name GameCenterLeaderboardSetLocalizationsGameCenterLeaderboardSetImageGetToOneRelated
     * @request GET:/v1/gameCenterLeaderboardSetLocalizations/{id}/gameCenterLeaderboardSetImage
     * @secure
     */
    gameCenterLeaderboardSetImageGetToOneRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type gameCenterLeaderboardSetLocalizations */
        "fields[gameCenterLeaderboardSetLocalizations]"?: (
          | "gameCenterLeaderboardSet"
          | "gameCenterLeaderboardSetImage"
          | "locale"
          | "name"
        )[];
        /** the fields to include for returned resources of type gameCenterLeaderboardSetImages */
        "fields[gameCenterLeaderboardSetImages]"?: (
          | "assetDeliveryState"
          | "fileName"
          | "fileSize"
          | "gameCenterLeaderboardSetLocalization"
          | "imageAsset"
          | "uploadOperations"
          | "uploaded"
        )[];
        /** comma-separated list of relationships to include */
        include?: "gameCenterLeaderboardSetLocalization"[];
      },
      params: RequestParams = {},
    ): Promise<GameCenterLeaderboardSetImageResponse> =>
      this.request<GameCenterLeaderboardSetImageResponse, ErrorResponse>({
        path: `/v1/gameCenterLeaderboardSetLocalizations/${id}/gameCenterLeaderboardSetImage`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  gameCenterLeaderboardSetMemberLocalizations = {
    /**
     * No description
     *
     * @tags GameCenterLeaderboardSetMemberLocalizations
     * @name GameCenterLeaderboardSetMemberLocalizationsGetCollection
     * @request GET:/v1/gameCenterLeaderboardSetMemberLocalizations
     * @secure
     */
    getCollection: (
      query: {
        /** filter by id(s) of related 'gameCenterLeaderboard' */
        "filter[gameCenterLeaderboard]": string[];
        /** filter by id(s) of related 'gameCenterLeaderboardSet' */
        "filter[gameCenterLeaderboardSet]": string[];
        /** the fields to include for returned resources of type gameCenterLeaderboardSetMemberLocalizations */
        "fields[gameCenterLeaderboardSetMemberLocalizations]"?: (
          | "gameCenterLeaderboard"
          | "gameCenterLeaderboardSet"
          | "locale"
          | "name"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /** comma-separated list of relationships to include */
        include?: ("gameCenterLeaderboard" | "gameCenterLeaderboardSet")[];
        /** the fields to include for returned resources of type gameCenterLeaderboardSets */
        "fields[gameCenterLeaderboardSets]"?: (
          | "gameCenterDetail"
          | "gameCenterGroup"
          | "gameCenterLeaderboards"
          | "groupLeaderboardSet"
          | "localizations"
          | "referenceName"
          | "releases"
          | "vendorIdentifier"
        )[];
        /** the fields to include for returned resources of type gameCenterLeaderboards */
        "fields[gameCenterLeaderboards]"?: (
          | "archived"
          | "defaultFormatter"
          | "gameCenterDetail"
          | "gameCenterGroup"
          | "gameCenterLeaderboardSets"
          | "groupLeaderboard"
          | "localizations"
          | "recurrenceDuration"
          | "recurrenceRule"
          | "recurrenceStartDate"
          | "referenceName"
          | "releases"
          | "scoreRangeEnd"
          | "scoreRangeStart"
          | "scoreSortType"
          | "submissionType"
          | "vendorIdentifier"
        )[];
      },
      params: RequestParams = {},
    ): Promise<GameCenterLeaderboardSetMemberLocalizationsResponse> =>
      this.request<GameCenterLeaderboardSetMemberLocalizationsResponse, ErrorResponse>({
        path: `/v1/gameCenterLeaderboardSetMemberLocalizations`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterLeaderboardSetMemberLocalizations
     * @name GameCenterLeaderboardSetMemberLocalizationsCreateInstance
     * @request POST:/v1/gameCenterLeaderboardSetMemberLocalizations
     * @secure
     */
    createInstance: (
      data: GameCenterLeaderboardSetMemberLocalizationCreateRequest,
      params: RequestParams = {},
    ): Promise<GameCenterLeaderboardSetMemberLocalizationResponse> =>
      this.request<GameCenterLeaderboardSetMemberLocalizationResponse, ErrorResponse>({
        path: `/v1/gameCenterLeaderboardSetMemberLocalizations`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterLeaderboardSetMemberLocalizations
     * @name GameCenterLeaderboardSetMemberLocalizationsUpdateInstance
     * @request PATCH:/v1/gameCenterLeaderboardSetMemberLocalizations/{id}
     * @secure
     */
    updateInstance: (
      id: string,
      data: GameCenterLeaderboardSetMemberLocalizationUpdateRequest,
      params: RequestParams = {},
    ): Promise<GameCenterLeaderboardSetMemberLocalizationResponse> =>
      this.request<GameCenterLeaderboardSetMemberLocalizationResponse, ErrorResponse>({
        path: `/v1/gameCenterLeaderboardSetMemberLocalizations/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterLeaderboardSetMemberLocalizations
     * @name GameCenterLeaderboardSetMemberLocalizationsDeleteInstance
     * @request DELETE:/v1/gameCenterLeaderboardSetMemberLocalizations/{id}
     * @secure
     */
    deleteInstance: (id: string, params: RequestParams = {}): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/gameCenterLeaderboardSetMemberLocalizations/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterLeaderboardSetMemberLocalizations
     * @name GameCenterLeaderboardSetMemberLocalizationsGameCenterLeaderboardGetToOneRelated
     * @request GET:/v1/gameCenterLeaderboardSetMemberLocalizations/{id}/gameCenterLeaderboard
     * @secure
     */
    gameCenterLeaderboardGetToOneRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type gameCenterLeaderboardLocalizations */
        "fields[gameCenterLeaderboardLocalizations]"?: (
          | "formatterOverride"
          | "formatterSuffix"
          | "formatterSuffixSingular"
          | "gameCenterLeaderboard"
          | "gameCenterLeaderboardImage"
          | "locale"
          | "name"
        )[];
        /** the fields to include for returned resources of type gameCenterLeaderboardSets */
        "fields[gameCenterLeaderboardSets]"?: (
          | "gameCenterDetail"
          | "gameCenterGroup"
          | "gameCenterLeaderboards"
          | "groupLeaderboardSet"
          | "localizations"
          | "referenceName"
          | "releases"
          | "vendorIdentifier"
        )[];
        /** the fields to include for returned resources of type gameCenterGroups */
        "fields[gameCenterGroups]"?: (
          | "gameCenterAchievements"
          | "gameCenterDetails"
          | "gameCenterLeaderboardSets"
          | "gameCenterLeaderboards"
          | "referenceName"
        )[];
        /** the fields to include for returned resources of type gameCenterDetails */
        "fields[gameCenterDetails]"?: (
          | "achievementReleases"
          | "app"
          | "arcadeEnabled"
          | "challengeEnabled"
          | "defaultGroupLeaderboard"
          | "defaultLeaderboard"
          | "gameCenterAchievements"
          | "gameCenterAppVersions"
          | "gameCenterGroup"
          | "gameCenterLeaderboardSets"
          | "gameCenterLeaderboards"
          | "leaderboardReleases"
          | "leaderboardSetReleases"
        )[];
        /** the fields to include for returned resources of type gameCenterLeaderboards */
        "fields[gameCenterLeaderboards]"?: (
          | "archived"
          | "defaultFormatter"
          | "gameCenterDetail"
          | "gameCenterGroup"
          | "gameCenterLeaderboardSets"
          | "groupLeaderboard"
          | "localizations"
          | "recurrenceDuration"
          | "recurrenceRule"
          | "recurrenceStartDate"
          | "referenceName"
          | "releases"
          | "scoreRangeEnd"
          | "scoreRangeStart"
          | "scoreSortType"
          | "submissionType"
          | "vendorIdentifier"
        )[];
        /** the fields to include for returned resources of type gameCenterLeaderboardReleases */
        "fields[gameCenterLeaderboardReleases]"?: ("gameCenterDetail" | "gameCenterLeaderboard" | "live")[];
        /**
         * maximum number of related gameCenterLeaderboardSets returned (when they are included)
         * @max 50
         */
        "limit[gameCenterLeaderboardSets]"?: number;
        /**
         * maximum number of related localizations returned (when they are included)
         * @max 50
         */
        "limit[localizations]"?: number;
        /**
         * maximum number of related releases returned (when they are included)
         * @max 50
         */
        "limit[releases]"?: number;
        /** comma-separated list of relationships to include */
        include?: (
          | "gameCenterDetail"
          | "gameCenterGroup"
          | "gameCenterLeaderboardSets"
          | "groupLeaderboard"
          | "localizations"
          | "releases"
        )[];
      },
      params: RequestParams = {},
    ): Promise<GameCenterLeaderboardResponse> =>
      this.request<GameCenterLeaderboardResponse, ErrorResponse>({
        path: `/v1/gameCenterLeaderboardSetMemberLocalizations/${id}/gameCenterLeaderboard`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterLeaderboardSetMemberLocalizations
     * @name GameCenterLeaderboardSetMemberLocalizationsGameCenterLeaderboardSetGetToOneRelated
     * @request GET:/v1/gameCenterLeaderboardSetMemberLocalizations/{id}/gameCenterLeaderboardSet
     * @secure
     */
    gameCenterLeaderboardSetGetToOneRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type gameCenterLeaderboardSetLocalizations */
        "fields[gameCenterLeaderboardSetLocalizations]"?: (
          | "gameCenterLeaderboardSet"
          | "gameCenterLeaderboardSetImage"
          | "locale"
          | "name"
        )[];
        /** the fields to include for returned resources of type gameCenterLeaderboardSetReleases */
        "fields[gameCenterLeaderboardSetReleases]"?: ("gameCenterDetail" | "gameCenterLeaderboardSet" | "live")[];
        /** the fields to include for returned resources of type gameCenterLeaderboardSets */
        "fields[gameCenterLeaderboardSets]"?: (
          | "gameCenterDetail"
          | "gameCenterGroup"
          | "gameCenterLeaderboards"
          | "groupLeaderboardSet"
          | "localizations"
          | "referenceName"
          | "releases"
          | "vendorIdentifier"
        )[];
        /** the fields to include for returned resources of type gameCenterGroups */
        "fields[gameCenterGroups]"?: (
          | "gameCenterAchievements"
          | "gameCenterDetails"
          | "gameCenterLeaderboardSets"
          | "gameCenterLeaderboards"
          | "referenceName"
        )[];
        /** the fields to include for returned resources of type gameCenterDetails */
        "fields[gameCenterDetails]"?: (
          | "achievementReleases"
          | "app"
          | "arcadeEnabled"
          | "challengeEnabled"
          | "defaultGroupLeaderboard"
          | "defaultLeaderboard"
          | "gameCenterAchievements"
          | "gameCenterAppVersions"
          | "gameCenterGroup"
          | "gameCenterLeaderboardSets"
          | "gameCenterLeaderboards"
          | "leaderboardReleases"
          | "leaderboardSetReleases"
        )[];
        /** the fields to include for returned resources of type gameCenterLeaderboards */
        "fields[gameCenterLeaderboards]"?: (
          | "archived"
          | "defaultFormatter"
          | "gameCenterDetail"
          | "gameCenterGroup"
          | "gameCenterLeaderboardSets"
          | "groupLeaderboard"
          | "localizations"
          | "recurrenceDuration"
          | "recurrenceRule"
          | "recurrenceStartDate"
          | "referenceName"
          | "releases"
          | "scoreRangeEnd"
          | "scoreRangeStart"
          | "scoreSortType"
          | "submissionType"
          | "vendorIdentifier"
        )[];
        /**
         * maximum number of related localizations returned (when they are included)
         * @max 50
         */
        "limit[localizations]"?: number;
        /**
         * maximum number of related gameCenterLeaderboards returned (when they are included)
         * @max 50
         */
        "limit[gameCenterLeaderboards]"?: number;
        /**
         * maximum number of related releases returned (when they are included)
         * @max 50
         */
        "limit[releases]"?: number;
        /** comma-separated list of relationships to include */
        include?: (
          | "gameCenterDetail"
          | "gameCenterGroup"
          | "gameCenterLeaderboards"
          | "groupLeaderboardSet"
          | "localizations"
          | "releases"
        )[];
      },
      params: RequestParams = {},
    ): Promise<GameCenterLeaderboardSetResponse> =>
      this.request<GameCenterLeaderboardSetResponse, ErrorResponse>({
        path: `/v1/gameCenterLeaderboardSetMemberLocalizations/${id}/gameCenterLeaderboardSet`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  gameCenterLeaderboardSetReleases = {
    /**
     * No description
     *
     * @tags GameCenterLeaderboardSetReleases
     * @name GameCenterLeaderboardSetReleasesCreateInstance
     * @request POST:/v1/gameCenterLeaderboardSetReleases
     * @secure
     */
    createInstance: (
      data: GameCenterLeaderboardSetReleaseCreateRequest,
      params: RequestParams = {},
    ): Promise<GameCenterLeaderboardSetReleaseResponse> =>
      this.request<GameCenterLeaderboardSetReleaseResponse, ErrorResponse>({
        path: `/v1/gameCenterLeaderboardSetReleases`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterLeaderboardSetReleases
     * @name GameCenterLeaderboardSetReleasesGetInstance
     * @request GET:/v1/gameCenterLeaderboardSetReleases/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type gameCenterLeaderboardSetReleases */
        "fields[gameCenterLeaderboardSetReleases]"?: ("gameCenterDetail" | "gameCenterLeaderboardSet" | "live")[];
        /** comma-separated list of relationships to include */
        include?: ("gameCenterDetail" | "gameCenterLeaderboardSet")[];
      },
      params: RequestParams = {},
    ): Promise<GameCenterLeaderboardSetReleaseResponse> =>
      this.request<GameCenterLeaderboardSetReleaseResponse, ErrorResponse>({
        path: `/v1/gameCenterLeaderboardSetReleases/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterLeaderboardSetReleases
     * @name GameCenterLeaderboardSetReleasesDeleteInstance
     * @request DELETE:/v1/gameCenterLeaderboardSetReleases/{id}
     * @secure
     */
    deleteInstance: (id: string, params: RequestParams = {}): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/gameCenterLeaderboardSetReleases/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),
  };
  gameCenterLeaderboardSets = {
    /**
     * No description
     *
     * @tags GameCenterLeaderboardSets
     * @name GameCenterLeaderboardSetsCreateInstance
     * @request POST:/v1/gameCenterLeaderboardSets
     * @secure
     */
    createInstance: (
      data: GameCenterLeaderboardSetCreateRequest,
      params: RequestParams = {},
    ): Promise<GameCenterLeaderboardSetResponse> =>
      this.request<GameCenterLeaderboardSetResponse, ErrorResponse>({
        path: `/v1/gameCenterLeaderboardSets`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterLeaderboardSets
     * @name GameCenterLeaderboardSetsGetInstance
     * @request GET:/v1/gameCenterLeaderboardSets/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type gameCenterLeaderboardSets */
        "fields[gameCenterLeaderboardSets]"?: (
          | "gameCenterDetail"
          | "gameCenterGroup"
          | "gameCenterLeaderboards"
          | "groupLeaderboardSet"
          | "localizations"
          | "referenceName"
          | "releases"
          | "vendorIdentifier"
        )[];
        /** comma-separated list of relationships to include */
        include?: (
          | "gameCenterDetail"
          | "gameCenterGroup"
          | "gameCenterLeaderboards"
          | "groupLeaderboardSet"
          | "localizations"
          | "releases"
        )[];
        /** the fields to include for returned resources of type gameCenterLeaderboardSetLocalizations */
        "fields[gameCenterLeaderboardSetLocalizations]"?: (
          | "gameCenterLeaderboardSet"
          | "gameCenterLeaderboardSetImage"
          | "locale"
          | "name"
        )[];
        /** the fields to include for returned resources of type gameCenterLeaderboardSetReleases */
        "fields[gameCenterLeaderboardSetReleases]"?: ("gameCenterDetail" | "gameCenterLeaderboardSet" | "live")[];
        /** the fields to include for returned resources of type gameCenterLeaderboards */
        "fields[gameCenterLeaderboards]"?: (
          | "archived"
          | "defaultFormatter"
          | "gameCenterDetail"
          | "gameCenterGroup"
          | "gameCenterLeaderboardSets"
          | "groupLeaderboard"
          | "localizations"
          | "recurrenceDuration"
          | "recurrenceRule"
          | "recurrenceStartDate"
          | "referenceName"
          | "releases"
          | "scoreRangeEnd"
          | "scoreRangeStart"
          | "scoreSortType"
          | "submissionType"
          | "vendorIdentifier"
        )[];
        /**
         * maximum number of related gameCenterLeaderboards returned (when they are included)
         * @max 50
         */
        "limit[gameCenterLeaderboards]"?: number;
        /**
         * maximum number of related localizations returned (when they are included)
         * @max 50
         */
        "limit[localizations]"?: number;
        /**
         * maximum number of related releases returned (when they are included)
         * @max 50
         */
        "limit[releases]"?: number;
      },
      params: RequestParams = {},
    ): Promise<GameCenterLeaderboardSetResponse> =>
      this.request<GameCenterLeaderboardSetResponse, ErrorResponse>({
        path: `/v1/gameCenterLeaderboardSets/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterLeaderboardSets
     * @name GameCenterLeaderboardSetsUpdateInstance
     * @request PATCH:/v1/gameCenterLeaderboardSets/{id}
     * @secure
     */
    updateInstance: (
      id: string,
      data: GameCenterLeaderboardSetUpdateRequest,
      params: RequestParams = {},
    ): Promise<GameCenterLeaderboardSetResponse> =>
      this.request<GameCenterLeaderboardSetResponse, ErrorResponse>({
        path: `/v1/gameCenterLeaderboardSets/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterLeaderboardSets
     * @name GameCenterLeaderboardSetsDeleteInstance
     * @request DELETE:/v1/gameCenterLeaderboardSets/{id}
     * @secure
     */
    deleteInstance: (id: string, params: RequestParams = {}): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/gameCenterLeaderboardSets/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterLeaderboardSets
     * @name GameCenterLeaderboardSetsGameCenterLeaderboardsGetToManyRelationship
     * @request GET:/v1/gameCenterLeaderboardSets/{id}/relationships/gameCenterLeaderboards
     * @secure
     */
    gameCenterLeaderboardsGetToManyRelationship: (
      id: string,
      query?: {
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
      },
      params: RequestParams = {},
    ): Promise<GameCenterLeaderboardSetGameCenterLeaderboardsLinkagesResponse> =>
      this.request<GameCenterLeaderboardSetGameCenterLeaderboardsLinkagesResponse, ErrorResponse>({
        path: `/v1/gameCenterLeaderboardSets/${id}/relationships/gameCenterLeaderboards`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterLeaderboardSets
     * @name GameCenterLeaderboardSetsGameCenterLeaderboardsCreateToManyRelationship
     * @request POST:/v1/gameCenterLeaderboardSets/{id}/relationships/gameCenterLeaderboards
     * @secure
     */
    gameCenterLeaderboardsCreateToManyRelationship: (
      id: string,
      data: GameCenterLeaderboardSetGameCenterLeaderboardsLinkagesRequest,
      params: RequestParams = {},
    ): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/gameCenterLeaderboardSets/${id}/relationships/gameCenterLeaderboards`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterLeaderboardSets
     * @name GameCenterLeaderboardSetsGameCenterLeaderboardsReplaceToManyRelationship
     * @request PATCH:/v1/gameCenterLeaderboardSets/{id}/relationships/gameCenterLeaderboards
     * @secure
     */
    gameCenterLeaderboardsReplaceToManyRelationship: (
      id: string,
      data: GameCenterLeaderboardSetGameCenterLeaderboardsLinkagesRequest,
      params: RequestParams = {},
    ): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/gameCenterLeaderboardSets/${id}/relationships/gameCenterLeaderboards`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterLeaderboardSets
     * @name GameCenterLeaderboardSetsGameCenterLeaderboardsDeleteToManyRelationship
     * @request DELETE:/v1/gameCenterLeaderboardSets/{id}/relationships/gameCenterLeaderboards
     * @secure
     */
    gameCenterLeaderboardsDeleteToManyRelationship: (
      id: string,
      data: GameCenterLeaderboardSetGameCenterLeaderboardsLinkagesRequest,
      params: RequestParams = {},
    ): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/gameCenterLeaderboardSets/${id}/relationships/gameCenterLeaderboards`,
        method: "DELETE",
        body: data,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterLeaderboardSets
     * @name GameCenterLeaderboardSetsGameCenterLeaderboardsGetToManyRelated
     * @request GET:/v1/gameCenterLeaderboardSets/{id}/gameCenterLeaderboards
     * @secure
     */
    gameCenterLeaderboardsGetToManyRelated: (
      id: string,
      query?: {
        /** filter by attribute 'archived' */
        "filter[archived]"?: string[];
        /** filter by attribute 'referenceName' */
        "filter[referenceName]"?: string[];
        /** filter by id(s) */
        "filter[id]"?: string[];
        /** the fields to include for returned resources of type gameCenterLeaderboardLocalizations */
        "fields[gameCenterLeaderboardLocalizations]"?: (
          | "formatterOverride"
          | "formatterSuffix"
          | "formatterSuffixSingular"
          | "gameCenterLeaderboard"
          | "gameCenterLeaderboardImage"
          | "locale"
          | "name"
        )[];
        /** the fields to include for returned resources of type gameCenterLeaderboardSets */
        "fields[gameCenterLeaderboardSets]"?: (
          | "gameCenterDetail"
          | "gameCenterGroup"
          | "gameCenterLeaderboards"
          | "groupLeaderboardSet"
          | "localizations"
          | "referenceName"
          | "releases"
          | "vendorIdentifier"
        )[];
        /** the fields to include for returned resources of type gameCenterGroups */
        "fields[gameCenterGroups]"?: (
          | "gameCenterAchievements"
          | "gameCenterDetails"
          | "gameCenterLeaderboardSets"
          | "gameCenterLeaderboards"
          | "referenceName"
        )[];
        /** the fields to include for returned resources of type gameCenterDetails */
        "fields[gameCenterDetails]"?: (
          | "achievementReleases"
          | "app"
          | "arcadeEnabled"
          | "challengeEnabled"
          | "defaultGroupLeaderboard"
          | "defaultLeaderboard"
          | "gameCenterAchievements"
          | "gameCenterAppVersions"
          | "gameCenterGroup"
          | "gameCenterLeaderboardSets"
          | "gameCenterLeaderboards"
          | "leaderboardReleases"
          | "leaderboardSetReleases"
        )[];
        /** the fields to include for returned resources of type gameCenterLeaderboards */
        "fields[gameCenterLeaderboards]"?: (
          | "archived"
          | "defaultFormatter"
          | "gameCenterDetail"
          | "gameCenterGroup"
          | "gameCenterLeaderboardSets"
          | "groupLeaderboard"
          | "localizations"
          | "recurrenceDuration"
          | "recurrenceRule"
          | "recurrenceStartDate"
          | "referenceName"
          | "releases"
          | "scoreRangeEnd"
          | "scoreRangeStart"
          | "scoreSortType"
          | "submissionType"
          | "vendorIdentifier"
        )[];
        /** the fields to include for returned resources of type gameCenterLeaderboardReleases */
        "fields[gameCenterLeaderboardReleases]"?: ("gameCenterDetail" | "gameCenterLeaderboard" | "live")[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /**
         * maximum number of related gameCenterLeaderboardSets returned (when they are included)
         * @max 50
         */
        "limit[gameCenterLeaderboardSets]"?: number;
        /**
         * maximum number of related localizations returned (when they are included)
         * @max 50
         */
        "limit[localizations]"?: number;
        /**
         * maximum number of related releases returned (when they are included)
         * @max 50
         */
        "limit[releases]"?: number;
        /** comma-separated list of relationships to include */
        include?: (
          | "gameCenterDetail"
          | "gameCenterGroup"
          | "gameCenterLeaderboardSets"
          | "groupLeaderboard"
          | "localizations"
          | "releases"
        )[];
      },
      params: RequestParams = {},
    ): Promise<GameCenterLeaderboardsResponse> =>
      this.request<GameCenterLeaderboardsResponse, ErrorResponse>({
        path: `/v1/gameCenterLeaderboardSets/${id}/gameCenterLeaderboards`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterLeaderboardSets
     * @name GameCenterLeaderboardSetsGroupLeaderboardSetGetToOneRelationship
     * @request GET:/v1/gameCenterLeaderboardSets/{id}/relationships/groupLeaderboardSet
     * @secure
     */
    groupLeaderboardSetGetToOneRelationship: (
      id: string,
      params: RequestParams = {},
    ): Promise<GameCenterLeaderboardSetGroupLeaderboardSetLinkageResponse> =>
      this.request<GameCenterLeaderboardSetGroupLeaderboardSetLinkageResponse, ErrorResponse>({
        path: `/v1/gameCenterLeaderboardSets/${id}/relationships/groupLeaderboardSet`,
        method: "GET",
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterLeaderboardSets
     * @name GameCenterLeaderboardSetsGroupLeaderboardSetUpdateToOneRelationship
     * @request PATCH:/v1/gameCenterLeaderboardSets/{id}/relationships/groupLeaderboardSet
     * @secure
     */
    groupLeaderboardSetUpdateToOneRelationship: (
      id: string,
      data: GameCenterLeaderboardSetGroupLeaderboardSetLinkageRequest,
      params: RequestParams = {},
    ): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/gameCenterLeaderboardSets/${id}/relationships/groupLeaderboardSet`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterLeaderboardSets
     * @name GameCenterLeaderboardSetsGroupLeaderboardSetGetToOneRelated
     * @request GET:/v1/gameCenterLeaderboardSets/{id}/groupLeaderboardSet
     * @secure
     */
    groupLeaderboardSetGetToOneRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type gameCenterLeaderboardSetLocalizations */
        "fields[gameCenterLeaderboardSetLocalizations]"?: (
          | "gameCenterLeaderboardSet"
          | "gameCenterLeaderboardSetImage"
          | "locale"
          | "name"
        )[];
        /** the fields to include for returned resources of type gameCenterLeaderboardSetReleases */
        "fields[gameCenterLeaderboardSetReleases]"?: ("gameCenterDetail" | "gameCenterLeaderboardSet" | "live")[];
        /** the fields to include for returned resources of type gameCenterLeaderboardSets */
        "fields[gameCenterLeaderboardSets]"?: (
          | "gameCenterDetail"
          | "gameCenterGroup"
          | "gameCenterLeaderboards"
          | "groupLeaderboardSet"
          | "localizations"
          | "referenceName"
          | "releases"
          | "vendorIdentifier"
        )[];
        /** the fields to include for returned resources of type gameCenterGroups */
        "fields[gameCenterGroups]"?: (
          | "gameCenterAchievements"
          | "gameCenterDetails"
          | "gameCenterLeaderboardSets"
          | "gameCenterLeaderboards"
          | "referenceName"
        )[];
        /** the fields to include for returned resources of type gameCenterDetails */
        "fields[gameCenterDetails]"?: (
          | "achievementReleases"
          | "app"
          | "arcadeEnabled"
          | "challengeEnabled"
          | "defaultGroupLeaderboard"
          | "defaultLeaderboard"
          | "gameCenterAchievements"
          | "gameCenterAppVersions"
          | "gameCenterGroup"
          | "gameCenterLeaderboardSets"
          | "gameCenterLeaderboards"
          | "leaderboardReleases"
          | "leaderboardSetReleases"
        )[];
        /** the fields to include for returned resources of type gameCenterLeaderboards */
        "fields[gameCenterLeaderboards]"?: (
          | "archived"
          | "defaultFormatter"
          | "gameCenterDetail"
          | "gameCenterGroup"
          | "gameCenterLeaderboardSets"
          | "groupLeaderboard"
          | "localizations"
          | "recurrenceDuration"
          | "recurrenceRule"
          | "recurrenceStartDate"
          | "referenceName"
          | "releases"
          | "scoreRangeEnd"
          | "scoreRangeStart"
          | "scoreSortType"
          | "submissionType"
          | "vendorIdentifier"
        )[];
        /**
         * maximum number of related localizations returned (when they are included)
         * @max 50
         */
        "limit[localizations]"?: number;
        /**
         * maximum number of related gameCenterLeaderboards returned (when they are included)
         * @max 50
         */
        "limit[gameCenterLeaderboards]"?: number;
        /**
         * maximum number of related releases returned (when they are included)
         * @max 50
         */
        "limit[releases]"?: number;
        /** comma-separated list of relationships to include */
        include?: (
          | "gameCenterDetail"
          | "gameCenterGroup"
          | "gameCenterLeaderboards"
          | "groupLeaderboardSet"
          | "localizations"
          | "releases"
        )[];
      },
      params: RequestParams = {},
    ): Promise<GameCenterLeaderboardSetResponse> =>
      this.request<GameCenterLeaderboardSetResponse, ErrorResponse>({
        path: `/v1/gameCenterLeaderboardSets/${id}/groupLeaderboardSet`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterLeaderboardSets
     * @name GameCenterLeaderboardSetsLocalizationsGetToManyRelated
     * @request GET:/v1/gameCenterLeaderboardSets/{id}/localizations
     * @secure
     */
    localizationsGetToManyRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type gameCenterLeaderboardSetLocalizations */
        "fields[gameCenterLeaderboardSetLocalizations]"?: (
          | "gameCenterLeaderboardSet"
          | "gameCenterLeaderboardSetImage"
          | "locale"
          | "name"
        )[];
        /** the fields to include for returned resources of type gameCenterLeaderboardSets */
        "fields[gameCenterLeaderboardSets]"?: (
          | "gameCenterDetail"
          | "gameCenterGroup"
          | "gameCenterLeaderboards"
          | "groupLeaderboardSet"
          | "localizations"
          | "referenceName"
          | "releases"
          | "vendorIdentifier"
        )[];
        /** the fields to include for returned resources of type gameCenterLeaderboardSetImages */
        "fields[gameCenterLeaderboardSetImages]"?: (
          | "assetDeliveryState"
          | "fileName"
          | "fileSize"
          | "gameCenterLeaderboardSetLocalization"
          | "imageAsset"
          | "uploadOperations"
          | "uploaded"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /** comma-separated list of relationships to include */
        include?: ("gameCenterLeaderboardSet" | "gameCenterLeaderboardSetImage")[];
      },
      params: RequestParams = {},
    ): Promise<GameCenterLeaderboardSetLocalizationsResponse> =>
      this.request<GameCenterLeaderboardSetLocalizationsResponse, ErrorResponse>({
        path: `/v1/gameCenterLeaderboardSets/${id}/localizations`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterLeaderboardSets
     * @name GameCenterLeaderboardSetsReleasesGetToManyRelated
     * @request GET:/v1/gameCenterLeaderboardSets/{id}/releases
     * @secure
     */
    releasesGetToManyRelated: (
      id: string,
      query?: {
        /** filter by attribute 'live' */
        "filter[live]"?: string[];
        /** filter by id(s) of related 'gameCenterDetail' */
        "filter[gameCenterDetail]"?: string[];
        /** the fields to include for returned resources of type gameCenterLeaderboardSetReleases */
        "fields[gameCenterLeaderboardSetReleases]"?: ("gameCenterDetail" | "gameCenterLeaderboardSet" | "live")[];
        /** the fields to include for returned resources of type gameCenterLeaderboardSets */
        "fields[gameCenterLeaderboardSets]"?: (
          | "gameCenterDetail"
          | "gameCenterGroup"
          | "gameCenterLeaderboards"
          | "groupLeaderboardSet"
          | "localizations"
          | "referenceName"
          | "releases"
          | "vendorIdentifier"
        )[];
        /** the fields to include for returned resources of type gameCenterDetails */
        "fields[gameCenterDetails]"?: (
          | "achievementReleases"
          | "app"
          | "arcadeEnabled"
          | "challengeEnabled"
          | "defaultGroupLeaderboard"
          | "defaultLeaderboard"
          | "gameCenterAchievements"
          | "gameCenterAppVersions"
          | "gameCenterGroup"
          | "gameCenterLeaderboardSets"
          | "gameCenterLeaderboards"
          | "leaderboardReleases"
          | "leaderboardSetReleases"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /** comma-separated list of relationships to include */
        include?: ("gameCenterDetail" | "gameCenterLeaderboardSet")[];
      },
      params: RequestParams = {},
    ): Promise<GameCenterLeaderboardSetReleasesResponse> =>
      this.request<GameCenterLeaderboardSetReleasesResponse, ErrorResponse>({
        path: `/v1/gameCenterLeaderboardSets/${id}/releases`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  gameCenterLeaderboards = {
    /**
     * No description
     *
     * @tags GameCenterLeaderboards
     * @name GameCenterLeaderboardsCreateInstance
     * @request POST:/v1/gameCenterLeaderboards
     * @secure
     */
    createInstance: (
      data: GameCenterLeaderboardCreateRequest,
      params: RequestParams = {},
    ): Promise<GameCenterLeaderboardResponse> =>
      this.request<GameCenterLeaderboardResponse, ErrorResponse>({
        path: `/v1/gameCenterLeaderboards`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterLeaderboards
     * @name GameCenterLeaderboardsGetInstance
     * @request GET:/v1/gameCenterLeaderboards/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type gameCenterLeaderboards */
        "fields[gameCenterLeaderboards]"?: (
          | "archived"
          | "defaultFormatter"
          | "gameCenterDetail"
          | "gameCenterGroup"
          | "gameCenterLeaderboardSets"
          | "groupLeaderboard"
          | "localizations"
          | "recurrenceDuration"
          | "recurrenceRule"
          | "recurrenceStartDate"
          | "referenceName"
          | "releases"
          | "scoreRangeEnd"
          | "scoreRangeStart"
          | "scoreSortType"
          | "submissionType"
          | "vendorIdentifier"
        )[];
        /** comma-separated list of relationships to include */
        include?: (
          | "gameCenterDetail"
          | "gameCenterGroup"
          | "gameCenterLeaderboardSets"
          | "groupLeaderboard"
          | "localizations"
          | "releases"
        )[];
        /** the fields to include for returned resources of type gameCenterLeaderboardLocalizations */
        "fields[gameCenterLeaderboardLocalizations]"?: (
          | "formatterOverride"
          | "formatterSuffix"
          | "formatterSuffixSingular"
          | "gameCenterLeaderboard"
          | "gameCenterLeaderboardImage"
          | "locale"
          | "name"
        )[];
        /** the fields to include for returned resources of type gameCenterLeaderboardReleases */
        "fields[gameCenterLeaderboardReleases]"?: ("gameCenterDetail" | "gameCenterLeaderboard" | "live")[];
        /**
         * maximum number of related gameCenterLeaderboardSets returned (when they are included)
         * @max 50
         */
        "limit[gameCenterLeaderboardSets]"?: number;
        /**
         * maximum number of related localizations returned (when they are included)
         * @max 50
         */
        "limit[localizations]"?: number;
        /**
         * maximum number of related releases returned (when they are included)
         * @max 50
         */
        "limit[releases]"?: number;
      },
      params: RequestParams = {},
    ): Promise<GameCenterLeaderboardResponse> =>
      this.request<GameCenterLeaderboardResponse, ErrorResponse>({
        path: `/v1/gameCenterLeaderboards/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterLeaderboards
     * @name GameCenterLeaderboardsUpdateInstance
     * @request PATCH:/v1/gameCenterLeaderboards/{id}
     * @secure
     */
    updateInstance: (
      id: string,
      data: GameCenterLeaderboardUpdateRequest,
      params: RequestParams = {},
    ): Promise<GameCenterLeaderboardResponse> =>
      this.request<GameCenterLeaderboardResponse, ErrorResponse>({
        path: `/v1/gameCenterLeaderboards/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterLeaderboards
     * @name GameCenterLeaderboardsDeleteInstance
     * @request DELETE:/v1/gameCenterLeaderboards/{id}
     * @secure
     */
    deleteInstance: (id: string, params: RequestParams = {}): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/gameCenterLeaderboards/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterLeaderboards
     * @name GameCenterLeaderboardsGroupLeaderboardGetToOneRelationship
     * @request GET:/v1/gameCenterLeaderboards/{id}/relationships/groupLeaderboard
     * @secure
     */
    groupLeaderboardGetToOneRelationship: (
      id: string,
      params: RequestParams = {},
    ): Promise<GameCenterLeaderboardGroupLeaderboardLinkageResponse> =>
      this.request<GameCenterLeaderboardGroupLeaderboardLinkageResponse, ErrorResponse>({
        path: `/v1/gameCenterLeaderboards/${id}/relationships/groupLeaderboard`,
        method: "GET",
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterLeaderboards
     * @name GameCenterLeaderboardsGroupLeaderboardUpdateToOneRelationship
     * @request PATCH:/v1/gameCenterLeaderboards/{id}/relationships/groupLeaderboard
     * @secure
     */
    groupLeaderboardUpdateToOneRelationship: (
      id: string,
      data: GameCenterLeaderboardGroupLeaderboardLinkageRequest,
      params: RequestParams = {},
    ): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/gameCenterLeaderboards/${id}/relationships/groupLeaderboard`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterLeaderboards
     * @name GameCenterLeaderboardsGroupLeaderboardGetToOneRelated
     * @request GET:/v1/gameCenterLeaderboards/{id}/groupLeaderboard
     * @secure
     */
    groupLeaderboardGetToOneRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type gameCenterLeaderboardLocalizations */
        "fields[gameCenterLeaderboardLocalizations]"?: (
          | "formatterOverride"
          | "formatterSuffix"
          | "formatterSuffixSingular"
          | "gameCenterLeaderboard"
          | "gameCenterLeaderboardImage"
          | "locale"
          | "name"
        )[];
        /** the fields to include for returned resources of type gameCenterLeaderboardSets */
        "fields[gameCenterLeaderboardSets]"?: (
          | "gameCenterDetail"
          | "gameCenterGroup"
          | "gameCenterLeaderboards"
          | "groupLeaderboardSet"
          | "localizations"
          | "referenceName"
          | "releases"
          | "vendorIdentifier"
        )[];
        /** the fields to include for returned resources of type gameCenterGroups */
        "fields[gameCenterGroups]"?: (
          | "gameCenterAchievements"
          | "gameCenterDetails"
          | "gameCenterLeaderboardSets"
          | "gameCenterLeaderboards"
          | "referenceName"
        )[];
        /** the fields to include for returned resources of type gameCenterDetails */
        "fields[gameCenterDetails]"?: (
          | "achievementReleases"
          | "app"
          | "arcadeEnabled"
          | "challengeEnabled"
          | "defaultGroupLeaderboard"
          | "defaultLeaderboard"
          | "gameCenterAchievements"
          | "gameCenterAppVersions"
          | "gameCenterGroup"
          | "gameCenterLeaderboardSets"
          | "gameCenterLeaderboards"
          | "leaderboardReleases"
          | "leaderboardSetReleases"
        )[];
        /** the fields to include for returned resources of type gameCenterLeaderboards */
        "fields[gameCenterLeaderboards]"?: (
          | "archived"
          | "defaultFormatter"
          | "gameCenterDetail"
          | "gameCenterGroup"
          | "gameCenterLeaderboardSets"
          | "groupLeaderboard"
          | "localizations"
          | "recurrenceDuration"
          | "recurrenceRule"
          | "recurrenceStartDate"
          | "referenceName"
          | "releases"
          | "scoreRangeEnd"
          | "scoreRangeStart"
          | "scoreSortType"
          | "submissionType"
          | "vendorIdentifier"
        )[];
        /** the fields to include for returned resources of type gameCenterLeaderboardReleases */
        "fields[gameCenterLeaderboardReleases]"?: ("gameCenterDetail" | "gameCenterLeaderboard" | "live")[];
        /**
         * maximum number of related gameCenterLeaderboardSets returned (when they are included)
         * @max 50
         */
        "limit[gameCenterLeaderboardSets]"?: number;
        /**
         * maximum number of related localizations returned (when they are included)
         * @max 50
         */
        "limit[localizations]"?: number;
        /**
         * maximum number of related releases returned (when they are included)
         * @max 50
         */
        "limit[releases]"?: number;
        /** comma-separated list of relationships to include */
        include?: (
          | "gameCenterDetail"
          | "gameCenterGroup"
          | "gameCenterLeaderboardSets"
          | "groupLeaderboard"
          | "localizations"
          | "releases"
        )[];
      },
      params: RequestParams = {},
    ): Promise<GameCenterLeaderboardResponse> =>
      this.request<GameCenterLeaderboardResponse, ErrorResponse>({
        path: `/v1/gameCenterLeaderboards/${id}/groupLeaderboard`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterLeaderboards
     * @name GameCenterLeaderboardsLocalizationsGetToManyRelated
     * @request GET:/v1/gameCenterLeaderboards/{id}/localizations
     * @secure
     */
    localizationsGetToManyRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type gameCenterLeaderboardLocalizations */
        "fields[gameCenterLeaderboardLocalizations]"?: (
          | "formatterOverride"
          | "formatterSuffix"
          | "formatterSuffixSingular"
          | "gameCenterLeaderboard"
          | "gameCenterLeaderboardImage"
          | "locale"
          | "name"
        )[];
        /** the fields to include for returned resources of type gameCenterLeaderboardImages */
        "fields[gameCenterLeaderboardImages]"?: (
          | "assetDeliveryState"
          | "fileName"
          | "fileSize"
          | "gameCenterLeaderboardLocalization"
          | "imageAsset"
          | "uploadOperations"
          | "uploaded"
        )[];
        /** the fields to include for returned resources of type gameCenterLeaderboards */
        "fields[gameCenterLeaderboards]"?: (
          | "archived"
          | "defaultFormatter"
          | "gameCenterDetail"
          | "gameCenterGroup"
          | "gameCenterLeaderboardSets"
          | "groupLeaderboard"
          | "localizations"
          | "recurrenceDuration"
          | "recurrenceRule"
          | "recurrenceStartDate"
          | "referenceName"
          | "releases"
          | "scoreRangeEnd"
          | "scoreRangeStart"
          | "scoreSortType"
          | "submissionType"
          | "vendorIdentifier"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /** comma-separated list of relationships to include */
        include?: ("gameCenterLeaderboard" | "gameCenterLeaderboardImage")[];
      },
      params: RequestParams = {},
    ): Promise<GameCenterLeaderboardLocalizationsResponse> =>
      this.request<GameCenterLeaderboardLocalizationsResponse, ErrorResponse>({
        path: `/v1/gameCenterLeaderboards/${id}/localizations`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterLeaderboards
     * @name GameCenterLeaderboardsReleasesGetToManyRelated
     * @request GET:/v1/gameCenterLeaderboards/{id}/releases
     * @secure
     */
    releasesGetToManyRelated: (
      id: string,
      query?: {
        /** filter by attribute 'live' */
        "filter[live]"?: string[];
        /** filter by id(s) of related 'gameCenterDetail' */
        "filter[gameCenterDetail]"?: string[];
        /** the fields to include for returned resources of type gameCenterDetails */
        "fields[gameCenterDetails]"?: (
          | "achievementReleases"
          | "app"
          | "arcadeEnabled"
          | "challengeEnabled"
          | "defaultGroupLeaderboard"
          | "defaultLeaderboard"
          | "gameCenterAchievements"
          | "gameCenterAppVersions"
          | "gameCenterGroup"
          | "gameCenterLeaderboardSets"
          | "gameCenterLeaderboards"
          | "leaderboardReleases"
          | "leaderboardSetReleases"
        )[];
        /** the fields to include for returned resources of type gameCenterLeaderboards */
        "fields[gameCenterLeaderboards]"?: (
          | "archived"
          | "defaultFormatter"
          | "gameCenterDetail"
          | "gameCenterGroup"
          | "gameCenterLeaderboardSets"
          | "groupLeaderboard"
          | "localizations"
          | "recurrenceDuration"
          | "recurrenceRule"
          | "recurrenceStartDate"
          | "referenceName"
          | "releases"
          | "scoreRangeEnd"
          | "scoreRangeStart"
          | "scoreSortType"
          | "submissionType"
          | "vendorIdentifier"
        )[];
        /** the fields to include for returned resources of type gameCenterLeaderboardReleases */
        "fields[gameCenterLeaderboardReleases]"?: ("gameCenterDetail" | "gameCenterLeaderboard" | "live")[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /** comma-separated list of relationships to include */
        include?: ("gameCenterDetail" | "gameCenterLeaderboard")[];
      },
      params: RequestParams = {},
    ): Promise<GameCenterLeaderboardReleasesResponse> =>
      this.request<GameCenterLeaderboardReleasesResponse, ErrorResponse>({
        path: `/v1/gameCenterLeaderboards/${id}/releases`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  gameCenterMatchmakingQueues = {
    /**
     * No description
     *
     * @tags GameCenterMatchmakingQueues
     * @name GameCenterMatchmakingQueuesGetCollection
     * @request GET:/v1/gameCenterMatchmakingQueues
     * @secure
     */
    getCollection: (
      query?: {
        /** the fields to include for returned resources of type gameCenterMatchmakingQueues */
        "fields[gameCenterMatchmakingQueues]"?: (
          | "classicMatchmakingBundleIds"
          | "experimentRuleSet"
          | "referenceName"
          | "ruleSet"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /** comma-separated list of relationships to include */
        include?: ("experimentRuleSet" | "ruleSet")[];
      },
      params: RequestParams = {},
    ): Promise<GameCenterMatchmakingQueuesResponse> =>
      this.request<GameCenterMatchmakingQueuesResponse, ErrorResponse>({
        path: `/v1/gameCenterMatchmakingQueues`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterMatchmakingQueues
     * @name GameCenterMatchmakingQueuesCreateInstance
     * @request POST:/v1/gameCenterMatchmakingQueues
     * @secure
     */
    createInstance: (
      data: GameCenterMatchmakingQueueCreateRequest,
      params: RequestParams = {},
    ): Promise<GameCenterMatchmakingQueueResponse> =>
      this.request<GameCenterMatchmakingQueueResponse, ErrorResponse>({
        path: `/v1/gameCenterMatchmakingQueues`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterMatchmakingQueues
     * @name GameCenterMatchmakingQueuesGetInstance
     * @request GET:/v1/gameCenterMatchmakingQueues/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type gameCenterMatchmakingQueues */
        "fields[gameCenterMatchmakingQueues]"?: (
          | "classicMatchmakingBundleIds"
          | "experimentRuleSet"
          | "referenceName"
          | "ruleSet"
        )[];
        /** comma-separated list of relationships to include */
        include?: ("experimentRuleSet" | "ruleSet")[];
      },
      params: RequestParams = {},
    ): Promise<GameCenterMatchmakingQueueResponse> =>
      this.request<GameCenterMatchmakingQueueResponse, ErrorResponse>({
        path: `/v1/gameCenterMatchmakingQueues/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterMatchmakingQueues
     * @name GameCenterMatchmakingQueuesUpdateInstance
     * @request PATCH:/v1/gameCenterMatchmakingQueues/{id}
     * @secure
     */
    updateInstance: (
      id: string,
      data: GameCenterMatchmakingQueueUpdateRequest,
      params: RequestParams = {},
    ): Promise<GameCenterMatchmakingQueueResponse> =>
      this.request<GameCenterMatchmakingQueueResponse, ErrorResponse>({
        path: `/v1/gameCenterMatchmakingQueues/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterMatchmakingQueues
     * @name GameCenterMatchmakingQueuesDeleteInstance
     * @request DELETE:/v1/gameCenterMatchmakingQueues/{id}
     * @secure
     */
    deleteInstance: (id: string, params: RequestParams = {}): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/gameCenterMatchmakingQueues/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterMatchmakingQueues, Metrics
     * @name GameCenterMatchmakingQueuesExperimentMatchmakingQueueSizesGetMetrics
     * @request GET:/v1/gameCenterMatchmakingQueues/{id}/metrics/experimentMatchmakingQueueSizes
     * @secure
     */
    experimentMatchmakingQueueSizesGetMetrics: (
      id: string,
      query: {
        /**
         * maximum number of groups to return per page
         * @max 200
         */
        limit?: number;
        /** the granularity of the per-group dataset */
        granularity: "P1D" | "PT1H" | "PT15M";
        /** comma-separated list of sort expressions; metrics will be sorted as specified */
        sort?: (
          | "averageNumberOfRequests"
          | "-averageNumberOfRequests"
          | "count"
          | "-count"
          | "p50NumberOfRequests"
          | "-p50NumberOfRequests"
          | "p95NumberOfRequests"
          | "-p95NumberOfRequests"
        )[];
      },
      params: RequestParams = {},
    ): Promise<GameCenterMatchmakingQueueSizesV1MetricResponse> =>
      this.request<GameCenterMatchmakingQueueSizesV1MetricResponse, ErrorResponse>({
        path: `/v1/gameCenterMatchmakingQueues/${id}/metrics/experimentMatchmakingQueueSizes`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterMatchmakingQueues, Metrics
     * @name GameCenterMatchmakingQueuesExperimentMatchmakingRequestsGetMetrics
     * @request GET:/v1/gameCenterMatchmakingQueues/{id}/metrics/experimentMatchmakingRequests
     * @secure
     */
    experimentMatchmakingRequestsGetMetrics: (
      id: string,
      query: {
        /**
         * maximum number of groups to return per page
         * @max 200
         */
        limit?: number;
        /** the granularity of the per-group dataset */
        granularity: "P1D" | "PT1H" | "PT15M";
        /** the dimension by which to group the results */
        groupBy?: ("gameCenterDetail" | "result")[];
        /** filter by 'result' attribute dimension */
        "filter[result]"?: "MATCHED" | "CANCELED" | "EXPIRED";
        /** filter by 'gameCenterDetail' relationship dimension */
        "filter[gameCenterDetail]"?: string;
        /** comma-separated list of sort expressions; metrics will be sorted as specified */
        sort?: (
          | "averageSecondsInQueue"
          | "-averageSecondsInQueue"
          | "count"
          | "-count"
          | "p50SecondsInQueue"
          | "-p50SecondsInQueue"
          | "p95SecondsInQueue"
          | "-p95SecondsInQueue"
        )[];
      },
      params: RequestParams = {},
    ): Promise<GameCenterMatchmakingQueueRequestsV1MetricResponse> =>
      this.request<GameCenterMatchmakingQueueRequestsV1MetricResponse, ErrorResponse>({
        path: `/v1/gameCenterMatchmakingQueues/${id}/metrics/experimentMatchmakingRequests`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterMatchmakingQueues, Metrics
     * @name GameCenterMatchmakingQueuesMatchmakingQueueSizesGetMetrics
     * @request GET:/v1/gameCenterMatchmakingQueues/{id}/metrics/matchmakingQueueSizes
     * @secure
     */
    matchmakingQueueSizesGetMetrics: (
      id: string,
      query: {
        /**
         * maximum number of groups to return per page
         * @max 200
         */
        limit?: number;
        /** the granularity of the per-group dataset */
        granularity: "P1D" | "PT1H" | "PT15M";
        /** comma-separated list of sort expressions; metrics will be sorted as specified */
        sort?: (
          | "averageNumberOfRequests"
          | "-averageNumberOfRequests"
          | "count"
          | "-count"
          | "p50NumberOfRequests"
          | "-p50NumberOfRequests"
          | "p95NumberOfRequests"
          | "-p95NumberOfRequests"
        )[];
      },
      params: RequestParams = {},
    ): Promise<GameCenterMatchmakingQueueSizesV1MetricResponse> =>
      this.request<GameCenterMatchmakingQueueSizesV1MetricResponse, ErrorResponse>({
        path: `/v1/gameCenterMatchmakingQueues/${id}/metrics/matchmakingQueueSizes`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterMatchmakingQueues, Metrics
     * @name GameCenterMatchmakingQueuesMatchmakingRequestsGetMetrics
     * @request GET:/v1/gameCenterMatchmakingQueues/{id}/metrics/matchmakingRequests
     * @secure
     */
    matchmakingRequestsGetMetrics: (
      id: string,
      query: {
        /**
         * maximum number of groups to return per page
         * @max 200
         */
        limit?: number;
        /** the granularity of the per-group dataset */
        granularity: "P1D" | "PT1H" | "PT15M";
        /** the dimension by which to group the results */
        groupBy?: ("gameCenterDetail" | "result")[];
        /** filter by 'result' attribute dimension */
        "filter[result]"?: "MATCHED" | "CANCELED" | "EXPIRED";
        /** filter by 'gameCenterDetail' relationship dimension */
        "filter[gameCenterDetail]"?: string;
        /** comma-separated list of sort expressions; metrics will be sorted as specified */
        sort?: (
          | "averageSecondsInQueue"
          | "-averageSecondsInQueue"
          | "count"
          | "-count"
          | "p50SecondsInQueue"
          | "-p50SecondsInQueue"
          | "p95SecondsInQueue"
          | "-p95SecondsInQueue"
        )[];
      },
      params: RequestParams = {},
    ): Promise<GameCenterMatchmakingQueueRequestsV1MetricResponse> =>
      this.request<GameCenterMatchmakingQueueRequestsV1MetricResponse, ErrorResponse>({
        path: `/v1/gameCenterMatchmakingQueues/${id}/metrics/matchmakingRequests`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterMatchmakingQueues, Metrics
     * @name GameCenterMatchmakingQueuesMatchmakingSessionsGetMetrics
     * @request GET:/v1/gameCenterMatchmakingQueues/{id}/metrics/matchmakingSessions
     * @secure
     */
    matchmakingSessionsGetMetrics: (
      id: string,
      query: {
        /**
         * maximum number of groups to return per page
         * @max 200
         */
        limit?: number;
        /** the granularity of the per-group dataset */
        granularity: "P1D" | "PT1H" | "PT15M";
        /** comma-separated list of sort expressions; metrics will be sorted as specified */
        sort?: (
          | "averagePlayerCount"
          | "-averagePlayerCount"
          | "count"
          | "-count"
          | "p50PlayerCount"
          | "-p50PlayerCount"
          | "p95PlayerCount"
          | "-p95PlayerCount"
        )[];
      },
      params: RequestParams = {},
    ): Promise<GameCenterMatchmakingSessionsV1MetricResponse> =>
      this.request<GameCenterMatchmakingSessionsV1MetricResponse, ErrorResponse>({
        path: `/v1/gameCenterMatchmakingQueues/${id}/metrics/matchmakingSessions`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  gameCenterMatchmakingRuleSetTests = {
    /**
     * No description
     *
     * @tags GameCenterMatchmakingRuleSetTests
     * @name GameCenterMatchmakingRuleSetTestsCreateInstance
     * @request POST:/v1/gameCenterMatchmakingRuleSetTests
     * @secure
     */
    createInstance: (
      data: GameCenterMatchmakingRuleSetTestCreateRequest,
      params: RequestParams = {},
    ): Promise<GameCenterMatchmakingRuleSetTestResponse> =>
      this.request<GameCenterMatchmakingRuleSetTestResponse, ErrorResponse>({
        path: `/v1/gameCenterMatchmakingRuleSetTests`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),
  };
  gameCenterMatchmakingRuleSets = {
    /**
     * No description
     *
     * @tags GameCenterMatchmakingRuleSets
     * @name GameCenterMatchmakingRuleSetsGetCollection
     * @request GET:/v1/gameCenterMatchmakingRuleSets
     * @secure
     */
    getCollection: (
      query?: {
        /** the fields to include for returned resources of type gameCenterMatchmakingRuleSets */
        "fields[gameCenterMatchmakingRuleSets]"?: (
          | "matchmakingQueues"
          | "maxPlayers"
          | "minPlayers"
          | "referenceName"
          | "ruleLanguageVersion"
          | "rules"
          | "teams"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /** comma-separated list of relationships to include */
        include?: ("matchmakingQueues" | "rules" | "teams")[];
        /** the fields to include for returned resources of type gameCenterMatchmakingQueues */
        "fields[gameCenterMatchmakingQueues]"?: (
          | "classicMatchmakingBundleIds"
          | "experimentRuleSet"
          | "referenceName"
          | "ruleSet"
        )[];
        /** the fields to include for returned resources of type gameCenterMatchmakingTeams */
        "fields[gameCenterMatchmakingTeams]"?: ("maxPlayers" | "minPlayers" | "referenceName" | "ruleSet")[];
        /** the fields to include for returned resources of type gameCenterMatchmakingRules */
        "fields[gameCenterMatchmakingRules]"?: (
          | "description"
          | "expression"
          | "referenceName"
          | "ruleSet"
          | "type"
          | "weight"
        )[];
        /**
         * maximum number of related matchmakingQueues returned (when they are included)
         * @max 50
         */
        "limit[matchmakingQueues]"?: number;
        /**
         * maximum number of related rules returned (when they are included)
         * @max 50
         */
        "limit[rules]"?: number;
        /**
         * maximum number of related teams returned (when they are included)
         * @max 50
         */
        "limit[teams]"?: number;
      },
      params: RequestParams = {},
    ): Promise<GameCenterMatchmakingRuleSetsResponse> =>
      this.request<GameCenterMatchmakingRuleSetsResponse, ErrorResponse>({
        path: `/v1/gameCenterMatchmakingRuleSets`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterMatchmakingRuleSets
     * @name GameCenterMatchmakingRuleSetsCreateInstance
     * @request POST:/v1/gameCenterMatchmakingRuleSets
     * @secure
     */
    createInstance: (
      data: GameCenterMatchmakingRuleSetCreateRequest,
      params: RequestParams = {},
    ): Promise<GameCenterMatchmakingRuleSetResponse> =>
      this.request<GameCenterMatchmakingRuleSetResponse, ErrorResponse>({
        path: `/v1/gameCenterMatchmakingRuleSets`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterMatchmakingRuleSets
     * @name GameCenterMatchmakingRuleSetsGetInstance
     * @request GET:/v1/gameCenterMatchmakingRuleSets/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type gameCenterMatchmakingRuleSets */
        "fields[gameCenterMatchmakingRuleSets]"?: (
          | "matchmakingQueues"
          | "maxPlayers"
          | "minPlayers"
          | "referenceName"
          | "ruleLanguageVersion"
          | "rules"
          | "teams"
        )[];
        /** comma-separated list of relationships to include */
        include?: ("matchmakingQueues" | "rules" | "teams")[];
        /** the fields to include for returned resources of type gameCenterMatchmakingQueues */
        "fields[gameCenterMatchmakingQueues]"?: (
          | "classicMatchmakingBundleIds"
          | "experimentRuleSet"
          | "referenceName"
          | "ruleSet"
        )[];
        /** the fields to include for returned resources of type gameCenterMatchmakingTeams */
        "fields[gameCenterMatchmakingTeams]"?: ("maxPlayers" | "minPlayers" | "referenceName" | "ruleSet")[];
        /** the fields to include for returned resources of type gameCenterMatchmakingRules */
        "fields[gameCenterMatchmakingRules]"?: (
          | "description"
          | "expression"
          | "referenceName"
          | "ruleSet"
          | "type"
          | "weight"
        )[];
        /**
         * maximum number of related matchmakingQueues returned (when they are included)
         * @max 50
         */
        "limit[matchmakingQueues]"?: number;
        /**
         * maximum number of related rules returned (when they are included)
         * @max 50
         */
        "limit[rules]"?: number;
        /**
         * maximum number of related teams returned (when they are included)
         * @max 50
         */
        "limit[teams]"?: number;
      },
      params: RequestParams = {},
    ): Promise<GameCenterMatchmakingRuleSetResponse> =>
      this.request<GameCenterMatchmakingRuleSetResponse, ErrorResponse>({
        path: `/v1/gameCenterMatchmakingRuleSets/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterMatchmakingRuleSets
     * @name GameCenterMatchmakingRuleSetsUpdateInstance
     * @request PATCH:/v1/gameCenterMatchmakingRuleSets/{id}
     * @secure
     */
    updateInstance: (
      id: string,
      data: GameCenterMatchmakingRuleSetUpdateRequest,
      params: RequestParams = {},
    ): Promise<GameCenterMatchmakingRuleSetResponse> =>
      this.request<GameCenterMatchmakingRuleSetResponse, ErrorResponse>({
        path: `/v1/gameCenterMatchmakingRuleSets/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterMatchmakingRuleSets
     * @name GameCenterMatchmakingRuleSetsDeleteInstance
     * @request DELETE:/v1/gameCenterMatchmakingRuleSets/{id}
     * @secure
     */
    deleteInstance: (id: string, params: RequestParams = {}): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/gameCenterMatchmakingRuleSets/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterMatchmakingRuleSets
     * @name GameCenterMatchmakingRuleSetsMatchmakingQueuesGetToManyRelated
     * @request GET:/v1/gameCenterMatchmakingRuleSets/{id}/matchmakingQueues
     * @secure
     */
    matchmakingQueuesGetToManyRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type gameCenterMatchmakingQueues */
        "fields[gameCenterMatchmakingQueues]"?: (
          | "classicMatchmakingBundleIds"
          | "experimentRuleSet"
          | "referenceName"
          | "ruleSet"
        )[];
        /** the fields to include for returned resources of type gameCenterMatchmakingRuleSets */
        "fields[gameCenterMatchmakingRuleSets]"?: (
          | "matchmakingQueues"
          | "maxPlayers"
          | "minPlayers"
          | "referenceName"
          | "ruleLanguageVersion"
          | "rules"
          | "teams"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /** comma-separated list of relationships to include */
        include?: ("experimentRuleSet" | "ruleSet")[];
      },
      params: RequestParams = {},
    ): Promise<GameCenterMatchmakingQueuesResponse> =>
      this.request<GameCenterMatchmakingQueuesResponse, ErrorResponse>({
        path: `/v1/gameCenterMatchmakingRuleSets/${id}/matchmakingQueues`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterMatchmakingRuleSets
     * @name GameCenterMatchmakingRuleSetsRulesGetToManyRelated
     * @request GET:/v1/gameCenterMatchmakingRuleSets/{id}/rules
     * @secure
     */
    rulesGetToManyRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type gameCenterMatchmakingRules */
        "fields[gameCenterMatchmakingRules]"?: (
          | "description"
          | "expression"
          | "referenceName"
          | "ruleSet"
          | "type"
          | "weight"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
      },
      params: RequestParams = {},
    ): Promise<GameCenterMatchmakingRulesResponse> =>
      this.request<GameCenterMatchmakingRulesResponse, ErrorResponse>({
        path: `/v1/gameCenterMatchmakingRuleSets/${id}/rules`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterMatchmakingRuleSets
     * @name GameCenterMatchmakingRuleSetsTeamsGetToManyRelated
     * @request GET:/v1/gameCenterMatchmakingRuleSets/{id}/teams
     * @secure
     */
    teamsGetToManyRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type gameCenterMatchmakingTeams */
        "fields[gameCenterMatchmakingTeams]"?: ("maxPlayers" | "minPlayers" | "referenceName" | "ruleSet")[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
      },
      params: RequestParams = {},
    ): Promise<GameCenterMatchmakingTeamsResponse> =>
      this.request<GameCenterMatchmakingTeamsResponse, ErrorResponse>({
        path: `/v1/gameCenterMatchmakingRuleSets/${id}/teams`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  gameCenterMatchmakingRules = {
    /**
     * No description
     *
     * @tags GameCenterMatchmakingRules
     * @name GameCenterMatchmakingRulesCreateInstance
     * @request POST:/v1/gameCenterMatchmakingRules
     * @secure
     */
    createInstance: (
      data: GameCenterMatchmakingRuleCreateRequest,
      params: RequestParams = {},
    ): Promise<GameCenterMatchmakingRuleResponse> =>
      this.request<GameCenterMatchmakingRuleResponse, ErrorResponse>({
        path: `/v1/gameCenterMatchmakingRules`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterMatchmakingRules
     * @name GameCenterMatchmakingRulesUpdateInstance
     * @request PATCH:/v1/gameCenterMatchmakingRules/{id}
     * @secure
     */
    updateInstance: (
      id: string,
      data: GameCenterMatchmakingRuleUpdateRequest,
      params: RequestParams = {},
    ): Promise<GameCenterMatchmakingRuleResponse> =>
      this.request<GameCenterMatchmakingRuleResponse, ErrorResponse>({
        path: `/v1/gameCenterMatchmakingRules/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterMatchmakingRules
     * @name GameCenterMatchmakingRulesDeleteInstance
     * @request DELETE:/v1/gameCenterMatchmakingRules/{id}
     * @secure
     */
    deleteInstance: (id: string, params: RequestParams = {}): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/gameCenterMatchmakingRules/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterMatchmakingRules, Metrics
     * @name GameCenterMatchmakingRulesMatchmakingBooleanRuleResultsGetMetrics
     * @request GET:/v1/gameCenterMatchmakingRules/{id}/metrics/matchmakingBooleanRuleResults
     * @secure
     */
    matchmakingBooleanRuleResultsGetMetrics: (
      id: string,
      query: {
        /**
         * maximum number of groups to return per page
         * @max 200
         */
        limit?: number;
        /** the granularity of the per-group dataset */
        granularity: "P1D" | "PT1H" | "PT15M";
        /** the dimension by which to group the results */
        groupBy?: ("gameCenterMatchmakingQueue" | "result")[];
        /** filter by 'result' attribute dimension */
        "filter[result]"?: string;
        /** filter by 'gameCenterMatchmakingQueue' relationship dimension */
        "filter[gameCenterMatchmakingQueue]"?: string;
        /** comma-separated list of sort expressions; metrics will be sorted as specified */
        sort?: ("count" | "-count")[];
      },
      params: RequestParams = {},
    ): Promise<GameCenterMatchmakingBooleanRuleResultsV1MetricResponse> =>
      this.request<GameCenterMatchmakingBooleanRuleResultsV1MetricResponse, ErrorResponse>({
        path: `/v1/gameCenterMatchmakingRules/${id}/metrics/matchmakingBooleanRuleResults`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterMatchmakingRules, Metrics
     * @name GameCenterMatchmakingRulesMatchmakingNumberRuleResultsGetMetrics
     * @request GET:/v1/gameCenterMatchmakingRules/{id}/metrics/matchmakingNumberRuleResults
     * @secure
     */
    matchmakingNumberRuleResultsGetMetrics: (
      id: string,
      query: {
        /**
         * maximum number of groups to return per page
         * @max 200
         */
        limit?: number;
        /** the granularity of the per-group dataset */
        granularity: "P1D" | "PT1H" | "PT15M";
        /** the dimension by which to group the results */
        groupBy?: "gameCenterMatchmakingQueue"[];
        /** filter by 'gameCenterMatchmakingQueue' relationship dimension */
        "filter[gameCenterMatchmakingQueue]"?: string;
        /** comma-separated list of sort expressions; metrics will be sorted as specified */
        sort?: (
          | "averageResult"
          | "-averageResult"
          | "count"
          | "-count"
          | "p50Result"
          | "-p50Result"
          | "p95Result"
          | "-p95Result"
        )[];
      },
      params: RequestParams = {},
    ): Promise<GameCenterMatchmakingNumberRuleResultsV1MetricResponse> =>
      this.request<GameCenterMatchmakingNumberRuleResultsV1MetricResponse, ErrorResponse>({
        path: `/v1/gameCenterMatchmakingRules/${id}/metrics/matchmakingNumberRuleResults`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterMatchmakingRules, Metrics
     * @name GameCenterMatchmakingRulesMatchmakingRuleErrorsGetMetrics
     * @request GET:/v1/gameCenterMatchmakingRules/{id}/metrics/matchmakingRuleErrors
     * @secure
     */
    matchmakingRuleErrorsGetMetrics: (
      id: string,
      query: {
        /**
         * maximum number of groups to return per page
         * @max 200
         */
        limit?: number;
        /** the granularity of the per-group dataset */
        granularity: "P1D" | "PT1H" | "PT15M";
        /** the dimension by which to group the results */
        groupBy?: "gameCenterMatchmakingQueue"[];
        /** filter by 'gameCenterMatchmakingQueue' relationship dimension */
        "filter[gameCenterMatchmakingQueue]"?: string;
        /** comma-separated list of sort expressions; metrics will be sorted as specified */
        sort?: ("count" | "-count")[];
      },
      params: RequestParams = {},
    ): Promise<GameCenterMatchmakingRuleErrorsV1MetricResponse> =>
      this.request<GameCenterMatchmakingRuleErrorsV1MetricResponse, ErrorResponse>({
        path: `/v1/gameCenterMatchmakingRules/${id}/metrics/matchmakingRuleErrors`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  gameCenterMatchmakingTeams = {
    /**
     * No description
     *
     * @tags GameCenterMatchmakingTeams
     * @name GameCenterMatchmakingTeamsCreateInstance
     * @request POST:/v1/gameCenterMatchmakingTeams
     * @secure
     */
    createInstance: (
      data: GameCenterMatchmakingTeamCreateRequest,
      params: RequestParams = {},
    ): Promise<GameCenterMatchmakingTeamResponse> =>
      this.request<GameCenterMatchmakingTeamResponse, ErrorResponse>({
        path: `/v1/gameCenterMatchmakingTeams`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterMatchmakingTeams
     * @name GameCenterMatchmakingTeamsUpdateInstance
     * @request PATCH:/v1/gameCenterMatchmakingTeams/{id}
     * @secure
     */
    updateInstance: (
      id: string,
      data: GameCenterMatchmakingTeamUpdateRequest,
      params: RequestParams = {},
    ): Promise<GameCenterMatchmakingTeamResponse> =>
      this.request<GameCenterMatchmakingTeamResponse, ErrorResponse>({
        path: `/v1/gameCenterMatchmakingTeams/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterMatchmakingTeams
     * @name GameCenterMatchmakingTeamsDeleteInstance
     * @request DELETE:/v1/gameCenterMatchmakingTeams/{id}
     * @secure
     */
    deleteInstance: (id: string, params: RequestParams = {}): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/gameCenterMatchmakingTeams/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),
  };
  gameCenterPlayerAchievementSubmissions = {
    /**
     * No description
     *
     * @tags GameCenterPlayerAchievementSubmissions
     * @name GameCenterPlayerAchievementSubmissionsCreateInstance
     * @request POST:/v1/gameCenterPlayerAchievementSubmissions
     * @secure
     */
    createInstance: (
      data: GameCenterPlayerAchievementSubmissionCreateRequest,
      params: RequestParams = {},
    ): Promise<GameCenterPlayerAchievementSubmissionResponse> =>
      this.request<GameCenterPlayerAchievementSubmissionResponse, ErrorResponse>({
        path: `/v1/gameCenterPlayerAchievementSubmissions`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),
  };
  inAppPurchaseAppStoreReviewScreenshots = {
    /**
     * No description
     *
     * @tags InAppPurchaseAppStoreReviewScreenshots
     * @name InAppPurchaseAppStoreReviewScreenshotsCreateInstance
     * @request POST:/v1/inAppPurchaseAppStoreReviewScreenshots
     * @secure
     */
    createInstance: (
      data: InAppPurchaseAppStoreReviewScreenshotCreateRequest,
      params: RequestParams = {},
    ): Promise<InAppPurchaseAppStoreReviewScreenshotResponse> =>
      this.request<InAppPurchaseAppStoreReviewScreenshotResponse, ErrorResponse>({
        path: `/v1/inAppPurchaseAppStoreReviewScreenshots`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags InAppPurchaseAppStoreReviewScreenshots
     * @name InAppPurchaseAppStoreReviewScreenshotsGetInstance
     * @request GET:/v1/inAppPurchaseAppStoreReviewScreenshots/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type inAppPurchaseAppStoreReviewScreenshots */
        "fields[inAppPurchaseAppStoreReviewScreenshots]"?: (
          | "assetDeliveryState"
          | "assetToken"
          | "assetType"
          | "fileName"
          | "fileSize"
          | "imageAsset"
          | "inAppPurchaseV2"
          | "sourceFileChecksum"
          | "uploadOperations"
          | "uploaded"
        )[];
        /** comma-separated list of relationships to include */
        include?: "inAppPurchaseV2"[];
      },
      params: RequestParams = {},
    ): Promise<InAppPurchaseAppStoreReviewScreenshotResponse> =>
      this.request<InAppPurchaseAppStoreReviewScreenshotResponse, ErrorResponse>({
        path: `/v1/inAppPurchaseAppStoreReviewScreenshots/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags InAppPurchaseAppStoreReviewScreenshots
     * @name InAppPurchaseAppStoreReviewScreenshotsUpdateInstance
     * @request PATCH:/v1/inAppPurchaseAppStoreReviewScreenshots/{id}
     * @secure
     */
    updateInstance: (
      id: string,
      data: InAppPurchaseAppStoreReviewScreenshotUpdateRequest,
      params: RequestParams = {},
    ): Promise<InAppPurchaseAppStoreReviewScreenshotResponse> =>
      this.request<InAppPurchaseAppStoreReviewScreenshotResponse, ErrorResponse>({
        path: `/v1/inAppPurchaseAppStoreReviewScreenshots/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags InAppPurchaseAppStoreReviewScreenshots
     * @name InAppPurchaseAppStoreReviewScreenshotsDeleteInstance
     * @request DELETE:/v1/inAppPurchaseAppStoreReviewScreenshots/{id}
     * @secure
     */
    deleteInstance: (id: string, params: RequestParams = {}): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/inAppPurchaseAppStoreReviewScreenshots/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),
  };
  inAppPurchaseAvailabilities = {
    /**
     * No description
     *
     * @tags InAppPurchaseAvailabilities
     * @name InAppPurchaseAvailabilitiesCreateInstance
     * @request POST:/v1/inAppPurchaseAvailabilities
     * @secure
     */
    createInstance: (
      data: InAppPurchaseAvailabilityCreateRequest,
      params: RequestParams = {},
    ): Promise<InAppPurchaseAvailabilityResponse> =>
      this.request<InAppPurchaseAvailabilityResponse, ErrorResponse>({
        path: `/v1/inAppPurchaseAvailabilities`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags InAppPurchaseAvailabilities
     * @name InAppPurchaseAvailabilitiesGetInstance
     * @request GET:/v1/inAppPurchaseAvailabilities/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type inAppPurchaseAvailabilities */
        "fields[inAppPurchaseAvailabilities]"?: (
          | "availableInNewTerritories"
          | "availableTerritories"
          | "inAppPurchase"
        )[];
        /** comma-separated list of relationships to include */
        include?: "availableTerritories"[];
        /** the fields to include for returned resources of type territories */
        "fields[territories]"?: "currency"[];
        /**
         * maximum number of related availableTerritories returned (when they are included)
         * @max 50
         */
        "limit[availableTerritories]"?: number;
      },
      params: RequestParams = {},
    ): Promise<InAppPurchaseAvailabilityResponse> =>
      this.request<InAppPurchaseAvailabilityResponse, ErrorResponse>({
        path: `/v1/inAppPurchaseAvailabilities/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags InAppPurchaseAvailabilities
     * @name InAppPurchaseAvailabilitiesAvailableTerritoriesGetToManyRelated
     * @request GET:/v1/inAppPurchaseAvailabilities/{id}/availableTerritories
     * @secure
     */
    availableTerritoriesGetToManyRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type territories */
        "fields[territories]"?: "currency"[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
      },
      params: RequestParams = {},
    ): Promise<TerritoriesResponse> =>
      this.request<TerritoriesResponse, ErrorResponse>({
        path: `/v1/inAppPurchaseAvailabilities/${id}/availableTerritories`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  inAppPurchaseContents = {
    /**
     * No description
     *
     * @tags InAppPurchaseContents
     * @name InAppPurchaseContentsGetInstance
     * @request GET:/v1/inAppPurchaseContents/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type inAppPurchaseContents */
        "fields[inAppPurchaseContents]"?: ("fileName" | "fileSize" | "inAppPurchaseV2" | "lastModifiedDate" | "url")[];
        /** comma-separated list of relationships to include */
        include?: "inAppPurchaseV2"[];
      },
      params: RequestParams = {},
    ): Promise<InAppPurchaseContentResponse> =>
      this.request<InAppPurchaseContentResponse, ErrorResponse>({
        path: `/v1/inAppPurchaseContents/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  inAppPurchaseLocalizations = {
    /**
     * No description
     *
     * @tags InAppPurchaseLocalizations
     * @name InAppPurchaseLocalizationsCreateInstance
     * @request POST:/v1/inAppPurchaseLocalizations
     * @secure
     */
    createInstance: (
      data: InAppPurchaseLocalizationCreateRequest,
      params: RequestParams = {},
    ): Promise<InAppPurchaseLocalizationResponse> =>
      this.request<InAppPurchaseLocalizationResponse, ErrorResponse>({
        path: `/v1/inAppPurchaseLocalizations`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags InAppPurchaseLocalizations
     * @name InAppPurchaseLocalizationsGetInstance
     * @request GET:/v1/inAppPurchaseLocalizations/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type inAppPurchaseLocalizations */
        "fields[inAppPurchaseLocalizations]"?: ("description" | "inAppPurchaseV2" | "locale" | "name" | "state")[];
        /** comma-separated list of relationships to include */
        include?: "inAppPurchaseV2"[];
      },
      params: RequestParams = {},
    ): Promise<InAppPurchaseLocalizationResponse> =>
      this.request<InAppPurchaseLocalizationResponse, ErrorResponse>({
        path: `/v1/inAppPurchaseLocalizations/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags InAppPurchaseLocalizations
     * @name InAppPurchaseLocalizationsUpdateInstance
     * @request PATCH:/v1/inAppPurchaseLocalizations/{id}
     * @secure
     */
    updateInstance: (
      id: string,
      data: InAppPurchaseLocalizationUpdateRequest,
      params: RequestParams = {},
    ): Promise<InAppPurchaseLocalizationResponse> =>
      this.request<InAppPurchaseLocalizationResponse, ErrorResponse>({
        path: `/v1/inAppPurchaseLocalizations/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags InAppPurchaseLocalizations
     * @name InAppPurchaseLocalizationsDeleteInstance
     * @request DELETE:/v1/inAppPurchaseLocalizations/{id}
     * @secure
     */
    deleteInstance: (id: string, params: RequestParams = {}): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/inAppPurchaseLocalizations/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),
  };
  inAppPurchasePriceSchedules = {
    /**
     * No description
     *
     * @tags InAppPurchasePriceSchedules
     * @name InAppPurchasePriceSchedulesCreateInstance
     * @request POST:/v1/inAppPurchasePriceSchedules
     * @secure
     */
    createInstance: (
      data: InAppPurchasePriceScheduleCreateRequest,
      params: RequestParams = {},
    ): Promise<InAppPurchasePriceScheduleResponse> =>
      this.request<InAppPurchasePriceScheduleResponse, ErrorResponse>({
        path: `/v1/inAppPurchasePriceSchedules`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags InAppPurchasePriceSchedules
     * @name InAppPurchasePriceSchedulesGetInstance
     * @request GET:/v1/inAppPurchasePriceSchedules/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type inAppPurchasePriceSchedules */
        "fields[inAppPurchasePriceSchedules]"?: (
          | "automaticPrices"
          | "baseTerritory"
          | "inAppPurchase"
          | "manualPrices"
        )[];
        /** comma-separated list of relationships to include */
        include?: ("automaticPrices" | "baseTerritory" | "inAppPurchase" | "manualPrices")[];
        /** the fields to include for returned resources of type inAppPurchasePrices */
        "fields[inAppPurchasePrices]"?: (
          | "endDate"
          | "inAppPurchasePricePoint"
          | "inAppPurchaseV2"
          | "manual"
          | "startDate"
          | "territory"
        )[];
        /** the fields to include for returned resources of type territories */
        "fields[territories]"?: "currency"[];
        /**
         * maximum number of related automaticPrices returned (when they are included)
         * @max 50
         */
        "limit[automaticPrices]"?: number;
        /**
         * maximum number of related manualPrices returned (when they are included)
         * @max 50
         */
        "limit[manualPrices]"?: number;
      },
      params: RequestParams = {},
    ): Promise<InAppPurchasePriceScheduleResponse> =>
      this.request<InAppPurchasePriceScheduleResponse, ErrorResponse>({
        path: `/v1/inAppPurchasePriceSchedules/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags InAppPurchasePriceSchedules
     * @name InAppPurchasePriceSchedulesAutomaticPricesGetToManyRelated
     * @request GET:/v1/inAppPurchasePriceSchedules/{id}/automaticPrices
     * @secure
     */
    automaticPricesGetToManyRelated: (
      id: string,
      query?: {
        /** filter by id(s) of related 'territory' */
        "filter[territory]"?: string[];
        /** the fields to include for returned resources of type inAppPurchasePricePoints */
        "fields[inAppPurchasePricePoints]"?: (
          | "customerPrice"
          | "inAppPurchaseV2"
          | "priceTier"
          | "proceeds"
          | "territory"
        )[];
        /** the fields to include for returned resources of type inAppPurchasePrices */
        "fields[inAppPurchasePrices]"?: (
          | "endDate"
          | "inAppPurchasePricePoint"
          | "inAppPurchaseV2"
          | "manual"
          | "startDate"
          | "territory"
        )[];
        /** the fields to include for returned resources of type territories */
        "fields[territories]"?: "currency"[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /** comma-separated list of relationships to include */
        include?: ("inAppPurchasePricePoint" | "territory")[];
      },
      params: RequestParams = {},
    ): Promise<InAppPurchasePricesResponse> =>
      this.request<InAppPurchasePricesResponse, ErrorResponse>({
        path: `/v1/inAppPurchasePriceSchedules/${id}/automaticPrices`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags InAppPurchasePriceSchedules
     * @name InAppPurchasePriceSchedulesBaseTerritoryGetToOneRelated
     * @request GET:/v1/inAppPurchasePriceSchedules/{id}/baseTerritory
     * @secure
     */
    baseTerritoryGetToOneRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type territories */
        "fields[territories]"?: "currency"[];
      },
      params: RequestParams = {},
    ): Promise<TerritoryResponse> =>
      this.request<TerritoryResponse, ErrorResponse>({
        path: `/v1/inAppPurchasePriceSchedules/${id}/baseTerritory`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags InAppPurchasePriceSchedules
     * @name InAppPurchasePriceSchedulesManualPricesGetToManyRelated
     * @request GET:/v1/inAppPurchasePriceSchedules/{id}/manualPrices
     * @secure
     */
    manualPricesGetToManyRelated: (
      id: string,
      query?: {
        /** filter by id(s) of related 'territory' */
        "filter[territory]"?: string[];
        /** the fields to include for returned resources of type inAppPurchasePricePoints */
        "fields[inAppPurchasePricePoints]"?: (
          | "customerPrice"
          | "inAppPurchaseV2"
          | "priceTier"
          | "proceeds"
          | "territory"
        )[];
        /** the fields to include for returned resources of type inAppPurchasePrices */
        "fields[inAppPurchasePrices]"?: (
          | "endDate"
          | "inAppPurchasePricePoint"
          | "inAppPurchaseV2"
          | "manual"
          | "startDate"
          | "territory"
        )[];
        /** the fields to include for returned resources of type territories */
        "fields[territories]"?: "currency"[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /** comma-separated list of relationships to include */
        include?: ("inAppPurchasePricePoint" | "territory")[];
      },
      params: RequestParams = {},
    ): Promise<InAppPurchasePricesResponse> =>
      this.request<InAppPurchasePricesResponse, ErrorResponse>({
        path: `/v1/inAppPurchasePriceSchedules/${id}/manualPrices`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  inAppPurchaseSubmissions = {
    /**
     * No description
     *
     * @tags InAppPurchaseSubmissions
     * @name InAppPurchaseSubmissionsCreateInstance
     * @request POST:/v1/inAppPurchaseSubmissions
     * @secure
     */
    createInstance: (
      data: InAppPurchaseSubmissionCreateRequest,
      params: RequestParams = {},
    ): Promise<InAppPurchaseSubmissionResponse> =>
      this.request<InAppPurchaseSubmissionResponse, ErrorResponse>({
        path: `/v1/inAppPurchaseSubmissions`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),
  };
  inAppPurchases = {
    /**
     * No description
     *
     * @tags InAppPurchases
     * @name InAppPurchasesGetInstance
     * @request GET:/v1/inAppPurchases/{id}
     * @deprecated
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type inAppPurchases */
        "fields[inAppPurchases]"?: ("apps" | "inAppPurchaseType" | "productId" | "referenceName" | "state")[];
        /** comma-separated list of relationships to include */
        include?: "apps"[];
        /**
         * maximum number of related apps returned (when they are included)
         * @max 50
         */
        "limit[apps]"?: number;
      },
      params: RequestParams = {},
    ): Promise<InAppPurchaseResponse> =>
      this.request<InAppPurchaseResponse, ErrorResponse>({
        path: `/v1/inAppPurchases/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags InAppPurchases
     * @name InAppPurchasesV2CreateInstance
     * @request POST:/v2/inAppPurchases
     * @secure
     */
    v2CreateInstance: (
      data: InAppPurchaseV2CreateRequest,
      params: RequestParams = {},
    ): Promise<InAppPurchaseV2Response> =>
      this.request<InAppPurchaseV2Response, ErrorResponse>({
        path: `/v2/inAppPurchases`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags InAppPurchases
     * @name InAppPurchasesV2GetInstance
     * @request GET:/v2/inAppPurchases/{id}
     * @secure
     */
    v2GetInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type inAppPurchases */
        "fields[inAppPurchases]"?: (
          | "app"
          | "appStoreReviewScreenshot"
          | "content"
          | "contentHosting"
          | "familySharable"
          | "iapPriceSchedule"
          | "inAppPurchaseAvailability"
          | "inAppPurchaseLocalizations"
          | "inAppPurchaseType"
          | "name"
          | "pricePoints"
          | "productId"
          | "promotedPurchase"
          | "reviewNote"
          | "state"
        )[];
        /** comma-separated list of relationships to include */
        include?: (
          | "appStoreReviewScreenshot"
          | "content"
          | "iapPriceSchedule"
          | "inAppPurchaseAvailability"
          | "inAppPurchaseLocalizations"
          | "pricePoints"
          | "promotedPurchase"
        )[];
        /** the fields to include for returned resources of type inAppPurchaseAvailabilities */
        "fields[inAppPurchaseAvailabilities]"?: (
          | "availableInNewTerritories"
          | "availableTerritories"
          | "inAppPurchase"
        )[];
        /** the fields to include for returned resources of type inAppPurchaseAppStoreReviewScreenshots */
        "fields[inAppPurchaseAppStoreReviewScreenshots]"?: (
          | "assetDeliveryState"
          | "assetToken"
          | "assetType"
          | "fileName"
          | "fileSize"
          | "imageAsset"
          | "inAppPurchaseV2"
          | "sourceFileChecksum"
          | "uploadOperations"
          | "uploaded"
        )[];
        /** the fields to include for returned resources of type promotedPurchases */
        "fields[promotedPurchases]"?: (
          | "app"
          | "enabled"
          | "inAppPurchaseV2"
          | "promotionImages"
          | "state"
          | "subscription"
          | "visibleForAllUsers"
        )[];
        /** the fields to include for returned resources of type inAppPurchasePricePoints */
        "fields[inAppPurchasePricePoints]"?: (
          | "customerPrice"
          | "inAppPurchaseV2"
          | "priceTier"
          | "proceeds"
          | "territory"
        )[];
        /** the fields to include for returned resources of type inAppPurchaseLocalizations */
        "fields[inAppPurchaseLocalizations]"?: ("description" | "inAppPurchaseV2" | "locale" | "name" | "state")[];
        /** the fields to include for returned resources of type inAppPurchasePriceSchedules */
        "fields[inAppPurchasePriceSchedules]"?: (
          | "automaticPrices"
          | "baseTerritory"
          | "inAppPurchase"
          | "manualPrices"
        )[];
        /** the fields to include for returned resources of type inAppPurchaseContents */
        "fields[inAppPurchaseContents]"?: ("fileName" | "fileSize" | "inAppPurchaseV2" | "lastModifiedDate" | "url")[];
        /**
         * maximum number of related inAppPurchaseLocalizations returned (when they are included)
         * @max 50
         */
        "limit[inAppPurchaseLocalizations]"?: number;
        /**
         * maximum number of related pricePoints returned (when they are included)
         * @max 8000
         */
        "limit[pricePoints]"?: number;
      },
      params: RequestParams = {},
    ): Promise<InAppPurchaseV2Response> =>
      this.request<InAppPurchaseV2Response, ErrorResponse>({
        path: `/v2/inAppPurchases/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags InAppPurchases
     * @name InAppPurchasesV2UpdateInstance
     * @request PATCH:/v2/inAppPurchases/{id}
     * @secure
     */
    v2UpdateInstance: (
      id: string,
      data: InAppPurchaseV2UpdateRequest,
      params: RequestParams = {},
    ): Promise<InAppPurchaseV2Response> =>
      this.request<InAppPurchaseV2Response, ErrorResponse>({
        path: `/v2/inAppPurchases/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags InAppPurchases
     * @name InAppPurchasesV2DeleteInstance
     * @request DELETE:/v2/inAppPurchases/{id}
     * @secure
     */
    v2DeleteInstance: (id: string, params: RequestParams = {}): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v2/inAppPurchases/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),

    /**
     * No description
     *
     * @tags InAppPurchases
     * @name InAppPurchasesV2AppStoreReviewScreenshotGetToOneRelated
     * @request GET:/v2/inAppPurchases/{id}/appStoreReviewScreenshot
     * @secure
     */
    v2AppStoreReviewScreenshotGetToOneRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type inAppPurchaseAppStoreReviewScreenshots */
        "fields[inAppPurchaseAppStoreReviewScreenshots]"?: (
          | "assetDeliveryState"
          | "assetToken"
          | "assetType"
          | "fileName"
          | "fileSize"
          | "imageAsset"
          | "inAppPurchaseV2"
          | "sourceFileChecksum"
          | "uploadOperations"
          | "uploaded"
        )[];
        /** the fields to include for returned resources of type inAppPurchases */
        "fields[inAppPurchases]"?: (
          | "app"
          | "appStoreReviewScreenshot"
          | "content"
          | "contentHosting"
          | "familySharable"
          | "iapPriceSchedule"
          | "inAppPurchaseAvailability"
          | "inAppPurchaseLocalizations"
          | "inAppPurchaseType"
          | "name"
          | "pricePoints"
          | "productId"
          | "promotedPurchase"
          | "reviewNote"
          | "state"
        )[];
        /** comma-separated list of relationships to include */
        include?: "inAppPurchaseV2"[];
      },
      params: RequestParams = {},
    ): Promise<InAppPurchaseAppStoreReviewScreenshotResponse> =>
      this.request<InAppPurchaseAppStoreReviewScreenshotResponse, ErrorResponse>({
        path: `/v2/inAppPurchases/${id}/appStoreReviewScreenshot`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags InAppPurchases
     * @name InAppPurchasesV2ContentGetToOneRelated
     * @request GET:/v2/inAppPurchases/{id}/content
     * @secure
     */
    v2ContentGetToOneRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type inAppPurchases */
        "fields[inAppPurchases]"?: (
          | "app"
          | "appStoreReviewScreenshot"
          | "content"
          | "contentHosting"
          | "familySharable"
          | "iapPriceSchedule"
          | "inAppPurchaseAvailability"
          | "inAppPurchaseLocalizations"
          | "inAppPurchaseType"
          | "name"
          | "pricePoints"
          | "productId"
          | "promotedPurchase"
          | "reviewNote"
          | "state"
        )[];
        /** the fields to include for returned resources of type inAppPurchaseContents */
        "fields[inAppPurchaseContents]"?: ("fileName" | "fileSize" | "inAppPurchaseV2" | "lastModifiedDate" | "url")[];
        /** comma-separated list of relationships to include */
        include?: "inAppPurchaseV2"[];
      },
      params: RequestParams = {},
    ): Promise<InAppPurchaseContentResponse> =>
      this.request<InAppPurchaseContentResponse, ErrorResponse>({
        path: `/v2/inAppPurchases/${id}/content`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags InAppPurchases
     * @name InAppPurchasesV2IapPriceScheduleGetToOneRelated
     * @request GET:/v2/inAppPurchases/{id}/iapPriceSchedule
     * @secure
     */
    v2IapPriceScheduleGetToOneRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type inAppPurchasePrices */
        "fields[inAppPurchasePrices]"?: (
          | "endDate"
          | "inAppPurchasePricePoint"
          | "inAppPurchaseV2"
          | "manual"
          | "startDate"
          | "territory"
        )[];
        /** the fields to include for returned resources of type inAppPurchases */
        "fields[inAppPurchases]"?: (
          | "app"
          | "appStoreReviewScreenshot"
          | "content"
          | "contentHosting"
          | "familySharable"
          | "iapPriceSchedule"
          | "inAppPurchaseAvailability"
          | "inAppPurchaseLocalizations"
          | "inAppPurchaseType"
          | "name"
          | "pricePoints"
          | "productId"
          | "promotedPurchase"
          | "reviewNote"
          | "state"
        )[];
        /** the fields to include for returned resources of type inAppPurchasePriceSchedules */
        "fields[inAppPurchasePriceSchedules]"?: (
          | "automaticPrices"
          | "baseTerritory"
          | "inAppPurchase"
          | "manualPrices"
        )[];
        /** the fields to include for returned resources of type territories */
        "fields[territories]"?: "currency"[];
        /**
         * maximum number of related manualPrices returned (when they are included)
         * @max 50
         */
        "limit[manualPrices]"?: number;
        /**
         * maximum number of related automaticPrices returned (when they are included)
         * @max 50
         */
        "limit[automaticPrices]"?: number;
        /** comma-separated list of relationships to include */
        include?: ("automaticPrices" | "baseTerritory" | "inAppPurchase" | "manualPrices")[];
      },
      params: RequestParams = {},
    ): Promise<InAppPurchasePriceScheduleResponse> =>
      this.request<InAppPurchasePriceScheduleResponse, ErrorResponse>({
        path: `/v2/inAppPurchases/${id}/iapPriceSchedule`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags InAppPurchases
     * @name InAppPurchasesV2InAppPurchaseAvailabilityGetToOneRelated
     * @request GET:/v2/inAppPurchases/{id}/inAppPurchaseAvailability
     * @secure
     */
    v2InAppPurchaseAvailabilityGetToOneRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type inAppPurchaseAvailabilities */
        "fields[inAppPurchaseAvailabilities]"?: (
          | "availableInNewTerritories"
          | "availableTerritories"
          | "inAppPurchase"
        )[];
        /** the fields to include for returned resources of type territories */
        "fields[territories]"?: "currency"[];
        /**
         * maximum number of related availableTerritories returned (when they are included)
         * @max 50
         */
        "limit[availableTerritories]"?: number;
        /** comma-separated list of relationships to include */
        include?: "availableTerritories"[];
      },
      params: RequestParams = {},
    ): Promise<InAppPurchaseAvailabilityResponse> =>
      this.request<InAppPurchaseAvailabilityResponse, ErrorResponse>({
        path: `/v2/inAppPurchases/${id}/inAppPurchaseAvailability`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags InAppPurchases
     * @name InAppPurchasesV2InAppPurchaseLocalizationsGetToManyRelated
     * @request GET:/v2/inAppPurchases/{id}/inAppPurchaseLocalizations
     * @secure
     */
    v2InAppPurchaseLocalizationsGetToManyRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type inAppPurchaseLocalizations */
        "fields[inAppPurchaseLocalizations]"?: ("description" | "inAppPurchaseV2" | "locale" | "name" | "state")[];
        /** the fields to include for returned resources of type inAppPurchases */
        "fields[inAppPurchases]"?: (
          | "app"
          | "appStoreReviewScreenshot"
          | "content"
          | "contentHosting"
          | "familySharable"
          | "iapPriceSchedule"
          | "inAppPurchaseAvailability"
          | "inAppPurchaseLocalizations"
          | "inAppPurchaseType"
          | "name"
          | "pricePoints"
          | "productId"
          | "promotedPurchase"
          | "reviewNote"
          | "state"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /** comma-separated list of relationships to include */
        include?: "inAppPurchaseV2"[];
      },
      params: RequestParams = {},
    ): Promise<InAppPurchaseLocalizationsResponse> =>
      this.request<InAppPurchaseLocalizationsResponse, ErrorResponse>({
        path: `/v2/inAppPurchases/${id}/inAppPurchaseLocalizations`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags InAppPurchases
     * @name InAppPurchasesV2PricePointsGetToManyRelated
     * @request GET:/v2/inAppPurchases/{id}/pricePoints
     * @secure
     */
    v2PricePointsGetToManyRelated: (
      id: string,
      query?: {
        /** filter by attribute 'priceTier' */
        "filter[priceTier]"?: string[];
        /** filter by id(s) of related 'territory' */
        "filter[territory]"?: string[];
        /** the fields to include for returned resources of type inAppPurchasePricePoints */
        "fields[inAppPurchasePricePoints]"?: (
          | "customerPrice"
          | "inAppPurchaseV2"
          | "priceTier"
          | "proceeds"
          | "territory"
        )[];
        /** the fields to include for returned resources of type territories */
        "fields[territories]"?: "currency"[];
        /**
         * maximum resources per page
         * @max 8000
         */
        limit?: number;
        /** comma-separated list of relationships to include */
        include?: "territory"[];
      },
      params: RequestParams = {},
    ): Promise<InAppPurchasePricePointsResponse> =>
      this.request<InAppPurchasePricePointsResponse, ErrorResponse>({
        path: `/v2/inAppPurchases/${id}/pricePoints`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags InAppPurchases
     * @name InAppPurchasesV2PromotedPurchaseGetToOneRelated
     * @request GET:/v2/inAppPurchases/{id}/promotedPurchase
     * @secure
     */
    v2PromotedPurchaseGetToOneRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type promotedPurchases */
        "fields[promotedPurchases]"?: (
          | "app"
          | "enabled"
          | "inAppPurchaseV2"
          | "promotionImages"
          | "state"
          | "subscription"
          | "visibleForAllUsers"
        )[];
        /** the fields to include for returned resources of type subscriptions */
        "fields[subscriptions]"?: (
          | "appStoreReviewScreenshot"
          | "familySharable"
          | "group"
          | "groupLevel"
          | "introductoryOffers"
          | "name"
          | "offerCodes"
          | "pricePoints"
          | "prices"
          | "productId"
          | "promotedPurchase"
          | "promotionalOffers"
          | "reviewNote"
          | "state"
          | "subscriptionAvailability"
          | "subscriptionLocalizations"
          | "subscriptionPeriod"
        )[];
        /** the fields to include for returned resources of type inAppPurchases */
        "fields[inAppPurchases]"?: (
          | "app"
          | "appStoreReviewScreenshot"
          | "content"
          | "contentHosting"
          | "familySharable"
          | "iapPriceSchedule"
          | "inAppPurchaseAvailability"
          | "inAppPurchaseLocalizations"
          | "inAppPurchaseType"
          | "name"
          | "pricePoints"
          | "productId"
          | "promotedPurchase"
          | "reviewNote"
          | "state"
        )[];
        /** the fields to include for returned resources of type promotedPurchaseImages */
        "fields[promotedPurchaseImages]"?: (
          | "assetToken"
          | "assetType"
          | "fileName"
          | "fileSize"
          | "imageAsset"
          | "promotedPurchase"
          | "sourceFileChecksum"
          | "state"
          | "uploadOperations"
          | "uploaded"
        )[];
        /**
         * maximum number of related promotionImages returned (when they are included)
         * @max 50
         */
        "limit[promotionImages]"?: number;
        /** comma-separated list of relationships to include */
        include?: ("inAppPurchaseV2" | "promotionImages" | "subscription")[];
      },
      params: RequestParams = {},
    ): Promise<PromotedPurchaseResponse> =>
      this.request<PromotedPurchaseResponse, ErrorResponse>({
        path: `/v2/inAppPurchases/${id}/promotedPurchase`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  marketplaceDomains = {
    /**
     * No description
     *
     * @tags MarketplaceDomains
     * @name MarketplaceDomainsGetCollection
     * @request GET:/v1/marketplaceDomains
     * @deprecated
     * @secure
     */
    getCollection: (
      query?: {
        /** the fields to include for returned resources of type marketplaceDomains */
        "fields[marketplaceDomains]"?: ("createdDate" | "domain" | "referenceName")[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
      },
      params: RequestParams = {},
    ): Promise<MarketplaceDomainsResponse> =>
      this.request<MarketplaceDomainsResponse, ErrorResponse>({
        path: `/v1/marketplaceDomains`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags MarketplaceDomains
     * @name MarketplaceDomainsCreateInstance
     * @request POST:/v1/marketplaceDomains
     * @deprecated
     * @secure
     */
    createInstance: (
      data: MarketplaceDomainCreateRequest,
      params: RequestParams = {},
    ): Promise<MarketplaceDomainResponse> =>
      this.request<MarketplaceDomainResponse, ErrorResponse>({
        path: `/v1/marketplaceDomains`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags MarketplaceDomains
     * @name MarketplaceDomainsGetInstance
     * @request GET:/v1/marketplaceDomains/{id}
     * @deprecated
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type marketplaceDomains */
        "fields[marketplaceDomains]"?: ("createdDate" | "domain" | "referenceName")[];
      },
      params: RequestParams = {},
    ): Promise<MarketplaceDomainResponse> =>
      this.request<MarketplaceDomainResponse, ErrorResponse>({
        path: `/v1/marketplaceDomains/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags MarketplaceDomains
     * @name MarketplaceDomainsDeleteInstance
     * @request DELETE:/v1/marketplaceDomains/{id}
     * @deprecated
     * @secure
     */
    deleteInstance: (id: string, params: RequestParams = {}): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/marketplaceDomains/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),
  };
  marketplaceSearchDetails = {
    /**
     * No description
     *
     * @tags MarketplaceSearchDetails
     * @name MarketplaceSearchDetailsCreateInstance
     * @request POST:/v1/marketplaceSearchDetails
     * @secure
     */
    createInstance: (
      data: MarketplaceSearchDetailCreateRequest,
      params: RequestParams = {},
    ): Promise<MarketplaceSearchDetailResponse> =>
      this.request<MarketplaceSearchDetailResponse, ErrorResponse>({
        path: `/v1/marketplaceSearchDetails`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags MarketplaceSearchDetails
     * @name MarketplaceSearchDetailsUpdateInstance
     * @request PATCH:/v1/marketplaceSearchDetails/{id}
     * @secure
     */
    updateInstance: (
      id: string,
      data: MarketplaceSearchDetailUpdateRequest,
      params: RequestParams = {},
    ): Promise<MarketplaceSearchDetailResponse> =>
      this.request<MarketplaceSearchDetailResponse, ErrorResponse>({
        path: `/v1/marketplaceSearchDetails/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags MarketplaceSearchDetails
     * @name MarketplaceSearchDetailsDeleteInstance
     * @request DELETE:/v1/marketplaceSearchDetails/{id}
     * @secure
     */
    deleteInstance: (id: string, params: RequestParams = {}): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/marketplaceSearchDetails/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),
  };
  marketplaceWebhooks = {
    /**
     * No description
     *
     * @tags MarketplaceWebhooks
     * @name MarketplaceWebhooksGetCollection
     * @request GET:/v1/marketplaceWebhooks
     * @secure
     */
    getCollection: (
      query?: {
        /** the fields to include for returned resources of type marketplaceWebhooks */
        "fields[marketplaceWebhooks]"?: ("endpointUrl" | "secret")[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
      },
      params: RequestParams = {},
    ): Promise<MarketplaceWebhooksResponse> =>
      this.request<MarketplaceWebhooksResponse, ErrorResponse>({
        path: `/v1/marketplaceWebhooks`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags MarketplaceWebhooks
     * @name MarketplaceWebhooksCreateInstance
     * @request POST:/v1/marketplaceWebhooks
     * @secure
     */
    createInstance: (
      data: MarketplaceWebhookCreateRequest,
      params: RequestParams = {},
    ): Promise<MarketplaceWebhookResponse> =>
      this.request<MarketplaceWebhookResponse, ErrorResponse>({
        path: `/v1/marketplaceWebhooks`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags MarketplaceWebhooks
     * @name MarketplaceWebhooksUpdateInstance
     * @request PATCH:/v1/marketplaceWebhooks/{id}
     * @secure
     */
    updateInstance: (
      id: string,
      data: MarketplaceWebhookUpdateRequest,
      params: RequestParams = {},
    ): Promise<MarketplaceWebhookResponse> =>
      this.request<MarketplaceWebhookResponse, ErrorResponse>({
        path: `/v1/marketplaceWebhooks/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags MarketplaceWebhooks
     * @name MarketplaceWebhooksDeleteInstance
     * @request DELETE:/v1/marketplaceWebhooks/{id}
     * @secure
     */
    deleteInstance: (id: string, params: RequestParams = {}): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/marketplaceWebhooks/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),
  };
  preReleaseVersions = {
    /**
     * No description
     *
     * @tags PreReleaseVersions
     * @name PreReleaseVersionsGetCollection
     * @request GET:/v1/preReleaseVersions
     * @secure
     */
    getCollection: (
      query?: {
        /** filter by attribute 'builds.expired' */
        filterBuildsExpired?: string[];
        /** filter by attribute 'builds.processingState' */
        filterBuildsProcessingState?: ("PROCESSING" | "FAILED" | "INVALID" | "VALID")[];
        /** filter by attribute 'builds.version' */
        filterBuildsVersion?: string[];
        /** filter by attribute 'platform' */
        "filter[platform]"?: ("IOS" | "MAC_OS" | "TV_OS" | "VISION_OS")[];
        /** filter by attribute 'version' */
        "filter[version]"?: string[];
        /** filter by id(s) of related 'app' */
        "filter[app]"?: string[];
        /** filter by id(s) of related 'builds' */
        "filter[builds]"?: string[];
        /** comma-separated list of sort expressions; resources will be sorted as specified */
        sort?: ("version" | "-version")[];
        /** the fields to include for returned resources of type preReleaseVersions */
        "fields[preReleaseVersions]"?: ("app" | "builds" | "platform" | "version")[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /** comma-separated list of relationships to include */
        include?: ("app" | "builds")[];
        /** the fields to include for returned resources of type apps */
        "fields[apps]"?: (
          | "alternativeDistributionKey"
          | "analyticsReportRequests"
          | "appAvailability"
          | "appClips"
          | "appCustomProductPages"
          | "appEncryptionDeclarations"
          | "appEvents"
          | "appInfos"
          | "appPricePoints"
          | "appPriceSchedule"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersions"
          | "availableInNewTerritories"
          | "availableTerritories"
          | "betaAppLocalizations"
          | "betaAppReviewDetail"
          | "betaGroups"
          | "betaLicenseAgreement"
          | "betaTesters"
          | "builds"
          | "bundleId"
          | "ciProduct"
          | "contentRightsDeclaration"
          | "customerReviews"
          | "endUserLicenseAgreement"
          | "gameCenterDetail"
          | "gameCenterEnabledVersions"
          | "inAppPurchases"
          | "inAppPurchasesV2"
          | "isOrEverWasMadeForKids"
          | "marketplaceSearchDetail"
          | "name"
          | "perfPowerMetrics"
          | "preOrder"
          | "preReleaseVersions"
          | "pricePoints"
          | "prices"
          | "primaryLocale"
          | "promotedPurchases"
          | "reviewSubmissions"
          | "sku"
          | "subscriptionGracePeriod"
          | "subscriptionGroups"
          | "subscriptionStatusUrl"
          | "subscriptionStatusUrlForSandbox"
          | "subscriptionStatusUrlVersion"
          | "subscriptionStatusUrlVersionForSandbox"
        )[];
        /** the fields to include for returned resources of type builds */
        "fields[builds]"?: (
          | "app"
          | "appEncryptionDeclaration"
          | "appStoreVersion"
          | "betaAppReviewSubmission"
          | "betaBuildLocalizations"
          | "betaGroups"
          | "buildAudienceType"
          | "buildBetaDetail"
          | "buildBundles"
          | "computedMinMacOsVersion"
          | "diagnosticSignatures"
          | "expirationDate"
          | "expired"
          | "iconAssetToken"
          | "icons"
          | "individualTesters"
          | "lsMinimumSystemVersion"
          | "minOsVersion"
          | "perfPowerMetrics"
          | "preReleaseVersion"
          | "processingState"
          | "uploadedDate"
          | "usesNonExemptEncryption"
          | "version"
        )[];
        /**
         * maximum number of related builds returned (when they are included)
         * @max 50
         */
        "limit[builds]"?: number;
      },
      params: RequestParams = {},
    ): Promise<PreReleaseVersionsResponse> =>
      this.request<PreReleaseVersionsResponse, ErrorResponse>({
        path: `/v1/preReleaseVersions`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags PreReleaseVersions
     * @name PreReleaseVersionsGetInstance
     * @request GET:/v1/preReleaseVersions/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type preReleaseVersions */
        "fields[preReleaseVersions]"?: ("app" | "builds" | "platform" | "version")[];
        /** comma-separated list of relationships to include */
        include?: ("app" | "builds")[];
        /** the fields to include for returned resources of type apps */
        "fields[apps]"?: (
          | "alternativeDistributionKey"
          | "analyticsReportRequests"
          | "appAvailability"
          | "appClips"
          | "appCustomProductPages"
          | "appEncryptionDeclarations"
          | "appEvents"
          | "appInfos"
          | "appPricePoints"
          | "appPriceSchedule"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersions"
          | "availableInNewTerritories"
          | "availableTerritories"
          | "betaAppLocalizations"
          | "betaAppReviewDetail"
          | "betaGroups"
          | "betaLicenseAgreement"
          | "betaTesters"
          | "builds"
          | "bundleId"
          | "ciProduct"
          | "contentRightsDeclaration"
          | "customerReviews"
          | "endUserLicenseAgreement"
          | "gameCenterDetail"
          | "gameCenterEnabledVersions"
          | "inAppPurchases"
          | "inAppPurchasesV2"
          | "isOrEverWasMadeForKids"
          | "marketplaceSearchDetail"
          | "name"
          | "perfPowerMetrics"
          | "preOrder"
          | "preReleaseVersions"
          | "pricePoints"
          | "prices"
          | "primaryLocale"
          | "promotedPurchases"
          | "reviewSubmissions"
          | "sku"
          | "subscriptionGracePeriod"
          | "subscriptionGroups"
          | "subscriptionStatusUrl"
          | "subscriptionStatusUrlForSandbox"
          | "subscriptionStatusUrlVersion"
          | "subscriptionStatusUrlVersionForSandbox"
        )[];
        /** the fields to include for returned resources of type builds */
        "fields[builds]"?: (
          | "app"
          | "appEncryptionDeclaration"
          | "appStoreVersion"
          | "betaAppReviewSubmission"
          | "betaBuildLocalizations"
          | "betaGroups"
          | "buildAudienceType"
          | "buildBetaDetail"
          | "buildBundles"
          | "computedMinMacOsVersion"
          | "diagnosticSignatures"
          | "expirationDate"
          | "expired"
          | "iconAssetToken"
          | "icons"
          | "individualTesters"
          | "lsMinimumSystemVersion"
          | "minOsVersion"
          | "perfPowerMetrics"
          | "preReleaseVersion"
          | "processingState"
          | "uploadedDate"
          | "usesNonExemptEncryption"
          | "version"
        )[];
        /**
         * maximum number of related builds returned (when they are included)
         * @max 50
         */
        "limit[builds]"?: number;
      },
      params: RequestParams = {},
    ): Promise<PrereleaseVersionResponse> =>
      this.request<PrereleaseVersionResponse, ErrorResponse>({
        path: `/v1/preReleaseVersions/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags PreReleaseVersions
     * @name PreReleaseVersionsAppGetToOneRelated
     * @request GET:/v1/preReleaseVersions/{id}/app
     * @secure
     */
    appGetToOneRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type apps */
        "fields[apps]"?: (
          | "alternativeDistributionKey"
          | "analyticsReportRequests"
          | "appAvailability"
          | "appClips"
          | "appCustomProductPages"
          | "appEncryptionDeclarations"
          | "appEvents"
          | "appInfos"
          | "appPricePoints"
          | "appPriceSchedule"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersions"
          | "availableInNewTerritories"
          | "availableTerritories"
          | "betaAppLocalizations"
          | "betaAppReviewDetail"
          | "betaGroups"
          | "betaLicenseAgreement"
          | "betaTesters"
          | "builds"
          | "bundleId"
          | "ciProduct"
          | "contentRightsDeclaration"
          | "customerReviews"
          | "endUserLicenseAgreement"
          | "gameCenterDetail"
          | "gameCenterEnabledVersions"
          | "inAppPurchases"
          | "inAppPurchasesV2"
          | "isOrEverWasMadeForKids"
          | "marketplaceSearchDetail"
          | "name"
          | "perfPowerMetrics"
          | "preOrder"
          | "preReleaseVersions"
          | "pricePoints"
          | "prices"
          | "primaryLocale"
          | "promotedPurchases"
          | "reviewSubmissions"
          | "sku"
          | "subscriptionGracePeriod"
          | "subscriptionGroups"
          | "subscriptionStatusUrl"
          | "subscriptionStatusUrlForSandbox"
          | "subscriptionStatusUrlVersion"
          | "subscriptionStatusUrlVersionForSandbox"
        )[];
      },
      params: RequestParams = {},
    ): Promise<AppWithoutIncludesResponse> =>
      this.request<AppWithoutIncludesResponse, ErrorResponse>({
        path: `/v1/preReleaseVersions/${id}/app`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags PreReleaseVersions
     * @name PreReleaseVersionsBuildsGetToManyRelated
     * @request GET:/v1/preReleaseVersions/{id}/builds
     * @secure
     */
    buildsGetToManyRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type builds */
        "fields[builds]"?: (
          | "app"
          | "appEncryptionDeclaration"
          | "appStoreVersion"
          | "betaAppReviewSubmission"
          | "betaBuildLocalizations"
          | "betaGroups"
          | "buildAudienceType"
          | "buildBetaDetail"
          | "buildBundles"
          | "computedMinMacOsVersion"
          | "diagnosticSignatures"
          | "expirationDate"
          | "expired"
          | "iconAssetToken"
          | "icons"
          | "individualTesters"
          | "lsMinimumSystemVersion"
          | "minOsVersion"
          | "perfPowerMetrics"
          | "preReleaseVersion"
          | "processingState"
          | "uploadedDate"
          | "usesNonExemptEncryption"
          | "version"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
      },
      params: RequestParams = {},
    ): Promise<BuildsWithoutIncludesResponse> =>
      this.request<BuildsWithoutIncludesResponse, ErrorResponse>({
        path: `/v1/preReleaseVersions/${id}/builds`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  profiles = {
    /**
     * No description
     *
     * @tags Profiles
     * @name ProfilesGetCollection
     * @request GET:/v1/profiles
     * @secure
     */
    getCollection: (
      query?: {
        /** filter by attribute 'name' */
        "filter[name]"?: string[];
        /** filter by attribute 'profileState' */
        "filter[profileState]"?: ("ACTIVE" | "INVALID")[];
        /** filter by attribute 'profileType' */
        "filter[profileType]"?: (
          | "IOS_APP_DEVELOPMENT"
          | "IOS_APP_STORE"
          | "IOS_APP_ADHOC"
          | "IOS_APP_INHOUSE"
          | "MAC_APP_DEVELOPMENT"
          | "MAC_APP_STORE"
          | "MAC_APP_DIRECT"
          | "TVOS_APP_DEVELOPMENT"
          | "TVOS_APP_STORE"
          | "TVOS_APP_ADHOC"
          | "TVOS_APP_INHOUSE"
          | "MAC_CATALYST_APP_DEVELOPMENT"
          | "MAC_CATALYST_APP_STORE"
          | "MAC_CATALYST_APP_DIRECT"
        )[];
        /** filter by id(s) */
        "filter[id]"?: string[];
        /** comma-separated list of sort expressions; resources will be sorted as specified */
        sort?: ("id" | "-id" | "name" | "-name" | "profileState" | "-profileState" | "profileType" | "-profileType")[];
        /** the fields to include for returned resources of type profiles */
        "fields[profiles]"?: (
          | "bundleId"
          | "certificates"
          | "createdDate"
          | "devices"
          | "expirationDate"
          | "name"
          | "platform"
          | "profileContent"
          | "profileState"
          | "profileType"
          | "uuid"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /** comma-separated list of relationships to include */
        include?: ("bundleId" | "certificates" | "devices")[];
        /** the fields to include for returned resources of type certificates */
        "fields[certificates]"?: (
          | "certificateContent"
          | "certificateType"
          | "csrContent"
          | "displayName"
          | "expirationDate"
          | "name"
          | "platform"
          | "serialNumber"
        )[];
        /** the fields to include for returned resources of type devices */
        "fields[devices]"?: ("addedDate" | "deviceClass" | "model" | "name" | "platform" | "status" | "udid")[];
        /** the fields to include for returned resources of type bundleIds */
        "fields[bundleIds]"?: (
          | "app"
          | "bundleIdCapabilities"
          | "identifier"
          | "name"
          | "platform"
          | "profiles"
          | "seedId"
        )[];
        /**
         * maximum number of related certificates returned (when they are included)
         * @max 50
         */
        "limit[certificates]"?: number;
        /**
         * maximum number of related devices returned (when they are included)
         * @max 50
         */
        "limit[devices]"?: number;
      },
      params: RequestParams = {},
    ): Promise<ProfilesResponse> =>
      this.request<ProfilesResponse, ErrorResponse>({
        path: `/v1/profiles`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Profiles
     * @name ProfilesCreateInstance
     * @request POST:/v1/profiles
     * @secure
     */
    createInstance: (data: ProfileCreateRequest, params: RequestParams = {}): Promise<ProfileResponse> =>
      this.request<ProfileResponse, ErrorResponse>({
        path: `/v1/profiles`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Profiles
     * @name ProfilesGetInstance
     * @request GET:/v1/profiles/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type profiles */
        "fields[profiles]"?: (
          | "bundleId"
          | "certificates"
          | "createdDate"
          | "devices"
          | "expirationDate"
          | "name"
          | "platform"
          | "profileContent"
          | "profileState"
          | "profileType"
          | "uuid"
        )[];
        /** comma-separated list of relationships to include */
        include?: ("bundleId" | "certificates" | "devices")[];
        /** the fields to include for returned resources of type certificates */
        "fields[certificates]"?: (
          | "certificateContent"
          | "certificateType"
          | "csrContent"
          | "displayName"
          | "expirationDate"
          | "name"
          | "platform"
          | "serialNumber"
        )[];
        /** the fields to include for returned resources of type devices */
        "fields[devices]"?: ("addedDate" | "deviceClass" | "model" | "name" | "platform" | "status" | "udid")[];
        /** the fields to include for returned resources of type bundleIds */
        "fields[bundleIds]"?: (
          | "app"
          | "bundleIdCapabilities"
          | "identifier"
          | "name"
          | "platform"
          | "profiles"
          | "seedId"
        )[];
        /**
         * maximum number of related certificates returned (when they are included)
         * @max 50
         */
        "limit[certificates]"?: number;
        /**
         * maximum number of related devices returned (when they are included)
         * @max 50
         */
        "limit[devices]"?: number;
      },
      params: RequestParams = {},
    ): Promise<ProfileResponse> =>
      this.request<ProfileResponse, ErrorResponse>({
        path: `/v1/profiles/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Profiles
     * @name ProfilesDeleteInstance
     * @request DELETE:/v1/profiles/{id}
     * @secure
     */
    deleteInstance: (id: string, params: RequestParams = {}): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/profiles/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),

    /**
     * No description
     *
     * @tags Profiles
     * @name ProfilesBundleIdGetToOneRelated
     * @request GET:/v1/profiles/{id}/bundleId
     * @secure
     */
    bundleIdGetToOneRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type bundleIds */
        "fields[bundleIds]"?: (
          | "app"
          | "bundleIdCapabilities"
          | "identifier"
          | "name"
          | "platform"
          | "profiles"
          | "seedId"
        )[];
      },
      params: RequestParams = {},
    ): Promise<BundleIdWithoutIncludesResponse> =>
      this.request<BundleIdWithoutIncludesResponse, ErrorResponse>({
        path: `/v1/profiles/${id}/bundleId`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Profiles
     * @name ProfilesCertificatesGetToManyRelated
     * @request GET:/v1/profiles/{id}/certificates
     * @secure
     */
    certificatesGetToManyRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type certificates */
        "fields[certificates]"?: (
          | "certificateContent"
          | "certificateType"
          | "csrContent"
          | "displayName"
          | "expirationDate"
          | "name"
          | "platform"
          | "serialNumber"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
      },
      params: RequestParams = {},
    ): Promise<CertificatesWithoutIncludesResponse> =>
      this.request<CertificatesWithoutIncludesResponse, ErrorResponse>({
        path: `/v1/profiles/${id}/certificates`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Profiles
     * @name ProfilesDevicesGetToManyRelated
     * @request GET:/v1/profiles/{id}/devices
     * @secure
     */
    devicesGetToManyRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type devices */
        "fields[devices]"?: ("addedDate" | "deviceClass" | "model" | "name" | "platform" | "status" | "udid")[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
      },
      params: RequestParams = {},
    ): Promise<DevicesWithoutIncludesResponse> =>
      this.request<DevicesWithoutIncludesResponse, ErrorResponse>({
        path: `/v1/profiles/${id}/devices`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  promotedPurchaseImages = {
    /**
     * No description
     *
     * @tags PromotedPurchaseImages
     * @name PromotedPurchaseImagesCreateInstance
     * @request POST:/v1/promotedPurchaseImages
     * @secure
     */
    createInstance: (
      data: PromotedPurchaseImageCreateRequest,
      params: RequestParams = {},
    ): Promise<PromotedPurchaseImageResponse> =>
      this.request<PromotedPurchaseImageResponse, ErrorResponse>({
        path: `/v1/promotedPurchaseImages`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags PromotedPurchaseImages
     * @name PromotedPurchaseImagesGetInstance
     * @request GET:/v1/promotedPurchaseImages/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type promotedPurchaseImages */
        "fields[promotedPurchaseImages]"?: (
          | "assetToken"
          | "assetType"
          | "fileName"
          | "fileSize"
          | "imageAsset"
          | "promotedPurchase"
          | "sourceFileChecksum"
          | "state"
          | "uploadOperations"
          | "uploaded"
        )[];
        /** comma-separated list of relationships to include */
        include?: "promotedPurchase"[];
      },
      params: RequestParams = {},
    ): Promise<PromotedPurchaseImageResponse> =>
      this.request<PromotedPurchaseImageResponse, ErrorResponse>({
        path: `/v1/promotedPurchaseImages/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags PromotedPurchaseImages
     * @name PromotedPurchaseImagesUpdateInstance
     * @request PATCH:/v1/promotedPurchaseImages/{id}
     * @secure
     */
    updateInstance: (
      id: string,
      data: PromotedPurchaseImageUpdateRequest,
      params: RequestParams = {},
    ): Promise<PromotedPurchaseImageResponse> =>
      this.request<PromotedPurchaseImageResponse, ErrorResponse>({
        path: `/v1/promotedPurchaseImages/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags PromotedPurchaseImages
     * @name PromotedPurchaseImagesDeleteInstance
     * @request DELETE:/v1/promotedPurchaseImages/{id}
     * @secure
     */
    deleteInstance: (id: string, params: RequestParams = {}): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/promotedPurchaseImages/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),
  };
  promotedPurchases = {
    /**
     * No description
     *
     * @tags PromotedPurchases
     * @name PromotedPurchasesCreateInstance
     * @request POST:/v1/promotedPurchases
     * @secure
     */
    createInstance: (
      data: PromotedPurchaseCreateRequest,
      params: RequestParams = {},
    ): Promise<PromotedPurchaseResponse> =>
      this.request<PromotedPurchaseResponse, ErrorResponse>({
        path: `/v1/promotedPurchases`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags PromotedPurchases
     * @name PromotedPurchasesGetInstance
     * @request GET:/v1/promotedPurchases/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type promotedPurchases */
        "fields[promotedPurchases]"?: (
          | "app"
          | "enabled"
          | "inAppPurchaseV2"
          | "promotionImages"
          | "state"
          | "subscription"
          | "visibleForAllUsers"
        )[];
        /** comma-separated list of relationships to include */
        include?: ("inAppPurchaseV2" | "promotionImages" | "subscription")[];
        /** the fields to include for returned resources of type promotedPurchaseImages */
        "fields[promotedPurchaseImages]"?: (
          | "assetToken"
          | "assetType"
          | "fileName"
          | "fileSize"
          | "imageAsset"
          | "promotedPurchase"
          | "sourceFileChecksum"
          | "state"
          | "uploadOperations"
          | "uploaded"
        )[];
        /**
         * maximum number of related promotionImages returned (when they are included)
         * @max 50
         */
        "limit[promotionImages]"?: number;
      },
      params: RequestParams = {},
    ): Promise<PromotedPurchaseResponse> =>
      this.request<PromotedPurchaseResponse, ErrorResponse>({
        path: `/v1/promotedPurchases/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags PromotedPurchases
     * @name PromotedPurchasesUpdateInstance
     * @request PATCH:/v1/promotedPurchases/{id}
     * @secure
     */
    updateInstance: (
      id: string,
      data: PromotedPurchaseUpdateRequest,
      params: RequestParams = {},
    ): Promise<PromotedPurchaseResponse> =>
      this.request<PromotedPurchaseResponse, ErrorResponse>({
        path: `/v1/promotedPurchases/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags PromotedPurchases
     * @name PromotedPurchasesDeleteInstance
     * @request DELETE:/v1/promotedPurchases/{id}
     * @secure
     */
    deleteInstance: (id: string, params: RequestParams = {}): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/promotedPurchases/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),

    /**
     * No description
     *
     * @tags PromotedPurchases
     * @name PromotedPurchasesPromotionImagesGetToManyRelated
     * @request GET:/v1/promotedPurchases/{id}/promotionImages
     * @secure
     */
    promotionImagesGetToManyRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type promotedPurchases */
        "fields[promotedPurchases]"?: (
          | "app"
          | "enabled"
          | "inAppPurchaseV2"
          | "promotionImages"
          | "state"
          | "subscription"
          | "visibleForAllUsers"
        )[];
        /** the fields to include for returned resources of type promotedPurchaseImages */
        "fields[promotedPurchaseImages]"?: (
          | "assetToken"
          | "assetType"
          | "fileName"
          | "fileSize"
          | "imageAsset"
          | "promotedPurchase"
          | "sourceFileChecksum"
          | "state"
          | "uploadOperations"
          | "uploaded"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /** comma-separated list of relationships to include */
        include?: "promotedPurchase"[];
      },
      params: RequestParams = {},
    ): Promise<PromotedPurchaseImagesResponse> =>
      this.request<PromotedPurchaseImagesResponse, ErrorResponse>({
        path: `/v1/promotedPurchases/${id}/promotionImages`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  reviewSubmissionItems = {
    /**
     * No description
     *
     * @tags ReviewSubmissionItems
     * @name ReviewSubmissionItemsCreateInstance
     * @request POST:/v1/reviewSubmissionItems
     * @secure
     */
    createInstance: (
      data: ReviewSubmissionItemCreateRequest,
      params: RequestParams = {},
    ): Promise<ReviewSubmissionItemResponse> =>
      this.request<ReviewSubmissionItemResponse, ErrorResponse>({
        path: `/v1/reviewSubmissionItems`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags ReviewSubmissionItems
     * @name ReviewSubmissionItemsUpdateInstance
     * @request PATCH:/v1/reviewSubmissionItems/{id}
     * @secure
     */
    updateInstance: (
      id: string,
      data: ReviewSubmissionItemUpdateRequest,
      params: RequestParams = {},
    ): Promise<ReviewSubmissionItemResponse> =>
      this.request<ReviewSubmissionItemResponse, ErrorResponse>({
        path: `/v1/reviewSubmissionItems/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags ReviewSubmissionItems
     * @name ReviewSubmissionItemsDeleteInstance
     * @request DELETE:/v1/reviewSubmissionItems/{id}
     * @secure
     */
    deleteInstance: (id: string, params: RequestParams = {}): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/reviewSubmissionItems/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),
  };
  reviewSubmissions = {
    /**
     * No description
     *
     * @tags ReviewSubmissions
     * @name ReviewSubmissionsGetCollection
     * @request GET:/v1/reviewSubmissions
     * @secure
     */
    getCollection: (
      query: {
        /** filter by attribute 'platform' */
        "filter[platform]"?: ("IOS" | "MAC_OS" | "TV_OS" | "VISION_OS")[];
        /** filter by attribute 'state' */
        "filter[state]"?: (
          | "READY_FOR_REVIEW"
          | "WAITING_FOR_REVIEW"
          | "IN_REVIEW"
          | "UNRESOLVED_ISSUES"
          | "CANCELING"
          | "COMPLETING"
          | "COMPLETE"
        )[];
        /** filter by id(s) of related 'app' */
        "filter[app]": string[];
        /** the fields to include for returned resources of type reviewSubmissions */
        "fields[reviewSubmissions]"?: (
          | "app"
          | "appStoreVersionForReview"
          | "canceled"
          | "items"
          | "lastUpdatedByActor"
          | "platform"
          | "state"
          | "submitted"
          | "submittedByActor"
          | "submittedDate"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /** comma-separated list of relationships to include */
        include?: ("app" | "appStoreVersionForReview" | "items" | "lastUpdatedByActor" | "submittedByActor")[];
        /** the fields to include for returned resources of type reviewSubmissionItems */
        "fields[reviewSubmissionItems]"?: (
          | "appCustomProductPageVersion"
          | "appEvent"
          | "appStoreVersion"
          | "appStoreVersionExperiment"
          | "appStoreVersionExperimentV2"
          | "removed"
          | "resolved"
          | "reviewSubmission"
          | "state"
        )[];
        /**
         * maximum number of related items returned (when they are included)
         * @max 50
         */
        "limit[items]"?: number;
      },
      params: RequestParams = {},
    ): Promise<ReviewSubmissionsResponse> =>
      this.request<ReviewSubmissionsResponse, ErrorResponse>({
        path: `/v1/reviewSubmissions`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags ReviewSubmissions
     * @name ReviewSubmissionsCreateInstance
     * @request POST:/v1/reviewSubmissions
     * @secure
     */
    createInstance: (
      data: ReviewSubmissionCreateRequest,
      params: RequestParams = {},
    ): Promise<ReviewSubmissionResponse> =>
      this.request<ReviewSubmissionResponse, ErrorResponse>({
        path: `/v1/reviewSubmissions`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags ReviewSubmissions
     * @name ReviewSubmissionsGetInstance
     * @request GET:/v1/reviewSubmissions/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type reviewSubmissions */
        "fields[reviewSubmissions]"?: (
          | "app"
          | "appStoreVersionForReview"
          | "canceled"
          | "items"
          | "lastUpdatedByActor"
          | "platform"
          | "state"
          | "submitted"
          | "submittedByActor"
          | "submittedDate"
        )[];
        /** comma-separated list of relationships to include */
        include?: ("app" | "appStoreVersionForReview" | "items" | "lastUpdatedByActor" | "submittedByActor")[];
        /** the fields to include for returned resources of type reviewSubmissionItems */
        "fields[reviewSubmissionItems]"?: (
          | "appCustomProductPageVersion"
          | "appEvent"
          | "appStoreVersion"
          | "appStoreVersionExperiment"
          | "appStoreVersionExperimentV2"
          | "removed"
          | "resolved"
          | "reviewSubmission"
          | "state"
        )[];
        /**
         * maximum number of related items returned (when they are included)
         * @max 50
         */
        "limit[items]"?: number;
      },
      params: RequestParams = {},
    ): Promise<ReviewSubmissionResponse> =>
      this.request<ReviewSubmissionResponse, ErrorResponse>({
        path: `/v1/reviewSubmissions/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags ReviewSubmissions
     * @name ReviewSubmissionsUpdateInstance
     * @request PATCH:/v1/reviewSubmissions/{id}
     * @secure
     */
    updateInstance: (
      id: string,
      data: ReviewSubmissionUpdateRequest,
      params: RequestParams = {},
    ): Promise<ReviewSubmissionResponse> =>
      this.request<ReviewSubmissionResponse, ErrorResponse>({
        path: `/v1/reviewSubmissions/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags ReviewSubmissions
     * @name ReviewSubmissionsItemsGetToManyRelated
     * @request GET:/v1/reviewSubmissions/{id}/items
     * @secure
     */
    itemsGetToManyRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type appStoreVersionExperiments */
        "fields[appStoreVersionExperiments]"?: (
          | "app"
          | "appStoreVersion"
          | "appStoreVersionExperimentTreatments"
          | "controlVersions"
          | "endDate"
          | "latestControlVersion"
          | "name"
          | "platform"
          | "reviewRequired"
          | "startDate"
          | "started"
          | "state"
          | "trafficProportion"
        )[];
        /** the fields to include for returned resources of type reviewSubmissionItems */
        "fields[reviewSubmissionItems]"?: (
          | "appCustomProductPageVersion"
          | "appEvent"
          | "appStoreVersion"
          | "appStoreVersionExperiment"
          | "appStoreVersionExperimentV2"
          | "removed"
          | "resolved"
          | "reviewSubmission"
          | "state"
        )[];
        /** the fields to include for returned resources of type appStoreVersions */
        "fields[appStoreVersions]"?: (
          | "ageRatingDeclaration"
          | "alternativeDistributionPackage"
          | "app"
          | "appClipDefaultExperience"
          | "appStoreReviewDetail"
          | "appStoreState"
          | "appStoreVersionExperiments"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersionLocalizations"
          | "appStoreVersionPhasedRelease"
          | "appStoreVersionSubmission"
          | "appVersionState"
          | "build"
          | "copyright"
          | "createdDate"
          | "customerReviews"
          | "downloadable"
          | "earliestReleaseDate"
          | "platform"
          | "releaseType"
          | "reviewType"
          | "routingAppCoverage"
          | "versionString"
        )[];
        /** the fields to include for returned resources of type appCustomProductPageVersions */
        "fields[appCustomProductPageVersions]"?: (
          | "appCustomProductPage"
          | "appCustomProductPageLocalizations"
          | "state"
          | "version"
        )[];
        /** the fields to include for returned resources of type appEvents */
        "fields[appEvents]"?: (
          | "app"
          | "archivedTerritorySchedules"
          | "badge"
          | "deepLink"
          | "eventState"
          | "localizations"
          | "primaryLocale"
          | "priority"
          | "purchaseRequirement"
          | "purpose"
          | "referenceName"
          | "territorySchedules"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /** comma-separated list of relationships to include */
        include?: (
          | "appCustomProductPageVersion"
          | "appEvent"
          | "appStoreVersion"
          | "appStoreVersionExperiment"
          | "appStoreVersionExperimentV2"
        )[];
      },
      params: RequestParams = {},
    ): Promise<ReviewSubmissionItemsResponse> =>
      this.request<ReviewSubmissionItemsResponse, ErrorResponse>({
        path: `/v1/reviewSubmissions/${id}/items`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  routingAppCoverages = {
    /**
     * No description
     *
     * @tags RoutingAppCoverages
     * @name RoutingAppCoveragesCreateInstance
     * @request POST:/v1/routingAppCoverages
     * @secure
     */
    createInstance: (
      data: RoutingAppCoverageCreateRequest,
      params: RequestParams = {},
    ): Promise<RoutingAppCoverageResponse> =>
      this.request<RoutingAppCoverageResponse, ErrorResponse>({
        path: `/v1/routingAppCoverages`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags RoutingAppCoverages
     * @name RoutingAppCoveragesGetInstance
     * @request GET:/v1/routingAppCoverages/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type routingAppCoverages */
        "fields[routingAppCoverages]"?: (
          | "appStoreVersion"
          | "assetDeliveryState"
          | "fileName"
          | "fileSize"
          | "sourceFileChecksum"
          | "uploadOperations"
          | "uploaded"
        )[];
        /** comma-separated list of relationships to include */
        include?: "appStoreVersion"[];
      },
      params: RequestParams = {},
    ): Promise<RoutingAppCoverageResponse> =>
      this.request<RoutingAppCoverageResponse, ErrorResponse>({
        path: `/v1/routingAppCoverages/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags RoutingAppCoverages
     * @name RoutingAppCoveragesUpdateInstance
     * @request PATCH:/v1/routingAppCoverages/{id}
     * @secure
     */
    updateInstance: (
      id: string,
      data: RoutingAppCoverageUpdateRequest,
      params: RequestParams = {},
    ): Promise<RoutingAppCoverageResponse> =>
      this.request<RoutingAppCoverageResponse, ErrorResponse>({
        path: `/v1/routingAppCoverages/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags RoutingAppCoverages
     * @name RoutingAppCoveragesDeleteInstance
     * @request DELETE:/v1/routingAppCoverages/{id}
     * @secure
     */
    deleteInstance: (id: string, params: RequestParams = {}): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/routingAppCoverages/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),
  };
  salesReports = {
    /**
     * No description
     *
     * @tags SalesReports
     * @name SalesReportsGetCollection
     * @request GET:/v1/salesReports
     * @secure
     */
    getCollection: (
      query: {
        /** filter by attribute 'frequency' */
        "filter[frequency]": ("DAILY" | "WEEKLY" | "MONTHLY" | "YEARLY")[];
        /** filter by attribute 'reportDate' */
        "filter[reportDate]"?: string[];
        /** filter by attribute 'reportSubType' */
        "filter[reportSubType]": (
          | "SUMMARY"
          | "DETAILED"
          | "SUMMARY_INSTALL_TYPE"
          | "SUMMARY_TERRITORY"
          | "SUMMARY_CHANNEL"
        )[];
        /** filter by attribute 'reportType' */
        "filter[reportType]": (
          | "SALES"
          | "PRE_ORDER"
          | "NEWSSTAND"
          | "SUBSCRIPTION"
          | "SUBSCRIPTION_EVENT"
          | "SUBSCRIBER"
          | "SUBSCRIPTION_OFFER_CODE_REDEMPTION"
          | "INSTALLS"
          | "FIRST_ANNUAL"
        )[];
        /** filter by attribute 'vendorNumber' */
        "filter[vendorNumber]": string[];
        /** filter by attribute 'version' */
        "filter[version]"?: string[];
      },
      params: RequestParams = {},
    ): Promise<Gzip> =>
      this.request<Gzip, ErrorResponse>({
        path: `/v1/salesReports`,
        method: "GET",
        query: query,
        secure: true,
        ...params,
      }),
  };
  sandboxTesters = {
    /**
     * No description
     *
     * @tags SandboxTesters
     * @name SandboxTestersV2GetCollection
     * @request GET:/v2/sandboxTesters
     * @secure
     */
    v2GetCollection: (
      query?: {
        /** the fields to include for returned resources of type sandboxTesters */
        "fields[sandboxTesters]"?: (
          | "acAccountName"
          | "applePayCompatible"
          | "firstName"
          | "interruptPurchases"
          | "lastName"
          | "subscriptionRenewalRate"
          | "territory"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
      },
      params: RequestParams = {},
    ): Promise<SandboxTestersV2Response> =>
      this.request<SandboxTestersV2Response, ErrorResponse>({
        path: `/v2/sandboxTesters`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags SandboxTesters
     * @name SandboxTestersV2UpdateInstance
     * @request PATCH:/v2/sandboxTesters/{id}
     * @secure
     */
    v2UpdateInstance: (
      id: string,
      data: SandboxTesterV2UpdateRequest,
      params: RequestParams = {},
    ): Promise<SandboxTesterV2Response> =>
      this.request<SandboxTesterV2Response, ErrorResponse>({
        path: `/v2/sandboxTesters/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),
  };
  sandboxTestersClearPurchaseHistoryRequest = {
    /**
     * No description
     *
     * @tags SandboxTestersClearPurchaseHistoryRequest
     * @name SandboxTestersClearPurchaseHistoryRequestV2CreateInstance
     * @request POST:/v2/sandboxTestersClearPurchaseHistoryRequest
     * @secure
     */
    v2CreateInstance: (
      data: SandboxTestersClearPurchaseHistoryRequestV2CreateRequest,
      params: RequestParams = {},
    ): Promise<SandboxTestersClearPurchaseHistoryRequestV2Response> =>
      this.request<SandboxTestersClearPurchaseHistoryRequestV2Response, ErrorResponse>({
        path: `/v2/sandboxTestersClearPurchaseHistoryRequest`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),
  };
  scmGitReferences = {
    /**
     * No description
     *
     * @tags ScmGitReferences
     * @name ScmGitReferencesGetInstance
     * @request GET:/v1/scmGitReferences/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type scmGitReferences */
        "fields[scmGitReferences]"?: ("canonicalName" | "isDeleted" | "kind" | "name" | "repository")[];
        /** comma-separated list of relationships to include */
        include?: "repository"[];
      },
      params: RequestParams = {},
    ): Promise<ScmGitReferenceResponse> =>
      this.request<ScmGitReferenceResponse, ErrorResponse>({
        path: `/v1/scmGitReferences/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  scmProviders = {
    /**
     * No description
     *
     * @tags ScmProviders
     * @name ScmProvidersGetCollection
     * @request GET:/v1/scmProviders
     * @secure
     */
    getCollection: (
      query?: {
        /** the fields to include for returned resources of type scmProviders */
        "fields[scmProviders]"?: ("repositories" | "scmProviderType" | "url")[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /** the fields to include for returned resources of type scmRepositories */
        "fields[scmRepositories]"?: (
          | "defaultBranch"
          | "gitReferences"
          | "httpCloneUrl"
          | "lastAccessedDate"
          | "ownerName"
          | "pullRequests"
          | "repositoryName"
          | "scmProvider"
          | "sshCloneUrl"
        )[];
      },
      params: RequestParams = {},
    ): Promise<ScmProvidersResponse> =>
      this.request<ScmProvidersResponse, ErrorResponse>({
        path: `/v1/scmProviders`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags ScmProviders
     * @name ScmProvidersGetInstance
     * @request GET:/v1/scmProviders/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type scmProviders */
        "fields[scmProviders]"?: ("repositories" | "scmProviderType" | "url")[];
        /** the fields to include for returned resources of type scmRepositories */
        "fields[scmRepositories]"?: (
          | "defaultBranch"
          | "gitReferences"
          | "httpCloneUrl"
          | "lastAccessedDate"
          | "ownerName"
          | "pullRequests"
          | "repositoryName"
          | "scmProvider"
          | "sshCloneUrl"
        )[];
      },
      params: RequestParams = {},
    ): Promise<ScmProviderResponse> =>
      this.request<ScmProviderResponse, ErrorResponse>({
        path: `/v1/scmProviders/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags ScmProviders
     * @name ScmProvidersRepositoriesGetToManyRelated
     * @request GET:/v1/scmProviders/{id}/repositories
     * @secure
     */
    repositoriesGetToManyRelated: (
      id: string,
      query?: {
        /** filter by id(s) */
        "filter[id]"?: string[];
        /** the fields to include for returned resources of type scmGitReferences */
        "fields[scmGitReferences]"?: ("canonicalName" | "isDeleted" | "kind" | "name" | "repository")[];
        /** the fields to include for returned resources of type scmProviders */
        "fields[scmProviders]"?: ("repositories" | "scmProviderType" | "url")[];
        /** the fields to include for returned resources of type scmRepositories */
        "fields[scmRepositories]"?: (
          | "defaultBranch"
          | "gitReferences"
          | "httpCloneUrl"
          | "lastAccessedDate"
          | "ownerName"
          | "pullRequests"
          | "repositoryName"
          | "scmProvider"
          | "sshCloneUrl"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /** comma-separated list of relationships to include */
        include?: ("defaultBranch" | "scmProvider")[];
      },
      params: RequestParams = {},
    ): Promise<ScmRepositoriesResponse> =>
      this.request<ScmRepositoriesResponse, ErrorResponse>({
        path: `/v1/scmProviders/${id}/repositories`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  scmPullRequests = {
    /**
     * No description
     *
     * @tags ScmPullRequests
     * @name ScmPullRequestsGetInstance
     * @request GET:/v1/scmPullRequests/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type scmPullRequests */
        "fields[scmPullRequests]"?: (
          | "destinationBranchName"
          | "destinationRepositoryName"
          | "destinationRepositoryOwner"
          | "isClosed"
          | "isCrossRepository"
          | "number"
          | "repository"
          | "sourceBranchName"
          | "sourceRepositoryName"
          | "sourceRepositoryOwner"
          | "title"
          | "webUrl"
        )[];
        /** comma-separated list of relationships to include */
        include?: "repository"[];
      },
      params: RequestParams = {},
    ): Promise<ScmPullRequestResponse> =>
      this.request<ScmPullRequestResponse, ErrorResponse>({
        path: `/v1/scmPullRequests/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  scmRepositories = {
    /**
     * No description
     *
     * @tags ScmRepositories
     * @name ScmRepositoriesGetCollection
     * @request GET:/v1/scmRepositories
     * @secure
     */
    getCollection: (
      query?: {
        /** filter by id(s) */
        "filter[id]"?: string[];
        /** the fields to include for returned resources of type scmRepositories */
        "fields[scmRepositories]"?: (
          | "defaultBranch"
          | "gitReferences"
          | "httpCloneUrl"
          | "lastAccessedDate"
          | "ownerName"
          | "pullRequests"
          | "repositoryName"
          | "scmProvider"
          | "sshCloneUrl"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /** comma-separated list of relationships to include */
        include?: ("defaultBranch" | "scmProvider")[];
        /** the fields to include for returned resources of type scmGitReferences */
        "fields[scmGitReferences]"?: ("canonicalName" | "isDeleted" | "kind" | "name" | "repository")[];
        /** the fields to include for returned resources of type scmPullRequests */
        "fields[scmPullRequests]"?: (
          | "destinationBranchName"
          | "destinationRepositoryName"
          | "destinationRepositoryOwner"
          | "isClosed"
          | "isCrossRepository"
          | "number"
          | "repository"
          | "sourceBranchName"
          | "sourceRepositoryName"
          | "sourceRepositoryOwner"
          | "title"
          | "webUrl"
        )[];
      },
      params: RequestParams = {},
    ): Promise<ScmRepositoriesResponse> =>
      this.request<ScmRepositoriesResponse, ErrorResponse>({
        path: `/v1/scmRepositories`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags ScmRepositories
     * @name ScmRepositoriesGetInstance
     * @request GET:/v1/scmRepositories/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type scmRepositories */
        "fields[scmRepositories]"?: (
          | "defaultBranch"
          | "gitReferences"
          | "httpCloneUrl"
          | "lastAccessedDate"
          | "ownerName"
          | "pullRequests"
          | "repositoryName"
          | "scmProvider"
          | "sshCloneUrl"
        )[];
        /** comma-separated list of relationships to include */
        include?: ("defaultBranch" | "scmProvider")[];
        /** the fields to include for returned resources of type scmGitReferences */
        "fields[scmGitReferences]"?: ("canonicalName" | "isDeleted" | "kind" | "name" | "repository")[];
        /** the fields to include for returned resources of type scmPullRequests */
        "fields[scmPullRequests]"?: (
          | "destinationBranchName"
          | "destinationRepositoryName"
          | "destinationRepositoryOwner"
          | "isClosed"
          | "isCrossRepository"
          | "number"
          | "repository"
          | "sourceBranchName"
          | "sourceRepositoryName"
          | "sourceRepositoryOwner"
          | "title"
          | "webUrl"
        )[];
      },
      params: RequestParams = {},
    ): Promise<ScmRepositoryResponse> =>
      this.request<ScmRepositoryResponse, ErrorResponse>({
        path: `/v1/scmRepositories/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags ScmRepositories
     * @name ScmRepositoriesGitReferencesGetToManyRelated
     * @request GET:/v1/scmRepositories/{id}/gitReferences
     * @secure
     */
    gitReferencesGetToManyRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type scmGitReferences */
        "fields[scmGitReferences]"?: ("canonicalName" | "isDeleted" | "kind" | "name" | "repository")[];
        /** the fields to include for returned resources of type scmRepositories */
        "fields[scmRepositories]"?: (
          | "defaultBranch"
          | "gitReferences"
          | "httpCloneUrl"
          | "lastAccessedDate"
          | "ownerName"
          | "pullRequests"
          | "repositoryName"
          | "scmProvider"
          | "sshCloneUrl"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /** comma-separated list of relationships to include */
        include?: "repository"[];
      },
      params: RequestParams = {},
    ): Promise<ScmGitReferencesResponse> =>
      this.request<ScmGitReferencesResponse, ErrorResponse>({
        path: `/v1/scmRepositories/${id}/gitReferences`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags ScmRepositories
     * @name ScmRepositoriesPullRequestsGetToManyRelated
     * @request GET:/v1/scmRepositories/{id}/pullRequests
     * @secure
     */
    pullRequestsGetToManyRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type scmPullRequests */
        "fields[scmPullRequests]"?: (
          | "destinationBranchName"
          | "destinationRepositoryName"
          | "destinationRepositoryOwner"
          | "isClosed"
          | "isCrossRepository"
          | "number"
          | "repository"
          | "sourceBranchName"
          | "sourceRepositoryName"
          | "sourceRepositoryOwner"
          | "title"
          | "webUrl"
        )[];
        /** the fields to include for returned resources of type scmRepositories */
        "fields[scmRepositories]"?: (
          | "defaultBranch"
          | "gitReferences"
          | "httpCloneUrl"
          | "lastAccessedDate"
          | "ownerName"
          | "pullRequests"
          | "repositoryName"
          | "scmProvider"
          | "sshCloneUrl"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /** comma-separated list of relationships to include */
        include?: "repository"[];
      },
      params: RequestParams = {},
    ): Promise<ScmPullRequestsResponse> =>
      this.request<ScmPullRequestsResponse, ErrorResponse>({
        path: `/v1/scmRepositories/${id}/pullRequests`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  subscriptionAppStoreReviewScreenshots = {
    /**
     * No description
     *
     * @tags SubscriptionAppStoreReviewScreenshots
     * @name SubscriptionAppStoreReviewScreenshotsCreateInstance
     * @request POST:/v1/subscriptionAppStoreReviewScreenshots
     * @secure
     */
    createInstance: (
      data: SubscriptionAppStoreReviewScreenshotCreateRequest,
      params: RequestParams = {},
    ): Promise<SubscriptionAppStoreReviewScreenshotResponse> =>
      this.request<SubscriptionAppStoreReviewScreenshotResponse, ErrorResponse>({
        path: `/v1/subscriptionAppStoreReviewScreenshots`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags SubscriptionAppStoreReviewScreenshots
     * @name SubscriptionAppStoreReviewScreenshotsGetInstance
     * @request GET:/v1/subscriptionAppStoreReviewScreenshots/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type subscriptionAppStoreReviewScreenshots */
        "fields[subscriptionAppStoreReviewScreenshots]"?: (
          | "assetDeliveryState"
          | "assetToken"
          | "assetType"
          | "fileName"
          | "fileSize"
          | "imageAsset"
          | "sourceFileChecksum"
          | "subscription"
          | "uploadOperations"
          | "uploaded"
        )[];
        /** comma-separated list of relationships to include */
        include?: "subscription"[];
      },
      params: RequestParams = {},
    ): Promise<SubscriptionAppStoreReviewScreenshotResponse> =>
      this.request<SubscriptionAppStoreReviewScreenshotResponse, ErrorResponse>({
        path: `/v1/subscriptionAppStoreReviewScreenshots/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags SubscriptionAppStoreReviewScreenshots
     * @name SubscriptionAppStoreReviewScreenshotsUpdateInstance
     * @request PATCH:/v1/subscriptionAppStoreReviewScreenshots/{id}
     * @secure
     */
    updateInstance: (
      id: string,
      data: SubscriptionAppStoreReviewScreenshotUpdateRequest,
      params: RequestParams = {},
    ): Promise<SubscriptionAppStoreReviewScreenshotResponse> =>
      this.request<SubscriptionAppStoreReviewScreenshotResponse, ErrorResponse>({
        path: `/v1/subscriptionAppStoreReviewScreenshots/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags SubscriptionAppStoreReviewScreenshots
     * @name SubscriptionAppStoreReviewScreenshotsDeleteInstance
     * @request DELETE:/v1/subscriptionAppStoreReviewScreenshots/{id}
     * @secure
     */
    deleteInstance: (id: string, params: RequestParams = {}): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/subscriptionAppStoreReviewScreenshots/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),
  };
  subscriptionAvailabilities = {
    /**
     * No description
     *
     * @tags SubscriptionAvailabilities
     * @name SubscriptionAvailabilitiesCreateInstance
     * @request POST:/v1/subscriptionAvailabilities
     * @secure
     */
    createInstance: (
      data: SubscriptionAvailabilityCreateRequest,
      params: RequestParams = {},
    ): Promise<SubscriptionAvailabilityResponse> =>
      this.request<SubscriptionAvailabilityResponse, ErrorResponse>({
        path: `/v1/subscriptionAvailabilities`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags SubscriptionAvailabilities
     * @name SubscriptionAvailabilitiesGetInstance
     * @request GET:/v1/subscriptionAvailabilities/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type subscriptionAvailabilities */
        "fields[subscriptionAvailabilities]"?: (
          | "availableInNewTerritories"
          | "availableTerritories"
          | "subscription"
        )[];
        /** comma-separated list of relationships to include */
        include?: ("availableTerritories" | "subscription")[];
        /** the fields to include for returned resources of type territories */
        "fields[territories]"?: "currency"[];
        /**
         * maximum number of related availableTerritories returned (when they are included)
         * @max 50
         */
        "limit[availableTerritories]"?: number;
      },
      params: RequestParams = {},
    ): Promise<SubscriptionAvailabilityResponse> =>
      this.request<SubscriptionAvailabilityResponse, ErrorResponse>({
        path: `/v1/subscriptionAvailabilities/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags SubscriptionAvailabilities
     * @name SubscriptionAvailabilitiesAvailableTerritoriesGetToManyRelated
     * @request GET:/v1/subscriptionAvailabilities/{id}/availableTerritories
     * @secure
     */
    availableTerritoriesGetToManyRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type territories */
        "fields[territories]"?: "currency"[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
      },
      params: RequestParams = {},
    ): Promise<TerritoriesResponse> =>
      this.request<TerritoriesResponse, ErrorResponse>({
        path: `/v1/subscriptionAvailabilities/${id}/availableTerritories`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  subscriptionGracePeriods = {
    /**
     * No description
     *
     * @tags SubscriptionGracePeriods
     * @name SubscriptionGracePeriodsGetInstance
     * @request GET:/v1/subscriptionGracePeriods/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type subscriptionGracePeriods */
        "fields[subscriptionGracePeriods]"?: ("duration" | "optIn" | "renewalType" | "sandboxOptIn")[];
      },
      params: RequestParams = {},
    ): Promise<SubscriptionGracePeriodResponse> =>
      this.request<SubscriptionGracePeriodResponse, ErrorResponse>({
        path: `/v1/subscriptionGracePeriods/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags SubscriptionGracePeriods
     * @name SubscriptionGracePeriodsUpdateInstance
     * @request PATCH:/v1/subscriptionGracePeriods/{id}
     * @secure
     */
    updateInstance: (
      id: string,
      data: SubscriptionGracePeriodUpdateRequest,
      params: RequestParams = {},
    ): Promise<SubscriptionGracePeriodResponse> =>
      this.request<SubscriptionGracePeriodResponse, ErrorResponse>({
        path: `/v1/subscriptionGracePeriods/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),
  };
  subscriptionGroupLocalizations = {
    /**
     * No description
     *
     * @tags SubscriptionGroupLocalizations
     * @name SubscriptionGroupLocalizationsCreateInstance
     * @request POST:/v1/subscriptionGroupLocalizations
     * @secure
     */
    createInstance: (
      data: SubscriptionGroupLocalizationCreateRequest,
      params: RequestParams = {},
    ): Promise<SubscriptionGroupLocalizationResponse> =>
      this.request<SubscriptionGroupLocalizationResponse, ErrorResponse>({
        path: `/v1/subscriptionGroupLocalizations`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags SubscriptionGroupLocalizations
     * @name SubscriptionGroupLocalizationsGetInstance
     * @request GET:/v1/subscriptionGroupLocalizations/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type subscriptionGroupLocalizations */
        "fields[subscriptionGroupLocalizations]"?: (
          | "customAppName"
          | "locale"
          | "name"
          | "state"
          | "subscriptionGroup"
        )[];
        /** comma-separated list of relationships to include */
        include?: "subscriptionGroup"[];
      },
      params: RequestParams = {},
    ): Promise<SubscriptionGroupLocalizationResponse> =>
      this.request<SubscriptionGroupLocalizationResponse, ErrorResponse>({
        path: `/v1/subscriptionGroupLocalizations/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags SubscriptionGroupLocalizations
     * @name SubscriptionGroupLocalizationsUpdateInstance
     * @request PATCH:/v1/subscriptionGroupLocalizations/{id}
     * @secure
     */
    updateInstance: (
      id: string,
      data: SubscriptionGroupLocalizationUpdateRequest,
      params: RequestParams = {},
    ): Promise<SubscriptionGroupLocalizationResponse> =>
      this.request<SubscriptionGroupLocalizationResponse, ErrorResponse>({
        path: `/v1/subscriptionGroupLocalizations/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags SubscriptionGroupLocalizations
     * @name SubscriptionGroupLocalizationsDeleteInstance
     * @request DELETE:/v1/subscriptionGroupLocalizations/{id}
     * @secure
     */
    deleteInstance: (id: string, params: RequestParams = {}): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/subscriptionGroupLocalizations/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),
  };
  subscriptionGroupSubmissions = {
    /**
     * No description
     *
     * @tags SubscriptionGroupSubmissions
     * @name SubscriptionGroupSubmissionsCreateInstance
     * @request POST:/v1/subscriptionGroupSubmissions
     * @secure
     */
    createInstance: (
      data: SubscriptionGroupSubmissionCreateRequest,
      params: RequestParams = {},
    ): Promise<SubscriptionGroupSubmissionResponse> =>
      this.request<SubscriptionGroupSubmissionResponse, ErrorResponse>({
        path: `/v1/subscriptionGroupSubmissions`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),
  };
  subscriptionGroups = {
    /**
     * No description
     *
     * @tags SubscriptionGroups
     * @name SubscriptionGroupsCreateInstance
     * @request POST:/v1/subscriptionGroups
     * @secure
     */
    createInstance: (
      data: SubscriptionGroupCreateRequest,
      params: RequestParams = {},
    ): Promise<SubscriptionGroupResponse> =>
      this.request<SubscriptionGroupResponse, ErrorResponse>({
        path: `/v1/subscriptionGroups`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags SubscriptionGroups
     * @name SubscriptionGroupsGetInstance
     * @request GET:/v1/subscriptionGroups/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type subscriptionGroups */
        "fields[subscriptionGroups]"?: ("app" | "referenceName" | "subscriptionGroupLocalizations" | "subscriptions")[];
        /** comma-separated list of relationships to include */
        include?: ("subscriptionGroupLocalizations" | "subscriptions")[];
        /** the fields to include for returned resources of type subscriptions */
        "fields[subscriptions]"?: (
          | "appStoreReviewScreenshot"
          | "familySharable"
          | "group"
          | "groupLevel"
          | "introductoryOffers"
          | "name"
          | "offerCodes"
          | "pricePoints"
          | "prices"
          | "productId"
          | "promotedPurchase"
          | "promotionalOffers"
          | "reviewNote"
          | "state"
          | "subscriptionAvailability"
          | "subscriptionLocalizations"
          | "subscriptionPeriod"
        )[];
        /** the fields to include for returned resources of type subscriptionGroupLocalizations */
        "fields[subscriptionGroupLocalizations]"?: (
          | "customAppName"
          | "locale"
          | "name"
          | "state"
          | "subscriptionGroup"
        )[];
        /**
         * maximum number of related subscriptionGroupLocalizations returned (when they are included)
         * @max 50
         */
        "limit[subscriptionGroupLocalizations]"?: number;
        /**
         * maximum number of related subscriptions returned (when they are included)
         * @max 50
         */
        "limit[subscriptions]"?: number;
      },
      params: RequestParams = {},
    ): Promise<SubscriptionGroupResponse> =>
      this.request<SubscriptionGroupResponse, ErrorResponse>({
        path: `/v1/subscriptionGroups/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags SubscriptionGroups
     * @name SubscriptionGroupsUpdateInstance
     * @request PATCH:/v1/subscriptionGroups/{id}
     * @secure
     */
    updateInstance: (
      id: string,
      data: SubscriptionGroupUpdateRequest,
      params: RequestParams = {},
    ): Promise<SubscriptionGroupResponse> =>
      this.request<SubscriptionGroupResponse, ErrorResponse>({
        path: `/v1/subscriptionGroups/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags SubscriptionGroups
     * @name SubscriptionGroupsDeleteInstance
     * @request DELETE:/v1/subscriptionGroups/{id}
     * @secure
     */
    deleteInstance: (id: string, params: RequestParams = {}): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/subscriptionGroups/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),

    /**
     * No description
     *
     * @tags SubscriptionGroups
     * @name SubscriptionGroupsSubscriptionGroupLocalizationsGetToManyRelated
     * @request GET:/v1/subscriptionGroups/{id}/subscriptionGroupLocalizations
     * @secure
     */
    subscriptionGroupLocalizationsGetToManyRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type subscriptionGroups */
        "fields[subscriptionGroups]"?: ("app" | "referenceName" | "subscriptionGroupLocalizations" | "subscriptions")[];
        /** the fields to include for returned resources of type subscriptionGroupLocalizations */
        "fields[subscriptionGroupLocalizations]"?: (
          | "customAppName"
          | "locale"
          | "name"
          | "state"
          | "subscriptionGroup"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /** comma-separated list of relationships to include */
        include?: "subscriptionGroup"[];
      },
      params: RequestParams = {},
    ): Promise<SubscriptionGroupLocalizationsResponse> =>
      this.request<SubscriptionGroupLocalizationsResponse, ErrorResponse>({
        path: `/v1/subscriptionGroups/${id}/subscriptionGroupLocalizations`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags SubscriptionGroups
     * @name SubscriptionGroupsSubscriptionsGetToManyRelated
     * @request GET:/v1/subscriptionGroups/{id}/subscriptions
     * @secure
     */
    subscriptionsGetToManyRelated: (
      id: string,
      query?: {
        /** filter by attribute 'name' */
        "filter[name]"?: string[];
        /** filter by attribute 'productId' */
        "filter[productId]"?: string[];
        /** filter by attribute 'state' */
        "filter[state]"?: (
          | "MISSING_METADATA"
          | "READY_TO_SUBMIT"
          | "WAITING_FOR_REVIEW"
          | "IN_REVIEW"
          | "DEVELOPER_ACTION_NEEDED"
          | "PENDING_BINARY_APPROVAL"
          | "APPROVED"
          | "DEVELOPER_REMOVED_FROM_SALE"
          | "REMOVED_FROM_SALE"
          | "REJECTED"
        )[];
        /** comma-separated list of sort expressions; resources will be sorted as specified */
        sort?: ("name" | "-name")[];
        /** the fields to include for returned resources of type promotedPurchases */
        "fields[promotedPurchases]"?: (
          | "app"
          | "enabled"
          | "inAppPurchaseV2"
          | "promotionImages"
          | "state"
          | "subscription"
          | "visibleForAllUsers"
        )[];
        /** the fields to include for returned resources of type subscriptionPromotionalOffers */
        "fields[subscriptionPromotionalOffers]"?: (
          | "duration"
          | "name"
          | "numberOfPeriods"
          | "offerCode"
          | "offerMode"
          | "prices"
          | "subscription"
        )[];
        /** the fields to include for returned resources of type subscriptionOfferCodes */
        "fields[subscriptionOfferCodes]"?: (
          | "active"
          | "customCodes"
          | "customerEligibilities"
          | "duration"
          | "name"
          | "numberOfPeriods"
          | "offerEligibility"
          | "offerMode"
          | "oneTimeUseCodes"
          | "prices"
          | "subscription"
          | "totalNumberOfCodes"
        )[];
        /** the fields to include for returned resources of type subscriptionAppStoreReviewScreenshots */
        "fields[subscriptionAppStoreReviewScreenshots]"?: (
          | "assetDeliveryState"
          | "assetToken"
          | "assetType"
          | "fileName"
          | "fileSize"
          | "imageAsset"
          | "sourceFileChecksum"
          | "subscription"
          | "uploadOperations"
          | "uploaded"
        )[];
        /** the fields to include for returned resources of type subscriptions */
        "fields[subscriptions]"?: (
          | "appStoreReviewScreenshot"
          | "familySharable"
          | "group"
          | "groupLevel"
          | "introductoryOffers"
          | "name"
          | "offerCodes"
          | "pricePoints"
          | "prices"
          | "productId"
          | "promotedPurchase"
          | "promotionalOffers"
          | "reviewNote"
          | "state"
          | "subscriptionAvailability"
          | "subscriptionLocalizations"
          | "subscriptionPeriod"
        )[];
        /** the fields to include for returned resources of type subscriptionAvailabilities */
        "fields[subscriptionAvailabilities]"?: (
          | "availableInNewTerritories"
          | "availableTerritories"
          | "subscription"
        )[];
        /** the fields to include for returned resources of type subscriptionGroups */
        "fields[subscriptionGroups]"?: ("app" | "referenceName" | "subscriptionGroupLocalizations" | "subscriptions")[];
        /** the fields to include for returned resources of type subscriptionIntroductoryOffers */
        "fields[subscriptionIntroductoryOffers]"?: (
          | "duration"
          | "endDate"
          | "numberOfPeriods"
          | "offerMode"
          | "startDate"
          | "subscription"
          | "subscriptionPricePoint"
          | "territory"
        )[];
        /** the fields to include for returned resources of type subscriptionPrices */
        "fields[subscriptionPrices]"?: (
          | "preserveCurrentPrice"
          | "preserved"
          | "startDate"
          | "subscription"
          | "subscriptionPricePoint"
          | "territory"
        )[];
        /** the fields to include for returned resources of type subscriptionLocalizations */
        "fields[subscriptionLocalizations]"?: ("description" | "locale" | "name" | "state" | "subscription")[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /**
         * maximum number of related subscriptionLocalizations returned (when they are included)
         * @max 50
         */
        "limit[subscriptionLocalizations]"?: number;
        /**
         * maximum number of related introductoryOffers returned (when they are included)
         * @max 50
         */
        "limit[introductoryOffers]"?: number;
        /**
         * maximum number of related promotionalOffers returned (when they are included)
         * @max 50
         */
        "limit[promotionalOffers]"?: number;
        /**
         * maximum number of related offerCodes returned (when they are included)
         * @max 50
         */
        "limit[offerCodes]"?: number;
        /**
         * maximum number of related prices returned (when they are included)
         * @max 50
         */
        "limit[prices]"?: number;
        /** comma-separated list of relationships to include */
        include?: (
          | "appStoreReviewScreenshot"
          | "group"
          | "introductoryOffers"
          | "offerCodes"
          | "prices"
          | "promotedPurchase"
          | "promotionalOffers"
          | "subscriptionAvailability"
          | "subscriptionLocalizations"
        )[];
      },
      params: RequestParams = {},
    ): Promise<SubscriptionsResponse> =>
      this.request<SubscriptionsResponse, ErrorResponse>({
        path: `/v1/subscriptionGroups/${id}/subscriptions`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  subscriptionIntroductoryOffers = {
    /**
     * No description
     *
     * @tags SubscriptionIntroductoryOffers
     * @name SubscriptionIntroductoryOffersCreateInstance
     * @request POST:/v1/subscriptionIntroductoryOffers
     * @secure
     */
    createInstance: (
      data: SubscriptionIntroductoryOfferCreateRequest,
      params: RequestParams = {},
    ): Promise<SubscriptionIntroductoryOfferResponse> =>
      this.request<SubscriptionIntroductoryOfferResponse, ErrorResponse>({
        path: `/v1/subscriptionIntroductoryOffers`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags SubscriptionIntroductoryOffers
     * @name SubscriptionIntroductoryOffersUpdateInstance
     * @request PATCH:/v1/subscriptionIntroductoryOffers/{id}
     * @secure
     */
    updateInstance: (
      id: string,
      data: SubscriptionIntroductoryOfferUpdateRequest,
      params: RequestParams = {},
    ): Promise<SubscriptionIntroductoryOfferResponse> =>
      this.request<SubscriptionIntroductoryOfferResponse, ErrorResponse>({
        path: `/v1/subscriptionIntroductoryOffers/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags SubscriptionIntroductoryOffers
     * @name SubscriptionIntroductoryOffersDeleteInstance
     * @request DELETE:/v1/subscriptionIntroductoryOffers/{id}
     * @secure
     */
    deleteInstance: (id: string, params: RequestParams = {}): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/subscriptionIntroductoryOffers/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),
  };
  subscriptionLocalizations = {
    /**
     * No description
     *
     * @tags SubscriptionLocalizations
     * @name SubscriptionLocalizationsCreateInstance
     * @request POST:/v1/subscriptionLocalizations
     * @secure
     */
    createInstance: (
      data: SubscriptionLocalizationCreateRequest,
      params: RequestParams = {},
    ): Promise<SubscriptionLocalizationResponse> =>
      this.request<SubscriptionLocalizationResponse, ErrorResponse>({
        path: `/v1/subscriptionLocalizations`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags SubscriptionLocalizations
     * @name SubscriptionLocalizationsGetInstance
     * @request GET:/v1/subscriptionLocalizations/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type subscriptionLocalizations */
        "fields[subscriptionLocalizations]"?: ("description" | "locale" | "name" | "state" | "subscription")[];
        /** comma-separated list of relationships to include */
        include?: "subscription"[];
      },
      params: RequestParams = {},
    ): Promise<SubscriptionLocalizationResponse> =>
      this.request<SubscriptionLocalizationResponse, ErrorResponse>({
        path: `/v1/subscriptionLocalizations/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags SubscriptionLocalizations
     * @name SubscriptionLocalizationsUpdateInstance
     * @request PATCH:/v1/subscriptionLocalizations/{id}
     * @secure
     */
    updateInstance: (
      id: string,
      data: SubscriptionLocalizationUpdateRequest,
      params: RequestParams = {},
    ): Promise<SubscriptionLocalizationResponse> =>
      this.request<SubscriptionLocalizationResponse, ErrorResponse>({
        path: `/v1/subscriptionLocalizations/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags SubscriptionLocalizations
     * @name SubscriptionLocalizationsDeleteInstance
     * @request DELETE:/v1/subscriptionLocalizations/{id}
     * @secure
     */
    deleteInstance: (id: string, params: RequestParams = {}): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/subscriptionLocalizations/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),
  };
  subscriptionOfferCodeCustomCodes = {
    /**
     * No description
     *
     * @tags SubscriptionOfferCodeCustomCodes
     * @name SubscriptionOfferCodeCustomCodesCreateInstance
     * @request POST:/v1/subscriptionOfferCodeCustomCodes
     * @secure
     */
    createInstance: (
      data: SubscriptionOfferCodeCustomCodeCreateRequest,
      params: RequestParams = {},
    ): Promise<SubscriptionOfferCodeCustomCodeResponse> =>
      this.request<SubscriptionOfferCodeCustomCodeResponse, ErrorResponse>({
        path: `/v1/subscriptionOfferCodeCustomCodes`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags SubscriptionOfferCodeCustomCodes
     * @name SubscriptionOfferCodeCustomCodesGetInstance
     * @request GET:/v1/subscriptionOfferCodeCustomCodes/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type subscriptionOfferCodeCustomCodes */
        "fields[subscriptionOfferCodeCustomCodes]"?: (
          | "active"
          | "createdDate"
          | "customCode"
          | "expirationDate"
          | "numberOfCodes"
          | "offerCode"
        )[];
        /** comma-separated list of relationships to include */
        include?: "offerCode"[];
      },
      params: RequestParams = {},
    ): Promise<SubscriptionOfferCodeCustomCodeResponse> =>
      this.request<SubscriptionOfferCodeCustomCodeResponse, ErrorResponse>({
        path: `/v1/subscriptionOfferCodeCustomCodes/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags SubscriptionOfferCodeCustomCodes
     * @name SubscriptionOfferCodeCustomCodesUpdateInstance
     * @request PATCH:/v1/subscriptionOfferCodeCustomCodes/{id}
     * @secure
     */
    updateInstance: (
      id: string,
      data: SubscriptionOfferCodeCustomCodeUpdateRequest,
      params: RequestParams = {},
    ): Promise<SubscriptionOfferCodeCustomCodeResponse> =>
      this.request<SubscriptionOfferCodeCustomCodeResponse, ErrorResponse>({
        path: `/v1/subscriptionOfferCodeCustomCodes/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),
  };
  subscriptionOfferCodeOneTimeUseCodes = {
    /**
     * No description
     *
     * @tags SubscriptionOfferCodeOneTimeUseCodes
     * @name SubscriptionOfferCodeOneTimeUseCodesCreateInstance
     * @request POST:/v1/subscriptionOfferCodeOneTimeUseCodes
     * @secure
     */
    createInstance: (
      data: SubscriptionOfferCodeOneTimeUseCodeCreateRequest,
      params: RequestParams = {},
    ): Promise<SubscriptionOfferCodeOneTimeUseCodeResponse> =>
      this.request<SubscriptionOfferCodeOneTimeUseCodeResponse, ErrorResponse>({
        path: `/v1/subscriptionOfferCodeOneTimeUseCodes`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags SubscriptionOfferCodeOneTimeUseCodes
     * @name SubscriptionOfferCodeOneTimeUseCodesGetInstance
     * @request GET:/v1/subscriptionOfferCodeOneTimeUseCodes/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type subscriptionOfferCodeOneTimeUseCodes */
        "fields[subscriptionOfferCodeOneTimeUseCodes]"?: (
          | "active"
          | "createdDate"
          | "expirationDate"
          | "numberOfCodes"
          | "offerCode"
          | "values"
        )[];
        /** comma-separated list of relationships to include */
        include?: "offerCode"[];
      },
      params: RequestParams = {},
    ): Promise<SubscriptionOfferCodeOneTimeUseCodeResponse> =>
      this.request<SubscriptionOfferCodeOneTimeUseCodeResponse, ErrorResponse>({
        path: `/v1/subscriptionOfferCodeOneTimeUseCodes/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags SubscriptionOfferCodeOneTimeUseCodes
     * @name SubscriptionOfferCodeOneTimeUseCodesUpdateInstance
     * @request PATCH:/v1/subscriptionOfferCodeOneTimeUseCodes/{id}
     * @secure
     */
    updateInstance: (
      id: string,
      data: SubscriptionOfferCodeOneTimeUseCodeUpdateRequest,
      params: RequestParams = {},
    ): Promise<SubscriptionOfferCodeOneTimeUseCodeResponse> =>
      this.request<SubscriptionOfferCodeOneTimeUseCodeResponse, ErrorResponse>({
        path: `/v1/subscriptionOfferCodeOneTimeUseCodes/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags SubscriptionOfferCodeOneTimeUseCodes
     * @name SubscriptionOfferCodeOneTimeUseCodesValuesGetToOneRelated
     * @request GET:/v1/subscriptionOfferCodeOneTimeUseCodes/{id}/values
     * @secure
     */
    valuesGetToOneRelated: (id: string, params: RequestParams = {}): Promise<Csv> =>
      this.request<Csv, ErrorResponse>({
        path: `/v1/subscriptionOfferCodeOneTimeUseCodes/${id}/values`,
        method: "GET",
        secure: true,
        ...params,
      }),
  };
  subscriptionOfferCodes = {
    /**
     * No description
     *
     * @tags SubscriptionOfferCodes
     * @name SubscriptionOfferCodesCreateInstance
     * @request POST:/v1/subscriptionOfferCodes
     * @secure
     */
    createInstance: (
      data: SubscriptionOfferCodeCreateRequest,
      params: RequestParams = {},
    ): Promise<SubscriptionOfferCodeResponse> =>
      this.request<SubscriptionOfferCodeResponse, ErrorResponse>({
        path: `/v1/subscriptionOfferCodes`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags SubscriptionOfferCodes
     * @name SubscriptionOfferCodesGetInstance
     * @request GET:/v1/subscriptionOfferCodes/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type subscriptionOfferCodes */
        "fields[subscriptionOfferCodes]"?: (
          | "active"
          | "customCodes"
          | "customerEligibilities"
          | "duration"
          | "name"
          | "numberOfPeriods"
          | "offerEligibility"
          | "offerMode"
          | "oneTimeUseCodes"
          | "prices"
          | "subscription"
          | "totalNumberOfCodes"
        )[];
        /** comma-separated list of relationships to include */
        include?: ("customCodes" | "oneTimeUseCodes" | "prices" | "subscription")[];
        /** the fields to include for returned resources of type subscriptionOfferCodeCustomCodes */
        "fields[subscriptionOfferCodeCustomCodes]"?: (
          | "active"
          | "createdDate"
          | "customCode"
          | "expirationDate"
          | "numberOfCodes"
          | "offerCode"
        )[];
        /** the fields to include for returned resources of type subscriptionOfferCodeOneTimeUseCodes */
        "fields[subscriptionOfferCodeOneTimeUseCodes]"?: (
          | "active"
          | "createdDate"
          | "expirationDate"
          | "numberOfCodes"
          | "offerCode"
          | "values"
        )[];
        /** the fields to include for returned resources of type subscriptionOfferCodePrices */
        "fields[subscriptionOfferCodePrices]"?: ("subscriptionPricePoint" | "territory")[];
        /**
         * maximum number of related customCodes returned (when they are included)
         * @max 50
         */
        "limit[customCodes]"?: number;
        /**
         * maximum number of related oneTimeUseCodes returned (when they are included)
         * @max 50
         */
        "limit[oneTimeUseCodes]"?: number;
        /**
         * maximum number of related prices returned (when they are included)
         * @max 50
         */
        "limit[prices]"?: number;
      },
      params: RequestParams = {},
    ): Promise<SubscriptionOfferCodeResponse> =>
      this.request<SubscriptionOfferCodeResponse, ErrorResponse>({
        path: `/v1/subscriptionOfferCodes/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags SubscriptionOfferCodes
     * @name SubscriptionOfferCodesUpdateInstance
     * @request PATCH:/v1/subscriptionOfferCodes/{id}
     * @secure
     */
    updateInstance: (
      id: string,
      data: SubscriptionOfferCodeUpdateRequest,
      params: RequestParams = {},
    ): Promise<SubscriptionOfferCodeResponse> =>
      this.request<SubscriptionOfferCodeResponse, ErrorResponse>({
        path: `/v1/subscriptionOfferCodes/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags SubscriptionOfferCodes
     * @name SubscriptionOfferCodesCustomCodesGetToManyRelated
     * @request GET:/v1/subscriptionOfferCodes/{id}/customCodes
     * @secure
     */
    customCodesGetToManyRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type subscriptionOfferCodeCustomCodes */
        "fields[subscriptionOfferCodeCustomCodes]"?: (
          | "active"
          | "createdDate"
          | "customCode"
          | "expirationDate"
          | "numberOfCodes"
          | "offerCode"
        )[];
        /** the fields to include for returned resources of type subscriptionOfferCodes */
        "fields[subscriptionOfferCodes]"?: (
          | "active"
          | "customCodes"
          | "customerEligibilities"
          | "duration"
          | "name"
          | "numberOfPeriods"
          | "offerEligibility"
          | "offerMode"
          | "oneTimeUseCodes"
          | "prices"
          | "subscription"
          | "totalNumberOfCodes"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /** comma-separated list of relationships to include */
        include?: "offerCode"[];
      },
      params: RequestParams = {},
    ): Promise<SubscriptionOfferCodeCustomCodesResponse> =>
      this.request<SubscriptionOfferCodeCustomCodesResponse, ErrorResponse>({
        path: `/v1/subscriptionOfferCodes/${id}/customCodes`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags SubscriptionOfferCodes
     * @name SubscriptionOfferCodesOneTimeUseCodesGetToManyRelated
     * @request GET:/v1/subscriptionOfferCodes/{id}/oneTimeUseCodes
     * @secure
     */
    oneTimeUseCodesGetToManyRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type subscriptionOfferCodes */
        "fields[subscriptionOfferCodes]"?: (
          | "active"
          | "customCodes"
          | "customerEligibilities"
          | "duration"
          | "name"
          | "numberOfPeriods"
          | "offerEligibility"
          | "offerMode"
          | "oneTimeUseCodes"
          | "prices"
          | "subscription"
          | "totalNumberOfCodes"
        )[];
        /** the fields to include for returned resources of type subscriptionOfferCodeOneTimeUseCodes */
        "fields[subscriptionOfferCodeOneTimeUseCodes]"?: (
          | "active"
          | "createdDate"
          | "expirationDate"
          | "numberOfCodes"
          | "offerCode"
          | "values"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /** comma-separated list of relationships to include */
        include?: "offerCode"[];
      },
      params: RequestParams = {},
    ): Promise<SubscriptionOfferCodeOneTimeUseCodesResponse> =>
      this.request<SubscriptionOfferCodeOneTimeUseCodesResponse, ErrorResponse>({
        path: `/v1/subscriptionOfferCodes/${id}/oneTimeUseCodes`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags SubscriptionOfferCodes
     * @name SubscriptionOfferCodesPricesGetToManyRelated
     * @request GET:/v1/subscriptionOfferCodes/{id}/prices
     * @secure
     */
    pricesGetToManyRelated: (
      id: string,
      query?: {
        /** filter by id(s) of related 'territory' */
        "filter[territory]"?: string[];
        /** the fields to include for returned resources of type subscriptionPricePoints */
        "fields[subscriptionPricePoints]"?: (
          | "customerPrice"
          | "equalizations"
          | "proceeds"
          | "proceedsYear2"
          | "subscription"
          | "territory"
        )[];
        /** the fields to include for returned resources of type territories */
        "fields[territories]"?: "currency"[];
        /** the fields to include for returned resources of type subscriptionOfferCodePrices */
        "fields[subscriptionOfferCodePrices]"?: ("subscriptionPricePoint" | "territory")[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /** comma-separated list of relationships to include */
        include?: ("subscriptionPricePoint" | "territory")[];
      },
      params: RequestParams = {},
    ): Promise<SubscriptionOfferCodePricesResponse> =>
      this.request<SubscriptionOfferCodePricesResponse, ErrorResponse>({
        path: `/v1/subscriptionOfferCodes/${id}/prices`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  subscriptionPricePoints = {
    /**
     * No description
     *
     * @tags SubscriptionPricePoints
     * @name SubscriptionPricePointsGetInstance
     * @request GET:/v1/subscriptionPricePoints/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type subscriptionPricePoints */
        "fields[subscriptionPricePoints]"?: (
          | "customerPrice"
          | "equalizations"
          | "proceeds"
          | "proceedsYear2"
          | "subscription"
          | "territory"
        )[];
        /** comma-separated list of relationships to include */
        include?: "territory"[];
      },
      params: RequestParams = {},
    ): Promise<SubscriptionPricePointResponse> =>
      this.request<SubscriptionPricePointResponse, ErrorResponse>({
        path: `/v1/subscriptionPricePoints/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags SubscriptionPricePoints
     * @name SubscriptionPricePointsEqualizationsGetToManyRelated
     * @request GET:/v1/subscriptionPricePoints/{id}/equalizations
     * @secure
     */
    equalizationsGetToManyRelated: (
      id: string,
      query?: {
        /** filter by id(s) of related 'subscription' */
        "filter[subscription]"?: string[];
        /** filter by id(s) of related 'territory' */
        "filter[territory]"?: string[];
        /** the fields to include for returned resources of type subscriptionPricePoints */
        "fields[subscriptionPricePoints]"?: (
          | "customerPrice"
          | "equalizations"
          | "proceeds"
          | "proceedsYear2"
          | "subscription"
          | "territory"
        )[];
        /** the fields to include for returned resources of type territories */
        "fields[territories]"?: "currency"[];
        /**
         * maximum resources per page
         * @max 8000
         */
        limit?: number;
        /** comma-separated list of relationships to include */
        include?: "territory"[];
      },
      params: RequestParams = {},
    ): Promise<SubscriptionPricePointsResponse> =>
      this.request<SubscriptionPricePointsResponse, ErrorResponse>({
        path: `/v1/subscriptionPricePoints/${id}/equalizations`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  subscriptionPrices = {
    /**
     * No description
     *
     * @tags SubscriptionPrices
     * @name SubscriptionPricesCreateInstance
     * @request POST:/v1/subscriptionPrices
     * @secure
     */
    createInstance: (
      data: SubscriptionPriceCreateRequest,
      params: RequestParams = {},
    ): Promise<SubscriptionPriceResponse> =>
      this.request<SubscriptionPriceResponse, ErrorResponse>({
        path: `/v1/subscriptionPrices`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags SubscriptionPrices
     * @name SubscriptionPricesDeleteInstance
     * @request DELETE:/v1/subscriptionPrices/{id}
     * @secure
     */
    deleteInstance: (id: string, params: RequestParams = {}): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/subscriptionPrices/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),
  };
  subscriptionPromotionalOffers = {
    /**
     * No description
     *
     * @tags SubscriptionPromotionalOffers
     * @name SubscriptionPromotionalOffersCreateInstance
     * @request POST:/v1/subscriptionPromotionalOffers
     * @secure
     */
    createInstance: (
      data: SubscriptionPromotionalOfferCreateRequest,
      params: RequestParams = {},
    ): Promise<SubscriptionPromotionalOfferResponse> =>
      this.request<SubscriptionPromotionalOfferResponse, ErrorResponse>({
        path: `/v1/subscriptionPromotionalOffers`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags SubscriptionPromotionalOffers
     * @name SubscriptionPromotionalOffersGetInstance
     * @request GET:/v1/subscriptionPromotionalOffers/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type subscriptionPromotionalOffers */
        "fields[subscriptionPromotionalOffers]"?: (
          | "duration"
          | "name"
          | "numberOfPeriods"
          | "offerCode"
          | "offerMode"
          | "prices"
          | "subscription"
        )[];
        /** comma-separated list of relationships to include */
        include?: ("prices" | "subscription")[];
        /** the fields to include for returned resources of type subscriptionPromotionalOfferPrices */
        "fields[subscriptionPromotionalOfferPrices]"?: ("subscriptionPricePoint" | "territory")[];
        /**
         * maximum number of related prices returned (when they are included)
         * @max 50
         */
        "limit[prices]"?: number;
      },
      params: RequestParams = {},
    ): Promise<SubscriptionPromotionalOfferResponse> =>
      this.request<SubscriptionPromotionalOfferResponse, ErrorResponse>({
        path: `/v1/subscriptionPromotionalOffers/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags SubscriptionPromotionalOffers
     * @name SubscriptionPromotionalOffersUpdateInstance
     * @request PATCH:/v1/subscriptionPromotionalOffers/{id}
     * @secure
     */
    updateInstance: (
      id: string,
      data: SubscriptionPromotionalOfferUpdateRequest,
      params: RequestParams = {},
    ): Promise<SubscriptionPromotionalOfferResponse> =>
      this.request<SubscriptionPromotionalOfferResponse, ErrorResponse>({
        path: `/v1/subscriptionPromotionalOffers/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags SubscriptionPromotionalOffers
     * @name SubscriptionPromotionalOffersDeleteInstance
     * @request DELETE:/v1/subscriptionPromotionalOffers/{id}
     * @secure
     */
    deleteInstance: (id: string, params: RequestParams = {}): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/subscriptionPromotionalOffers/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),

    /**
     * No description
     *
     * @tags SubscriptionPromotionalOffers
     * @name SubscriptionPromotionalOffersPricesGetToManyRelated
     * @request GET:/v1/subscriptionPromotionalOffers/{id}/prices
     * @secure
     */
    pricesGetToManyRelated: (
      id: string,
      query?: {
        /** filter by id(s) of related 'territory' */
        "filter[territory]"?: string[];
        /** the fields to include for returned resources of type subscriptionPricePoints */
        "fields[subscriptionPricePoints]"?: (
          | "customerPrice"
          | "equalizations"
          | "proceeds"
          | "proceedsYear2"
          | "subscription"
          | "territory"
        )[];
        /** the fields to include for returned resources of type territories */
        "fields[territories]"?: "currency"[];
        /** the fields to include for returned resources of type subscriptionPromotionalOfferPrices */
        "fields[subscriptionPromotionalOfferPrices]"?: ("subscriptionPricePoint" | "territory")[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /** comma-separated list of relationships to include */
        include?: ("subscriptionPricePoint" | "territory")[];
      },
      params: RequestParams = {},
    ): Promise<SubscriptionPromotionalOfferPricesResponse> =>
      this.request<SubscriptionPromotionalOfferPricesResponse, ErrorResponse>({
        path: `/v1/subscriptionPromotionalOffers/${id}/prices`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  subscriptionSubmissions = {
    /**
     * No description
     *
     * @tags SubscriptionSubmissions
     * @name SubscriptionSubmissionsCreateInstance
     * @request POST:/v1/subscriptionSubmissions
     * @secure
     */
    createInstance: (
      data: SubscriptionSubmissionCreateRequest,
      params: RequestParams = {},
    ): Promise<SubscriptionSubmissionResponse> =>
      this.request<SubscriptionSubmissionResponse, ErrorResponse>({
        path: `/v1/subscriptionSubmissions`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),
  };
  subscriptions = {
    /**
     * No description
     *
     * @tags Subscriptions
     * @name SubscriptionsCreateInstance
     * @request POST:/v1/subscriptions
     * @secure
     */
    createInstance: (data: SubscriptionCreateRequest, params: RequestParams = {}): Promise<SubscriptionResponse> =>
      this.request<SubscriptionResponse, ErrorResponse>({
        path: `/v1/subscriptions`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Subscriptions
     * @name SubscriptionsGetInstance
     * @request GET:/v1/subscriptions/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type subscriptions */
        "fields[subscriptions]"?: (
          | "appStoreReviewScreenshot"
          | "familySharable"
          | "group"
          | "groupLevel"
          | "introductoryOffers"
          | "name"
          | "offerCodes"
          | "pricePoints"
          | "prices"
          | "productId"
          | "promotedPurchase"
          | "promotionalOffers"
          | "reviewNote"
          | "state"
          | "subscriptionAvailability"
          | "subscriptionLocalizations"
          | "subscriptionPeriod"
        )[];
        /** comma-separated list of relationships to include */
        include?: (
          | "appStoreReviewScreenshot"
          | "group"
          | "introductoryOffers"
          | "offerCodes"
          | "prices"
          | "promotedPurchase"
          | "promotionalOffers"
          | "subscriptionAvailability"
          | "subscriptionLocalizations"
        )[];
        /** the fields to include for returned resources of type promotedPurchases */
        "fields[promotedPurchases]"?: (
          | "app"
          | "enabled"
          | "inAppPurchaseV2"
          | "promotionImages"
          | "state"
          | "subscription"
          | "visibleForAllUsers"
        )[];
        /** the fields to include for returned resources of type subscriptionPricePoints */
        "fields[subscriptionPricePoints]"?: (
          | "customerPrice"
          | "equalizations"
          | "proceeds"
          | "proceedsYear2"
          | "subscription"
          | "territory"
        )[];
        /** the fields to include for returned resources of type subscriptionPromotionalOffers */
        "fields[subscriptionPromotionalOffers]"?: (
          | "duration"
          | "name"
          | "numberOfPeriods"
          | "offerCode"
          | "offerMode"
          | "prices"
          | "subscription"
        )[];
        /** the fields to include for returned resources of type subscriptionOfferCodes */
        "fields[subscriptionOfferCodes]"?: (
          | "active"
          | "customCodes"
          | "customerEligibilities"
          | "duration"
          | "name"
          | "numberOfPeriods"
          | "offerEligibility"
          | "offerMode"
          | "oneTimeUseCodes"
          | "prices"
          | "subscription"
          | "totalNumberOfCodes"
        )[];
        /** the fields to include for returned resources of type subscriptionAppStoreReviewScreenshots */
        "fields[subscriptionAppStoreReviewScreenshots]"?: (
          | "assetDeliveryState"
          | "assetToken"
          | "assetType"
          | "fileName"
          | "fileSize"
          | "imageAsset"
          | "sourceFileChecksum"
          | "subscription"
          | "uploadOperations"
          | "uploaded"
        )[];
        /** the fields to include for returned resources of type subscriptionAvailabilities */
        "fields[subscriptionAvailabilities]"?: (
          | "availableInNewTerritories"
          | "availableTerritories"
          | "subscription"
        )[];
        /** the fields to include for returned resources of type subscriptionPrices */
        "fields[subscriptionPrices]"?: (
          | "preserveCurrentPrice"
          | "preserved"
          | "startDate"
          | "subscription"
          | "subscriptionPricePoint"
          | "territory"
        )[];
        /** the fields to include for returned resources of type subscriptionIntroductoryOffers */
        "fields[subscriptionIntroductoryOffers]"?: (
          | "duration"
          | "endDate"
          | "numberOfPeriods"
          | "offerMode"
          | "startDate"
          | "subscription"
          | "subscriptionPricePoint"
          | "territory"
        )[];
        /** the fields to include for returned resources of type subscriptionLocalizations */
        "fields[subscriptionLocalizations]"?: ("description" | "locale" | "name" | "state" | "subscription")[];
        /**
         * maximum number of related introductoryOffers returned (when they are included)
         * @max 50
         */
        "limit[introductoryOffers]"?: number;
        /**
         * maximum number of related offerCodes returned (when they are included)
         * @max 50
         */
        "limit[offerCodes]"?: number;
        /**
         * maximum number of related prices returned (when they are included)
         * @max 50
         */
        "limit[prices]"?: number;
        /**
         * maximum number of related promotionalOffers returned (when they are included)
         * @max 50
         */
        "limit[promotionalOffers]"?: number;
        /**
         * maximum number of related subscriptionLocalizations returned (when they are included)
         * @max 50
         */
        "limit[subscriptionLocalizations]"?: number;
      },
      params: RequestParams = {},
    ): Promise<SubscriptionResponse> =>
      this.request<SubscriptionResponse, ErrorResponse>({
        path: `/v1/subscriptions/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Subscriptions
     * @name SubscriptionsUpdateInstance
     * @request PATCH:/v1/subscriptions/{id}
     * @secure
     */
    updateInstance: (
      id: string,
      data: SubscriptionUpdateRequest,
      params: RequestParams = {},
    ): Promise<SubscriptionResponse> =>
      this.request<SubscriptionResponse, ErrorResponse>({
        path: `/v1/subscriptions/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Subscriptions
     * @name SubscriptionsDeleteInstance
     * @request DELETE:/v1/subscriptions/{id}
     * @secure
     */
    deleteInstance: (id: string, params: RequestParams = {}): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/subscriptions/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),

    /**
     * No description
     *
     * @tags Subscriptions
     * @name SubscriptionsAppStoreReviewScreenshotGetToOneRelated
     * @request GET:/v1/subscriptions/{id}/appStoreReviewScreenshot
     * @secure
     */
    appStoreReviewScreenshotGetToOneRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type subscriptionAppStoreReviewScreenshots */
        "fields[subscriptionAppStoreReviewScreenshots]"?: (
          | "assetDeliveryState"
          | "assetToken"
          | "assetType"
          | "fileName"
          | "fileSize"
          | "imageAsset"
          | "sourceFileChecksum"
          | "subscription"
          | "uploadOperations"
          | "uploaded"
        )[];
        /** the fields to include for returned resources of type subscriptions */
        "fields[subscriptions]"?: (
          | "appStoreReviewScreenshot"
          | "familySharable"
          | "group"
          | "groupLevel"
          | "introductoryOffers"
          | "name"
          | "offerCodes"
          | "pricePoints"
          | "prices"
          | "productId"
          | "promotedPurchase"
          | "promotionalOffers"
          | "reviewNote"
          | "state"
          | "subscriptionAvailability"
          | "subscriptionLocalizations"
          | "subscriptionPeriod"
        )[];
        /** comma-separated list of relationships to include */
        include?: "subscription"[];
      },
      params: RequestParams = {},
    ): Promise<SubscriptionAppStoreReviewScreenshotResponse> =>
      this.request<SubscriptionAppStoreReviewScreenshotResponse, ErrorResponse>({
        path: `/v1/subscriptions/${id}/appStoreReviewScreenshot`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Subscriptions
     * @name SubscriptionsIntroductoryOffersGetToManyRelationship
     * @request GET:/v1/subscriptions/{id}/relationships/introductoryOffers
     * @secure
     */
    introductoryOffersGetToManyRelationship: (
      id: string,
      query?: {
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
      },
      params: RequestParams = {},
    ): Promise<SubscriptionIntroductoryOffersLinkagesResponse> =>
      this.request<SubscriptionIntroductoryOffersLinkagesResponse, ErrorResponse>({
        path: `/v1/subscriptions/${id}/relationships/introductoryOffers`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Subscriptions
     * @name SubscriptionsIntroductoryOffersDeleteToManyRelationship
     * @request DELETE:/v1/subscriptions/{id}/relationships/introductoryOffers
     * @secure
     */
    introductoryOffersDeleteToManyRelationship: (
      id: string,
      data: SubscriptionIntroductoryOffersLinkagesRequest,
      params: RequestParams = {},
    ): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/subscriptions/${id}/relationships/introductoryOffers`,
        method: "DELETE",
        body: data,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * No description
     *
     * @tags Subscriptions
     * @name SubscriptionsIntroductoryOffersGetToManyRelated
     * @request GET:/v1/subscriptions/{id}/introductoryOffers
     * @secure
     */
    introductoryOffersGetToManyRelated: (
      id: string,
      query?: {
        /** filter by id(s) of related 'territory' */
        "filter[territory]"?: string[];
        /** the fields to include for returned resources of type subscriptionPricePoints */
        "fields[subscriptionPricePoints]"?: (
          | "customerPrice"
          | "equalizations"
          | "proceeds"
          | "proceedsYear2"
          | "subscription"
          | "territory"
        )[];
        /** the fields to include for returned resources of type subscriptions */
        "fields[subscriptions]"?: (
          | "appStoreReviewScreenshot"
          | "familySharable"
          | "group"
          | "groupLevel"
          | "introductoryOffers"
          | "name"
          | "offerCodes"
          | "pricePoints"
          | "prices"
          | "productId"
          | "promotedPurchase"
          | "promotionalOffers"
          | "reviewNote"
          | "state"
          | "subscriptionAvailability"
          | "subscriptionLocalizations"
          | "subscriptionPeriod"
        )[];
        /** the fields to include for returned resources of type subscriptionIntroductoryOffers */
        "fields[subscriptionIntroductoryOffers]"?: (
          | "duration"
          | "endDate"
          | "numberOfPeriods"
          | "offerMode"
          | "startDate"
          | "subscription"
          | "subscriptionPricePoint"
          | "territory"
        )[];
        /** the fields to include for returned resources of type territories */
        "fields[territories]"?: "currency"[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /** comma-separated list of relationships to include */
        include?: ("subscription" | "subscriptionPricePoint" | "territory")[];
      },
      params: RequestParams = {},
    ): Promise<SubscriptionIntroductoryOffersResponse> =>
      this.request<SubscriptionIntroductoryOffersResponse, ErrorResponse>({
        path: `/v1/subscriptions/${id}/introductoryOffers`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Subscriptions
     * @name SubscriptionsOfferCodesGetToManyRelated
     * @request GET:/v1/subscriptions/{id}/offerCodes
     * @secure
     */
    offerCodesGetToManyRelated: (
      id: string,
      query?: {
        /** filter by territory */
        "filter[territory]"?: string[];
        /** the fields to include for returned resources of type subscriptionOfferCodeCustomCodes */
        "fields[subscriptionOfferCodeCustomCodes]"?: (
          | "active"
          | "createdDate"
          | "customCode"
          | "expirationDate"
          | "numberOfCodes"
          | "offerCode"
        )[];
        /** the fields to include for returned resources of type subscriptionOfferCodes */
        "fields[subscriptionOfferCodes]"?: (
          | "active"
          | "customCodes"
          | "customerEligibilities"
          | "duration"
          | "name"
          | "numberOfPeriods"
          | "offerEligibility"
          | "offerMode"
          | "oneTimeUseCodes"
          | "prices"
          | "subscription"
          | "totalNumberOfCodes"
        )[];
        /** the fields to include for returned resources of type subscriptionOfferCodeOneTimeUseCodes */
        "fields[subscriptionOfferCodeOneTimeUseCodes]"?: (
          | "active"
          | "createdDate"
          | "expirationDate"
          | "numberOfCodes"
          | "offerCode"
          | "values"
        )[];
        /** the fields to include for returned resources of type subscriptions */
        "fields[subscriptions]"?: (
          | "appStoreReviewScreenshot"
          | "familySharable"
          | "group"
          | "groupLevel"
          | "introductoryOffers"
          | "name"
          | "offerCodes"
          | "pricePoints"
          | "prices"
          | "productId"
          | "promotedPurchase"
          | "promotionalOffers"
          | "reviewNote"
          | "state"
          | "subscriptionAvailability"
          | "subscriptionLocalizations"
          | "subscriptionPeriod"
        )[];
        /** the fields to include for returned resources of type subscriptionOfferCodePrices */
        "fields[subscriptionOfferCodePrices]"?: ("subscriptionPricePoint" | "territory")[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /**
         * maximum number of related oneTimeUseCodes returned (when they are included)
         * @max 50
         */
        "limit[oneTimeUseCodes]"?: number;
        /**
         * maximum number of related customCodes returned (when they are included)
         * @max 50
         */
        "limit[customCodes]"?: number;
        /**
         * maximum number of related prices returned (when they are included)
         * @max 50
         */
        "limit[prices]"?: number;
        /** comma-separated list of relationships to include */
        include?: ("customCodes" | "oneTimeUseCodes" | "prices" | "subscription")[];
      },
      params: RequestParams = {},
    ): Promise<SubscriptionOfferCodesResponse> =>
      this.request<SubscriptionOfferCodesResponse, ErrorResponse>({
        path: `/v1/subscriptions/${id}/offerCodes`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Subscriptions
     * @name SubscriptionsPricePointsGetToManyRelated
     * @request GET:/v1/subscriptions/{id}/pricePoints
     * @secure
     */
    pricePointsGetToManyRelated: (
      id: string,
      query?: {
        /** filter by id(s) of related 'territory' */
        "filter[territory]"?: string[];
        /** the fields to include for returned resources of type subscriptionPricePoints */
        "fields[subscriptionPricePoints]"?: (
          | "customerPrice"
          | "equalizations"
          | "proceeds"
          | "proceedsYear2"
          | "subscription"
          | "territory"
        )[];
        /** the fields to include for returned resources of type territories */
        "fields[territories]"?: "currency"[];
        /**
         * maximum resources per page
         * @max 8000
         */
        limit?: number;
        /** comma-separated list of relationships to include */
        include?: "territory"[];
      },
      params: RequestParams = {},
    ): Promise<SubscriptionPricePointsResponse> =>
      this.request<SubscriptionPricePointsResponse, ErrorResponse>({
        path: `/v1/subscriptions/${id}/pricePoints`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Subscriptions
     * @name SubscriptionsPricesGetToManyRelationship
     * @request GET:/v1/subscriptions/{id}/relationships/prices
     * @secure
     */
    pricesGetToManyRelationship: (
      id: string,
      query?: {
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
      },
      params: RequestParams = {},
    ): Promise<SubscriptionPricesLinkagesResponse> =>
      this.request<SubscriptionPricesLinkagesResponse, ErrorResponse>({
        path: `/v1/subscriptions/${id}/relationships/prices`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Subscriptions
     * @name SubscriptionsPricesDeleteToManyRelationship
     * @request DELETE:/v1/subscriptions/{id}/relationships/prices
     * @secure
     */
    pricesDeleteToManyRelationship: (
      id: string,
      data: SubscriptionPricesLinkagesRequest,
      params: RequestParams = {},
    ): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/subscriptions/${id}/relationships/prices`,
        method: "DELETE",
        body: data,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * No description
     *
     * @tags Subscriptions
     * @name SubscriptionsPricesGetToManyRelated
     * @request GET:/v1/subscriptions/{id}/prices
     * @secure
     */
    pricesGetToManyRelated: (
      id: string,
      query?: {
        /** filter by id(s) of related 'subscriptionPricePoint' */
        "filter[subscriptionPricePoint]"?: string[];
        /** filter by id(s) of related 'territory' */
        "filter[territory]"?: string[];
        /** the fields to include for returned resources of type subscriptionPricePoints */
        "fields[subscriptionPricePoints]"?: (
          | "customerPrice"
          | "equalizations"
          | "proceeds"
          | "proceedsYear2"
          | "subscription"
          | "territory"
        )[];
        /** the fields to include for returned resources of type subscriptionPrices */
        "fields[subscriptionPrices]"?: (
          | "preserveCurrentPrice"
          | "preserved"
          | "startDate"
          | "subscription"
          | "subscriptionPricePoint"
          | "territory"
        )[];
        /** the fields to include for returned resources of type territories */
        "fields[territories]"?: "currency"[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /** comma-separated list of relationships to include */
        include?: ("subscriptionPricePoint" | "territory")[];
      },
      params: RequestParams = {},
    ): Promise<SubscriptionPricesResponse> =>
      this.request<SubscriptionPricesResponse, ErrorResponse>({
        path: `/v1/subscriptions/${id}/prices`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Subscriptions
     * @name SubscriptionsPromotedPurchaseGetToOneRelated
     * @request GET:/v1/subscriptions/{id}/promotedPurchase
     * @secure
     */
    promotedPurchaseGetToOneRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type promotedPurchases */
        "fields[promotedPurchases]"?: (
          | "app"
          | "enabled"
          | "inAppPurchaseV2"
          | "promotionImages"
          | "state"
          | "subscription"
          | "visibleForAllUsers"
        )[];
        /** the fields to include for returned resources of type subscriptions */
        "fields[subscriptions]"?: (
          | "appStoreReviewScreenshot"
          | "familySharable"
          | "group"
          | "groupLevel"
          | "introductoryOffers"
          | "name"
          | "offerCodes"
          | "pricePoints"
          | "prices"
          | "productId"
          | "promotedPurchase"
          | "promotionalOffers"
          | "reviewNote"
          | "state"
          | "subscriptionAvailability"
          | "subscriptionLocalizations"
          | "subscriptionPeriod"
        )[];
        /** the fields to include for returned resources of type inAppPurchases */
        "fields[inAppPurchases]"?: (
          | "app"
          | "appStoreReviewScreenshot"
          | "content"
          | "contentHosting"
          | "familySharable"
          | "iapPriceSchedule"
          | "inAppPurchaseAvailability"
          | "inAppPurchaseLocalizations"
          | "inAppPurchaseType"
          | "name"
          | "pricePoints"
          | "productId"
          | "promotedPurchase"
          | "reviewNote"
          | "state"
        )[];
        /** the fields to include for returned resources of type promotedPurchaseImages */
        "fields[promotedPurchaseImages]"?: (
          | "assetToken"
          | "assetType"
          | "fileName"
          | "fileSize"
          | "imageAsset"
          | "promotedPurchase"
          | "sourceFileChecksum"
          | "state"
          | "uploadOperations"
          | "uploaded"
        )[];
        /**
         * maximum number of related promotionImages returned (when they are included)
         * @max 50
         */
        "limit[promotionImages]"?: number;
        /** comma-separated list of relationships to include */
        include?: ("inAppPurchaseV2" | "promotionImages" | "subscription")[];
      },
      params: RequestParams = {},
    ): Promise<PromotedPurchaseResponse> =>
      this.request<PromotedPurchaseResponse, ErrorResponse>({
        path: `/v1/subscriptions/${id}/promotedPurchase`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Subscriptions
     * @name SubscriptionsPromotionalOffersGetToManyRelated
     * @request GET:/v1/subscriptions/{id}/promotionalOffers
     * @secure
     */
    promotionalOffersGetToManyRelated: (
      id: string,
      query?: {
        /** filter by territory */
        "filter[territory]"?: string[];
        /** the fields to include for returned resources of type subscriptionPromotionalOffers */
        "fields[subscriptionPromotionalOffers]"?: (
          | "duration"
          | "name"
          | "numberOfPeriods"
          | "offerCode"
          | "offerMode"
          | "prices"
          | "subscription"
        )[];
        /** the fields to include for returned resources of type subscriptions */
        "fields[subscriptions]"?: (
          | "appStoreReviewScreenshot"
          | "familySharable"
          | "group"
          | "groupLevel"
          | "introductoryOffers"
          | "name"
          | "offerCodes"
          | "pricePoints"
          | "prices"
          | "productId"
          | "promotedPurchase"
          | "promotionalOffers"
          | "reviewNote"
          | "state"
          | "subscriptionAvailability"
          | "subscriptionLocalizations"
          | "subscriptionPeriod"
        )[];
        /** the fields to include for returned resources of type subscriptionPromotionalOfferPrices */
        "fields[subscriptionPromotionalOfferPrices]"?: ("subscriptionPricePoint" | "territory")[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /**
         * maximum number of related prices returned (when they are included)
         * @max 50
         */
        "limit[prices]"?: number;
        /** comma-separated list of relationships to include */
        include?: ("prices" | "subscription")[];
      },
      params: RequestParams = {},
    ): Promise<SubscriptionPromotionalOffersResponse> =>
      this.request<SubscriptionPromotionalOffersResponse, ErrorResponse>({
        path: `/v1/subscriptions/${id}/promotionalOffers`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Subscriptions
     * @name SubscriptionsSubscriptionAvailabilityGetToOneRelated
     * @request GET:/v1/subscriptions/{id}/subscriptionAvailability
     * @secure
     */
    subscriptionAvailabilityGetToOneRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type subscriptionAvailabilities */
        "fields[subscriptionAvailabilities]"?: (
          | "availableInNewTerritories"
          | "availableTerritories"
          | "subscription"
        )[];
        /** the fields to include for returned resources of type subscriptions */
        "fields[subscriptions]"?: (
          | "appStoreReviewScreenshot"
          | "familySharable"
          | "group"
          | "groupLevel"
          | "introductoryOffers"
          | "name"
          | "offerCodes"
          | "pricePoints"
          | "prices"
          | "productId"
          | "promotedPurchase"
          | "promotionalOffers"
          | "reviewNote"
          | "state"
          | "subscriptionAvailability"
          | "subscriptionLocalizations"
          | "subscriptionPeriod"
        )[];
        /** the fields to include for returned resources of type territories */
        "fields[territories]"?: "currency"[];
        /**
         * maximum number of related availableTerritories returned (when they are included)
         * @max 50
         */
        "limit[availableTerritories]"?: number;
        /** comma-separated list of relationships to include */
        include?: ("availableTerritories" | "subscription")[];
      },
      params: RequestParams = {},
    ): Promise<SubscriptionAvailabilityResponse> =>
      this.request<SubscriptionAvailabilityResponse, ErrorResponse>({
        path: `/v1/subscriptions/${id}/subscriptionAvailability`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Subscriptions
     * @name SubscriptionsSubscriptionLocalizationsGetToManyRelated
     * @request GET:/v1/subscriptions/{id}/subscriptionLocalizations
     * @secure
     */
    subscriptionLocalizationsGetToManyRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type subscriptions */
        "fields[subscriptions]"?: (
          | "appStoreReviewScreenshot"
          | "familySharable"
          | "group"
          | "groupLevel"
          | "introductoryOffers"
          | "name"
          | "offerCodes"
          | "pricePoints"
          | "prices"
          | "productId"
          | "promotedPurchase"
          | "promotionalOffers"
          | "reviewNote"
          | "state"
          | "subscriptionAvailability"
          | "subscriptionLocalizations"
          | "subscriptionPeriod"
        )[];
        /** the fields to include for returned resources of type subscriptionLocalizations */
        "fields[subscriptionLocalizations]"?: ("description" | "locale" | "name" | "state" | "subscription")[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /** comma-separated list of relationships to include */
        include?: "subscription"[];
      },
      params: RequestParams = {},
    ): Promise<SubscriptionLocalizationsResponse> =>
      this.request<SubscriptionLocalizationsResponse, ErrorResponse>({
        path: `/v1/subscriptions/${id}/subscriptionLocalizations`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  territories = {
    /**
     * No description
     *
     * @tags Territories
     * @name TerritoriesGetCollection
     * @request GET:/v1/territories
     * @secure
     */
    getCollection: (
      query?: {
        /** the fields to include for returned resources of type territories */
        "fields[territories]"?: "currency"[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
      },
      params: RequestParams = {},
    ): Promise<TerritoriesResponse> =>
      this.request<TerritoriesResponse, ErrorResponse>({
        path: `/v1/territories`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  territoryAvailabilities = {
    /**
     * No description
     *
     * @tags TerritoryAvailabilities
     * @name TerritoryAvailabilitiesUpdateInstance
     * @request PATCH:/v1/territoryAvailabilities/{id}
     * @secure
     */
    updateInstance: (
      id: string,
      data: TerritoryAvailabilityUpdateRequest,
      params: RequestParams = {},
    ): Promise<TerritoryAvailabilityResponse> =>
      this.request<TerritoryAvailabilityResponse, ErrorResponse>({
        path: `/v1/territoryAvailabilities/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),
  };
  userInvitations = {
    /**
     * No description
     *
     * @tags UserInvitations
     * @name UserInvitationsGetCollection
     * @request GET:/v1/userInvitations
     * @secure
     */
    getCollection: (
      query?: {
        /** filter by attribute 'email' */
        "filter[email]"?: string[];
        /** filter by attribute 'roles' */
        "filter[roles]"?: (
          | "ADMIN"
          | "FINANCE"
          | "ACCOUNT_HOLDER"
          | "SALES"
          | "MARKETING"
          | "APP_MANAGER"
          | "DEVELOPER"
          | "ACCESS_TO_REPORTS"
          | "CUSTOMER_SUPPORT"
          | "IMAGE_MANAGER"
          | "CREATE_APPS"
          | "CLOUD_MANAGED_DEVELOPER_ID"
          | "CLOUD_MANAGED_APP_DISTRIBUTION"
          | "GENERATE_INDIVIDUAL_KEYS"
        )[];
        /** filter by id(s) of related 'visibleApps' */
        "filter[visibleApps]"?: string[];
        /** comma-separated list of sort expressions; resources will be sorted as specified */
        sort?: ("email" | "-email" | "lastName" | "-lastName")[];
        /** the fields to include for returned resources of type userInvitations */
        "fields[userInvitations]"?: (
          | "allAppsVisible"
          | "email"
          | "expirationDate"
          | "firstName"
          | "lastName"
          | "provisioningAllowed"
          | "roles"
          | "visibleApps"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /** comma-separated list of relationships to include */
        include?: "visibleApps"[];
        /** the fields to include for returned resources of type apps */
        "fields[apps]"?: (
          | "alternativeDistributionKey"
          | "analyticsReportRequests"
          | "appAvailability"
          | "appClips"
          | "appCustomProductPages"
          | "appEncryptionDeclarations"
          | "appEvents"
          | "appInfos"
          | "appPricePoints"
          | "appPriceSchedule"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersions"
          | "availableInNewTerritories"
          | "availableTerritories"
          | "betaAppLocalizations"
          | "betaAppReviewDetail"
          | "betaGroups"
          | "betaLicenseAgreement"
          | "betaTesters"
          | "builds"
          | "bundleId"
          | "ciProduct"
          | "contentRightsDeclaration"
          | "customerReviews"
          | "endUserLicenseAgreement"
          | "gameCenterDetail"
          | "gameCenterEnabledVersions"
          | "inAppPurchases"
          | "inAppPurchasesV2"
          | "isOrEverWasMadeForKids"
          | "marketplaceSearchDetail"
          | "name"
          | "perfPowerMetrics"
          | "preOrder"
          | "preReleaseVersions"
          | "pricePoints"
          | "prices"
          | "primaryLocale"
          | "promotedPurchases"
          | "reviewSubmissions"
          | "sku"
          | "subscriptionGracePeriod"
          | "subscriptionGroups"
          | "subscriptionStatusUrl"
          | "subscriptionStatusUrlForSandbox"
          | "subscriptionStatusUrlVersion"
          | "subscriptionStatusUrlVersionForSandbox"
        )[];
        /**
         * maximum number of related visibleApps returned (when they are included)
         * @max 50
         */
        "limit[visibleApps]"?: number;
      },
      params: RequestParams = {},
    ): Promise<UserInvitationsResponse> =>
      this.request<UserInvitationsResponse, ErrorResponse>({
        path: `/v1/userInvitations`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags UserInvitations
     * @name UserInvitationsCreateInstance
     * @request POST:/v1/userInvitations
     * @secure
     */
    createInstance: (data: UserInvitationCreateRequest, params: RequestParams = {}): Promise<UserInvitationResponse> =>
      this.request<UserInvitationResponse, ErrorResponse>({
        path: `/v1/userInvitations`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags UserInvitations
     * @name UserInvitationsGetInstance
     * @request GET:/v1/userInvitations/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type userInvitations */
        "fields[userInvitations]"?: (
          | "allAppsVisible"
          | "email"
          | "expirationDate"
          | "firstName"
          | "lastName"
          | "provisioningAllowed"
          | "roles"
          | "visibleApps"
        )[];
        /** comma-separated list of relationships to include */
        include?: "visibleApps"[];
        /** the fields to include for returned resources of type apps */
        "fields[apps]"?: (
          | "alternativeDistributionKey"
          | "analyticsReportRequests"
          | "appAvailability"
          | "appClips"
          | "appCustomProductPages"
          | "appEncryptionDeclarations"
          | "appEvents"
          | "appInfos"
          | "appPricePoints"
          | "appPriceSchedule"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersions"
          | "availableInNewTerritories"
          | "availableTerritories"
          | "betaAppLocalizations"
          | "betaAppReviewDetail"
          | "betaGroups"
          | "betaLicenseAgreement"
          | "betaTesters"
          | "builds"
          | "bundleId"
          | "ciProduct"
          | "contentRightsDeclaration"
          | "customerReviews"
          | "endUserLicenseAgreement"
          | "gameCenterDetail"
          | "gameCenterEnabledVersions"
          | "inAppPurchases"
          | "inAppPurchasesV2"
          | "isOrEverWasMadeForKids"
          | "marketplaceSearchDetail"
          | "name"
          | "perfPowerMetrics"
          | "preOrder"
          | "preReleaseVersions"
          | "pricePoints"
          | "prices"
          | "primaryLocale"
          | "promotedPurchases"
          | "reviewSubmissions"
          | "sku"
          | "subscriptionGracePeriod"
          | "subscriptionGroups"
          | "subscriptionStatusUrl"
          | "subscriptionStatusUrlForSandbox"
          | "subscriptionStatusUrlVersion"
          | "subscriptionStatusUrlVersionForSandbox"
        )[];
        /**
         * maximum number of related visibleApps returned (when they are included)
         * @max 50
         */
        "limit[visibleApps]"?: number;
      },
      params: RequestParams = {},
    ): Promise<UserInvitationResponse> =>
      this.request<UserInvitationResponse, ErrorResponse>({
        path: `/v1/userInvitations/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags UserInvitations
     * @name UserInvitationsDeleteInstance
     * @request DELETE:/v1/userInvitations/{id}
     * @secure
     */
    deleteInstance: (id: string, params: RequestParams = {}): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/userInvitations/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),

    /**
     * No description
     *
     * @tags UserInvitations
     * @name UserInvitationsVisibleAppsGetToManyRelated
     * @request GET:/v1/userInvitations/{id}/visibleApps
     * @secure
     */
    visibleAppsGetToManyRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type apps */
        "fields[apps]"?: (
          | "alternativeDistributionKey"
          | "analyticsReportRequests"
          | "appAvailability"
          | "appClips"
          | "appCustomProductPages"
          | "appEncryptionDeclarations"
          | "appEvents"
          | "appInfos"
          | "appPricePoints"
          | "appPriceSchedule"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersions"
          | "availableInNewTerritories"
          | "availableTerritories"
          | "betaAppLocalizations"
          | "betaAppReviewDetail"
          | "betaGroups"
          | "betaLicenseAgreement"
          | "betaTesters"
          | "builds"
          | "bundleId"
          | "ciProduct"
          | "contentRightsDeclaration"
          | "customerReviews"
          | "endUserLicenseAgreement"
          | "gameCenterDetail"
          | "gameCenterEnabledVersions"
          | "inAppPurchases"
          | "inAppPurchasesV2"
          | "isOrEverWasMadeForKids"
          | "marketplaceSearchDetail"
          | "name"
          | "perfPowerMetrics"
          | "preOrder"
          | "preReleaseVersions"
          | "pricePoints"
          | "prices"
          | "primaryLocale"
          | "promotedPurchases"
          | "reviewSubmissions"
          | "sku"
          | "subscriptionGracePeriod"
          | "subscriptionGroups"
          | "subscriptionStatusUrl"
          | "subscriptionStatusUrlForSandbox"
          | "subscriptionStatusUrlVersion"
          | "subscriptionStatusUrlVersionForSandbox"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
      },
      params: RequestParams = {},
    ): Promise<AppsWithoutIncludesResponse> =>
      this.request<AppsWithoutIncludesResponse, ErrorResponse>({
        path: `/v1/userInvitations/${id}/visibleApps`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  users = {
    /**
     * No description
     *
     * @tags Users
     * @name UsersGetCollection
     * @request GET:/v1/users
     * @secure
     */
    getCollection: (
      query?: {
        /** filter by attribute 'roles' */
        "filter[roles]"?: (
          | "ADMIN"
          | "FINANCE"
          | "ACCOUNT_HOLDER"
          | "SALES"
          | "MARKETING"
          | "APP_MANAGER"
          | "DEVELOPER"
          | "ACCESS_TO_REPORTS"
          | "CUSTOMER_SUPPORT"
          | "IMAGE_MANAGER"
          | "CREATE_APPS"
          | "CLOUD_MANAGED_DEVELOPER_ID"
          | "CLOUD_MANAGED_APP_DISTRIBUTION"
          | "GENERATE_INDIVIDUAL_KEYS"
        )[];
        /** filter by attribute 'username' */
        "filter[username]"?: string[];
        /** filter by id(s) of related 'visibleApps' */
        "filter[visibleApps]"?: string[];
        /** comma-separated list of sort expressions; resources will be sorted as specified */
        sort?: ("lastName" | "-lastName" | "username" | "-username")[];
        /** the fields to include for returned resources of type users */
        "fields[users]"?: (
          | "allAppsVisible"
          | "firstName"
          | "lastName"
          | "provisioningAllowed"
          | "roles"
          | "username"
          | "visibleApps"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /** comma-separated list of relationships to include */
        include?: "visibleApps"[];
        /** the fields to include for returned resources of type apps */
        "fields[apps]"?: (
          | "alternativeDistributionKey"
          | "analyticsReportRequests"
          | "appAvailability"
          | "appClips"
          | "appCustomProductPages"
          | "appEncryptionDeclarations"
          | "appEvents"
          | "appInfos"
          | "appPricePoints"
          | "appPriceSchedule"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersions"
          | "availableInNewTerritories"
          | "availableTerritories"
          | "betaAppLocalizations"
          | "betaAppReviewDetail"
          | "betaGroups"
          | "betaLicenseAgreement"
          | "betaTesters"
          | "builds"
          | "bundleId"
          | "ciProduct"
          | "contentRightsDeclaration"
          | "customerReviews"
          | "endUserLicenseAgreement"
          | "gameCenterDetail"
          | "gameCenterEnabledVersions"
          | "inAppPurchases"
          | "inAppPurchasesV2"
          | "isOrEverWasMadeForKids"
          | "marketplaceSearchDetail"
          | "name"
          | "perfPowerMetrics"
          | "preOrder"
          | "preReleaseVersions"
          | "pricePoints"
          | "prices"
          | "primaryLocale"
          | "promotedPurchases"
          | "reviewSubmissions"
          | "sku"
          | "subscriptionGracePeriod"
          | "subscriptionGroups"
          | "subscriptionStatusUrl"
          | "subscriptionStatusUrlForSandbox"
          | "subscriptionStatusUrlVersion"
          | "subscriptionStatusUrlVersionForSandbox"
        )[];
        /**
         * maximum number of related visibleApps returned (when they are included)
         * @max 50
         */
        "limit[visibleApps]"?: number;
      },
      params: RequestParams = {},
    ): Promise<UsersResponse> =>
      this.request<UsersResponse, ErrorResponse>({
        path: `/v1/users`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Users
     * @name UsersGetInstance
     * @request GET:/v1/users/{id}
     * @secure
     */
    getInstance: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type users */
        "fields[users]"?: (
          | "allAppsVisible"
          | "firstName"
          | "lastName"
          | "provisioningAllowed"
          | "roles"
          | "username"
          | "visibleApps"
        )[];
        /** comma-separated list of relationships to include */
        include?: "visibleApps"[];
        /** the fields to include for returned resources of type apps */
        "fields[apps]"?: (
          | "alternativeDistributionKey"
          | "analyticsReportRequests"
          | "appAvailability"
          | "appClips"
          | "appCustomProductPages"
          | "appEncryptionDeclarations"
          | "appEvents"
          | "appInfos"
          | "appPricePoints"
          | "appPriceSchedule"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersions"
          | "availableInNewTerritories"
          | "availableTerritories"
          | "betaAppLocalizations"
          | "betaAppReviewDetail"
          | "betaGroups"
          | "betaLicenseAgreement"
          | "betaTesters"
          | "builds"
          | "bundleId"
          | "ciProduct"
          | "contentRightsDeclaration"
          | "customerReviews"
          | "endUserLicenseAgreement"
          | "gameCenterDetail"
          | "gameCenterEnabledVersions"
          | "inAppPurchases"
          | "inAppPurchasesV2"
          | "isOrEverWasMadeForKids"
          | "marketplaceSearchDetail"
          | "name"
          | "perfPowerMetrics"
          | "preOrder"
          | "preReleaseVersions"
          | "pricePoints"
          | "prices"
          | "primaryLocale"
          | "promotedPurchases"
          | "reviewSubmissions"
          | "sku"
          | "subscriptionGracePeriod"
          | "subscriptionGroups"
          | "subscriptionStatusUrl"
          | "subscriptionStatusUrlForSandbox"
          | "subscriptionStatusUrlVersion"
          | "subscriptionStatusUrlVersionForSandbox"
        )[];
        /**
         * maximum number of related visibleApps returned (when they are included)
         * @max 50
         */
        "limit[visibleApps]"?: number;
      },
      params: RequestParams = {},
    ): Promise<UserResponse> =>
      this.request<UserResponse, ErrorResponse>({
        path: `/v1/users/${id}`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Users
     * @name UsersUpdateInstance
     * @request PATCH:/v1/users/{id}
     * @secure
     */
    updateInstance: (id: string, data: UserUpdateRequest, params: RequestParams = {}): Promise<UserResponse> =>
      this.request<UserResponse, ErrorResponse>({
        path: `/v1/users/${id}`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Users
     * @name UsersDeleteInstance
     * @request DELETE:/v1/users/{id}
     * @secure
     */
    deleteInstance: (id: string, params: RequestParams = {}): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/users/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),

    /**
     * No description
     *
     * @tags Users
     * @name UsersVisibleAppsGetToManyRelationship
     * @request GET:/v1/users/{id}/relationships/visibleApps
     * @secure
     */
    visibleAppsGetToManyRelationship: (
      id: string,
      query?: {
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
      },
      params: RequestParams = {},
    ): Promise<UserVisibleAppsLinkagesResponse> =>
      this.request<UserVisibleAppsLinkagesResponse, ErrorResponse>({
        path: `/v1/users/${id}/relationships/visibleApps`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Users
     * @name UsersVisibleAppsCreateToManyRelationship
     * @request POST:/v1/users/{id}/relationships/visibleApps
     * @secure
     */
    visibleAppsCreateToManyRelationship: (
      id: string,
      data: UserVisibleAppsLinkagesRequest,
      params: RequestParams = {},
    ): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/users/${id}/relationships/visibleApps`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * No description
     *
     * @tags Users
     * @name UsersVisibleAppsReplaceToManyRelationship
     * @request PATCH:/v1/users/{id}/relationships/visibleApps
     * @secure
     */
    visibleAppsReplaceToManyRelationship: (
      id: string,
      data: UserVisibleAppsLinkagesRequest,
      params: RequestParams = {},
    ): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/users/${id}/relationships/visibleApps`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * No description
     *
     * @tags Users
     * @name UsersVisibleAppsDeleteToManyRelationship
     * @request DELETE:/v1/users/{id}/relationships/visibleApps
     * @secure
     */
    visibleAppsDeleteToManyRelationship: (
      id: string,
      data: UserVisibleAppsLinkagesRequest,
      params: RequestParams = {},
    ): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/users/${id}/relationships/visibleApps`,
        method: "DELETE",
        body: data,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * No description
     *
     * @tags Users
     * @name UsersVisibleAppsGetToManyRelated
     * @request GET:/v1/users/{id}/visibleApps
     * @secure
     */
    visibleAppsGetToManyRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type apps */
        "fields[apps]"?: (
          | "alternativeDistributionKey"
          | "analyticsReportRequests"
          | "appAvailability"
          | "appClips"
          | "appCustomProductPages"
          | "appEncryptionDeclarations"
          | "appEvents"
          | "appInfos"
          | "appPricePoints"
          | "appPriceSchedule"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersions"
          | "availableInNewTerritories"
          | "availableTerritories"
          | "betaAppLocalizations"
          | "betaAppReviewDetail"
          | "betaGroups"
          | "betaLicenseAgreement"
          | "betaTesters"
          | "builds"
          | "bundleId"
          | "ciProduct"
          | "contentRightsDeclaration"
          | "customerReviews"
          | "endUserLicenseAgreement"
          | "gameCenterDetail"
          | "gameCenterEnabledVersions"
          | "inAppPurchases"
          | "inAppPurchasesV2"
          | "isOrEverWasMadeForKids"
          | "marketplaceSearchDetail"
          | "name"
          | "perfPowerMetrics"
          | "preOrder"
          | "preReleaseVersions"
          | "pricePoints"
          | "prices"
          | "primaryLocale"
          | "promotedPurchases"
          | "reviewSubmissions"
          | "sku"
          | "subscriptionGracePeriod"
          | "subscriptionGroups"
          | "subscriptionStatusUrl"
          | "subscriptionStatusUrlForSandbox"
          | "subscriptionStatusUrlVersion"
          | "subscriptionStatusUrlVersionForSandbox"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
      },
      params: RequestParams = {},
    ): Promise<AppsWithoutIncludesResponse> =>
      this.request<AppsWithoutIncludesResponse, ErrorResponse>({
        path: `/v1/users/${id}/visibleApps`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  buildBundles = {
    /**
     * No description
     *
     * @tags BuildBundles
     * @name BuildBundlesAppClipDomainCacheStatusGetToOneRelated
     * @request GET:/v1/buildBundles/{id}/appClipDomainCacheStatus
     * @secure
     */
    appClipDomainCacheStatusGetToOneRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type appClipDomainStatuses */
        "fields[appClipDomainStatuses]"?: ("domains" | "lastUpdatedDate")[];
      },
      params: RequestParams = {},
    ): Promise<AppClipDomainStatusResponse> =>
      this.request<AppClipDomainStatusResponse, ErrorResponse>({
        path: `/v1/buildBundles/${id}/appClipDomainCacheStatus`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags BuildBundles
     * @name BuildBundlesAppClipDomainDebugStatusGetToOneRelated
     * @request GET:/v1/buildBundles/{id}/appClipDomainDebugStatus
     * @secure
     */
    appClipDomainDebugStatusGetToOneRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type appClipDomainStatuses */
        "fields[appClipDomainStatuses]"?: ("domains" | "lastUpdatedDate")[];
      },
      params: RequestParams = {},
    ): Promise<AppClipDomainStatusResponse> =>
      this.request<AppClipDomainStatusResponse, ErrorResponse>({
        path: `/v1/buildBundles/${id}/appClipDomainDebugStatus`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags BuildBundles
     * @name BuildBundlesBetaAppClipInvocationsGetToManyRelated
     * @request GET:/v1/buildBundles/{id}/betaAppClipInvocations
     * @secure
     */
    betaAppClipInvocationsGetToManyRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type betaAppClipInvocations */
        "fields[betaAppClipInvocations]"?: ("betaAppClipInvocationLocalizations" | "buildBundle" | "url")[];
        /** the fields to include for returned resources of type betaAppClipInvocationLocalizations */
        "fields[betaAppClipInvocationLocalizations]"?: ("betaAppClipInvocation" | "locale" | "title")[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /**
         * maximum number of related betaAppClipInvocationLocalizations returned (when they are included)
         * @max 50
         */
        "limit[betaAppClipInvocationLocalizations]"?: number;
        /** comma-separated list of relationships to include */
        include?: "betaAppClipInvocationLocalizations"[];
      },
      params: RequestParams = {},
    ): Promise<BetaAppClipInvocationsResponse> =>
      this.request<BetaAppClipInvocationsResponse, ErrorResponse>({
        path: `/v1/buildBundles/${id}/betaAppClipInvocations`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags BuildBundles
     * @name BuildBundlesBuildBundleFileSizesGetToManyRelated
     * @request GET:/v1/buildBundles/{id}/buildBundleFileSizes
     * @secure
     */
    buildBundleFileSizesGetToManyRelated: (
      id: string,
      query?: {
        /** the fields to include for returned resources of type buildBundleFileSizes */
        "fields[buildBundleFileSizes]"?: ("deviceModel" | "downloadBytes" | "installBytes" | "osVersion")[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
      },
      params: RequestParams = {},
    ): Promise<BuildBundleFileSizesResponse> =>
      this.request<BuildBundleFileSizesResponse, ErrorResponse>({
        path: `/v1/buildBundles/${id}/buildBundleFileSizes`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  diagnosticSignatures = {
    /**
     * No description
     *
     * @tags DiagnosticSignatures
     * @name DiagnosticSignaturesLogsGetToManyRelated
     * @request GET:/v1/diagnosticSignatures/{id}/logs
     * @secure
     */
    logsGetToManyRelated: (
      id: string,
      query?: {
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
      },
      params: RequestParams = {},
    ): Promise<DiagnosticLogs> =>
      this.request<DiagnosticLogs, ErrorResponse>({
        path: `/v1/diagnosticSignatures/${id}/logs`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  gameCenterEnabledVersions = {
    /**
     * No description
     *
     * @tags GameCenterEnabledVersions
     * @name GameCenterEnabledVersionsCompatibleVersionsGetToManyRelationship
     * @request GET:/v1/gameCenterEnabledVersions/{id}/relationships/compatibleVersions
     * @deprecated
     * @secure
     */
    compatibleVersionsGetToManyRelationship: (
      id: string,
      query?: {
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
      },
      params: RequestParams = {},
    ): Promise<GameCenterEnabledVersionCompatibleVersionsLinkagesResponse> =>
      this.request<GameCenterEnabledVersionCompatibleVersionsLinkagesResponse, ErrorResponse>({
        path: `/v1/gameCenterEnabledVersions/${id}/relationships/compatibleVersions`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterEnabledVersions
     * @name GameCenterEnabledVersionsCompatibleVersionsCreateToManyRelationship
     * @request POST:/v1/gameCenterEnabledVersions/{id}/relationships/compatibleVersions
     * @deprecated
     * @secure
     */
    compatibleVersionsCreateToManyRelationship: (
      id: string,
      data: GameCenterEnabledVersionCompatibleVersionsLinkagesRequest,
      params: RequestParams = {},
    ): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/gameCenterEnabledVersions/${id}/relationships/compatibleVersions`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterEnabledVersions
     * @name GameCenterEnabledVersionsCompatibleVersionsReplaceToManyRelationship
     * @request PATCH:/v1/gameCenterEnabledVersions/{id}/relationships/compatibleVersions
     * @deprecated
     * @secure
     */
    compatibleVersionsReplaceToManyRelationship: (
      id: string,
      data: GameCenterEnabledVersionCompatibleVersionsLinkagesRequest,
      params: RequestParams = {},
    ): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/gameCenterEnabledVersions/${id}/relationships/compatibleVersions`,
        method: "PATCH",
        body: data,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterEnabledVersions
     * @name GameCenterEnabledVersionsCompatibleVersionsDeleteToManyRelationship
     * @request DELETE:/v1/gameCenterEnabledVersions/{id}/relationships/compatibleVersions
     * @deprecated
     * @secure
     */
    compatibleVersionsDeleteToManyRelationship: (
      id: string,
      data: GameCenterEnabledVersionCompatibleVersionsLinkagesRequest,
      params: RequestParams = {},
    ): Promise<void> =>
      this.request<void, ErrorResponse>({
        path: `/v1/gameCenterEnabledVersions/${id}/relationships/compatibleVersions`,
        method: "DELETE",
        body: data,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * No description
     *
     * @tags GameCenterEnabledVersions
     * @name GameCenterEnabledVersionsCompatibleVersionsGetToManyRelated
     * @request GET:/v1/gameCenterEnabledVersions/{id}/compatibleVersions
     * @deprecated
     * @secure
     */
    compatibleVersionsGetToManyRelated: (
      id: string,
      query?: {
        /** filter by attribute 'platform' */
        "filter[platform]"?: ("IOS" | "MAC_OS" | "TV_OS" | "VISION_OS")[];
        /** filter by attribute 'versionString' */
        "filter[versionString]"?: string[];
        /** filter by id(s) of related 'app' */
        "filter[app]"?: string[];
        /** filter by id(s) */
        "filter[id]"?: string[];
        /** comma-separated list of sort expressions; resources will be sorted as specified */
        sort?: ("versionString" | "-versionString")[];
        /** the fields to include for returned resources of type gameCenterEnabledVersions */
        "fields[gameCenterEnabledVersions]"?: (
          | "app"
          | "compatibleVersions"
          | "iconAsset"
          | "platform"
          | "versionString"
        )[];
        /** the fields to include for returned resources of type apps */
        "fields[apps]"?: (
          | "alternativeDistributionKey"
          | "analyticsReportRequests"
          | "appAvailability"
          | "appClips"
          | "appCustomProductPages"
          | "appEncryptionDeclarations"
          | "appEvents"
          | "appInfos"
          | "appPricePoints"
          | "appPriceSchedule"
          | "appStoreVersionExperimentsV2"
          | "appStoreVersions"
          | "availableInNewTerritories"
          | "availableTerritories"
          | "betaAppLocalizations"
          | "betaAppReviewDetail"
          | "betaGroups"
          | "betaLicenseAgreement"
          | "betaTesters"
          | "builds"
          | "bundleId"
          | "ciProduct"
          | "contentRightsDeclaration"
          | "customerReviews"
          | "endUserLicenseAgreement"
          | "gameCenterDetail"
          | "gameCenterEnabledVersions"
          | "inAppPurchases"
          | "inAppPurchasesV2"
          | "isOrEverWasMadeForKids"
          | "marketplaceSearchDetail"
          | "name"
          | "perfPowerMetrics"
          | "preOrder"
          | "preReleaseVersions"
          | "pricePoints"
          | "prices"
          | "primaryLocale"
          | "promotedPurchases"
          | "reviewSubmissions"
          | "sku"
          | "subscriptionGracePeriod"
          | "subscriptionGroups"
          | "subscriptionStatusUrl"
          | "subscriptionStatusUrlForSandbox"
          | "subscriptionStatusUrlVersion"
          | "subscriptionStatusUrlVersionForSandbox"
        )[];
        /**
         * maximum resources per page
         * @max 200
         */
        limit?: number;
        /**
         * maximum number of related compatibleVersions returned (when they are included)
         * @deprecated
         * @max 50
         */
        "limit[compatibleVersions]"?: number;
        /** comma-separated list of relationships to include */
        include?: ("app" | "compatibleVersions")[];
      },
      params: RequestParams = {},
    ): Promise<GameCenterEnabledVersionsResponse> =>
      this.request<GameCenterEnabledVersionsResponse, ErrorResponse>({
        path: `/v1/gameCenterEnabledVersions/${id}/compatibleVersions`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),
  };
}
