import { ResponseContext, RequestContext, HttpFile, HttpInfo } from '../http/http.ts';
import { Configuration} from '../configuration.ts'
import { Observable, of, from } from '../rxjsStub.ts';
import {mergeMap, map} from  '../rxjsStub.ts';
import { Actor } from '../models/Actor.ts';
import { ActorAttributes } from '../models/ActorAttributes.ts';
import { ActorResponse } from '../models/ActorResponse.ts';
import { ActorsResponse } from '../models/ActorsResponse.ts';
import { AgeRatingDeclaration } from '../models/AgeRatingDeclaration.ts';
import { AgeRatingDeclarationAttributes } from '../models/AgeRatingDeclarationAttributes.ts';
import { AgeRatingDeclarationResponse } from '../models/AgeRatingDeclarationResponse.ts';
import { AgeRatingDeclarationUpdateRequest } from '../models/AgeRatingDeclarationUpdateRequest.ts';
import { AgeRatingDeclarationUpdateRequestData } from '../models/AgeRatingDeclarationUpdateRequestData.ts';
import { AgeRatingDeclarationWithoutIncludesResponse } from '../models/AgeRatingDeclarationWithoutIncludesResponse.ts';
import { AlternativeDistributionDomain } from '../models/AlternativeDistributionDomain.ts';
import { AlternativeDistributionDomainAttributes } from '../models/AlternativeDistributionDomainAttributes.ts';
import { AlternativeDistributionDomainCreateRequest } from '../models/AlternativeDistributionDomainCreateRequest.ts';
import { AlternativeDistributionDomainCreateRequestData } from '../models/AlternativeDistributionDomainCreateRequestData.ts';
import { AlternativeDistributionDomainCreateRequestDataAttributes } from '../models/AlternativeDistributionDomainCreateRequestDataAttributes.ts';
import { AlternativeDistributionDomainResponse } from '../models/AlternativeDistributionDomainResponse.ts';
import { AlternativeDistributionDomainsResponse } from '../models/AlternativeDistributionDomainsResponse.ts';
import { AlternativeDistributionKey } from '../models/AlternativeDistributionKey.ts';
import { AlternativeDistributionKeyAttributes } from '../models/AlternativeDistributionKeyAttributes.ts';
import { AlternativeDistributionKeyCreateRequest } from '../models/AlternativeDistributionKeyCreateRequest.ts';
import { AlternativeDistributionKeyCreateRequestData } from '../models/AlternativeDistributionKeyCreateRequestData.ts';
import { AlternativeDistributionKeyCreateRequestDataAttributes } from '../models/AlternativeDistributionKeyCreateRequestDataAttributes.ts';
import { AlternativeDistributionKeyCreateRequestDataRelationships } from '../models/AlternativeDistributionKeyCreateRequestDataRelationships.ts';
import { AlternativeDistributionKeyCreateRequestDataRelationshipsApp } from '../models/AlternativeDistributionKeyCreateRequestDataRelationshipsApp.ts';
import { AlternativeDistributionKeyCreateRequestDataRelationshipsAppData } from '../models/AlternativeDistributionKeyCreateRequestDataRelationshipsAppData.ts';
import { AlternativeDistributionKeyResponse } from '../models/AlternativeDistributionKeyResponse.ts';
import { AlternativeDistributionPackage } from '../models/AlternativeDistributionPackage.ts';
import { AlternativeDistributionPackageCreateRequest } from '../models/AlternativeDistributionPackageCreateRequest.ts';
import { AlternativeDistributionPackageCreateRequestData } from '../models/AlternativeDistributionPackageCreateRequestData.ts';
import { AlternativeDistributionPackageCreateRequestDataRelationships } from '../models/AlternativeDistributionPackageCreateRequestDataRelationships.ts';
import { AlternativeDistributionPackageCreateRequestDataRelationshipsAppStoreVersion } from '../models/AlternativeDistributionPackageCreateRequestDataRelationshipsAppStoreVersion.ts';
import { AlternativeDistributionPackageCreateRequestDataRelationshipsAppStoreVersionData } from '../models/AlternativeDistributionPackageCreateRequestDataRelationshipsAppStoreVersionData.ts';
import { AlternativeDistributionPackageDelta } from '../models/AlternativeDistributionPackageDelta.ts';
import { AlternativeDistributionPackageDeltaAttributes } from '../models/AlternativeDistributionPackageDeltaAttributes.ts';
import { AlternativeDistributionPackageDeltaResponse } from '../models/AlternativeDistributionPackageDeltaResponse.ts';
import { AlternativeDistributionPackageDeltasResponse } from '../models/AlternativeDistributionPackageDeltasResponse.ts';
import { AlternativeDistributionPackageRelationships } from '../models/AlternativeDistributionPackageRelationships.ts';
import { AlternativeDistributionPackageRelationshipsVersions } from '../models/AlternativeDistributionPackageRelationshipsVersions.ts';
import { AlternativeDistributionPackageRelationshipsVersionsDataInner } from '../models/AlternativeDistributionPackageRelationshipsVersionsDataInner.ts';
import { AlternativeDistributionPackageResponse } from '../models/AlternativeDistributionPackageResponse.ts';
import { AlternativeDistributionPackageVariant } from '../models/AlternativeDistributionPackageVariant.ts';
import { AlternativeDistributionPackageVariantResponse } from '../models/AlternativeDistributionPackageVariantResponse.ts';
import { AlternativeDistributionPackageVariantsResponse } from '../models/AlternativeDistributionPackageVariantsResponse.ts';
import { AlternativeDistributionPackageVersion } from '../models/AlternativeDistributionPackageVersion.ts';
import { AlternativeDistributionPackageVersionAttributes } from '../models/AlternativeDistributionPackageVersionAttributes.ts';
import { AlternativeDistributionPackageVersionRelationships } from '../models/AlternativeDistributionPackageVersionRelationships.ts';
import { AlternativeDistributionPackageVersionRelationshipsAlternativeDistributionPackage } from '../models/AlternativeDistributionPackageVersionRelationshipsAlternativeDistributionPackage.ts';
import { AlternativeDistributionPackageVersionRelationshipsAlternativeDistributionPackageData } from '../models/AlternativeDistributionPackageVersionRelationshipsAlternativeDistributionPackageData.ts';
import { AlternativeDistributionPackageVersionRelationshipsDeltas } from '../models/AlternativeDistributionPackageVersionRelationshipsDeltas.ts';
import { AlternativeDistributionPackageVersionRelationshipsDeltasDataInner } from '../models/AlternativeDistributionPackageVersionRelationshipsDeltasDataInner.ts';
import { AlternativeDistributionPackageVersionRelationshipsVariants } from '../models/AlternativeDistributionPackageVersionRelationshipsVariants.ts';
import { AlternativeDistributionPackageVersionRelationshipsVariantsDataInner } from '../models/AlternativeDistributionPackageVersionRelationshipsVariantsDataInner.ts';
import { AlternativeDistributionPackageVersionRelationshipsVariantsLinks } from '../models/AlternativeDistributionPackageVersionRelationshipsVariantsLinks.ts';
import { AlternativeDistributionPackageVersionResponse } from '../models/AlternativeDistributionPackageVersionResponse.ts';
import { AlternativeDistributionPackageVersionsResponse } from '../models/AlternativeDistributionPackageVersionsResponse.ts';
import { AlternativeDistributionPackageVersionsResponseIncludedInner } from '../models/AlternativeDistributionPackageVersionsResponseIncludedInner.ts';
import { AnalyticsReport } from '../models/AnalyticsReport.ts';
import { AnalyticsReportAttributes } from '../models/AnalyticsReportAttributes.ts';
import { AnalyticsReportInstance } from '../models/AnalyticsReportInstance.ts';
import { AnalyticsReportInstanceAttributes } from '../models/AnalyticsReportInstanceAttributes.ts';
import { AnalyticsReportInstanceResponse } from '../models/AnalyticsReportInstanceResponse.ts';
import { AnalyticsReportInstancesResponse } from '../models/AnalyticsReportInstancesResponse.ts';
import { AnalyticsReportRequest } from '../models/AnalyticsReportRequest.ts';
import { AnalyticsReportRequestAttributes } from '../models/AnalyticsReportRequestAttributes.ts';
import { AnalyticsReportRequestCreateRequest } from '../models/AnalyticsReportRequestCreateRequest.ts';
import { AnalyticsReportRequestCreateRequestData } from '../models/AnalyticsReportRequestCreateRequestData.ts';
import { AnalyticsReportRequestCreateRequestDataAttributes } from '../models/AnalyticsReportRequestCreateRequestDataAttributes.ts';
import { AnalyticsReportRequestRelationships } from '../models/AnalyticsReportRequestRelationships.ts';
import { AnalyticsReportRequestRelationshipsReports } from '../models/AnalyticsReportRequestRelationshipsReports.ts';
import { AnalyticsReportRequestRelationshipsReportsDataInner } from '../models/AnalyticsReportRequestRelationshipsReportsDataInner.ts';
import { AnalyticsReportRequestResponse } from '../models/AnalyticsReportRequestResponse.ts';
import { AnalyticsReportRequestsResponse } from '../models/AnalyticsReportRequestsResponse.ts';
import { AnalyticsReportResponse } from '../models/AnalyticsReportResponse.ts';
import { AnalyticsReportSegment } from '../models/AnalyticsReportSegment.ts';
import { AnalyticsReportSegmentAttributes } from '../models/AnalyticsReportSegmentAttributes.ts';
import { AnalyticsReportSegmentResponse } from '../models/AnalyticsReportSegmentResponse.ts';
import { AnalyticsReportSegmentsResponse } from '../models/AnalyticsReportSegmentsResponse.ts';
import { AnalyticsReportsResponse } from '../models/AnalyticsReportsResponse.ts';
import { App } from '../models/App.ts';
import { AppAttributes } from '../models/AppAttributes.ts';
import { AppAvailability } from '../models/AppAvailability.ts';
import { AppAvailabilityCreateRequest } from '../models/AppAvailabilityCreateRequest.ts';
import { AppAvailabilityCreateRequestData } from '../models/AppAvailabilityCreateRequestData.ts';
import { AppAvailabilityCreateRequestDataRelationships } from '../models/AppAvailabilityCreateRequestDataRelationships.ts';
import { AppAvailabilityCreateRequestDataRelationshipsAvailableTerritories } from '../models/AppAvailabilityCreateRequestDataRelationshipsAvailableTerritories.ts';
import { AppAvailabilityRelationships } from '../models/AppAvailabilityRelationships.ts';
import { AppAvailabilityRelationshipsApp } from '../models/AppAvailabilityRelationshipsApp.ts';
import { AppAvailabilityRelationshipsAvailableTerritories } from '../models/AppAvailabilityRelationshipsAvailableTerritories.ts';
import { AppAvailabilityRelationshipsAvailableTerritoriesDataInner } from '../models/AppAvailabilityRelationshipsAvailableTerritoriesDataInner.ts';
import { AppAvailabilityResponse } from '../models/AppAvailabilityResponse.ts';
import { AppAvailabilityResponseIncludedInner } from '../models/AppAvailabilityResponseIncludedInner.ts';
import { AppAvailabilityV2 } from '../models/AppAvailabilityV2.ts';
import { AppAvailabilityV2Attributes } from '../models/AppAvailabilityV2Attributes.ts';
import { AppAvailabilityV2CreateRequest } from '../models/AppAvailabilityV2CreateRequest.ts';
import { AppAvailabilityV2CreateRequestData } from '../models/AppAvailabilityV2CreateRequestData.ts';
import { AppAvailabilityV2CreateRequestDataAttributes } from '../models/AppAvailabilityV2CreateRequestDataAttributes.ts';
import { AppAvailabilityV2CreateRequestDataRelationships } from '../models/AppAvailabilityV2CreateRequestDataRelationships.ts';
import { AppAvailabilityV2CreateRequestDataRelationshipsTerritoryAvailabilities } from '../models/AppAvailabilityV2CreateRequestDataRelationshipsTerritoryAvailabilities.ts';
import { AppAvailabilityV2Relationships } from '../models/AppAvailabilityV2Relationships.ts';
import { AppAvailabilityV2RelationshipsTerritoryAvailabilities } from '../models/AppAvailabilityV2RelationshipsTerritoryAvailabilities.ts';
import { AppAvailabilityV2RelationshipsTerritoryAvailabilitiesDataInner } from '../models/AppAvailabilityV2RelationshipsTerritoryAvailabilitiesDataInner.ts';
import { AppAvailabilityV2Response } from '../models/AppAvailabilityV2Response.ts';
import { AppBetaTestersLinkagesRequest } from '../models/AppBetaTestersLinkagesRequest.ts';
import { AppCategoriesResponse } from '../models/AppCategoriesResponse.ts';
import { AppCategoriesWithoutIncludesResponse } from '../models/AppCategoriesWithoutIncludesResponse.ts';
import { AppCategory } from '../models/AppCategory.ts';
import { AppCategoryAttributes } from '../models/AppCategoryAttributes.ts';
import { AppCategoryRelationships } from '../models/AppCategoryRelationships.ts';
import { AppCategoryRelationshipsParent } from '../models/AppCategoryRelationshipsParent.ts';
import { AppCategoryRelationshipsSubcategories } from '../models/AppCategoryRelationshipsSubcategories.ts';
import { AppCategoryRelationshipsSubcategoriesDataInner } from '../models/AppCategoryRelationshipsSubcategoriesDataInner.ts';
import { AppCategoryResponse } from '../models/AppCategoryResponse.ts';
import { AppCategoryWithoutIncludesResponse } from '../models/AppCategoryWithoutIncludesResponse.ts';
import { AppClip } from '../models/AppClip.ts';
import { AppClipAction } from '../models/AppClipAction.ts';
import { AppClipAdvancedExperience } from '../models/AppClipAdvancedExperience.ts';
import { AppClipAdvancedExperienceAttributes } from '../models/AppClipAdvancedExperienceAttributes.ts';
import { AppClipAdvancedExperienceAttributesPlace } from '../models/AppClipAdvancedExperienceAttributesPlace.ts';
import { AppClipAdvancedExperienceAttributesPlaceDisplayPoint } from '../models/AppClipAdvancedExperienceAttributesPlaceDisplayPoint.ts';
import { AppClipAdvancedExperienceAttributesPlaceDisplayPointCoordinates } from '../models/AppClipAdvancedExperienceAttributesPlaceDisplayPointCoordinates.ts';
import { AppClipAdvancedExperienceAttributesPlaceMainAddress } from '../models/AppClipAdvancedExperienceAttributesPlaceMainAddress.ts';
import { AppClipAdvancedExperienceAttributesPlaceMainAddressStructuredAddress } from '../models/AppClipAdvancedExperienceAttributesPlaceMainAddressStructuredAddress.ts';
import { AppClipAdvancedExperienceAttributesPlacePhoneNumber } from '../models/AppClipAdvancedExperienceAttributesPlacePhoneNumber.ts';
import { AppClipAdvancedExperienceCreateRequest } from '../models/AppClipAdvancedExperienceCreateRequest.ts';
import { AppClipAdvancedExperienceCreateRequestData } from '../models/AppClipAdvancedExperienceCreateRequestData.ts';
import { AppClipAdvancedExperienceCreateRequestDataAttributes } from '../models/AppClipAdvancedExperienceCreateRequestDataAttributes.ts';
import { AppClipAdvancedExperienceCreateRequestDataRelationships } from '../models/AppClipAdvancedExperienceCreateRequestDataRelationships.ts';
import { AppClipAdvancedExperienceCreateRequestDataRelationshipsAppClip } from '../models/AppClipAdvancedExperienceCreateRequestDataRelationshipsAppClip.ts';
import { AppClipAdvancedExperienceCreateRequestDataRelationshipsHeaderImage } from '../models/AppClipAdvancedExperienceCreateRequestDataRelationshipsHeaderImage.ts';
import { AppClipAdvancedExperienceCreateRequestDataRelationshipsLocalizations } from '../models/AppClipAdvancedExperienceCreateRequestDataRelationshipsLocalizations.ts';
import { AppClipAdvancedExperienceImage } from '../models/AppClipAdvancedExperienceImage.ts';
import { AppClipAdvancedExperienceImageAttributes } from '../models/AppClipAdvancedExperienceImageAttributes.ts';
import { AppClipAdvancedExperienceImageCreateRequest } from '../models/AppClipAdvancedExperienceImageCreateRequest.ts';
import { AppClipAdvancedExperienceImageCreateRequestData } from '../models/AppClipAdvancedExperienceImageCreateRequestData.ts';
import { AppClipAdvancedExperienceImageCreateRequestDataAttributes } from '../models/AppClipAdvancedExperienceImageCreateRequestDataAttributes.ts';
import { AppClipAdvancedExperienceImageResponse } from '../models/AppClipAdvancedExperienceImageResponse.ts';
import { AppClipAdvancedExperienceImageUpdateRequest } from '../models/AppClipAdvancedExperienceImageUpdateRequest.ts';
import { AppClipAdvancedExperienceImageUpdateRequestData } from '../models/AppClipAdvancedExperienceImageUpdateRequestData.ts';
import { AppClipAdvancedExperienceImageUpdateRequestDataAttributes } from '../models/AppClipAdvancedExperienceImageUpdateRequestDataAttributes.ts';
import { AppClipAdvancedExperienceLanguage } from '../models/AppClipAdvancedExperienceLanguage.ts';
import { AppClipAdvancedExperienceLocalization } from '../models/AppClipAdvancedExperienceLocalization.ts';
import { AppClipAdvancedExperienceLocalizationAttributes } from '../models/AppClipAdvancedExperienceLocalizationAttributes.ts';
import { AppClipAdvancedExperienceLocalizationInlineCreate } from '../models/AppClipAdvancedExperienceLocalizationInlineCreate.ts';
import { AppClipAdvancedExperienceRelationships } from '../models/AppClipAdvancedExperienceRelationships.ts';
import { AppClipAdvancedExperienceRelationshipsAppClip } from '../models/AppClipAdvancedExperienceRelationshipsAppClip.ts';
import { AppClipAdvancedExperienceRelationshipsAppClipData } from '../models/AppClipAdvancedExperienceRelationshipsAppClipData.ts';
import { AppClipAdvancedExperienceRelationshipsHeaderImage } from '../models/AppClipAdvancedExperienceRelationshipsHeaderImage.ts';
import { AppClipAdvancedExperienceRelationshipsHeaderImageData } from '../models/AppClipAdvancedExperienceRelationshipsHeaderImageData.ts';
import { AppClipAdvancedExperienceRelationshipsLocalizations } from '../models/AppClipAdvancedExperienceRelationshipsLocalizations.ts';
import { AppClipAdvancedExperienceRelationshipsLocalizationsDataInner } from '../models/AppClipAdvancedExperienceRelationshipsLocalizationsDataInner.ts';
import { AppClipAdvancedExperienceResponse } from '../models/AppClipAdvancedExperienceResponse.ts';
import { AppClipAdvancedExperienceUpdateRequest } from '../models/AppClipAdvancedExperienceUpdateRequest.ts';
import { AppClipAdvancedExperienceUpdateRequestData } from '../models/AppClipAdvancedExperienceUpdateRequestData.ts';
import { AppClipAdvancedExperienceUpdateRequestDataAttributes } from '../models/AppClipAdvancedExperienceUpdateRequestDataAttributes.ts';
import { AppClipAdvancedExperienceUpdateRequestDataRelationships } from '../models/AppClipAdvancedExperienceUpdateRequestDataRelationships.ts';
import { AppClipAdvancedExperienceUpdateRequestDataRelationshipsAppClip } from '../models/AppClipAdvancedExperienceUpdateRequestDataRelationshipsAppClip.ts';
import { AppClipAdvancedExperienceUpdateRequestDataRelationshipsHeaderImage } from '../models/AppClipAdvancedExperienceUpdateRequestDataRelationshipsHeaderImage.ts';
import { AppClipAdvancedExperienceUpdateRequestDataRelationshipsLocalizations } from '../models/AppClipAdvancedExperienceUpdateRequestDataRelationshipsLocalizations.ts';
import { AppClipAdvancedExperiencesResponse } from '../models/AppClipAdvancedExperiencesResponse.ts';
import { AppClipAdvancedExperiencesResponseIncludedInner } from '../models/AppClipAdvancedExperiencesResponseIncludedInner.ts';
import { AppClipAppStoreReviewDetail } from '../models/AppClipAppStoreReviewDetail.ts';
import { AppClipAppStoreReviewDetailAttributes } from '../models/AppClipAppStoreReviewDetailAttributes.ts';
import { AppClipAppStoreReviewDetailCreateRequest } from '../models/AppClipAppStoreReviewDetailCreateRequest.ts';
import { AppClipAppStoreReviewDetailCreateRequestData } from '../models/AppClipAppStoreReviewDetailCreateRequestData.ts';
import { AppClipAppStoreReviewDetailCreateRequestDataRelationships } from '../models/AppClipAppStoreReviewDetailCreateRequestDataRelationships.ts';
import { AppClipAppStoreReviewDetailCreateRequestDataRelationshipsAppClipDefaultExperience } from '../models/AppClipAppStoreReviewDetailCreateRequestDataRelationshipsAppClipDefaultExperience.ts';
import { AppClipAppStoreReviewDetailRelationships } from '../models/AppClipAppStoreReviewDetailRelationships.ts';
import { AppClipAppStoreReviewDetailRelationshipsAppClipDefaultExperience } from '../models/AppClipAppStoreReviewDetailRelationshipsAppClipDefaultExperience.ts';
import { AppClipAppStoreReviewDetailRelationshipsAppClipDefaultExperienceData } from '../models/AppClipAppStoreReviewDetailRelationshipsAppClipDefaultExperienceData.ts';
import { AppClipAppStoreReviewDetailResponse } from '../models/AppClipAppStoreReviewDetailResponse.ts';
import { AppClipAppStoreReviewDetailUpdateRequest } from '../models/AppClipAppStoreReviewDetailUpdateRequest.ts';
import { AppClipAppStoreReviewDetailUpdateRequestData } from '../models/AppClipAppStoreReviewDetailUpdateRequestData.ts';
import { AppClipAttributes } from '../models/AppClipAttributes.ts';
import { AppClipDefaultExperience } from '../models/AppClipDefaultExperience.ts';
import { AppClipDefaultExperienceAttributes } from '../models/AppClipDefaultExperienceAttributes.ts';
import { AppClipDefaultExperienceCreateRequest } from '../models/AppClipDefaultExperienceCreateRequest.ts';
import { AppClipDefaultExperienceCreateRequestData } from '../models/AppClipDefaultExperienceCreateRequestData.ts';
import { AppClipDefaultExperienceCreateRequestDataRelationships } from '../models/AppClipDefaultExperienceCreateRequestDataRelationships.ts';
import { AppClipDefaultExperienceCreateRequestDataRelationshipsAppClipDefaultExperienceTemplate } from '../models/AppClipDefaultExperienceCreateRequestDataRelationshipsAppClipDefaultExperienceTemplate.ts';
import { AppClipDefaultExperienceCreateRequestDataRelationshipsReleaseWithAppStoreVersion } from '../models/AppClipDefaultExperienceCreateRequestDataRelationshipsReleaseWithAppStoreVersion.ts';
import { AppClipDefaultExperienceLocalization } from '../models/AppClipDefaultExperienceLocalization.ts';
import { AppClipDefaultExperienceLocalizationAttributes } from '../models/AppClipDefaultExperienceLocalizationAttributes.ts';
import { AppClipDefaultExperienceLocalizationCreateRequest } from '../models/AppClipDefaultExperienceLocalizationCreateRequest.ts';
import { AppClipDefaultExperienceLocalizationCreateRequestData } from '../models/AppClipDefaultExperienceLocalizationCreateRequestData.ts';
import { AppClipDefaultExperienceLocalizationCreateRequestDataAttributes } from '../models/AppClipDefaultExperienceLocalizationCreateRequestDataAttributes.ts';
import { AppClipDefaultExperienceLocalizationRelationships } from '../models/AppClipDefaultExperienceLocalizationRelationships.ts';
import { AppClipDefaultExperienceLocalizationRelationshipsAppClipHeaderImage } from '../models/AppClipDefaultExperienceLocalizationRelationshipsAppClipHeaderImage.ts';
import { AppClipDefaultExperienceLocalizationRelationshipsAppClipHeaderImageData } from '../models/AppClipDefaultExperienceLocalizationRelationshipsAppClipHeaderImageData.ts';
import { AppClipDefaultExperienceLocalizationResponse } from '../models/AppClipDefaultExperienceLocalizationResponse.ts';
import { AppClipDefaultExperienceLocalizationUpdateRequest } from '../models/AppClipDefaultExperienceLocalizationUpdateRequest.ts';
import { AppClipDefaultExperienceLocalizationUpdateRequestData } from '../models/AppClipDefaultExperienceLocalizationUpdateRequestData.ts';
import { AppClipDefaultExperienceLocalizationUpdateRequestDataAttributes } from '../models/AppClipDefaultExperienceLocalizationUpdateRequestDataAttributes.ts';
import { AppClipDefaultExperienceLocalizationsResponse } from '../models/AppClipDefaultExperienceLocalizationsResponse.ts';
import { AppClipDefaultExperienceLocalizationsResponseIncludedInner } from '../models/AppClipDefaultExperienceLocalizationsResponseIncludedInner.ts';
import { AppClipDefaultExperienceRelationships } from '../models/AppClipDefaultExperienceRelationships.ts';
import { AppClipDefaultExperienceRelationshipsAppClipAppStoreReviewDetail } from '../models/AppClipDefaultExperienceRelationshipsAppClipAppStoreReviewDetail.ts';
import { AppClipDefaultExperienceRelationshipsAppClipAppStoreReviewDetailData } from '../models/AppClipDefaultExperienceRelationshipsAppClipAppStoreReviewDetailData.ts';
import { AppClipDefaultExperienceRelationshipsAppClipDefaultExperienceLocalizations } from '../models/AppClipDefaultExperienceRelationshipsAppClipDefaultExperienceLocalizations.ts';
import { AppClipDefaultExperienceRelationshipsAppClipDefaultExperienceLocalizationsDataInner } from '../models/AppClipDefaultExperienceRelationshipsAppClipDefaultExperienceLocalizationsDataInner.ts';
import { AppClipDefaultExperienceRelationshipsReleaseWithAppStoreVersion } from '../models/AppClipDefaultExperienceRelationshipsReleaseWithAppStoreVersion.ts';
import { AppClipDefaultExperienceReleaseWithAppStoreVersionLinkageRequest } from '../models/AppClipDefaultExperienceReleaseWithAppStoreVersionLinkageRequest.ts';
import { AppClipDefaultExperienceReleaseWithAppStoreVersionLinkageResponse } from '../models/AppClipDefaultExperienceReleaseWithAppStoreVersionLinkageResponse.ts';
import { AppClipDefaultExperienceResponse } from '../models/AppClipDefaultExperienceResponse.ts';
import { AppClipDefaultExperienceUpdateRequest } from '../models/AppClipDefaultExperienceUpdateRequest.ts';
import { AppClipDefaultExperienceUpdateRequestData } from '../models/AppClipDefaultExperienceUpdateRequestData.ts';
import { AppClipDefaultExperienceUpdateRequestDataRelationships } from '../models/AppClipDefaultExperienceUpdateRequestDataRelationships.ts';
import { AppClipDefaultExperiencesResponse } from '../models/AppClipDefaultExperiencesResponse.ts';
import { AppClipDefaultExperiencesResponseIncludedInner } from '../models/AppClipDefaultExperiencesResponseIncludedInner.ts';
import { AppClipDomainStatus } from '../models/AppClipDomainStatus.ts';
import { AppClipDomainStatusAttributes } from '../models/AppClipDomainStatusAttributes.ts';
import { AppClipDomainStatusAttributesDomainsInner } from '../models/AppClipDomainStatusAttributesDomainsInner.ts';
import { AppClipDomainStatusResponse } from '../models/AppClipDomainStatusResponse.ts';
import { AppClipHeaderImage } from '../models/AppClipHeaderImage.ts';
import { AppClipHeaderImageCreateRequest } from '../models/AppClipHeaderImageCreateRequest.ts';
import { AppClipHeaderImageCreateRequestData } from '../models/AppClipHeaderImageCreateRequestData.ts';
import { AppClipHeaderImageCreateRequestDataRelationships } from '../models/AppClipHeaderImageCreateRequestDataRelationships.ts';
import { AppClipHeaderImageCreateRequestDataRelationshipsAppClipDefaultExperienceLocalization } from '../models/AppClipHeaderImageCreateRequestDataRelationshipsAppClipDefaultExperienceLocalization.ts';
import { AppClipHeaderImageRelationships } from '../models/AppClipHeaderImageRelationships.ts';
import { AppClipHeaderImageRelationshipsAppClipDefaultExperienceLocalization } from '../models/AppClipHeaderImageRelationshipsAppClipDefaultExperienceLocalization.ts';
import { AppClipHeaderImageResponse } from '../models/AppClipHeaderImageResponse.ts';
import { AppClipHeaderImageUpdateRequest } from '../models/AppClipHeaderImageUpdateRequest.ts';
import { AppClipHeaderImageUpdateRequestData } from '../models/AppClipHeaderImageUpdateRequestData.ts';
import { AppClipRelationships } from '../models/AppClipRelationships.ts';
import { AppClipRelationshipsAppClipDefaultExperiences } from '../models/AppClipRelationshipsAppClipDefaultExperiences.ts';
import { AppClipResponse } from '../models/AppClipResponse.ts';
import { AppClipsResponse } from '../models/AppClipsResponse.ts';
import { AppClipsResponseIncludedInner } from '../models/AppClipsResponseIncludedInner.ts';
import { AppCustomProductPage } from '../models/AppCustomProductPage.ts';
import { AppCustomProductPageAttributes } from '../models/AppCustomProductPageAttributes.ts';
import { AppCustomProductPageCreateRequest } from '../models/AppCustomProductPageCreateRequest.ts';
import { AppCustomProductPageCreateRequestData } from '../models/AppCustomProductPageCreateRequestData.ts';
import { AppCustomProductPageCreateRequestDataAttributes } from '../models/AppCustomProductPageCreateRequestDataAttributes.ts';
import { AppCustomProductPageCreateRequestDataRelationships } from '../models/AppCustomProductPageCreateRequestDataRelationships.ts';
import { AppCustomProductPageCreateRequestDataRelationshipsAppCustomProductPageVersions } from '../models/AppCustomProductPageCreateRequestDataRelationshipsAppCustomProductPageVersions.ts';
import { AppCustomProductPageCreateRequestIncludedInner } from '../models/AppCustomProductPageCreateRequestIncludedInner.ts';
import { AppCustomProductPageLocalization } from '../models/AppCustomProductPageLocalization.ts';
import { AppCustomProductPageLocalizationAttributes } from '../models/AppCustomProductPageLocalizationAttributes.ts';
import { AppCustomProductPageLocalizationCreateRequest } from '../models/AppCustomProductPageLocalizationCreateRequest.ts';
import { AppCustomProductPageLocalizationCreateRequestData } from '../models/AppCustomProductPageLocalizationCreateRequestData.ts';
import { AppCustomProductPageLocalizationCreateRequestDataRelationships } from '../models/AppCustomProductPageLocalizationCreateRequestDataRelationships.ts';
import { AppCustomProductPageLocalizationCreateRequestDataRelationshipsAppCustomProductPageVersion } from '../models/AppCustomProductPageLocalizationCreateRequestDataRelationshipsAppCustomProductPageVersion.ts';
import { AppCustomProductPageLocalizationInlineCreate } from '../models/AppCustomProductPageLocalizationInlineCreate.ts';
import { AppCustomProductPageLocalizationInlineCreateAttributes } from '../models/AppCustomProductPageLocalizationInlineCreateAttributes.ts';
import { AppCustomProductPageLocalizationInlineCreateRelationships } from '../models/AppCustomProductPageLocalizationInlineCreateRelationships.ts';
import { AppCustomProductPageLocalizationInlineCreateRelationshipsAppCustomProductPageVersion } from '../models/AppCustomProductPageLocalizationInlineCreateRelationshipsAppCustomProductPageVersion.ts';
import { AppCustomProductPageLocalizationRelationships } from '../models/AppCustomProductPageLocalizationRelationships.ts';
import { AppCustomProductPageLocalizationRelationshipsAppCustomProductPageVersion } from '../models/AppCustomProductPageLocalizationRelationshipsAppCustomProductPageVersion.ts';
import { AppCustomProductPageLocalizationRelationshipsAppCustomProductPageVersionData } from '../models/AppCustomProductPageLocalizationRelationshipsAppCustomProductPageVersionData.ts';
import { AppCustomProductPageLocalizationRelationshipsAppPreviewSets } from '../models/AppCustomProductPageLocalizationRelationshipsAppPreviewSets.ts';
import { AppCustomProductPageLocalizationRelationshipsAppPreviewSetsDataInner } from '../models/AppCustomProductPageLocalizationRelationshipsAppPreviewSetsDataInner.ts';
import { AppCustomProductPageLocalizationRelationshipsAppScreenshotSets } from '../models/AppCustomProductPageLocalizationRelationshipsAppScreenshotSets.ts';
import { AppCustomProductPageLocalizationRelationshipsAppScreenshotSetsDataInner } from '../models/AppCustomProductPageLocalizationRelationshipsAppScreenshotSetsDataInner.ts';
import { AppCustomProductPageLocalizationResponse } from '../models/AppCustomProductPageLocalizationResponse.ts';
import { AppCustomProductPageLocalizationUpdateRequest } from '../models/AppCustomProductPageLocalizationUpdateRequest.ts';
import { AppCustomProductPageLocalizationUpdateRequestData } from '../models/AppCustomProductPageLocalizationUpdateRequestData.ts';
import { AppCustomProductPageLocalizationUpdateRequestDataAttributes } from '../models/AppCustomProductPageLocalizationUpdateRequestDataAttributes.ts';
import { AppCustomProductPageLocalizationsResponse } from '../models/AppCustomProductPageLocalizationsResponse.ts';
import { AppCustomProductPageLocalizationsResponseIncludedInner } from '../models/AppCustomProductPageLocalizationsResponseIncludedInner.ts';
import { AppCustomProductPageRelationships } from '../models/AppCustomProductPageRelationships.ts';
import { AppCustomProductPageRelationshipsAppCustomProductPageVersions } from '../models/AppCustomProductPageRelationshipsAppCustomProductPageVersions.ts';
import { AppCustomProductPageResponse } from '../models/AppCustomProductPageResponse.ts';
import { AppCustomProductPageUpdateRequest } from '../models/AppCustomProductPageUpdateRequest.ts';
import { AppCustomProductPageUpdateRequestData } from '../models/AppCustomProductPageUpdateRequestData.ts';
import { AppCustomProductPageUpdateRequestDataAttributes } from '../models/AppCustomProductPageUpdateRequestDataAttributes.ts';
import { AppCustomProductPageVersion } from '../models/AppCustomProductPageVersion.ts';
import { AppCustomProductPageVersionAttributes } from '../models/AppCustomProductPageVersionAttributes.ts';
import { AppCustomProductPageVersionCreateRequest } from '../models/AppCustomProductPageVersionCreateRequest.ts';
import { AppCustomProductPageVersionCreateRequestData } from '../models/AppCustomProductPageVersionCreateRequestData.ts';
import { AppCustomProductPageVersionCreateRequestDataRelationships } from '../models/AppCustomProductPageVersionCreateRequestDataRelationships.ts';
import { AppCustomProductPageVersionCreateRequestDataRelationshipsAppCustomProductPage } from '../models/AppCustomProductPageVersionCreateRequestDataRelationshipsAppCustomProductPage.ts';
import { AppCustomProductPageVersionInlineCreate } from '../models/AppCustomProductPageVersionInlineCreate.ts';
import { AppCustomProductPageVersionInlineCreateRelationships } from '../models/AppCustomProductPageVersionInlineCreateRelationships.ts';
import { AppCustomProductPageVersionInlineCreateRelationshipsAppCustomProductPage } from '../models/AppCustomProductPageVersionInlineCreateRelationshipsAppCustomProductPage.ts';
import { AppCustomProductPageVersionInlineCreateRelationshipsAppCustomProductPageLocalizations } from '../models/AppCustomProductPageVersionInlineCreateRelationshipsAppCustomProductPageLocalizations.ts';
import { AppCustomProductPageVersionRelationships } from '../models/AppCustomProductPageVersionRelationships.ts';
import { AppCustomProductPageVersionRelationshipsAppCustomProductPage } from '../models/AppCustomProductPageVersionRelationshipsAppCustomProductPage.ts';
import { AppCustomProductPageVersionRelationshipsAppCustomProductPageData } from '../models/AppCustomProductPageVersionRelationshipsAppCustomProductPageData.ts';
import { AppCustomProductPageVersionRelationshipsAppCustomProductPageLocalizations } from '../models/AppCustomProductPageVersionRelationshipsAppCustomProductPageLocalizations.ts';
import { AppCustomProductPageVersionRelationshipsAppCustomProductPageLocalizationsDataInner } from '../models/AppCustomProductPageVersionRelationshipsAppCustomProductPageLocalizationsDataInner.ts';
import { AppCustomProductPageVersionResponse } from '../models/AppCustomProductPageVersionResponse.ts';
import { AppCustomProductPageVersionsResponse } from '../models/AppCustomProductPageVersionsResponse.ts';
import { AppCustomProductPageVersionsResponseIncludedInner } from '../models/AppCustomProductPageVersionsResponseIncludedInner.ts';
import { AppCustomProductPagesResponse } from '../models/AppCustomProductPagesResponse.ts';
import { AppCustomProductPagesResponseIncludedInner } from '../models/AppCustomProductPagesResponseIncludedInner.ts';
import { AppEncryptionDeclaration } from '../models/AppEncryptionDeclaration.ts';
import { AppEncryptionDeclarationAttributes } from '../models/AppEncryptionDeclarationAttributes.ts';
import { AppEncryptionDeclarationBuildsLinkagesRequest } from '../models/AppEncryptionDeclarationBuildsLinkagesRequest.ts';
import { AppEncryptionDeclarationDocument } from '../models/AppEncryptionDeclarationDocument.ts';
import { AppEncryptionDeclarationDocumentAttributes } from '../models/AppEncryptionDeclarationDocumentAttributes.ts';
import { AppEncryptionDeclarationDocumentCreateRequest } from '../models/AppEncryptionDeclarationDocumentCreateRequest.ts';
import { AppEncryptionDeclarationDocumentCreateRequestData } from '../models/AppEncryptionDeclarationDocumentCreateRequestData.ts';
import { AppEncryptionDeclarationDocumentCreateRequestDataRelationships } from '../models/AppEncryptionDeclarationDocumentCreateRequestDataRelationships.ts';
import { AppEncryptionDeclarationDocumentCreateRequestDataRelationshipsAppEncryptionDeclaration } from '../models/AppEncryptionDeclarationDocumentCreateRequestDataRelationshipsAppEncryptionDeclaration.ts';
import { AppEncryptionDeclarationDocumentCreateRequestDataRelationshipsAppEncryptionDeclarationData } from '../models/AppEncryptionDeclarationDocumentCreateRequestDataRelationshipsAppEncryptionDeclarationData.ts';
import { AppEncryptionDeclarationDocumentResponse } from '../models/AppEncryptionDeclarationDocumentResponse.ts';
import { AppEncryptionDeclarationDocumentUpdateRequest } from '../models/AppEncryptionDeclarationDocumentUpdateRequest.ts';
import { AppEncryptionDeclarationDocumentUpdateRequestData } from '../models/AppEncryptionDeclarationDocumentUpdateRequestData.ts';
import { AppEncryptionDeclarationRelationships } from '../models/AppEncryptionDeclarationRelationships.ts';
import { AppEncryptionDeclarationRelationshipsAppEncryptionDeclarationDocument } from '../models/AppEncryptionDeclarationRelationshipsAppEncryptionDeclarationDocument.ts';
import { AppEncryptionDeclarationRelationshipsAppEncryptionDeclarationDocumentData } from '../models/AppEncryptionDeclarationRelationshipsAppEncryptionDeclarationDocumentData.ts';
import { AppEncryptionDeclarationRelationshipsBuilds } from '../models/AppEncryptionDeclarationRelationshipsBuilds.ts';
import { AppEncryptionDeclarationRelationshipsBuildsDataInner } from '../models/AppEncryptionDeclarationRelationshipsBuildsDataInner.ts';
import { AppEncryptionDeclarationResponse } from '../models/AppEncryptionDeclarationResponse.ts';
import { AppEncryptionDeclarationState } from '../models/AppEncryptionDeclarationState.ts';
import { AppEncryptionDeclarationWithoutIncludesResponse } from '../models/AppEncryptionDeclarationWithoutIncludesResponse.ts';
import { AppEncryptionDeclarationsResponse } from '../models/AppEncryptionDeclarationsResponse.ts';
import { AppEncryptionDeclarationsResponseIncludedInner } from '../models/AppEncryptionDeclarationsResponseIncludedInner.ts';
import { AppEvent } from '../models/AppEvent.ts';
import { AppEventAssetType } from '../models/AppEventAssetType.ts';
import { AppEventAttributes } from '../models/AppEventAttributes.ts';
import { AppEventAttributesTerritorySchedulesInner } from '../models/AppEventAttributesTerritorySchedulesInner.ts';
import { AppEventCreateRequest } from '../models/AppEventCreateRequest.ts';
import { AppEventCreateRequestData } from '../models/AppEventCreateRequestData.ts';
import { AppEventCreateRequestDataAttributes } from '../models/AppEventCreateRequestDataAttributes.ts';
import { AppEventLocalization } from '../models/AppEventLocalization.ts';
import { AppEventLocalizationAttributes } from '../models/AppEventLocalizationAttributes.ts';
import { AppEventLocalizationCreateRequest } from '../models/AppEventLocalizationCreateRequest.ts';
import { AppEventLocalizationCreateRequestData } from '../models/AppEventLocalizationCreateRequestData.ts';
import { AppEventLocalizationCreateRequestDataAttributes } from '../models/AppEventLocalizationCreateRequestDataAttributes.ts';
import { AppEventLocalizationCreateRequestDataRelationships } from '../models/AppEventLocalizationCreateRequestDataRelationships.ts';
import { AppEventLocalizationCreateRequestDataRelationshipsAppEvent } from '../models/AppEventLocalizationCreateRequestDataRelationshipsAppEvent.ts';
import { AppEventLocalizationRelationships } from '../models/AppEventLocalizationRelationships.ts';
import { AppEventLocalizationRelationshipsAppEvent } from '../models/AppEventLocalizationRelationshipsAppEvent.ts';
import { AppEventLocalizationRelationshipsAppEventData } from '../models/AppEventLocalizationRelationshipsAppEventData.ts';
import { AppEventLocalizationRelationshipsAppEventScreenshots } from '../models/AppEventLocalizationRelationshipsAppEventScreenshots.ts';
import { AppEventLocalizationRelationshipsAppEventScreenshotsDataInner } from '../models/AppEventLocalizationRelationshipsAppEventScreenshotsDataInner.ts';
import { AppEventLocalizationRelationshipsAppEventVideoClips } from '../models/AppEventLocalizationRelationshipsAppEventVideoClips.ts';
import { AppEventLocalizationRelationshipsAppEventVideoClipsDataInner } from '../models/AppEventLocalizationRelationshipsAppEventVideoClipsDataInner.ts';
import { AppEventLocalizationResponse } from '../models/AppEventLocalizationResponse.ts';
import { AppEventLocalizationUpdateRequest } from '../models/AppEventLocalizationUpdateRequest.ts';
import { AppEventLocalizationUpdateRequestData } from '../models/AppEventLocalizationUpdateRequestData.ts';
import { AppEventLocalizationUpdateRequestDataAttributes } from '../models/AppEventLocalizationUpdateRequestDataAttributes.ts';
import { AppEventLocalizationsResponse } from '../models/AppEventLocalizationsResponse.ts';
import { AppEventLocalizationsResponseIncludedInner } from '../models/AppEventLocalizationsResponseIncludedInner.ts';
import { AppEventRelationships } from '../models/AppEventRelationships.ts';
import { AppEventRelationshipsLocalizations } from '../models/AppEventRelationshipsLocalizations.ts';
import { AppEventResponse } from '../models/AppEventResponse.ts';
import { AppEventScreenshot } from '../models/AppEventScreenshot.ts';
import { AppEventScreenshotAttributes } from '../models/AppEventScreenshotAttributes.ts';
import { AppEventScreenshotCreateRequest } from '../models/AppEventScreenshotCreateRequest.ts';
import { AppEventScreenshotCreateRequestData } from '../models/AppEventScreenshotCreateRequestData.ts';
import { AppEventScreenshotCreateRequestDataAttributes } from '../models/AppEventScreenshotCreateRequestDataAttributes.ts';
import { AppEventScreenshotCreateRequestDataRelationships } from '../models/AppEventScreenshotCreateRequestDataRelationships.ts';
import { AppEventScreenshotCreateRequestDataRelationshipsAppEventLocalization } from '../models/AppEventScreenshotCreateRequestDataRelationshipsAppEventLocalization.ts';
import { AppEventScreenshotRelationships } from '../models/AppEventScreenshotRelationships.ts';
import { AppEventScreenshotRelationshipsAppEventLocalization } from '../models/AppEventScreenshotRelationshipsAppEventLocalization.ts';
import { AppEventScreenshotRelationshipsAppEventLocalizationData } from '../models/AppEventScreenshotRelationshipsAppEventLocalizationData.ts';
import { AppEventScreenshotResponse } from '../models/AppEventScreenshotResponse.ts';
import { AppEventScreenshotUpdateRequest } from '../models/AppEventScreenshotUpdateRequest.ts';
import { AppEventScreenshotUpdateRequestData } from '../models/AppEventScreenshotUpdateRequestData.ts';
import { AppEventScreenshotUpdateRequestDataAttributes } from '../models/AppEventScreenshotUpdateRequestDataAttributes.ts';
import { AppEventScreenshotsResponse } from '../models/AppEventScreenshotsResponse.ts';
import { AppEventUpdateRequest } from '../models/AppEventUpdateRequest.ts';
import { AppEventUpdateRequestData } from '../models/AppEventUpdateRequestData.ts';
import { AppEventUpdateRequestDataAttributes } from '../models/AppEventUpdateRequestDataAttributes.ts';
import { AppEventVideoClip } from '../models/AppEventVideoClip.ts';
import { AppEventVideoClipAttributes } from '../models/AppEventVideoClipAttributes.ts';
import { AppEventVideoClipCreateRequest } from '../models/AppEventVideoClipCreateRequest.ts';
import { AppEventVideoClipCreateRequestData } from '../models/AppEventVideoClipCreateRequestData.ts';
import { AppEventVideoClipCreateRequestDataAttributes } from '../models/AppEventVideoClipCreateRequestDataAttributes.ts';
import { AppEventVideoClipResponse } from '../models/AppEventVideoClipResponse.ts';
import { AppEventVideoClipUpdateRequest } from '../models/AppEventVideoClipUpdateRequest.ts';
import { AppEventVideoClipUpdateRequestData } from '../models/AppEventVideoClipUpdateRequestData.ts';
import { AppEventVideoClipUpdateRequestDataAttributes } from '../models/AppEventVideoClipUpdateRequestDataAttributes.ts';
import { AppEventVideoClipsResponse } from '../models/AppEventVideoClipsResponse.ts';
import { AppEventsResponse } from '../models/AppEventsResponse.ts';
import { AppInfo } from '../models/AppInfo.ts';
import { AppInfoAttributes } from '../models/AppInfoAttributes.ts';
import { AppInfoLocalization } from '../models/AppInfoLocalization.ts';
import { AppInfoLocalizationAttributes } from '../models/AppInfoLocalizationAttributes.ts';
import { AppInfoLocalizationCreateRequest } from '../models/AppInfoLocalizationCreateRequest.ts';
import { AppInfoLocalizationCreateRequestData } from '../models/AppInfoLocalizationCreateRequestData.ts';
import { AppInfoLocalizationCreateRequestDataAttributes } from '../models/AppInfoLocalizationCreateRequestDataAttributes.ts';
import { AppInfoLocalizationCreateRequestDataRelationships } from '../models/AppInfoLocalizationCreateRequestDataRelationships.ts';
import { AppInfoLocalizationCreateRequestDataRelationshipsAppInfo } from '../models/AppInfoLocalizationCreateRequestDataRelationshipsAppInfo.ts';
import { AppInfoLocalizationRelationships } from '../models/AppInfoLocalizationRelationships.ts';
import { AppInfoLocalizationRelationshipsAppInfo } from '../models/AppInfoLocalizationRelationshipsAppInfo.ts';
import { AppInfoLocalizationRelationshipsAppInfoData } from '../models/AppInfoLocalizationRelationshipsAppInfoData.ts';
import { AppInfoLocalizationResponse } from '../models/AppInfoLocalizationResponse.ts';
import { AppInfoLocalizationUpdateRequest } from '../models/AppInfoLocalizationUpdateRequest.ts';
import { AppInfoLocalizationUpdateRequestData } from '../models/AppInfoLocalizationUpdateRequestData.ts';
import { AppInfoLocalizationUpdateRequestDataAttributes } from '../models/AppInfoLocalizationUpdateRequestDataAttributes.ts';
import { AppInfoLocalizationsResponse } from '../models/AppInfoLocalizationsResponse.ts';
import { AppInfoRelationships } from '../models/AppInfoRelationships.ts';
import { AppInfoRelationshipsAgeRatingDeclaration } from '../models/AppInfoRelationshipsAgeRatingDeclaration.ts';
import { AppInfoRelationshipsAgeRatingDeclarationData } from '../models/AppInfoRelationshipsAgeRatingDeclarationData.ts';
import { AppInfoRelationshipsAppInfoLocalizations } from '../models/AppInfoRelationshipsAppInfoLocalizations.ts';
import { AppInfoRelationshipsAppInfoLocalizationsDataInner } from '../models/AppInfoRelationshipsAppInfoLocalizationsDataInner.ts';
import { AppInfoResponse } from '../models/AppInfoResponse.ts';
import { AppInfoUpdateRequest } from '../models/AppInfoUpdateRequest.ts';
import { AppInfoUpdateRequestData } from '../models/AppInfoUpdateRequestData.ts';
import { AppInfoUpdateRequestDataRelationships } from '../models/AppInfoUpdateRequestDataRelationships.ts';
import { AppInfoUpdateRequestDataRelationshipsPrimaryCategory } from '../models/AppInfoUpdateRequestDataRelationshipsPrimaryCategory.ts';
import { AppInfosResponse } from '../models/AppInfosResponse.ts';
import { AppInfosResponseIncludedInner } from '../models/AppInfosResponseIncludedInner.ts';
import { AppMediaAssetState } from '../models/AppMediaAssetState.ts';
import { AppMediaStateError } from '../models/AppMediaStateError.ts';
import { AppPreOrder } from '../models/AppPreOrder.ts';
import { AppPreOrderAttributes } from '../models/AppPreOrderAttributes.ts';
import { AppPreOrderCreateRequest } from '../models/AppPreOrderCreateRequest.ts';
import { AppPreOrderCreateRequestData } from '../models/AppPreOrderCreateRequestData.ts';
import { AppPreOrderCreateRequestDataAttributes } from '../models/AppPreOrderCreateRequestDataAttributes.ts';
import { AppPreOrderRelationships } from '../models/AppPreOrderRelationships.ts';
import { AppPreOrderResponse } from '../models/AppPreOrderResponse.ts';
import { AppPreOrderUpdateRequest } from '../models/AppPreOrderUpdateRequest.ts';
import { AppPreOrderUpdateRequestData } from '../models/AppPreOrderUpdateRequestData.ts';
import { AppPreOrderWithoutIncludesResponse } from '../models/AppPreOrderWithoutIncludesResponse.ts';
import { AppPreview } from '../models/AppPreview.ts';
import { AppPreviewAttributes } from '../models/AppPreviewAttributes.ts';
import { AppPreviewCreateRequest } from '../models/AppPreviewCreateRequest.ts';
import { AppPreviewCreateRequestData } from '../models/AppPreviewCreateRequestData.ts';
import { AppPreviewCreateRequestDataAttributes } from '../models/AppPreviewCreateRequestDataAttributes.ts';
import { AppPreviewCreateRequestDataRelationships } from '../models/AppPreviewCreateRequestDataRelationships.ts';
import { AppPreviewCreateRequestDataRelationshipsAppPreviewSet } from '../models/AppPreviewCreateRequestDataRelationshipsAppPreviewSet.ts';
import { AppPreviewRelationships } from '../models/AppPreviewRelationships.ts';
import { AppPreviewRelationshipsAppPreviewSet } from '../models/AppPreviewRelationshipsAppPreviewSet.ts';
import { AppPreviewResponse } from '../models/AppPreviewResponse.ts';
import { AppPreviewSet } from '../models/AppPreviewSet.ts';
import { AppPreviewSetAppPreviewsLinkagesRequest } from '../models/AppPreviewSetAppPreviewsLinkagesRequest.ts';
import { AppPreviewSetAppPreviewsLinkagesResponse } from '../models/AppPreviewSetAppPreviewsLinkagesResponse.ts';
import { AppPreviewSetAttributes } from '../models/AppPreviewSetAttributes.ts';
import { AppPreviewSetCreateRequest } from '../models/AppPreviewSetCreateRequest.ts';
import { AppPreviewSetCreateRequestData } from '../models/AppPreviewSetCreateRequestData.ts';
import { AppPreviewSetCreateRequestDataAttributes } from '../models/AppPreviewSetCreateRequestDataAttributes.ts';
import { AppPreviewSetCreateRequestDataRelationships } from '../models/AppPreviewSetCreateRequestDataRelationships.ts';
import { AppPreviewSetCreateRequestDataRelationshipsAppCustomProductPageLocalization } from '../models/AppPreviewSetCreateRequestDataRelationshipsAppCustomProductPageLocalization.ts';
import { AppPreviewSetCreateRequestDataRelationshipsAppStoreVersionExperimentTreatmentLocalization } from '../models/AppPreviewSetCreateRequestDataRelationshipsAppStoreVersionExperimentTreatmentLocalization.ts';
import { AppPreviewSetCreateRequestDataRelationshipsAppStoreVersionLocalization } from '../models/AppPreviewSetCreateRequestDataRelationshipsAppStoreVersionLocalization.ts';
import { AppPreviewSetRelationships } from '../models/AppPreviewSetRelationships.ts';
import { AppPreviewSetRelationshipsAppCustomProductPageLocalization } from '../models/AppPreviewSetRelationshipsAppCustomProductPageLocalization.ts';
import { AppPreviewSetRelationshipsAppPreviews } from '../models/AppPreviewSetRelationshipsAppPreviews.ts';
import { AppPreviewSetRelationshipsAppPreviewsDataInner } from '../models/AppPreviewSetRelationshipsAppPreviewsDataInner.ts';
import { AppPreviewSetRelationshipsAppStoreVersionExperimentTreatmentLocalization } from '../models/AppPreviewSetRelationshipsAppStoreVersionExperimentTreatmentLocalization.ts';
import { AppPreviewSetRelationshipsAppStoreVersionExperimentTreatmentLocalizationData } from '../models/AppPreviewSetRelationshipsAppStoreVersionExperimentTreatmentLocalizationData.ts';
import { AppPreviewSetRelationshipsAppStoreVersionLocalization } from '../models/AppPreviewSetRelationshipsAppStoreVersionLocalization.ts';
import { AppPreviewSetRelationshipsAppStoreVersionLocalizationData } from '../models/AppPreviewSetRelationshipsAppStoreVersionLocalizationData.ts';
import { AppPreviewSetResponse } from '../models/AppPreviewSetResponse.ts';
import { AppPreviewSetsResponse } from '../models/AppPreviewSetsResponse.ts';
import { AppPreviewSetsResponseIncludedInner } from '../models/AppPreviewSetsResponseIncludedInner.ts';
import { AppPreviewUpdateRequest } from '../models/AppPreviewUpdateRequest.ts';
import { AppPreviewUpdateRequestData } from '../models/AppPreviewUpdateRequestData.ts';
import { AppPreviewUpdateRequestDataAttributes } from '../models/AppPreviewUpdateRequestDataAttributes.ts';
import { AppPreviewsResponse } from '../models/AppPreviewsResponse.ts';
import { AppPrice } from '../models/AppPrice.ts';
import { AppPriceInlineCreate } from '../models/AppPriceInlineCreate.ts';
import { AppPricePoint } from '../models/AppPricePoint.ts';
import { AppPricePointRelationships } from '../models/AppPricePointRelationships.ts';
import { AppPricePointResponse } from '../models/AppPricePointResponse.ts';
import { AppPricePointV2 } from '../models/AppPricePointV2.ts';
import { AppPricePointV2Attributes } from '../models/AppPricePointV2Attributes.ts';
import { AppPricePointV2Relationships } from '../models/AppPricePointV2Relationships.ts';
import { AppPricePointV2RelationshipsPriceTier } from '../models/AppPricePointV2RelationshipsPriceTier.ts';
import { AppPricePointV2RelationshipsPriceTierData } from '../models/AppPricePointV2RelationshipsPriceTierData.ts';
import { AppPricePointV2RelationshipsTerritory } from '../models/AppPricePointV2RelationshipsTerritory.ts';
import { AppPricePointV3 } from '../models/AppPricePointV3.ts';
import { AppPricePointV3Relationships } from '../models/AppPricePointV3Relationships.ts';
import { AppPricePointV3Response } from '../models/AppPricePointV3Response.ts';
import { AppPricePointsResponse } from '../models/AppPricePointsResponse.ts';
import { AppPricePointsResponseIncludedInner } from '../models/AppPricePointsResponseIncludedInner.ts';
import { AppPricePointsV2Response } from '../models/AppPricePointsV2Response.ts';
import { AppPricePointsV2ResponseIncludedInner } from '../models/AppPricePointsV2ResponseIncludedInner.ts';
import { AppPricePointsV3Response } from '../models/AppPricePointsV3Response.ts';
import { AppPriceRelationships } from '../models/AppPriceRelationships.ts';
import { AppPriceResponse } from '../models/AppPriceResponse.ts';
import { AppPriceSchedule } from '../models/AppPriceSchedule.ts';
import { AppPriceScheduleCreateRequest } from '../models/AppPriceScheduleCreateRequest.ts';
import { AppPriceScheduleCreateRequestData } from '../models/AppPriceScheduleCreateRequestData.ts';
import { AppPriceScheduleCreateRequestDataRelationships } from '../models/AppPriceScheduleCreateRequestDataRelationships.ts';
import { AppPriceScheduleCreateRequestDataRelationshipsBaseTerritory } from '../models/AppPriceScheduleCreateRequestDataRelationshipsBaseTerritory.ts';
import { AppPriceScheduleCreateRequestDataRelationshipsManualPrices } from '../models/AppPriceScheduleCreateRequestDataRelationshipsManualPrices.ts';
import { AppPriceScheduleCreateRequestIncludedInner } from '../models/AppPriceScheduleCreateRequestIncludedInner.ts';
import { AppPriceScheduleRelationships } from '../models/AppPriceScheduleRelationships.ts';
import { AppPriceScheduleRelationshipsManualPrices } from '../models/AppPriceScheduleRelationshipsManualPrices.ts';
import { AppPriceScheduleRelationshipsManualPricesDataInner } from '../models/AppPriceScheduleRelationshipsManualPricesDataInner.ts';
import { AppPriceScheduleResponse } from '../models/AppPriceScheduleResponse.ts';
import { AppPriceScheduleResponseIncludedInner } from '../models/AppPriceScheduleResponseIncludedInner.ts';
import { AppPriceTier } from '../models/AppPriceTier.ts';
import { AppPriceTierRelationships } from '../models/AppPriceTierRelationships.ts';
import { AppPriceTierRelationshipsPricePoints } from '../models/AppPriceTierRelationshipsPricePoints.ts';
import { AppPriceTierRelationshipsPricePointsDataInner } from '../models/AppPriceTierRelationshipsPricePointsDataInner.ts';
import { AppPriceTierResponse } from '../models/AppPriceTierResponse.ts';
import { AppPriceTiersResponse } from '../models/AppPriceTiersResponse.ts';
import { AppPriceV2 } from '../models/AppPriceV2.ts';
import { AppPriceV2Attributes } from '../models/AppPriceV2Attributes.ts';
import { AppPriceV2InlineCreate } from '../models/AppPriceV2InlineCreate.ts';
import { AppPriceV2Relationships } from '../models/AppPriceV2Relationships.ts';
import { AppPriceV2RelationshipsAppPricePoint } from '../models/AppPriceV2RelationshipsAppPricePoint.ts';
import { AppPricesResponse } from '../models/AppPricesResponse.ts';
import { AppPricesResponseIncludedInner } from '../models/AppPricesResponseIncludedInner.ts';
import { AppPricesV2Response } from '../models/AppPricesV2Response.ts';
import { AppPricesV2ResponseIncludedInner } from '../models/AppPricesV2ResponseIncludedInner.ts';
import { AppPromotedPurchasesLinkagesRequest } from '../models/AppPromotedPurchasesLinkagesRequest.ts';
import { AppPromotedPurchasesLinkagesResponse } from '../models/AppPromotedPurchasesLinkagesResponse.ts';
import { AppRelationships } from '../models/AppRelationships.ts';
import { AppRelationshipsAppClips } from '../models/AppRelationshipsAppClips.ts';
import { AppRelationshipsAppCustomProductPages } from '../models/AppRelationshipsAppCustomProductPages.ts';
import { AppRelationshipsAppEncryptionDeclarations } from '../models/AppRelationshipsAppEncryptionDeclarations.ts';
import { AppRelationshipsAppEvents } from '../models/AppRelationshipsAppEvents.ts';
import { AppRelationshipsAppInfos } from '../models/AppRelationshipsAppInfos.ts';
import { AppRelationshipsAvailableTerritories } from '../models/AppRelationshipsAvailableTerritories.ts';
import { AppRelationshipsBetaAppLocalizations } from '../models/AppRelationshipsBetaAppLocalizations.ts';
import { AppRelationshipsBetaAppLocalizationsDataInner } from '../models/AppRelationshipsBetaAppLocalizationsDataInner.ts';
import { AppRelationshipsBetaAppReviewDetail } from '../models/AppRelationshipsBetaAppReviewDetail.ts';
import { AppRelationshipsBetaAppReviewDetailData } from '../models/AppRelationshipsBetaAppReviewDetailData.ts';
import { AppRelationshipsBetaGroups } from '../models/AppRelationshipsBetaGroups.ts';
import { AppRelationshipsBetaGroupsDataInner } from '../models/AppRelationshipsBetaGroupsDataInner.ts';
import { AppRelationshipsBetaLicenseAgreement } from '../models/AppRelationshipsBetaLicenseAgreement.ts';
import { AppRelationshipsBetaLicenseAgreementData } from '../models/AppRelationshipsBetaLicenseAgreementData.ts';
import { AppRelationshipsBuilds } from '../models/AppRelationshipsBuilds.ts';
import { AppRelationshipsCiProduct } from '../models/AppRelationshipsCiProduct.ts';
import { AppRelationshipsCiProductData } from '../models/AppRelationshipsCiProductData.ts';
import { AppRelationshipsEndUserLicenseAgreement } from '../models/AppRelationshipsEndUserLicenseAgreement.ts';
import { AppRelationshipsEndUserLicenseAgreementData } from '../models/AppRelationshipsEndUserLicenseAgreementData.ts';
import { AppRelationshipsGameCenterDetail } from '../models/AppRelationshipsGameCenterDetail.ts';
import { AppRelationshipsGameCenterDetailData } from '../models/AppRelationshipsGameCenterDetailData.ts';
import { AppRelationshipsGameCenterEnabledVersions } from '../models/AppRelationshipsGameCenterEnabledVersions.ts';
import { AppRelationshipsGameCenterEnabledVersionsDataInner } from '../models/AppRelationshipsGameCenterEnabledVersionsDataInner.ts';
import { AppRelationshipsInAppPurchases } from '../models/AppRelationshipsInAppPurchases.ts';
import { AppRelationshipsInAppPurchasesDataInner } from '../models/AppRelationshipsInAppPurchasesDataInner.ts';
import { AppRelationshipsInAppPurchasesV2 } from '../models/AppRelationshipsInAppPurchasesV2.ts';
import { AppRelationshipsPreOrder } from '../models/AppRelationshipsPreOrder.ts';
import { AppRelationshipsPreOrderData } from '../models/AppRelationshipsPreOrderData.ts';
import { AppRelationshipsPreReleaseVersions } from '../models/AppRelationshipsPreReleaseVersions.ts';
import { AppRelationshipsPreReleaseVersionsDataInner } from '../models/AppRelationshipsPreReleaseVersionsDataInner.ts';
import { AppRelationshipsPrices } from '../models/AppRelationshipsPrices.ts';
import { AppRelationshipsPromotedPurchases } from '../models/AppRelationshipsPromotedPurchases.ts';
import { AppRelationshipsPromotedPurchasesDataInner } from '../models/AppRelationshipsPromotedPurchasesDataInner.ts';
import { AppRelationshipsReviewSubmissions } from '../models/AppRelationshipsReviewSubmissions.ts';
import { AppRelationshipsReviewSubmissionsDataInner } from '../models/AppRelationshipsReviewSubmissionsDataInner.ts';
import { AppRelationshipsSubscriptionGracePeriod } from '../models/AppRelationshipsSubscriptionGracePeriod.ts';
import { AppRelationshipsSubscriptionGracePeriodData } from '../models/AppRelationshipsSubscriptionGracePeriodData.ts';
import { AppRelationshipsSubscriptionGroups } from '../models/AppRelationshipsSubscriptionGroups.ts';
import { AppRelationshipsSubscriptionGroupsDataInner } from '../models/AppRelationshipsSubscriptionGroupsDataInner.ts';
import { AppResponse } from '../models/AppResponse.ts';
import { AppScreenshot } from '../models/AppScreenshot.ts';
import { AppScreenshotAttributes } from '../models/AppScreenshotAttributes.ts';
import { AppScreenshotCreateRequest } from '../models/AppScreenshotCreateRequest.ts';
import { AppScreenshotCreateRequestData } from '../models/AppScreenshotCreateRequestData.ts';
import { AppScreenshotCreateRequestDataRelationships } from '../models/AppScreenshotCreateRequestDataRelationships.ts';
import { AppScreenshotCreateRequestDataRelationshipsAppScreenshotSet } from '../models/AppScreenshotCreateRequestDataRelationshipsAppScreenshotSet.ts';
import { AppScreenshotRelationships } from '../models/AppScreenshotRelationships.ts';
import { AppScreenshotRelationshipsAppScreenshotSet } from '../models/AppScreenshotRelationshipsAppScreenshotSet.ts';
import { AppScreenshotResponse } from '../models/AppScreenshotResponse.ts';
import { AppScreenshotSet } from '../models/AppScreenshotSet.ts';
import { AppScreenshotSetAppScreenshotsLinkagesRequest } from '../models/AppScreenshotSetAppScreenshotsLinkagesRequest.ts';
import { AppScreenshotSetAppScreenshotsLinkagesResponse } from '../models/AppScreenshotSetAppScreenshotsLinkagesResponse.ts';
import { AppScreenshotSetAttributes } from '../models/AppScreenshotSetAttributes.ts';
import { AppScreenshotSetCreateRequest } from '../models/AppScreenshotSetCreateRequest.ts';
import { AppScreenshotSetCreateRequestData } from '../models/AppScreenshotSetCreateRequestData.ts';
import { AppScreenshotSetCreateRequestDataAttributes } from '../models/AppScreenshotSetCreateRequestDataAttributes.ts';
import { AppScreenshotSetRelationships } from '../models/AppScreenshotSetRelationships.ts';
import { AppScreenshotSetRelationshipsAppScreenshots } from '../models/AppScreenshotSetRelationshipsAppScreenshots.ts';
import { AppScreenshotSetRelationshipsAppScreenshotsDataInner } from '../models/AppScreenshotSetRelationshipsAppScreenshotsDataInner.ts';
import { AppScreenshotSetResponse } from '../models/AppScreenshotSetResponse.ts';
import { AppScreenshotSetsResponse } from '../models/AppScreenshotSetsResponse.ts';
import { AppScreenshotSetsResponseIncludedInner } from '../models/AppScreenshotSetsResponseIncludedInner.ts';
import { AppScreenshotUpdateRequest } from '../models/AppScreenshotUpdateRequest.ts';
import { AppScreenshotUpdateRequestData } from '../models/AppScreenshotUpdateRequestData.ts';
import { AppScreenshotsResponse } from '../models/AppScreenshotsResponse.ts';
import { AppStoreAgeRating } from '../models/AppStoreAgeRating.ts';
import { AppStoreReviewAttachment } from '../models/AppStoreReviewAttachment.ts';
import { AppStoreReviewAttachmentAttributes } from '../models/AppStoreReviewAttachmentAttributes.ts';
import { AppStoreReviewAttachmentCreateRequest } from '../models/AppStoreReviewAttachmentCreateRequest.ts';
import { AppStoreReviewAttachmentCreateRequestData } from '../models/AppStoreReviewAttachmentCreateRequestData.ts';
import { AppStoreReviewAttachmentCreateRequestDataRelationships } from '../models/AppStoreReviewAttachmentCreateRequestDataRelationships.ts';
import { AppStoreReviewAttachmentCreateRequestDataRelationshipsAppStoreReviewDetail } from '../models/AppStoreReviewAttachmentCreateRequestDataRelationshipsAppStoreReviewDetail.ts';
import { AppStoreReviewAttachmentRelationships } from '../models/AppStoreReviewAttachmentRelationships.ts';
import { AppStoreReviewAttachmentRelationshipsAppStoreReviewDetail } from '../models/AppStoreReviewAttachmentRelationshipsAppStoreReviewDetail.ts';
import { AppStoreReviewAttachmentRelationshipsAppStoreReviewDetailData } from '../models/AppStoreReviewAttachmentRelationshipsAppStoreReviewDetailData.ts';
import { AppStoreReviewAttachmentResponse } from '../models/AppStoreReviewAttachmentResponse.ts';
import { AppStoreReviewAttachmentUpdateRequest } from '../models/AppStoreReviewAttachmentUpdateRequest.ts';
import { AppStoreReviewAttachmentUpdateRequestData } from '../models/AppStoreReviewAttachmentUpdateRequestData.ts';
import { AppStoreReviewAttachmentsResponse } from '../models/AppStoreReviewAttachmentsResponse.ts';
import { AppStoreReviewDetail } from '../models/AppStoreReviewDetail.ts';
import { AppStoreReviewDetailAttributes } from '../models/AppStoreReviewDetailAttributes.ts';
import { AppStoreReviewDetailCreateRequest } from '../models/AppStoreReviewDetailCreateRequest.ts';
import { AppStoreReviewDetailCreateRequestData } from '../models/AppStoreReviewDetailCreateRequestData.ts';
import { AppStoreReviewDetailRelationships } from '../models/AppStoreReviewDetailRelationships.ts';
import { AppStoreReviewDetailRelationshipsAppStoreReviewAttachments } from '../models/AppStoreReviewDetailRelationshipsAppStoreReviewAttachments.ts';
import { AppStoreReviewDetailRelationshipsAppStoreReviewAttachmentsDataInner } from '../models/AppStoreReviewDetailRelationshipsAppStoreReviewAttachmentsDataInner.ts';
import { AppStoreReviewDetailResponse } from '../models/AppStoreReviewDetailResponse.ts';
import { AppStoreReviewDetailResponseIncludedInner } from '../models/AppStoreReviewDetailResponseIncludedInner.ts';
import { AppStoreReviewDetailUpdateRequest } from '../models/AppStoreReviewDetailUpdateRequest.ts';
import { AppStoreReviewDetailUpdateRequestData } from '../models/AppStoreReviewDetailUpdateRequestData.ts';
import { AppStoreVersion } from '../models/AppStoreVersion.ts';
import { AppStoreVersionAppClipDefaultExperienceLinkageRequest } from '../models/AppStoreVersionAppClipDefaultExperienceLinkageRequest.ts';
import { AppStoreVersionAppClipDefaultExperienceLinkageResponse } from '../models/AppStoreVersionAppClipDefaultExperienceLinkageResponse.ts';
import { AppStoreVersionAttributes } from '../models/AppStoreVersionAttributes.ts';
import { AppStoreVersionBuildLinkageRequest } from '../models/AppStoreVersionBuildLinkageRequest.ts';
import { AppStoreVersionBuildLinkageResponse } from '../models/AppStoreVersionBuildLinkageResponse.ts';
import { AppStoreVersionCreateRequest } from '../models/AppStoreVersionCreateRequest.ts';
import { AppStoreVersionCreateRequestData } from '../models/AppStoreVersionCreateRequestData.ts';
import { AppStoreVersionCreateRequestDataAttributes } from '../models/AppStoreVersionCreateRequestDataAttributes.ts';
import { AppStoreVersionCreateRequestDataRelationships } from '../models/AppStoreVersionCreateRequestDataRelationships.ts';
import { AppStoreVersionCreateRequestDataRelationshipsAppStoreVersionLocalizations } from '../models/AppStoreVersionCreateRequestDataRelationshipsAppStoreVersionLocalizations.ts';
import { AppStoreVersionCreateRequestDataRelationshipsBuild } from '../models/AppStoreVersionCreateRequestDataRelationshipsBuild.ts';
import { AppStoreVersionExperiment } from '../models/AppStoreVersionExperiment.ts';
import { AppStoreVersionExperimentAttributes } from '../models/AppStoreVersionExperimentAttributes.ts';
import { AppStoreVersionExperimentCreateRequest } from '../models/AppStoreVersionExperimentCreateRequest.ts';
import { AppStoreVersionExperimentCreateRequestData } from '../models/AppStoreVersionExperimentCreateRequestData.ts';
import { AppStoreVersionExperimentCreateRequestDataAttributes } from '../models/AppStoreVersionExperimentCreateRequestDataAttributes.ts';
import { AppStoreVersionExperimentRelationships } from '../models/AppStoreVersionExperimentRelationships.ts';
import { AppStoreVersionExperimentResponse } from '../models/AppStoreVersionExperimentResponse.ts';
import { AppStoreVersionExperimentTreatment } from '../models/AppStoreVersionExperimentTreatment.ts';
import { AppStoreVersionExperimentTreatmentAttributes } from '../models/AppStoreVersionExperimentTreatmentAttributes.ts';
import { AppStoreVersionExperimentTreatmentCreateRequest } from '../models/AppStoreVersionExperimentTreatmentCreateRequest.ts';
import { AppStoreVersionExperimentTreatmentCreateRequestData } from '../models/AppStoreVersionExperimentTreatmentCreateRequestData.ts';
import { AppStoreVersionExperimentTreatmentCreateRequestDataAttributes } from '../models/AppStoreVersionExperimentTreatmentCreateRequestDataAttributes.ts';
import { AppStoreVersionExperimentTreatmentCreateRequestDataRelationships } from '../models/AppStoreVersionExperimentTreatmentCreateRequestDataRelationships.ts';
import { AppStoreVersionExperimentTreatmentCreateRequestDataRelationshipsAppStoreVersionExperiment } from '../models/AppStoreVersionExperimentTreatmentCreateRequestDataRelationshipsAppStoreVersionExperiment.ts';
import { AppStoreVersionExperimentTreatmentCreateRequestDataRelationshipsAppStoreVersionExperimentV2 } from '../models/AppStoreVersionExperimentTreatmentCreateRequestDataRelationshipsAppStoreVersionExperimentV2.ts';
import { AppStoreVersionExperimentTreatmentLocalization } from '../models/AppStoreVersionExperimentTreatmentLocalization.ts';
import { AppStoreVersionExperimentTreatmentLocalizationAttributes } from '../models/AppStoreVersionExperimentTreatmentLocalizationAttributes.ts';
import { AppStoreVersionExperimentTreatmentLocalizationCreateRequest } from '../models/AppStoreVersionExperimentTreatmentLocalizationCreateRequest.ts';
import { AppStoreVersionExperimentTreatmentLocalizationCreateRequestData } from '../models/AppStoreVersionExperimentTreatmentLocalizationCreateRequestData.ts';
import { AppStoreVersionExperimentTreatmentLocalizationCreateRequestDataAttributes } from '../models/AppStoreVersionExperimentTreatmentLocalizationCreateRequestDataAttributes.ts';
import { AppStoreVersionExperimentTreatmentLocalizationCreateRequestDataRelationships } from '../models/AppStoreVersionExperimentTreatmentLocalizationCreateRequestDataRelationships.ts';
import { AppStoreVersionExperimentTreatmentLocalizationCreateRequestDataRelationshipsAppStoreVersionExperimentTreatment } from '../models/AppStoreVersionExperimentTreatmentLocalizationCreateRequestDataRelationshipsAppStoreVersionExperimentTreatment.ts';
import { AppStoreVersionExperimentTreatmentLocalizationRelationships } from '../models/AppStoreVersionExperimentTreatmentLocalizationRelationships.ts';
import { AppStoreVersionExperimentTreatmentLocalizationRelationshipsAppStoreVersionExperimentTreatment } from '../models/AppStoreVersionExperimentTreatmentLocalizationRelationshipsAppStoreVersionExperimentTreatment.ts';
import { AppStoreVersionExperimentTreatmentLocalizationRelationshipsAppStoreVersionExperimentTreatmentData } from '../models/AppStoreVersionExperimentTreatmentLocalizationRelationshipsAppStoreVersionExperimentTreatmentData.ts';
import { AppStoreVersionExperimentTreatmentLocalizationResponse } from '../models/AppStoreVersionExperimentTreatmentLocalizationResponse.ts';
import { AppStoreVersionExperimentTreatmentLocalizationsResponse } from '../models/AppStoreVersionExperimentTreatmentLocalizationsResponse.ts';
import { AppStoreVersionExperimentTreatmentLocalizationsResponseIncludedInner } from '../models/AppStoreVersionExperimentTreatmentLocalizationsResponseIncludedInner.ts';
import { AppStoreVersionExperimentTreatmentRelationships } from '../models/AppStoreVersionExperimentTreatmentRelationships.ts';
import { AppStoreVersionExperimentTreatmentRelationshipsAppStoreVersionExperiment } from '../models/AppStoreVersionExperimentTreatmentRelationshipsAppStoreVersionExperiment.ts';
import { AppStoreVersionExperimentTreatmentRelationshipsAppStoreVersionExperimentData } from '../models/AppStoreVersionExperimentTreatmentRelationshipsAppStoreVersionExperimentData.ts';
import { AppStoreVersionExperimentTreatmentRelationshipsAppStoreVersionExperimentTreatmentLocalizations } from '../models/AppStoreVersionExperimentTreatmentRelationshipsAppStoreVersionExperimentTreatmentLocalizations.ts';
import { AppStoreVersionExperimentTreatmentResponse } from '../models/AppStoreVersionExperimentTreatmentResponse.ts';
import { AppStoreVersionExperimentTreatmentUpdateRequest } from '../models/AppStoreVersionExperimentTreatmentUpdateRequest.ts';
import { AppStoreVersionExperimentTreatmentUpdateRequestData } from '../models/AppStoreVersionExperimentTreatmentUpdateRequestData.ts';
import { AppStoreVersionExperimentTreatmentUpdateRequestDataAttributes } from '../models/AppStoreVersionExperimentTreatmentUpdateRequestDataAttributes.ts';
import { AppStoreVersionExperimentTreatmentsResponse } from '../models/AppStoreVersionExperimentTreatmentsResponse.ts';
import { AppStoreVersionExperimentTreatmentsResponseIncludedInner } from '../models/AppStoreVersionExperimentTreatmentsResponseIncludedInner.ts';
import { AppStoreVersionExperimentUpdateRequest } from '../models/AppStoreVersionExperimentUpdateRequest.ts';
import { AppStoreVersionExperimentV2 } from '../models/AppStoreVersionExperimentV2.ts';
import { AppStoreVersionExperimentV2Attributes } from '../models/AppStoreVersionExperimentV2Attributes.ts';
import { AppStoreVersionExperimentV2CreateRequest } from '../models/AppStoreVersionExperimentV2CreateRequest.ts';
import { AppStoreVersionExperimentV2CreateRequestData } from '../models/AppStoreVersionExperimentV2CreateRequestData.ts';
import { AppStoreVersionExperimentV2CreateRequestDataAttributes } from '../models/AppStoreVersionExperimentV2CreateRequestDataAttributes.ts';
import { AppStoreVersionExperimentV2Relationships } from '../models/AppStoreVersionExperimentV2Relationships.ts';
import { AppStoreVersionExperimentV2RelationshipsAppStoreVersionExperimentTreatments } from '../models/AppStoreVersionExperimentV2RelationshipsAppStoreVersionExperimentTreatments.ts';
import { AppStoreVersionExperimentV2RelationshipsControlVersions } from '../models/AppStoreVersionExperimentV2RelationshipsControlVersions.ts';
import { AppStoreVersionExperimentV2Response } from '../models/AppStoreVersionExperimentV2Response.ts';
import { AppStoreVersionExperimentV2UpdateRequest } from '../models/AppStoreVersionExperimentV2UpdateRequest.ts';
import { AppStoreVersionExperimentV2UpdateRequestData } from '../models/AppStoreVersionExperimentV2UpdateRequestData.ts';
import { AppStoreVersionExperimentV2UpdateRequestDataAttributes } from '../models/AppStoreVersionExperimentV2UpdateRequestDataAttributes.ts';
import { AppStoreVersionExperimentsResponse } from '../models/AppStoreVersionExperimentsResponse.ts';
import { AppStoreVersionExperimentsResponseIncludedInner } from '../models/AppStoreVersionExperimentsResponseIncludedInner.ts';
import { AppStoreVersionExperimentsV2Response } from '../models/AppStoreVersionExperimentsV2Response.ts';
import { AppStoreVersionExperimentsV2ResponseIncludedInner } from '../models/AppStoreVersionExperimentsV2ResponseIncludedInner.ts';
import { AppStoreVersionLocalization } from '../models/AppStoreVersionLocalization.ts';
import { AppStoreVersionLocalizationAttributes } from '../models/AppStoreVersionLocalizationAttributes.ts';
import { AppStoreVersionLocalizationCreateRequest } from '../models/AppStoreVersionLocalizationCreateRequest.ts';
import { AppStoreVersionLocalizationCreateRequestData } from '../models/AppStoreVersionLocalizationCreateRequestData.ts';
import { AppStoreVersionLocalizationCreateRequestDataAttributes } from '../models/AppStoreVersionLocalizationCreateRequestDataAttributes.ts';
import { AppStoreVersionLocalizationRelationships } from '../models/AppStoreVersionLocalizationRelationships.ts';
import { AppStoreVersionLocalizationResponse } from '../models/AppStoreVersionLocalizationResponse.ts';
import { AppStoreVersionLocalizationUpdateRequest } from '../models/AppStoreVersionLocalizationUpdateRequest.ts';
import { AppStoreVersionLocalizationUpdateRequestData } from '../models/AppStoreVersionLocalizationUpdateRequestData.ts';
import { AppStoreVersionLocalizationUpdateRequestDataAttributes } from '../models/AppStoreVersionLocalizationUpdateRequestDataAttributes.ts';
import { AppStoreVersionLocalizationsResponse } from '../models/AppStoreVersionLocalizationsResponse.ts';
import { AppStoreVersionLocalizationsResponseIncludedInner } from '../models/AppStoreVersionLocalizationsResponseIncludedInner.ts';
import { AppStoreVersionPhasedRelease } from '../models/AppStoreVersionPhasedRelease.ts';
import { AppStoreVersionPhasedReleaseAttributes } from '../models/AppStoreVersionPhasedReleaseAttributes.ts';
import { AppStoreVersionPhasedReleaseCreateRequest } from '../models/AppStoreVersionPhasedReleaseCreateRequest.ts';
import { AppStoreVersionPhasedReleaseCreateRequestData } from '../models/AppStoreVersionPhasedReleaseCreateRequestData.ts';
import { AppStoreVersionPhasedReleaseCreateRequestDataAttributes } from '../models/AppStoreVersionPhasedReleaseCreateRequestDataAttributes.ts';
import { AppStoreVersionPhasedReleaseResponse } from '../models/AppStoreVersionPhasedReleaseResponse.ts';
import { AppStoreVersionPhasedReleaseUpdateRequest } from '../models/AppStoreVersionPhasedReleaseUpdateRequest.ts';
import { AppStoreVersionPhasedReleaseUpdateRequestData } from '../models/AppStoreVersionPhasedReleaseUpdateRequestData.ts';
import { AppStoreVersionPhasedReleaseWithoutIncludesResponse } from '../models/AppStoreVersionPhasedReleaseWithoutIncludesResponse.ts';
import { AppStoreVersionPromotion } from '../models/AppStoreVersionPromotion.ts';
import { AppStoreVersionPromotionCreateRequest } from '../models/AppStoreVersionPromotionCreateRequest.ts';
import { AppStoreVersionPromotionCreateRequestData } from '../models/AppStoreVersionPromotionCreateRequestData.ts';
import { AppStoreVersionPromotionCreateRequestDataRelationships } from '../models/AppStoreVersionPromotionCreateRequestDataRelationships.ts';
import { AppStoreVersionPromotionResponse } from '../models/AppStoreVersionPromotionResponse.ts';
import { AppStoreVersionRelationships } from '../models/AppStoreVersionRelationships.ts';
import { AppStoreVersionRelationshipsAgeRatingDeclaration } from '../models/AppStoreVersionRelationshipsAgeRatingDeclaration.ts';
import { AppStoreVersionRelationshipsAppStoreVersionExperiments } from '../models/AppStoreVersionRelationshipsAppStoreVersionExperiments.ts';
import { AppStoreVersionRelationshipsAppStoreVersionLocalizations } from '../models/AppStoreVersionRelationshipsAppStoreVersionLocalizations.ts';
import { AppStoreVersionRelationshipsAppStoreVersionPhasedRelease } from '../models/AppStoreVersionRelationshipsAppStoreVersionPhasedRelease.ts';
import { AppStoreVersionRelationshipsAppStoreVersionPhasedReleaseData } from '../models/AppStoreVersionRelationshipsAppStoreVersionPhasedReleaseData.ts';
import { AppStoreVersionRelationshipsAppStoreVersionSubmission } from '../models/AppStoreVersionRelationshipsAppStoreVersionSubmission.ts';
import { AppStoreVersionRelationshipsAppStoreVersionSubmissionData } from '../models/AppStoreVersionRelationshipsAppStoreVersionSubmissionData.ts';
import { AppStoreVersionRelationshipsBuild } from '../models/AppStoreVersionRelationshipsBuild.ts';
import { AppStoreVersionRelationshipsRoutingAppCoverage } from '../models/AppStoreVersionRelationshipsRoutingAppCoverage.ts';
import { AppStoreVersionRelationshipsRoutingAppCoverageData } from '../models/AppStoreVersionRelationshipsRoutingAppCoverageData.ts';
import { AppStoreVersionReleaseRequest } from '../models/AppStoreVersionReleaseRequest.ts';
import { AppStoreVersionReleaseRequestCreateRequest } from '../models/AppStoreVersionReleaseRequestCreateRequest.ts';
import { AppStoreVersionReleaseRequestCreateRequestData } from '../models/AppStoreVersionReleaseRequestCreateRequestData.ts';
import { AppStoreVersionReleaseRequestResponse } from '../models/AppStoreVersionReleaseRequestResponse.ts';
import { AppStoreVersionResponse } from '../models/AppStoreVersionResponse.ts';
import { AppStoreVersionState } from '../models/AppStoreVersionState.ts';
import { AppStoreVersionSubmission } from '../models/AppStoreVersionSubmission.ts';
import { AppStoreVersionSubmissionCreateRequest } from '../models/AppStoreVersionSubmissionCreateRequest.ts';
import { AppStoreVersionSubmissionCreateRequestData } from '../models/AppStoreVersionSubmissionCreateRequestData.ts';
import { AppStoreVersionSubmissionRelationships } from '../models/AppStoreVersionSubmissionRelationships.ts';
import { AppStoreVersionSubmissionResponse } from '../models/AppStoreVersionSubmissionResponse.ts';
import { AppStoreVersionUpdateRequest } from '../models/AppStoreVersionUpdateRequest.ts';
import { AppStoreVersionUpdateRequestData } from '../models/AppStoreVersionUpdateRequestData.ts';
import { AppStoreVersionUpdateRequestDataAttributes } from '../models/AppStoreVersionUpdateRequestDataAttributes.ts';
import { AppStoreVersionUpdateRequestDataRelationships } from '../models/AppStoreVersionUpdateRequestDataRelationships.ts';
import { AppStoreVersionsResponse } from '../models/AppStoreVersionsResponse.ts';
import { AppStoreVersionsResponseIncludedInner } from '../models/AppStoreVersionsResponseIncludedInner.ts';
import { AppUpdateRequest } from '../models/AppUpdateRequest.ts';
import { AppUpdateRequestData } from '../models/AppUpdateRequestData.ts';
import { AppUpdateRequestDataAttributes } from '../models/AppUpdateRequestDataAttributes.ts';
import { AppUpdateRequestDataRelationships } from '../models/AppUpdateRequestDataRelationships.ts';
import { AppUpdateRequestDataRelationshipsAvailableTerritories } from '../models/AppUpdateRequestDataRelationshipsAvailableTerritories.ts';
import { AppUpdateRequestDataRelationshipsPrices } from '../models/AppUpdateRequestDataRelationshipsPrices.ts';
import { AppVersionState } from '../models/AppVersionState.ts';
import { AppWithoutIncludesResponse } from '../models/AppWithoutIncludesResponse.ts';
import { AppsBetaTesterUsagesV1MetricResponse } from '../models/AppsBetaTesterUsagesV1MetricResponse.ts';
import { AppsBetaTesterUsagesV1MetricResponseDataInner } from '../models/AppsBetaTesterUsagesV1MetricResponseDataInner.ts';
import { AppsBetaTesterUsagesV1MetricResponseDataInnerDataPoints } from '../models/AppsBetaTesterUsagesV1MetricResponseDataInnerDataPoints.ts';
import { AppsBetaTesterUsagesV1MetricResponseDataInnerDataPointsValues } from '../models/AppsBetaTesterUsagesV1MetricResponseDataInnerDataPointsValues.ts';
import { AppsBetaTesterUsagesV1MetricResponseDataInnerDimensions } from '../models/AppsBetaTesterUsagesV1MetricResponseDataInnerDimensions.ts';
import { AppsBetaTesterUsagesV1MetricResponseDataInnerDimensionsBetaTesters } from '../models/AppsBetaTesterUsagesV1MetricResponseDataInnerDimensionsBetaTesters.ts';
import { AppsBetaTesterUsagesV1MetricResponseDataInnerDimensionsBetaTestersLinks } from '../models/AppsBetaTesterUsagesV1MetricResponseDataInnerDimensionsBetaTestersLinks.ts';
import { AppsResponse } from '../models/AppsResponse.ts';
import { AppsResponseIncludedInner } from '../models/AppsResponseIncludedInner.ts';
import { AppsWithoutIncludesResponse } from '../models/AppsWithoutIncludesResponse.ts';
import { BetaAppClipInvocation } from '../models/BetaAppClipInvocation.ts';
import { BetaAppClipInvocationAttributes } from '../models/BetaAppClipInvocationAttributes.ts';
import { BetaAppClipInvocationCreateRequest } from '../models/BetaAppClipInvocationCreateRequest.ts';
import { BetaAppClipInvocationCreateRequestData } from '../models/BetaAppClipInvocationCreateRequestData.ts';
import { BetaAppClipInvocationCreateRequestDataAttributes } from '../models/BetaAppClipInvocationCreateRequestDataAttributes.ts';
import { BetaAppClipInvocationCreateRequestDataRelationships } from '../models/BetaAppClipInvocationCreateRequestDataRelationships.ts';
import { BetaAppClipInvocationCreateRequestDataRelationshipsBetaAppClipInvocationLocalizations } from '../models/BetaAppClipInvocationCreateRequestDataRelationshipsBetaAppClipInvocationLocalizations.ts';
import { BetaAppClipInvocationCreateRequestDataRelationshipsBuildBundle } from '../models/BetaAppClipInvocationCreateRequestDataRelationshipsBuildBundle.ts';
import { BetaAppClipInvocationCreateRequestDataRelationshipsBuildBundleData } from '../models/BetaAppClipInvocationCreateRequestDataRelationshipsBuildBundleData.ts';
import { BetaAppClipInvocationLocalization } from '../models/BetaAppClipInvocationLocalization.ts';
import { BetaAppClipInvocationLocalizationAttributes } from '../models/BetaAppClipInvocationLocalizationAttributes.ts';
import { BetaAppClipInvocationLocalizationCreateRequest } from '../models/BetaAppClipInvocationLocalizationCreateRequest.ts';
import { BetaAppClipInvocationLocalizationCreateRequestData } from '../models/BetaAppClipInvocationLocalizationCreateRequestData.ts';
import { BetaAppClipInvocationLocalizationCreateRequestDataRelationships } from '../models/BetaAppClipInvocationLocalizationCreateRequestDataRelationships.ts';
import { BetaAppClipInvocationLocalizationCreateRequestDataRelationshipsBetaAppClipInvocation } from '../models/BetaAppClipInvocationLocalizationCreateRequestDataRelationshipsBetaAppClipInvocation.ts';
import { BetaAppClipInvocationLocalizationInlineCreate } from '../models/BetaAppClipInvocationLocalizationInlineCreate.ts';
import { BetaAppClipInvocationLocalizationInlineCreateAttributes } from '../models/BetaAppClipInvocationLocalizationInlineCreateAttributes.ts';
import { BetaAppClipInvocationLocalizationInlineCreateRelationships } from '../models/BetaAppClipInvocationLocalizationInlineCreateRelationships.ts';
import { BetaAppClipInvocationLocalizationInlineCreateRelationshipsBetaAppClipInvocation } from '../models/BetaAppClipInvocationLocalizationInlineCreateRelationshipsBetaAppClipInvocation.ts';
import { BetaAppClipInvocationLocalizationInlineCreateRelationshipsBetaAppClipInvocationData } from '../models/BetaAppClipInvocationLocalizationInlineCreateRelationshipsBetaAppClipInvocationData.ts';
import { BetaAppClipInvocationLocalizationResponse } from '../models/BetaAppClipInvocationLocalizationResponse.ts';
import { BetaAppClipInvocationLocalizationUpdateRequest } from '../models/BetaAppClipInvocationLocalizationUpdateRequest.ts';
import { BetaAppClipInvocationLocalizationUpdateRequestData } from '../models/BetaAppClipInvocationLocalizationUpdateRequestData.ts';
import { BetaAppClipInvocationLocalizationUpdateRequestDataAttributes } from '../models/BetaAppClipInvocationLocalizationUpdateRequestDataAttributes.ts';
import { BetaAppClipInvocationRelationships } from '../models/BetaAppClipInvocationRelationships.ts';
import { BetaAppClipInvocationRelationshipsBetaAppClipInvocationLocalizations } from '../models/BetaAppClipInvocationRelationshipsBetaAppClipInvocationLocalizations.ts';
import { BetaAppClipInvocationRelationshipsBetaAppClipInvocationLocalizationsDataInner } from '../models/BetaAppClipInvocationRelationshipsBetaAppClipInvocationLocalizationsDataInner.ts';
import { BetaAppClipInvocationResponse } from '../models/BetaAppClipInvocationResponse.ts';
import { BetaAppClipInvocationUpdateRequest } from '../models/BetaAppClipInvocationUpdateRequest.ts';
import { BetaAppClipInvocationUpdateRequestData } from '../models/BetaAppClipInvocationUpdateRequestData.ts';
import { BetaAppClipInvocationsResponse } from '../models/BetaAppClipInvocationsResponse.ts';
import { BetaAppLocalization } from '../models/BetaAppLocalization.ts';
import { BetaAppLocalizationAttributes } from '../models/BetaAppLocalizationAttributes.ts';
import { BetaAppLocalizationCreateRequest } from '../models/BetaAppLocalizationCreateRequest.ts';
import { BetaAppLocalizationCreateRequestData } from '../models/BetaAppLocalizationCreateRequestData.ts';
import { BetaAppLocalizationCreateRequestDataAttributes } from '../models/BetaAppLocalizationCreateRequestDataAttributes.ts';
import { BetaAppLocalizationResponse } from '../models/BetaAppLocalizationResponse.ts';
import { BetaAppLocalizationUpdateRequest } from '../models/BetaAppLocalizationUpdateRequest.ts';
import { BetaAppLocalizationUpdateRequestData } from '../models/BetaAppLocalizationUpdateRequestData.ts';
import { BetaAppLocalizationUpdateRequestDataAttributes } from '../models/BetaAppLocalizationUpdateRequestDataAttributes.ts';
import { BetaAppLocalizationsResponse } from '../models/BetaAppLocalizationsResponse.ts';
import { BetaAppLocalizationsWithoutIncludesResponse } from '../models/BetaAppLocalizationsWithoutIncludesResponse.ts';
import { BetaAppReviewDetail } from '../models/BetaAppReviewDetail.ts';
import { BetaAppReviewDetailResponse } from '../models/BetaAppReviewDetailResponse.ts';
import { BetaAppReviewDetailUpdateRequest } from '../models/BetaAppReviewDetailUpdateRequest.ts';
import { BetaAppReviewDetailUpdateRequestData } from '../models/BetaAppReviewDetailUpdateRequestData.ts';
import { BetaAppReviewDetailWithoutIncludesResponse } from '../models/BetaAppReviewDetailWithoutIncludesResponse.ts';
import { BetaAppReviewDetailsResponse } from '../models/BetaAppReviewDetailsResponse.ts';
import { BetaAppReviewSubmission } from '../models/BetaAppReviewSubmission.ts';
import { BetaAppReviewSubmissionAttributes } from '../models/BetaAppReviewSubmissionAttributes.ts';
import { BetaAppReviewSubmissionCreateRequest } from '../models/BetaAppReviewSubmissionCreateRequest.ts';
import { BetaAppReviewSubmissionCreateRequestData } from '../models/BetaAppReviewSubmissionCreateRequestData.ts';
import { BetaAppReviewSubmissionCreateRequestDataRelationships } from '../models/BetaAppReviewSubmissionCreateRequestDataRelationships.ts';
import { BetaAppReviewSubmissionCreateRequestDataRelationshipsBuild } from '../models/BetaAppReviewSubmissionCreateRequestDataRelationshipsBuild.ts';
import { BetaAppReviewSubmissionRelationships } from '../models/BetaAppReviewSubmissionRelationships.ts';
import { BetaAppReviewSubmissionResponse } from '../models/BetaAppReviewSubmissionResponse.ts';
import { BetaAppReviewSubmissionWithoutIncludesResponse } from '../models/BetaAppReviewSubmissionWithoutIncludesResponse.ts';
import { BetaAppReviewSubmissionsResponse } from '../models/BetaAppReviewSubmissionsResponse.ts';
import { BetaBuildLocalization } from '../models/BetaBuildLocalization.ts';
import { BetaBuildLocalizationAttributes } from '../models/BetaBuildLocalizationAttributes.ts';
import { BetaBuildLocalizationCreateRequest } from '../models/BetaBuildLocalizationCreateRequest.ts';
import { BetaBuildLocalizationCreateRequestData } from '../models/BetaBuildLocalizationCreateRequestData.ts';
import { BetaBuildLocalizationCreateRequestDataAttributes } from '../models/BetaBuildLocalizationCreateRequestDataAttributes.ts';
import { BetaBuildLocalizationResponse } from '../models/BetaBuildLocalizationResponse.ts';
import { BetaBuildLocalizationUpdateRequest } from '../models/BetaBuildLocalizationUpdateRequest.ts';
import { BetaBuildLocalizationUpdateRequestData } from '../models/BetaBuildLocalizationUpdateRequestData.ts';
import { BetaBuildLocalizationUpdateRequestDataAttributes } from '../models/BetaBuildLocalizationUpdateRequestDataAttributes.ts';
import { BetaBuildLocalizationsResponse } from '../models/BetaBuildLocalizationsResponse.ts';
import { BetaBuildLocalizationsWithoutIncludesResponse } from '../models/BetaBuildLocalizationsWithoutIncludesResponse.ts';
import { BetaBuildUsagesV1MetricResponse } from '../models/BetaBuildUsagesV1MetricResponse.ts';
import { BetaBuildUsagesV1MetricResponseDataInner } from '../models/BetaBuildUsagesV1MetricResponseDataInner.ts';
import { BetaBuildUsagesV1MetricResponseDataInnerDataPoints } from '../models/BetaBuildUsagesV1MetricResponseDataInnerDataPoints.ts';
import { BetaBuildUsagesV1MetricResponseDataInnerDataPointsValues } from '../models/BetaBuildUsagesV1MetricResponseDataInnerDataPointsValues.ts';
import { BetaBuildUsagesV1MetricResponseDataInnerDimensions } from '../models/BetaBuildUsagesV1MetricResponseDataInnerDimensions.ts';
import { BetaBuildUsagesV1MetricResponseDataInnerDimensionsBundleIds } from '../models/BetaBuildUsagesV1MetricResponseDataInnerDimensionsBundleIds.ts';
import { BetaBuildUsagesV1MetricResponseDataInnerDimensionsBundleIdsLinks } from '../models/BetaBuildUsagesV1MetricResponseDataInnerDimensionsBundleIdsLinks.ts';
import { BetaGroup } from '../models/BetaGroup.ts';
import { BetaGroupAttributes } from '../models/BetaGroupAttributes.ts';
import { BetaGroupBetaTestersLinkagesRequest } from '../models/BetaGroupBetaTestersLinkagesRequest.ts';
import { BetaGroupBetaTestersLinkagesResponse } from '../models/BetaGroupBetaTestersLinkagesResponse.ts';
import { BetaGroupBuildsLinkagesRequest } from '../models/BetaGroupBuildsLinkagesRequest.ts';
import { BetaGroupBuildsLinkagesResponse } from '../models/BetaGroupBuildsLinkagesResponse.ts';
import { BetaGroupCreateRequest } from '../models/BetaGroupCreateRequest.ts';
import { BetaGroupCreateRequestData } from '../models/BetaGroupCreateRequestData.ts';
import { BetaGroupCreateRequestDataAttributes } from '../models/BetaGroupCreateRequestDataAttributes.ts';
import { BetaGroupCreateRequestDataRelationships } from '../models/BetaGroupCreateRequestDataRelationships.ts';
import { BetaGroupCreateRequestDataRelationshipsBetaTesters } from '../models/BetaGroupCreateRequestDataRelationshipsBetaTesters.ts';
import { BetaGroupCreateRequestDataRelationshipsBuilds } from '../models/BetaGroupCreateRequestDataRelationshipsBuilds.ts';
import { BetaGroupRelationships } from '../models/BetaGroupRelationships.ts';
import { BetaGroupRelationshipsBetaTesters } from '../models/BetaGroupRelationshipsBetaTesters.ts';
import { BetaGroupRelationshipsBetaTestersDataInner } from '../models/BetaGroupRelationshipsBetaTestersDataInner.ts';
import { BetaGroupResponse } from '../models/BetaGroupResponse.ts';
import { BetaGroupUpdateRequest } from '../models/BetaGroupUpdateRequest.ts';
import { BetaGroupUpdateRequestData } from '../models/BetaGroupUpdateRequestData.ts';
import { BetaGroupUpdateRequestDataAttributes } from '../models/BetaGroupUpdateRequestDataAttributes.ts';
import { BetaGroupsResponse } from '../models/BetaGroupsResponse.ts';
import { BetaGroupsResponseIncludedInner } from '../models/BetaGroupsResponseIncludedInner.ts';
import { BetaGroupsWithoutIncludesResponse } from '../models/BetaGroupsWithoutIncludesResponse.ts';
import { BetaInviteType } from '../models/BetaInviteType.ts';
import { BetaLicenseAgreement } from '../models/BetaLicenseAgreement.ts';
import { BetaLicenseAgreementAttributes } from '../models/BetaLicenseAgreementAttributes.ts';
import { BetaLicenseAgreementResponse } from '../models/BetaLicenseAgreementResponse.ts';
import { BetaLicenseAgreementUpdateRequest } from '../models/BetaLicenseAgreementUpdateRequest.ts';
import { BetaLicenseAgreementUpdateRequestData } from '../models/BetaLicenseAgreementUpdateRequestData.ts';
import { BetaLicenseAgreementWithoutIncludesResponse } from '../models/BetaLicenseAgreementWithoutIncludesResponse.ts';
import { BetaLicenseAgreementsResponse } from '../models/BetaLicenseAgreementsResponse.ts';
import { BetaReviewState } from '../models/BetaReviewState.ts';
import { BetaTester } from '../models/BetaTester.ts';
import { BetaTesterAppsLinkagesRequest } from '../models/BetaTesterAppsLinkagesRequest.ts';
import { BetaTesterAppsLinkagesResponse } from '../models/BetaTesterAppsLinkagesResponse.ts';
import { BetaTesterAttributes } from '../models/BetaTesterAttributes.ts';
import { BetaTesterBetaGroupsLinkagesRequest } from '../models/BetaTesterBetaGroupsLinkagesRequest.ts';
import { BetaTesterBetaGroupsLinkagesResponse } from '../models/BetaTesterBetaGroupsLinkagesResponse.ts';
import { BetaTesterBuildsLinkagesRequest } from '../models/BetaTesterBuildsLinkagesRequest.ts';
import { BetaTesterBuildsLinkagesResponse } from '../models/BetaTesterBuildsLinkagesResponse.ts';
import { BetaTesterCreateRequest } from '../models/BetaTesterCreateRequest.ts';
import { BetaTesterCreateRequestData } from '../models/BetaTesterCreateRequestData.ts';
import { BetaTesterCreateRequestDataAttributes } from '../models/BetaTesterCreateRequestDataAttributes.ts';
import { BetaTesterCreateRequestDataRelationships } from '../models/BetaTesterCreateRequestDataRelationships.ts';
import { BetaTesterCreateRequestDataRelationshipsBetaGroups } from '../models/BetaTesterCreateRequestDataRelationshipsBetaGroups.ts';
import { BetaTesterInvitation } from '../models/BetaTesterInvitation.ts';
import { BetaTesterInvitationCreateRequest } from '../models/BetaTesterInvitationCreateRequest.ts';
import { BetaTesterInvitationCreateRequestData } from '../models/BetaTesterInvitationCreateRequestData.ts';
import { BetaTesterInvitationCreateRequestDataRelationships } from '../models/BetaTesterInvitationCreateRequestDataRelationships.ts';
import { BetaTesterInvitationCreateRequestDataRelationshipsBetaTester } from '../models/BetaTesterInvitationCreateRequestDataRelationshipsBetaTester.ts';
import { BetaTesterInvitationResponse } from '../models/BetaTesterInvitationResponse.ts';
import { BetaTesterRelationships } from '../models/BetaTesterRelationships.ts';
import { BetaTesterRelationshipsApps } from '../models/BetaTesterRelationshipsApps.ts';
import { BetaTesterResponse } from '../models/BetaTesterResponse.ts';
import { BetaTesterUsagesV1MetricResponse } from '../models/BetaTesterUsagesV1MetricResponse.ts';
import { BetaTesterUsagesV1MetricResponseDataInner } from '../models/BetaTesterUsagesV1MetricResponseDataInner.ts';
import { BetaTesterUsagesV1MetricResponseDataInnerDimensions } from '../models/BetaTesterUsagesV1MetricResponseDataInnerDimensions.ts';
import { BetaTestersResponse } from '../models/BetaTestersResponse.ts';
import { BetaTestersResponseIncludedInner } from '../models/BetaTestersResponseIncludedInner.ts';
import { BetaTestersWithoutIncludesResponse } from '../models/BetaTestersWithoutIncludesResponse.ts';
import { BrazilAgeRating } from '../models/BrazilAgeRating.ts';
import { Build } from '../models/Build.ts';
import { BuildAppEncryptionDeclarationLinkageRequest } from '../models/BuildAppEncryptionDeclarationLinkageRequest.ts';
import { BuildAppEncryptionDeclarationLinkageResponse } from '../models/BuildAppEncryptionDeclarationLinkageResponse.ts';
import { BuildAttributes } from '../models/BuildAttributes.ts';
import { BuildAudienceType } from '../models/BuildAudienceType.ts';
import { BuildBetaDetail } from '../models/BuildBetaDetail.ts';
import { BuildBetaDetailAttributes } from '../models/BuildBetaDetailAttributes.ts';
import { BuildBetaDetailResponse } from '../models/BuildBetaDetailResponse.ts';
import { BuildBetaDetailUpdateRequest } from '../models/BuildBetaDetailUpdateRequest.ts';
import { BuildBetaDetailUpdateRequestData } from '../models/BuildBetaDetailUpdateRequestData.ts';
import { BuildBetaDetailUpdateRequestDataAttributes } from '../models/BuildBetaDetailUpdateRequestDataAttributes.ts';
import { BuildBetaDetailsResponse } from '../models/BuildBetaDetailsResponse.ts';
import { BuildBetaGroupsLinkagesRequest } from '../models/BuildBetaGroupsLinkagesRequest.ts';
import { BuildBetaNotification } from '../models/BuildBetaNotification.ts';
import { BuildBetaNotificationCreateRequest } from '../models/BuildBetaNotificationCreateRequest.ts';
import { BuildBetaNotificationCreateRequestData } from '../models/BuildBetaNotificationCreateRequestData.ts';
import { BuildBetaNotificationResponse } from '../models/BuildBetaNotificationResponse.ts';
import { BuildBundle } from '../models/BuildBundle.ts';
import { BuildBundleAttributes } from '../models/BuildBundleAttributes.ts';
import { BuildBundleFileSize } from '../models/BuildBundleFileSize.ts';
import { BuildBundleFileSizeAttributes } from '../models/BuildBundleFileSizeAttributes.ts';
import { BuildBundleFileSizesResponse } from '../models/BuildBundleFileSizesResponse.ts';
import { BuildBundleRelationships } from '../models/BuildBundleRelationships.ts';
import { BuildBundleRelationshipsAppClipDomainCacheStatus } from '../models/BuildBundleRelationshipsAppClipDomainCacheStatus.ts';
import { BuildBundleRelationshipsAppClipDomainCacheStatusData } from '../models/BuildBundleRelationshipsAppClipDomainCacheStatusData.ts';
import { BuildBundleRelationshipsBetaAppClipInvocations } from '../models/BuildBundleRelationshipsBetaAppClipInvocations.ts';
import { BuildBundleRelationshipsBuildBundleFileSizes } from '../models/BuildBundleRelationshipsBuildBundleFileSizes.ts';
import { BuildBundleRelationshipsBuildBundleFileSizesDataInner } from '../models/BuildBundleRelationshipsBuildBundleFileSizesDataInner.ts';
import { BuildIcon } from '../models/BuildIcon.ts';
import { BuildIconAttributes } from '../models/BuildIconAttributes.ts';
import { BuildIconsResponse } from '../models/BuildIconsResponse.ts';
import { BuildIconsWithoutIncludesResponse } from '../models/BuildIconsWithoutIncludesResponse.ts';
import { BuildIndividualTestersLinkagesRequest } from '../models/BuildIndividualTestersLinkagesRequest.ts';
import { BuildIndividualTestersLinkagesResponse } from '../models/BuildIndividualTestersLinkagesResponse.ts';
import { BuildRelationships } from '../models/BuildRelationships.ts';
import { BuildRelationshipsAppEncryptionDeclaration } from '../models/BuildRelationshipsAppEncryptionDeclaration.ts';
import { BuildRelationshipsBetaAppReviewSubmission } from '../models/BuildRelationshipsBetaAppReviewSubmission.ts';
import { BuildRelationshipsBetaAppReviewSubmissionData } from '../models/BuildRelationshipsBetaAppReviewSubmissionData.ts';
import { BuildRelationshipsBetaBuildLocalizations } from '../models/BuildRelationshipsBetaBuildLocalizations.ts';
import { BuildRelationshipsBetaBuildLocalizationsDataInner } from '../models/BuildRelationshipsBetaBuildLocalizationsDataInner.ts';
import { BuildRelationshipsBuildBetaDetail } from '../models/BuildRelationshipsBuildBetaDetail.ts';
import { BuildRelationshipsBuildBetaDetailData } from '../models/BuildRelationshipsBuildBetaDetailData.ts';
import { BuildRelationshipsBuildBundles } from '../models/BuildRelationshipsBuildBundles.ts';
import { BuildRelationshipsIcons } from '../models/BuildRelationshipsIcons.ts';
import { BuildRelationshipsIconsDataInner } from '../models/BuildRelationshipsIconsDataInner.ts';
import { BuildRelationshipsPreReleaseVersion } from '../models/BuildRelationshipsPreReleaseVersion.ts';
import { BuildResponse } from '../models/BuildResponse.ts';
import { BuildUpdateRequest } from '../models/BuildUpdateRequest.ts';
import { BuildUpdateRequestData } from '../models/BuildUpdateRequestData.ts';
import { BuildUpdateRequestDataAttributes } from '../models/BuildUpdateRequestDataAttributes.ts';
import { BuildUpdateRequestDataRelationships } from '../models/BuildUpdateRequestDataRelationships.ts';
import { BuildUpdateRequestDataRelationshipsAppEncryptionDeclaration } from '../models/BuildUpdateRequestDataRelationshipsAppEncryptionDeclaration.ts';
import { BuildWithoutIncludesResponse } from '../models/BuildWithoutIncludesResponse.ts';
import { BuildsResponse } from '../models/BuildsResponse.ts';
import { BuildsResponseIncludedInner } from '../models/BuildsResponseIncludedInner.ts';
import { BuildsWithoutIncludesResponse } from '../models/BuildsWithoutIncludesResponse.ts';
import { BundleId } from '../models/BundleId.ts';
import { BundleIdAttributes } from '../models/BundleIdAttributes.ts';
import { BundleIdCapabilitiesResponse } from '../models/BundleIdCapabilitiesResponse.ts';
import { BundleIdCapabilitiesWithoutIncludesResponse } from '../models/BundleIdCapabilitiesWithoutIncludesResponse.ts';
import { BundleIdCapability } from '../models/BundleIdCapability.ts';
import { BundleIdCapabilityAttributes } from '../models/BundleIdCapabilityAttributes.ts';
import { BundleIdCapabilityCreateRequest } from '../models/BundleIdCapabilityCreateRequest.ts';
import { BundleIdCapabilityCreateRequestData } from '../models/BundleIdCapabilityCreateRequestData.ts';
import { BundleIdCapabilityCreateRequestDataAttributes } from '../models/BundleIdCapabilityCreateRequestDataAttributes.ts';
import { BundleIdCapabilityCreateRequestDataRelationships } from '../models/BundleIdCapabilityCreateRequestDataRelationships.ts';
import { BundleIdCapabilityCreateRequestDataRelationshipsBundleId } from '../models/BundleIdCapabilityCreateRequestDataRelationshipsBundleId.ts';
import { BundleIdCapabilityCreateRequestDataRelationshipsBundleIdData } from '../models/BundleIdCapabilityCreateRequestDataRelationshipsBundleIdData.ts';
import { BundleIdCapabilityResponse } from '../models/BundleIdCapabilityResponse.ts';
import { BundleIdCapabilityUpdateRequest } from '../models/BundleIdCapabilityUpdateRequest.ts';
import { BundleIdCapabilityUpdateRequestData } from '../models/BundleIdCapabilityUpdateRequestData.ts';
import { BundleIdCreateRequest } from '../models/BundleIdCreateRequest.ts';
import { BundleIdCreateRequestData } from '../models/BundleIdCreateRequestData.ts';
import { BundleIdCreateRequestDataAttributes } from '../models/BundleIdCreateRequestDataAttributes.ts';
import { BundleIdPlatform } from '../models/BundleIdPlatform.ts';
import { BundleIdRelationships } from '../models/BundleIdRelationships.ts';
import { BundleIdRelationshipsBundleIdCapabilities } from '../models/BundleIdRelationshipsBundleIdCapabilities.ts';
import { BundleIdRelationshipsBundleIdCapabilitiesDataInner } from '../models/BundleIdRelationshipsBundleIdCapabilitiesDataInner.ts';
import { BundleIdRelationshipsProfiles } from '../models/BundleIdRelationshipsProfiles.ts';
import { BundleIdRelationshipsProfilesDataInner } from '../models/BundleIdRelationshipsProfilesDataInner.ts';
import { BundleIdResponse } from '../models/BundleIdResponse.ts';
import { BundleIdUpdateRequest } from '../models/BundleIdUpdateRequest.ts';
import { BundleIdUpdateRequestData } from '../models/BundleIdUpdateRequestData.ts';
import { BundleIdUpdateRequestDataAttributes } from '../models/BundleIdUpdateRequestDataAttributes.ts';
import { BundleIdWithoutIncludesResponse } from '../models/BundleIdWithoutIncludesResponse.ts';
import { BundleIdsResponse } from '../models/BundleIdsResponse.ts';
import { BundleIdsResponseIncludedInner } from '../models/BundleIdsResponseIncludedInner.ts';
import { CapabilityOption } from '../models/CapabilityOption.ts';
import { CapabilitySetting } from '../models/CapabilitySetting.ts';
import { CapabilityType } from '../models/CapabilityType.ts';
import { Certificate } from '../models/Certificate.ts';
import { CertificateAttributes } from '../models/CertificateAttributes.ts';
import { CertificateCreateRequest } from '../models/CertificateCreateRequest.ts';
import { CertificateCreateRequestData } from '../models/CertificateCreateRequestData.ts';
import { CertificateCreateRequestDataAttributes } from '../models/CertificateCreateRequestDataAttributes.ts';
import { CertificateResponse } from '../models/CertificateResponse.ts';
import { CertificateType } from '../models/CertificateType.ts';
import { CertificatesResponse } from '../models/CertificatesResponse.ts';
import { CertificatesWithoutIncludesResponse } from '../models/CertificatesWithoutIncludesResponse.ts';
import { CiAction } from '../models/CiAction.ts';
import { CiActionTestConfiguration } from '../models/CiActionTestConfiguration.ts';
import { CiActionType } from '../models/CiActionType.ts';
import { CiArtifact } from '../models/CiArtifact.ts';
import { CiArtifactAttributes } from '../models/CiArtifactAttributes.ts';
import { CiArtifactResponse } from '../models/CiArtifactResponse.ts';
import { CiArtifactsResponse } from '../models/CiArtifactsResponse.ts';
import { CiBranchPatterns } from '../models/CiBranchPatterns.ts';
import { CiBranchPatternsPatternsInner } from '../models/CiBranchPatternsPatternsInner.ts';
import { CiBranchStartCondition } from '../models/CiBranchStartCondition.ts';
import { CiBuildAction } from '../models/CiBuildAction.ts';
import { CiBuildActionAttributes } from '../models/CiBuildActionAttributes.ts';
import { CiBuildActionRelationships } from '../models/CiBuildActionRelationships.ts';
import { CiBuildActionRelationshipsBuildRun } from '../models/CiBuildActionRelationshipsBuildRun.ts';
import { CiBuildActionRelationshipsBuildRunData } from '../models/CiBuildActionRelationshipsBuildRunData.ts';
import { CiBuildActionResponse } from '../models/CiBuildActionResponse.ts';
import { CiBuildActionsResponse } from '../models/CiBuildActionsResponse.ts';
import { CiBuildRun } from '../models/CiBuildRun.ts';
import { CiBuildRunAttributes } from '../models/CiBuildRunAttributes.ts';
import { CiBuildRunAttributesSourceCommit } from '../models/CiBuildRunAttributesSourceCommit.ts';
import { CiBuildRunCreateRequest } from '../models/CiBuildRunCreateRequest.ts';
import { CiBuildRunCreateRequestData } from '../models/CiBuildRunCreateRequestData.ts';
import { CiBuildRunCreateRequestDataAttributes } from '../models/CiBuildRunCreateRequestDataAttributes.ts';
import { CiBuildRunCreateRequestDataRelationships } from '../models/CiBuildRunCreateRequestDataRelationships.ts';
import { CiBuildRunCreateRequestDataRelationshipsBuildRun } from '../models/CiBuildRunCreateRequestDataRelationshipsBuildRun.ts';
import { CiBuildRunCreateRequestDataRelationshipsPullRequest } from '../models/CiBuildRunCreateRequestDataRelationshipsPullRequest.ts';
import { CiBuildRunCreateRequestDataRelationshipsSourceBranchOrTag } from '../models/CiBuildRunCreateRequestDataRelationshipsSourceBranchOrTag.ts';
import { CiBuildRunCreateRequestDataRelationshipsWorkflow } from '../models/CiBuildRunCreateRequestDataRelationshipsWorkflow.ts';
import { CiBuildRunRelationships } from '../models/CiBuildRunRelationships.ts';
import { CiBuildRunRelationshipsPullRequest } from '../models/CiBuildRunRelationshipsPullRequest.ts';
import { CiBuildRunRelationshipsPullRequestData } from '../models/CiBuildRunRelationshipsPullRequestData.ts';
import { CiBuildRunRelationshipsSourceBranchOrTag } from '../models/CiBuildRunRelationshipsSourceBranchOrTag.ts';
import { CiBuildRunRelationshipsSourceBranchOrTagData } from '../models/CiBuildRunRelationshipsSourceBranchOrTagData.ts';
import { CiBuildRunRelationshipsWorkflow } from '../models/CiBuildRunRelationshipsWorkflow.ts';
import { CiBuildRunRelationshipsWorkflowData } from '../models/CiBuildRunRelationshipsWorkflowData.ts';
import { CiBuildRunResponse } from '../models/CiBuildRunResponse.ts';
import { CiBuildRunsResponse } from '../models/CiBuildRunsResponse.ts';
import { CiBuildRunsResponseIncludedInner } from '../models/CiBuildRunsResponseIncludedInner.ts';
import { CiCompletionStatus } from '../models/CiCompletionStatus.ts';
import { CiExecutionProgress } from '../models/CiExecutionProgress.ts';
import { CiFilesAndFoldersRule } from '../models/CiFilesAndFoldersRule.ts';
import { CiGitRefKind } from '../models/CiGitRefKind.ts';
import { CiGitUser } from '../models/CiGitUser.ts';
import { CiIssue } from '../models/CiIssue.ts';
import { CiIssueAttributes } from '../models/CiIssueAttributes.ts';
import { CiIssueCounts } from '../models/CiIssueCounts.ts';
import { CiIssueResponse } from '../models/CiIssueResponse.ts';
import { CiIssuesResponse } from '../models/CiIssuesResponse.ts';
import { CiMacOsVersion } from '../models/CiMacOsVersion.ts';
import { CiMacOsVersionAttributes } from '../models/CiMacOsVersionAttributes.ts';
import { CiMacOsVersionRelationships } from '../models/CiMacOsVersionRelationships.ts';
import { CiMacOsVersionRelationshipsXcodeVersions } from '../models/CiMacOsVersionRelationshipsXcodeVersions.ts';
import { CiMacOsVersionRelationshipsXcodeVersionsDataInner } from '../models/CiMacOsVersionRelationshipsXcodeVersionsDataInner.ts';
import { CiMacOsVersionResponse } from '../models/CiMacOsVersionResponse.ts';
import { CiMacOsVersionsResponse } from '../models/CiMacOsVersionsResponse.ts';
import { CiManualBranchStartCondition } from '../models/CiManualBranchStartCondition.ts';
import { CiManualPullRequestStartCondition } from '../models/CiManualPullRequestStartCondition.ts';
import { CiManualTagStartCondition } from '../models/CiManualTagStartCondition.ts';
import { CiProduct } from '../models/CiProduct.ts';
import { CiProductAttributes } from '../models/CiProductAttributes.ts';
import { CiProductRelationships } from '../models/CiProductRelationships.ts';
import { CiProductRelationshipsBundleId } from '../models/CiProductRelationshipsBundleId.ts';
import { CiProductRelationshipsPrimaryRepositories } from '../models/CiProductRelationshipsPrimaryRepositories.ts';
import { CiProductRelationshipsPrimaryRepositoriesDataInner } from '../models/CiProductRelationshipsPrimaryRepositoriesDataInner.ts';
import { CiProductResponse } from '../models/CiProductResponse.ts';
import { CiProductsResponse } from '../models/CiProductsResponse.ts';
import { CiProductsResponseIncludedInner } from '../models/CiProductsResponseIncludedInner.ts';
import { CiPullRequestStartCondition } from '../models/CiPullRequestStartCondition.ts';
import { CiScheduledStartCondition } from '../models/CiScheduledStartCondition.ts';
import { CiScheduledStartConditionSchedule } from '../models/CiScheduledStartConditionSchedule.ts';
import { CiStartConditionFileMatcher } from '../models/CiStartConditionFileMatcher.ts';
import { CiTagPatterns } from '../models/CiTagPatterns.ts';
import { CiTagStartCondition } from '../models/CiTagStartCondition.ts';
import { CiTestDestination } from '../models/CiTestDestination.ts';
import { CiTestDestinationKind } from '../models/CiTestDestinationKind.ts';
import { CiTestResult } from '../models/CiTestResult.ts';
import { CiTestResultAttributes } from '../models/CiTestResultAttributes.ts';
import { CiTestResultAttributesDestinationTestResultsInner } from '../models/CiTestResultAttributesDestinationTestResultsInner.ts';
import { CiTestResultResponse } from '../models/CiTestResultResponse.ts';
import { CiTestResultsResponse } from '../models/CiTestResultsResponse.ts';
import { CiTestStatus } from '../models/CiTestStatus.ts';
import { CiWorkflow } from '../models/CiWorkflow.ts';
import { CiWorkflowAttributes } from '../models/CiWorkflowAttributes.ts';
import { CiWorkflowCreateRequest } from '../models/CiWorkflowCreateRequest.ts';
import { CiWorkflowCreateRequestData } from '../models/CiWorkflowCreateRequestData.ts';
import { CiWorkflowCreateRequestDataAttributes } from '../models/CiWorkflowCreateRequestDataAttributes.ts';
import { CiWorkflowCreateRequestDataRelationships } from '../models/CiWorkflowCreateRequestDataRelationships.ts';
import { CiWorkflowCreateRequestDataRelationshipsMacOsVersion } from '../models/CiWorkflowCreateRequestDataRelationshipsMacOsVersion.ts';
import { CiWorkflowCreateRequestDataRelationshipsProduct } from '../models/CiWorkflowCreateRequestDataRelationshipsProduct.ts';
import { CiWorkflowCreateRequestDataRelationshipsRepository } from '../models/CiWorkflowCreateRequestDataRelationshipsRepository.ts';
import { CiWorkflowCreateRequestDataRelationshipsXcodeVersion } from '../models/CiWorkflowCreateRequestDataRelationshipsXcodeVersion.ts';
import { CiWorkflowRelationships } from '../models/CiWorkflowRelationships.ts';
import { CiWorkflowRelationshipsMacOsVersion } from '../models/CiWorkflowRelationshipsMacOsVersion.ts';
import { CiWorkflowRelationshipsMacOsVersionData } from '../models/CiWorkflowRelationshipsMacOsVersionData.ts';
import { CiWorkflowRelationshipsRepository } from '../models/CiWorkflowRelationshipsRepository.ts';
import { CiWorkflowRelationshipsXcodeVersion } from '../models/CiWorkflowRelationshipsXcodeVersion.ts';
import { CiWorkflowResponse } from '../models/CiWorkflowResponse.ts';
import { CiWorkflowUpdateRequest } from '../models/CiWorkflowUpdateRequest.ts';
import { CiWorkflowUpdateRequestData } from '../models/CiWorkflowUpdateRequestData.ts';
import { CiWorkflowUpdateRequestDataAttributes } from '../models/CiWorkflowUpdateRequestDataAttributes.ts';
import { CiWorkflowUpdateRequestDataRelationships } from '../models/CiWorkflowUpdateRequestDataRelationships.ts';
import { CiWorkflowUpdateRequestDataRelationshipsMacOsVersion } from '../models/CiWorkflowUpdateRequestDataRelationshipsMacOsVersion.ts';
import { CiWorkflowUpdateRequestDataRelationshipsXcodeVersion } from '../models/CiWorkflowUpdateRequestDataRelationshipsXcodeVersion.ts';
import { CiWorkflowsResponse } from '../models/CiWorkflowsResponse.ts';
import { CiWorkflowsResponseIncludedInner } from '../models/CiWorkflowsResponseIncludedInner.ts';
import { CiXcodeVersion } from '../models/CiXcodeVersion.ts';
import { CiXcodeVersionAttributes } from '../models/CiXcodeVersionAttributes.ts';
import { CiXcodeVersionAttributesTestDestinationsInner } from '../models/CiXcodeVersionAttributesTestDestinationsInner.ts';
import { CiXcodeVersionAttributesTestDestinationsInnerAvailableRuntimesInner } from '../models/CiXcodeVersionAttributesTestDestinationsInnerAvailableRuntimesInner.ts';
import { CiXcodeVersionRelationships } from '../models/CiXcodeVersionRelationships.ts';
import { CiXcodeVersionRelationshipsMacOsVersions } from '../models/CiXcodeVersionRelationshipsMacOsVersions.ts';
import { CiXcodeVersionResponse } from '../models/CiXcodeVersionResponse.ts';
import { CiXcodeVersionsResponse } from '../models/CiXcodeVersionsResponse.ts';
import { CustomerReview } from '../models/CustomerReview.ts';
import { CustomerReviewAttributes } from '../models/CustomerReviewAttributes.ts';
import { CustomerReviewRelationships } from '../models/CustomerReviewRelationships.ts';
import { CustomerReviewRelationshipsResponse } from '../models/CustomerReviewRelationshipsResponse.ts';
import { CustomerReviewRelationshipsResponseData } from '../models/CustomerReviewRelationshipsResponseData.ts';
import { CustomerReviewResponse } from '../models/CustomerReviewResponse.ts';
import { CustomerReviewResponseV1 } from '../models/CustomerReviewResponseV1.ts';
import { CustomerReviewResponseV1Attributes } from '../models/CustomerReviewResponseV1Attributes.ts';
import { CustomerReviewResponseV1CreateRequest } from '../models/CustomerReviewResponseV1CreateRequest.ts';
import { CustomerReviewResponseV1CreateRequestData } from '../models/CustomerReviewResponseV1CreateRequestData.ts';
import { CustomerReviewResponseV1CreateRequestDataAttributes } from '../models/CustomerReviewResponseV1CreateRequestDataAttributes.ts';
import { CustomerReviewResponseV1CreateRequestDataRelationships } from '../models/CustomerReviewResponseV1CreateRequestDataRelationships.ts';
import { CustomerReviewResponseV1CreateRequestDataRelationshipsReview } from '../models/CustomerReviewResponseV1CreateRequestDataRelationshipsReview.ts';
import { CustomerReviewResponseV1Relationships } from '../models/CustomerReviewResponseV1Relationships.ts';
import { CustomerReviewResponseV1RelationshipsReview } from '../models/CustomerReviewResponseV1RelationshipsReview.ts';
import { CustomerReviewResponseV1RelationshipsReviewData } from '../models/CustomerReviewResponseV1RelationshipsReviewData.ts';
import { CustomerReviewResponseV1Response } from '../models/CustomerReviewResponseV1Response.ts';
import { CustomerReviewsResponse } from '../models/CustomerReviewsResponse.ts';
import { Device } from '../models/Device.ts';
import { DeviceAttributes } from '../models/DeviceAttributes.ts';
import { DeviceCreateRequest } from '../models/DeviceCreateRequest.ts';
import { DeviceCreateRequestData } from '../models/DeviceCreateRequestData.ts';
import { DeviceCreateRequestDataAttributes } from '../models/DeviceCreateRequestDataAttributes.ts';
import { DeviceResponse } from '../models/DeviceResponse.ts';
import { DeviceUpdateRequest } from '../models/DeviceUpdateRequest.ts';
import { DeviceUpdateRequestData } from '../models/DeviceUpdateRequestData.ts';
import { DeviceUpdateRequestDataAttributes } from '../models/DeviceUpdateRequestDataAttributes.ts';
import { DevicesResponse } from '../models/DevicesResponse.ts';
import { DevicesWithoutIncludesResponse } from '../models/DevicesWithoutIncludesResponse.ts';
import { DiagnosticLog } from '../models/DiagnosticLog.ts';
import { DiagnosticLogCallStackNode } from '../models/DiagnosticLogCallStackNode.ts';
import { DiagnosticLogs } from '../models/DiagnosticLogs.ts';
import { DiagnosticLogsProductDataInner } from '../models/DiagnosticLogsProductDataInner.ts';
import { DiagnosticLogsProductDataInnerDiagnosticInsightsInner } from '../models/DiagnosticLogsProductDataInnerDiagnosticInsightsInner.ts';
import { DiagnosticLogsProductDataInnerDiagnosticLogsInner } from '../models/DiagnosticLogsProductDataInnerDiagnosticLogsInner.ts';
import { DiagnosticLogsProductDataInnerDiagnosticLogsInnerCallStackTreeInner } from '../models/DiagnosticLogsProductDataInnerDiagnosticLogsInnerCallStackTreeInner.ts';
import { DiagnosticLogsProductDataInnerDiagnosticLogsInnerCallStackTreeInnerCallStacksInner } from '../models/DiagnosticLogsProductDataInnerDiagnosticLogsInnerCallStackTreeInnerCallStacksInner.ts';
import { DiagnosticLogsProductDataInnerDiagnosticLogsInnerDiagnosticMetaData } from '../models/DiagnosticLogsProductDataInnerDiagnosticLogsInnerDiagnosticMetaData.ts';
import { DiagnosticSignature } from '../models/DiagnosticSignature.ts';
import { DiagnosticSignatureAttributes } from '../models/DiagnosticSignatureAttributes.ts';
import { DiagnosticSignaturesResponse } from '../models/DiagnosticSignaturesResponse.ts';
import { DocumentLinks } from '../models/DocumentLinks.ts';
import { EndAppAvailabilityPreOrder } from '../models/EndAppAvailabilityPreOrder.ts';
import { EndAppAvailabilityPreOrderCreateRequest } from '../models/EndAppAvailabilityPreOrderCreateRequest.ts';
import { EndAppAvailabilityPreOrderCreateRequestData } from '../models/EndAppAvailabilityPreOrderCreateRequestData.ts';
import { EndAppAvailabilityPreOrderCreateRequestDataRelationships } from '../models/EndAppAvailabilityPreOrderCreateRequestDataRelationships.ts';
import { EndAppAvailabilityPreOrderResponse } from '../models/EndAppAvailabilityPreOrderResponse.ts';
import { EndUserLicenseAgreement } from '../models/EndUserLicenseAgreement.ts';
import { EndUserLicenseAgreementCreateRequest } from '../models/EndUserLicenseAgreementCreateRequest.ts';
import { EndUserLicenseAgreementCreateRequestData } from '../models/EndUserLicenseAgreementCreateRequestData.ts';
import { EndUserLicenseAgreementCreateRequestDataAttributes } from '../models/EndUserLicenseAgreementCreateRequestDataAttributes.ts';
import { EndUserLicenseAgreementCreateRequestDataRelationships } from '../models/EndUserLicenseAgreementCreateRequestDataRelationships.ts';
import { EndUserLicenseAgreementRelationships } from '../models/EndUserLicenseAgreementRelationships.ts';
import { EndUserLicenseAgreementResponse } from '../models/EndUserLicenseAgreementResponse.ts';
import { EndUserLicenseAgreementUpdateRequest } from '../models/EndUserLicenseAgreementUpdateRequest.ts';
import { EndUserLicenseAgreementUpdateRequestData } from '../models/EndUserLicenseAgreementUpdateRequestData.ts';
import { EndUserLicenseAgreementUpdateRequestDataRelationships } from '../models/EndUserLicenseAgreementUpdateRequestDataRelationships.ts';
import { EndUserLicenseAgreementUpdateRequestDataRelationshipsTerritories } from '../models/EndUserLicenseAgreementUpdateRequestDataRelationshipsTerritories.ts';
import { EndUserLicenseAgreementWithoutIncludesResponse } from '../models/EndUserLicenseAgreementWithoutIncludesResponse.ts';
import { ErrorResponse } from '../models/ErrorResponse.ts';
import { ErrorResponseErrorsInner } from '../models/ErrorResponseErrorsInner.ts';
import { ErrorResponseErrorsInnerSource } from '../models/ErrorResponseErrorsInnerSource.ts';
import { ErrorSourceParameter } from '../models/ErrorSourceParameter.ts';
import { ErrorSourcePointer } from '../models/ErrorSourcePointer.ts';
import { ExternalBetaState } from '../models/ExternalBetaState.ts';
import { FileLocation } from '../models/FileLocation.ts';
import { GameCenterAchievement } from '../models/GameCenterAchievement.ts';
import { GameCenterAchievementAttributes } from '../models/GameCenterAchievementAttributes.ts';
import { GameCenterAchievementCreateRequest } from '../models/GameCenterAchievementCreateRequest.ts';
import { GameCenterAchievementCreateRequestData } from '../models/GameCenterAchievementCreateRequestData.ts';
import { GameCenterAchievementCreateRequestDataAttributes } from '../models/GameCenterAchievementCreateRequestDataAttributes.ts';
import { GameCenterAchievementCreateRequestDataRelationships } from '../models/GameCenterAchievementCreateRequestDataRelationships.ts';
import { GameCenterAchievementCreateRequestDataRelationshipsGameCenterDetail } from '../models/GameCenterAchievementCreateRequestDataRelationshipsGameCenterDetail.ts';
import { GameCenterAchievementCreateRequestDataRelationshipsGameCenterGroup } from '../models/GameCenterAchievementCreateRequestDataRelationshipsGameCenterGroup.ts';
import { GameCenterAchievementGroupAchievementLinkageRequest } from '../models/GameCenterAchievementGroupAchievementLinkageRequest.ts';
import { GameCenterAchievementGroupAchievementLinkageResponse } from '../models/GameCenterAchievementGroupAchievementLinkageResponse.ts';
import { GameCenterAchievementImage } from '../models/GameCenterAchievementImage.ts';
import { GameCenterAchievementImageAttributes } from '../models/GameCenterAchievementImageAttributes.ts';
import { GameCenterAchievementImageCreateRequest } from '../models/GameCenterAchievementImageCreateRequest.ts';
import { GameCenterAchievementImageCreateRequestData } from '../models/GameCenterAchievementImageCreateRequestData.ts';
import { GameCenterAchievementImageCreateRequestDataRelationships } from '../models/GameCenterAchievementImageCreateRequestDataRelationships.ts';
import { GameCenterAchievementImageCreateRequestDataRelationshipsGameCenterAchievementLocalization } from '../models/GameCenterAchievementImageCreateRequestDataRelationshipsGameCenterAchievementLocalization.ts';
import { GameCenterAchievementImageRelationships } from '../models/GameCenterAchievementImageRelationships.ts';
import { GameCenterAchievementImageRelationshipsGameCenterAchievementLocalization } from '../models/GameCenterAchievementImageRelationshipsGameCenterAchievementLocalization.ts';
import { GameCenterAchievementImageRelationshipsGameCenterAchievementLocalizationData } from '../models/GameCenterAchievementImageRelationshipsGameCenterAchievementLocalizationData.ts';
import { GameCenterAchievementImageResponse } from '../models/GameCenterAchievementImageResponse.ts';
import { GameCenterAchievementImageUpdateRequest } from '../models/GameCenterAchievementImageUpdateRequest.ts';
import { GameCenterAchievementImageUpdateRequestData } from '../models/GameCenterAchievementImageUpdateRequestData.ts';
import { GameCenterAchievementLocalization } from '../models/GameCenterAchievementLocalization.ts';
import { GameCenterAchievementLocalizationAttributes } from '../models/GameCenterAchievementLocalizationAttributes.ts';
import { GameCenterAchievementLocalizationCreateRequest } from '../models/GameCenterAchievementLocalizationCreateRequest.ts';
import { GameCenterAchievementLocalizationCreateRequestData } from '../models/GameCenterAchievementLocalizationCreateRequestData.ts';
import { GameCenterAchievementLocalizationCreateRequestDataAttributes } from '../models/GameCenterAchievementLocalizationCreateRequestDataAttributes.ts';
import { GameCenterAchievementLocalizationCreateRequestDataRelationships } from '../models/GameCenterAchievementLocalizationCreateRequestDataRelationships.ts';
import { GameCenterAchievementLocalizationCreateRequestDataRelationshipsGameCenterAchievement } from '../models/GameCenterAchievementLocalizationCreateRequestDataRelationshipsGameCenterAchievement.ts';
import { GameCenterAchievementLocalizationRelationships } from '../models/GameCenterAchievementLocalizationRelationships.ts';
import { GameCenterAchievementLocalizationRelationshipsGameCenterAchievement } from '../models/GameCenterAchievementLocalizationRelationshipsGameCenterAchievement.ts';
import { GameCenterAchievementLocalizationRelationshipsGameCenterAchievementData } from '../models/GameCenterAchievementLocalizationRelationshipsGameCenterAchievementData.ts';
import { GameCenterAchievementLocalizationRelationshipsGameCenterAchievementImage } from '../models/GameCenterAchievementLocalizationRelationshipsGameCenterAchievementImage.ts';
import { GameCenterAchievementLocalizationRelationshipsGameCenterAchievementImageData } from '../models/GameCenterAchievementLocalizationRelationshipsGameCenterAchievementImageData.ts';
import { GameCenterAchievementLocalizationResponse } from '../models/GameCenterAchievementLocalizationResponse.ts';
import { GameCenterAchievementLocalizationUpdateRequest } from '../models/GameCenterAchievementLocalizationUpdateRequest.ts';
import { GameCenterAchievementLocalizationUpdateRequestData } from '../models/GameCenterAchievementLocalizationUpdateRequestData.ts';
import { GameCenterAchievementLocalizationUpdateRequestDataAttributes } from '../models/GameCenterAchievementLocalizationUpdateRequestDataAttributes.ts';
import { GameCenterAchievementLocalizationsResponse } from '../models/GameCenterAchievementLocalizationsResponse.ts';
import { GameCenterAchievementLocalizationsResponseIncludedInner } from '../models/GameCenterAchievementLocalizationsResponseIncludedInner.ts';
import { GameCenterAchievementRelationships } from '../models/GameCenterAchievementRelationships.ts';
import { GameCenterAchievementRelationshipsGameCenterGroup } from '../models/GameCenterAchievementRelationshipsGameCenterGroup.ts';
import { GameCenterAchievementRelationshipsGameCenterGroupData } from '../models/GameCenterAchievementRelationshipsGameCenterGroupData.ts';
import { GameCenterAchievementRelationshipsLocalizations } from '../models/GameCenterAchievementRelationshipsLocalizations.ts';
import { GameCenterAchievementRelationshipsReleases } from '../models/GameCenterAchievementRelationshipsReleases.ts';
import { GameCenterAchievementRelationshipsReleasesDataInner } from '../models/GameCenterAchievementRelationshipsReleasesDataInner.ts';
import { GameCenterAchievementRelease } from '../models/GameCenterAchievementRelease.ts';
import { GameCenterAchievementReleaseAttributes } from '../models/GameCenterAchievementReleaseAttributes.ts';
import { GameCenterAchievementReleaseCreateRequest } from '../models/GameCenterAchievementReleaseCreateRequest.ts';
import { GameCenterAchievementReleaseCreateRequestData } from '../models/GameCenterAchievementReleaseCreateRequestData.ts';
import { GameCenterAchievementReleaseCreateRequestDataRelationships } from '../models/GameCenterAchievementReleaseCreateRequestDataRelationships.ts';
import { GameCenterAchievementReleaseCreateRequestDataRelationshipsGameCenterDetail } from '../models/GameCenterAchievementReleaseCreateRequestDataRelationshipsGameCenterDetail.ts';
import { GameCenterAchievementReleaseRelationships } from '../models/GameCenterAchievementReleaseRelationships.ts';
import { GameCenterAchievementReleaseResponse } from '../models/GameCenterAchievementReleaseResponse.ts';
import { GameCenterAchievementReleasesResponse } from '../models/GameCenterAchievementReleasesResponse.ts';
import { GameCenterAchievementReleasesResponseIncludedInner } from '../models/GameCenterAchievementReleasesResponseIncludedInner.ts';
import { GameCenterAchievementResponse } from '../models/GameCenterAchievementResponse.ts';
import { GameCenterAchievementUpdateRequest } from '../models/GameCenterAchievementUpdateRequest.ts';
import { GameCenterAchievementUpdateRequestData } from '../models/GameCenterAchievementUpdateRequestData.ts';
import { GameCenterAchievementUpdateRequestDataAttributes } from '../models/GameCenterAchievementUpdateRequestDataAttributes.ts';
import { GameCenterAchievementsResponse } from '../models/GameCenterAchievementsResponse.ts';
import { GameCenterAchievementsResponseIncludedInner } from '../models/GameCenterAchievementsResponseIncludedInner.ts';
import { GameCenterAppVersion } from '../models/GameCenterAppVersion.ts';
import { GameCenterAppVersionAttributes } from '../models/GameCenterAppVersionAttributes.ts';
import { GameCenterAppVersionCompatibilityVersionsLinkagesRequest } from '../models/GameCenterAppVersionCompatibilityVersionsLinkagesRequest.ts';
import { GameCenterAppVersionCompatibilityVersionsLinkagesResponse } from '../models/GameCenterAppVersionCompatibilityVersionsLinkagesResponse.ts';
import { GameCenterAppVersionCreateRequest } from '../models/GameCenterAppVersionCreateRequest.ts';
import { GameCenterAppVersionCreateRequestData } from '../models/GameCenterAppVersionCreateRequestData.ts';
import { GameCenterAppVersionRelationships } from '../models/GameCenterAppVersionRelationships.ts';
import { GameCenterAppVersionRelationshipsCompatibilityVersions } from '../models/GameCenterAppVersionRelationshipsCompatibilityVersions.ts';
import { GameCenterAppVersionRelationshipsCompatibilityVersionsDataInner } from '../models/GameCenterAppVersionRelationshipsCompatibilityVersionsDataInner.ts';
import { GameCenterAppVersionResponse } from '../models/GameCenterAppVersionResponse.ts';
import { GameCenterAppVersionUpdateRequest } from '../models/GameCenterAppVersionUpdateRequest.ts';
import { GameCenterAppVersionUpdateRequestData } from '../models/GameCenterAppVersionUpdateRequestData.ts';
import { GameCenterAppVersionsResponse } from '../models/GameCenterAppVersionsResponse.ts';
import { GameCenterAppVersionsResponseIncludedInner } from '../models/GameCenterAppVersionsResponseIncludedInner.ts';
import { GameCenterDetail } from '../models/GameCenterDetail.ts';
import { GameCenterDetailAttributes } from '../models/GameCenterDetailAttributes.ts';
import { GameCenterDetailCreateRequest } from '../models/GameCenterDetailCreateRequest.ts';
import { GameCenterDetailCreateRequestData } from '../models/GameCenterDetailCreateRequestData.ts';
import { GameCenterDetailCreateRequestDataAttributes } from '../models/GameCenterDetailCreateRequestDataAttributes.ts';
import { GameCenterDetailGameCenterAchievementsLinkagesRequest } from '../models/GameCenterDetailGameCenterAchievementsLinkagesRequest.ts';
import { GameCenterDetailGameCenterAchievementsLinkagesResponse } from '../models/GameCenterDetailGameCenterAchievementsLinkagesResponse.ts';
import { GameCenterDetailGameCenterLeaderboardSetsLinkagesRequest } from '../models/GameCenterDetailGameCenterLeaderboardSetsLinkagesRequest.ts';
import { GameCenterDetailGameCenterLeaderboardSetsLinkagesResponse } from '../models/GameCenterDetailGameCenterLeaderboardSetsLinkagesResponse.ts';
import { GameCenterDetailGameCenterLeaderboardsLinkagesRequest } from '../models/GameCenterDetailGameCenterLeaderboardsLinkagesRequest.ts';
import { GameCenterDetailGameCenterLeaderboardsLinkagesResponse } from '../models/GameCenterDetailGameCenterLeaderboardsLinkagesResponse.ts';
import { GameCenterDetailRelationships } from '../models/GameCenterDetailRelationships.ts';
import { GameCenterDetailRelationshipsDefaultLeaderboard } from '../models/GameCenterDetailRelationshipsDefaultLeaderboard.ts';
import { GameCenterDetailRelationshipsGameCenterAchievements } from '../models/GameCenterDetailRelationshipsGameCenterAchievements.ts';
import { GameCenterDetailRelationshipsGameCenterLeaderboardSets } from '../models/GameCenterDetailRelationshipsGameCenterLeaderboardSets.ts';
import { GameCenterDetailRelationshipsGameCenterLeaderboardSetsDataInner } from '../models/GameCenterDetailRelationshipsGameCenterLeaderboardSetsDataInner.ts';
import { GameCenterDetailRelationshipsGameCenterLeaderboards } from '../models/GameCenterDetailRelationshipsGameCenterLeaderboards.ts';
import { GameCenterDetailRelationshipsGameCenterLeaderboardsDataInner } from '../models/GameCenterDetailRelationshipsGameCenterLeaderboardsDataInner.ts';
import { GameCenterDetailRelationshipsLeaderboardReleases } from '../models/GameCenterDetailRelationshipsLeaderboardReleases.ts';
import { GameCenterDetailRelationshipsLeaderboardReleasesDataInner } from '../models/GameCenterDetailRelationshipsLeaderboardReleasesDataInner.ts';
import { GameCenterDetailRelationshipsLeaderboardSetReleases } from '../models/GameCenterDetailRelationshipsLeaderboardSetReleases.ts';
import { GameCenterDetailRelationshipsLeaderboardSetReleasesDataInner } from '../models/GameCenterDetailRelationshipsLeaderboardSetReleasesDataInner.ts';
import { GameCenterDetailResponse } from '../models/GameCenterDetailResponse.ts';
import { GameCenterDetailUpdateRequest } from '../models/GameCenterDetailUpdateRequest.ts';
import { GameCenterDetailUpdateRequestData } from '../models/GameCenterDetailUpdateRequestData.ts';
import { GameCenterDetailUpdateRequestDataRelationships } from '../models/GameCenterDetailUpdateRequestDataRelationships.ts';
import { GameCenterDetailUpdateRequestDataRelationshipsDefaultLeaderboard } from '../models/GameCenterDetailUpdateRequestDataRelationshipsDefaultLeaderboard.ts';
import { GameCenterDetailsResponse } from '../models/GameCenterDetailsResponse.ts';
import { GameCenterDetailsResponseIncludedInner } from '../models/GameCenterDetailsResponseIncludedInner.ts';
import { GameCenterEnabledVersion } from '../models/GameCenterEnabledVersion.ts';
import { GameCenterEnabledVersionAttributes } from '../models/GameCenterEnabledVersionAttributes.ts';
import { GameCenterEnabledVersionCompatibleVersionsLinkagesRequest } from '../models/GameCenterEnabledVersionCompatibleVersionsLinkagesRequest.ts';
import { GameCenterEnabledVersionCompatibleVersionsLinkagesResponse } from '../models/GameCenterEnabledVersionCompatibleVersionsLinkagesResponse.ts';
import { GameCenterEnabledVersionRelationships } from '../models/GameCenterEnabledVersionRelationships.ts';
import { GameCenterEnabledVersionsResponse } from '../models/GameCenterEnabledVersionsResponse.ts';
import { GameCenterEnabledVersionsResponseIncludedInner } from '../models/GameCenterEnabledVersionsResponseIncludedInner.ts';
import { GameCenterGroup } from '../models/GameCenterGroup.ts';
import { GameCenterGroupAttributes } from '../models/GameCenterGroupAttributes.ts';
import { GameCenterGroupCreateRequest } from '../models/GameCenterGroupCreateRequest.ts';
import { GameCenterGroupCreateRequestData } from '../models/GameCenterGroupCreateRequestData.ts';
import { GameCenterGroupGameCenterAchievementsLinkagesRequest } from '../models/GameCenterGroupGameCenterAchievementsLinkagesRequest.ts';
import { GameCenterGroupGameCenterAchievementsLinkagesResponse } from '../models/GameCenterGroupGameCenterAchievementsLinkagesResponse.ts';
import { GameCenterGroupGameCenterLeaderboardSetsLinkagesRequest } from '../models/GameCenterGroupGameCenterLeaderboardSetsLinkagesRequest.ts';
import { GameCenterGroupGameCenterLeaderboardSetsLinkagesResponse } from '../models/GameCenterGroupGameCenterLeaderboardSetsLinkagesResponse.ts';
import { GameCenterGroupGameCenterLeaderboardsLinkagesRequest } from '../models/GameCenterGroupGameCenterLeaderboardsLinkagesRequest.ts';
import { GameCenterGroupGameCenterLeaderboardsLinkagesResponse } from '../models/GameCenterGroupGameCenterLeaderboardsLinkagesResponse.ts';
import { GameCenterGroupRelationships } from '../models/GameCenterGroupRelationships.ts';
import { GameCenterGroupRelationshipsGameCenterDetails } from '../models/GameCenterGroupRelationshipsGameCenterDetails.ts';
import { GameCenterGroupResponse } from '../models/GameCenterGroupResponse.ts';
import { GameCenterGroupUpdateRequest } from '../models/GameCenterGroupUpdateRequest.ts';
import { GameCenterGroupUpdateRequestData } from '../models/GameCenterGroupUpdateRequestData.ts';
import { GameCenterGroupsResponse } from '../models/GameCenterGroupsResponse.ts';
import { GameCenterGroupsResponseIncludedInner } from '../models/GameCenterGroupsResponseIncludedInner.ts';
import { GameCenterLeaderboard } from '../models/GameCenterLeaderboard.ts';
import { GameCenterLeaderboardAttributes } from '../models/GameCenterLeaderboardAttributes.ts';
import { GameCenterLeaderboardCreateRequest } from '../models/GameCenterLeaderboardCreateRequest.ts';
import { GameCenterLeaderboardCreateRequestData } from '../models/GameCenterLeaderboardCreateRequestData.ts';
import { GameCenterLeaderboardCreateRequestDataAttributes } from '../models/GameCenterLeaderboardCreateRequestDataAttributes.ts';
import { GameCenterLeaderboardCreateRequestDataRelationships } from '../models/GameCenterLeaderboardCreateRequestDataRelationships.ts';
import { GameCenterLeaderboardCreateRequestDataRelationshipsGameCenterLeaderboardSets } from '../models/GameCenterLeaderboardCreateRequestDataRelationshipsGameCenterLeaderboardSets.ts';
import { GameCenterLeaderboardEntrySubmission } from '../models/GameCenterLeaderboardEntrySubmission.ts';
import { GameCenterLeaderboardEntrySubmissionAttributes } from '../models/GameCenterLeaderboardEntrySubmissionAttributes.ts';
import { GameCenterLeaderboardEntrySubmissionCreateRequest } from '../models/GameCenterLeaderboardEntrySubmissionCreateRequest.ts';
import { GameCenterLeaderboardEntrySubmissionCreateRequestData } from '../models/GameCenterLeaderboardEntrySubmissionCreateRequestData.ts';
import { GameCenterLeaderboardEntrySubmissionCreateRequestDataAttributes } from '../models/GameCenterLeaderboardEntrySubmissionCreateRequestDataAttributes.ts';
import { GameCenterLeaderboardEntrySubmissionResponse } from '../models/GameCenterLeaderboardEntrySubmissionResponse.ts';
import { GameCenterLeaderboardFormatter } from '../models/GameCenterLeaderboardFormatter.ts';
import { GameCenterLeaderboardGroupLeaderboardLinkageRequest } from '../models/GameCenterLeaderboardGroupLeaderboardLinkageRequest.ts';
import { GameCenterLeaderboardGroupLeaderboardLinkageResponse } from '../models/GameCenterLeaderboardGroupLeaderboardLinkageResponse.ts';
import { GameCenterLeaderboardImage } from '../models/GameCenterLeaderboardImage.ts';
import { GameCenterLeaderboardImageCreateRequest } from '../models/GameCenterLeaderboardImageCreateRequest.ts';
import { GameCenterLeaderboardImageCreateRequestData } from '../models/GameCenterLeaderboardImageCreateRequestData.ts';
import { GameCenterLeaderboardImageCreateRequestDataRelationships } from '../models/GameCenterLeaderboardImageCreateRequestDataRelationships.ts';
import { GameCenterLeaderboardImageCreateRequestDataRelationshipsGameCenterLeaderboardLocalization } from '../models/GameCenterLeaderboardImageCreateRequestDataRelationshipsGameCenterLeaderboardLocalization.ts';
import { GameCenterLeaderboardImageRelationships } from '../models/GameCenterLeaderboardImageRelationships.ts';
import { GameCenterLeaderboardImageRelationshipsGameCenterLeaderboardLocalization } from '../models/GameCenterLeaderboardImageRelationshipsGameCenterLeaderboardLocalization.ts';
import { GameCenterLeaderboardImageRelationshipsGameCenterLeaderboardLocalizationData } from '../models/GameCenterLeaderboardImageRelationshipsGameCenterLeaderboardLocalizationData.ts';
import { GameCenterLeaderboardImageResponse } from '../models/GameCenterLeaderboardImageResponse.ts';
import { GameCenterLeaderboardImageUpdateRequest } from '../models/GameCenterLeaderboardImageUpdateRequest.ts';
import { GameCenterLeaderboardImageUpdateRequestData } from '../models/GameCenterLeaderboardImageUpdateRequestData.ts';
import { GameCenterLeaderboardLocalization } from '../models/GameCenterLeaderboardLocalization.ts';
import { GameCenterLeaderboardLocalizationAttributes } from '../models/GameCenterLeaderboardLocalizationAttributes.ts';
import { GameCenterLeaderboardLocalizationCreateRequest } from '../models/GameCenterLeaderboardLocalizationCreateRequest.ts';
import { GameCenterLeaderboardLocalizationCreateRequestData } from '../models/GameCenterLeaderboardLocalizationCreateRequestData.ts';
import { GameCenterLeaderboardLocalizationCreateRequestDataAttributes } from '../models/GameCenterLeaderboardLocalizationCreateRequestDataAttributes.ts';
import { GameCenterLeaderboardLocalizationCreateRequestDataRelationships } from '../models/GameCenterLeaderboardLocalizationCreateRequestDataRelationships.ts';
import { GameCenterLeaderboardLocalizationCreateRequestDataRelationshipsGameCenterLeaderboard } from '../models/GameCenterLeaderboardLocalizationCreateRequestDataRelationshipsGameCenterLeaderboard.ts';
import { GameCenterLeaderboardLocalizationRelationships } from '../models/GameCenterLeaderboardLocalizationRelationships.ts';
import { GameCenterLeaderboardLocalizationRelationshipsGameCenterLeaderboardImage } from '../models/GameCenterLeaderboardLocalizationRelationshipsGameCenterLeaderboardImage.ts';
import { GameCenterLeaderboardLocalizationRelationshipsGameCenterLeaderboardImageData } from '../models/GameCenterLeaderboardLocalizationRelationshipsGameCenterLeaderboardImageData.ts';
import { GameCenterLeaderboardLocalizationResponse } from '../models/GameCenterLeaderboardLocalizationResponse.ts';
import { GameCenterLeaderboardLocalizationUpdateRequest } from '../models/GameCenterLeaderboardLocalizationUpdateRequest.ts';
import { GameCenterLeaderboardLocalizationUpdateRequestData } from '../models/GameCenterLeaderboardLocalizationUpdateRequestData.ts';
import { GameCenterLeaderboardLocalizationUpdateRequestDataAttributes } from '../models/GameCenterLeaderboardLocalizationUpdateRequestDataAttributes.ts';
import { GameCenterLeaderboardLocalizationsResponse } from '../models/GameCenterLeaderboardLocalizationsResponse.ts';
import { GameCenterLeaderboardLocalizationsResponseIncludedInner } from '../models/GameCenterLeaderboardLocalizationsResponseIncludedInner.ts';
import { GameCenterLeaderboardRelationships } from '../models/GameCenterLeaderboardRelationships.ts';
import { GameCenterLeaderboardRelationshipsLocalizations } from '../models/GameCenterLeaderboardRelationshipsLocalizations.ts';
import { GameCenterLeaderboardRelease } from '../models/GameCenterLeaderboardRelease.ts';
import { GameCenterLeaderboardReleaseCreateRequest } from '../models/GameCenterLeaderboardReleaseCreateRequest.ts';
import { GameCenterLeaderboardReleaseCreateRequestData } from '../models/GameCenterLeaderboardReleaseCreateRequestData.ts';
import { GameCenterLeaderboardReleaseCreateRequestDataRelationships } from '../models/GameCenterLeaderboardReleaseCreateRequestDataRelationships.ts';
import { GameCenterLeaderboardReleaseRelationships } from '../models/GameCenterLeaderboardReleaseRelationships.ts';
import { GameCenterLeaderboardReleaseResponse } from '../models/GameCenterLeaderboardReleaseResponse.ts';
import { GameCenterLeaderboardReleasesResponse } from '../models/GameCenterLeaderboardReleasesResponse.ts';
import { GameCenterLeaderboardReleasesResponseIncludedInner } from '../models/GameCenterLeaderboardReleasesResponseIncludedInner.ts';
import { GameCenterLeaderboardResponse } from '../models/GameCenterLeaderboardResponse.ts';
import { GameCenterLeaderboardSet } from '../models/GameCenterLeaderboardSet.ts';
import { GameCenterLeaderboardSetAttributes } from '../models/GameCenterLeaderboardSetAttributes.ts';
import { GameCenterLeaderboardSetCreateRequest } from '../models/GameCenterLeaderboardSetCreateRequest.ts';
import { GameCenterLeaderboardSetCreateRequestData } from '../models/GameCenterLeaderboardSetCreateRequestData.ts';
import { GameCenterLeaderboardSetCreateRequestDataAttributes } from '../models/GameCenterLeaderboardSetCreateRequestDataAttributes.ts';
import { GameCenterLeaderboardSetCreateRequestDataRelationships } from '../models/GameCenterLeaderboardSetCreateRequestDataRelationships.ts';
import { GameCenterLeaderboardSetCreateRequestDataRelationshipsGameCenterLeaderboards } from '../models/GameCenterLeaderboardSetCreateRequestDataRelationshipsGameCenterLeaderboards.ts';
import { GameCenterLeaderboardSetGameCenterLeaderboardsLinkagesRequest } from '../models/GameCenterLeaderboardSetGameCenterLeaderboardsLinkagesRequest.ts';
import { GameCenterLeaderboardSetGameCenterLeaderboardsLinkagesResponse } from '../models/GameCenterLeaderboardSetGameCenterLeaderboardsLinkagesResponse.ts';
import { GameCenterLeaderboardSetGroupLeaderboardSetLinkageRequest } from '../models/GameCenterLeaderboardSetGroupLeaderboardSetLinkageRequest.ts';
import { GameCenterLeaderboardSetGroupLeaderboardSetLinkageResponse } from '../models/GameCenterLeaderboardSetGroupLeaderboardSetLinkageResponse.ts';
import { GameCenterLeaderboardSetImage } from '../models/GameCenterLeaderboardSetImage.ts';
import { GameCenterLeaderboardSetImageCreateRequest } from '../models/GameCenterLeaderboardSetImageCreateRequest.ts';
import { GameCenterLeaderboardSetImageCreateRequestData } from '../models/GameCenterLeaderboardSetImageCreateRequestData.ts';
import { GameCenterLeaderboardSetImageCreateRequestDataRelationships } from '../models/GameCenterLeaderboardSetImageCreateRequestDataRelationships.ts';
import { GameCenterLeaderboardSetImageCreateRequestDataRelationshipsGameCenterLeaderboardSetLocalization } from '../models/GameCenterLeaderboardSetImageCreateRequestDataRelationshipsGameCenterLeaderboardSetLocalization.ts';
import { GameCenterLeaderboardSetImageRelationships } from '../models/GameCenterLeaderboardSetImageRelationships.ts';
import { GameCenterLeaderboardSetImageRelationshipsGameCenterLeaderboardSetLocalization } from '../models/GameCenterLeaderboardSetImageRelationshipsGameCenterLeaderboardSetLocalization.ts';
import { GameCenterLeaderboardSetImageRelationshipsGameCenterLeaderboardSetLocalizationData } from '../models/GameCenterLeaderboardSetImageRelationshipsGameCenterLeaderboardSetLocalizationData.ts';
import { GameCenterLeaderboardSetImageResponse } from '../models/GameCenterLeaderboardSetImageResponse.ts';
import { GameCenterLeaderboardSetImageUpdateRequest } from '../models/GameCenterLeaderboardSetImageUpdateRequest.ts';
import { GameCenterLeaderboardSetImageUpdateRequestData } from '../models/GameCenterLeaderboardSetImageUpdateRequestData.ts';
import { GameCenterLeaderboardSetLocalization } from '../models/GameCenterLeaderboardSetLocalization.ts';
import { GameCenterLeaderboardSetLocalizationAttributes } from '../models/GameCenterLeaderboardSetLocalizationAttributes.ts';
import { GameCenterLeaderboardSetLocalizationCreateRequest } from '../models/GameCenterLeaderboardSetLocalizationCreateRequest.ts';
import { GameCenterLeaderboardSetLocalizationCreateRequestData } from '../models/GameCenterLeaderboardSetLocalizationCreateRequestData.ts';
import { GameCenterLeaderboardSetLocalizationCreateRequestDataAttributes } from '../models/GameCenterLeaderboardSetLocalizationCreateRequestDataAttributes.ts';
import { GameCenterLeaderboardSetLocalizationCreateRequestDataRelationships } from '../models/GameCenterLeaderboardSetLocalizationCreateRequestDataRelationships.ts';
import { GameCenterLeaderboardSetLocalizationCreateRequestDataRelationshipsGameCenterLeaderboardSet } from '../models/GameCenterLeaderboardSetLocalizationCreateRequestDataRelationshipsGameCenterLeaderboardSet.ts';
import { GameCenterLeaderboardSetLocalizationRelationships } from '../models/GameCenterLeaderboardSetLocalizationRelationships.ts';
import { GameCenterLeaderboardSetLocalizationRelationshipsGameCenterLeaderboardSet } from '../models/GameCenterLeaderboardSetLocalizationRelationshipsGameCenterLeaderboardSet.ts';
import { GameCenterLeaderboardSetLocalizationRelationshipsGameCenterLeaderboardSetImage } from '../models/GameCenterLeaderboardSetLocalizationRelationshipsGameCenterLeaderboardSetImage.ts';
import { GameCenterLeaderboardSetLocalizationRelationshipsGameCenterLeaderboardSetImageData } from '../models/GameCenterLeaderboardSetLocalizationRelationshipsGameCenterLeaderboardSetImageData.ts';
import { GameCenterLeaderboardSetLocalizationResponse } from '../models/GameCenterLeaderboardSetLocalizationResponse.ts';
import { GameCenterLeaderboardSetLocalizationUpdateRequest } from '../models/GameCenterLeaderboardSetLocalizationUpdateRequest.ts';
import { GameCenterLeaderboardSetLocalizationUpdateRequestData } from '../models/GameCenterLeaderboardSetLocalizationUpdateRequestData.ts';
import { GameCenterLeaderboardSetLocalizationsResponse } from '../models/GameCenterLeaderboardSetLocalizationsResponse.ts';
import { GameCenterLeaderboardSetLocalizationsResponseIncludedInner } from '../models/GameCenterLeaderboardSetLocalizationsResponseIncludedInner.ts';
import { GameCenterLeaderboardSetMemberLocalization } from '../models/GameCenterLeaderboardSetMemberLocalization.ts';
import { GameCenterLeaderboardSetMemberLocalizationAttributes } from '../models/GameCenterLeaderboardSetMemberLocalizationAttributes.ts';
import { GameCenterLeaderboardSetMemberLocalizationCreateRequest } from '../models/GameCenterLeaderboardSetMemberLocalizationCreateRequest.ts';
import { GameCenterLeaderboardSetMemberLocalizationCreateRequestData } from '../models/GameCenterLeaderboardSetMemberLocalizationCreateRequestData.ts';
import { GameCenterLeaderboardSetMemberLocalizationCreateRequestDataRelationships } from '../models/GameCenterLeaderboardSetMemberLocalizationCreateRequestDataRelationships.ts';
import { GameCenterLeaderboardSetMemberLocalizationRelationships } from '../models/GameCenterLeaderboardSetMemberLocalizationRelationships.ts';
import { GameCenterLeaderboardSetMemberLocalizationResponse } from '../models/GameCenterLeaderboardSetMemberLocalizationResponse.ts';
import { GameCenterLeaderboardSetMemberLocalizationUpdateRequest } from '../models/GameCenterLeaderboardSetMemberLocalizationUpdateRequest.ts';
import { GameCenterLeaderboardSetMemberLocalizationUpdateRequestData } from '../models/GameCenterLeaderboardSetMemberLocalizationUpdateRequestData.ts';
import { GameCenterLeaderboardSetMemberLocalizationsResponse } from '../models/GameCenterLeaderboardSetMemberLocalizationsResponse.ts';
import { GameCenterLeaderboardSetMemberLocalizationsResponseIncludedInner } from '../models/GameCenterLeaderboardSetMemberLocalizationsResponseIncludedInner.ts';
import { GameCenterLeaderboardSetRelationships } from '../models/GameCenterLeaderboardSetRelationships.ts';
import { GameCenterLeaderboardSetRelationshipsLocalizations } from '../models/GameCenterLeaderboardSetRelationshipsLocalizations.ts';
import { GameCenterLeaderboardSetRelease } from '../models/GameCenterLeaderboardSetRelease.ts';
import { GameCenterLeaderboardSetReleaseCreateRequest } from '../models/GameCenterLeaderboardSetReleaseCreateRequest.ts';
import { GameCenterLeaderboardSetReleaseCreateRequestData } from '../models/GameCenterLeaderboardSetReleaseCreateRequestData.ts';
import { GameCenterLeaderboardSetReleaseCreateRequestDataRelationships } from '../models/GameCenterLeaderboardSetReleaseCreateRequestDataRelationships.ts';
import { GameCenterLeaderboardSetReleaseRelationships } from '../models/GameCenterLeaderboardSetReleaseRelationships.ts';
import { GameCenterLeaderboardSetReleaseResponse } from '../models/GameCenterLeaderboardSetReleaseResponse.ts';
import { GameCenterLeaderboardSetReleasesResponse } from '../models/GameCenterLeaderboardSetReleasesResponse.ts';
import { GameCenterLeaderboardSetReleasesResponseIncludedInner } from '../models/GameCenterLeaderboardSetReleasesResponseIncludedInner.ts';
import { GameCenterLeaderboardSetResponse } from '../models/GameCenterLeaderboardSetResponse.ts';
import { GameCenterLeaderboardSetUpdateRequest } from '../models/GameCenterLeaderboardSetUpdateRequest.ts';
import { GameCenterLeaderboardSetUpdateRequestData } from '../models/GameCenterLeaderboardSetUpdateRequestData.ts';
import { GameCenterLeaderboardSetsResponse } from '../models/GameCenterLeaderboardSetsResponse.ts';
import { GameCenterLeaderboardSetsResponseIncludedInner } from '../models/GameCenterLeaderboardSetsResponseIncludedInner.ts';
import { GameCenterLeaderboardUpdateRequest } from '../models/GameCenterLeaderboardUpdateRequest.ts';
import { GameCenterLeaderboardUpdateRequestData } from '../models/GameCenterLeaderboardUpdateRequestData.ts';
import { GameCenterLeaderboardUpdateRequestDataAttributes } from '../models/GameCenterLeaderboardUpdateRequestDataAttributes.ts';
import { GameCenterLeaderboardsResponse } from '../models/GameCenterLeaderboardsResponse.ts';
import { GameCenterLeaderboardsResponseIncludedInner } from '../models/GameCenterLeaderboardsResponseIncludedInner.ts';
import { GameCenterMatchmakingAppRequestsV1MetricResponse } from '../models/GameCenterMatchmakingAppRequestsV1MetricResponse.ts';
import { GameCenterMatchmakingAppRequestsV1MetricResponseDataInner } from '../models/GameCenterMatchmakingAppRequestsV1MetricResponseDataInner.ts';
import { GameCenterMatchmakingAppRequestsV1MetricResponseDataInnerDataPoints } from '../models/GameCenterMatchmakingAppRequestsV1MetricResponseDataInnerDataPoints.ts';
import { GameCenterMatchmakingAppRequestsV1MetricResponseDataInnerDataPointsValues } from '../models/GameCenterMatchmakingAppRequestsV1MetricResponseDataInnerDataPointsValues.ts';
import { GameCenterMatchmakingAppRequestsV1MetricResponseDataInnerDimensions } from '../models/GameCenterMatchmakingAppRequestsV1MetricResponseDataInnerDimensions.ts';
import { GameCenterMatchmakingBooleanRuleResultsV1MetricResponse } from '../models/GameCenterMatchmakingBooleanRuleResultsV1MetricResponse.ts';
import { GameCenterMatchmakingBooleanRuleResultsV1MetricResponseDataInner } from '../models/GameCenterMatchmakingBooleanRuleResultsV1MetricResponseDataInner.ts';
import { GameCenterMatchmakingBooleanRuleResultsV1MetricResponseDataInnerDataPoints } from '../models/GameCenterMatchmakingBooleanRuleResultsV1MetricResponseDataInnerDataPoints.ts';
import { GameCenterMatchmakingBooleanRuleResultsV1MetricResponseDataInnerDataPointsValues } from '../models/GameCenterMatchmakingBooleanRuleResultsV1MetricResponseDataInnerDataPointsValues.ts';
import { GameCenterMatchmakingBooleanRuleResultsV1MetricResponseDataInnerDimensions } from '../models/GameCenterMatchmakingBooleanRuleResultsV1MetricResponseDataInnerDimensions.ts';
import { GameCenterMatchmakingNumberRuleResultsV1MetricResponse } from '../models/GameCenterMatchmakingNumberRuleResultsV1MetricResponse.ts';
import { GameCenterMatchmakingNumberRuleResultsV1MetricResponseDataInner } from '../models/GameCenterMatchmakingNumberRuleResultsV1MetricResponseDataInner.ts';
import { GameCenterMatchmakingNumberRuleResultsV1MetricResponseDataInnerDataPoints } from '../models/GameCenterMatchmakingNumberRuleResultsV1MetricResponseDataInnerDataPoints.ts';
import { GameCenterMatchmakingNumberRuleResultsV1MetricResponseDataInnerDataPointsValues } from '../models/GameCenterMatchmakingNumberRuleResultsV1MetricResponseDataInnerDataPointsValues.ts';
import { GameCenterMatchmakingNumberRuleResultsV1MetricResponseDataInnerDimensions } from '../models/GameCenterMatchmakingNumberRuleResultsV1MetricResponseDataInnerDimensions.ts';
import { GameCenterMatchmakingQueue } from '../models/GameCenterMatchmakingQueue.ts';
import { GameCenterMatchmakingQueueAttributes } from '../models/GameCenterMatchmakingQueueAttributes.ts';
import { GameCenterMatchmakingQueueCreateRequest } from '../models/GameCenterMatchmakingQueueCreateRequest.ts';
import { GameCenterMatchmakingQueueCreateRequestData } from '../models/GameCenterMatchmakingQueueCreateRequestData.ts';
import { GameCenterMatchmakingQueueCreateRequestDataAttributes } from '../models/GameCenterMatchmakingQueueCreateRequestDataAttributes.ts';
import { GameCenterMatchmakingQueueCreateRequestDataRelationships } from '../models/GameCenterMatchmakingQueueCreateRequestDataRelationships.ts';
import { GameCenterMatchmakingQueueCreateRequestDataRelationshipsExperimentRuleSet } from '../models/GameCenterMatchmakingQueueCreateRequestDataRelationshipsExperimentRuleSet.ts';
import { GameCenterMatchmakingQueueCreateRequestDataRelationshipsRuleSet } from '../models/GameCenterMatchmakingQueueCreateRequestDataRelationshipsRuleSet.ts';
import { GameCenterMatchmakingQueueRelationships } from '../models/GameCenterMatchmakingQueueRelationships.ts';
import { GameCenterMatchmakingQueueRelationshipsRuleSet } from '../models/GameCenterMatchmakingQueueRelationshipsRuleSet.ts';
import { GameCenterMatchmakingQueueRelationshipsRuleSetData } from '../models/GameCenterMatchmakingQueueRelationshipsRuleSetData.ts';
import { GameCenterMatchmakingQueueRequestsV1MetricResponse } from '../models/GameCenterMatchmakingQueueRequestsV1MetricResponse.ts';
import { GameCenterMatchmakingQueueRequestsV1MetricResponseDataInner } from '../models/GameCenterMatchmakingQueueRequestsV1MetricResponseDataInner.ts';
import { GameCenterMatchmakingQueueRequestsV1MetricResponseDataInnerDimensions } from '../models/GameCenterMatchmakingQueueRequestsV1MetricResponseDataInnerDimensions.ts';
import { GameCenterMatchmakingQueueResponse } from '../models/GameCenterMatchmakingQueueResponse.ts';
import { GameCenterMatchmakingQueueSizesV1MetricResponse } from '../models/GameCenterMatchmakingQueueSizesV1MetricResponse.ts';
import { GameCenterMatchmakingQueueSizesV1MetricResponseDataInner } from '../models/GameCenterMatchmakingQueueSizesV1MetricResponseDataInner.ts';
import { GameCenterMatchmakingQueueSizesV1MetricResponseDataInnerDataPoints } from '../models/GameCenterMatchmakingQueueSizesV1MetricResponseDataInnerDataPoints.ts';
import { GameCenterMatchmakingQueueSizesV1MetricResponseDataInnerDataPointsValues } from '../models/GameCenterMatchmakingQueueSizesV1MetricResponseDataInnerDataPointsValues.ts';
import { GameCenterMatchmakingQueueUpdateRequest } from '../models/GameCenterMatchmakingQueueUpdateRequest.ts';
import { GameCenterMatchmakingQueueUpdateRequestData } from '../models/GameCenterMatchmakingQueueUpdateRequestData.ts';
import { GameCenterMatchmakingQueueUpdateRequestDataAttributes } from '../models/GameCenterMatchmakingQueueUpdateRequestDataAttributes.ts';
import { GameCenterMatchmakingQueueUpdateRequestDataRelationships } from '../models/GameCenterMatchmakingQueueUpdateRequestDataRelationships.ts';
import { GameCenterMatchmakingQueuesResponse } from '../models/GameCenterMatchmakingQueuesResponse.ts';
import { GameCenterMatchmakingRule } from '../models/GameCenterMatchmakingRule.ts';
import { GameCenterMatchmakingRuleAttributes } from '../models/GameCenterMatchmakingRuleAttributes.ts';
import { GameCenterMatchmakingRuleCreateRequest } from '../models/GameCenterMatchmakingRuleCreateRequest.ts';
import { GameCenterMatchmakingRuleCreateRequestData } from '../models/GameCenterMatchmakingRuleCreateRequestData.ts';
import { GameCenterMatchmakingRuleCreateRequestDataAttributes } from '../models/GameCenterMatchmakingRuleCreateRequestDataAttributes.ts';
import { GameCenterMatchmakingRuleCreateRequestDataRelationships } from '../models/GameCenterMatchmakingRuleCreateRequestDataRelationships.ts';
import { GameCenterMatchmakingRuleErrorsV1MetricResponse } from '../models/GameCenterMatchmakingRuleErrorsV1MetricResponse.ts';
import { GameCenterMatchmakingRuleErrorsV1MetricResponseDataInner } from '../models/GameCenterMatchmakingRuleErrorsV1MetricResponseDataInner.ts';
import { GameCenterMatchmakingRuleResponse } from '../models/GameCenterMatchmakingRuleResponse.ts';
import { GameCenterMatchmakingRuleSet } from '../models/GameCenterMatchmakingRuleSet.ts';
import { GameCenterMatchmakingRuleSetAttributes } from '../models/GameCenterMatchmakingRuleSetAttributes.ts';
import { GameCenterMatchmakingRuleSetCreateRequest } from '../models/GameCenterMatchmakingRuleSetCreateRequest.ts';
import { GameCenterMatchmakingRuleSetCreateRequestData } from '../models/GameCenterMatchmakingRuleSetCreateRequestData.ts';
import { GameCenterMatchmakingRuleSetCreateRequestDataAttributes } from '../models/GameCenterMatchmakingRuleSetCreateRequestDataAttributes.ts';
import { GameCenterMatchmakingRuleSetRelationships } from '../models/GameCenterMatchmakingRuleSetRelationships.ts';
import { GameCenterMatchmakingRuleSetRelationshipsMatchmakingQueues } from '../models/GameCenterMatchmakingRuleSetRelationshipsMatchmakingQueues.ts';
import { GameCenterMatchmakingRuleSetRelationshipsMatchmakingQueuesDataInner } from '../models/GameCenterMatchmakingRuleSetRelationshipsMatchmakingQueuesDataInner.ts';
import { GameCenterMatchmakingRuleSetRelationshipsRules } from '../models/GameCenterMatchmakingRuleSetRelationshipsRules.ts';
import { GameCenterMatchmakingRuleSetRelationshipsRulesDataInner } from '../models/GameCenterMatchmakingRuleSetRelationshipsRulesDataInner.ts';
import { GameCenterMatchmakingRuleSetRelationshipsTeams } from '../models/GameCenterMatchmakingRuleSetRelationshipsTeams.ts';
import { GameCenterMatchmakingRuleSetRelationshipsTeamsDataInner } from '../models/GameCenterMatchmakingRuleSetRelationshipsTeamsDataInner.ts';
import { GameCenterMatchmakingRuleSetResponse } from '../models/GameCenterMatchmakingRuleSetResponse.ts';
import { GameCenterMatchmakingRuleSetTest } from '../models/GameCenterMatchmakingRuleSetTest.ts';
import { GameCenterMatchmakingRuleSetTestAttributes } from '../models/GameCenterMatchmakingRuleSetTestAttributes.ts';
import { GameCenterMatchmakingRuleSetTestAttributesMatchmakingResultsInnerInner } from '../models/GameCenterMatchmakingRuleSetTestAttributesMatchmakingResultsInnerInner.ts';
import { GameCenterMatchmakingRuleSetTestCreateRequest } from '../models/GameCenterMatchmakingRuleSetTestCreateRequest.ts';
import { GameCenterMatchmakingRuleSetTestCreateRequestData } from '../models/GameCenterMatchmakingRuleSetTestCreateRequestData.ts';
import { GameCenterMatchmakingRuleSetTestCreateRequestDataRelationships } from '../models/GameCenterMatchmakingRuleSetTestCreateRequestDataRelationships.ts';
import { GameCenterMatchmakingRuleSetTestCreateRequestDataRelationshipsMatchmakingRequests } from '../models/GameCenterMatchmakingRuleSetTestCreateRequestDataRelationshipsMatchmakingRequests.ts';
import { GameCenterMatchmakingRuleSetTestCreateRequestDataRelationshipsMatchmakingRequestsDataInner } from '../models/GameCenterMatchmakingRuleSetTestCreateRequestDataRelationshipsMatchmakingRequestsDataInner.ts';
import { GameCenterMatchmakingRuleSetTestCreateRequestIncludedInner } from '../models/GameCenterMatchmakingRuleSetTestCreateRequestIncludedInner.ts';
import { GameCenterMatchmakingRuleSetTestResponse } from '../models/GameCenterMatchmakingRuleSetTestResponse.ts';
import { GameCenterMatchmakingRuleSetUpdateRequest } from '../models/GameCenterMatchmakingRuleSetUpdateRequest.ts';
import { GameCenterMatchmakingRuleSetUpdateRequestData } from '../models/GameCenterMatchmakingRuleSetUpdateRequestData.ts';
import { GameCenterMatchmakingRuleSetUpdateRequestDataAttributes } from '../models/GameCenterMatchmakingRuleSetUpdateRequestDataAttributes.ts';
import { GameCenterMatchmakingRuleSetsResponse } from '../models/GameCenterMatchmakingRuleSetsResponse.ts';
import { GameCenterMatchmakingRuleSetsResponseIncludedInner } from '../models/GameCenterMatchmakingRuleSetsResponseIncludedInner.ts';
import { GameCenterMatchmakingRuleUpdateRequest } from '../models/GameCenterMatchmakingRuleUpdateRequest.ts';
import { GameCenterMatchmakingRuleUpdateRequestData } from '../models/GameCenterMatchmakingRuleUpdateRequestData.ts';
import { GameCenterMatchmakingRuleUpdateRequestDataAttributes } from '../models/GameCenterMatchmakingRuleUpdateRequestDataAttributes.ts';
import { GameCenterMatchmakingRulesResponse } from '../models/GameCenterMatchmakingRulesResponse.ts';
import { GameCenterMatchmakingSessionsV1MetricResponse } from '../models/GameCenterMatchmakingSessionsV1MetricResponse.ts';
import { GameCenterMatchmakingSessionsV1MetricResponseDataInner } from '../models/GameCenterMatchmakingSessionsV1MetricResponseDataInner.ts';
import { GameCenterMatchmakingSessionsV1MetricResponseDataInnerDataPoints } from '../models/GameCenterMatchmakingSessionsV1MetricResponseDataInnerDataPoints.ts';
import { GameCenterMatchmakingSessionsV1MetricResponseDataInnerDataPointsValues } from '../models/GameCenterMatchmakingSessionsV1MetricResponseDataInnerDataPointsValues.ts';
import { GameCenterMatchmakingTeam } from '../models/GameCenterMatchmakingTeam.ts';
import { GameCenterMatchmakingTeamAssignment } from '../models/GameCenterMatchmakingTeamAssignment.ts';
import { GameCenterMatchmakingTeamAttributes } from '../models/GameCenterMatchmakingTeamAttributes.ts';
import { GameCenterMatchmakingTeamCreateRequest } from '../models/GameCenterMatchmakingTeamCreateRequest.ts';
import { GameCenterMatchmakingTeamCreateRequestData } from '../models/GameCenterMatchmakingTeamCreateRequestData.ts';
import { GameCenterMatchmakingTeamCreateRequestDataAttributes } from '../models/GameCenterMatchmakingTeamCreateRequestDataAttributes.ts';
import { GameCenterMatchmakingTeamResponse } from '../models/GameCenterMatchmakingTeamResponse.ts';
import { GameCenterMatchmakingTeamUpdateRequest } from '../models/GameCenterMatchmakingTeamUpdateRequest.ts';
import { GameCenterMatchmakingTeamUpdateRequestData } from '../models/GameCenterMatchmakingTeamUpdateRequestData.ts';
import { GameCenterMatchmakingTeamsResponse } from '../models/GameCenterMatchmakingTeamsResponse.ts';
import { GameCenterMatchmakingTestPlayerPropertyInlineCreate } from '../models/GameCenterMatchmakingTestPlayerPropertyInlineCreate.ts';
import { GameCenterMatchmakingTestPlayerPropertyInlineCreateAttributes } from '../models/GameCenterMatchmakingTestPlayerPropertyInlineCreateAttributes.ts';
import { GameCenterMatchmakingTestRequestInlineCreate } from '../models/GameCenterMatchmakingTestRequestInlineCreate.ts';
import { GameCenterMatchmakingTestRequestInlineCreateAttributes } from '../models/GameCenterMatchmakingTestRequestInlineCreateAttributes.ts';
import { GameCenterMatchmakingTestRequestInlineCreateRelationships } from '../models/GameCenterMatchmakingTestRequestInlineCreateRelationships.ts';
import { GameCenterMatchmakingTestRequestInlineCreateRelationshipsMatchmakingPlayerProperties } from '../models/GameCenterMatchmakingTestRequestInlineCreateRelationshipsMatchmakingPlayerProperties.ts';
import { GameCenterMatchmakingTestRequestInlineCreateRelationshipsMatchmakingPlayerPropertiesDataInner } from '../models/GameCenterMatchmakingTestRequestInlineCreateRelationshipsMatchmakingPlayerPropertiesDataInner.ts';
import { GameCenterPlayerAchievementSubmission } from '../models/GameCenterPlayerAchievementSubmission.ts';
import { GameCenterPlayerAchievementSubmissionAttributes } from '../models/GameCenterPlayerAchievementSubmissionAttributes.ts';
import { GameCenterPlayerAchievementSubmissionCreateRequest } from '../models/GameCenterPlayerAchievementSubmissionCreateRequest.ts';
import { GameCenterPlayerAchievementSubmissionCreateRequestData } from '../models/GameCenterPlayerAchievementSubmissionCreateRequestData.ts';
import { GameCenterPlayerAchievementSubmissionCreateRequestDataAttributes } from '../models/GameCenterPlayerAchievementSubmissionCreateRequestDataAttributes.ts';
import { GameCenterPlayerAchievementSubmissionResponse } from '../models/GameCenterPlayerAchievementSubmissionResponse.ts';
import { HttpHeader } from '../models/HttpHeader.ts';
import { IconAssetType } from '../models/IconAssetType.ts';
import { ImageAsset } from '../models/ImageAsset.ts';
import { InAppPurchase } from '../models/InAppPurchase.ts';
import { InAppPurchaseAppStoreReviewScreenshot } from '../models/InAppPurchaseAppStoreReviewScreenshot.ts';
import { InAppPurchaseAppStoreReviewScreenshotCreateRequest } from '../models/InAppPurchaseAppStoreReviewScreenshotCreateRequest.ts';
import { InAppPurchaseAppStoreReviewScreenshotCreateRequestData } from '../models/InAppPurchaseAppStoreReviewScreenshotCreateRequestData.ts';
import { InAppPurchaseAppStoreReviewScreenshotCreateRequestDataRelationships } from '../models/InAppPurchaseAppStoreReviewScreenshotCreateRequestDataRelationships.ts';
import { InAppPurchaseAppStoreReviewScreenshotCreateRequestDataRelationshipsInAppPurchaseV2 } from '../models/InAppPurchaseAppStoreReviewScreenshotCreateRequestDataRelationshipsInAppPurchaseV2.ts';
import { InAppPurchaseAppStoreReviewScreenshotRelationships } from '../models/InAppPurchaseAppStoreReviewScreenshotRelationships.ts';
import { InAppPurchaseAppStoreReviewScreenshotRelationshipsInAppPurchaseV2 } from '../models/InAppPurchaseAppStoreReviewScreenshotRelationshipsInAppPurchaseV2.ts';
import { InAppPurchaseAppStoreReviewScreenshotResponse } from '../models/InAppPurchaseAppStoreReviewScreenshotResponse.ts';
import { InAppPurchaseAppStoreReviewScreenshotUpdateRequest } from '../models/InAppPurchaseAppStoreReviewScreenshotUpdateRequest.ts';
import { InAppPurchaseAppStoreReviewScreenshotUpdateRequestData } from '../models/InAppPurchaseAppStoreReviewScreenshotUpdateRequestData.ts';
import { InAppPurchaseAttributes } from '../models/InAppPurchaseAttributes.ts';
import { InAppPurchaseAvailability } from '../models/InAppPurchaseAvailability.ts';
import { InAppPurchaseAvailabilityCreateRequest } from '../models/InAppPurchaseAvailabilityCreateRequest.ts';
import { InAppPurchaseAvailabilityCreateRequestData } from '../models/InAppPurchaseAvailabilityCreateRequestData.ts';
import { InAppPurchaseAvailabilityCreateRequestDataRelationships } from '../models/InAppPurchaseAvailabilityCreateRequestDataRelationships.ts';
import { InAppPurchaseAvailabilityRelationships } from '../models/InAppPurchaseAvailabilityRelationships.ts';
import { InAppPurchaseAvailabilityResponse } from '../models/InAppPurchaseAvailabilityResponse.ts';
import { InAppPurchaseContent } from '../models/InAppPurchaseContent.ts';
import { InAppPurchaseContentAttributes } from '../models/InAppPurchaseContentAttributes.ts';
import { InAppPurchaseContentResponse } from '../models/InAppPurchaseContentResponse.ts';
import { InAppPurchaseLocalization } from '../models/InAppPurchaseLocalization.ts';
import { InAppPurchaseLocalizationAttributes } from '../models/InAppPurchaseLocalizationAttributes.ts';
import { InAppPurchaseLocalizationCreateRequest } from '../models/InAppPurchaseLocalizationCreateRequest.ts';
import { InAppPurchaseLocalizationCreateRequestData } from '../models/InAppPurchaseLocalizationCreateRequestData.ts';
import { InAppPurchaseLocalizationCreateRequestDataAttributes } from '../models/InAppPurchaseLocalizationCreateRequestDataAttributes.ts';
import { InAppPurchaseLocalizationResponse } from '../models/InAppPurchaseLocalizationResponse.ts';
import { InAppPurchaseLocalizationUpdateRequest } from '../models/InAppPurchaseLocalizationUpdateRequest.ts';
import { InAppPurchaseLocalizationUpdateRequestData } from '../models/InAppPurchaseLocalizationUpdateRequestData.ts';
import { InAppPurchaseLocalizationUpdateRequestDataAttributes } from '../models/InAppPurchaseLocalizationUpdateRequestDataAttributes.ts';
import { InAppPurchaseLocalizationsResponse } from '../models/InAppPurchaseLocalizationsResponse.ts';
import { InAppPurchasePrice } from '../models/InAppPurchasePrice.ts';
import { InAppPurchasePriceAttributes } from '../models/InAppPurchasePriceAttributes.ts';
import { InAppPurchasePriceInlineCreate } from '../models/InAppPurchasePriceInlineCreate.ts';
import { InAppPurchasePriceInlineCreateAttributes } from '../models/InAppPurchasePriceInlineCreateAttributes.ts';
import { InAppPurchasePriceInlineCreateRelationships } from '../models/InAppPurchasePriceInlineCreateRelationships.ts';
import { InAppPurchasePriceInlineCreateRelationshipsInAppPurchasePricePoint } from '../models/InAppPurchasePriceInlineCreateRelationshipsInAppPurchasePricePoint.ts';
import { InAppPurchasePriceInlineCreateRelationshipsInAppPurchaseV2 } from '../models/InAppPurchasePriceInlineCreateRelationshipsInAppPurchaseV2.ts';
import { InAppPurchasePricePoint } from '../models/InAppPurchasePricePoint.ts';
import { InAppPurchasePricePointAttributes } from '../models/InAppPurchasePricePointAttributes.ts';
import { InAppPurchasePricePointRelationships } from '../models/InAppPurchasePricePointRelationships.ts';
import { InAppPurchasePricePointsResponse } from '../models/InAppPurchasePricePointsResponse.ts';
import { InAppPurchasePriceRelationships } from '../models/InAppPurchasePriceRelationships.ts';
import { InAppPurchasePriceRelationshipsInAppPurchasePricePoint } from '../models/InAppPurchasePriceRelationshipsInAppPurchasePricePoint.ts';
import { InAppPurchasePriceRelationshipsInAppPurchasePricePointData } from '../models/InAppPurchasePriceRelationshipsInAppPurchasePricePointData.ts';
import { InAppPurchasePriceSchedule } from '../models/InAppPurchasePriceSchedule.ts';
import { InAppPurchasePriceScheduleCreateRequest } from '../models/InAppPurchasePriceScheduleCreateRequest.ts';
import { InAppPurchasePriceScheduleCreateRequestData } from '../models/InAppPurchasePriceScheduleCreateRequestData.ts';
import { InAppPurchasePriceScheduleCreateRequestDataRelationships } from '../models/InAppPurchasePriceScheduleCreateRequestDataRelationships.ts';
import { InAppPurchasePriceScheduleCreateRequestDataRelationshipsManualPrices } from '../models/InAppPurchasePriceScheduleCreateRequestDataRelationshipsManualPrices.ts';
import { InAppPurchasePriceScheduleCreateRequestIncludedInner } from '../models/InAppPurchasePriceScheduleCreateRequestIncludedInner.ts';
import { InAppPurchasePriceScheduleRelationships } from '../models/InAppPurchasePriceScheduleRelationships.ts';
import { InAppPurchasePriceScheduleRelationshipsManualPrices } from '../models/InAppPurchasePriceScheduleRelationshipsManualPrices.ts';
import { InAppPurchasePriceScheduleRelationshipsManualPricesDataInner } from '../models/InAppPurchasePriceScheduleRelationshipsManualPricesDataInner.ts';
import { InAppPurchasePriceScheduleResponse } from '../models/InAppPurchasePriceScheduleResponse.ts';
import { InAppPurchasePriceScheduleResponseIncludedInner } from '../models/InAppPurchasePriceScheduleResponseIncludedInner.ts';
import { InAppPurchasePricesResponse } from '../models/InAppPurchasePricesResponse.ts';
import { InAppPurchasePricesResponseIncludedInner } from '../models/InAppPurchasePricesResponseIncludedInner.ts';
import { InAppPurchaseRelationships } from '../models/InAppPurchaseRelationships.ts';
import { InAppPurchaseResponse } from '../models/InAppPurchaseResponse.ts';
import { InAppPurchaseState } from '../models/InAppPurchaseState.ts';
import { InAppPurchaseSubmission } from '../models/InAppPurchaseSubmission.ts';
import { InAppPurchaseSubmissionCreateRequest } from '../models/InAppPurchaseSubmissionCreateRequest.ts';
import { InAppPurchaseSubmissionCreateRequestData } from '../models/InAppPurchaseSubmissionCreateRequestData.ts';
import { InAppPurchaseSubmissionResponse } from '../models/InAppPurchaseSubmissionResponse.ts';
import { InAppPurchaseType } from '../models/InAppPurchaseType.ts';
import { InAppPurchaseV2 } from '../models/InAppPurchaseV2.ts';
import { InAppPurchaseV2Attributes } from '../models/InAppPurchaseV2Attributes.ts';
import { InAppPurchaseV2CreateRequest } from '../models/InAppPurchaseV2CreateRequest.ts';
import { InAppPurchaseV2CreateRequestData } from '../models/InAppPurchaseV2CreateRequestData.ts';
import { InAppPurchaseV2CreateRequestDataAttributes } from '../models/InAppPurchaseV2CreateRequestDataAttributes.ts';
import { InAppPurchaseV2Relationships } from '../models/InAppPurchaseV2Relationships.ts';
import { InAppPurchaseV2RelationshipsAppStoreReviewScreenshot } from '../models/InAppPurchaseV2RelationshipsAppStoreReviewScreenshot.ts';
import { InAppPurchaseV2RelationshipsAppStoreReviewScreenshotData } from '../models/InAppPurchaseV2RelationshipsAppStoreReviewScreenshotData.ts';
import { InAppPurchaseV2RelationshipsContent } from '../models/InAppPurchaseV2RelationshipsContent.ts';
import { InAppPurchaseV2RelationshipsContentData } from '../models/InAppPurchaseV2RelationshipsContentData.ts';
import { InAppPurchaseV2RelationshipsIapPriceSchedule } from '../models/InAppPurchaseV2RelationshipsIapPriceSchedule.ts';
import { InAppPurchaseV2RelationshipsIapPriceScheduleData } from '../models/InAppPurchaseV2RelationshipsIapPriceScheduleData.ts';
import { InAppPurchaseV2RelationshipsInAppPurchaseAvailability } from '../models/InAppPurchaseV2RelationshipsInAppPurchaseAvailability.ts';
import { InAppPurchaseV2RelationshipsInAppPurchaseAvailabilityData } from '../models/InAppPurchaseV2RelationshipsInAppPurchaseAvailabilityData.ts';
import { InAppPurchaseV2RelationshipsInAppPurchaseLocalizations } from '../models/InAppPurchaseV2RelationshipsInAppPurchaseLocalizations.ts';
import { InAppPurchaseV2RelationshipsInAppPurchaseLocalizationsDataInner } from '../models/InAppPurchaseV2RelationshipsInAppPurchaseLocalizationsDataInner.ts';
import { InAppPurchaseV2RelationshipsPricePoints } from '../models/InAppPurchaseV2RelationshipsPricePoints.ts';
import { InAppPurchaseV2RelationshipsPromotedPurchase } from '../models/InAppPurchaseV2RelationshipsPromotedPurchase.ts';
import { InAppPurchaseV2Response } from '../models/InAppPurchaseV2Response.ts';
import { InAppPurchaseV2UpdateRequest } from '../models/InAppPurchaseV2UpdateRequest.ts';
import { InAppPurchaseV2UpdateRequestData } from '../models/InAppPurchaseV2UpdateRequestData.ts';
import { InAppPurchaseV2UpdateRequestDataAttributes } from '../models/InAppPurchaseV2UpdateRequestDataAttributes.ts';
import { InAppPurchasesResponse } from '../models/InAppPurchasesResponse.ts';
import { InAppPurchasesV2Response } from '../models/InAppPurchasesV2Response.ts';
import { InAppPurchasesV2ResponseIncludedInner } from '../models/InAppPurchasesV2ResponseIncludedInner.ts';
import { InternalBetaState } from '../models/InternalBetaState.ts';
import { KidsAgeBand } from '../models/KidsAgeBand.ts';
import { Location } from '../models/Location.ts';
import { MarketplaceDomain } from '../models/MarketplaceDomain.ts';
import { MarketplaceDomainCreateRequest } from '../models/MarketplaceDomainCreateRequest.ts';
import { MarketplaceDomainCreateRequestData } from '../models/MarketplaceDomainCreateRequestData.ts';
import { MarketplaceDomainResponse } from '../models/MarketplaceDomainResponse.ts';
import { MarketplaceDomainsResponse } from '../models/MarketplaceDomainsResponse.ts';
import { MarketplaceSearchDetail } from '../models/MarketplaceSearchDetail.ts';
import { MarketplaceSearchDetailAttributes } from '../models/MarketplaceSearchDetailAttributes.ts';
import { MarketplaceSearchDetailCreateRequest } from '../models/MarketplaceSearchDetailCreateRequest.ts';
import { MarketplaceSearchDetailCreateRequestData } from '../models/MarketplaceSearchDetailCreateRequestData.ts';
import { MarketplaceSearchDetailCreateRequestDataAttributes } from '../models/MarketplaceSearchDetailCreateRequestDataAttributes.ts';
import { MarketplaceSearchDetailResponse } from '../models/MarketplaceSearchDetailResponse.ts';
import { MarketplaceSearchDetailUpdateRequest } from '../models/MarketplaceSearchDetailUpdateRequest.ts';
import { MarketplaceSearchDetailUpdateRequestData } from '../models/MarketplaceSearchDetailUpdateRequestData.ts';
import { MarketplaceWebhook } from '../models/MarketplaceWebhook.ts';
import { MarketplaceWebhookAttributes } from '../models/MarketplaceWebhookAttributes.ts';
import { MarketplaceWebhookCreateRequest } from '../models/MarketplaceWebhookCreateRequest.ts';
import { MarketplaceWebhookCreateRequestData } from '../models/MarketplaceWebhookCreateRequestData.ts';
import { MarketplaceWebhookCreateRequestDataAttributes } from '../models/MarketplaceWebhookCreateRequestDataAttributes.ts';
import { MarketplaceWebhookResponse } from '../models/MarketplaceWebhookResponse.ts';
import { MarketplaceWebhookUpdateRequest } from '../models/MarketplaceWebhookUpdateRequest.ts';
import { MarketplaceWebhookUpdateRequestData } from '../models/MarketplaceWebhookUpdateRequestData.ts';
import { MarketplaceWebhookUpdateRequestDataAttributes } from '../models/MarketplaceWebhookUpdateRequestDataAttributes.ts';
import { MarketplaceWebhooksResponse } from '../models/MarketplaceWebhooksResponse.ts';
import { MetricCategory } from '../models/MetricCategory.ts';
import { MetricsInsight } from '../models/MetricsInsight.ts';
import { MetricsInsightPopulationsInner } from '../models/MetricsInsightPopulationsInner.ts';
import { PagedDocumentLinks } from '../models/PagedDocumentLinks.ts';
import { PagingInformation } from '../models/PagingInformation.ts';
import { PagingInformationPaging } from '../models/PagingInformationPaging.ts';
import { PerfPowerMetric } from '../models/PerfPowerMetric.ts';
import { PerfPowerMetricAttributes } from '../models/PerfPowerMetricAttributes.ts';
import { PhasedReleaseState } from '../models/PhasedReleaseState.ts';
import { Platform } from '../models/Platform.ts';
import { PreReleaseVersionsResponse } from '../models/PreReleaseVersionsResponse.ts';
import { PreReleaseVersionsResponseIncludedInner } from '../models/PreReleaseVersionsResponseIncludedInner.ts';
import { PreReleaseVersionsWithoutIncludesResponse } from '../models/PreReleaseVersionsWithoutIncludesResponse.ts';
import { PrereleaseVersion } from '../models/PrereleaseVersion.ts';
import { PrereleaseVersionAttributes } from '../models/PrereleaseVersionAttributes.ts';
import { PrereleaseVersionRelationships } from '../models/PrereleaseVersionRelationships.ts';
import { PrereleaseVersionResponse } from '../models/PrereleaseVersionResponse.ts';
import { PrereleaseVersionWithoutIncludesResponse } from '../models/PrereleaseVersionWithoutIncludesResponse.ts';
import { PreviewType } from '../models/PreviewType.ts';
import { Profile } from '../models/Profile.ts';
import { ProfileAttributes } from '../models/ProfileAttributes.ts';
import { ProfileCreateRequest } from '../models/ProfileCreateRequest.ts';
import { ProfileCreateRequestData } from '../models/ProfileCreateRequestData.ts';
import { ProfileCreateRequestDataAttributes } from '../models/ProfileCreateRequestDataAttributes.ts';
import { ProfileCreateRequestDataRelationships } from '../models/ProfileCreateRequestDataRelationships.ts';
import { ProfileCreateRequestDataRelationshipsCertificates } from '../models/ProfileCreateRequestDataRelationshipsCertificates.ts';
import { ProfileCreateRequestDataRelationshipsDevices } from '../models/ProfileCreateRequestDataRelationshipsDevices.ts';
import { ProfileRelationships } from '../models/ProfileRelationships.ts';
import { ProfileRelationshipsCertificates } from '../models/ProfileRelationshipsCertificates.ts';
import { ProfileRelationshipsCertificatesDataInner } from '../models/ProfileRelationshipsCertificatesDataInner.ts';
import { ProfileRelationshipsDevices } from '../models/ProfileRelationshipsDevices.ts';
import { ProfileRelationshipsDevicesDataInner } from '../models/ProfileRelationshipsDevicesDataInner.ts';
import { ProfileResponse } from '../models/ProfileResponse.ts';
import { ProfilesResponse } from '../models/ProfilesResponse.ts';
import { ProfilesResponseIncludedInner } from '../models/ProfilesResponseIncludedInner.ts';
import { ProfilesWithoutIncludesResponse } from '../models/ProfilesWithoutIncludesResponse.ts';
import { PromotedPurchase } from '../models/PromotedPurchase.ts';
import { PromotedPurchaseAttributes } from '../models/PromotedPurchaseAttributes.ts';
import { PromotedPurchaseCreateRequest } from '../models/PromotedPurchaseCreateRequest.ts';
import { PromotedPurchaseCreateRequestData } from '../models/PromotedPurchaseCreateRequestData.ts';
import { PromotedPurchaseCreateRequestDataAttributes } from '../models/PromotedPurchaseCreateRequestDataAttributes.ts';
import { PromotedPurchaseCreateRequestDataRelationships } from '../models/PromotedPurchaseCreateRequestDataRelationships.ts';
import { PromotedPurchaseCreateRequestDataRelationshipsSubscription } from '../models/PromotedPurchaseCreateRequestDataRelationshipsSubscription.ts';
import { PromotedPurchaseImage } from '../models/PromotedPurchaseImage.ts';
import { PromotedPurchaseImageAttributes } from '../models/PromotedPurchaseImageAttributes.ts';
import { PromotedPurchaseImageCreateRequest } from '../models/PromotedPurchaseImageCreateRequest.ts';
import { PromotedPurchaseImageCreateRequestData } from '../models/PromotedPurchaseImageCreateRequestData.ts';
import { PromotedPurchaseImageCreateRequestDataRelationships } from '../models/PromotedPurchaseImageCreateRequestDataRelationships.ts';
import { PromotedPurchaseImageCreateRequestDataRelationshipsPromotedPurchase } from '../models/PromotedPurchaseImageCreateRequestDataRelationshipsPromotedPurchase.ts';
import { PromotedPurchaseImageRelationships } from '../models/PromotedPurchaseImageRelationships.ts';
import { PromotedPurchaseImageResponse } from '../models/PromotedPurchaseImageResponse.ts';
import { PromotedPurchaseImageUpdateRequest } from '../models/PromotedPurchaseImageUpdateRequest.ts';
import { PromotedPurchaseImageUpdateRequestData } from '../models/PromotedPurchaseImageUpdateRequestData.ts';
import { PromotedPurchaseImagesResponse } from '../models/PromotedPurchaseImagesResponse.ts';
import { PromotedPurchaseRelationships } from '../models/PromotedPurchaseRelationships.ts';
import { PromotedPurchaseRelationshipsPromotionImages } from '../models/PromotedPurchaseRelationshipsPromotionImages.ts';
import { PromotedPurchaseRelationshipsPromotionImagesDataInner } from '../models/PromotedPurchaseRelationshipsPromotionImagesDataInner.ts';
import { PromotedPurchaseRelationshipsSubscription } from '../models/PromotedPurchaseRelationshipsSubscription.ts';
import { PromotedPurchaseRelationshipsSubscriptionData } from '../models/PromotedPurchaseRelationshipsSubscriptionData.ts';
import { PromotedPurchaseResponse } from '../models/PromotedPurchaseResponse.ts';
import { PromotedPurchaseUpdateRequest } from '../models/PromotedPurchaseUpdateRequest.ts';
import { PromotedPurchaseUpdateRequestData } from '../models/PromotedPurchaseUpdateRequestData.ts';
import { PromotedPurchaseUpdateRequestDataAttributes } from '../models/PromotedPurchaseUpdateRequestDataAttributes.ts';
import { PromotedPurchasesResponse } from '../models/PromotedPurchasesResponse.ts';
import { PromotedPurchasesResponseIncludedInner } from '../models/PromotedPurchasesResponseIncludedInner.ts';
import { Property } from '../models/Property.ts';
import { ResourceLinks } from '../models/ResourceLinks.ts';
import { ReviewSubmission } from '../models/ReviewSubmission.ts';
import { ReviewSubmissionAttributes } from '../models/ReviewSubmissionAttributes.ts';
import { ReviewSubmissionCreateRequest } from '../models/ReviewSubmissionCreateRequest.ts';
import { ReviewSubmissionCreateRequestData } from '../models/ReviewSubmissionCreateRequestData.ts';
import { ReviewSubmissionCreateRequestDataAttributes } from '../models/ReviewSubmissionCreateRequestDataAttributes.ts';
import { ReviewSubmissionItem } from '../models/ReviewSubmissionItem.ts';
import { ReviewSubmissionItemAttributes } from '../models/ReviewSubmissionItemAttributes.ts';
import { ReviewSubmissionItemCreateRequest } from '../models/ReviewSubmissionItemCreateRequest.ts';
import { ReviewSubmissionItemCreateRequestData } from '../models/ReviewSubmissionItemCreateRequestData.ts';
import { ReviewSubmissionItemCreateRequestDataRelationships } from '../models/ReviewSubmissionItemCreateRequestDataRelationships.ts';
import { ReviewSubmissionItemCreateRequestDataRelationshipsAppEvent } from '../models/ReviewSubmissionItemCreateRequestDataRelationshipsAppEvent.ts';
import { ReviewSubmissionItemCreateRequestDataRelationshipsReviewSubmission } from '../models/ReviewSubmissionItemCreateRequestDataRelationshipsReviewSubmission.ts';
import { ReviewSubmissionItemRelationships } from '../models/ReviewSubmissionItemRelationships.ts';
import { ReviewSubmissionItemResponse } from '../models/ReviewSubmissionItemResponse.ts';
import { ReviewSubmissionItemUpdateRequest } from '../models/ReviewSubmissionItemUpdateRequest.ts';
import { ReviewSubmissionItemUpdateRequestData } from '../models/ReviewSubmissionItemUpdateRequestData.ts';
import { ReviewSubmissionItemUpdateRequestDataAttributes } from '../models/ReviewSubmissionItemUpdateRequestDataAttributes.ts';
import { ReviewSubmissionItemsResponse } from '../models/ReviewSubmissionItemsResponse.ts';
import { ReviewSubmissionItemsResponseIncludedInner } from '../models/ReviewSubmissionItemsResponseIncludedInner.ts';
import { ReviewSubmissionRelationships } from '../models/ReviewSubmissionRelationships.ts';
import { ReviewSubmissionRelationshipsItems } from '../models/ReviewSubmissionRelationshipsItems.ts';
import { ReviewSubmissionRelationshipsItemsDataInner } from '../models/ReviewSubmissionRelationshipsItemsDataInner.ts';
import { ReviewSubmissionRelationshipsSubmittedByActor } from '../models/ReviewSubmissionRelationshipsSubmittedByActor.ts';
import { ReviewSubmissionRelationshipsSubmittedByActorData } from '../models/ReviewSubmissionRelationshipsSubmittedByActorData.ts';
import { ReviewSubmissionResponse } from '../models/ReviewSubmissionResponse.ts';
import { ReviewSubmissionUpdateRequest } from '../models/ReviewSubmissionUpdateRequest.ts';
import { ReviewSubmissionUpdateRequestData } from '../models/ReviewSubmissionUpdateRequestData.ts';
import { ReviewSubmissionUpdateRequestDataAttributes } from '../models/ReviewSubmissionUpdateRequestDataAttributes.ts';
import { ReviewSubmissionsResponse } from '../models/ReviewSubmissionsResponse.ts';
import { ReviewSubmissionsResponseIncludedInner } from '../models/ReviewSubmissionsResponseIncludedInner.ts';
import { RoutingAppCoverage } from '../models/RoutingAppCoverage.ts';
import { RoutingAppCoverageCreateRequest } from '../models/RoutingAppCoverageCreateRequest.ts';
import { RoutingAppCoverageCreateRequestData } from '../models/RoutingAppCoverageCreateRequestData.ts';
import { RoutingAppCoverageResponse } from '../models/RoutingAppCoverageResponse.ts';
import { RoutingAppCoverageUpdateRequest } from '../models/RoutingAppCoverageUpdateRequest.ts';
import { RoutingAppCoverageUpdateRequestData } from '../models/RoutingAppCoverageUpdateRequestData.ts';
import { RoutingAppCoverageWithoutIncludesResponse } from '../models/RoutingAppCoverageWithoutIncludesResponse.ts';
import { SandboxTesterV2 } from '../models/SandboxTesterV2.ts';
import { SandboxTesterV2Attributes } from '../models/SandboxTesterV2Attributes.ts';
import { SandboxTesterV2Response } from '../models/SandboxTesterV2Response.ts';
import { SandboxTesterV2UpdateRequest } from '../models/SandboxTesterV2UpdateRequest.ts';
import { SandboxTesterV2UpdateRequestData } from '../models/SandboxTesterV2UpdateRequestData.ts';
import { SandboxTesterV2UpdateRequestDataAttributes } from '../models/SandboxTesterV2UpdateRequestDataAttributes.ts';
import { SandboxTestersClearPurchaseHistoryRequestV2 } from '../models/SandboxTestersClearPurchaseHistoryRequestV2.ts';
import { SandboxTestersClearPurchaseHistoryRequestV2CreateRequest } from '../models/SandboxTestersClearPurchaseHistoryRequestV2CreateRequest.ts';
import { SandboxTestersClearPurchaseHistoryRequestV2CreateRequestData } from '../models/SandboxTestersClearPurchaseHistoryRequestV2CreateRequestData.ts';
import { SandboxTestersClearPurchaseHistoryRequestV2CreateRequestDataRelationships } from '../models/SandboxTestersClearPurchaseHistoryRequestV2CreateRequestDataRelationships.ts';
import { SandboxTestersClearPurchaseHistoryRequestV2CreateRequestDataRelationshipsSandboxTesters } from '../models/SandboxTestersClearPurchaseHistoryRequestV2CreateRequestDataRelationshipsSandboxTesters.ts';
import { SandboxTestersClearPurchaseHistoryRequestV2CreateRequestDataRelationshipsSandboxTestersDataInner } from '../models/SandboxTestersClearPurchaseHistoryRequestV2CreateRequestDataRelationshipsSandboxTestersDataInner.ts';
import { SandboxTestersClearPurchaseHistoryRequestV2Response } from '../models/SandboxTestersClearPurchaseHistoryRequestV2Response.ts';
import { SandboxTestersV2Response } from '../models/SandboxTestersV2Response.ts';
import { ScmGitReference } from '../models/ScmGitReference.ts';
import { ScmGitReferenceAttributes } from '../models/ScmGitReferenceAttributes.ts';
import { ScmGitReferenceRelationships } from '../models/ScmGitReferenceRelationships.ts';
import { ScmGitReferenceResponse } from '../models/ScmGitReferenceResponse.ts';
import { ScmGitReferencesResponse } from '../models/ScmGitReferencesResponse.ts';
import { ScmProvider } from '../models/ScmProvider.ts';
import { ScmProviderAttributes } from '../models/ScmProviderAttributes.ts';
import { ScmProviderResponse } from '../models/ScmProviderResponse.ts';
import { ScmProviderType } from '../models/ScmProviderType.ts';
import { ScmProvidersResponse } from '../models/ScmProvidersResponse.ts';
import { ScmPullRequest } from '../models/ScmPullRequest.ts';
import { ScmPullRequestAttributes } from '../models/ScmPullRequestAttributes.ts';
import { ScmPullRequestResponse } from '../models/ScmPullRequestResponse.ts';
import { ScmPullRequestsResponse } from '../models/ScmPullRequestsResponse.ts';
import { ScmRepositoriesResponse } from '../models/ScmRepositoriesResponse.ts';
import { ScmRepositoriesResponseIncludedInner } from '../models/ScmRepositoriesResponseIncludedInner.ts';
import { ScmRepository } from '../models/ScmRepository.ts';
import { ScmRepositoryAttributes } from '../models/ScmRepositoryAttributes.ts';
import { ScmRepositoryRelationships } from '../models/ScmRepositoryRelationships.ts';
import { ScmRepositoryRelationshipsScmProvider } from '../models/ScmRepositoryRelationshipsScmProvider.ts';
import { ScmRepositoryRelationshipsScmProviderData } from '../models/ScmRepositoryRelationshipsScmProviderData.ts';
import { ScmRepositoryResponse } from '../models/ScmRepositoryResponse.ts';
import { ScreenshotDisplayType } from '../models/ScreenshotDisplayType.ts';
import { Subscription } from '../models/Subscription.ts';
import { SubscriptionAppStoreReviewScreenshot } from '../models/SubscriptionAppStoreReviewScreenshot.ts';
import { SubscriptionAppStoreReviewScreenshotCreateRequest } from '../models/SubscriptionAppStoreReviewScreenshotCreateRequest.ts';
import { SubscriptionAppStoreReviewScreenshotCreateRequestData } from '../models/SubscriptionAppStoreReviewScreenshotCreateRequestData.ts';
import { SubscriptionAppStoreReviewScreenshotCreateRequestDataRelationships } from '../models/SubscriptionAppStoreReviewScreenshotCreateRequestDataRelationships.ts';
import { SubscriptionAppStoreReviewScreenshotCreateRequestDataRelationshipsSubscription } from '../models/SubscriptionAppStoreReviewScreenshotCreateRequestDataRelationshipsSubscription.ts';
import { SubscriptionAppStoreReviewScreenshotRelationships } from '../models/SubscriptionAppStoreReviewScreenshotRelationships.ts';
import { SubscriptionAppStoreReviewScreenshotResponse } from '../models/SubscriptionAppStoreReviewScreenshotResponse.ts';
import { SubscriptionAppStoreReviewScreenshotUpdateRequest } from '../models/SubscriptionAppStoreReviewScreenshotUpdateRequest.ts';
import { SubscriptionAppStoreReviewScreenshotUpdateRequestData } from '../models/SubscriptionAppStoreReviewScreenshotUpdateRequestData.ts';
import { SubscriptionAttributes } from '../models/SubscriptionAttributes.ts';
import { SubscriptionAvailability } from '../models/SubscriptionAvailability.ts';
import { SubscriptionAvailabilityCreateRequest } from '../models/SubscriptionAvailabilityCreateRequest.ts';
import { SubscriptionAvailabilityCreateRequestData } from '../models/SubscriptionAvailabilityCreateRequestData.ts';
import { SubscriptionAvailabilityCreateRequestDataRelationships } from '../models/SubscriptionAvailabilityCreateRequestDataRelationships.ts';
import { SubscriptionAvailabilityRelationships } from '../models/SubscriptionAvailabilityRelationships.ts';
import { SubscriptionAvailabilityResponse } from '../models/SubscriptionAvailabilityResponse.ts';
import { SubscriptionAvailabilityResponseIncludedInner } from '../models/SubscriptionAvailabilityResponseIncludedInner.ts';
import { SubscriptionCreateRequest } from '../models/SubscriptionCreateRequest.ts';
import { SubscriptionCreateRequestData } from '../models/SubscriptionCreateRequestData.ts';
import { SubscriptionCreateRequestDataAttributes } from '../models/SubscriptionCreateRequestDataAttributes.ts';
import { SubscriptionCreateRequestDataRelationships } from '../models/SubscriptionCreateRequestDataRelationships.ts';
import { SubscriptionCustomerEligibility } from '../models/SubscriptionCustomerEligibility.ts';
import { SubscriptionGracePeriod } from '../models/SubscriptionGracePeriod.ts';
import { SubscriptionGracePeriodAttributes } from '../models/SubscriptionGracePeriodAttributes.ts';
import { SubscriptionGracePeriodDuration } from '../models/SubscriptionGracePeriodDuration.ts';
import { SubscriptionGracePeriodResponse } from '../models/SubscriptionGracePeriodResponse.ts';
import { SubscriptionGracePeriodUpdateRequest } from '../models/SubscriptionGracePeriodUpdateRequest.ts';
import { SubscriptionGracePeriodUpdateRequestData } from '../models/SubscriptionGracePeriodUpdateRequestData.ts';
import { SubscriptionGroup } from '../models/SubscriptionGroup.ts';
import { SubscriptionGroupCreateRequest } from '../models/SubscriptionGroupCreateRequest.ts';
import { SubscriptionGroupCreateRequestData } from '../models/SubscriptionGroupCreateRequestData.ts';
import { SubscriptionGroupCreateRequestDataAttributes } from '../models/SubscriptionGroupCreateRequestDataAttributes.ts';
import { SubscriptionGroupLocalization } from '../models/SubscriptionGroupLocalization.ts';
import { SubscriptionGroupLocalizationAttributes } from '../models/SubscriptionGroupLocalizationAttributes.ts';
import { SubscriptionGroupLocalizationCreateRequest } from '../models/SubscriptionGroupLocalizationCreateRequest.ts';
import { SubscriptionGroupLocalizationCreateRequestData } from '../models/SubscriptionGroupLocalizationCreateRequestData.ts';
import { SubscriptionGroupLocalizationCreateRequestDataAttributes } from '../models/SubscriptionGroupLocalizationCreateRequestDataAttributes.ts';
import { SubscriptionGroupLocalizationCreateRequestDataRelationships } from '../models/SubscriptionGroupLocalizationCreateRequestDataRelationships.ts';
import { SubscriptionGroupLocalizationCreateRequestDataRelationshipsSubscriptionGroup } from '../models/SubscriptionGroupLocalizationCreateRequestDataRelationshipsSubscriptionGroup.ts';
import { SubscriptionGroupLocalizationRelationships } from '../models/SubscriptionGroupLocalizationRelationships.ts';
import { SubscriptionGroupLocalizationRelationshipsSubscriptionGroup } from '../models/SubscriptionGroupLocalizationRelationshipsSubscriptionGroup.ts';
import { SubscriptionGroupLocalizationResponse } from '../models/SubscriptionGroupLocalizationResponse.ts';
import { SubscriptionGroupLocalizationUpdateRequest } from '../models/SubscriptionGroupLocalizationUpdateRequest.ts';
import { SubscriptionGroupLocalizationUpdateRequestData } from '../models/SubscriptionGroupLocalizationUpdateRequestData.ts';
import { SubscriptionGroupLocalizationUpdateRequestDataAttributes } from '../models/SubscriptionGroupLocalizationUpdateRequestDataAttributes.ts';
import { SubscriptionGroupLocalizationsResponse } from '../models/SubscriptionGroupLocalizationsResponse.ts';
import { SubscriptionGroupRelationships } from '../models/SubscriptionGroupRelationships.ts';
import { SubscriptionGroupRelationshipsSubscriptionGroupLocalizations } from '../models/SubscriptionGroupRelationshipsSubscriptionGroupLocalizations.ts';
import { SubscriptionGroupRelationshipsSubscriptionGroupLocalizationsDataInner } from '../models/SubscriptionGroupRelationshipsSubscriptionGroupLocalizationsDataInner.ts';
import { SubscriptionGroupRelationshipsSubscriptions } from '../models/SubscriptionGroupRelationshipsSubscriptions.ts';
import { SubscriptionGroupResponse } from '../models/SubscriptionGroupResponse.ts';
import { SubscriptionGroupSubmission } from '../models/SubscriptionGroupSubmission.ts';
import { SubscriptionGroupSubmissionCreateRequest } from '../models/SubscriptionGroupSubmissionCreateRequest.ts';
import { SubscriptionGroupSubmissionCreateRequestData } from '../models/SubscriptionGroupSubmissionCreateRequestData.ts';
import { SubscriptionGroupSubmissionResponse } from '../models/SubscriptionGroupSubmissionResponse.ts';
import { SubscriptionGroupUpdateRequest } from '../models/SubscriptionGroupUpdateRequest.ts';
import { SubscriptionGroupUpdateRequestData } from '../models/SubscriptionGroupUpdateRequestData.ts';
import { SubscriptionGroupsResponse } from '../models/SubscriptionGroupsResponse.ts';
import { SubscriptionGroupsResponseIncludedInner } from '../models/SubscriptionGroupsResponseIncludedInner.ts';
import { SubscriptionIntroductoryOffer } from '../models/SubscriptionIntroductoryOffer.ts';
import { SubscriptionIntroductoryOfferAttributes } from '../models/SubscriptionIntroductoryOfferAttributes.ts';
import { SubscriptionIntroductoryOfferCreateRequest } from '../models/SubscriptionIntroductoryOfferCreateRequest.ts';
import { SubscriptionIntroductoryOfferCreateRequestData } from '../models/SubscriptionIntroductoryOfferCreateRequestData.ts';
import { SubscriptionIntroductoryOfferCreateRequestDataRelationships } from '../models/SubscriptionIntroductoryOfferCreateRequestDataRelationships.ts';
import { SubscriptionIntroductoryOfferInlineCreate } from '../models/SubscriptionIntroductoryOfferInlineCreate.ts';
import { SubscriptionIntroductoryOfferInlineCreateAttributes } from '../models/SubscriptionIntroductoryOfferInlineCreateAttributes.ts';
import { SubscriptionIntroductoryOfferInlineCreateRelationships } from '../models/SubscriptionIntroductoryOfferInlineCreateRelationships.ts';
import { SubscriptionIntroductoryOfferInlineCreateRelationshipsSubscriptionPricePoint } from '../models/SubscriptionIntroductoryOfferInlineCreateRelationshipsSubscriptionPricePoint.ts';
import { SubscriptionIntroductoryOfferInlineCreateRelationshipsTerritory } from '../models/SubscriptionIntroductoryOfferInlineCreateRelationshipsTerritory.ts';
import { SubscriptionIntroductoryOfferRelationships } from '../models/SubscriptionIntroductoryOfferRelationships.ts';
import { SubscriptionIntroductoryOfferRelationshipsSubscriptionPricePoint } from '../models/SubscriptionIntroductoryOfferRelationshipsSubscriptionPricePoint.ts';
import { SubscriptionIntroductoryOfferRelationshipsSubscriptionPricePointData } from '../models/SubscriptionIntroductoryOfferRelationshipsSubscriptionPricePointData.ts';
import { SubscriptionIntroductoryOfferResponse } from '../models/SubscriptionIntroductoryOfferResponse.ts';
import { SubscriptionIntroductoryOfferUpdateRequest } from '../models/SubscriptionIntroductoryOfferUpdateRequest.ts';
import { SubscriptionIntroductoryOfferUpdateRequestData } from '../models/SubscriptionIntroductoryOfferUpdateRequestData.ts';
import { SubscriptionIntroductoryOfferUpdateRequestDataAttributes } from '../models/SubscriptionIntroductoryOfferUpdateRequestDataAttributes.ts';
import { SubscriptionIntroductoryOffersLinkagesRequest } from '../models/SubscriptionIntroductoryOffersLinkagesRequest.ts';
import { SubscriptionIntroductoryOffersLinkagesResponse } from '../models/SubscriptionIntroductoryOffersLinkagesResponse.ts';
import { SubscriptionIntroductoryOffersResponse } from '../models/SubscriptionIntroductoryOffersResponse.ts';
import { SubscriptionIntroductoryOffersResponseIncludedInner } from '../models/SubscriptionIntroductoryOffersResponseIncludedInner.ts';
import { SubscriptionLocalization } from '../models/SubscriptionLocalization.ts';
import { SubscriptionLocalizationCreateRequest } from '../models/SubscriptionLocalizationCreateRequest.ts';
import { SubscriptionLocalizationCreateRequestData } from '../models/SubscriptionLocalizationCreateRequestData.ts';
import { SubscriptionLocalizationResponse } from '../models/SubscriptionLocalizationResponse.ts';
import { SubscriptionLocalizationUpdateRequest } from '../models/SubscriptionLocalizationUpdateRequest.ts';
import { SubscriptionLocalizationUpdateRequestData } from '../models/SubscriptionLocalizationUpdateRequestData.ts';
import { SubscriptionLocalizationsResponse } from '../models/SubscriptionLocalizationsResponse.ts';
import { SubscriptionOfferCode } from '../models/SubscriptionOfferCode.ts';
import { SubscriptionOfferCodeAttributes } from '../models/SubscriptionOfferCodeAttributes.ts';
import { SubscriptionOfferCodeCreateRequest } from '../models/SubscriptionOfferCodeCreateRequest.ts';
import { SubscriptionOfferCodeCreateRequestData } from '../models/SubscriptionOfferCodeCreateRequestData.ts';
import { SubscriptionOfferCodeCreateRequestDataAttributes } from '../models/SubscriptionOfferCodeCreateRequestDataAttributes.ts';
import { SubscriptionOfferCodeCreateRequestDataRelationships } from '../models/SubscriptionOfferCodeCreateRequestDataRelationships.ts';
import { SubscriptionOfferCodeCreateRequestDataRelationshipsPrices } from '../models/SubscriptionOfferCodeCreateRequestDataRelationshipsPrices.ts';
import { SubscriptionOfferCodeCustomCode } from '../models/SubscriptionOfferCodeCustomCode.ts';
import { SubscriptionOfferCodeCustomCodeAttributes } from '../models/SubscriptionOfferCodeCustomCodeAttributes.ts';
import { SubscriptionOfferCodeCustomCodeCreateRequest } from '../models/SubscriptionOfferCodeCustomCodeCreateRequest.ts';
import { SubscriptionOfferCodeCustomCodeCreateRequestData } from '../models/SubscriptionOfferCodeCustomCodeCreateRequestData.ts';
import { SubscriptionOfferCodeCustomCodeCreateRequestDataAttributes } from '../models/SubscriptionOfferCodeCustomCodeCreateRequestDataAttributes.ts';
import { SubscriptionOfferCodeCustomCodeCreateRequestDataRelationships } from '../models/SubscriptionOfferCodeCustomCodeCreateRequestDataRelationships.ts';
import { SubscriptionOfferCodeCustomCodeCreateRequestDataRelationshipsOfferCode } from '../models/SubscriptionOfferCodeCustomCodeCreateRequestDataRelationshipsOfferCode.ts';
import { SubscriptionOfferCodeCustomCodeRelationships } from '../models/SubscriptionOfferCodeCustomCodeRelationships.ts';
import { SubscriptionOfferCodeCustomCodeRelationshipsOfferCode } from '../models/SubscriptionOfferCodeCustomCodeRelationshipsOfferCode.ts';
import { SubscriptionOfferCodeCustomCodeRelationshipsOfferCodeData } from '../models/SubscriptionOfferCodeCustomCodeRelationshipsOfferCodeData.ts';
import { SubscriptionOfferCodeCustomCodeResponse } from '../models/SubscriptionOfferCodeCustomCodeResponse.ts';
import { SubscriptionOfferCodeCustomCodeUpdateRequest } from '../models/SubscriptionOfferCodeCustomCodeUpdateRequest.ts';
import { SubscriptionOfferCodeCustomCodeUpdateRequestData } from '../models/SubscriptionOfferCodeCustomCodeUpdateRequestData.ts';
import { SubscriptionOfferCodeCustomCodeUpdateRequestDataAttributes } from '../models/SubscriptionOfferCodeCustomCodeUpdateRequestDataAttributes.ts';
import { SubscriptionOfferCodeCustomCodesResponse } from '../models/SubscriptionOfferCodeCustomCodesResponse.ts';
import { SubscriptionOfferCodeOneTimeUseCode } from '../models/SubscriptionOfferCodeOneTimeUseCode.ts';
import { SubscriptionOfferCodeOneTimeUseCodeAttributes } from '../models/SubscriptionOfferCodeOneTimeUseCodeAttributes.ts';
import { SubscriptionOfferCodeOneTimeUseCodeCreateRequest } from '../models/SubscriptionOfferCodeOneTimeUseCodeCreateRequest.ts';
import { SubscriptionOfferCodeOneTimeUseCodeCreateRequestData } from '../models/SubscriptionOfferCodeOneTimeUseCodeCreateRequestData.ts';
import { SubscriptionOfferCodeOneTimeUseCodeCreateRequestDataAttributes } from '../models/SubscriptionOfferCodeOneTimeUseCodeCreateRequestDataAttributes.ts';
import { SubscriptionOfferCodeOneTimeUseCodeResponse } from '../models/SubscriptionOfferCodeOneTimeUseCodeResponse.ts';
import { SubscriptionOfferCodeOneTimeUseCodeUpdateRequest } from '../models/SubscriptionOfferCodeOneTimeUseCodeUpdateRequest.ts';
import { SubscriptionOfferCodeOneTimeUseCodeUpdateRequestData } from '../models/SubscriptionOfferCodeOneTimeUseCodeUpdateRequestData.ts';
import { SubscriptionOfferCodeOneTimeUseCodeValue } from '../models/SubscriptionOfferCodeOneTimeUseCodeValue.ts';
import { SubscriptionOfferCodeOneTimeUseCodesResponse } from '../models/SubscriptionOfferCodeOneTimeUseCodesResponse.ts';
import { SubscriptionOfferCodePrice } from '../models/SubscriptionOfferCodePrice.ts';
import { SubscriptionOfferCodePriceInlineCreate } from '../models/SubscriptionOfferCodePriceInlineCreate.ts';
import { SubscriptionOfferCodePriceInlineCreateRelationships } from '../models/SubscriptionOfferCodePriceInlineCreateRelationships.ts';
import { SubscriptionOfferCodePriceRelationships } from '../models/SubscriptionOfferCodePriceRelationships.ts';
import { SubscriptionOfferCodePricesResponse } from '../models/SubscriptionOfferCodePricesResponse.ts';
import { SubscriptionOfferCodePricesResponseIncludedInner } from '../models/SubscriptionOfferCodePricesResponseIncludedInner.ts';
import { SubscriptionOfferCodeRelationships } from '../models/SubscriptionOfferCodeRelationships.ts';
import { SubscriptionOfferCodeRelationshipsCustomCodes } from '../models/SubscriptionOfferCodeRelationshipsCustomCodes.ts';
import { SubscriptionOfferCodeRelationshipsCustomCodesDataInner } from '../models/SubscriptionOfferCodeRelationshipsCustomCodesDataInner.ts';
import { SubscriptionOfferCodeRelationshipsOneTimeUseCodes } from '../models/SubscriptionOfferCodeRelationshipsOneTimeUseCodes.ts';
import { SubscriptionOfferCodeRelationshipsOneTimeUseCodesDataInner } from '../models/SubscriptionOfferCodeRelationshipsOneTimeUseCodesDataInner.ts';
import { SubscriptionOfferCodeRelationshipsPrices } from '../models/SubscriptionOfferCodeRelationshipsPrices.ts';
import { SubscriptionOfferCodeRelationshipsPricesDataInner } from '../models/SubscriptionOfferCodeRelationshipsPricesDataInner.ts';
import { SubscriptionOfferCodeResponse } from '../models/SubscriptionOfferCodeResponse.ts';
import { SubscriptionOfferCodeUpdateRequest } from '../models/SubscriptionOfferCodeUpdateRequest.ts';
import { SubscriptionOfferCodeUpdateRequestData } from '../models/SubscriptionOfferCodeUpdateRequestData.ts';
import { SubscriptionOfferCodesResponse } from '../models/SubscriptionOfferCodesResponse.ts';
import { SubscriptionOfferCodesResponseIncludedInner } from '../models/SubscriptionOfferCodesResponseIncludedInner.ts';
import { SubscriptionOfferDuration } from '../models/SubscriptionOfferDuration.ts';
import { SubscriptionOfferEligibility } from '../models/SubscriptionOfferEligibility.ts';
import { SubscriptionOfferMode } from '../models/SubscriptionOfferMode.ts';
import { SubscriptionPrice } from '../models/SubscriptionPrice.ts';
import { SubscriptionPriceAttributes } from '../models/SubscriptionPriceAttributes.ts';
import { SubscriptionPriceCreateRequest } from '../models/SubscriptionPriceCreateRequest.ts';
import { SubscriptionPriceCreateRequestData } from '../models/SubscriptionPriceCreateRequestData.ts';
import { SubscriptionPriceCreateRequestDataRelationships } from '../models/SubscriptionPriceCreateRequestDataRelationships.ts';
import { SubscriptionPriceCreateRequestDataRelationshipsSubscriptionPricePoint } from '../models/SubscriptionPriceCreateRequestDataRelationshipsSubscriptionPricePoint.ts';
import { SubscriptionPriceInlineCreate } from '../models/SubscriptionPriceInlineCreate.ts';
import { SubscriptionPriceInlineCreateAttributes } from '../models/SubscriptionPriceInlineCreateAttributes.ts';
import { SubscriptionPricePoint } from '../models/SubscriptionPricePoint.ts';
import { SubscriptionPricePointAttributes } from '../models/SubscriptionPricePointAttributes.ts';
import { SubscriptionPricePointInlineCreate } from '../models/SubscriptionPricePointInlineCreate.ts';
import { SubscriptionPricePointResponse } from '../models/SubscriptionPricePointResponse.ts';
import { SubscriptionPricePointsResponse } from '../models/SubscriptionPricePointsResponse.ts';
import { SubscriptionPriceResponse } from '../models/SubscriptionPriceResponse.ts';
import { SubscriptionPricesLinkagesRequest } from '../models/SubscriptionPricesLinkagesRequest.ts';
import { SubscriptionPricesLinkagesResponse } from '../models/SubscriptionPricesLinkagesResponse.ts';
import { SubscriptionPricesResponse } from '../models/SubscriptionPricesResponse.ts';
import { SubscriptionPromotionalOffer } from '../models/SubscriptionPromotionalOffer.ts';
import { SubscriptionPromotionalOfferAttributes } from '../models/SubscriptionPromotionalOfferAttributes.ts';
import { SubscriptionPromotionalOfferCreateRequest } from '../models/SubscriptionPromotionalOfferCreateRequest.ts';
import { SubscriptionPromotionalOfferCreateRequestData } from '../models/SubscriptionPromotionalOfferCreateRequestData.ts';
import { SubscriptionPromotionalOfferCreateRequestDataRelationships } from '../models/SubscriptionPromotionalOfferCreateRequestDataRelationships.ts';
import { SubscriptionPromotionalOfferCreateRequestDataRelationshipsPrices } from '../models/SubscriptionPromotionalOfferCreateRequestDataRelationshipsPrices.ts';
import { SubscriptionPromotionalOfferInlineCreate } from '../models/SubscriptionPromotionalOfferInlineCreate.ts';
import { SubscriptionPromotionalOfferInlineCreateAttributes } from '../models/SubscriptionPromotionalOfferInlineCreateAttributes.ts';
import { SubscriptionPromotionalOfferInlineCreateRelationships } from '../models/SubscriptionPromotionalOfferInlineCreateRelationships.ts';
import { SubscriptionPromotionalOfferInlineCreateRelationshipsPrices } from '../models/SubscriptionPromotionalOfferInlineCreateRelationshipsPrices.ts';
import { SubscriptionPromotionalOfferPrice } from '../models/SubscriptionPromotionalOfferPrice.ts';
import { SubscriptionPromotionalOfferPriceInlineCreate } from '../models/SubscriptionPromotionalOfferPriceInlineCreate.ts';
import { SubscriptionPromotionalOfferPricesResponse } from '../models/SubscriptionPromotionalOfferPricesResponse.ts';
import { SubscriptionPromotionalOfferRelationships } from '../models/SubscriptionPromotionalOfferRelationships.ts';
import { SubscriptionPromotionalOfferRelationshipsPrices } from '../models/SubscriptionPromotionalOfferRelationshipsPrices.ts';
import { SubscriptionPromotionalOfferRelationshipsPricesDataInner } from '../models/SubscriptionPromotionalOfferRelationshipsPricesDataInner.ts';
import { SubscriptionPromotionalOfferResponse } from '../models/SubscriptionPromotionalOfferResponse.ts';
import { SubscriptionPromotionalOfferUpdateRequest } from '../models/SubscriptionPromotionalOfferUpdateRequest.ts';
import { SubscriptionPromotionalOfferUpdateRequestData } from '../models/SubscriptionPromotionalOfferUpdateRequestData.ts';
import { SubscriptionPromotionalOfferUpdateRequestDataRelationships } from '../models/SubscriptionPromotionalOfferUpdateRequestDataRelationships.ts';
import { SubscriptionPromotionalOffersResponse } from '../models/SubscriptionPromotionalOffersResponse.ts';
import { SubscriptionPromotionalOffersResponseIncludedInner } from '../models/SubscriptionPromotionalOffersResponseIncludedInner.ts';
import { SubscriptionRelationships } from '../models/SubscriptionRelationships.ts';
import { SubscriptionRelationshipsAppStoreReviewScreenshot } from '../models/SubscriptionRelationshipsAppStoreReviewScreenshot.ts';
import { SubscriptionRelationshipsAppStoreReviewScreenshotData } from '../models/SubscriptionRelationshipsAppStoreReviewScreenshotData.ts';
import { SubscriptionRelationshipsIntroductoryOffers } from '../models/SubscriptionRelationshipsIntroductoryOffers.ts';
import { SubscriptionRelationshipsIntroductoryOffersDataInner } from '../models/SubscriptionRelationshipsIntroductoryOffersDataInner.ts';
import { SubscriptionRelationshipsOfferCodes } from '../models/SubscriptionRelationshipsOfferCodes.ts';
import { SubscriptionRelationshipsPrices } from '../models/SubscriptionRelationshipsPrices.ts';
import { SubscriptionRelationshipsPricesDataInner } from '../models/SubscriptionRelationshipsPricesDataInner.ts';
import { SubscriptionRelationshipsPromotionalOffers } from '../models/SubscriptionRelationshipsPromotionalOffers.ts';
import { SubscriptionRelationshipsPromotionalOffersDataInner } from '../models/SubscriptionRelationshipsPromotionalOffersDataInner.ts';
import { SubscriptionRelationshipsSubscriptionAvailability } from '../models/SubscriptionRelationshipsSubscriptionAvailability.ts';
import { SubscriptionRelationshipsSubscriptionAvailabilityData } from '../models/SubscriptionRelationshipsSubscriptionAvailabilityData.ts';
import { SubscriptionRelationshipsSubscriptionLocalizations } from '../models/SubscriptionRelationshipsSubscriptionLocalizations.ts';
import { SubscriptionRelationshipsSubscriptionLocalizationsDataInner } from '../models/SubscriptionRelationshipsSubscriptionLocalizationsDataInner.ts';
import { SubscriptionResponse } from '../models/SubscriptionResponse.ts';
import { SubscriptionStatusUrlVersion } from '../models/SubscriptionStatusUrlVersion.ts';
import { SubscriptionSubmission } from '../models/SubscriptionSubmission.ts';
import { SubscriptionSubmissionCreateRequest } from '../models/SubscriptionSubmissionCreateRequest.ts';
import { SubscriptionSubmissionCreateRequestData } from '../models/SubscriptionSubmissionCreateRequestData.ts';
import { SubscriptionSubmissionResponse } from '../models/SubscriptionSubmissionResponse.ts';
import { SubscriptionUpdateRequest } from '../models/SubscriptionUpdateRequest.ts';
import { SubscriptionUpdateRequestData } from '../models/SubscriptionUpdateRequestData.ts';
import { SubscriptionUpdateRequestDataAttributes } from '../models/SubscriptionUpdateRequestDataAttributes.ts';
import { SubscriptionUpdateRequestDataRelationships } from '../models/SubscriptionUpdateRequestDataRelationships.ts';
import { SubscriptionUpdateRequestDataRelationshipsIntroductoryOffers } from '../models/SubscriptionUpdateRequestDataRelationshipsIntroductoryOffers.ts';
import { SubscriptionUpdateRequestDataRelationshipsPrices } from '../models/SubscriptionUpdateRequestDataRelationshipsPrices.ts';
import { SubscriptionUpdateRequestDataRelationshipsPromotionalOffers } from '../models/SubscriptionUpdateRequestDataRelationshipsPromotionalOffers.ts';
import { SubscriptionUpdateRequestIncludedInner } from '../models/SubscriptionUpdateRequestIncludedInner.ts';
import { SubscriptionsResponse } from '../models/SubscriptionsResponse.ts';
import { SubscriptionsResponseIncludedInner } from '../models/SubscriptionsResponseIncludedInner.ts';
import { TerritoriesResponse } from '../models/TerritoriesResponse.ts';
import { TerritoriesWithoutIncludesResponse } from '../models/TerritoriesWithoutIncludesResponse.ts';
import { Territory } from '../models/Territory.ts';
import { TerritoryAttributes } from '../models/TerritoryAttributes.ts';
import { TerritoryAvailabilitiesResponse } from '../models/TerritoryAvailabilitiesResponse.ts';
import { TerritoryAvailability } from '../models/TerritoryAvailability.ts';
import { TerritoryAvailabilityAttributes } from '../models/TerritoryAvailabilityAttributes.ts';
import { TerritoryAvailabilityInlineCreate } from '../models/TerritoryAvailabilityInlineCreate.ts';
import { TerritoryAvailabilityResponse } from '../models/TerritoryAvailabilityResponse.ts';
import { TerritoryAvailabilityUpdateRequest } from '../models/TerritoryAvailabilityUpdateRequest.ts';
import { TerritoryAvailabilityUpdateRequestData } from '../models/TerritoryAvailabilityUpdateRequestData.ts';
import { TerritoryAvailabilityUpdateRequestDataAttributes } from '../models/TerritoryAvailabilityUpdateRequestDataAttributes.ts';
import { TerritoryCode } from '../models/TerritoryCode.ts';
import { TerritoryInlineCreate } from '../models/TerritoryInlineCreate.ts';
import { TerritoryResponse } from '../models/TerritoryResponse.ts';
import { UploadOperation } from '../models/UploadOperation.ts';
import { User } from '../models/User.ts';
import { UserAttributes } from '../models/UserAttributes.ts';
import { UserInvitation } from '../models/UserInvitation.ts';
import { UserInvitationAttributes } from '../models/UserInvitationAttributes.ts';
import { UserInvitationCreateRequest } from '../models/UserInvitationCreateRequest.ts';
import { UserInvitationCreateRequestData } from '../models/UserInvitationCreateRequestData.ts';
import { UserInvitationCreateRequestDataAttributes } from '../models/UserInvitationCreateRequestDataAttributes.ts';
import { UserInvitationCreateRequestDataRelationships } from '../models/UserInvitationCreateRequestDataRelationships.ts';
import { UserInvitationCreateRequestDataRelationshipsVisibleApps } from '../models/UserInvitationCreateRequestDataRelationshipsVisibleApps.ts';
import { UserInvitationRelationships } from '../models/UserInvitationRelationships.ts';
import { UserInvitationResponse } from '../models/UserInvitationResponse.ts';
import { UserInvitationsResponse } from '../models/UserInvitationsResponse.ts';
import { UserResponse } from '../models/UserResponse.ts';
import { UserRole } from '../models/UserRole.ts';
import { UserUpdateRequest } from '../models/UserUpdateRequest.ts';
import { UserUpdateRequestData } from '../models/UserUpdateRequestData.ts';
import { UserUpdateRequestDataAttributes } from '../models/UserUpdateRequestDataAttributes.ts';
import { UserVisibleAppsLinkagesRequest } from '../models/UserVisibleAppsLinkagesRequest.ts';
import { UserVisibleAppsLinkagesResponse } from '../models/UserVisibleAppsLinkagesResponse.ts';
import { UsersResponse } from '../models/UsersResponse.ts';
import { XcodeMetrics } from '../models/XcodeMetrics.ts';
import { XcodeMetricsInsights } from '../models/XcodeMetricsInsights.ts';
import { XcodeMetricsProductDataInner } from '../models/XcodeMetricsProductDataInner.ts';
import { XcodeMetricsProductDataInnerMetricCategoriesInner } from '../models/XcodeMetricsProductDataInnerMetricCategoriesInner.ts';
import { XcodeMetricsProductDataInnerMetricCategoriesInnerMetricsInner } from '../models/XcodeMetricsProductDataInnerMetricCategoriesInnerMetricsInner.ts';
import { XcodeMetricsProductDataInnerMetricCategoriesInnerMetricsInnerDatasetsInner } from '../models/XcodeMetricsProductDataInnerMetricCategoriesInnerMetricsInnerDatasetsInner.ts';
import { XcodeMetricsProductDataInnerMetricCategoriesInnerMetricsInnerDatasetsInnerFilterCriteria } from '../models/XcodeMetricsProductDataInnerMetricCategoriesInnerMetricsInnerDatasetsInnerFilterCriteria.ts';
import { XcodeMetricsProductDataInnerMetricCategoriesInnerMetricsInnerDatasetsInnerPointsInner } from '../models/XcodeMetricsProductDataInnerMetricCategoriesInnerMetricsInnerDatasetsInnerPointsInner.ts';
import { XcodeMetricsProductDataInnerMetricCategoriesInnerMetricsInnerDatasetsInnerPointsInnerPercentageBreakdown } from '../models/XcodeMetricsProductDataInnerMetricCategoriesInnerMetricsInnerDatasetsInnerPointsInnerPercentageBreakdown.ts';
import { XcodeMetricsProductDataInnerMetricCategoriesInnerMetricsInnerGoalKeysInner } from '../models/XcodeMetricsProductDataInnerMetricCategoriesInnerMetricsInnerGoalKeysInner.ts';
import { XcodeMetricsProductDataInnerMetricCategoriesInnerMetricsInnerUnit } from '../models/XcodeMetricsProductDataInnerMetricCategoriesInnerMetricsInnerUnit.ts';

import { ActorsApiRequestFactory, ActorsApiResponseProcessor} from "../apis/ActorsApi.ts";
export class ObservableActorsApi {
    private requestFactory: ActorsApiRequestFactory;
    private responseProcessor: ActorsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: ActorsApiRequestFactory,
        responseProcessor?: ActorsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new ActorsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new ActorsApiResponseProcessor();
    }

    /**
     * @param filterId filter by id(s)
     * @param fieldsActors the fields to include for returned resources of type actors
     * @param limit maximum resources per page
     */
    public actorsGetCollectionWithHttpInfo(filterId: Array<string>, fieldsActors?: Array<'actorType' | 'apiKeyId' | 'userEmail' | 'userFirstName' | 'userLastName'>, limit?: number, _options?: Configuration): Observable<HttpInfo<ActorsResponse>> {
        const requestContextPromise = this.requestFactory.actorsGetCollection(filterId, fieldsActors, limit, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.actorsGetCollectionWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param filterId filter by id(s)
     * @param fieldsActors the fields to include for returned resources of type actors
     * @param limit maximum resources per page
     */
    public actorsGetCollection(filterId: Array<string>, fieldsActors?: Array<'actorType' | 'apiKeyId' | 'userEmail' | 'userFirstName' | 'userLastName'>, limit?: number, _options?: Configuration): Observable<ActorsResponse> {
        return this.actorsGetCollectionWithHttpInfo(filterId, fieldsActors, limit, _options).pipe(map((apiResponse: HttpInfo<ActorsResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsActors the fields to include for returned resources of type actors
     */
    public actorsGetInstanceWithHttpInfo(id: string, fieldsActors?: Array<'actorType' | 'apiKeyId' | 'userEmail' | 'userFirstName' | 'userLastName'>, _options?: Configuration): Observable<HttpInfo<ActorResponse>> {
        const requestContextPromise = this.requestFactory.actorsGetInstance(id, fieldsActors, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.actorsGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsActors the fields to include for returned resources of type actors
     */
    public actorsGetInstance(id: string, fieldsActors?: Array<'actorType' | 'apiKeyId' | 'userEmail' | 'userFirstName' | 'userLastName'>, _options?: Configuration): Observable<ActorResponse> {
        return this.actorsGetInstanceWithHttpInfo(id, fieldsActors, _options).pipe(map((apiResponse: HttpInfo<ActorResponse>) => apiResponse.data));
    }

}

import { AgeRatingDeclarationsApiRequestFactory, AgeRatingDeclarationsApiResponseProcessor} from "../apis/AgeRatingDeclarationsApi.ts";
export class ObservableAgeRatingDeclarationsApi {
    private requestFactory: AgeRatingDeclarationsApiRequestFactory;
    private responseProcessor: AgeRatingDeclarationsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: AgeRatingDeclarationsApiRequestFactory,
        responseProcessor?: AgeRatingDeclarationsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new AgeRatingDeclarationsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new AgeRatingDeclarationsApiResponseProcessor();
    }

    /**
     * @param id the id of the requested resource
     * @param ageRatingDeclarationUpdateRequest AgeRatingDeclaration representation
     */
    public ageRatingDeclarationsUpdateInstanceWithHttpInfo(id: string, ageRatingDeclarationUpdateRequest: AgeRatingDeclarationUpdateRequest, _options?: Configuration): Observable<HttpInfo<AgeRatingDeclarationResponse>> {
        const requestContextPromise = this.requestFactory.ageRatingDeclarationsUpdateInstance(id, ageRatingDeclarationUpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.ageRatingDeclarationsUpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param ageRatingDeclarationUpdateRequest AgeRatingDeclaration representation
     */
    public ageRatingDeclarationsUpdateInstance(id: string, ageRatingDeclarationUpdateRequest: AgeRatingDeclarationUpdateRequest, _options?: Configuration): Observable<AgeRatingDeclarationResponse> {
        return this.ageRatingDeclarationsUpdateInstanceWithHttpInfo(id, ageRatingDeclarationUpdateRequest, _options).pipe(map((apiResponse: HttpInfo<AgeRatingDeclarationResponse>) => apiResponse.data));
    }

}

import { AlternativeDistributionDomainsApiRequestFactory, AlternativeDistributionDomainsApiResponseProcessor} from "../apis/AlternativeDistributionDomainsApi.ts";
export class ObservableAlternativeDistributionDomainsApi {
    private requestFactory: AlternativeDistributionDomainsApiRequestFactory;
    private responseProcessor: AlternativeDistributionDomainsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: AlternativeDistributionDomainsApiRequestFactory,
        responseProcessor?: AlternativeDistributionDomainsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new AlternativeDistributionDomainsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new AlternativeDistributionDomainsApiResponseProcessor();
    }

    /**
     * @param alternativeDistributionDomainCreateRequest AlternativeDistributionDomain representation
     */
    public alternativeDistributionDomainsCreateInstanceWithHttpInfo(alternativeDistributionDomainCreateRequest: AlternativeDistributionDomainCreateRequest, _options?: Configuration): Observable<HttpInfo<AlternativeDistributionDomainResponse>> {
        const requestContextPromise = this.requestFactory.alternativeDistributionDomainsCreateInstance(alternativeDistributionDomainCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.alternativeDistributionDomainsCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param alternativeDistributionDomainCreateRequest AlternativeDistributionDomain representation
     */
    public alternativeDistributionDomainsCreateInstance(alternativeDistributionDomainCreateRequest: AlternativeDistributionDomainCreateRequest, _options?: Configuration): Observable<AlternativeDistributionDomainResponse> {
        return this.alternativeDistributionDomainsCreateInstanceWithHttpInfo(alternativeDistributionDomainCreateRequest, _options).pipe(map((apiResponse: HttpInfo<AlternativeDistributionDomainResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public alternativeDistributionDomainsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.alternativeDistributionDomainsDeleteInstance(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.alternativeDistributionDomainsDeleteInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public alternativeDistributionDomainsDeleteInstance(id: string, _options?: Configuration): Observable<void> {
        return this.alternativeDistributionDomainsDeleteInstanceWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param fieldsAlternativeDistributionDomains the fields to include for returned resources of type alternativeDistributionDomains
     * @param limit maximum resources per page
     */
    public alternativeDistributionDomainsGetCollectionWithHttpInfo(fieldsAlternativeDistributionDomains?: Array<'createdDate' | 'domain' | 'referenceName'>, limit?: number, _options?: Configuration): Observable<HttpInfo<AlternativeDistributionDomainsResponse>> {
        const requestContextPromise = this.requestFactory.alternativeDistributionDomainsGetCollection(fieldsAlternativeDistributionDomains, limit, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.alternativeDistributionDomainsGetCollectionWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param fieldsAlternativeDistributionDomains the fields to include for returned resources of type alternativeDistributionDomains
     * @param limit maximum resources per page
     */
    public alternativeDistributionDomainsGetCollection(fieldsAlternativeDistributionDomains?: Array<'createdDate' | 'domain' | 'referenceName'>, limit?: number, _options?: Configuration): Observable<AlternativeDistributionDomainsResponse> {
        return this.alternativeDistributionDomainsGetCollectionWithHttpInfo(fieldsAlternativeDistributionDomains, limit, _options).pipe(map((apiResponse: HttpInfo<AlternativeDistributionDomainsResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAlternativeDistributionDomains the fields to include for returned resources of type alternativeDistributionDomains
     */
    public alternativeDistributionDomainsGetInstanceWithHttpInfo(id: string, fieldsAlternativeDistributionDomains?: Array<'createdDate' | 'domain' | 'referenceName'>, _options?: Configuration): Observable<HttpInfo<AlternativeDistributionDomainResponse>> {
        const requestContextPromise = this.requestFactory.alternativeDistributionDomainsGetInstance(id, fieldsAlternativeDistributionDomains, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.alternativeDistributionDomainsGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAlternativeDistributionDomains the fields to include for returned resources of type alternativeDistributionDomains
     */
    public alternativeDistributionDomainsGetInstance(id: string, fieldsAlternativeDistributionDomains?: Array<'createdDate' | 'domain' | 'referenceName'>, _options?: Configuration): Observable<AlternativeDistributionDomainResponse> {
        return this.alternativeDistributionDomainsGetInstanceWithHttpInfo(id, fieldsAlternativeDistributionDomains, _options).pipe(map((apiResponse: HttpInfo<AlternativeDistributionDomainResponse>) => apiResponse.data));
    }

}

import { AlternativeDistributionKeysApiRequestFactory, AlternativeDistributionKeysApiResponseProcessor} from "../apis/AlternativeDistributionKeysApi.ts";
export class ObservableAlternativeDistributionKeysApi {
    private requestFactory: AlternativeDistributionKeysApiRequestFactory;
    private responseProcessor: AlternativeDistributionKeysApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: AlternativeDistributionKeysApiRequestFactory,
        responseProcessor?: AlternativeDistributionKeysApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new AlternativeDistributionKeysApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new AlternativeDistributionKeysApiResponseProcessor();
    }

    /**
     * @param alternativeDistributionKeyCreateRequest AlternativeDistributionKey representation
     */
    public alternativeDistributionKeysCreateInstanceWithHttpInfo(alternativeDistributionKeyCreateRequest: AlternativeDistributionKeyCreateRequest, _options?: Configuration): Observable<HttpInfo<AlternativeDistributionKeyResponse>> {
        const requestContextPromise = this.requestFactory.alternativeDistributionKeysCreateInstance(alternativeDistributionKeyCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.alternativeDistributionKeysCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param alternativeDistributionKeyCreateRequest AlternativeDistributionKey representation
     */
    public alternativeDistributionKeysCreateInstance(alternativeDistributionKeyCreateRequest: AlternativeDistributionKeyCreateRequest, _options?: Configuration): Observable<AlternativeDistributionKeyResponse> {
        return this.alternativeDistributionKeysCreateInstanceWithHttpInfo(alternativeDistributionKeyCreateRequest, _options).pipe(map((apiResponse: HttpInfo<AlternativeDistributionKeyResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public alternativeDistributionKeysDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.alternativeDistributionKeysDeleteInstance(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.alternativeDistributionKeysDeleteInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public alternativeDistributionKeysDeleteInstance(id: string, _options?: Configuration): Observable<void> {
        return this.alternativeDistributionKeysDeleteInstanceWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAlternativeDistributionKeys the fields to include for returned resources of type alternativeDistributionKeys
     */
    public alternativeDistributionKeysGetInstanceWithHttpInfo(id: string, fieldsAlternativeDistributionKeys?: Array<'app' | 'publicKey'>, _options?: Configuration): Observable<HttpInfo<AlternativeDistributionKeyResponse>> {
        const requestContextPromise = this.requestFactory.alternativeDistributionKeysGetInstance(id, fieldsAlternativeDistributionKeys, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.alternativeDistributionKeysGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAlternativeDistributionKeys the fields to include for returned resources of type alternativeDistributionKeys
     */
    public alternativeDistributionKeysGetInstance(id: string, fieldsAlternativeDistributionKeys?: Array<'app' | 'publicKey'>, _options?: Configuration): Observable<AlternativeDistributionKeyResponse> {
        return this.alternativeDistributionKeysGetInstanceWithHttpInfo(id, fieldsAlternativeDistributionKeys, _options).pipe(map((apiResponse: HttpInfo<AlternativeDistributionKeyResponse>) => apiResponse.data));
    }

}

import { AlternativeDistributionPackageDeltasApiRequestFactory, AlternativeDistributionPackageDeltasApiResponseProcessor} from "../apis/AlternativeDistributionPackageDeltasApi.ts";
export class ObservableAlternativeDistributionPackageDeltasApi {
    private requestFactory: AlternativeDistributionPackageDeltasApiRequestFactory;
    private responseProcessor: AlternativeDistributionPackageDeltasApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: AlternativeDistributionPackageDeltasApiRequestFactory,
        responseProcessor?: AlternativeDistributionPackageDeltasApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new AlternativeDistributionPackageDeltasApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new AlternativeDistributionPackageDeltasApiResponseProcessor();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAlternativeDistributionPackageDeltas the fields to include for returned resources of type alternativeDistributionPackageDeltas
     */
    public alternativeDistributionPackageDeltasGetInstanceWithHttpInfo(id: string, fieldsAlternativeDistributionPackageDeltas?: Array<'alternativeDistributionKeyBlob' | 'fileChecksum' | 'url' | 'urlExpirationDate'>, _options?: Configuration): Observable<HttpInfo<AlternativeDistributionPackageDeltaResponse>> {
        const requestContextPromise = this.requestFactory.alternativeDistributionPackageDeltasGetInstance(id, fieldsAlternativeDistributionPackageDeltas, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.alternativeDistributionPackageDeltasGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAlternativeDistributionPackageDeltas the fields to include for returned resources of type alternativeDistributionPackageDeltas
     */
    public alternativeDistributionPackageDeltasGetInstance(id: string, fieldsAlternativeDistributionPackageDeltas?: Array<'alternativeDistributionKeyBlob' | 'fileChecksum' | 'url' | 'urlExpirationDate'>, _options?: Configuration): Observable<AlternativeDistributionPackageDeltaResponse> {
        return this.alternativeDistributionPackageDeltasGetInstanceWithHttpInfo(id, fieldsAlternativeDistributionPackageDeltas, _options).pipe(map((apiResponse: HttpInfo<AlternativeDistributionPackageDeltaResponse>) => apiResponse.data));
    }

}

import { AlternativeDistributionPackageVariantsApiRequestFactory, AlternativeDistributionPackageVariantsApiResponseProcessor} from "../apis/AlternativeDistributionPackageVariantsApi.ts";
export class ObservableAlternativeDistributionPackageVariantsApi {
    private requestFactory: AlternativeDistributionPackageVariantsApiRequestFactory;
    private responseProcessor: AlternativeDistributionPackageVariantsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: AlternativeDistributionPackageVariantsApiRequestFactory,
        responseProcessor?: AlternativeDistributionPackageVariantsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new AlternativeDistributionPackageVariantsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new AlternativeDistributionPackageVariantsApiResponseProcessor();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAlternativeDistributionPackageVariants the fields to include for returned resources of type alternativeDistributionPackageVariants
     */
    public alternativeDistributionPackageVariantsGetInstanceWithHttpInfo(id: string, fieldsAlternativeDistributionPackageVariants?: Array<'alternativeDistributionKeyBlob' | 'fileChecksum' | 'url' | 'urlExpirationDate'>, _options?: Configuration): Observable<HttpInfo<AlternativeDistributionPackageVariantResponse>> {
        const requestContextPromise = this.requestFactory.alternativeDistributionPackageVariantsGetInstance(id, fieldsAlternativeDistributionPackageVariants, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.alternativeDistributionPackageVariantsGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAlternativeDistributionPackageVariants the fields to include for returned resources of type alternativeDistributionPackageVariants
     */
    public alternativeDistributionPackageVariantsGetInstance(id: string, fieldsAlternativeDistributionPackageVariants?: Array<'alternativeDistributionKeyBlob' | 'fileChecksum' | 'url' | 'urlExpirationDate'>, _options?: Configuration): Observable<AlternativeDistributionPackageVariantResponse> {
        return this.alternativeDistributionPackageVariantsGetInstanceWithHttpInfo(id, fieldsAlternativeDistributionPackageVariants, _options).pipe(map((apiResponse: HttpInfo<AlternativeDistributionPackageVariantResponse>) => apiResponse.data));
    }

}

import { AlternativeDistributionPackageVersionsApiRequestFactory, AlternativeDistributionPackageVersionsApiResponseProcessor} from "../apis/AlternativeDistributionPackageVersionsApi.ts";
export class ObservableAlternativeDistributionPackageVersionsApi {
    private requestFactory: AlternativeDistributionPackageVersionsApiRequestFactory;
    private responseProcessor: AlternativeDistributionPackageVersionsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: AlternativeDistributionPackageVersionsApiRequestFactory,
        responseProcessor?: AlternativeDistributionPackageVersionsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new AlternativeDistributionPackageVersionsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new AlternativeDistributionPackageVersionsApiResponseProcessor();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAlternativeDistributionPackageDeltas the fields to include for returned resources of type alternativeDistributionPackageDeltas
     * @param limit maximum resources per page
     */
    public alternativeDistributionPackageVersionsDeltasGetToManyRelatedWithHttpInfo(id: string, fieldsAlternativeDistributionPackageDeltas?: Array<'alternativeDistributionKeyBlob' | 'fileChecksum' | 'url' | 'urlExpirationDate'>, limit?: number, _options?: Configuration): Observable<HttpInfo<AlternativeDistributionPackageDeltasResponse>> {
        const requestContextPromise = this.requestFactory.alternativeDistributionPackageVersionsDeltasGetToManyRelated(id, fieldsAlternativeDistributionPackageDeltas, limit, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.alternativeDistributionPackageVersionsDeltasGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAlternativeDistributionPackageDeltas the fields to include for returned resources of type alternativeDistributionPackageDeltas
     * @param limit maximum resources per page
     */
    public alternativeDistributionPackageVersionsDeltasGetToManyRelated(id: string, fieldsAlternativeDistributionPackageDeltas?: Array<'alternativeDistributionKeyBlob' | 'fileChecksum' | 'url' | 'urlExpirationDate'>, limit?: number, _options?: Configuration): Observable<AlternativeDistributionPackageDeltasResponse> {
        return this.alternativeDistributionPackageVersionsDeltasGetToManyRelatedWithHttpInfo(id, fieldsAlternativeDistributionPackageDeltas, limit, _options).pipe(map((apiResponse: HttpInfo<AlternativeDistributionPackageDeltasResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAlternativeDistributionPackageVersions the fields to include for returned resources of type alternativeDistributionPackageVersions
     * @param include comma-separated list of relationships to include
     * @param fieldsAlternativeDistributionPackageVariants the fields to include for returned resources of type alternativeDistributionPackageVariants
     * @param fieldsAlternativeDistributionPackageDeltas the fields to include for returned resources of type alternativeDistributionPackageDeltas
     * @param limitDeltas maximum number of related deltas returned (when they are included)
     * @param limitVariants maximum number of related variants returned (when they are included)
     */
    public alternativeDistributionPackageVersionsGetInstanceWithHttpInfo(id: string, fieldsAlternativeDistributionPackageVersions?: Array<'alternativeDistributionPackage' | 'deltas' | 'fileChecksum' | 'state' | 'url' | 'urlExpirationDate' | 'variants' | 'version'>, include?: Array<'alternativeDistributionPackage' | 'deltas' | 'variants'>, fieldsAlternativeDistributionPackageVariants?: Array<'alternativeDistributionKeyBlob' | 'fileChecksum' | 'url' | 'urlExpirationDate'>, fieldsAlternativeDistributionPackageDeltas?: Array<'alternativeDistributionKeyBlob' | 'fileChecksum' | 'url' | 'urlExpirationDate'>, limitDeltas?: number, limitVariants?: number, _options?: Configuration): Observable<HttpInfo<AlternativeDistributionPackageVersionResponse>> {
        const requestContextPromise = this.requestFactory.alternativeDistributionPackageVersionsGetInstance(id, fieldsAlternativeDistributionPackageVersions, include, fieldsAlternativeDistributionPackageVariants, fieldsAlternativeDistributionPackageDeltas, limitDeltas, limitVariants, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.alternativeDistributionPackageVersionsGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAlternativeDistributionPackageVersions the fields to include for returned resources of type alternativeDistributionPackageVersions
     * @param include comma-separated list of relationships to include
     * @param fieldsAlternativeDistributionPackageVariants the fields to include for returned resources of type alternativeDistributionPackageVariants
     * @param fieldsAlternativeDistributionPackageDeltas the fields to include for returned resources of type alternativeDistributionPackageDeltas
     * @param limitDeltas maximum number of related deltas returned (when they are included)
     * @param limitVariants maximum number of related variants returned (when they are included)
     */
    public alternativeDistributionPackageVersionsGetInstance(id: string, fieldsAlternativeDistributionPackageVersions?: Array<'alternativeDistributionPackage' | 'deltas' | 'fileChecksum' | 'state' | 'url' | 'urlExpirationDate' | 'variants' | 'version'>, include?: Array<'alternativeDistributionPackage' | 'deltas' | 'variants'>, fieldsAlternativeDistributionPackageVariants?: Array<'alternativeDistributionKeyBlob' | 'fileChecksum' | 'url' | 'urlExpirationDate'>, fieldsAlternativeDistributionPackageDeltas?: Array<'alternativeDistributionKeyBlob' | 'fileChecksum' | 'url' | 'urlExpirationDate'>, limitDeltas?: number, limitVariants?: number, _options?: Configuration): Observable<AlternativeDistributionPackageVersionResponse> {
        return this.alternativeDistributionPackageVersionsGetInstanceWithHttpInfo(id, fieldsAlternativeDistributionPackageVersions, include, fieldsAlternativeDistributionPackageVariants, fieldsAlternativeDistributionPackageDeltas, limitDeltas, limitVariants, _options).pipe(map((apiResponse: HttpInfo<AlternativeDistributionPackageVersionResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAlternativeDistributionPackageVariants the fields to include for returned resources of type alternativeDistributionPackageVariants
     * @param limit maximum resources per page
     */
    public alternativeDistributionPackageVersionsVariantsGetToManyRelatedWithHttpInfo(id: string, fieldsAlternativeDistributionPackageVariants?: Array<'alternativeDistributionKeyBlob' | 'fileChecksum' | 'url' | 'urlExpirationDate'>, limit?: number, _options?: Configuration): Observable<HttpInfo<AlternativeDistributionPackageVariantsResponse>> {
        const requestContextPromise = this.requestFactory.alternativeDistributionPackageVersionsVariantsGetToManyRelated(id, fieldsAlternativeDistributionPackageVariants, limit, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.alternativeDistributionPackageVersionsVariantsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAlternativeDistributionPackageVariants the fields to include for returned resources of type alternativeDistributionPackageVariants
     * @param limit maximum resources per page
     */
    public alternativeDistributionPackageVersionsVariantsGetToManyRelated(id: string, fieldsAlternativeDistributionPackageVariants?: Array<'alternativeDistributionKeyBlob' | 'fileChecksum' | 'url' | 'urlExpirationDate'>, limit?: number, _options?: Configuration): Observable<AlternativeDistributionPackageVariantsResponse> {
        return this.alternativeDistributionPackageVersionsVariantsGetToManyRelatedWithHttpInfo(id, fieldsAlternativeDistributionPackageVariants, limit, _options).pipe(map((apiResponse: HttpInfo<AlternativeDistributionPackageVariantsResponse>) => apiResponse.data));
    }

}

import { AlternativeDistributionPackagesApiRequestFactory, AlternativeDistributionPackagesApiResponseProcessor} from "../apis/AlternativeDistributionPackagesApi.ts";
export class ObservableAlternativeDistributionPackagesApi {
    private requestFactory: AlternativeDistributionPackagesApiRequestFactory;
    private responseProcessor: AlternativeDistributionPackagesApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: AlternativeDistributionPackagesApiRequestFactory,
        responseProcessor?: AlternativeDistributionPackagesApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new AlternativeDistributionPackagesApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new AlternativeDistributionPackagesApiResponseProcessor();
    }

    /**
     * @param alternativeDistributionPackageCreateRequest AlternativeDistributionPackage representation
     */
    public alternativeDistributionPackagesCreateInstanceWithHttpInfo(alternativeDistributionPackageCreateRequest: AlternativeDistributionPackageCreateRequest, _options?: Configuration): Observable<HttpInfo<AlternativeDistributionPackageResponse>> {
        const requestContextPromise = this.requestFactory.alternativeDistributionPackagesCreateInstance(alternativeDistributionPackageCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.alternativeDistributionPackagesCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param alternativeDistributionPackageCreateRequest AlternativeDistributionPackage representation
     */
    public alternativeDistributionPackagesCreateInstance(alternativeDistributionPackageCreateRequest: AlternativeDistributionPackageCreateRequest, _options?: Configuration): Observable<AlternativeDistributionPackageResponse> {
        return this.alternativeDistributionPackagesCreateInstanceWithHttpInfo(alternativeDistributionPackageCreateRequest, _options).pipe(map((apiResponse: HttpInfo<AlternativeDistributionPackageResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAlternativeDistributionPackages the fields to include for returned resources of type alternativeDistributionPackages
     * @param include comma-separated list of relationships to include
     * @param fieldsAlternativeDistributionPackageVersions the fields to include for returned resources of type alternativeDistributionPackageVersions
     * @param limitVersions maximum number of related versions returned (when they are included)
     */
    public alternativeDistributionPackagesGetInstanceWithHttpInfo(id: string, fieldsAlternativeDistributionPackages?: Array<'appStoreVersion' | 'versions'>, include?: Array<'versions'>, fieldsAlternativeDistributionPackageVersions?: Array<'alternativeDistributionPackage' | 'deltas' | 'fileChecksum' | 'state' | 'url' | 'urlExpirationDate' | 'variants' | 'version'>, limitVersions?: number, _options?: Configuration): Observable<HttpInfo<AlternativeDistributionPackageResponse>> {
        const requestContextPromise = this.requestFactory.alternativeDistributionPackagesGetInstance(id, fieldsAlternativeDistributionPackages, include, fieldsAlternativeDistributionPackageVersions, limitVersions, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.alternativeDistributionPackagesGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAlternativeDistributionPackages the fields to include for returned resources of type alternativeDistributionPackages
     * @param include comma-separated list of relationships to include
     * @param fieldsAlternativeDistributionPackageVersions the fields to include for returned resources of type alternativeDistributionPackageVersions
     * @param limitVersions maximum number of related versions returned (when they are included)
     */
    public alternativeDistributionPackagesGetInstance(id: string, fieldsAlternativeDistributionPackages?: Array<'appStoreVersion' | 'versions'>, include?: Array<'versions'>, fieldsAlternativeDistributionPackageVersions?: Array<'alternativeDistributionPackage' | 'deltas' | 'fileChecksum' | 'state' | 'url' | 'urlExpirationDate' | 'variants' | 'version'>, limitVersions?: number, _options?: Configuration): Observable<AlternativeDistributionPackageResponse> {
        return this.alternativeDistributionPackagesGetInstanceWithHttpInfo(id, fieldsAlternativeDistributionPackages, include, fieldsAlternativeDistributionPackageVersions, limitVersions, _options).pipe(map((apiResponse: HttpInfo<AlternativeDistributionPackageResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param filterState filter by attribute \&#39;state\&#39;
     * @param fieldsAlternativeDistributionPackageVariants the fields to include for returned resources of type alternativeDistributionPackageVariants
     * @param fieldsAlternativeDistributionPackages the fields to include for returned resources of type alternativeDistributionPackages
     * @param fieldsAlternativeDistributionPackageVersions the fields to include for returned resources of type alternativeDistributionPackageVersions
     * @param fieldsAlternativeDistributionPackageDeltas the fields to include for returned resources of type alternativeDistributionPackageDeltas
     * @param limit maximum resources per page
     * @param limitVariants maximum number of related variants returned (when they are included)
     * @param limitDeltas maximum number of related deltas returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public alternativeDistributionPackagesVersionsGetToManyRelatedWithHttpInfo(id: string, filterState?: Array<'COMPLETED' | 'REPLACED'>, fieldsAlternativeDistributionPackageVariants?: Array<'alternativeDistributionKeyBlob' | 'fileChecksum' | 'url' | 'urlExpirationDate'>, fieldsAlternativeDistributionPackages?: Array<'appStoreVersion' | 'versions'>, fieldsAlternativeDistributionPackageVersions?: Array<'alternativeDistributionPackage' | 'deltas' | 'fileChecksum' | 'state' | 'url' | 'urlExpirationDate' | 'variants' | 'version'>, fieldsAlternativeDistributionPackageDeltas?: Array<'alternativeDistributionKeyBlob' | 'fileChecksum' | 'url' | 'urlExpirationDate'>, limit?: number, limitVariants?: number, limitDeltas?: number, include?: Array<'alternativeDistributionPackage' | 'deltas' | 'variants'>, _options?: Configuration): Observable<HttpInfo<AlternativeDistributionPackageVersionsResponse>> {
        const requestContextPromise = this.requestFactory.alternativeDistributionPackagesVersionsGetToManyRelated(id, filterState, fieldsAlternativeDistributionPackageVariants, fieldsAlternativeDistributionPackages, fieldsAlternativeDistributionPackageVersions, fieldsAlternativeDistributionPackageDeltas, limit, limitVariants, limitDeltas, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.alternativeDistributionPackagesVersionsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param filterState filter by attribute \&#39;state\&#39;
     * @param fieldsAlternativeDistributionPackageVariants the fields to include for returned resources of type alternativeDistributionPackageVariants
     * @param fieldsAlternativeDistributionPackages the fields to include for returned resources of type alternativeDistributionPackages
     * @param fieldsAlternativeDistributionPackageVersions the fields to include for returned resources of type alternativeDistributionPackageVersions
     * @param fieldsAlternativeDistributionPackageDeltas the fields to include for returned resources of type alternativeDistributionPackageDeltas
     * @param limit maximum resources per page
     * @param limitVariants maximum number of related variants returned (when they are included)
     * @param limitDeltas maximum number of related deltas returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public alternativeDistributionPackagesVersionsGetToManyRelated(id: string, filterState?: Array<'COMPLETED' | 'REPLACED'>, fieldsAlternativeDistributionPackageVariants?: Array<'alternativeDistributionKeyBlob' | 'fileChecksum' | 'url' | 'urlExpirationDate'>, fieldsAlternativeDistributionPackages?: Array<'appStoreVersion' | 'versions'>, fieldsAlternativeDistributionPackageVersions?: Array<'alternativeDistributionPackage' | 'deltas' | 'fileChecksum' | 'state' | 'url' | 'urlExpirationDate' | 'variants' | 'version'>, fieldsAlternativeDistributionPackageDeltas?: Array<'alternativeDistributionKeyBlob' | 'fileChecksum' | 'url' | 'urlExpirationDate'>, limit?: number, limitVariants?: number, limitDeltas?: number, include?: Array<'alternativeDistributionPackage' | 'deltas' | 'variants'>, _options?: Configuration): Observable<AlternativeDistributionPackageVersionsResponse> {
        return this.alternativeDistributionPackagesVersionsGetToManyRelatedWithHttpInfo(id, filterState, fieldsAlternativeDistributionPackageVariants, fieldsAlternativeDistributionPackages, fieldsAlternativeDistributionPackageVersions, fieldsAlternativeDistributionPackageDeltas, limit, limitVariants, limitDeltas, include, _options).pipe(map((apiResponse: HttpInfo<AlternativeDistributionPackageVersionsResponse>) => apiResponse.data));
    }

}

import { AnalyticsReportInstancesApiRequestFactory, AnalyticsReportInstancesApiResponseProcessor} from "../apis/AnalyticsReportInstancesApi.ts";
export class ObservableAnalyticsReportInstancesApi {
    private requestFactory: AnalyticsReportInstancesApiRequestFactory;
    private responseProcessor: AnalyticsReportInstancesApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: AnalyticsReportInstancesApiRequestFactory,
        responseProcessor?: AnalyticsReportInstancesApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new AnalyticsReportInstancesApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new AnalyticsReportInstancesApiResponseProcessor();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAnalyticsReportInstances the fields to include for returned resources of type analyticsReportInstances
     * @param fieldsAnalyticsReportSegments the fields to include for returned resources of type analyticsReportSegments
     */
    public analyticsReportInstancesGetInstanceWithHttpInfo(id: string, fieldsAnalyticsReportInstances?: Array<'granularity' | 'processingDate' | 'segments'>, fieldsAnalyticsReportSegments?: Array<'checksum' | 'sizeInBytes' | 'url'>, _options?: Configuration): Observable<HttpInfo<AnalyticsReportInstanceResponse>> {
        const requestContextPromise = this.requestFactory.analyticsReportInstancesGetInstance(id, fieldsAnalyticsReportInstances, fieldsAnalyticsReportSegments, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.analyticsReportInstancesGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAnalyticsReportInstances the fields to include for returned resources of type analyticsReportInstances
     * @param fieldsAnalyticsReportSegments the fields to include for returned resources of type analyticsReportSegments
     */
    public analyticsReportInstancesGetInstance(id: string, fieldsAnalyticsReportInstances?: Array<'granularity' | 'processingDate' | 'segments'>, fieldsAnalyticsReportSegments?: Array<'checksum' | 'sizeInBytes' | 'url'>, _options?: Configuration): Observable<AnalyticsReportInstanceResponse> {
        return this.analyticsReportInstancesGetInstanceWithHttpInfo(id, fieldsAnalyticsReportInstances, fieldsAnalyticsReportSegments, _options).pipe(map((apiResponse: HttpInfo<AnalyticsReportInstanceResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAnalyticsReportSegments the fields to include for returned resources of type analyticsReportSegments
     * @param limit maximum resources per page
     */
    public analyticsReportInstancesSegmentsGetToManyRelatedWithHttpInfo(id: string, fieldsAnalyticsReportSegments?: Array<'checksum' | 'sizeInBytes' | 'url'>, limit?: number, _options?: Configuration): Observable<HttpInfo<AnalyticsReportSegmentsResponse>> {
        const requestContextPromise = this.requestFactory.analyticsReportInstancesSegmentsGetToManyRelated(id, fieldsAnalyticsReportSegments, limit, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.analyticsReportInstancesSegmentsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAnalyticsReportSegments the fields to include for returned resources of type analyticsReportSegments
     * @param limit maximum resources per page
     */
    public analyticsReportInstancesSegmentsGetToManyRelated(id: string, fieldsAnalyticsReportSegments?: Array<'checksum' | 'sizeInBytes' | 'url'>, limit?: number, _options?: Configuration): Observable<AnalyticsReportSegmentsResponse> {
        return this.analyticsReportInstancesSegmentsGetToManyRelatedWithHttpInfo(id, fieldsAnalyticsReportSegments, limit, _options).pipe(map((apiResponse: HttpInfo<AnalyticsReportSegmentsResponse>) => apiResponse.data));
    }

}

import { AnalyticsReportRequestsApiRequestFactory, AnalyticsReportRequestsApiResponseProcessor} from "../apis/AnalyticsReportRequestsApi.ts";
export class ObservableAnalyticsReportRequestsApi {
    private requestFactory: AnalyticsReportRequestsApiRequestFactory;
    private responseProcessor: AnalyticsReportRequestsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: AnalyticsReportRequestsApiRequestFactory,
        responseProcessor?: AnalyticsReportRequestsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new AnalyticsReportRequestsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new AnalyticsReportRequestsApiResponseProcessor();
    }

    /**
     * @param analyticsReportRequestCreateRequest AnalyticsReportRequest representation
     */
    public analyticsReportRequestsCreateInstanceWithHttpInfo(analyticsReportRequestCreateRequest: AnalyticsReportRequestCreateRequest, _options?: Configuration): Observable<HttpInfo<AnalyticsReportRequestResponse>> {
        const requestContextPromise = this.requestFactory.analyticsReportRequestsCreateInstance(analyticsReportRequestCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.analyticsReportRequestsCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param analyticsReportRequestCreateRequest AnalyticsReportRequest representation
     */
    public analyticsReportRequestsCreateInstance(analyticsReportRequestCreateRequest: AnalyticsReportRequestCreateRequest, _options?: Configuration): Observable<AnalyticsReportRequestResponse> {
        return this.analyticsReportRequestsCreateInstanceWithHttpInfo(analyticsReportRequestCreateRequest, _options).pipe(map((apiResponse: HttpInfo<AnalyticsReportRequestResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public analyticsReportRequestsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.analyticsReportRequestsDeleteInstance(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.analyticsReportRequestsDeleteInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public analyticsReportRequestsDeleteInstance(id: string, _options?: Configuration): Observable<void> {
        return this.analyticsReportRequestsDeleteInstanceWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAnalyticsReportRequests the fields to include for returned resources of type analyticsReportRequests
     * @param include comma-separated list of relationships to include
     * @param fieldsAnalyticsReports the fields to include for returned resources of type analyticsReports
     * @param limitReports maximum number of related reports returned (when they are included)
     */
    public analyticsReportRequestsGetInstanceWithHttpInfo(id: string, fieldsAnalyticsReportRequests?: Array<'accessType' | 'app' | 'reports' | 'stoppedDueToInactivity'>, include?: Array<'reports'>, fieldsAnalyticsReports?: Array<'category' | 'instances' | 'name'>, limitReports?: number, _options?: Configuration): Observable<HttpInfo<AnalyticsReportRequestResponse>> {
        const requestContextPromise = this.requestFactory.analyticsReportRequestsGetInstance(id, fieldsAnalyticsReportRequests, include, fieldsAnalyticsReports, limitReports, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.analyticsReportRequestsGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAnalyticsReportRequests the fields to include for returned resources of type analyticsReportRequests
     * @param include comma-separated list of relationships to include
     * @param fieldsAnalyticsReports the fields to include for returned resources of type analyticsReports
     * @param limitReports maximum number of related reports returned (when they are included)
     */
    public analyticsReportRequestsGetInstance(id: string, fieldsAnalyticsReportRequests?: Array<'accessType' | 'app' | 'reports' | 'stoppedDueToInactivity'>, include?: Array<'reports'>, fieldsAnalyticsReports?: Array<'category' | 'instances' | 'name'>, limitReports?: number, _options?: Configuration): Observable<AnalyticsReportRequestResponse> {
        return this.analyticsReportRequestsGetInstanceWithHttpInfo(id, fieldsAnalyticsReportRequests, include, fieldsAnalyticsReports, limitReports, _options).pipe(map((apiResponse: HttpInfo<AnalyticsReportRequestResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param filterCategory filter by attribute \&#39;category\&#39;
     * @param filterName filter by attribute \&#39;name\&#39;
     * @param fieldsAnalyticsReports the fields to include for returned resources of type analyticsReports
     * @param limit maximum resources per page
     */
    public analyticsReportRequestsReportsGetToManyRelatedWithHttpInfo(id: string, filterCategory?: Array<'APP_USAGE' | 'APP_STORE_ENGAGEMENT' | 'COMMERCE' | 'FRAMEWORK_USAGE' | 'PERFORMANCE'>, filterName?: Array<string>, fieldsAnalyticsReports?: Array<'category' | 'instances' | 'name'>, limit?: number, _options?: Configuration): Observable<HttpInfo<AnalyticsReportsResponse>> {
        const requestContextPromise = this.requestFactory.analyticsReportRequestsReportsGetToManyRelated(id, filterCategory, filterName, fieldsAnalyticsReports, limit, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.analyticsReportRequestsReportsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param filterCategory filter by attribute \&#39;category\&#39;
     * @param filterName filter by attribute \&#39;name\&#39;
     * @param fieldsAnalyticsReports the fields to include for returned resources of type analyticsReports
     * @param limit maximum resources per page
     */
    public analyticsReportRequestsReportsGetToManyRelated(id: string, filterCategory?: Array<'APP_USAGE' | 'APP_STORE_ENGAGEMENT' | 'COMMERCE' | 'FRAMEWORK_USAGE' | 'PERFORMANCE'>, filterName?: Array<string>, fieldsAnalyticsReports?: Array<'category' | 'instances' | 'name'>, limit?: number, _options?: Configuration): Observable<AnalyticsReportsResponse> {
        return this.analyticsReportRequestsReportsGetToManyRelatedWithHttpInfo(id, filterCategory, filterName, fieldsAnalyticsReports, limit, _options).pipe(map((apiResponse: HttpInfo<AnalyticsReportsResponse>) => apiResponse.data));
    }

}

import { AnalyticsReportSegmentsApiRequestFactory, AnalyticsReportSegmentsApiResponseProcessor} from "../apis/AnalyticsReportSegmentsApi.ts";
export class ObservableAnalyticsReportSegmentsApi {
    private requestFactory: AnalyticsReportSegmentsApiRequestFactory;
    private responseProcessor: AnalyticsReportSegmentsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: AnalyticsReportSegmentsApiRequestFactory,
        responseProcessor?: AnalyticsReportSegmentsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new AnalyticsReportSegmentsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new AnalyticsReportSegmentsApiResponseProcessor();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAnalyticsReportSegments the fields to include for returned resources of type analyticsReportSegments
     */
    public analyticsReportSegmentsGetInstanceWithHttpInfo(id: string, fieldsAnalyticsReportSegments?: Array<'checksum' | 'sizeInBytes' | 'url'>, _options?: Configuration): Observable<HttpInfo<AnalyticsReportSegmentResponse>> {
        const requestContextPromise = this.requestFactory.analyticsReportSegmentsGetInstance(id, fieldsAnalyticsReportSegments, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.analyticsReportSegmentsGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAnalyticsReportSegments the fields to include for returned resources of type analyticsReportSegments
     */
    public analyticsReportSegmentsGetInstance(id: string, fieldsAnalyticsReportSegments?: Array<'checksum' | 'sizeInBytes' | 'url'>, _options?: Configuration): Observable<AnalyticsReportSegmentResponse> {
        return this.analyticsReportSegmentsGetInstanceWithHttpInfo(id, fieldsAnalyticsReportSegments, _options).pipe(map((apiResponse: HttpInfo<AnalyticsReportSegmentResponse>) => apiResponse.data));
    }

}

import { AnalyticsReportsApiRequestFactory, AnalyticsReportsApiResponseProcessor} from "../apis/AnalyticsReportsApi.ts";
export class ObservableAnalyticsReportsApi {
    private requestFactory: AnalyticsReportsApiRequestFactory;
    private responseProcessor: AnalyticsReportsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: AnalyticsReportsApiRequestFactory,
        responseProcessor?: AnalyticsReportsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new AnalyticsReportsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new AnalyticsReportsApiResponseProcessor();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAnalyticsReports the fields to include for returned resources of type analyticsReports
     * @param fieldsAnalyticsReportInstances the fields to include for returned resources of type analyticsReportInstances
     */
    public analyticsReportsGetInstanceWithHttpInfo(id: string, fieldsAnalyticsReports?: Array<'category' | 'instances' | 'name'>, fieldsAnalyticsReportInstances?: Array<'granularity' | 'processingDate' | 'segments'>, _options?: Configuration): Observable<HttpInfo<AnalyticsReportResponse>> {
        const requestContextPromise = this.requestFactory.analyticsReportsGetInstance(id, fieldsAnalyticsReports, fieldsAnalyticsReportInstances, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.analyticsReportsGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAnalyticsReports the fields to include for returned resources of type analyticsReports
     * @param fieldsAnalyticsReportInstances the fields to include for returned resources of type analyticsReportInstances
     */
    public analyticsReportsGetInstance(id: string, fieldsAnalyticsReports?: Array<'category' | 'instances' | 'name'>, fieldsAnalyticsReportInstances?: Array<'granularity' | 'processingDate' | 'segments'>, _options?: Configuration): Observable<AnalyticsReportResponse> {
        return this.analyticsReportsGetInstanceWithHttpInfo(id, fieldsAnalyticsReports, fieldsAnalyticsReportInstances, _options).pipe(map((apiResponse: HttpInfo<AnalyticsReportResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param filterGranularity filter by attribute \&#39;granularity\&#39;
     * @param filterProcessingDate filter by attribute \&#39;processingDate\&#39;
     * @param fieldsAnalyticsReportInstances the fields to include for returned resources of type analyticsReportInstances
     * @param limit maximum resources per page
     */
    public analyticsReportsInstancesGetToManyRelatedWithHttpInfo(id: string, filterGranularity?: Array<'DAILY' | 'WEEKLY' | 'MONTHLY'>, filterProcessingDate?: Array<string>, fieldsAnalyticsReportInstances?: Array<'granularity' | 'processingDate' | 'segments'>, limit?: number, _options?: Configuration): Observable<HttpInfo<AnalyticsReportInstancesResponse>> {
        const requestContextPromise = this.requestFactory.analyticsReportsInstancesGetToManyRelated(id, filterGranularity, filterProcessingDate, fieldsAnalyticsReportInstances, limit, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.analyticsReportsInstancesGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param filterGranularity filter by attribute \&#39;granularity\&#39;
     * @param filterProcessingDate filter by attribute \&#39;processingDate\&#39;
     * @param fieldsAnalyticsReportInstances the fields to include for returned resources of type analyticsReportInstances
     * @param limit maximum resources per page
     */
    public analyticsReportsInstancesGetToManyRelated(id: string, filterGranularity?: Array<'DAILY' | 'WEEKLY' | 'MONTHLY'>, filterProcessingDate?: Array<string>, fieldsAnalyticsReportInstances?: Array<'granularity' | 'processingDate' | 'segments'>, limit?: number, _options?: Configuration): Observable<AnalyticsReportInstancesResponse> {
        return this.analyticsReportsInstancesGetToManyRelatedWithHttpInfo(id, filterGranularity, filterProcessingDate, fieldsAnalyticsReportInstances, limit, _options).pipe(map((apiResponse: HttpInfo<AnalyticsReportInstancesResponse>) => apiResponse.data));
    }

}

import { AppAvailabilitiesApiRequestFactory, AppAvailabilitiesApiResponseProcessor} from "../apis/AppAvailabilitiesApi.ts";
export class ObservableAppAvailabilitiesApi {
    private requestFactory: AppAvailabilitiesApiRequestFactory;
    private responseProcessor: AppAvailabilitiesApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: AppAvailabilitiesApiRequestFactory,
        responseProcessor?: AppAvailabilitiesApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new AppAvailabilitiesApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new AppAvailabilitiesApiResponseProcessor();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limit maximum resources per page
     */
    public appAvailabilitiesAvailableTerritoriesGetToManyRelatedWithHttpInfo(id: string, fieldsTerritories?: Array<'currency'>, limit?: number, _options?: Configuration): Observable<HttpInfo<TerritoriesResponse>> {
        const requestContextPromise = this.requestFactory.appAvailabilitiesAvailableTerritoriesGetToManyRelated(id, fieldsTerritories, limit, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appAvailabilitiesAvailableTerritoriesGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limit maximum resources per page
     */
    public appAvailabilitiesAvailableTerritoriesGetToManyRelated(id: string, fieldsTerritories?: Array<'currency'>, limit?: number, _options?: Configuration): Observable<TerritoriesResponse> {
        return this.appAvailabilitiesAvailableTerritoriesGetToManyRelatedWithHttpInfo(id, fieldsTerritories, limit, _options).pipe(map((apiResponse: HttpInfo<TerritoriesResponse>) => apiResponse.data));
    }

    /**
     * @param appAvailabilityCreateRequest AppAvailability representation
     */
    public appAvailabilitiesCreateInstanceWithHttpInfo(appAvailabilityCreateRequest: AppAvailabilityCreateRequest, _options?: Configuration): Observable<HttpInfo<AppAvailabilityResponse>> {
        const requestContextPromise = this.requestFactory.appAvailabilitiesCreateInstance(appAvailabilityCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appAvailabilitiesCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param appAvailabilityCreateRequest AppAvailability representation
     */
    public appAvailabilitiesCreateInstance(appAvailabilityCreateRequest: AppAvailabilityCreateRequest, _options?: Configuration): Observable<AppAvailabilityResponse> {
        return this.appAvailabilitiesCreateInstanceWithHttpInfo(appAvailabilityCreateRequest, _options).pipe(map((apiResponse: HttpInfo<AppAvailabilityResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppAvailabilities the fields to include for returned resources of type appAvailabilities
     * @param include comma-separated list of relationships to include
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limitAvailableTerritories maximum number of related availableTerritories returned (when they are included)
     */
    public appAvailabilitiesGetInstanceWithHttpInfo(id: string, fieldsAppAvailabilities?: Array<'app' | 'availableInNewTerritories' | 'availableTerritories'>, include?: Array<'app' | 'availableTerritories'>, fieldsTerritories?: Array<'currency'>, limitAvailableTerritories?: number, _options?: Configuration): Observable<HttpInfo<AppAvailabilityResponse>> {
        const requestContextPromise = this.requestFactory.appAvailabilitiesGetInstance(id, fieldsAppAvailabilities, include, fieldsTerritories, limitAvailableTerritories, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appAvailabilitiesGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppAvailabilities the fields to include for returned resources of type appAvailabilities
     * @param include comma-separated list of relationships to include
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limitAvailableTerritories maximum number of related availableTerritories returned (when they are included)
     */
    public appAvailabilitiesGetInstance(id: string, fieldsAppAvailabilities?: Array<'app' | 'availableInNewTerritories' | 'availableTerritories'>, include?: Array<'app' | 'availableTerritories'>, fieldsTerritories?: Array<'currency'>, limitAvailableTerritories?: number, _options?: Configuration): Observable<AppAvailabilityResponse> {
        return this.appAvailabilitiesGetInstanceWithHttpInfo(id, fieldsAppAvailabilities, include, fieldsTerritories, limitAvailableTerritories, _options).pipe(map((apiResponse: HttpInfo<AppAvailabilityResponse>) => apiResponse.data));
    }

    /**
     * @param appAvailabilityV2CreateRequest AppAvailability representation
     */
    public appAvailabilitiesV2CreateInstanceWithHttpInfo(appAvailabilityV2CreateRequest: AppAvailabilityV2CreateRequest, _options?: Configuration): Observable<HttpInfo<AppAvailabilityV2Response>> {
        const requestContextPromise = this.requestFactory.appAvailabilitiesV2CreateInstance(appAvailabilityV2CreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appAvailabilitiesV2CreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param appAvailabilityV2CreateRequest AppAvailability representation
     */
    public appAvailabilitiesV2CreateInstance(appAvailabilityV2CreateRequest: AppAvailabilityV2CreateRequest, _options?: Configuration): Observable<AppAvailabilityV2Response> {
        return this.appAvailabilitiesV2CreateInstanceWithHttpInfo(appAvailabilityV2CreateRequest, _options).pipe(map((apiResponse: HttpInfo<AppAvailabilityV2Response>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppAvailabilities the fields to include for returned resources of type appAvailabilities
     * @param include comma-separated list of relationships to include
     * @param fieldsTerritoryAvailabilities the fields to include for returned resources of type territoryAvailabilities
     * @param limitTerritoryAvailabilities maximum number of related territoryAvailabilities returned (when they are included)
     */
    public appAvailabilitiesV2GetInstanceWithHttpInfo(id: string, fieldsAppAvailabilities?: Array<'app' | 'availableInNewTerritories' | 'territoryAvailabilities'>, include?: Array<'territoryAvailabilities'>, fieldsTerritoryAvailabilities?: Array<'available' | 'contentStatuses' | 'preOrderEnabled' | 'preOrderPublishDate' | 'releaseDate' | 'territory'>, limitTerritoryAvailabilities?: number, _options?: Configuration): Observable<HttpInfo<AppAvailabilityV2Response>> {
        const requestContextPromise = this.requestFactory.appAvailabilitiesV2GetInstance(id, fieldsAppAvailabilities, include, fieldsTerritoryAvailabilities, limitTerritoryAvailabilities, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appAvailabilitiesV2GetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppAvailabilities the fields to include for returned resources of type appAvailabilities
     * @param include comma-separated list of relationships to include
     * @param fieldsTerritoryAvailabilities the fields to include for returned resources of type territoryAvailabilities
     * @param limitTerritoryAvailabilities maximum number of related territoryAvailabilities returned (when they are included)
     */
    public appAvailabilitiesV2GetInstance(id: string, fieldsAppAvailabilities?: Array<'app' | 'availableInNewTerritories' | 'territoryAvailabilities'>, include?: Array<'territoryAvailabilities'>, fieldsTerritoryAvailabilities?: Array<'available' | 'contentStatuses' | 'preOrderEnabled' | 'preOrderPublishDate' | 'releaseDate' | 'territory'>, limitTerritoryAvailabilities?: number, _options?: Configuration): Observable<AppAvailabilityV2Response> {
        return this.appAvailabilitiesV2GetInstanceWithHttpInfo(id, fieldsAppAvailabilities, include, fieldsTerritoryAvailabilities, limitTerritoryAvailabilities, _options).pipe(map((apiResponse: HttpInfo<AppAvailabilityV2Response>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsTerritoryAvailabilities the fields to include for returned resources of type territoryAvailabilities
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public appAvailabilitiesV2TerritoryAvailabilitiesGetToManyRelatedWithHttpInfo(id: string, fieldsTerritoryAvailabilities?: Array<'available' | 'contentStatuses' | 'preOrderEnabled' | 'preOrderPublishDate' | 'releaseDate' | 'territory'>, fieldsTerritories?: Array<'currency'>, limit?: number, include?: Array<'territory'>, _options?: Configuration): Observable<HttpInfo<TerritoryAvailabilitiesResponse>> {
        const requestContextPromise = this.requestFactory.appAvailabilitiesV2TerritoryAvailabilitiesGetToManyRelated(id, fieldsTerritoryAvailabilities, fieldsTerritories, limit, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appAvailabilitiesV2TerritoryAvailabilitiesGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsTerritoryAvailabilities the fields to include for returned resources of type territoryAvailabilities
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public appAvailabilitiesV2TerritoryAvailabilitiesGetToManyRelated(id: string, fieldsTerritoryAvailabilities?: Array<'available' | 'contentStatuses' | 'preOrderEnabled' | 'preOrderPublishDate' | 'releaseDate' | 'territory'>, fieldsTerritories?: Array<'currency'>, limit?: number, include?: Array<'territory'>, _options?: Configuration): Observable<TerritoryAvailabilitiesResponse> {
        return this.appAvailabilitiesV2TerritoryAvailabilitiesGetToManyRelatedWithHttpInfo(id, fieldsTerritoryAvailabilities, fieldsTerritories, limit, include, _options).pipe(map((apiResponse: HttpInfo<TerritoryAvailabilitiesResponse>) => apiResponse.data));
    }

}

import { AppCategoriesApiRequestFactory, AppCategoriesApiResponseProcessor} from "../apis/AppCategoriesApi.ts";
export class ObservableAppCategoriesApi {
    private requestFactory: AppCategoriesApiRequestFactory;
    private responseProcessor: AppCategoriesApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: AppCategoriesApiRequestFactory,
        responseProcessor?: AppCategoriesApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new AppCategoriesApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new AppCategoriesApiResponseProcessor();
    }

    /**
     * @param filterPlatforms filter by attribute \&#39;platforms\&#39;
     * @param existsParent filter by existence or non-existence of related \&#39;parent\&#39;
     * @param fieldsAppCategories the fields to include for returned resources of type appCategories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param limitSubcategories maximum number of related subcategories returned (when they are included)
     */
    public appCategoriesGetCollectionWithHttpInfo(filterPlatforms?: Array<'IOS' | 'MAC_OS' | 'TV_OS' | 'VISION_OS'>, existsParent?: boolean, fieldsAppCategories?: Array<'parent' | 'platforms' | 'subcategories'>, limit?: number, include?: Array<'parent' | 'subcategories'>, limitSubcategories?: number, _options?: Configuration): Observable<HttpInfo<AppCategoriesResponse>> {
        const requestContextPromise = this.requestFactory.appCategoriesGetCollection(filterPlatforms, existsParent, fieldsAppCategories, limit, include, limitSubcategories, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appCategoriesGetCollectionWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param filterPlatforms filter by attribute \&#39;platforms\&#39;
     * @param existsParent filter by existence or non-existence of related \&#39;parent\&#39;
     * @param fieldsAppCategories the fields to include for returned resources of type appCategories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param limitSubcategories maximum number of related subcategories returned (when they are included)
     */
    public appCategoriesGetCollection(filterPlatforms?: Array<'IOS' | 'MAC_OS' | 'TV_OS' | 'VISION_OS'>, existsParent?: boolean, fieldsAppCategories?: Array<'parent' | 'platforms' | 'subcategories'>, limit?: number, include?: Array<'parent' | 'subcategories'>, limitSubcategories?: number, _options?: Configuration): Observable<AppCategoriesResponse> {
        return this.appCategoriesGetCollectionWithHttpInfo(filterPlatforms, existsParent, fieldsAppCategories, limit, include, limitSubcategories, _options).pipe(map((apiResponse: HttpInfo<AppCategoriesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppCategories the fields to include for returned resources of type appCategories
     * @param include comma-separated list of relationships to include
     * @param limitSubcategories maximum number of related subcategories returned (when they are included)
     */
    public appCategoriesGetInstanceWithHttpInfo(id: string, fieldsAppCategories?: Array<'parent' | 'platforms' | 'subcategories'>, include?: Array<'parent' | 'subcategories'>, limitSubcategories?: number, _options?: Configuration): Observable<HttpInfo<AppCategoryResponse>> {
        const requestContextPromise = this.requestFactory.appCategoriesGetInstance(id, fieldsAppCategories, include, limitSubcategories, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appCategoriesGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppCategories the fields to include for returned resources of type appCategories
     * @param include comma-separated list of relationships to include
     * @param limitSubcategories maximum number of related subcategories returned (when they are included)
     */
    public appCategoriesGetInstance(id: string, fieldsAppCategories?: Array<'parent' | 'platforms' | 'subcategories'>, include?: Array<'parent' | 'subcategories'>, limitSubcategories?: number, _options?: Configuration): Observable<AppCategoryResponse> {
        return this.appCategoriesGetInstanceWithHttpInfo(id, fieldsAppCategories, include, limitSubcategories, _options).pipe(map((apiResponse: HttpInfo<AppCategoryResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppCategories the fields to include for returned resources of type appCategories
     */
    public appCategoriesParentGetToOneRelatedWithHttpInfo(id: string, fieldsAppCategories?: Array<'parent' | 'platforms' | 'subcategories'>, _options?: Configuration): Observable<HttpInfo<AppCategoryWithoutIncludesResponse>> {
        const requestContextPromise = this.requestFactory.appCategoriesParentGetToOneRelated(id, fieldsAppCategories, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appCategoriesParentGetToOneRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppCategories the fields to include for returned resources of type appCategories
     */
    public appCategoriesParentGetToOneRelated(id: string, fieldsAppCategories?: Array<'parent' | 'platforms' | 'subcategories'>, _options?: Configuration): Observable<AppCategoryWithoutIncludesResponse> {
        return this.appCategoriesParentGetToOneRelatedWithHttpInfo(id, fieldsAppCategories, _options).pipe(map((apiResponse: HttpInfo<AppCategoryWithoutIncludesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppCategories the fields to include for returned resources of type appCategories
     * @param limit maximum resources per page
     */
    public appCategoriesSubcategoriesGetToManyRelatedWithHttpInfo(id: string, fieldsAppCategories?: Array<'parent' | 'platforms' | 'subcategories'>, limit?: number, _options?: Configuration): Observable<HttpInfo<AppCategoriesWithoutIncludesResponse>> {
        const requestContextPromise = this.requestFactory.appCategoriesSubcategoriesGetToManyRelated(id, fieldsAppCategories, limit, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appCategoriesSubcategoriesGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppCategories the fields to include for returned resources of type appCategories
     * @param limit maximum resources per page
     */
    public appCategoriesSubcategoriesGetToManyRelated(id: string, fieldsAppCategories?: Array<'parent' | 'platforms' | 'subcategories'>, limit?: number, _options?: Configuration): Observable<AppCategoriesWithoutIncludesResponse> {
        return this.appCategoriesSubcategoriesGetToManyRelatedWithHttpInfo(id, fieldsAppCategories, limit, _options).pipe(map((apiResponse: HttpInfo<AppCategoriesWithoutIncludesResponse>) => apiResponse.data));
    }

}

import { AppClipAdvancedExperienceImagesApiRequestFactory, AppClipAdvancedExperienceImagesApiResponseProcessor} from "../apis/AppClipAdvancedExperienceImagesApi.ts";
export class ObservableAppClipAdvancedExperienceImagesApi {
    private requestFactory: AppClipAdvancedExperienceImagesApiRequestFactory;
    private responseProcessor: AppClipAdvancedExperienceImagesApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: AppClipAdvancedExperienceImagesApiRequestFactory,
        responseProcessor?: AppClipAdvancedExperienceImagesApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new AppClipAdvancedExperienceImagesApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new AppClipAdvancedExperienceImagesApiResponseProcessor();
    }

    /**
     * @param appClipAdvancedExperienceImageCreateRequest AppClipAdvancedExperienceImage representation
     */
    public appClipAdvancedExperienceImagesCreateInstanceWithHttpInfo(appClipAdvancedExperienceImageCreateRequest: AppClipAdvancedExperienceImageCreateRequest, _options?: Configuration): Observable<HttpInfo<AppClipAdvancedExperienceImageResponse>> {
        const requestContextPromise = this.requestFactory.appClipAdvancedExperienceImagesCreateInstance(appClipAdvancedExperienceImageCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appClipAdvancedExperienceImagesCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param appClipAdvancedExperienceImageCreateRequest AppClipAdvancedExperienceImage representation
     */
    public appClipAdvancedExperienceImagesCreateInstance(appClipAdvancedExperienceImageCreateRequest: AppClipAdvancedExperienceImageCreateRequest, _options?: Configuration): Observable<AppClipAdvancedExperienceImageResponse> {
        return this.appClipAdvancedExperienceImagesCreateInstanceWithHttpInfo(appClipAdvancedExperienceImageCreateRequest, _options).pipe(map((apiResponse: HttpInfo<AppClipAdvancedExperienceImageResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppClipAdvancedExperienceImages the fields to include for returned resources of type appClipAdvancedExperienceImages
     */
    public appClipAdvancedExperienceImagesGetInstanceWithHttpInfo(id: string, fieldsAppClipAdvancedExperienceImages?: Array<'assetDeliveryState' | 'fileName' | 'fileSize' | 'imageAsset' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, _options?: Configuration): Observable<HttpInfo<AppClipAdvancedExperienceImageResponse>> {
        const requestContextPromise = this.requestFactory.appClipAdvancedExperienceImagesGetInstance(id, fieldsAppClipAdvancedExperienceImages, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appClipAdvancedExperienceImagesGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppClipAdvancedExperienceImages the fields to include for returned resources of type appClipAdvancedExperienceImages
     */
    public appClipAdvancedExperienceImagesGetInstance(id: string, fieldsAppClipAdvancedExperienceImages?: Array<'assetDeliveryState' | 'fileName' | 'fileSize' | 'imageAsset' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, _options?: Configuration): Observable<AppClipAdvancedExperienceImageResponse> {
        return this.appClipAdvancedExperienceImagesGetInstanceWithHttpInfo(id, fieldsAppClipAdvancedExperienceImages, _options).pipe(map((apiResponse: HttpInfo<AppClipAdvancedExperienceImageResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param appClipAdvancedExperienceImageUpdateRequest AppClipAdvancedExperienceImage representation
     */
    public appClipAdvancedExperienceImagesUpdateInstanceWithHttpInfo(id: string, appClipAdvancedExperienceImageUpdateRequest: AppClipAdvancedExperienceImageUpdateRequest, _options?: Configuration): Observable<HttpInfo<AppClipAdvancedExperienceImageResponse>> {
        const requestContextPromise = this.requestFactory.appClipAdvancedExperienceImagesUpdateInstance(id, appClipAdvancedExperienceImageUpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appClipAdvancedExperienceImagesUpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param appClipAdvancedExperienceImageUpdateRequest AppClipAdvancedExperienceImage representation
     */
    public appClipAdvancedExperienceImagesUpdateInstance(id: string, appClipAdvancedExperienceImageUpdateRequest: AppClipAdvancedExperienceImageUpdateRequest, _options?: Configuration): Observable<AppClipAdvancedExperienceImageResponse> {
        return this.appClipAdvancedExperienceImagesUpdateInstanceWithHttpInfo(id, appClipAdvancedExperienceImageUpdateRequest, _options).pipe(map((apiResponse: HttpInfo<AppClipAdvancedExperienceImageResponse>) => apiResponse.data));
    }

}

import { AppClipAdvancedExperiencesApiRequestFactory, AppClipAdvancedExperiencesApiResponseProcessor} from "../apis/AppClipAdvancedExperiencesApi.ts";
export class ObservableAppClipAdvancedExperiencesApi {
    private requestFactory: AppClipAdvancedExperiencesApiRequestFactory;
    private responseProcessor: AppClipAdvancedExperiencesApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: AppClipAdvancedExperiencesApiRequestFactory,
        responseProcessor?: AppClipAdvancedExperiencesApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new AppClipAdvancedExperiencesApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new AppClipAdvancedExperiencesApiResponseProcessor();
    }

    /**
     * @param appClipAdvancedExperienceCreateRequest AppClipAdvancedExperience representation
     */
    public appClipAdvancedExperiencesCreateInstanceWithHttpInfo(appClipAdvancedExperienceCreateRequest: AppClipAdvancedExperienceCreateRequest, _options?: Configuration): Observable<HttpInfo<AppClipAdvancedExperienceResponse>> {
        const requestContextPromise = this.requestFactory.appClipAdvancedExperiencesCreateInstance(appClipAdvancedExperienceCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appClipAdvancedExperiencesCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param appClipAdvancedExperienceCreateRequest AppClipAdvancedExperience representation
     */
    public appClipAdvancedExperiencesCreateInstance(appClipAdvancedExperienceCreateRequest: AppClipAdvancedExperienceCreateRequest, _options?: Configuration): Observable<AppClipAdvancedExperienceResponse> {
        return this.appClipAdvancedExperiencesCreateInstanceWithHttpInfo(appClipAdvancedExperienceCreateRequest, _options).pipe(map((apiResponse: HttpInfo<AppClipAdvancedExperienceResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppClipAdvancedExperiences the fields to include for returned resources of type appClipAdvancedExperiences
     * @param include comma-separated list of relationships to include
     * @param limitLocalizations maximum number of related localizations returned (when they are included)
     */
    public appClipAdvancedExperiencesGetInstanceWithHttpInfo(id: string, fieldsAppClipAdvancedExperiences?: Array<'action' | 'appClip' | 'businessCategory' | 'defaultLanguage' | 'headerImage' | 'isPoweredBy' | 'link' | 'localizations' | 'place' | 'placeStatus' | 'removed' | 'status' | 'version'>, include?: Array<'appClip' | 'headerImage' | 'localizations'>, limitLocalizations?: number, _options?: Configuration): Observable<HttpInfo<AppClipAdvancedExperienceResponse>> {
        const requestContextPromise = this.requestFactory.appClipAdvancedExperiencesGetInstance(id, fieldsAppClipAdvancedExperiences, include, limitLocalizations, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appClipAdvancedExperiencesGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppClipAdvancedExperiences the fields to include for returned resources of type appClipAdvancedExperiences
     * @param include comma-separated list of relationships to include
     * @param limitLocalizations maximum number of related localizations returned (when they are included)
     */
    public appClipAdvancedExperiencesGetInstance(id: string, fieldsAppClipAdvancedExperiences?: Array<'action' | 'appClip' | 'businessCategory' | 'defaultLanguage' | 'headerImage' | 'isPoweredBy' | 'link' | 'localizations' | 'place' | 'placeStatus' | 'removed' | 'status' | 'version'>, include?: Array<'appClip' | 'headerImage' | 'localizations'>, limitLocalizations?: number, _options?: Configuration): Observable<AppClipAdvancedExperienceResponse> {
        return this.appClipAdvancedExperiencesGetInstanceWithHttpInfo(id, fieldsAppClipAdvancedExperiences, include, limitLocalizations, _options).pipe(map((apiResponse: HttpInfo<AppClipAdvancedExperienceResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param appClipAdvancedExperienceUpdateRequest AppClipAdvancedExperience representation
     */
    public appClipAdvancedExperiencesUpdateInstanceWithHttpInfo(id: string, appClipAdvancedExperienceUpdateRequest: AppClipAdvancedExperienceUpdateRequest, _options?: Configuration): Observable<HttpInfo<AppClipAdvancedExperienceResponse>> {
        const requestContextPromise = this.requestFactory.appClipAdvancedExperiencesUpdateInstance(id, appClipAdvancedExperienceUpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appClipAdvancedExperiencesUpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param appClipAdvancedExperienceUpdateRequest AppClipAdvancedExperience representation
     */
    public appClipAdvancedExperiencesUpdateInstance(id: string, appClipAdvancedExperienceUpdateRequest: AppClipAdvancedExperienceUpdateRequest, _options?: Configuration): Observable<AppClipAdvancedExperienceResponse> {
        return this.appClipAdvancedExperiencesUpdateInstanceWithHttpInfo(id, appClipAdvancedExperienceUpdateRequest, _options).pipe(map((apiResponse: HttpInfo<AppClipAdvancedExperienceResponse>) => apiResponse.data));
    }

}

import { AppClipAppStoreReviewDetailsApiRequestFactory, AppClipAppStoreReviewDetailsApiResponseProcessor} from "../apis/AppClipAppStoreReviewDetailsApi.ts";
export class ObservableAppClipAppStoreReviewDetailsApi {
    private requestFactory: AppClipAppStoreReviewDetailsApiRequestFactory;
    private responseProcessor: AppClipAppStoreReviewDetailsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: AppClipAppStoreReviewDetailsApiRequestFactory,
        responseProcessor?: AppClipAppStoreReviewDetailsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new AppClipAppStoreReviewDetailsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new AppClipAppStoreReviewDetailsApiResponseProcessor();
    }

    /**
     * @param appClipAppStoreReviewDetailCreateRequest AppClipAppStoreReviewDetail representation
     */
    public appClipAppStoreReviewDetailsCreateInstanceWithHttpInfo(appClipAppStoreReviewDetailCreateRequest: AppClipAppStoreReviewDetailCreateRequest, _options?: Configuration): Observable<HttpInfo<AppClipAppStoreReviewDetailResponse>> {
        const requestContextPromise = this.requestFactory.appClipAppStoreReviewDetailsCreateInstance(appClipAppStoreReviewDetailCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appClipAppStoreReviewDetailsCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param appClipAppStoreReviewDetailCreateRequest AppClipAppStoreReviewDetail representation
     */
    public appClipAppStoreReviewDetailsCreateInstance(appClipAppStoreReviewDetailCreateRequest: AppClipAppStoreReviewDetailCreateRequest, _options?: Configuration): Observable<AppClipAppStoreReviewDetailResponse> {
        return this.appClipAppStoreReviewDetailsCreateInstanceWithHttpInfo(appClipAppStoreReviewDetailCreateRequest, _options).pipe(map((apiResponse: HttpInfo<AppClipAppStoreReviewDetailResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppClipAppStoreReviewDetails the fields to include for returned resources of type appClipAppStoreReviewDetails
     * @param include comma-separated list of relationships to include
     */
    public appClipAppStoreReviewDetailsGetInstanceWithHttpInfo(id: string, fieldsAppClipAppStoreReviewDetails?: Array<'appClipDefaultExperience' | 'invocationUrls'>, include?: Array<'appClipDefaultExperience'>, _options?: Configuration): Observable<HttpInfo<AppClipAppStoreReviewDetailResponse>> {
        const requestContextPromise = this.requestFactory.appClipAppStoreReviewDetailsGetInstance(id, fieldsAppClipAppStoreReviewDetails, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appClipAppStoreReviewDetailsGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppClipAppStoreReviewDetails the fields to include for returned resources of type appClipAppStoreReviewDetails
     * @param include comma-separated list of relationships to include
     */
    public appClipAppStoreReviewDetailsGetInstance(id: string, fieldsAppClipAppStoreReviewDetails?: Array<'appClipDefaultExperience' | 'invocationUrls'>, include?: Array<'appClipDefaultExperience'>, _options?: Configuration): Observable<AppClipAppStoreReviewDetailResponse> {
        return this.appClipAppStoreReviewDetailsGetInstanceWithHttpInfo(id, fieldsAppClipAppStoreReviewDetails, include, _options).pipe(map((apiResponse: HttpInfo<AppClipAppStoreReviewDetailResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param appClipAppStoreReviewDetailUpdateRequest AppClipAppStoreReviewDetail representation
     */
    public appClipAppStoreReviewDetailsUpdateInstanceWithHttpInfo(id: string, appClipAppStoreReviewDetailUpdateRequest: AppClipAppStoreReviewDetailUpdateRequest, _options?: Configuration): Observable<HttpInfo<AppClipAppStoreReviewDetailResponse>> {
        const requestContextPromise = this.requestFactory.appClipAppStoreReviewDetailsUpdateInstance(id, appClipAppStoreReviewDetailUpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appClipAppStoreReviewDetailsUpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param appClipAppStoreReviewDetailUpdateRequest AppClipAppStoreReviewDetail representation
     */
    public appClipAppStoreReviewDetailsUpdateInstance(id: string, appClipAppStoreReviewDetailUpdateRequest: AppClipAppStoreReviewDetailUpdateRequest, _options?: Configuration): Observable<AppClipAppStoreReviewDetailResponse> {
        return this.appClipAppStoreReviewDetailsUpdateInstanceWithHttpInfo(id, appClipAppStoreReviewDetailUpdateRequest, _options).pipe(map((apiResponse: HttpInfo<AppClipAppStoreReviewDetailResponse>) => apiResponse.data));
    }

}

import { AppClipDefaultExperienceLocalizationsApiRequestFactory, AppClipDefaultExperienceLocalizationsApiResponseProcessor} from "../apis/AppClipDefaultExperienceLocalizationsApi.ts";
export class ObservableAppClipDefaultExperienceLocalizationsApi {
    private requestFactory: AppClipDefaultExperienceLocalizationsApiRequestFactory;
    private responseProcessor: AppClipDefaultExperienceLocalizationsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: AppClipDefaultExperienceLocalizationsApiRequestFactory,
        responseProcessor?: AppClipDefaultExperienceLocalizationsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new AppClipDefaultExperienceLocalizationsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new AppClipDefaultExperienceLocalizationsApiResponseProcessor();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppClipHeaderImages the fields to include for returned resources of type appClipHeaderImages
     * @param fieldsAppClipDefaultExperienceLocalizations the fields to include for returned resources of type appClipDefaultExperienceLocalizations
     * @param include comma-separated list of relationships to include
     */
    public appClipDefaultExperienceLocalizationsAppClipHeaderImageGetToOneRelatedWithHttpInfo(id: string, fieldsAppClipHeaderImages?: Array<'appClipDefaultExperienceLocalization' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'imageAsset' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, fieldsAppClipDefaultExperienceLocalizations?: Array<'appClipDefaultExperience' | 'appClipHeaderImage' | 'locale' | 'subtitle'>, include?: Array<'appClipDefaultExperienceLocalization'>, _options?: Configuration): Observable<HttpInfo<AppClipHeaderImageResponse>> {
        const requestContextPromise = this.requestFactory.appClipDefaultExperienceLocalizationsAppClipHeaderImageGetToOneRelated(id, fieldsAppClipHeaderImages, fieldsAppClipDefaultExperienceLocalizations, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appClipDefaultExperienceLocalizationsAppClipHeaderImageGetToOneRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppClipHeaderImages the fields to include for returned resources of type appClipHeaderImages
     * @param fieldsAppClipDefaultExperienceLocalizations the fields to include for returned resources of type appClipDefaultExperienceLocalizations
     * @param include comma-separated list of relationships to include
     */
    public appClipDefaultExperienceLocalizationsAppClipHeaderImageGetToOneRelated(id: string, fieldsAppClipHeaderImages?: Array<'appClipDefaultExperienceLocalization' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'imageAsset' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, fieldsAppClipDefaultExperienceLocalizations?: Array<'appClipDefaultExperience' | 'appClipHeaderImage' | 'locale' | 'subtitle'>, include?: Array<'appClipDefaultExperienceLocalization'>, _options?: Configuration): Observable<AppClipHeaderImageResponse> {
        return this.appClipDefaultExperienceLocalizationsAppClipHeaderImageGetToOneRelatedWithHttpInfo(id, fieldsAppClipHeaderImages, fieldsAppClipDefaultExperienceLocalizations, include, _options).pipe(map((apiResponse: HttpInfo<AppClipHeaderImageResponse>) => apiResponse.data));
    }

    /**
     * @param appClipDefaultExperienceLocalizationCreateRequest AppClipDefaultExperienceLocalization representation
     */
    public appClipDefaultExperienceLocalizationsCreateInstanceWithHttpInfo(appClipDefaultExperienceLocalizationCreateRequest: AppClipDefaultExperienceLocalizationCreateRequest, _options?: Configuration): Observable<HttpInfo<AppClipDefaultExperienceLocalizationResponse>> {
        const requestContextPromise = this.requestFactory.appClipDefaultExperienceLocalizationsCreateInstance(appClipDefaultExperienceLocalizationCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appClipDefaultExperienceLocalizationsCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param appClipDefaultExperienceLocalizationCreateRequest AppClipDefaultExperienceLocalization representation
     */
    public appClipDefaultExperienceLocalizationsCreateInstance(appClipDefaultExperienceLocalizationCreateRequest: AppClipDefaultExperienceLocalizationCreateRequest, _options?: Configuration): Observable<AppClipDefaultExperienceLocalizationResponse> {
        return this.appClipDefaultExperienceLocalizationsCreateInstanceWithHttpInfo(appClipDefaultExperienceLocalizationCreateRequest, _options).pipe(map((apiResponse: HttpInfo<AppClipDefaultExperienceLocalizationResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public appClipDefaultExperienceLocalizationsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.appClipDefaultExperienceLocalizationsDeleteInstance(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appClipDefaultExperienceLocalizationsDeleteInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public appClipDefaultExperienceLocalizationsDeleteInstance(id: string, _options?: Configuration): Observable<void> {
        return this.appClipDefaultExperienceLocalizationsDeleteInstanceWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppClipDefaultExperienceLocalizations the fields to include for returned resources of type appClipDefaultExperienceLocalizations
     * @param include comma-separated list of relationships to include
     * @param fieldsAppClipHeaderImages the fields to include for returned resources of type appClipHeaderImages
     */
    public appClipDefaultExperienceLocalizationsGetInstanceWithHttpInfo(id: string, fieldsAppClipDefaultExperienceLocalizations?: Array<'appClipDefaultExperience' | 'appClipHeaderImage' | 'locale' | 'subtitle'>, include?: Array<'appClipDefaultExperience' | 'appClipHeaderImage'>, fieldsAppClipHeaderImages?: Array<'appClipDefaultExperienceLocalization' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'imageAsset' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, _options?: Configuration): Observable<HttpInfo<AppClipDefaultExperienceLocalizationResponse>> {
        const requestContextPromise = this.requestFactory.appClipDefaultExperienceLocalizationsGetInstance(id, fieldsAppClipDefaultExperienceLocalizations, include, fieldsAppClipHeaderImages, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appClipDefaultExperienceLocalizationsGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppClipDefaultExperienceLocalizations the fields to include for returned resources of type appClipDefaultExperienceLocalizations
     * @param include comma-separated list of relationships to include
     * @param fieldsAppClipHeaderImages the fields to include for returned resources of type appClipHeaderImages
     */
    public appClipDefaultExperienceLocalizationsGetInstance(id: string, fieldsAppClipDefaultExperienceLocalizations?: Array<'appClipDefaultExperience' | 'appClipHeaderImage' | 'locale' | 'subtitle'>, include?: Array<'appClipDefaultExperience' | 'appClipHeaderImage'>, fieldsAppClipHeaderImages?: Array<'appClipDefaultExperienceLocalization' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'imageAsset' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, _options?: Configuration): Observable<AppClipDefaultExperienceLocalizationResponse> {
        return this.appClipDefaultExperienceLocalizationsGetInstanceWithHttpInfo(id, fieldsAppClipDefaultExperienceLocalizations, include, fieldsAppClipHeaderImages, _options).pipe(map((apiResponse: HttpInfo<AppClipDefaultExperienceLocalizationResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param appClipDefaultExperienceLocalizationUpdateRequest AppClipDefaultExperienceLocalization representation
     */
    public appClipDefaultExperienceLocalizationsUpdateInstanceWithHttpInfo(id: string, appClipDefaultExperienceLocalizationUpdateRequest: AppClipDefaultExperienceLocalizationUpdateRequest, _options?: Configuration): Observable<HttpInfo<AppClipDefaultExperienceLocalizationResponse>> {
        const requestContextPromise = this.requestFactory.appClipDefaultExperienceLocalizationsUpdateInstance(id, appClipDefaultExperienceLocalizationUpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appClipDefaultExperienceLocalizationsUpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param appClipDefaultExperienceLocalizationUpdateRequest AppClipDefaultExperienceLocalization representation
     */
    public appClipDefaultExperienceLocalizationsUpdateInstance(id: string, appClipDefaultExperienceLocalizationUpdateRequest: AppClipDefaultExperienceLocalizationUpdateRequest, _options?: Configuration): Observable<AppClipDefaultExperienceLocalizationResponse> {
        return this.appClipDefaultExperienceLocalizationsUpdateInstanceWithHttpInfo(id, appClipDefaultExperienceLocalizationUpdateRequest, _options).pipe(map((apiResponse: HttpInfo<AppClipDefaultExperienceLocalizationResponse>) => apiResponse.data));
    }

}

import { AppClipDefaultExperiencesApiRequestFactory, AppClipDefaultExperiencesApiResponseProcessor} from "../apis/AppClipDefaultExperiencesApi.ts";
export class ObservableAppClipDefaultExperiencesApi {
    private requestFactory: AppClipDefaultExperiencesApiRequestFactory;
    private responseProcessor: AppClipDefaultExperiencesApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: AppClipDefaultExperiencesApiRequestFactory,
        responseProcessor?: AppClipDefaultExperiencesApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new AppClipDefaultExperiencesApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new AppClipDefaultExperiencesApiResponseProcessor();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppClipAppStoreReviewDetails the fields to include for returned resources of type appClipAppStoreReviewDetails
     * @param fieldsAppClipDefaultExperiences the fields to include for returned resources of type appClipDefaultExperiences
     * @param include comma-separated list of relationships to include
     */
    public appClipDefaultExperiencesAppClipAppStoreReviewDetailGetToOneRelatedWithHttpInfo(id: string, fieldsAppClipAppStoreReviewDetails?: Array<'appClipDefaultExperience' | 'invocationUrls'>, fieldsAppClipDefaultExperiences?: Array<'action' | 'appClip' | 'appClipAppStoreReviewDetail' | 'appClipDefaultExperienceLocalizations' | 'appClipDefaultExperienceTemplate' | 'releaseWithAppStoreVersion'>, include?: Array<'appClipDefaultExperience'>, _options?: Configuration): Observable<HttpInfo<AppClipAppStoreReviewDetailResponse>> {
        const requestContextPromise = this.requestFactory.appClipDefaultExperiencesAppClipAppStoreReviewDetailGetToOneRelated(id, fieldsAppClipAppStoreReviewDetails, fieldsAppClipDefaultExperiences, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appClipDefaultExperiencesAppClipAppStoreReviewDetailGetToOneRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppClipAppStoreReviewDetails the fields to include for returned resources of type appClipAppStoreReviewDetails
     * @param fieldsAppClipDefaultExperiences the fields to include for returned resources of type appClipDefaultExperiences
     * @param include comma-separated list of relationships to include
     */
    public appClipDefaultExperiencesAppClipAppStoreReviewDetailGetToOneRelated(id: string, fieldsAppClipAppStoreReviewDetails?: Array<'appClipDefaultExperience' | 'invocationUrls'>, fieldsAppClipDefaultExperiences?: Array<'action' | 'appClip' | 'appClipAppStoreReviewDetail' | 'appClipDefaultExperienceLocalizations' | 'appClipDefaultExperienceTemplate' | 'releaseWithAppStoreVersion'>, include?: Array<'appClipDefaultExperience'>, _options?: Configuration): Observable<AppClipAppStoreReviewDetailResponse> {
        return this.appClipDefaultExperiencesAppClipAppStoreReviewDetailGetToOneRelatedWithHttpInfo(id, fieldsAppClipAppStoreReviewDetails, fieldsAppClipDefaultExperiences, include, _options).pipe(map((apiResponse: HttpInfo<AppClipAppStoreReviewDetailResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param filterLocale filter by attribute \&#39;locale\&#39;
     * @param fieldsAppClipDefaultExperiences the fields to include for returned resources of type appClipDefaultExperiences
     * @param fieldsAppClipDefaultExperienceLocalizations the fields to include for returned resources of type appClipDefaultExperienceLocalizations
     * @param fieldsAppClipHeaderImages the fields to include for returned resources of type appClipHeaderImages
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public appClipDefaultExperiencesAppClipDefaultExperienceLocalizationsGetToManyRelatedWithHttpInfo(id: string, filterLocale?: Array<string>, fieldsAppClipDefaultExperiences?: Array<'action' | 'appClip' | 'appClipAppStoreReviewDetail' | 'appClipDefaultExperienceLocalizations' | 'appClipDefaultExperienceTemplate' | 'releaseWithAppStoreVersion'>, fieldsAppClipDefaultExperienceLocalizations?: Array<'appClipDefaultExperience' | 'appClipHeaderImage' | 'locale' | 'subtitle'>, fieldsAppClipHeaderImages?: Array<'appClipDefaultExperienceLocalization' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'imageAsset' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, limit?: number, include?: Array<'appClipDefaultExperience' | 'appClipHeaderImage'>, _options?: Configuration): Observable<HttpInfo<AppClipDefaultExperienceLocalizationsResponse>> {
        const requestContextPromise = this.requestFactory.appClipDefaultExperiencesAppClipDefaultExperienceLocalizationsGetToManyRelated(id, filterLocale, fieldsAppClipDefaultExperiences, fieldsAppClipDefaultExperienceLocalizations, fieldsAppClipHeaderImages, limit, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appClipDefaultExperiencesAppClipDefaultExperienceLocalizationsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param filterLocale filter by attribute \&#39;locale\&#39;
     * @param fieldsAppClipDefaultExperiences the fields to include for returned resources of type appClipDefaultExperiences
     * @param fieldsAppClipDefaultExperienceLocalizations the fields to include for returned resources of type appClipDefaultExperienceLocalizations
     * @param fieldsAppClipHeaderImages the fields to include for returned resources of type appClipHeaderImages
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public appClipDefaultExperiencesAppClipDefaultExperienceLocalizationsGetToManyRelated(id: string, filterLocale?: Array<string>, fieldsAppClipDefaultExperiences?: Array<'action' | 'appClip' | 'appClipAppStoreReviewDetail' | 'appClipDefaultExperienceLocalizations' | 'appClipDefaultExperienceTemplate' | 'releaseWithAppStoreVersion'>, fieldsAppClipDefaultExperienceLocalizations?: Array<'appClipDefaultExperience' | 'appClipHeaderImage' | 'locale' | 'subtitle'>, fieldsAppClipHeaderImages?: Array<'appClipDefaultExperienceLocalization' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'imageAsset' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, limit?: number, include?: Array<'appClipDefaultExperience' | 'appClipHeaderImage'>, _options?: Configuration): Observable<AppClipDefaultExperienceLocalizationsResponse> {
        return this.appClipDefaultExperiencesAppClipDefaultExperienceLocalizationsGetToManyRelatedWithHttpInfo(id, filterLocale, fieldsAppClipDefaultExperiences, fieldsAppClipDefaultExperienceLocalizations, fieldsAppClipHeaderImages, limit, include, _options).pipe(map((apiResponse: HttpInfo<AppClipDefaultExperienceLocalizationsResponse>) => apiResponse.data));
    }

    /**
     * @param appClipDefaultExperienceCreateRequest AppClipDefaultExperience representation
     */
    public appClipDefaultExperiencesCreateInstanceWithHttpInfo(appClipDefaultExperienceCreateRequest: AppClipDefaultExperienceCreateRequest, _options?: Configuration): Observable<HttpInfo<AppClipDefaultExperienceResponse>> {
        const requestContextPromise = this.requestFactory.appClipDefaultExperiencesCreateInstance(appClipDefaultExperienceCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appClipDefaultExperiencesCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param appClipDefaultExperienceCreateRequest AppClipDefaultExperience representation
     */
    public appClipDefaultExperiencesCreateInstance(appClipDefaultExperienceCreateRequest: AppClipDefaultExperienceCreateRequest, _options?: Configuration): Observable<AppClipDefaultExperienceResponse> {
        return this.appClipDefaultExperiencesCreateInstanceWithHttpInfo(appClipDefaultExperienceCreateRequest, _options).pipe(map((apiResponse: HttpInfo<AppClipDefaultExperienceResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public appClipDefaultExperiencesDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.appClipDefaultExperiencesDeleteInstance(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appClipDefaultExperiencesDeleteInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public appClipDefaultExperiencesDeleteInstance(id: string, _options?: Configuration): Observable<void> {
        return this.appClipDefaultExperiencesDeleteInstanceWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppClipDefaultExperiences the fields to include for returned resources of type appClipDefaultExperiences
     * @param include comma-separated list of relationships to include
     * @param fieldsAppClipAppStoreReviewDetails the fields to include for returned resources of type appClipAppStoreReviewDetails
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsAppClipDefaultExperienceLocalizations the fields to include for returned resources of type appClipDefaultExperienceLocalizations
     * @param limitAppClipDefaultExperienceLocalizations maximum number of related appClipDefaultExperienceLocalizations returned (when they are included)
     */
    public appClipDefaultExperiencesGetInstanceWithHttpInfo(id: string, fieldsAppClipDefaultExperiences?: Array<'action' | 'appClip' | 'appClipAppStoreReviewDetail' | 'appClipDefaultExperienceLocalizations' | 'appClipDefaultExperienceTemplate' | 'releaseWithAppStoreVersion'>, include?: Array<'appClip' | 'appClipAppStoreReviewDetail' | 'appClipDefaultExperienceLocalizations' | 'releaseWithAppStoreVersion'>, fieldsAppClipAppStoreReviewDetails?: Array<'appClipDefaultExperience' | 'invocationUrls'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsAppClipDefaultExperienceLocalizations?: Array<'appClipDefaultExperience' | 'appClipHeaderImage' | 'locale' | 'subtitle'>, limitAppClipDefaultExperienceLocalizations?: number, _options?: Configuration): Observable<HttpInfo<AppClipDefaultExperienceResponse>> {
        const requestContextPromise = this.requestFactory.appClipDefaultExperiencesGetInstance(id, fieldsAppClipDefaultExperiences, include, fieldsAppClipAppStoreReviewDetails, fieldsAppStoreVersions, fieldsAppClipDefaultExperienceLocalizations, limitAppClipDefaultExperienceLocalizations, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appClipDefaultExperiencesGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppClipDefaultExperiences the fields to include for returned resources of type appClipDefaultExperiences
     * @param include comma-separated list of relationships to include
     * @param fieldsAppClipAppStoreReviewDetails the fields to include for returned resources of type appClipAppStoreReviewDetails
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsAppClipDefaultExperienceLocalizations the fields to include for returned resources of type appClipDefaultExperienceLocalizations
     * @param limitAppClipDefaultExperienceLocalizations maximum number of related appClipDefaultExperienceLocalizations returned (when they are included)
     */
    public appClipDefaultExperiencesGetInstance(id: string, fieldsAppClipDefaultExperiences?: Array<'action' | 'appClip' | 'appClipAppStoreReviewDetail' | 'appClipDefaultExperienceLocalizations' | 'appClipDefaultExperienceTemplate' | 'releaseWithAppStoreVersion'>, include?: Array<'appClip' | 'appClipAppStoreReviewDetail' | 'appClipDefaultExperienceLocalizations' | 'releaseWithAppStoreVersion'>, fieldsAppClipAppStoreReviewDetails?: Array<'appClipDefaultExperience' | 'invocationUrls'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsAppClipDefaultExperienceLocalizations?: Array<'appClipDefaultExperience' | 'appClipHeaderImage' | 'locale' | 'subtitle'>, limitAppClipDefaultExperienceLocalizations?: number, _options?: Configuration): Observable<AppClipDefaultExperienceResponse> {
        return this.appClipDefaultExperiencesGetInstanceWithHttpInfo(id, fieldsAppClipDefaultExperiences, include, fieldsAppClipAppStoreReviewDetails, fieldsAppStoreVersions, fieldsAppClipDefaultExperienceLocalizations, limitAppClipDefaultExperienceLocalizations, _options).pipe(map((apiResponse: HttpInfo<AppClipDefaultExperienceResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAgeRatingDeclarations the fields to include for returned resources of type ageRatingDeclarations
     * @param fieldsAppStoreReviewDetails the fields to include for returned resources of type appStoreReviewDetails
     * @param fieldsAppStoreVersionLocalizations the fields to include for returned resources of type appStoreVersionLocalizations
     * @param fieldsAppStoreVersionExperiments the fields to include for returned resources of type appStoreVersionExperiments
     * @param fieldsAppStoreVersionSubmissions the fields to include for returned resources of type appStoreVersionSubmissions
     * @param fieldsAlternativeDistributionPackages the fields to include for returned resources of type alternativeDistributionPackages
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsRoutingAppCoverages the fields to include for returned resources of type routingAppCoverages
     * @param fieldsAppClipDefaultExperiences the fields to include for returned resources of type appClipDefaultExperiences
     * @param fieldsAppStoreVersionPhasedReleases the fields to include for returned resources of type appStoreVersionPhasedReleases
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param limitAppStoreVersionLocalizations maximum number of related appStoreVersionLocalizations returned (when they are included)
     * @param limitAppStoreVersionExperiments maximum number of related appStoreVersionExperiments returned (when they are included)
     * @param limitAppStoreVersionExperimentsV2 maximum number of related appStoreVersionExperimentsV2 returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appClipDefaultExperiencesReleaseWithAppStoreVersionGetToOneRelatedWithHttpInfo(id: string, fieldsAgeRatingDeclarations?: Array<'ageRatingOverride' | 'alcoholTobaccoOrDrugUseOrReferences' | 'contests' | 'gambling' | 'gamblingAndContests' | 'gamblingSimulated' | 'horrorOrFearThemes' | 'kidsAgeBand' | 'matureOrSuggestiveThemes' | 'medicalOrTreatmentInformation' | 'profanityOrCrudeHumor' | 'seventeenPlus' | 'sexualContentGraphicAndNudity' | 'sexualContentOrNudity' | 'unrestrictedWebAccess' | 'violenceCartoonOrFantasy' | 'violenceRealistic' | 'violenceRealisticProlongedGraphicOrSadistic'>, fieldsAppStoreReviewDetails?: Array<'appStoreReviewAttachments' | 'appStoreVersion' | 'contactEmail' | 'contactFirstName' | 'contactLastName' | 'contactPhone' | 'demoAccountName' | 'demoAccountPassword' | 'demoAccountRequired' | 'notes'>, fieldsAppStoreVersionLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersion' | 'description' | 'keywords' | 'locale' | 'marketingUrl' | 'promotionalText' | 'supportUrl' | 'whatsNew'>, fieldsAppStoreVersionExperiments?: Array<'app' | 'appStoreVersion' | 'appStoreVersionExperimentTreatments' | 'controlVersions' | 'endDate' | 'latestControlVersion' | 'name' | 'platform' | 'reviewRequired' | 'startDate' | 'started' | 'state' | 'trafficProportion'>, fieldsAppStoreVersionSubmissions?: Array<'appStoreVersion'>, fieldsAlternativeDistributionPackages?: Array<'appStoreVersion' | 'versions'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsRoutingAppCoverages?: Array<'appStoreVersion' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, fieldsAppClipDefaultExperiences?: Array<'action' | 'appClip' | 'appClipAppStoreReviewDetail' | 'appClipDefaultExperienceLocalizations' | 'appClipDefaultExperienceTemplate' | 'releaseWithAppStoreVersion'>, fieldsAppStoreVersionPhasedReleases?: Array<'appStoreVersion' | 'currentDayNumber' | 'phasedReleaseState' | 'startDate' | 'totalPauseDuration'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, limitAppStoreVersionLocalizations?: number, limitAppStoreVersionExperiments?: number, limitAppStoreVersionExperimentsV2?: number, include?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'build' | 'routingAppCoverage'>, _options?: Configuration): Observable<HttpInfo<AppStoreVersionResponse>> {
        const requestContextPromise = this.requestFactory.appClipDefaultExperiencesReleaseWithAppStoreVersionGetToOneRelated(id, fieldsAgeRatingDeclarations, fieldsAppStoreReviewDetails, fieldsAppStoreVersionLocalizations, fieldsAppStoreVersionExperiments, fieldsAppStoreVersionSubmissions, fieldsAlternativeDistributionPackages, fieldsAppStoreVersions, fieldsApps, fieldsRoutingAppCoverages, fieldsAppClipDefaultExperiences, fieldsAppStoreVersionPhasedReleases, fieldsBuilds, limitAppStoreVersionLocalizations, limitAppStoreVersionExperiments, limitAppStoreVersionExperimentsV2, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appClipDefaultExperiencesReleaseWithAppStoreVersionGetToOneRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAgeRatingDeclarations the fields to include for returned resources of type ageRatingDeclarations
     * @param fieldsAppStoreReviewDetails the fields to include for returned resources of type appStoreReviewDetails
     * @param fieldsAppStoreVersionLocalizations the fields to include for returned resources of type appStoreVersionLocalizations
     * @param fieldsAppStoreVersionExperiments the fields to include for returned resources of type appStoreVersionExperiments
     * @param fieldsAppStoreVersionSubmissions the fields to include for returned resources of type appStoreVersionSubmissions
     * @param fieldsAlternativeDistributionPackages the fields to include for returned resources of type alternativeDistributionPackages
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsRoutingAppCoverages the fields to include for returned resources of type routingAppCoverages
     * @param fieldsAppClipDefaultExperiences the fields to include for returned resources of type appClipDefaultExperiences
     * @param fieldsAppStoreVersionPhasedReleases the fields to include for returned resources of type appStoreVersionPhasedReleases
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param limitAppStoreVersionLocalizations maximum number of related appStoreVersionLocalizations returned (when they are included)
     * @param limitAppStoreVersionExperiments maximum number of related appStoreVersionExperiments returned (when they are included)
     * @param limitAppStoreVersionExperimentsV2 maximum number of related appStoreVersionExperimentsV2 returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appClipDefaultExperiencesReleaseWithAppStoreVersionGetToOneRelated(id: string, fieldsAgeRatingDeclarations?: Array<'ageRatingOverride' | 'alcoholTobaccoOrDrugUseOrReferences' | 'contests' | 'gambling' | 'gamblingAndContests' | 'gamblingSimulated' | 'horrorOrFearThemes' | 'kidsAgeBand' | 'matureOrSuggestiveThemes' | 'medicalOrTreatmentInformation' | 'profanityOrCrudeHumor' | 'seventeenPlus' | 'sexualContentGraphicAndNudity' | 'sexualContentOrNudity' | 'unrestrictedWebAccess' | 'violenceCartoonOrFantasy' | 'violenceRealistic' | 'violenceRealisticProlongedGraphicOrSadistic'>, fieldsAppStoreReviewDetails?: Array<'appStoreReviewAttachments' | 'appStoreVersion' | 'contactEmail' | 'contactFirstName' | 'contactLastName' | 'contactPhone' | 'demoAccountName' | 'demoAccountPassword' | 'demoAccountRequired' | 'notes'>, fieldsAppStoreVersionLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersion' | 'description' | 'keywords' | 'locale' | 'marketingUrl' | 'promotionalText' | 'supportUrl' | 'whatsNew'>, fieldsAppStoreVersionExperiments?: Array<'app' | 'appStoreVersion' | 'appStoreVersionExperimentTreatments' | 'controlVersions' | 'endDate' | 'latestControlVersion' | 'name' | 'platform' | 'reviewRequired' | 'startDate' | 'started' | 'state' | 'trafficProportion'>, fieldsAppStoreVersionSubmissions?: Array<'appStoreVersion'>, fieldsAlternativeDistributionPackages?: Array<'appStoreVersion' | 'versions'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsRoutingAppCoverages?: Array<'appStoreVersion' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, fieldsAppClipDefaultExperiences?: Array<'action' | 'appClip' | 'appClipAppStoreReviewDetail' | 'appClipDefaultExperienceLocalizations' | 'appClipDefaultExperienceTemplate' | 'releaseWithAppStoreVersion'>, fieldsAppStoreVersionPhasedReleases?: Array<'appStoreVersion' | 'currentDayNumber' | 'phasedReleaseState' | 'startDate' | 'totalPauseDuration'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, limitAppStoreVersionLocalizations?: number, limitAppStoreVersionExperiments?: number, limitAppStoreVersionExperimentsV2?: number, include?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'build' | 'routingAppCoverage'>, _options?: Configuration): Observable<AppStoreVersionResponse> {
        return this.appClipDefaultExperiencesReleaseWithAppStoreVersionGetToOneRelatedWithHttpInfo(id, fieldsAgeRatingDeclarations, fieldsAppStoreReviewDetails, fieldsAppStoreVersionLocalizations, fieldsAppStoreVersionExperiments, fieldsAppStoreVersionSubmissions, fieldsAlternativeDistributionPackages, fieldsAppStoreVersions, fieldsApps, fieldsRoutingAppCoverages, fieldsAppClipDefaultExperiences, fieldsAppStoreVersionPhasedReleases, fieldsBuilds, limitAppStoreVersionLocalizations, limitAppStoreVersionExperiments, limitAppStoreVersionExperimentsV2, include, _options).pipe(map((apiResponse: HttpInfo<AppStoreVersionResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public appClipDefaultExperiencesReleaseWithAppStoreVersionGetToOneRelationshipWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<AppClipDefaultExperienceReleaseWithAppStoreVersionLinkageResponse>> {
        const requestContextPromise = this.requestFactory.appClipDefaultExperiencesReleaseWithAppStoreVersionGetToOneRelationship(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appClipDefaultExperiencesReleaseWithAppStoreVersionGetToOneRelationshipWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public appClipDefaultExperiencesReleaseWithAppStoreVersionGetToOneRelationship(id: string, _options?: Configuration): Observable<AppClipDefaultExperienceReleaseWithAppStoreVersionLinkageResponse> {
        return this.appClipDefaultExperiencesReleaseWithAppStoreVersionGetToOneRelationshipWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<AppClipDefaultExperienceReleaseWithAppStoreVersionLinkageResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param appClipDefaultExperienceReleaseWithAppStoreVersionLinkageRequest Related linkage
     */
    public appClipDefaultExperiencesReleaseWithAppStoreVersionUpdateToOneRelationshipWithHttpInfo(id: string, appClipDefaultExperienceReleaseWithAppStoreVersionLinkageRequest: AppClipDefaultExperienceReleaseWithAppStoreVersionLinkageRequest, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.appClipDefaultExperiencesReleaseWithAppStoreVersionUpdateToOneRelationship(id, appClipDefaultExperienceReleaseWithAppStoreVersionLinkageRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appClipDefaultExperiencesReleaseWithAppStoreVersionUpdateToOneRelationshipWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param appClipDefaultExperienceReleaseWithAppStoreVersionLinkageRequest Related linkage
     */
    public appClipDefaultExperiencesReleaseWithAppStoreVersionUpdateToOneRelationship(id: string, appClipDefaultExperienceReleaseWithAppStoreVersionLinkageRequest: AppClipDefaultExperienceReleaseWithAppStoreVersionLinkageRequest, _options?: Configuration): Observable<void> {
        return this.appClipDefaultExperiencesReleaseWithAppStoreVersionUpdateToOneRelationshipWithHttpInfo(id, appClipDefaultExperienceReleaseWithAppStoreVersionLinkageRequest, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param appClipDefaultExperienceUpdateRequest AppClipDefaultExperience representation
     */
    public appClipDefaultExperiencesUpdateInstanceWithHttpInfo(id: string, appClipDefaultExperienceUpdateRequest: AppClipDefaultExperienceUpdateRequest, _options?: Configuration): Observable<HttpInfo<AppClipDefaultExperienceResponse>> {
        const requestContextPromise = this.requestFactory.appClipDefaultExperiencesUpdateInstance(id, appClipDefaultExperienceUpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appClipDefaultExperiencesUpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param appClipDefaultExperienceUpdateRequest AppClipDefaultExperience representation
     */
    public appClipDefaultExperiencesUpdateInstance(id: string, appClipDefaultExperienceUpdateRequest: AppClipDefaultExperienceUpdateRequest, _options?: Configuration): Observable<AppClipDefaultExperienceResponse> {
        return this.appClipDefaultExperiencesUpdateInstanceWithHttpInfo(id, appClipDefaultExperienceUpdateRequest, _options).pipe(map((apiResponse: HttpInfo<AppClipDefaultExperienceResponse>) => apiResponse.data));
    }

}

import { AppClipHeaderImagesApiRequestFactory, AppClipHeaderImagesApiResponseProcessor} from "../apis/AppClipHeaderImagesApi.ts";
export class ObservableAppClipHeaderImagesApi {
    private requestFactory: AppClipHeaderImagesApiRequestFactory;
    private responseProcessor: AppClipHeaderImagesApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: AppClipHeaderImagesApiRequestFactory,
        responseProcessor?: AppClipHeaderImagesApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new AppClipHeaderImagesApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new AppClipHeaderImagesApiResponseProcessor();
    }

    /**
     * @param appClipHeaderImageCreateRequest AppClipHeaderImage representation
     */
    public appClipHeaderImagesCreateInstanceWithHttpInfo(appClipHeaderImageCreateRequest: AppClipHeaderImageCreateRequest, _options?: Configuration): Observable<HttpInfo<AppClipHeaderImageResponse>> {
        const requestContextPromise = this.requestFactory.appClipHeaderImagesCreateInstance(appClipHeaderImageCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appClipHeaderImagesCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param appClipHeaderImageCreateRequest AppClipHeaderImage representation
     */
    public appClipHeaderImagesCreateInstance(appClipHeaderImageCreateRequest: AppClipHeaderImageCreateRequest, _options?: Configuration): Observable<AppClipHeaderImageResponse> {
        return this.appClipHeaderImagesCreateInstanceWithHttpInfo(appClipHeaderImageCreateRequest, _options).pipe(map((apiResponse: HttpInfo<AppClipHeaderImageResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public appClipHeaderImagesDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.appClipHeaderImagesDeleteInstance(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appClipHeaderImagesDeleteInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public appClipHeaderImagesDeleteInstance(id: string, _options?: Configuration): Observable<void> {
        return this.appClipHeaderImagesDeleteInstanceWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppClipHeaderImages the fields to include for returned resources of type appClipHeaderImages
     * @param include comma-separated list of relationships to include
     */
    public appClipHeaderImagesGetInstanceWithHttpInfo(id: string, fieldsAppClipHeaderImages?: Array<'appClipDefaultExperienceLocalization' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'imageAsset' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, include?: Array<'appClipDefaultExperienceLocalization'>, _options?: Configuration): Observable<HttpInfo<AppClipHeaderImageResponse>> {
        const requestContextPromise = this.requestFactory.appClipHeaderImagesGetInstance(id, fieldsAppClipHeaderImages, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appClipHeaderImagesGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppClipHeaderImages the fields to include for returned resources of type appClipHeaderImages
     * @param include comma-separated list of relationships to include
     */
    public appClipHeaderImagesGetInstance(id: string, fieldsAppClipHeaderImages?: Array<'appClipDefaultExperienceLocalization' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'imageAsset' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, include?: Array<'appClipDefaultExperienceLocalization'>, _options?: Configuration): Observable<AppClipHeaderImageResponse> {
        return this.appClipHeaderImagesGetInstanceWithHttpInfo(id, fieldsAppClipHeaderImages, include, _options).pipe(map((apiResponse: HttpInfo<AppClipHeaderImageResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param appClipHeaderImageUpdateRequest AppClipHeaderImage representation
     */
    public appClipHeaderImagesUpdateInstanceWithHttpInfo(id: string, appClipHeaderImageUpdateRequest: AppClipHeaderImageUpdateRequest, _options?: Configuration): Observable<HttpInfo<AppClipHeaderImageResponse>> {
        const requestContextPromise = this.requestFactory.appClipHeaderImagesUpdateInstance(id, appClipHeaderImageUpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appClipHeaderImagesUpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param appClipHeaderImageUpdateRequest AppClipHeaderImage representation
     */
    public appClipHeaderImagesUpdateInstance(id: string, appClipHeaderImageUpdateRequest: AppClipHeaderImageUpdateRequest, _options?: Configuration): Observable<AppClipHeaderImageResponse> {
        return this.appClipHeaderImagesUpdateInstanceWithHttpInfo(id, appClipHeaderImageUpdateRequest, _options).pipe(map((apiResponse: HttpInfo<AppClipHeaderImageResponse>) => apiResponse.data));
    }

}

import { AppClipsApiRequestFactory, AppClipsApiResponseProcessor} from "../apis/AppClipsApi.ts";
export class ObservableAppClipsApi {
    private requestFactory: AppClipsApiRequestFactory;
    private responseProcessor: AppClipsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: AppClipsApiRequestFactory,
        responseProcessor?: AppClipsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new AppClipsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new AppClipsApiResponseProcessor();
    }

    /**
     * @param id the id of the requested resource
     * @param filterAction filter by attribute \&#39;action\&#39;
     * @param filterPlaceStatus filter by attribute \&#39;placeStatus\&#39;
     * @param filterStatus filter by attribute \&#39;status\&#39;
     * @param fieldsAppClipAdvancedExperiences the fields to include for returned resources of type appClipAdvancedExperiences
     * @param fieldsAppClips the fields to include for returned resources of type appClips
     * @param fieldsAppClipAdvancedExperienceImages the fields to include for returned resources of type appClipAdvancedExperienceImages
     * @param fieldsAppClipAdvancedExperienceLocalizations the fields to include for returned resources of type appClipAdvancedExperienceLocalizations
     * @param limit maximum resources per page
     * @param limitLocalizations maximum number of related localizations returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appClipsAppClipAdvancedExperiencesGetToManyRelatedWithHttpInfo(id: string, filterAction?: Array<'OPEN' | 'VIEW' | 'PLAY'>, filterPlaceStatus?: Array<'PENDING' | 'MATCHED' | 'NO_MATCH'>, filterStatus?: Array<'RECEIVED' | 'DEACTIVATED' | 'APP_TRANSFER_IN_PROGRESS'>, fieldsAppClipAdvancedExperiences?: Array<'action' | 'appClip' | 'businessCategory' | 'defaultLanguage' | 'headerImage' | 'isPoweredBy' | 'link' | 'localizations' | 'place' | 'placeStatus' | 'removed' | 'status' | 'version'>, fieldsAppClips?: Array<'app' | 'appClipAdvancedExperiences' | 'appClipDefaultExperiences' | 'bundleId'>, fieldsAppClipAdvancedExperienceImages?: Array<'assetDeliveryState' | 'fileName' | 'fileSize' | 'imageAsset' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, fieldsAppClipAdvancedExperienceLocalizations?: Array<'language' | 'subtitle' | 'title'>, limit?: number, limitLocalizations?: number, include?: Array<'appClip' | 'headerImage' | 'localizations'>, _options?: Configuration): Observable<HttpInfo<AppClipAdvancedExperiencesResponse>> {
        const requestContextPromise = this.requestFactory.appClipsAppClipAdvancedExperiencesGetToManyRelated(id, filterAction, filterPlaceStatus, filterStatus, fieldsAppClipAdvancedExperiences, fieldsAppClips, fieldsAppClipAdvancedExperienceImages, fieldsAppClipAdvancedExperienceLocalizations, limit, limitLocalizations, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appClipsAppClipAdvancedExperiencesGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param filterAction filter by attribute \&#39;action\&#39;
     * @param filterPlaceStatus filter by attribute \&#39;placeStatus\&#39;
     * @param filterStatus filter by attribute \&#39;status\&#39;
     * @param fieldsAppClipAdvancedExperiences the fields to include for returned resources of type appClipAdvancedExperiences
     * @param fieldsAppClips the fields to include for returned resources of type appClips
     * @param fieldsAppClipAdvancedExperienceImages the fields to include for returned resources of type appClipAdvancedExperienceImages
     * @param fieldsAppClipAdvancedExperienceLocalizations the fields to include for returned resources of type appClipAdvancedExperienceLocalizations
     * @param limit maximum resources per page
     * @param limitLocalizations maximum number of related localizations returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appClipsAppClipAdvancedExperiencesGetToManyRelated(id: string, filterAction?: Array<'OPEN' | 'VIEW' | 'PLAY'>, filterPlaceStatus?: Array<'PENDING' | 'MATCHED' | 'NO_MATCH'>, filterStatus?: Array<'RECEIVED' | 'DEACTIVATED' | 'APP_TRANSFER_IN_PROGRESS'>, fieldsAppClipAdvancedExperiences?: Array<'action' | 'appClip' | 'businessCategory' | 'defaultLanguage' | 'headerImage' | 'isPoweredBy' | 'link' | 'localizations' | 'place' | 'placeStatus' | 'removed' | 'status' | 'version'>, fieldsAppClips?: Array<'app' | 'appClipAdvancedExperiences' | 'appClipDefaultExperiences' | 'bundleId'>, fieldsAppClipAdvancedExperienceImages?: Array<'assetDeliveryState' | 'fileName' | 'fileSize' | 'imageAsset' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, fieldsAppClipAdvancedExperienceLocalizations?: Array<'language' | 'subtitle' | 'title'>, limit?: number, limitLocalizations?: number, include?: Array<'appClip' | 'headerImage' | 'localizations'>, _options?: Configuration): Observable<AppClipAdvancedExperiencesResponse> {
        return this.appClipsAppClipAdvancedExperiencesGetToManyRelatedWithHttpInfo(id, filterAction, filterPlaceStatus, filterStatus, fieldsAppClipAdvancedExperiences, fieldsAppClips, fieldsAppClipAdvancedExperienceImages, fieldsAppClipAdvancedExperienceLocalizations, limit, limitLocalizations, include, _options).pipe(map((apiResponse: HttpInfo<AppClipAdvancedExperiencesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param existsReleaseWithAppStoreVersion filter by existence or non-existence of related \&#39;releaseWithAppStoreVersion\&#39;
     * @param fieldsAppClips the fields to include for returned resources of type appClips
     * @param fieldsAppClipAppStoreReviewDetails the fields to include for returned resources of type appClipAppStoreReviewDetails
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsAppClipDefaultExperiences the fields to include for returned resources of type appClipDefaultExperiences
     * @param fieldsAppClipDefaultExperienceLocalizations the fields to include for returned resources of type appClipDefaultExperienceLocalizations
     * @param limit maximum resources per page
     * @param limitAppClipDefaultExperienceLocalizations maximum number of related appClipDefaultExperienceLocalizations returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appClipsAppClipDefaultExperiencesGetToManyRelatedWithHttpInfo(id: string, existsReleaseWithAppStoreVersion?: boolean, fieldsAppClips?: Array<'app' | 'appClipAdvancedExperiences' | 'appClipDefaultExperiences' | 'bundleId'>, fieldsAppClipAppStoreReviewDetails?: Array<'appClipDefaultExperience' | 'invocationUrls'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsAppClipDefaultExperiences?: Array<'action' | 'appClip' | 'appClipAppStoreReviewDetail' | 'appClipDefaultExperienceLocalizations' | 'appClipDefaultExperienceTemplate' | 'releaseWithAppStoreVersion'>, fieldsAppClipDefaultExperienceLocalizations?: Array<'appClipDefaultExperience' | 'appClipHeaderImage' | 'locale' | 'subtitle'>, limit?: number, limitAppClipDefaultExperienceLocalizations?: number, include?: Array<'appClip' | 'appClipAppStoreReviewDetail' | 'appClipDefaultExperienceLocalizations' | 'releaseWithAppStoreVersion'>, _options?: Configuration): Observable<HttpInfo<AppClipDefaultExperiencesResponse>> {
        const requestContextPromise = this.requestFactory.appClipsAppClipDefaultExperiencesGetToManyRelated(id, existsReleaseWithAppStoreVersion, fieldsAppClips, fieldsAppClipAppStoreReviewDetails, fieldsAppStoreVersions, fieldsAppClipDefaultExperiences, fieldsAppClipDefaultExperienceLocalizations, limit, limitAppClipDefaultExperienceLocalizations, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appClipsAppClipDefaultExperiencesGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param existsReleaseWithAppStoreVersion filter by existence or non-existence of related \&#39;releaseWithAppStoreVersion\&#39;
     * @param fieldsAppClips the fields to include for returned resources of type appClips
     * @param fieldsAppClipAppStoreReviewDetails the fields to include for returned resources of type appClipAppStoreReviewDetails
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsAppClipDefaultExperiences the fields to include for returned resources of type appClipDefaultExperiences
     * @param fieldsAppClipDefaultExperienceLocalizations the fields to include for returned resources of type appClipDefaultExperienceLocalizations
     * @param limit maximum resources per page
     * @param limitAppClipDefaultExperienceLocalizations maximum number of related appClipDefaultExperienceLocalizations returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appClipsAppClipDefaultExperiencesGetToManyRelated(id: string, existsReleaseWithAppStoreVersion?: boolean, fieldsAppClips?: Array<'app' | 'appClipAdvancedExperiences' | 'appClipDefaultExperiences' | 'bundleId'>, fieldsAppClipAppStoreReviewDetails?: Array<'appClipDefaultExperience' | 'invocationUrls'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsAppClipDefaultExperiences?: Array<'action' | 'appClip' | 'appClipAppStoreReviewDetail' | 'appClipDefaultExperienceLocalizations' | 'appClipDefaultExperienceTemplate' | 'releaseWithAppStoreVersion'>, fieldsAppClipDefaultExperienceLocalizations?: Array<'appClipDefaultExperience' | 'appClipHeaderImage' | 'locale' | 'subtitle'>, limit?: number, limitAppClipDefaultExperienceLocalizations?: number, include?: Array<'appClip' | 'appClipAppStoreReviewDetail' | 'appClipDefaultExperienceLocalizations' | 'releaseWithAppStoreVersion'>, _options?: Configuration): Observable<AppClipDefaultExperiencesResponse> {
        return this.appClipsAppClipDefaultExperiencesGetToManyRelatedWithHttpInfo(id, existsReleaseWithAppStoreVersion, fieldsAppClips, fieldsAppClipAppStoreReviewDetails, fieldsAppStoreVersions, fieldsAppClipDefaultExperiences, fieldsAppClipDefaultExperienceLocalizations, limit, limitAppClipDefaultExperienceLocalizations, include, _options).pipe(map((apiResponse: HttpInfo<AppClipDefaultExperiencesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppClips the fields to include for returned resources of type appClips
     * @param include comma-separated list of relationships to include
     * @param fieldsAppClipAdvancedExperiences the fields to include for returned resources of type appClipAdvancedExperiences
     * @param fieldsAppClipDefaultExperiences the fields to include for returned resources of type appClipDefaultExperiences
     * @param limitAppClipDefaultExperiences maximum number of related appClipDefaultExperiences returned (when they are included)
     */
    public appClipsGetInstanceWithHttpInfo(id: string, fieldsAppClips?: Array<'app' | 'appClipAdvancedExperiences' | 'appClipDefaultExperiences' | 'bundleId'>, include?: Array<'app' | 'appClipDefaultExperiences'>, fieldsAppClipAdvancedExperiences?: Array<'action' | 'appClip' | 'businessCategory' | 'defaultLanguage' | 'headerImage' | 'isPoweredBy' | 'link' | 'localizations' | 'place' | 'placeStatus' | 'removed' | 'status' | 'version'>, fieldsAppClipDefaultExperiences?: Array<'action' | 'appClip' | 'appClipAppStoreReviewDetail' | 'appClipDefaultExperienceLocalizations' | 'appClipDefaultExperienceTemplate' | 'releaseWithAppStoreVersion'>, limitAppClipDefaultExperiences?: number, _options?: Configuration): Observable<HttpInfo<AppClipResponse>> {
        const requestContextPromise = this.requestFactory.appClipsGetInstance(id, fieldsAppClips, include, fieldsAppClipAdvancedExperiences, fieldsAppClipDefaultExperiences, limitAppClipDefaultExperiences, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appClipsGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppClips the fields to include for returned resources of type appClips
     * @param include comma-separated list of relationships to include
     * @param fieldsAppClipAdvancedExperiences the fields to include for returned resources of type appClipAdvancedExperiences
     * @param fieldsAppClipDefaultExperiences the fields to include for returned resources of type appClipDefaultExperiences
     * @param limitAppClipDefaultExperiences maximum number of related appClipDefaultExperiences returned (when they are included)
     */
    public appClipsGetInstance(id: string, fieldsAppClips?: Array<'app' | 'appClipAdvancedExperiences' | 'appClipDefaultExperiences' | 'bundleId'>, include?: Array<'app' | 'appClipDefaultExperiences'>, fieldsAppClipAdvancedExperiences?: Array<'action' | 'appClip' | 'businessCategory' | 'defaultLanguage' | 'headerImage' | 'isPoweredBy' | 'link' | 'localizations' | 'place' | 'placeStatus' | 'removed' | 'status' | 'version'>, fieldsAppClipDefaultExperiences?: Array<'action' | 'appClip' | 'appClipAppStoreReviewDetail' | 'appClipDefaultExperienceLocalizations' | 'appClipDefaultExperienceTemplate' | 'releaseWithAppStoreVersion'>, limitAppClipDefaultExperiences?: number, _options?: Configuration): Observable<AppClipResponse> {
        return this.appClipsGetInstanceWithHttpInfo(id, fieldsAppClips, include, fieldsAppClipAdvancedExperiences, fieldsAppClipDefaultExperiences, limitAppClipDefaultExperiences, _options).pipe(map((apiResponse: HttpInfo<AppClipResponse>) => apiResponse.data));
    }

}

import { AppCustomProductPageLocalizationsApiRequestFactory, AppCustomProductPageLocalizationsApiResponseProcessor} from "../apis/AppCustomProductPageLocalizationsApi.ts";
export class ObservableAppCustomProductPageLocalizationsApi {
    private requestFactory: AppCustomProductPageLocalizationsApiRequestFactory;
    private responseProcessor: AppCustomProductPageLocalizationsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: AppCustomProductPageLocalizationsApiRequestFactory,
        responseProcessor?: AppCustomProductPageLocalizationsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new AppCustomProductPageLocalizationsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new AppCustomProductPageLocalizationsApiResponseProcessor();
    }

    /**
     * @param id the id of the requested resource
     * @param filterPreviewType filter by attribute \&#39;previewType\&#39;
     * @param filterAppStoreVersionExperimentTreatmentLocalization filter by id(s) of related \&#39;appStoreVersionExperimentTreatmentLocalization\&#39;
     * @param filterAppStoreVersionLocalization filter by id(s) of related \&#39;appStoreVersionLocalization\&#39;
     * @param fieldsAppCustomProductPageLocalizations the fields to include for returned resources of type appCustomProductPageLocalizations
     * @param fieldsAppStoreVersionExperimentTreatmentLocalizations the fields to include for returned resources of type appStoreVersionExperimentTreatmentLocalizations
     * @param fieldsAppPreviews the fields to include for returned resources of type appPreviews
     * @param fieldsAppPreviewSets the fields to include for returned resources of type appPreviewSets
     * @param fieldsAppStoreVersionLocalizations the fields to include for returned resources of type appStoreVersionLocalizations
     * @param limit maximum resources per page
     * @param limitAppPreviews maximum number of related appPreviews returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appCustomProductPageLocalizationsAppPreviewSetsGetToManyRelatedWithHttpInfo(id: string, filterPreviewType?: Array<'IPHONE_67' | 'IPHONE_61' | 'IPHONE_65' | 'IPHONE_58' | 'IPHONE_55' | 'IPHONE_47' | 'IPHONE_40' | 'IPHONE_35' | 'IPAD_PRO_3GEN_129' | 'IPAD_PRO_3GEN_11' | 'IPAD_PRO_129' | 'IPAD_105' | 'IPAD_97' | 'DESKTOP' | 'APPLE_TV' | 'APPLE_VISION_PRO'>, filterAppStoreVersionExperimentTreatmentLocalization?: Array<string>, filterAppStoreVersionLocalization?: Array<string>, fieldsAppCustomProductPageLocalizations?: Array<'appCustomProductPageVersion' | 'appPreviewSets' | 'appScreenshotSets' | 'locale' | 'promotionalText'>, fieldsAppStoreVersionExperimentTreatmentLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersionExperimentTreatment' | 'locale'>, fieldsAppPreviews?: Array<'appPreviewSet' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'mimeType' | 'previewFrameTimeCode' | 'previewImage' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded' | 'videoUrl'>, fieldsAppPreviewSets?: Array<'appCustomProductPageLocalization' | 'appPreviews' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'previewType'>, fieldsAppStoreVersionLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersion' | 'description' | 'keywords' | 'locale' | 'marketingUrl' | 'promotionalText' | 'supportUrl' | 'whatsNew'>, limit?: number, limitAppPreviews?: number, include?: Array<'appCustomProductPageLocalization' | 'appPreviews' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization'>, _options?: Configuration): Observable<HttpInfo<AppPreviewSetsResponse>> {
        const requestContextPromise = this.requestFactory.appCustomProductPageLocalizationsAppPreviewSetsGetToManyRelated(id, filterPreviewType, filterAppStoreVersionExperimentTreatmentLocalization, filterAppStoreVersionLocalization, fieldsAppCustomProductPageLocalizations, fieldsAppStoreVersionExperimentTreatmentLocalizations, fieldsAppPreviews, fieldsAppPreviewSets, fieldsAppStoreVersionLocalizations, limit, limitAppPreviews, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appCustomProductPageLocalizationsAppPreviewSetsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param filterPreviewType filter by attribute \&#39;previewType\&#39;
     * @param filterAppStoreVersionExperimentTreatmentLocalization filter by id(s) of related \&#39;appStoreVersionExperimentTreatmentLocalization\&#39;
     * @param filterAppStoreVersionLocalization filter by id(s) of related \&#39;appStoreVersionLocalization\&#39;
     * @param fieldsAppCustomProductPageLocalizations the fields to include for returned resources of type appCustomProductPageLocalizations
     * @param fieldsAppStoreVersionExperimentTreatmentLocalizations the fields to include for returned resources of type appStoreVersionExperimentTreatmentLocalizations
     * @param fieldsAppPreviews the fields to include for returned resources of type appPreviews
     * @param fieldsAppPreviewSets the fields to include for returned resources of type appPreviewSets
     * @param fieldsAppStoreVersionLocalizations the fields to include for returned resources of type appStoreVersionLocalizations
     * @param limit maximum resources per page
     * @param limitAppPreviews maximum number of related appPreviews returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appCustomProductPageLocalizationsAppPreviewSetsGetToManyRelated(id: string, filterPreviewType?: Array<'IPHONE_67' | 'IPHONE_61' | 'IPHONE_65' | 'IPHONE_58' | 'IPHONE_55' | 'IPHONE_47' | 'IPHONE_40' | 'IPHONE_35' | 'IPAD_PRO_3GEN_129' | 'IPAD_PRO_3GEN_11' | 'IPAD_PRO_129' | 'IPAD_105' | 'IPAD_97' | 'DESKTOP' | 'APPLE_TV' | 'APPLE_VISION_PRO'>, filterAppStoreVersionExperimentTreatmentLocalization?: Array<string>, filterAppStoreVersionLocalization?: Array<string>, fieldsAppCustomProductPageLocalizations?: Array<'appCustomProductPageVersion' | 'appPreviewSets' | 'appScreenshotSets' | 'locale' | 'promotionalText'>, fieldsAppStoreVersionExperimentTreatmentLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersionExperimentTreatment' | 'locale'>, fieldsAppPreviews?: Array<'appPreviewSet' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'mimeType' | 'previewFrameTimeCode' | 'previewImage' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded' | 'videoUrl'>, fieldsAppPreviewSets?: Array<'appCustomProductPageLocalization' | 'appPreviews' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'previewType'>, fieldsAppStoreVersionLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersion' | 'description' | 'keywords' | 'locale' | 'marketingUrl' | 'promotionalText' | 'supportUrl' | 'whatsNew'>, limit?: number, limitAppPreviews?: number, include?: Array<'appCustomProductPageLocalization' | 'appPreviews' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization'>, _options?: Configuration): Observable<AppPreviewSetsResponse> {
        return this.appCustomProductPageLocalizationsAppPreviewSetsGetToManyRelatedWithHttpInfo(id, filterPreviewType, filterAppStoreVersionExperimentTreatmentLocalization, filterAppStoreVersionLocalization, fieldsAppCustomProductPageLocalizations, fieldsAppStoreVersionExperimentTreatmentLocalizations, fieldsAppPreviews, fieldsAppPreviewSets, fieldsAppStoreVersionLocalizations, limit, limitAppPreviews, include, _options).pipe(map((apiResponse: HttpInfo<AppPreviewSetsResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param filterScreenshotDisplayType filter by attribute \&#39;screenshotDisplayType\&#39;
     * @param filterAppStoreVersionExperimentTreatmentLocalization filter by id(s) of related \&#39;appStoreVersionExperimentTreatmentLocalization\&#39;
     * @param filterAppStoreVersionLocalization filter by id(s) of related \&#39;appStoreVersionLocalization\&#39;
     * @param fieldsAppScreenshotSets the fields to include for returned resources of type appScreenshotSets
     * @param fieldsAppCustomProductPageLocalizations the fields to include for returned resources of type appCustomProductPageLocalizations
     * @param fieldsAppStoreVersionExperimentTreatmentLocalizations the fields to include for returned resources of type appStoreVersionExperimentTreatmentLocalizations
     * @param fieldsAppScreenshots the fields to include for returned resources of type appScreenshots
     * @param fieldsAppStoreVersionLocalizations the fields to include for returned resources of type appStoreVersionLocalizations
     * @param limit maximum resources per page
     * @param limitAppScreenshots maximum number of related appScreenshots returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appCustomProductPageLocalizationsAppScreenshotSetsGetToManyRelatedWithHttpInfo(id: string, filterScreenshotDisplayType?: Array<'APP_IPHONE_67' | 'APP_IPHONE_61' | 'APP_IPHONE_65' | 'APP_IPHONE_58' | 'APP_IPHONE_55' | 'APP_IPHONE_47' | 'APP_IPHONE_40' | 'APP_IPHONE_35' | 'APP_IPAD_PRO_3GEN_129' | 'APP_IPAD_PRO_3GEN_11' | 'APP_IPAD_PRO_129' | 'APP_IPAD_105' | 'APP_IPAD_97' | 'APP_DESKTOP' | 'APP_WATCH_ULTRA' | 'APP_WATCH_SERIES_7' | 'APP_WATCH_SERIES_4' | 'APP_WATCH_SERIES_3' | 'APP_APPLE_TV' | 'APP_APPLE_VISION_PRO' | 'IMESSAGE_APP_IPHONE_67' | 'IMESSAGE_APP_IPHONE_61' | 'IMESSAGE_APP_IPHONE_65' | 'IMESSAGE_APP_IPHONE_58' | 'IMESSAGE_APP_IPHONE_55' | 'IMESSAGE_APP_IPHONE_47' | 'IMESSAGE_APP_IPHONE_40' | 'IMESSAGE_APP_IPAD_PRO_3GEN_129' | 'IMESSAGE_APP_IPAD_PRO_3GEN_11' | 'IMESSAGE_APP_IPAD_PRO_129' | 'IMESSAGE_APP_IPAD_105' | 'IMESSAGE_APP_IPAD_97'>, filterAppStoreVersionExperimentTreatmentLocalization?: Array<string>, filterAppStoreVersionLocalization?: Array<string>, fieldsAppScreenshotSets?: Array<'appCustomProductPageLocalization' | 'appScreenshots' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'screenshotDisplayType'>, fieldsAppCustomProductPageLocalizations?: Array<'appCustomProductPageVersion' | 'appPreviewSets' | 'appScreenshotSets' | 'locale' | 'promotionalText'>, fieldsAppStoreVersionExperimentTreatmentLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersionExperimentTreatment' | 'locale'>, fieldsAppScreenshots?: Array<'appScreenshotSet' | 'assetDeliveryState' | 'assetToken' | 'assetType' | 'fileName' | 'fileSize' | 'imageAsset' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, fieldsAppStoreVersionLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersion' | 'description' | 'keywords' | 'locale' | 'marketingUrl' | 'promotionalText' | 'supportUrl' | 'whatsNew'>, limit?: number, limitAppScreenshots?: number, include?: Array<'appCustomProductPageLocalization' | 'appScreenshots' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization'>, _options?: Configuration): Observable<HttpInfo<AppScreenshotSetsResponse>> {
        const requestContextPromise = this.requestFactory.appCustomProductPageLocalizationsAppScreenshotSetsGetToManyRelated(id, filterScreenshotDisplayType, filterAppStoreVersionExperimentTreatmentLocalization, filterAppStoreVersionLocalization, fieldsAppScreenshotSets, fieldsAppCustomProductPageLocalizations, fieldsAppStoreVersionExperimentTreatmentLocalizations, fieldsAppScreenshots, fieldsAppStoreVersionLocalizations, limit, limitAppScreenshots, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appCustomProductPageLocalizationsAppScreenshotSetsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param filterScreenshotDisplayType filter by attribute \&#39;screenshotDisplayType\&#39;
     * @param filterAppStoreVersionExperimentTreatmentLocalization filter by id(s) of related \&#39;appStoreVersionExperimentTreatmentLocalization\&#39;
     * @param filterAppStoreVersionLocalization filter by id(s) of related \&#39;appStoreVersionLocalization\&#39;
     * @param fieldsAppScreenshotSets the fields to include for returned resources of type appScreenshotSets
     * @param fieldsAppCustomProductPageLocalizations the fields to include for returned resources of type appCustomProductPageLocalizations
     * @param fieldsAppStoreVersionExperimentTreatmentLocalizations the fields to include for returned resources of type appStoreVersionExperimentTreatmentLocalizations
     * @param fieldsAppScreenshots the fields to include for returned resources of type appScreenshots
     * @param fieldsAppStoreVersionLocalizations the fields to include for returned resources of type appStoreVersionLocalizations
     * @param limit maximum resources per page
     * @param limitAppScreenshots maximum number of related appScreenshots returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appCustomProductPageLocalizationsAppScreenshotSetsGetToManyRelated(id: string, filterScreenshotDisplayType?: Array<'APP_IPHONE_67' | 'APP_IPHONE_61' | 'APP_IPHONE_65' | 'APP_IPHONE_58' | 'APP_IPHONE_55' | 'APP_IPHONE_47' | 'APP_IPHONE_40' | 'APP_IPHONE_35' | 'APP_IPAD_PRO_3GEN_129' | 'APP_IPAD_PRO_3GEN_11' | 'APP_IPAD_PRO_129' | 'APP_IPAD_105' | 'APP_IPAD_97' | 'APP_DESKTOP' | 'APP_WATCH_ULTRA' | 'APP_WATCH_SERIES_7' | 'APP_WATCH_SERIES_4' | 'APP_WATCH_SERIES_3' | 'APP_APPLE_TV' | 'APP_APPLE_VISION_PRO' | 'IMESSAGE_APP_IPHONE_67' | 'IMESSAGE_APP_IPHONE_61' | 'IMESSAGE_APP_IPHONE_65' | 'IMESSAGE_APP_IPHONE_58' | 'IMESSAGE_APP_IPHONE_55' | 'IMESSAGE_APP_IPHONE_47' | 'IMESSAGE_APP_IPHONE_40' | 'IMESSAGE_APP_IPAD_PRO_3GEN_129' | 'IMESSAGE_APP_IPAD_PRO_3GEN_11' | 'IMESSAGE_APP_IPAD_PRO_129' | 'IMESSAGE_APP_IPAD_105' | 'IMESSAGE_APP_IPAD_97'>, filterAppStoreVersionExperimentTreatmentLocalization?: Array<string>, filterAppStoreVersionLocalization?: Array<string>, fieldsAppScreenshotSets?: Array<'appCustomProductPageLocalization' | 'appScreenshots' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'screenshotDisplayType'>, fieldsAppCustomProductPageLocalizations?: Array<'appCustomProductPageVersion' | 'appPreviewSets' | 'appScreenshotSets' | 'locale' | 'promotionalText'>, fieldsAppStoreVersionExperimentTreatmentLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersionExperimentTreatment' | 'locale'>, fieldsAppScreenshots?: Array<'appScreenshotSet' | 'assetDeliveryState' | 'assetToken' | 'assetType' | 'fileName' | 'fileSize' | 'imageAsset' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, fieldsAppStoreVersionLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersion' | 'description' | 'keywords' | 'locale' | 'marketingUrl' | 'promotionalText' | 'supportUrl' | 'whatsNew'>, limit?: number, limitAppScreenshots?: number, include?: Array<'appCustomProductPageLocalization' | 'appScreenshots' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization'>, _options?: Configuration): Observable<AppScreenshotSetsResponse> {
        return this.appCustomProductPageLocalizationsAppScreenshotSetsGetToManyRelatedWithHttpInfo(id, filterScreenshotDisplayType, filterAppStoreVersionExperimentTreatmentLocalization, filterAppStoreVersionLocalization, fieldsAppScreenshotSets, fieldsAppCustomProductPageLocalizations, fieldsAppStoreVersionExperimentTreatmentLocalizations, fieldsAppScreenshots, fieldsAppStoreVersionLocalizations, limit, limitAppScreenshots, include, _options).pipe(map((apiResponse: HttpInfo<AppScreenshotSetsResponse>) => apiResponse.data));
    }

    /**
     * @param appCustomProductPageLocalizationCreateRequest AppCustomProductPageLocalization representation
     */
    public appCustomProductPageLocalizationsCreateInstanceWithHttpInfo(appCustomProductPageLocalizationCreateRequest: AppCustomProductPageLocalizationCreateRequest, _options?: Configuration): Observable<HttpInfo<AppCustomProductPageLocalizationResponse>> {
        const requestContextPromise = this.requestFactory.appCustomProductPageLocalizationsCreateInstance(appCustomProductPageLocalizationCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appCustomProductPageLocalizationsCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param appCustomProductPageLocalizationCreateRequest AppCustomProductPageLocalization representation
     */
    public appCustomProductPageLocalizationsCreateInstance(appCustomProductPageLocalizationCreateRequest: AppCustomProductPageLocalizationCreateRequest, _options?: Configuration): Observable<AppCustomProductPageLocalizationResponse> {
        return this.appCustomProductPageLocalizationsCreateInstanceWithHttpInfo(appCustomProductPageLocalizationCreateRequest, _options).pipe(map((apiResponse: HttpInfo<AppCustomProductPageLocalizationResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public appCustomProductPageLocalizationsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.appCustomProductPageLocalizationsDeleteInstance(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appCustomProductPageLocalizationsDeleteInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public appCustomProductPageLocalizationsDeleteInstance(id: string, _options?: Configuration): Observable<void> {
        return this.appCustomProductPageLocalizationsDeleteInstanceWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppCustomProductPageLocalizations the fields to include for returned resources of type appCustomProductPageLocalizations
     * @param include comma-separated list of relationships to include
     * @param fieldsAppScreenshotSets the fields to include for returned resources of type appScreenshotSets
     * @param fieldsAppPreviewSets the fields to include for returned resources of type appPreviewSets
     * @param limitAppPreviewSets maximum number of related appPreviewSets returned (when they are included)
     * @param limitAppScreenshotSets maximum number of related appScreenshotSets returned (when they are included)
     */
    public appCustomProductPageLocalizationsGetInstanceWithHttpInfo(id: string, fieldsAppCustomProductPageLocalizations?: Array<'appCustomProductPageVersion' | 'appPreviewSets' | 'appScreenshotSets' | 'locale' | 'promotionalText'>, include?: Array<'appCustomProductPageVersion' | 'appPreviewSets' | 'appScreenshotSets'>, fieldsAppScreenshotSets?: Array<'appCustomProductPageLocalization' | 'appScreenshots' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'screenshotDisplayType'>, fieldsAppPreviewSets?: Array<'appCustomProductPageLocalization' | 'appPreviews' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'previewType'>, limitAppPreviewSets?: number, limitAppScreenshotSets?: number, _options?: Configuration): Observable<HttpInfo<AppCustomProductPageLocalizationResponse>> {
        const requestContextPromise = this.requestFactory.appCustomProductPageLocalizationsGetInstance(id, fieldsAppCustomProductPageLocalizations, include, fieldsAppScreenshotSets, fieldsAppPreviewSets, limitAppPreviewSets, limitAppScreenshotSets, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appCustomProductPageLocalizationsGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppCustomProductPageLocalizations the fields to include for returned resources of type appCustomProductPageLocalizations
     * @param include comma-separated list of relationships to include
     * @param fieldsAppScreenshotSets the fields to include for returned resources of type appScreenshotSets
     * @param fieldsAppPreviewSets the fields to include for returned resources of type appPreviewSets
     * @param limitAppPreviewSets maximum number of related appPreviewSets returned (when they are included)
     * @param limitAppScreenshotSets maximum number of related appScreenshotSets returned (when they are included)
     */
    public appCustomProductPageLocalizationsGetInstance(id: string, fieldsAppCustomProductPageLocalizations?: Array<'appCustomProductPageVersion' | 'appPreviewSets' | 'appScreenshotSets' | 'locale' | 'promotionalText'>, include?: Array<'appCustomProductPageVersion' | 'appPreviewSets' | 'appScreenshotSets'>, fieldsAppScreenshotSets?: Array<'appCustomProductPageLocalization' | 'appScreenshots' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'screenshotDisplayType'>, fieldsAppPreviewSets?: Array<'appCustomProductPageLocalization' | 'appPreviews' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'previewType'>, limitAppPreviewSets?: number, limitAppScreenshotSets?: number, _options?: Configuration): Observable<AppCustomProductPageLocalizationResponse> {
        return this.appCustomProductPageLocalizationsGetInstanceWithHttpInfo(id, fieldsAppCustomProductPageLocalizations, include, fieldsAppScreenshotSets, fieldsAppPreviewSets, limitAppPreviewSets, limitAppScreenshotSets, _options).pipe(map((apiResponse: HttpInfo<AppCustomProductPageLocalizationResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param appCustomProductPageLocalizationUpdateRequest AppCustomProductPageLocalization representation
     */
    public appCustomProductPageLocalizationsUpdateInstanceWithHttpInfo(id: string, appCustomProductPageLocalizationUpdateRequest: AppCustomProductPageLocalizationUpdateRequest, _options?: Configuration): Observable<HttpInfo<AppCustomProductPageLocalizationResponse>> {
        const requestContextPromise = this.requestFactory.appCustomProductPageLocalizationsUpdateInstance(id, appCustomProductPageLocalizationUpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appCustomProductPageLocalizationsUpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param appCustomProductPageLocalizationUpdateRequest AppCustomProductPageLocalization representation
     */
    public appCustomProductPageLocalizationsUpdateInstance(id: string, appCustomProductPageLocalizationUpdateRequest: AppCustomProductPageLocalizationUpdateRequest, _options?: Configuration): Observable<AppCustomProductPageLocalizationResponse> {
        return this.appCustomProductPageLocalizationsUpdateInstanceWithHttpInfo(id, appCustomProductPageLocalizationUpdateRequest, _options).pipe(map((apiResponse: HttpInfo<AppCustomProductPageLocalizationResponse>) => apiResponse.data));
    }

}

import { AppCustomProductPageVersionsApiRequestFactory, AppCustomProductPageVersionsApiResponseProcessor} from "../apis/AppCustomProductPageVersionsApi.ts";
export class ObservableAppCustomProductPageVersionsApi {
    private requestFactory: AppCustomProductPageVersionsApiRequestFactory;
    private responseProcessor: AppCustomProductPageVersionsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: AppCustomProductPageVersionsApiRequestFactory,
        responseProcessor?: AppCustomProductPageVersionsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new AppCustomProductPageVersionsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new AppCustomProductPageVersionsApiResponseProcessor();
    }

    /**
     * @param id the id of the requested resource
     * @param filterLocale filter by attribute \&#39;locale\&#39;
     * @param fieldsAppScreenshotSets the fields to include for returned resources of type appScreenshotSets
     * @param fieldsAppCustomProductPageLocalizations the fields to include for returned resources of type appCustomProductPageLocalizations
     * @param fieldsAppCustomProductPageVersions the fields to include for returned resources of type appCustomProductPageVersions
     * @param fieldsAppPreviewSets the fields to include for returned resources of type appPreviewSets
     * @param limit maximum resources per page
     * @param limitAppScreenshotSets maximum number of related appScreenshotSets returned (when they are included)
     * @param limitAppPreviewSets maximum number of related appPreviewSets returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appCustomProductPageVersionsAppCustomProductPageLocalizationsGetToManyRelatedWithHttpInfo(id: string, filterLocale?: Array<string>, fieldsAppScreenshotSets?: Array<'appCustomProductPageLocalization' | 'appScreenshots' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'screenshotDisplayType'>, fieldsAppCustomProductPageLocalizations?: Array<'appCustomProductPageVersion' | 'appPreviewSets' | 'appScreenshotSets' | 'locale' | 'promotionalText'>, fieldsAppCustomProductPageVersions?: Array<'appCustomProductPage' | 'appCustomProductPageLocalizations' | 'state' | 'version'>, fieldsAppPreviewSets?: Array<'appCustomProductPageLocalization' | 'appPreviews' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'previewType'>, limit?: number, limitAppScreenshotSets?: number, limitAppPreviewSets?: number, include?: Array<'appCustomProductPageVersion' | 'appPreviewSets' | 'appScreenshotSets'>, _options?: Configuration): Observable<HttpInfo<AppCustomProductPageLocalizationsResponse>> {
        const requestContextPromise = this.requestFactory.appCustomProductPageVersionsAppCustomProductPageLocalizationsGetToManyRelated(id, filterLocale, fieldsAppScreenshotSets, fieldsAppCustomProductPageLocalizations, fieldsAppCustomProductPageVersions, fieldsAppPreviewSets, limit, limitAppScreenshotSets, limitAppPreviewSets, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appCustomProductPageVersionsAppCustomProductPageLocalizationsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param filterLocale filter by attribute \&#39;locale\&#39;
     * @param fieldsAppScreenshotSets the fields to include for returned resources of type appScreenshotSets
     * @param fieldsAppCustomProductPageLocalizations the fields to include for returned resources of type appCustomProductPageLocalizations
     * @param fieldsAppCustomProductPageVersions the fields to include for returned resources of type appCustomProductPageVersions
     * @param fieldsAppPreviewSets the fields to include for returned resources of type appPreviewSets
     * @param limit maximum resources per page
     * @param limitAppScreenshotSets maximum number of related appScreenshotSets returned (when they are included)
     * @param limitAppPreviewSets maximum number of related appPreviewSets returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appCustomProductPageVersionsAppCustomProductPageLocalizationsGetToManyRelated(id: string, filterLocale?: Array<string>, fieldsAppScreenshotSets?: Array<'appCustomProductPageLocalization' | 'appScreenshots' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'screenshotDisplayType'>, fieldsAppCustomProductPageLocalizations?: Array<'appCustomProductPageVersion' | 'appPreviewSets' | 'appScreenshotSets' | 'locale' | 'promotionalText'>, fieldsAppCustomProductPageVersions?: Array<'appCustomProductPage' | 'appCustomProductPageLocalizations' | 'state' | 'version'>, fieldsAppPreviewSets?: Array<'appCustomProductPageLocalization' | 'appPreviews' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'previewType'>, limit?: number, limitAppScreenshotSets?: number, limitAppPreviewSets?: number, include?: Array<'appCustomProductPageVersion' | 'appPreviewSets' | 'appScreenshotSets'>, _options?: Configuration): Observable<AppCustomProductPageLocalizationsResponse> {
        return this.appCustomProductPageVersionsAppCustomProductPageLocalizationsGetToManyRelatedWithHttpInfo(id, filterLocale, fieldsAppScreenshotSets, fieldsAppCustomProductPageLocalizations, fieldsAppCustomProductPageVersions, fieldsAppPreviewSets, limit, limitAppScreenshotSets, limitAppPreviewSets, include, _options).pipe(map((apiResponse: HttpInfo<AppCustomProductPageLocalizationsResponse>) => apiResponse.data));
    }

    /**
     * @param appCustomProductPageVersionCreateRequest AppCustomProductPageVersion representation
     */
    public appCustomProductPageVersionsCreateInstanceWithHttpInfo(appCustomProductPageVersionCreateRequest: AppCustomProductPageVersionCreateRequest, _options?: Configuration): Observable<HttpInfo<AppCustomProductPageVersionResponse>> {
        const requestContextPromise = this.requestFactory.appCustomProductPageVersionsCreateInstance(appCustomProductPageVersionCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appCustomProductPageVersionsCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param appCustomProductPageVersionCreateRequest AppCustomProductPageVersion representation
     */
    public appCustomProductPageVersionsCreateInstance(appCustomProductPageVersionCreateRequest: AppCustomProductPageVersionCreateRequest, _options?: Configuration): Observable<AppCustomProductPageVersionResponse> {
        return this.appCustomProductPageVersionsCreateInstanceWithHttpInfo(appCustomProductPageVersionCreateRequest, _options).pipe(map((apiResponse: HttpInfo<AppCustomProductPageVersionResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppCustomProductPageVersions the fields to include for returned resources of type appCustomProductPageVersions
     * @param include comma-separated list of relationships to include
     * @param fieldsAppCustomProductPageLocalizations the fields to include for returned resources of type appCustomProductPageLocalizations
     * @param limitAppCustomProductPageLocalizations maximum number of related appCustomProductPageLocalizations returned (when they are included)
     */
    public appCustomProductPageVersionsGetInstanceWithHttpInfo(id: string, fieldsAppCustomProductPageVersions?: Array<'appCustomProductPage' | 'appCustomProductPageLocalizations' | 'state' | 'version'>, include?: Array<'appCustomProductPage' | 'appCustomProductPageLocalizations'>, fieldsAppCustomProductPageLocalizations?: Array<'appCustomProductPageVersion' | 'appPreviewSets' | 'appScreenshotSets' | 'locale' | 'promotionalText'>, limitAppCustomProductPageLocalizations?: number, _options?: Configuration): Observable<HttpInfo<AppCustomProductPageVersionResponse>> {
        const requestContextPromise = this.requestFactory.appCustomProductPageVersionsGetInstance(id, fieldsAppCustomProductPageVersions, include, fieldsAppCustomProductPageLocalizations, limitAppCustomProductPageLocalizations, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appCustomProductPageVersionsGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppCustomProductPageVersions the fields to include for returned resources of type appCustomProductPageVersions
     * @param include comma-separated list of relationships to include
     * @param fieldsAppCustomProductPageLocalizations the fields to include for returned resources of type appCustomProductPageLocalizations
     * @param limitAppCustomProductPageLocalizations maximum number of related appCustomProductPageLocalizations returned (when they are included)
     */
    public appCustomProductPageVersionsGetInstance(id: string, fieldsAppCustomProductPageVersions?: Array<'appCustomProductPage' | 'appCustomProductPageLocalizations' | 'state' | 'version'>, include?: Array<'appCustomProductPage' | 'appCustomProductPageLocalizations'>, fieldsAppCustomProductPageLocalizations?: Array<'appCustomProductPageVersion' | 'appPreviewSets' | 'appScreenshotSets' | 'locale' | 'promotionalText'>, limitAppCustomProductPageLocalizations?: number, _options?: Configuration): Observable<AppCustomProductPageVersionResponse> {
        return this.appCustomProductPageVersionsGetInstanceWithHttpInfo(id, fieldsAppCustomProductPageVersions, include, fieldsAppCustomProductPageLocalizations, limitAppCustomProductPageLocalizations, _options).pipe(map((apiResponse: HttpInfo<AppCustomProductPageVersionResponse>) => apiResponse.data));
    }

}

import { AppCustomProductPagesApiRequestFactory, AppCustomProductPagesApiResponseProcessor} from "../apis/AppCustomProductPagesApi.ts";
export class ObservableAppCustomProductPagesApi {
    private requestFactory: AppCustomProductPagesApiRequestFactory;
    private responseProcessor: AppCustomProductPagesApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: AppCustomProductPagesApiRequestFactory,
        responseProcessor?: AppCustomProductPagesApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new AppCustomProductPagesApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new AppCustomProductPagesApiResponseProcessor();
    }

    /**
     * @param id the id of the requested resource
     * @param filterState filter by attribute \&#39;state\&#39;
     * @param fieldsAppCustomProductPageLocalizations the fields to include for returned resources of type appCustomProductPageLocalizations
     * @param fieldsAppCustomProductPageVersions the fields to include for returned resources of type appCustomProductPageVersions
     * @param fieldsAppCustomProductPages the fields to include for returned resources of type appCustomProductPages
     * @param limit maximum resources per page
     * @param limitAppCustomProductPageLocalizations maximum number of related appCustomProductPageLocalizations returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appCustomProductPagesAppCustomProductPageVersionsGetToManyRelatedWithHttpInfo(id: string, filterState?: Array<'PREPARE_FOR_SUBMISSION' | 'READY_FOR_REVIEW' | 'WAITING_FOR_REVIEW' | 'IN_REVIEW' | 'ACCEPTED' | 'APPROVED' | 'REPLACED_WITH_NEW_VERSION' | 'REJECTED'>, fieldsAppCustomProductPageLocalizations?: Array<'appCustomProductPageVersion' | 'appPreviewSets' | 'appScreenshotSets' | 'locale' | 'promotionalText'>, fieldsAppCustomProductPageVersions?: Array<'appCustomProductPage' | 'appCustomProductPageLocalizations' | 'state' | 'version'>, fieldsAppCustomProductPages?: Array<'app' | 'appCustomProductPageVersions' | 'appStoreVersionTemplate' | 'customProductPageTemplate' | 'name' | 'url' | 'visible'>, limit?: number, limitAppCustomProductPageLocalizations?: number, include?: Array<'appCustomProductPage' | 'appCustomProductPageLocalizations'>, _options?: Configuration): Observable<HttpInfo<AppCustomProductPageVersionsResponse>> {
        const requestContextPromise = this.requestFactory.appCustomProductPagesAppCustomProductPageVersionsGetToManyRelated(id, filterState, fieldsAppCustomProductPageLocalizations, fieldsAppCustomProductPageVersions, fieldsAppCustomProductPages, limit, limitAppCustomProductPageLocalizations, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appCustomProductPagesAppCustomProductPageVersionsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param filterState filter by attribute \&#39;state\&#39;
     * @param fieldsAppCustomProductPageLocalizations the fields to include for returned resources of type appCustomProductPageLocalizations
     * @param fieldsAppCustomProductPageVersions the fields to include for returned resources of type appCustomProductPageVersions
     * @param fieldsAppCustomProductPages the fields to include for returned resources of type appCustomProductPages
     * @param limit maximum resources per page
     * @param limitAppCustomProductPageLocalizations maximum number of related appCustomProductPageLocalizations returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appCustomProductPagesAppCustomProductPageVersionsGetToManyRelated(id: string, filterState?: Array<'PREPARE_FOR_SUBMISSION' | 'READY_FOR_REVIEW' | 'WAITING_FOR_REVIEW' | 'IN_REVIEW' | 'ACCEPTED' | 'APPROVED' | 'REPLACED_WITH_NEW_VERSION' | 'REJECTED'>, fieldsAppCustomProductPageLocalizations?: Array<'appCustomProductPageVersion' | 'appPreviewSets' | 'appScreenshotSets' | 'locale' | 'promotionalText'>, fieldsAppCustomProductPageVersions?: Array<'appCustomProductPage' | 'appCustomProductPageLocalizations' | 'state' | 'version'>, fieldsAppCustomProductPages?: Array<'app' | 'appCustomProductPageVersions' | 'appStoreVersionTemplate' | 'customProductPageTemplate' | 'name' | 'url' | 'visible'>, limit?: number, limitAppCustomProductPageLocalizations?: number, include?: Array<'appCustomProductPage' | 'appCustomProductPageLocalizations'>, _options?: Configuration): Observable<AppCustomProductPageVersionsResponse> {
        return this.appCustomProductPagesAppCustomProductPageVersionsGetToManyRelatedWithHttpInfo(id, filterState, fieldsAppCustomProductPageLocalizations, fieldsAppCustomProductPageVersions, fieldsAppCustomProductPages, limit, limitAppCustomProductPageLocalizations, include, _options).pipe(map((apiResponse: HttpInfo<AppCustomProductPageVersionsResponse>) => apiResponse.data));
    }

    /**
     * @param appCustomProductPageCreateRequest AppCustomProductPage representation
     */
    public appCustomProductPagesCreateInstanceWithHttpInfo(appCustomProductPageCreateRequest: AppCustomProductPageCreateRequest, _options?: Configuration): Observable<HttpInfo<AppCustomProductPageResponse>> {
        const requestContextPromise = this.requestFactory.appCustomProductPagesCreateInstance(appCustomProductPageCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appCustomProductPagesCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param appCustomProductPageCreateRequest AppCustomProductPage representation
     */
    public appCustomProductPagesCreateInstance(appCustomProductPageCreateRequest: AppCustomProductPageCreateRequest, _options?: Configuration): Observable<AppCustomProductPageResponse> {
        return this.appCustomProductPagesCreateInstanceWithHttpInfo(appCustomProductPageCreateRequest, _options).pipe(map((apiResponse: HttpInfo<AppCustomProductPageResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public appCustomProductPagesDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.appCustomProductPagesDeleteInstance(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appCustomProductPagesDeleteInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public appCustomProductPagesDeleteInstance(id: string, _options?: Configuration): Observable<void> {
        return this.appCustomProductPagesDeleteInstanceWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppCustomProductPages the fields to include for returned resources of type appCustomProductPages
     * @param include comma-separated list of relationships to include
     * @param fieldsAppCustomProductPageVersions the fields to include for returned resources of type appCustomProductPageVersions
     * @param limitAppCustomProductPageVersions maximum number of related appCustomProductPageVersions returned (when they are included)
     */
    public appCustomProductPagesGetInstanceWithHttpInfo(id: string, fieldsAppCustomProductPages?: Array<'app' | 'appCustomProductPageVersions' | 'appStoreVersionTemplate' | 'customProductPageTemplate' | 'name' | 'url' | 'visible'>, include?: Array<'app' | 'appCustomProductPageVersions'>, fieldsAppCustomProductPageVersions?: Array<'appCustomProductPage' | 'appCustomProductPageLocalizations' | 'state' | 'version'>, limitAppCustomProductPageVersions?: number, _options?: Configuration): Observable<HttpInfo<AppCustomProductPageResponse>> {
        const requestContextPromise = this.requestFactory.appCustomProductPagesGetInstance(id, fieldsAppCustomProductPages, include, fieldsAppCustomProductPageVersions, limitAppCustomProductPageVersions, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appCustomProductPagesGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppCustomProductPages the fields to include for returned resources of type appCustomProductPages
     * @param include comma-separated list of relationships to include
     * @param fieldsAppCustomProductPageVersions the fields to include for returned resources of type appCustomProductPageVersions
     * @param limitAppCustomProductPageVersions maximum number of related appCustomProductPageVersions returned (when they are included)
     */
    public appCustomProductPagesGetInstance(id: string, fieldsAppCustomProductPages?: Array<'app' | 'appCustomProductPageVersions' | 'appStoreVersionTemplate' | 'customProductPageTemplate' | 'name' | 'url' | 'visible'>, include?: Array<'app' | 'appCustomProductPageVersions'>, fieldsAppCustomProductPageVersions?: Array<'appCustomProductPage' | 'appCustomProductPageLocalizations' | 'state' | 'version'>, limitAppCustomProductPageVersions?: number, _options?: Configuration): Observable<AppCustomProductPageResponse> {
        return this.appCustomProductPagesGetInstanceWithHttpInfo(id, fieldsAppCustomProductPages, include, fieldsAppCustomProductPageVersions, limitAppCustomProductPageVersions, _options).pipe(map((apiResponse: HttpInfo<AppCustomProductPageResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param appCustomProductPageUpdateRequest AppCustomProductPage representation
     */
    public appCustomProductPagesUpdateInstanceWithHttpInfo(id: string, appCustomProductPageUpdateRequest: AppCustomProductPageUpdateRequest, _options?: Configuration): Observable<HttpInfo<AppCustomProductPageResponse>> {
        const requestContextPromise = this.requestFactory.appCustomProductPagesUpdateInstance(id, appCustomProductPageUpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appCustomProductPagesUpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param appCustomProductPageUpdateRequest AppCustomProductPage representation
     */
    public appCustomProductPagesUpdateInstance(id: string, appCustomProductPageUpdateRequest: AppCustomProductPageUpdateRequest, _options?: Configuration): Observable<AppCustomProductPageResponse> {
        return this.appCustomProductPagesUpdateInstanceWithHttpInfo(id, appCustomProductPageUpdateRequest, _options).pipe(map((apiResponse: HttpInfo<AppCustomProductPageResponse>) => apiResponse.data));
    }

}

import { AppEncryptionDeclarationDocumentsApiRequestFactory, AppEncryptionDeclarationDocumentsApiResponseProcessor} from "../apis/AppEncryptionDeclarationDocumentsApi.ts";
export class ObservableAppEncryptionDeclarationDocumentsApi {
    private requestFactory: AppEncryptionDeclarationDocumentsApiRequestFactory;
    private responseProcessor: AppEncryptionDeclarationDocumentsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: AppEncryptionDeclarationDocumentsApiRequestFactory,
        responseProcessor?: AppEncryptionDeclarationDocumentsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new AppEncryptionDeclarationDocumentsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new AppEncryptionDeclarationDocumentsApiResponseProcessor();
    }

    /**
     * @param appEncryptionDeclarationDocumentCreateRequest AppEncryptionDeclarationDocument representation
     */
    public appEncryptionDeclarationDocumentsCreateInstanceWithHttpInfo(appEncryptionDeclarationDocumentCreateRequest: AppEncryptionDeclarationDocumentCreateRequest, _options?: Configuration): Observable<HttpInfo<AppEncryptionDeclarationDocumentResponse>> {
        const requestContextPromise = this.requestFactory.appEncryptionDeclarationDocumentsCreateInstance(appEncryptionDeclarationDocumentCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appEncryptionDeclarationDocumentsCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param appEncryptionDeclarationDocumentCreateRequest AppEncryptionDeclarationDocument representation
     */
    public appEncryptionDeclarationDocumentsCreateInstance(appEncryptionDeclarationDocumentCreateRequest: AppEncryptionDeclarationDocumentCreateRequest, _options?: Configuration): Observable<AppEncryptionDeclarationDocumentResponse> {
        return this.appEncryptionDeclarationDocumentsCreateInstanceWithHttpInfo(appEncryptionDeclarationDocumentCreateRequest, _options).pipe(map((apiResponse: HttpInfo<AppEncryptionDeclarationDocumentResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppEncryptionDeclarationDocuments the fields to include for returned resources of type appEncryptionDeclarationDocuments
     */
    public appEncryptionDeclarationDocumentsGetInstanceWithHttpInfo(id: string, fieldsAppEncryptionDeclarationDocuments?: Array<'appEncryptionDeclaration' | 'assetDeliveryState' | 'assetToken' | 'downloadUrl' | 'fileName' | 'fileSize' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, _options?: Configuration): Observable<HttpInfo<AppEncryptionDeclarationDocumentResponse>> {
        const requestContextPromise = this.requestFactory.appEncryptionDeclarationDocumentsGetInstance(id, fieldsAppEncryptionDeclarationDocuments, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appEncryptionDeclarationDocumentsGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppEncryptionDeclarationDocuments the fields to include for returned resources of type appEncryptionDeclarationDocuments
     */
    public appEncryptionDeclarationDocumentsGetInstance(id: string, fieldsAppEncryptionDeclarationDocuments?: Array<'appEncryptionDeclaration' | 'assetDeliveryState' | 'assetToken' | 'downloadUrl' | 'fileName' | 'fileSize' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, _options?: Configuration): Observable<AppEncryptionDeclarationDocumentResponse> {
        return this.appEncryptionDeclarationDocumentsGetInstanceWithHttpInfo(id, fieldsAppEncryptionDeclarationDocuments, _options).pipe(map((apiResponse: HttpInfo<AppEncryptionDeclarationDocumentResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param appEncryptionDeclarationDocumentUpdateRequest AppEncryptionDeclarationDocument representation
     */
    public appEncryptionDeclarationDocumentsUpdateInstanceWithHttpInfo(id: string, appEncryptionDeclarationDocumentUpdateRequest: AppEncryptionDeclarationDocumentUpdateRequest, _options?: Configuration): Observable<HttpInfo<AppEncryptionDeclarationDocumentResponse>> {
        const requestContextPromise = this.requestFactory.appEncryptionDeclarationDocumentsUpdateInstance(id, appEncryptionDeclarationDocumentUpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appEncryptionDeclarationDocumentsUpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param appEncryptionDeclarationDocumentUpdateRequest AppEncryptionDeclarationDocument representation
     */
    public appEncryptionDeclarationDocumentsUpdateInstance(id: string, appEncryptionDeclarationDocumentUpdateRequest: AppEncryptionDeclarationDocumentUpdateRequest, _options?: Configuration): Observable<AppEncryptionDeclarationDocumentResponse> {
        return this.appEncryptionDeclarationDocumentsUpdateInstanceWithHttpInfo(id, appEncryptionDeclarationDocumentUpdateRequest, _options).pipe(map((apiResponse: HttpInfo<AppEncryptionDeclarationDocumentResponse>) => apiResponse.data));
    }

}

import { AppEncryptionDeclarationsApiRequestFactory, AppEncryptionDeclarationsApiResponseProcessor} from "../apis/AppEncryptionDeclarationsApi.ts";
export class ObservableAppEncryptionDeclarationsApi {
    private requestFactory: AppEncryptionDeclarationsApiRequestFactory;
    private responseProcessor: AppEncryptionDeclarationsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: AppEncryptionDeclarationsApiRequestFactory,
        responseProcessor?: AppEncryptionDeclarationsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new AppEncryptionDeclarationsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new AppEncryptionDeclarationsApiResponseProcessor();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppEncryptionDeclarationDocuments the fields to include for returned resources of type appEncryptionDeclarationDocuments
     */
    public appEncryptionDeclarationsAppEncryptionDeclarationDocumentGetToOneRelatedWithHttpInfo(id: string, fieldsAppEncryptionDeclarationDocuments?: Array<'appEncryptionDeclaration' | 'assetDeliveryState' | 'assetToken' | 'downloadUrl' | 'fileName' | 'fileSize' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, _options?: Configuration): Observable<HttpInfo<AppEncryptionDeclarationDocumentResponse>> {
        const requestContextPromise = this.requestFactory.appEncryptionDeclarationsAppEncryptionDeclarationDocumentGetToOneRelated(id, fieldsAppEncryptionDeclarationDocuments, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appEncryptionDeclarationsAppEncryptionDeclarationDocumentGetToOneRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppEncryptionDeclarationDocuments the fields to include for returned resources of type appEncryptionDeclarationDocuments
     */
    public appEncryptionDeclarationsAppEncryptionDeclarationDocumentGetToOneRelated(id: string, fieldsAppEncryptionDeclarationDocuments?: Array<'appEncryptionDeclaration' | 'assetDeliveryState' | 'assetToken' | 'downloadUrl' | 'fileName' | 'fileSize' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, _options?: Configuration): Observable<AppEncryptionDeclarationDocumentResponse> {
        return this.appEncryptionDeclarationsAppEncryptionDeclarationDocumentGetToOneRelatedWithHttpInfo(id, fieldsAppEncryptionDeclarationDocuments, _options).pipe(map((apiResponse: HttpInfo<AppEncryptionDeclarationDocumentResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsApps the fields to include for returned resources of type apps
     */
    public appEncryptionDeclarationsAppGetToOneRelatedWithHttpInfo(id: string, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, _options?: Configuration): Observable<HttpInfo<AppWithoutIncludesResponse>> {
        const requestContextPromise = this.requestFactory.appEncryptionDeclarationsAppGetToOneRelated(id, fieldsApps, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appEncryptionDeclarationsAppGetToOneRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsApps the fields to include for returned resources of type apps
     */
    public appEncryptionDeclarationsAppGetToOneRelated(id: string, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, _options?: Configuration): Observable<AppWithoutIncludesResponse> {
        return this.appEncryptionDeclarationsAppGetToOneRelatedWithHttpInfo(id, fieldsApps, _options).pipe(map((apiResponse: HttpInfo<AppWithoutIncludesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param appEncryptionDeclarationBuildsLinkagesRequest List of related linkages
     */
    public appEncryptionDeclarationsBuildsCreateToManyRelationshipWithHttpInfo(id: string, appEncryptionDeclarationBuildsLinkagesRequest: AppEncryptionDeclarationBuildsLinkagesRequest, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.appEncryptionDeclarationsBuildsCreateToManyRelationship(id, appEncryptionDeclarationBuildsLinkagesRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appEncryptionDeclarationsBuildsCreateToManyRelationshipWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param appEncryptionDeclarationBuildsLinkagesRequest List of related linkages
     */
    public appEncryptionDeclarationsBuildsCreateToManyRelationship(id: string, appEncryptionDeclarationBuildsLinkagesRequest: AppEncryptionDeclarationBuildsLinkagesRequest, _options?: Configuration): Observable<void> {
        return this.appEncryptionDeclarationsBuildsCreateToManyRelationshipWithHttpInfo(id, appEncryptionDeclarationBuildsLinkagesRequest, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param filterPlatform filter by attribute \&#39;platform\&#39;
     * @param filterApp filter by id(s) of related \&#39;app\&#39;
     * @param filterBuilds filter by id(s) of related \&#39;builds\&#39;
     * @param fieldsAppEncryptionDeclarations the fields to include for returned resources of type appEncryptionDeclarations
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsAppEncryptionDeclarationDocuments the fields to include for returned resources of type appEncryptionDeclarationDocuments
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param limitBuilds maximum number of related builds returned (when they are included)
     */
    public appEncryptionDeclarationsGetCollectionWithHttpInfo(filterPlatform?: Array<'IOS' | 'MAC_OS' | 'TV_OS' | 'VISION_OS'>, filterApp?: Array<string>, filterBuilds?: Array<string>, fieldsAppEncryptionDeclarations?: Array<'app' | 'appDescription' | 'appEncryptionDeclarationDocument' | 'appEncryptionDeclarationState' | 'availableOnFrenchStore' | 'builds' | 'codeValue' | 'containsProprietaryCryptography' | 'containsThirdPartyCryptography' | 'createdDate' | 'documentName' | 'documentType' | 'documentUrl' | 'exempt' | 'platform' | 'uploadedDate' | 'usesEncryption'>, limit?: number, include?: Array<'app' | 'appEncryptionDeclarationDocument' | 'builds'>, fieldsAppEncryptionDeclarationDocuments?: Array<'appEncryptionDeclaration' | 'assetDeliveryState' | 'assetToken' | 'downloadUrl' | 'fileName' | 'fileSize' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, limitBuilds?: number, _options?: Configuration): Observable<HttpInfo<AppEncryptionDeclarationsResponse>> {
        const requestContextPromise = this.requestFactory.appEncryptionDeclarationsGetCollection(filterPlatform, filterApp, filterBuilds, fieldsAppEncryptionDeclarations, limit, include, fieldsAppEncryptionDeclarationDocuments, fieldsApps, limitBuilds, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appEncryptionDeclarationsGetCollectionWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param filterPlatform filter by attribute \&#39;platform\&#39;
     * @param filterApp filter by id(s) of related \&#39;app\&#39;
     * @param filterBuilds filter by id(s) of related \&#39;builds\&#39;
     * @param fieldsAppEncryptionDeclarations the fields to include for returned resources of type appEncryptionDeclarations
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsAppEncryptionDeclarationDocuments the fields to include for returned resources of type appEncryptionDeclarationDocuments
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param limitBuilds maximum number of related builds returned (when they are included)
     */
    public appEncryptionDeclarationsGetCollection(filterPlatform?: Array<'IOS' | 'MAC_OS' | 'TV_OS' | 'VISION_OS'>, filterApp?: Array<string>, filterBuilds?: Array<string>, fieldsAppEncryptionDeclarations?: Array<'app' | 'appDescription' | 'appEncryptionDeclarationDocument' | 'appEncryptionDeclarationState' | 'availableOnFrenchStore' | 'builds' | 'codeValue' | 'containsProprietaryCryptography' | 'containsThirdPartyCryptography' | 'createdDate' | 'documentName' | 'documentType' | 'documentUrl' | 'exempt' | 'platform' | 'uploadedDate' | 'usesEncryption'>, limit?: number, include?: Array<'app' | 'appEncryptionDeclarationDocument' | 'builds'>, fieldsAppEncryptionDeclarationDocuments?: Array<'appEncryptionDeclaration' | 'assetDeliveryState' | 'assetToken' | 'downloadUrl' | 'fileName' | 'fileSize' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, limitBuilds?: number, _options?: Configuration): Observable<AppEncryptionDeclarationsResponse> {
        return this.appEncryptionDeclarationsGetCollectionWithHttpInfo(filterPlatform, filterApp, filterBuilds, fieldsAppEncryptionDeclarations, limit, include, fieldsAppEncryptionDeclarationDocuments, fieldsApps, limitBuilds, _options).pipe(map((apiResponse: HttpInfo<AppEncryptionDeclarationsResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppEncryptionDeclarations the fields to include for returned resources of type appEncryptionDeclarations
     * @param include comma-separated list of relationships to include
     * @param fieldsAppEncryptionDeclarationDocuments the fields to include for returned resources of type appEncryptionDeclarationDocuments
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param limitBuilds maximum number of related builds returned (when they are included)
     */
    public appEncryptionDeclarationsGetInstanceWithHttpInfo(id: string, fieldsAppEncryptionDeclarations?: Array<'app' | 'appDescription' | 'appEncryptionDeclarationDocument' | 'appEncryptionDeclarationState' | 'availableOnFrenchStore' | 'builds' | 'codeValue' | 'containsProprietaryCryptography' | 'containsThirdPartyCryptography' | 'createdDate' | 'documentName' | 'documentType' | 'documentUrl' | 'exempt' | 'platform' | 'uploadedDate' | 'usesEncryption'>, include?: Array<'app' | 'appEncryptionDeclarationDocument' | 'builds'>, fieldsAppEncryptionDeclarationDocuments?: Array<'appEncryptionDeclaration' | 'assetDeliveryState' | 'assetToken' | 'downloadUrl' | 'fileName' | 'fileSize' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, limitBuilds?: number, _options?: Configuration): Observable<HttpInfo<AppEncryptionDeclarationResponse>> {
        const requestContextPromise = this.requestFactory.appEncryptionDeclarationsGetInstance(id, fieldsAppEncryptionDeclarations, include, fieldsAppEncryptionDeclarationDocuments, fieldsApps, limitBuilds, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appEncryptionDeclarationsGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppEncryptionDeclarations the fields to include for returned resources of type appEncryptionDeclarations
     * @param include comma-separated list of relationships to include
     * @param fieldsAppEncryptionDeclarationDocuments the fields to include for returned resources of type appEncryptionDeclarationDocuments
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param limitBuilds maximum number of related builds returned (when they are included)
     */
    public appEncryptionDeclarationsGetInstance(id: string, fieldsAppEncryptionDeclarations?: Array<'app' | 'appDescription' | 'appEncryptionDeclarationDocument' | 'appEncryptionDeclarationState' | 'availableOnFrenchStore' | 'builds' | 'codeValue' | 'containsProprietaryCryptography' | 'containsThirdPartyCryptography' | 'createdDate' | 'documentName' | 'documentType' | 'documentUrl' | 'exempt' | 'platform' | 'uploadedDate' | 'usesEncryption'>, include?: Array<'app' | 'appEncryptionDeclarationDocument' | 'builds'>, fieldsAppEncryptionDeclarationDocuments?: Array<'appEncryptionDeclaration' | 'assetDeliveryState' | 'assetToken' | 'downloadUrl' | 'fileName' | 'fileSize' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, limitBuilds?: number, _options?: Configuration): Observable<AppEncryptionDeclarationResponse> {
        return this.appEncryptionDeclarationsGetInstanceWithHttpInfo(id, fieldsAppEncryptionDeclarations, include, fieldsAppEncryptionDeclarationDocuments, fieldsApps, limitBuilds, _options).pipe(map((apiResponse: HttpInfo<AppEncryptionDeclarationResponse>) => apiResponse.data));
    }

}

import { AppEventLocalizationsApiRequestFactory, AppEventLocalizationsApiResponseProcessor} from "../apis/AppEventLocalizationsApi.ts";
export class ObservableAppEventLocalizationsApi {
    private requestFactory: AppEventLocalizationsApiRequestFactory;
    private responseProcessor: AppEventLocalizationsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: AppEventLocalizationsApiRequestFactory,
        responseProcessor?: AppEventLocalizationsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new AppEventLocalizationsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new AppEventLocalizationsApiResponseProcessor();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppEventScreenshots the fields to include for returned resources of type appEventScreenshots
     * @param fieldsAppEventLocalizations the fields to include for returned resources of type appEventLocalizations
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public appEventLocalizationsAppEventScreenshotsGetToManyRelatedWithHttpInfo(id: string, fieldsAppEventScreenshots?: Array<'appEventAssetType' | 'appEventLocalization' | 'assetDeliveryState' | 'assetToken' | 'fileName' | 'fileSize' | 'imageAsset' | 'uploadOperations' | 'uploaded'>, fieldsAppEventLocalizations?: Array<'appEvent' | 'appEventScreenshots' | 'appEventVideoClips' | 'locale' | 'longDescription' | 'name' | 'shortDescription'>, limit?: number, include?: Array<'appEventLocalization'>, _options?: Configuration): Observable<HttpInfo<AppEventScreenshotsResponse>> {
        const requestContextPromise = this.requestFactory.appEventLocalizationsAppEventScreenshotsGetToManyRelated(id, fieldsAppEventScreenshots, fieldsAppEventLocalizations, limit, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appEventLocalizationsAppEventScreenshotsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppEventScreenshots the fields to include for returned resources of type appEventScreenshots
     * @param fieldsAppEventLocalizations the fields to include for returned resources of type appEventLocalizations
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public appEventLocalizationsAppEventScreenshotsGetToManyRelated(id: string, fieldsAppEventScreenshots?: Array<'appEventAssetType' | 'appEventLocalization' | 'assetDeliveryState' | 'assetToken' | 'fileName' | 'fileSize' | 'imageAsset' | 'uploadOperations' | 'uploaded'>, fieldsAppEventLocalizations?: Array<'appEvent' | 'appEventScreenshots' | 'appEventVideoClips' | 'locale' | 'longDescription' | 'name' | 'shortDescription'>, limit?: number, include?: Array<'appEventLocalization'>, _options?: Configuration): Observable<AppEventScreenshotsResponse> {
        return this.appEventLocalizationsAppEventScreenshotsGetToManyRelatedWithHttpInfo(id, fieldsAppEventScreenshots, fieldsAppEventLocalizations, limit, include, _options).pipe(map((apiResponse: HttpInfo<AppEventScreenshotsResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppEventVideoClips the fields to include for returned resources of type appEventVideoClips
     * @param fieldsAppEventLocalizations the fields to include for returned resources of type appEventLocalizations
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public appEventLocalizationsAppEventVideoClipsGetToManyRelatedWithHttpInfo(id: string, fieldsAppEventVideoClips?: Array<'appEventAssetType' | 'appEventLocalization' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'previewFrameTimeCode' | 'previewImage' | 'uploadOperations' | 'uploaded' | 'videoUrl'>, fieldsAppEventLocalizations?: Array<'appEvent' | 'appEventScreenshots' | 'appEventVideoClips' | 'locale' | 'longDescription' | 'name' | 'shortDescription'>, limit?: number, include?: Array<'appEventLocalization'>, _options?: Configuration): Observable<HttpInfo<AppEventVideoClipsResponse>> {
        const requestContextPromise = this.requestFactory.appEventLocalizationsAppEventVideoClipsGetToManyRelated(id, fieldsAppEventVideoClips, fieldsAppEventLocalizations, limit, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appEventLocalizationsAppEventVideoClipsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppEventVideoClips the fields to include for returned resources of type appEventVideoClips
     * @param fieldsAppEventLocalizations the fields to include for returned resources of type appEventLocalizations
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public appEventLocalizationsAppEventVideoClipsGetToManyRelated(id: string, fieldsAppEventVideoClips?: Array<'appEventAssetType' | 'appEventLocalization' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'previewFrameTimeCode' | 'previewImage' | 'uploadOperations' | 'uploaded' | 'videoUrl'>, fieldsAppEventLocalizations?: Array<'appEvent' | 'appEventScreenshots' | 'appEventVideoClips' | 'locale' | 'longDescription' | 'name' | 'shortDescription'>, limit?: number, include?: Array<'appEventLocalization'>, _options?: Configuration): Observable<AppEventVideoClipsResponse> {
        return this.appEventLocalizationsAppEventVideoClipsGetToManyRelatedWithHttpInfo(id, fieldsAppEventVideoClips, fieldsAppEventLocalizations, limit, include, _options).pipe(map((apiResponse: HttpInfo<AppEventVideoClipsResponse>) => apiResponse.data));
    }

    /**
     * @param appEventLocalizationCreateRequest AppEventLocalization representation
     */
    public appEventLocalizationsCreateInstanceWithHttpInfo(appEventLocalizationCreateRequest: AppEventLocalizationCreateRequest, _options?: Configuration): Observable<HttpInfo<AppEventLocalizationResponse>> {
        const requestContextPromise = this.requestFactory.appEventLocalizationsCreateInstance(appEventLocalizationCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appEventLocalizationsCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param appEventLocalizationCreateRequest AppEventLocalization representation
     */
    public appEventLocalizationsCreateInstance(appEventLocalizationCreateRequest: AppEventLocalizationCreateRequest, _options?: Configuration): Observable<AppEventLocalizationResponse> {
        return this.appEventLocalizationsCreateInstanceWithHttpInfo(appEventLocalizationCreateRequest, _options).pipe(map((apiResponse: HttpInfo<AppEventLocalizationResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public appEventLocalizationsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.appEventLocalizationsDeleteInstance(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appEventLocalizationsDeleteInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public appEventLocalizationsDeleteInstance(id: string, _options?: Configuration): Observable<void> {
        return this.appEventLocalizationsDeleteInstanceWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppEventLocalizations the fields to include for returned resources of type appEventLocalizations
     * @param include comma-separated list of relationships to include
     * @param fieldsAppEventScreenshots the fields to include for returned resources of type appEventScreenshots
     * @param fieldsAppEventVideoClips the fields to include for returned resources of type appEventVideoClips
     * @param limitAppEventScreenshots maximum number of related appEventScreenshots returned (when they are included)
     * @param limitAppEventVideoClips maximum number of related appEventVideoClips returned (when they are included)
     */
    public appEventLocalizationsGetInstanceWithHttpInfo(id: string, fieldsAppEventLocalizations?: Array<'appEvent' | 'appEventScreenshots' | 'appEventVideoClips' | 'locale' | 'longDescription' | 'name' | 'shortDescription'>, include?: Array<'appEvent' | 'appEventScreenshots' | 'appEventVideoClips'>, fieldsAppEventScreenshots?: Array<'appEventAssetType' | 'appEventLocalization' | 'assetDeliveryState' | 'assetToken' | 'fileName' | 'fileSize' | 'imageAsset' | 'uploadOperations' | 'uploaded'>, fieldsAppEventVideoClips?: Array<'appEventAssetType' | 'appEventLocalization' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'previewFrameTimeCode' | 'previewImage' | 'uploadOperations' | 'uploaded' | 'videoUrl'>, limitAppEventScreenshots?: number, limitAppEventVideoClips?: number, _options?: Configuration): Observable<HttpInfo<AppEventLocalizationResponse>> {
        const requestContextPromise = this.requestFactory.appEventLocalizationsGetInstance(id, fieldsAppEventLocalizations, include, fieldsAppEventScreenshots, fieldsAppEventVideoClips, limitAppEventScreenshots, limitAppEventVideoClips, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appEventLocalizationsGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppEventLocalizations the fields to include for returned resources of type appEventLocalizations
     * @param include comma-separated list of relationships to include
     * @param fieldsAppEventScreenshots the fields to include for returned resources of type appEventScreenshots
     * @param fieldsAppEventVideoClips the fields to include for returned resources of type appEventVideoClips
     * @param limitAppEventScreenshots maximum number of related appEventScreenshots returned (when they are included)
     * @param limitAppEventVideoClips maximum number of related appEventVideoClips returned (when they are included)
     */
    public appEventLocalizationsGetInstance(id: string, fieldsAppEventLocalizations?: Array<'appEvent' | 'appEventScreenshots' | 'appEventVideoClips' | 'locale' | 'longDescription' | 'name' | 'shortDescription'>, include?: Array<'appEvent' | 'appEventScreenshots' | 'appEventVideoClips'>, fieldsAppEventScreenshots?: Array<'appEventAssetType' | 'appEventLocalization' | 'assetDeliveryState' | 'assetToken' | 'fileName' | 'fileSize' | 'imageAsset' | 'uploadOperations' | 'uploaded'>, fieldsAppEventVideoClips?: Array<'appEventAssetType' | 'appEventLocalization' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'previewFrameTimeCode' | 'previewImage' | 'uploadOperations' | 'uploaded' | 'videoUrl'>, limitAppEventScreenshots?: number, limitAppEventVideoClips?: number, _options?: Configuration): Observable<AppEventLocalizationResponse> {
        return this.appEventLocalizationsGetInstanceWithHttpInfo(id, fieldsAppEventLocalizations, include, fieldsAppEventScreenshots, fieldsAppEventVideoClips, limitAppEventScreenshots, limitAppEventVideoClips, _options).pipe(map((apiResponse: HttpInfo<AppEventLocalizationResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param appEventLocalizationUpdateRequest AppEventLocalization representation
     */
    public appEventLocalizationsUpdateInstanceWithHttpInfo(id: string, appEventLocalizationUpdateRequest: AppEventLocalizationUpdateRequest, _options?: Configuration): Observable<HttpInfo<AppEventLocalizationResponse>> {
        const requestContextPromise = this.requestFactory.appEventLocalizationsUpdateInstance(id, appEventLocalizationUpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appEventLocalizationsUpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param appEventLocalizationUpdateRequest AppEventLocalization representation
     */
    public appEventLocalizationsUpdateInstance(id: string, appEventLocalizationUpdateRequest: AppEventLocalizationUpdateRequest, _options?: Configuration): Observable<AppEventLocalizationResponse> {
        return this.appEventLocalizationsUpdateInstanceWithHttpInfo(id, appEventLocalizationUpdateRequest, _options).pipe(map((apiResponse: HttpInfo<AppEventLocalizationResponse>) => apiResponse.data));
    }

}

import { AppEventScreenshotsApiRequestFactory, AppEventScreenshotsApiResponseProcessor} from "../apis/AppEventScreenshotsApi.ts";
export class ObservableAppEventScreenshotsApi {
    private requestFactory: AppEventScreenshotsApiRequestFactory;
    private responseProcessor: AppEventScreenshotsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: AppEventScreenshotsApiRequestFactory,
        responseProcessor?: AppEventScreenshotsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new AppEventScreenshotsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new AppEventScreenshotsApiResponseProcessor();
    }

    /**
     * @param appEventScreenshotCreateRequest AppEventScreenshot representation
     */
    public appEventScreenshotsCreateInstanceWithHttpInfo(appEventScreenshotCreateRequest: AppEventScreenshotCreateRequest, _options?: Configuration): Observable<HttpInfo<AppEventScreenshotResponse>> {
        const requestContextPromise = this.requestFactory.appEventScreenshotsCreateInstance(appEventScreenshotCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appEventScreenshotsCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param appEventScreenshotCreateRequest AppEventScreenshot representation
     */
    public appEventScreenshotsCreateInstance(appEventScreenshotCreateRequest: AppEventScreenshotCreateRequest, _options?: Configuration): Observable<AppEventScreenshotResponse> {
        return this.appEventScreenshotsCreateInstanceWithHttpInfo(appEventScreenshotCreateRequest, _options).pipe(map((apiResponse: HttpInfo<AppEventScreenshotResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public appEventScreenshotsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.appEventScreenshotsDeleteInstance(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appEventScreenshotsDeleteInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public appEventScreenshotsDeleteInstance(id: string, _options?: Configuration): Observable<void> {
        return this.appEventScreenshotsDeleteInstanceWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppEventScreenshots the fields to include for returned resources of type appEventScreenshots
     * @param include comma-separated list of relationships to include
     */
    public appEventScreenshotsGetInstanceWithHttpInfo(id: string, fieldsAppEventScreenshots?: Array<'appEventAssetType' | 'appEventLocalization' | 'assetDeliveryState' | 'assetToken' | 'fileName' | 'fileSize' | 'imageAsset' | 'uploadOperations' | 'uploaded'>, include?: Array<'appEventLocalization'>, _options?: Configuration): Observable<HttpInfo<AppEventScreenshotResponse>> {
        const requestContextPromise = this.requestFactory.appEventScreenshotsGetInstance(id, fieldsAppEventScreenshots, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appEventScreenshotsGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppEventScreenshots the fields to include for returned resources of type appEventScreenshots
     * @param include comma-separated list of relationships to include
     */
    public appEventScreenshotsGetInstance(id: string, fieldsAppEventScreenshots?: Array<'appEventAssetType' | 'appEventLocalization' | 'assetDeliveryState' | 'assetToken' | 'fileName' | 'fileSize' | 'imageAsset' | 'uploadOperations' | 'uploaded'>, include?: Array<'appEventLocalization'>, _options?: Configuration): Observable<AppEventScreenshotResponse> {
        return this.appEventScreenshotsGetInstanceWithHttpInfo(id, fieldsAppEventScreenshots, include, _options).pipe(map((apiResponse: HttpInfo<AppEventScreenshotResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param appEventScreenshotUpdateRequest AppEventScreenshot representation
     */
    public appEventScreenshotsUpdateInstanceWithHttpInfo(id: string, appEventScreenshotUpdateRequest: AppEventScreenshotUpdateRequest, _options?: Configuration): Observable<HttpInfo<AppEventScreenshotResponse>> {
        const requestContextPromise = this.requestFactory.appEventScreenshotsUpdateInstance(id, appEventScreenshotUpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appEventScreenshotsUpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param appEventScreenshotUpdateRequest AppEventScreenshot representation
     */
    public appEventScreenshotsUpdateInstance(id: string, appEventScreenshotUpdateRequest: AppEventScreenshotUpdateRequest, _options?: Configuration): Observable<AppEventScreenshotResponse> {
        return this.appEventScreenshotsUpdateInstanceWithHttpInfo(id, appEventScreenshotUpdateRequest, _options).pipe(map((apiResponse: HttpInfo<AppEventScreenshotResponse>) => apiResponse.data));
    }

}

import { AppEventVideoClipsApiRequestFactory, AppEventVideoClipsApiResponseProcessor} from "../apis/AppEventVideoClipsApi.ts";
export class ObservableAppEventVideoClipsApi {
    private requestFactory: AppEventVideoClipsApiRequestFactory;
    private responseProcessor: AppEventVideoClipsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: AppEventVideoClipsApiRequestFactory,
        responseProcessor?: AppEventVideoClipsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new AppEventVideoClipsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new AppEventVideoClipsApiResponseProcessor();
    }

    /**
     * @param appEventVideoClipCreateRequest AppEventVideoClip representation
     */
    public appEventVideoClipsCreateInstanceWithHttpInfo(appEventVideoClipCreateRequest: AppEventVideoClipCreateRequest, _options?: Configuration): Observable<HttpInfo<AppEventVideoClipResponse>> {
        const requestContextPromise = this.requestFactory.appEventVideoClipsCreateInstance(appEventVideoClipCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appEventVideoClipsCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param appEventVideoClipCreateRequest AppEventVideoClip representation
     */
    public appEventVideoClipsCreateInstance(appEventVideoClipCreateRequest: AppEventVideoClipCreateRequest, _options?: Configuration): Observable<AppEventVideoClipResponse> {
        return this.appEventVideoClipsCreateInstanceWithHttpInfo(appEventVideoClipCreateRequest, _options).pipe(map((apiResponse: HttpInfo<AppEventVideoClipResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public appEventVideoClipsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.appEventVideoClipsDeleteInstance(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appEventVideoClipsDeleteInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public appEventVideoClipsDeleteInstance(id: string, _options?: Configuration): Observable<void> {
        return this.appEventVideoClipsDeleteInstanceWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppEventVideoClips the fields to include for returned resources of type appEventVideoClips
     * @param include comma-separated list of relationships to include
     */
    public appEventVideoClipsGetInstanceWithHttpInfo(id: string, fieldsAppEventVideoClips?: Array<'appEventAssetType' | 'appEventLocalization' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'previewFrameTimeCode' | 'previewImage' | 'uploadOperations' | 'uploaded' | 'videoUrl'>, include?: Array<'appEventLocalization'>, _options?: Configuration): Observable<HttpInfo<AppEventVideoClipResponse>> {
        const requestContextPromise = this.requestFactory.appEventVideoClipsGetInstance(id, fieldsAppEventVideoClips, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appEventVideoClipsGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppEventVideoClips the fields to include for returned resources of type appEventVideoClips
     * @param include comma-separated list of relationships to include
     */
    public appEventVideoClipsGetInstance(id: string, fieldsAppEventVideoClips?: Array<'appEventAssetType' | 'appEventLocalization' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'previewFrameTimeCode' | 'previewImage' | 'uploadOperations' | 'uploaded' | 'videoUrl'>, include?: Array<'appEventLocalization'>, _options?: Configuration): Observable<AppEventVideoClipResponse> {
        return this.appEventVideoClipsGetInstanceWithHttpInfo(id, fieldsAppEventVideoClips, include, _options).pipe(map((apiResponse: HttpInfo<AppEventVideoClipResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param appEventVideoClipUpdateRequest AppEventVideoClip representation
     */
    public appEventVideoClipsUpdateInstanceWithHttpInfo(id: string, appEventVideoClipUpdateRequest: AppEventVideoClipUpdateRequest, _options?: Configuration): Observable<HttpInfo<AppEventVideoClipResponse>> {
        const requestContextPromise = this.requestFactory.appEventVideoClipsUpdateInstance(id, appEventVideoClipUpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appEventVideoClipsUpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param appEventVideoClipUpdateRequest AppEventVideoClip representation
     */
    public appEventVideoClipsUpdateInstance(id: string, appEventVideoClipUpdateRequest: AppEventVideoClipUpdateRequest, _options?: Configuration): Observable<AppEventVideoClipResponse> {
        return this.appEventVideoClipsUpdateInstanceWithHttpInfo(id, appEventVideoClipUpdateRequest, _options).pipe(map((apiResponse: HttpInfo<AppEventVideoClipResponse>) => apiResponse.data));
    }

}

import { AppEventsApiRequestFactory, AppEventsApiResponseProcessor} from "../apis/AppEventsApi.ts";
export class ObservableAppEventsApi {
    private requestFactory: AppEventsApiRequestFactory;
    private responseProcessor: AppEventsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: AppEventsApiRequestFactory,
        responseProcessor?: AppEventsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new AppEventsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new AppEventsApiResponseProcessor();
    }

    /**
     * @param appEventCreateRequest AppEvent representation
     */
    public appEventsCreateInstanceWithHttpInfo(appEventCreateRequest: AppEventCreateRequest, _options?: Configuration): Observable<HttpInfo<AppEventResponse>> {
        const requestContextPromise = this.requestFactory.appEventsCreateInstance(appEventCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appEventsCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param appEventCreateRequest AppEvent representation
     */
    public appEventsCreateInstance(appEventCreateRequest: AppEventCreateRequest, _options?: Configuration): Observable<AppEventResponse> {
        return this.appEventsCreateInstanceWithHttpInfo(appEventCreateRequest, _options).pipe(map((apiResponse: HttpInfo<AppEventResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public appEventsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.appEventsDeleteInstance(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appEventsDeleteInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public appEventsDeleteInstance(id: string, _options?: Configuration): Observable<void> {
        return this.appEventsDeleteInstanceWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppEvents the fields to include for returned resources of type appEvents
     * @param include comma-separated list of relationships to include
     * @param fieldsAppEventLocalizations the fields to include for returned resources of type appEventLocalizations
     * @param limitLocalizations maximum number of related localizations returned (when they are included)
     */
    public appEventsGetInstanceWithHttpInfo(id: string, fieldsAppEvents?: Array<'app' | 'archivedTerritorySchedules' | 'badge' | 'deepLink' | 'eventState' | 'localizations' | 'primaryLocale' | 'priority' | 'purchaseRequirement' | 'purpose' | 'referenceName' | 'territorySchedules'>, include?: Array<'localizations'>, fieldsAppEventLocalizations?: Array<'appEvent' | 'appEventScreenshots' | 'appEventVideoClips' | 'locale' | 'longDescription' | 'name' | 'shortDescription'>, limitLocalizations?: number, _options?: Configuration): Observable<HttpInfo<AppEventResponse>> {
        const requestContextPromise = this.requestFactory.appEventsGetInstance(id, fieldsAppEvents, include, fieldsAppEventLocalizations, limitLocalizations, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appEventsGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppEvents the fields to include for returned resources of type appEvents
     * @param include comma-separated list of relationships to include
     * @param fieldsAppEventLocalizations the fields to include for returned resources of type appEventLocalizations
     * @param limitLocalizations maximum number of related localizations returned (when they are included)
     */
    public appEventsGetInstance(id: string, fieldsAppEvents?: Array<'app' | 'archivedTerritorySchedules' | 'badge' | 'deepLink' | 'eventState' | 'localizations' | 'primaryLocale' | 'priority' | 'purchaseRequirement' | 'purpose' | 'referenceName' | 'territorySchedules'>, include?: Array<'localizations'>, fieldsAppEventLocalizations?: Array<'appEvent' | 'appEventScreenshots' | 'appEventVideoClips' | 'locale' | 'longDescription' | 'name' | 'shortDescription'>, limitLocalizations?: number, _options?: Configuration): Observable<AppEventResponse> {
        return this.appEventsGetInstanceWithHttpInfo(id, fieldsAppEvents, include, fieldsAppEventLocalizations, limitLocalizations, _options).pipe(map((apiResponse: HttpInfo<AppEventResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppEventScreenshots the fields to include for returned resources of type appEventScreenshots
     * @param fieldsAppEventVideoClips the fields to include for returned resources of type appEventVideoClips
     * @param fieldsAppEventLocalizations the fields to include for returned resources of type appEventLocalizations
     * @param fieldsAppEvents the fields to include for returned resources of type appEvents
     * @param limit maximum resources per page
     * @param limitAppEventScreenshots maximum number of related appEventScreenshots returned (when they are included)
     * @param limitAppEventVideoClips maximum number of related appEventVideoClips returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appEventsLocalizationsGetToManyRelatedWithHttpInfo(id: string, fieldsAppEventScreenshots?: Array<'appEventAssetType' | 'appEventLocalization' | 'assetDeliveryState' | 'assetToken' | 'fileName' | 'fileSize' | 'imageAsset' | 'uploadOperations' | 'uploaded'>, fieldsAppEventVideoClips?: Array<'appEventAssetType' | 'appEventLocalization' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'previewFrameTimeCode' | 'previewImage' | 'uploadOperations' | 'uploaded' | 'videoUrl'>, fieldsAppEventLocalizations?: Array<'appEvent' | 'appEventScreenshots' | 'appEventVideoClips' | 'locale' | 'longDescription' | 'name' | 'shortDescription'>, fieldsAppEvents?: Array<'app' | 'archivedTerritorySchedules' | 'badge' | 'deepLink' | 'eventState' | 'localizations' | 'primaryLocale' | 'priority' | 'purchaseRequirement' | 'purpose' | 'referenceName' | 'territorySchedules'>, limit?: number, limitAppEventScreenshots?: number, limitAppEventVideoClips?: number, include?: Array<'appEvent' | 'appEventScreenshots' | 'appEventVideoClips'>, _options?: Configuration): Observable<HttpInfo<AppEventLocalizationsResponse>> {
        const requestContextPromise = this.requestFactory.appEventsLocalizationsGetToManyRelated(id, fieldsAppEventScreenshots, fieldsAppEventVideoClips, fieldsAppEventLocalizations, fieldsAppEvents, limit, limitAppEventScreenshots, limitAppEventVideoClips, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appEventsLocalizationsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppEventScreenshots the fields to include for returned resources of type appEventScreenshots
     * @param fieldsAppEventVideoClips the fields to include for returned resources of type appEventVideoClips
     * @param fieldsAppEventLocalizations the fields to include for returned resources of type appEventLocalizations
     * @param fieldsAppEvents the fields to include for returned resources of type appEvents
     * @param limit maximum resources per page
     * @param limitAppEventScreenshots maximum number of related appEventScreenshots returned (when they are included)
     * @param limitAppEventVideoClips maximum number of related appEventVideoClips returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appEventsLocalizationsGetToManyRelated(id: string, fieldsAppEventScreenshots?: Array<'appEventAssetType' | 'appEventLocalization' | 'assetDeliveryState' | 'assetToken' | 'fileName' | 'fileSize' | 'imageAsset' | 'uploadOperations' | 'uploaded'>, fieldsAppEventVideoClips?: Array<'appEventAssetType' | 'appEventLocalization' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'previewFrameTimeCode' | 'previewImage' | 'uploadOperations' | 'uploaded' | 'videoUrl'>, fieldsAppEventLocalizations?: Array<'appEvent' | 'appEventScreenshots' | 'appEventVideoClips' | 'locale' | 'longDescription' | 'name' | 'shortDescription'>, fieldsAppEvents?: Array<'app' | 'archivedTerritorySchedules' | 'badge' | 'deepLink' | 'eventState' | 'localizations' | 'primaryLocale' | 'priority' | 'purchaseRequirement' | 'purpose' | 'referenceName' | 'territorySchedules'>, limit?: number, limitAppEventScreenshots?: number, limitAppEventVideoClips?: number, include?: Array<'appEvent' | 'appEventScreenshots' | 'appEventVideoClips'>, _options?: Configuration): Observable<AppEventLocalizationsResponse> {
        return this.appEventsLocalizationsGetToManyRelatedWithHttpInfo(id, fieldsAppEventScreenshots, fieldsAppEventVideoClips, fieldsAppEventLocalizations, fieldsAppEvents, limit, limitAppEventScreenshots, limitAppEventVideoClips, include, _options).pipe(map((apiResponse: HttpInfo<AppEventLocalizationsResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param appEventUpdateRequest AppEvent representation
     */
    public appEventsUpdateInstanceWithHttpInfo(id: string, appEventUpdateRequest: AppEventUpdateRequest, _options?: Configuration): Observable<HttpInfo<AppEventResponse>> {
        const requestContextPromise = this.requestFactory.appEventsUpdateInstance(id, appEventUpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appEventsUpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param appEventUpdateRequest AppEvent representation
     */
    public appEventsUpdateInstance(id: string, appEventUpdateRequest: AppEventUpdateRequest, _options?: Configuration): Observable<AppEventResponse> {
        return this.appEventsUpdateInstanceWithHttpInfo(id, appEventUpdateRequest, _options).pipe(map((apiResponse: HttpInfo<AppEventResponse>) => apiResponse.data));
    }

}

import { AppInfoLocalizationsApiRequestFactory, AppInfoLocalizationsApiResponseProcessor} from "../apis/AppInfoLocalizationsApi.ts";
export class ObservableAppInfoLocalizationsApi {
    private requestFactory: AppInfoLocalizationsApiRequestFactory;
    private responseProcessor: AppInfoLocalizationsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: AppInfoLocalizationsApiRequestFactory,
        responseProcessor?: AppInfoLocalizationsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new AppInfoLocalizationsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new AppInfoLocalizationsApiResponseProcessor();
    }

    /**
     * @param appInfoLocalizationCreateRequest AppInfoLocalization representation
     */
    public appInfoLocalizationsCreateInstanceWithHttpInfo(appInfoLocalizationCreateRequest: AppInfoLocalizationCreateRequest, _options?: Configuration): Observable<HttpInfo<AppInfoLocalizationResponse>> {
        const requestContextPromise = this.requestFactory.appInfoLocalizationsCreateInstance(appInfoLocalizationCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appInfoLocalizationsCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param appInfoLocalizationCreateRequest AppInfoLocalization representation
     */
    public appInfoLocalizationsCreateInstance(appInfoLocalizationCreateRequest: AppInfoLocalizationCreateRequest, _options?: Configuration): Observable<AppInfoLocalizationResponse> {
        return this.appInfoLocalizationsCreateInstanceWithHttpInfo(appInfoLocalizationCreateRequest, _options).pipe(map((apiResponse: HttpInfo<AppInfoLocalizationResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public appInfoLocalizationsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.appInfoLocalizationsDeleteInstance(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appInfoLocalizationsDeleteInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public appInfoLocalizationsDeleteInstance(id: string, _options?: Configuration): Observable<void> {
        return this.appInfoLocalizationsDeleteInstanceWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppInfoLocalizations the fields to include for returned resources of type appInfoLocalizations
     * @param include comma-separated list of relationships to include
     */
    public appInfoLocalizationsGetInstanceWithHttpInfo(id: string, fieldsAppInfoLocalizations?: Array<'appInfo' | 'locale' | 'name' | 'privacyChoicesUrl' | 'privacyPolicyText' | 'privacyPolicyUrl' | 'subtitle'>, include?: Array<'appInfo'>, _options?: Configuration): Observable<HttpInfo<AppInfoLocalizationResponse>> {
        const requestContextPromise = this.requestFactory.appInfoLocalizationsGetInstance(id, fieldsAppInfoLocalizations, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appInfoLocalizationsGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppInfoLocalizations the fields to include for returned resources of type appInfoLocalizations
     * @param include comma-separated list of relationships to include
     */
    public appInfoLocalizationsGetInstance(id: string, fieldsAppInfoLocalizations?: Array<'appInfo' | 'locale' | 'name' | 'privacyChoicesUrl' | 'privacyPolicyText' | 'privacyPolicyUrl' | 'subtitle'>, include?: Array<'appInfo'>, _options?: Configuration): Observable<AppInfoLocalizationResponse> {
        return this.appInfoLocalizationsGetInstanceWithHttpInfo(id, fieldsAppInfoLocalizations, include, _options).pipe(map((apiResponse: HttpInfo<AppInfoLocalizationResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param appInfoLocalizationUpdateRequest AppInfoLocalization representation
     */
    public appInfoLocalizationsUpdateInstanceWithHttpInfo(id: string, appInfoLocalizationUpdateRequest: AppInfoLocalizationUpdateRequest, _options?: Configuration): Observable<HttpInfo<AppInfoLocalizationResponse>> {
        const requestContextPromise = this.requestFactory.appInfoLocalizationsUpdateInstance(id, appInfoLocalizationUpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appInfoLocalizationsUpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param appInfoLocalizationUpdateRequest AppInfoLocalization representation
     */
    public appInfoLocalizationsUpdateInstance(id: string, appInfoLocalizationUpdateRequest: AppInfoLocalizationUpdateRequest, _options?: Configuration): Observable<AppInfoLocalizationResponse> {
        return this.appInfoLocalizationsUpdateInstanceWithHttpInfo(id, appInfoLocalizationUpdateRequest, _options).pipe(map((apiResponse: HttpInfo<AppInfoLocalizationResponse>) => apiResponse.data));
    }

}

import { AppInfosApiRequestFactory, AppInfosApiResponseProcessor} from "../apis/AppInfosApi.ts";
export class ObservableAppInfosApi {
    private requestFactory: AppInfosApiRequestFactory;
    private responseProcessor: AppInfosApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: AppInfosApiRequestFactory,
        responseProcessor?: AppInfosApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new AppInfosApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new AppInfosApiResponseProcessor();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAgeRatingDeclarations the fields to include for returned resources of type ageRatingDeclarations
     */
    public appInfosAgeRatingDeclarationGetToOneRelatedWithHttpInfo(id: string, fieldsAgeRatingDeclarations?: Array<'ageRatingOverride' | 'alcoholTobaccoOrDrugUseOrReferences' | 'contests' | 'gambling' | 'gamblingAndContests' | 'gamblingSimulated' | 'horrorOrFearThemes' | 'kidsAgeBand' | 'matureOrSuggestiveThemes' | 'medicalOrTreatmentInformation' | 'profanityOrCrudeHumor' | 'seventeenPlus' | 'sexualContentGraphicAndNudity' | 'sexualContentOrNudity' | 'unrestrictedWebAccess' | 'violenceCartoonOrFantasy' | 'violenceRealistic' | 'violenceRealisticProlongedGraphicOrSadistic'>, _options?: Configuration): Observable<HttpInfo<AgeRatingDeclarationResponse>> {
        const requestContextPromise = this.requestFactory.appInfosAgeRatingDeclarationGetToOneRelated(id, fieldsAgeRatingDeclarations, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appInfosAgeRatingDeclarationGetToOneRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAgeRatingDeclarations the fields to include for returned resources of type ageRatingDeclarations
     */
    public appInfosAgeRatingDeclarationGetToOneRelated(id: string, fieldsAgeRatingDeclarations?: Array<'ageRatingOverride' | 'alcoholTobaccoOrDrugUseOrReferences' | 'contests' | 'gambling' | 'gamblingAndContests' | 'gamblingSimulated' | 'horrorOrFearThemes' | 'kidsAgeBand' | 'matureOrSuggestiveThemes' | 'medicalOrTreatmentInformation' | 'profanityOrCrudeHumor' | 'seventeenPlus' | 'sexualContentGraphicAndNudity' | 'sexualContentOrNudity' | 'unrestrictedWebAccess' | 'violenceCartoonOrFantasy' | 'violenceRealistic' | 'violenceRealisticProlongedGraphicOrSadistic'>, _options?: Configuration): Observable<AgeRatingDeclarationResponse> {
        return this.appInfosAgeRatingDeclarationGetToOneRelatedWithHttpInfo(id, fieldsAgeRatingDeclarations, _options).pipe(map((apiResponse: HttpInfo<AgeRatingDeclarationResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param filterLocale filter by attribute \&#39;locale\&#39;
     * @param fieldsAppInfos the fields to include for returned resources of type appInfos
     * @param fieldsAppInfoLocalizations the fields to include for returned resources of type appInfoLocalizations
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public appInfosAppInfoLocalizationsGetToManyRelatedWithHttpInfo(id: string, filterLocale?: Array<string>, fieldsAppInfos?: Array<'ageRatingDeclaration' | 'app' | 'appInfoLocalizations' | 'appStoreAgeRating' | 'appStoreState' | 'brazilAgeRating' | 'brazilAgeRatingV2' | 'kidsAgeBand' | 'primaryCategory' | 'primarySubcategoryOne' | 'primarySubcategoryTwo' | 'secondaryCategory' | 'secondarySubcategoryOne' | 'secondarySubcategoryTwo' | 'state'>, fieldsAppInfoLocalizations?: Array<'appInfo' | 'locale' | 'name' | 'privacyChoicesUrl' | 'privacyPolicyText' | 'privacyPolicyUrl' | 'subtitle'>, limit?: number, include?: Array<'appInfo'>, _options?: Configuration): Observable<HttpInfo<AppInfoLocalizationsResponse>> {
        const requestContextPromise = this.requestFactory.appInfosAppInfoLocalizationsGetToManyRelated(id, filterLocale, fieldsAppInfos, fieldsAppInfoLocalizations, limit, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appInfosAppInfoLocalizationsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param filterLocale filter by attribute \&#39;locale\&#39;
     * @param fieldsAppInfos the fields to include for returned resources of type appInfos
     * @param fieldsAppInfoLocalizations the fields to include for returned resources of type appInfoLocalizations
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public appInfosAppInfoLocalizationsGetToManyRelated(id: string, filterLocale?: Array<string>, fieldsAppInfos?: Array<'ageRatingDeclaration' | 'app' | 'appInfoLocalizations' | 'appStoreAgeRating' | 'appStoreState' | 'brazilAgeRating' | 'brazilAgeRatingV2' | 'kidsAgeBand' | 'primaryCategory' | 'primarySubcategoryOne' | 'primarySubcategoryTwo' | 'secondaryCategory' | 'secondarySubcategoryOne' | 'secondarySubcategoryTwo' | 'state'>, fieldsAppInfoLocalizations?: Array<'appInfo' | 'locale' | 'name' | 'privacyChoicesUrl' | 'privacyPolicyText' | 'privacyPolicyUrl' | 'subtitle'>, limit?: number, include?: Array<'appInfo'>, _options?: Configuration): Observable<AppInfoLocalizationsResponse> {
        return this.appInfosAppInfoLocalizationsGetToManyRelatedWithHttpInfo(id, filterLocale, fieldsAppInfos, fieldsAppInfoLocalizations, limit, include, _options).pipe(map((apiResponse: HttpInfo<AppInfoLocalizationsResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppInfos the fields to include for returned resources of type appInfos
     * @param include comma-separated list of relationships to include
     * @param fieldsAgeRatingDeclarations the fields to include for returned resources of type ageRatingDeclarations
     * @param fieldsAppInfoLocalizations the fields to include for returned resources of type appInfoLocalizations
     * @param fieldsAppCategories the fields to include for returned resources of type appCategories
     * @param limitAppInfoLocalizations maximum number of related appInfoLocalizations returned (when they are included)
     */
    public appInfosGetInstanceWithHttpInfo(id: string, fieldsAppInfos?: Array<'ageRatingDeclaration' | 'app' | 'appInfoLocalizations' | 'appStoreAgeRating' | 'appStoreState' | 'brazilAgeRating' | 'brazilAgeRatingV2' | 'kidsAgeBand' | 'primaryCategory' | 'primarySubcategoryOne' | 'primarySubcategoryTwo' | 'secondaryCategory' | 'secondarySubcategoryOne' | 'secondarySubcategoryTwo' | 'state'>, include?: Array<'ageRatingDeclaration' | 'app' | 'appInfoLocalizations' | 'primaryCategory' | 'primarySubcategoryOne' | 'primarySubcategoryTwo' | 'secondaryCategory' | 'secondarySubcategoryOne' | 'secondarySubcategoryTwo'>, fieldsAgeRatingDeclarations?: Array<'ageRatingOverride' | 'alcoholTobaccoOrDrugUseOrReferences' | 'contests' | 'gambling' | 'gamblingAndContests' | 'gamblingSimulated' | 'horrorOrFearThemes' | 'kidsAgeBand' | 'matureOrSuggestiveThemes' | 'medicalOrTreatmentInformation' | 'profanityOrCrudeHumor' | 'seventeenPlus' | 'sexualContentGraphicAndNudity' | 'sexualContentOrNudity' | 'unrestrictedWebAccess' | 'violenceCartoonOrFantasy' | 'violenceRealistic' | 'violenceRealisticProlongedGraphicOrSadistic'>, fieldsAppInfoLocalizations?: Array<'appInfo' | 'locale' | 'name' | 'privacyChoicesUrl' | 'privacyPolicyText' | 'privacyPolicyUrl' | 'subtitle'>, fieldsAppCategories?: Array<'parent' | 'platforms' | 'subcategories'>, limitAppInfoLocalizations?: number, _options?: Configuration): Observable<HttpInfo<AppInfoResponse>> {
        const requestContextPromise = this.requestFactory.appInfosGetInstance(id, fieldsAppInfos, include, fieldsAgeRatingDeclarations, fieldsAppInfoLocalizations, fieldsAppCategories, limitAppInfoLocalizations, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appInfosGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppInfos the fields to include for returned resources of type appInfos
     * @param include comma-separated list of relationships to include
     * @param fieldsAgeRatingDeclarations the fields to include for returned resources of type ageRatingDeclarations
     * @param fieldsAppInfoLocalizations the fields to include for returned resources of type appInfoLocalizations
     * @param fieldsAppCategories the fields to include for returned resources of type appCategories
     * @param limitAppInfoLocalizations maximum number of related appInfoLocalizations returned (when they are included)
     */
    public appInfosGetInstance(id: string, fieldsAppInfos?: Array<'ageRatingDeclaration' | 'app' | 'appInfoLocalizations' | 'appStoreAgeRating' | 'appStoreState' | 'brazilAgeRating' | 'brazilAgeRatingV2' | 'kidsAgeBand' | 'primaryCategory' | 'primarySubcategoryOne' | 'primarySubcategoryTwo' | 'secondaryCategory' | 'secondarySubcategoryOne' | 'secondarySubcategoryTwo' | 'state'>, include?: Array<'ageRatingDeclaration' | 'app' | 'appInfoLocalizations' | 'primaryCategory' | 'primarySubcategoryOne' | 'primarySubcategoryTwo' | 'secondaryCategory' | 'secondarySubcategoryOne' | 'secondarySubcategoryTwo'>, fieldsAgeRatingDeclarations?: Array<'ageRatingOverride' | 'alcoholTobaccoOrDrugUseOrReferences' | 'contests' | 'gambling' | 'gamblingAndContests' | 'gamblingSimulated' | 'horrorOrFearThemes' | 'kidsAgeBand' | 'matureOrSuggestiveThemes' | 'medicalOrTreatmentInformation' | 'profanityOrCrudeHumor' | 'seventeenPlus' | 'sexualContentGraphicAndNudity' | 'sexualContentOrNudity' | 'unrestrictedWebAccess' | 'violenceCartoonOrFantasy' | 'violenceRealistic' | 'violenceRealisticProlongedGraphicOrSadistic'>, fieldsAppInfoLocalizations?: Array<'appInfo' | 'locale' | 'name' | 'privacyChoicesUrl' | 'privacyPolicyText' | 'privacyPolicyUrl' | 'subtitle'>, fieldsAppCategories?: Array<'parent' | 'platforms' | 'subcategories'>, limitAppInfoLocalizations?: number, _options?: Configuration): Observable<AppInfoResponse> {
        return this.appInfosGetInstanceWithHttpInfo(id, fieldsAppInfos, include, fieldsAgeRatingDeclarations, fieldsAppInfoLocalizations, fieldsAppCategories, limitAppInfoLocalizations, _options).pipe(map((apiResponse: HttpInfo<AppInfoResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppCategories the fields to include for returned resources of type appCategories
     * @param limitSubcategories maximum number of related subcategories returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appInfosPrimaryCategoryGetToOneRelatedWithHttpInfo(id: string, fieldsAppCategories?: Array<'parent' | 'platforms' | 'subcategories'>, limitSubcategories?: number, include?: Array<'parent' | 'subcategories'>, _options?: Configuration): Observable<HttpInfo<AppCategoryResponse>> {
        const requestContextPromise = this.requestFactory.appInfosPrimaryCategoryGetToOneRelated(id, fieldsAppCategories, limitSubcategories, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appInfosPrimaryCategoryGetToOneRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppCategories the fields to include for returned resources of type appCategories
     * @param limitSubcategories maximum number of related subcategories returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appInfosPrimaryCategoryGetToOneRelated(id: string, fieldsAppCategories?: Array<'parent' | 'platforms' | 'subcategories'>, limitSubcategories?: number, include?: Array<'parent' | 'subcategories'>, _options?: Configuration): Observable<AppCategoryResponse> {
        return this.appInfosPrimaryCategoryGetToOneRelatedWithHttpInfo(id, fieldsAppCategories, limitSubcategories, include, _options).pipe(map((apiResponse: HttpInfo<AppCategoryResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppCategories the fields to include for returned resources of type appCategories
     * @param limitSubcategories maximum number of related subcategories returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appInfosPrimarySubcategoryOneGetToOneRelatedWithHttpInfo(id: string, fieldsAppCategories?: Array<'parent' | 'platforms' | 'subcategories'>, limitSubcategories?: number, include?: Array<'parent' | 'subcategories'>, _options?: Configuration): Observable<HttpInfo<AppCategoryResponse>> {
        const requestContextPromise = this.requestFactory.appInfosPrimarySubcategoryOneGetToOneRelated(id, fieldsAppCategories, limitSubcategories, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appInfosPrimarySubcategoryOneGetToOneRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppCategories the fields to include for returned resources of type appCategories
     * @param limitSubcategories maximum number of related subcategories returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appInfosPrimarySubcategoryOneGetToOneRelated(id: string, fieldsAppCategories?: Array<'parent' | 'platforms' | 'subcategories'>, limitSubcategories?: number, include?: Array<'parent' | 'subcategories'>, _options?: Configuration): Observable<AppCategoryResponse> {
        return this.appInfosPrimarySubcategoryOneGetToOneRelatedWithHttpInfo(id, fieldsAppCategories, limitSubcategories, include, _options).pipe(map((apiResponse: HttpInfo<AppCategoryResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppCategories the fields to include for returned resources of type appCategories
     * @param limitSubcategories maximum number of related subcategories returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appInfosPrimarySubcategoryTwoGetToOneRelatedWithHttpInfo(id: string, fieldsAppCategories?: Array<'parent' | 'platforms' | 'subcategories'>, limitSubcategories?: number, include?: Array<'parent' | 'subcategories'>, _options?: Configuration): Observable<HttpInfo<AppCategoryResponse>> {
        const requestContextPromise = this.requestFactory.appInfosPrimarySubcategoryTwoGetToOneRelated(id, fieldsAppCategories, limitSubcategories, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appInfosPrimarySubcategoryTwoGetToOneRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppCategories the fields to include for returned resources of type appCategories
     * @param limitSubcategories maximum number of related subcategories returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appInfosPrimarySubcategoryTwoGetToOneRelated(id: string, fieldsAppCategories?: Array<'parent' | 'platforms' | 'subcategories'>, limitSubcategories?: number, include?: Array<'parent' | 'subcategories'>, _options?: Configuration): Observable<AppCategoryResponse> {
        return this.appInfosPrimarySubcategoryTwoGetToOneRelatedWithHttpInfo(id, fieldsAppCategories, limitSubcategories, include, _options).pipe(map((apiResponse: HttpInfo<AppCategoryResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppCategories the fields to include for returned resources of type appCategories
     * @param limitSubcategories maximum number of related subcategories returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appInfosSecondaryCategoryGetToOneRelatedWithHttpInfo(id: string, fieldsAppCategories?: Array<'parent' | 'platforms' | 'subcategories'>, limitSubcategories?: number, include?: Array<'parent' | 'subcategories'>, _options?: Configuration): Observable<HttpInfo<AppCategoryResponse>> {
        const requestContextPromise = this.requestFactory.appInfosSecondaryCategoryGetToOneRelated(id, fieldsAppCategories, limitSubcategories, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appInfosSecondaryCategoryGetToOneRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppCategories the fields to include for returned resources of type appCategories
     * @param limitSubcategories maximum number of related subcategories returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appInfosSecondaryCategoryGetToOneRelated(id: string, fieldsAppCategories?: Array<'parent' | 'platforms' | 'subcategories'>, limitSubcategories?: number, include?: Array<'parent' | 'subcategories'>, _options?: Configuration): Observable<AppCategoryResponse> {
        return this.appInfosSecondaryCategoryGetToOneRelatedWithHttpInfo(id, fieldsAppCategories, limitSubcategories, include, _options).pipe(map((apiResponse: HttpInfo<AppCategoryResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppCategories the fields to include for returned resources of type appCategories
     * @param limitSubcategories maximum number of related subcategories returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appInfosSecondarySubcategoryOneGetToOneRelatedWithHttpInfo(id: string, fieldsAppCategories?: Array<'parent' | 'platforms' | 'subcategories'>, limitSubcategories?: number, include?: Array<'parent' | 'subcategories'>, _options?: Configuration): Observable<HttpInfo<AppCategoryResponse>> {
        const requestContextPromise = this.requestFactory.appInfosSecondarySubcategoryOneGetToOneRelated(id, fieldsAppCategories, limitSubcategories, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appInfosSecondarySubcategoryOneGetToOneRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppCategories the fields to include for returned resources of type appCategories
     * @param limitSubcategories maximum number of related subcategories returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appInfosSecondarySubcategoryOneGetToOneRelated(id: string, fieldsAppCategories?: Array<'parent' | 'platforms' | 'subcategories'>, limitSubcategories?: number, include?: Array<'parent' | 'subcategories'>, _options?: Configuration): Observable<AppCategoryResponse> {
        return this.appInfosSecondarySubcategoryOneGetToOneRelatedWithHttpInfo(id, fieldsAppCategories, limitSubcategories, include, _options).pipe(map((apiResponse: HttpInfo<AppCategoryResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppCategories the fields to include for returned resources of type appCategories
     * @param limitSubcategories maximum number of related subcategories returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appInfosSecondarySubcategoryTwoGetToOneRelatedWithHttpInfo(id: string, fieldsAppCategories?: Array<'parent' | 'platforms' | 'subcategories'>, limitSubcategories?: number, include?: Array<'parent' | 'subcategories'>, _options?: Configuration): Observable<HttpInfo<AppCategoryResponse>> {
        const requestContextPromise = this.requestFactory.appInfosSecondarySubcategoryTwoGetToOneRelated(id, fieldsAppCategories, limitSubcategories, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appInfosSecondarySubcategoryTwoGetToOneRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppCategories the fields to include for returned resources of type appCategories
     * @param limitSubcategories maximum number of related subcategories returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appInfosSecondarySubcategoryTwoGetToOneRelated(id: string, fieldsAppCategories?: Array<'parent' | 'platforms' | 'subcategories'>, limitSubcategories?: number, include?: Array<'parent' | 'subcategories'>, _options?: Configuration): Observable<AppCategoryResponse> {
        return this.appInfosSecondarySubcategoryTwoGetToOneRelatedWithHttpInfo(id, fieldsAppCategories, limitSubcategories, include, _options).pipe(map((apiResponse: HttpInfo<AppCategoryResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param appInfoUpdateRequest AppInfo representation
     */
    public appInfosUpdateInstanceWithHttpInfo(id: string, appInfoUpdateRequest: AppInfoUpdateRequest, _options?: Configuration): Observable<HttpInfo<AppInfoResponse>> {
        const requestContextPromise = this.requestFactory.appInfosUpdateInstance(id, appInfoUpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appInfosUpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param appInfoUpdateRequest AppInfo representation
     */
    public appInfosUpdateInstance(id: string, appInfoUpdateRequest: AppInfoUpdateRequest, _options?: Configuration): Observable<AppInfoResponse> {
        return this.appInfosUpdateInstanceWithHttpInfo(id, appInfoUpdateRequest, _options).pipe(map((apiResponse: HttpInfo<AppInfoResponse>) => apiResponse.data));
    }

}

import { AppPreOrdersApiRequestFactory, AppPreOrdersApiResponseProcessor} from "../apis/AppPreOrdersApi.ts";
export class ObservableAppPreOrdersApi {
    private requestFactory: AppPreOrdersApiRequestFactory;
    private responseProcessor: AppPreOrdersApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: AppPreOrdersApiRequestFactory,
        responseProcessor?: AppPreOrdersApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new AppPreOrdersApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new AppPreOrdersApiResponseProcessor();
    }

    /**
     * @param appPreOrderCreateRequest AppPreOrder representation
     */
    public appPreOrdersCreateInstanceWithHttpInfo(appPreOrderCreateRequest: AppPreOrderCreateRequest, _options?: Configuration): Observable<HttpInfo<AppPreOrderResponse>> {
        const requestContextPromise = this.requestFactory.appPreOrdersCreateInstance(appPreOrderCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appPreOrdersCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param appPreOrderCreateRequest AppPreOrder representation
     */
    public appPreOrdersCreateInstance(appPreOrderCreateRequest: AppPreOrderCreateRequest, _options?: Configuration): Observable<AppPreOrderResponse> {
        return this.appPreOrdersCreateInstanceWithHttpInfo(appPreOrderCreateRequest, _options).pipe(map((apiResponse: HttpInfo<AppPreOrderResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public appPreOrdersDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.appPreOrdersDeleteInstance(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appPreOrdersDeleteInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public appPreOrdersDeleteInstance(id: string, _options?: Configuration): Observable<void> {
        return this.appPreOrdersDeleteInstanceWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppPreOrders the fields to include for returned resources of type appPreOrders
     * @param include comma-separated list of relationships to include
     */
    public appPreOrdersGetInstanceWithHttpInfo(id: string, fieldsAppPreOrders?: Array<'app' | 'appReleaseDate' | 'preOrderAvailableDate'>, include?: Array<'app'>, _options?: Configuration): Observable<HttpInfo<AppPreOrderResponse>> {
        const requestContextPromise = this.requestFactory.appPreOrdersGetInstance(id, fieldsAppPreOrders, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appPreOrdersGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppPreOrders the fields to include for returned resources of type appPreOrders
     * @param include comma-separated list of relationships to include
     */
    public appPreOrdersGetInstance(id: string, fieldsAppPreOrders?: Array<'app' | 'appReleaseDate' | 'preOrderAvailableDate'>, include?: Array<'app'>, _options?: Configuration): Observable<AppPreOrderResponse> {
        return this.appPreOrdersGetInstanceWithHttpInfo(id, fieldsAppPreOrders, include, _options).pipe(map((apiResponse: HttpInfo<AppPreOrderResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param appPreOrderUpdateRequest AppPreOrder representation
     */
    public appPreOrdersUpdateInstanceWithHttpInfo(id: string, appPreOrderUpdateRequest: AppPreOrderUpdateRequest, _options?: Configuration): Observable<HttpInfo<AppPreOrderResponse>> {
        const requestContextPromise = this.requestFactory.appPreOrdersUpdateInstance(id, appPreOrderUpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appPreOrdersUpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param appPreOrderUpdateRequest AppPreOrder representation
     */
    public appPreOrdersUpdateInstance(id: string, appPreOrderUpdateRequest: AppPreOrderUpdateRequest, _options?: Configuration): Observable<AppPreOrderResponse> {
        return this.appPreOrdersUpdateInstanceWithHttpInfo(id, appPreOrderUpdateRequest, _options).pipe(map((apiResponse: HttpInfo<AppPreOrderResponse>) => apiResponse.data));
    }

}

import { AppPreviewSetsApiRequestFactory, AppPreviewSetsApiResponseProcessor} from "../apis/AppPreviewSetsApi.ts";
export class ObservableAppPreviewSetsApi {
    private requestFactory: AppPreviewSetsApiRequestFactory;
    private responseProcessor: AppPreviewSetsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: AppPreviewSetsApiRequestFactory,
        responseProcessor?: AppPreviewSetsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new AppPreviewSetsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new AppPreviewSetsApiResponseProcessor();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppPreviews the fields to include for returned resources of type appPreviews
     * @param fieldsAppPreviewSets the fields to include for returned resources of type appPreviewSets
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public appPreviewSetsAppPreviewsGetToManyRelatedWithHttpInfo(id: string, fieldsAppPreviews?: Array<'appPreviewSet' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'mimeType' | 'previewFrameTimeCode' | 'previewImage' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded' | 'videoUrl'>, fieldsAppPreviewSets?: Array<'appCustomProductPageLocalization' | 'appPreviews' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'previewType'>, limit?: number, include?: Array<'appPreviewSet'>, _options?: Configuration): Observable<HttpInfo<AppPreviewsResponse>> {
        const requestContextPromise = this.requestFactory.appPreviewSetsAppPreviewsGetToManyRelated(id, fieldsAppPreviews, fieldsAppPreviewSets, limit, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appPreviewSetsAppPreviewsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppPreviews the fields to include for returned resources of type appPreviews
     * @param fieldsAppPreviewSets the fields to include for returned resources of type appPreviewSets
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public appPreviewSetsAppPreviewsGetToManyRelated(id: string, fieldsAppPreviews?: Array<'appPreviewSet' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'mimeType' | 'previewFrameTimeCode' | 'previewImage' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded' | 'videoUrl'>, fieldsAppPreviewSets?: Array<'appCustomProductPageLocalization' | 'appPreviews' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'previewType'>, limit?: number, include?: Array<'appPreviewSet'>, _options?: Configuration): Observable<AppPreviewsResponse> {
        return this.appPreviewSetsAppPreviewsGetToManyRelatedWithHttpInfo(id, fieldsAppPreviews, fieldsAppPreviewSets, limit, include, _options).pipe(map((apiResponse: HttpInfo<AppPreviewsResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public appPreviewSetsAppPreviewsGetToManyRelationshipWithHttpInfo(id: string, limit?: number, _options?: Configuration): Observable<HttpInfo<AppPreviewSetAppPreviewsLinkagesResponse>> {
        const requestContextPromise = this.requestFactory.appPreviewSetsAppPreviewsGetToManyRelationship(id, limit, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appPreviewSetsAppPreviewsGetToManyRelationshipWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public appPreviewSetsAppPreviewsGetToManyRelationship(id: string, limit?: number, _options?: Configuration): Observable<AppPreviewSetAppPreviewsLinkagesResponse> {
        return this.appPreviewSetsAppPreviewsGetToManyRelationshipWithHttpInfo(id, limit, _options).pipe(map((apiResponse: HttpInfo<AppPreviewSetAppPreviewsLinkagesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param appPreviewSetAppPreviewsLinkagesRequest List of related linkages
     */
    public appPreviewSetsAppPreviewsReplaceToManyRelationshipWithHttpInfo(id: string, appPreviewSetAppPreviewsLinkagesRequest: AppPreviewSetAppPreviewsLinkagesRequest, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.appPreviewSetsAppPreviewsReplaceToManyRelationship(id, appPreviewSetAppPreviewsLinkagesRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appPreviewSetsAppPreviewsReplaceToManyRelationshipWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param appPreviewSetAppPreviewsLinkagesRequest List of related linkages
     */
    public appPreviewSetsAppPreviewsReplaceToManyRelationship(id: string, appPreviewSetAppPreviewsLinkagesRequest: AppPreviewSetAppPreviewsLinkagesRequest, _options?: Configuration): Observable<void> {
        return this.appPreviewSetsAppPreviewsReplaceToManyRelationshipWithHttpInfo(id, appPreviewSetAppPreviewsLinkagesRequest, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param appPreviewSetCreateRequest AppPreviewSet representation
     */
    public appPreviewSetsCreateInstanceWithHttpInfo(appPreviewSetCreateRequest: AppPreviewSetCreateRequest, _options?: Configuration): Observable<HttpInfo<AppPreviewSetResponse>> {
        const requestContextPromise = this.requestFactory.appPreviewSetsCreateInstance(appPreviewSetCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appPreviewSetsCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param appPreviewSetCreateRequest AppPreviewSet representation
     */
    public appPreviewSetsCreateInstance(appPreviewSetCreateRequest: AppPreviewSetCreateRequest, _options?: Configuration): Observable<AppPreviewSetResponse> {
        return this.appPreviewSetsCreateInstanceWithHttpInfo(appPreviewSetCreateRequest, _options).pipe(map((apiResponse: HttpInfo<AppPreviewSetResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public appPreviewSetsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.appPreviewSetsDeleteInstance(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appPreviewSetsDeleteInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public appPreviewSetsDeleteInstance(id: string, _options?: Configuration): Observable<void> {
        return this.appPreviewSetsDeleteInstanceWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppPreviewSets the fields to include for returned resources of type appPreviewSets
     * @param include comma-separated list of relationships to include
     * @param fieldsAppPreviews the fields to include for returned resources of type appPreviews
     * @param limitAppPreviews maximum number of related appPreviews returned (when they are included)
     */
    public appPreviewSetsGetInstanceWithHttpInfo(id: string, fieldsAppPreviewSets?: Array<'appCustomProductPageLocalization' | 'appPreviews' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'previewType'>, include?: Array<'appCustomProductPageLocalization' | 'appPreviews' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization'>, fieldsAppPreviews?: Array<'appPreviewSet' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'mimeType' | 'previewFrameTimeCode' | 'previewImage' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded' | 'videoUrl'>, limitAppPreviews?: number, _options?: Configuration): Observable<HttpInfo<AppPreviewSetResponse>> {
        const requestContextPromise = this.requestFactory.appPreviewSetsGetInstance(id, fieldsAppPreviewSets, include, fieldsAppPreviews, limitAppPreviews, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appPreviewSetsGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppPreviewSets the fields to include for returned resources of type appPreviewSets
     * @param include comma-separated list of relationships to include
     * @param fieldsAppPreviews the fields to include for returned resources of type appPreviews
     * @param limitAppPreviews maximum number of related appPreviews returned (when they are included)
     */
    public appPreviewSetsGetInstance(id: string, fieldsAppPreviewSets?: Array<'appCustomProductPageLocalization' | 'appPreviews' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'previewType'>, include?: Array<'appCustomProductPageLocalization' | 'appPreviews' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization'>, fieldsAppPreviews?: Array<'appPreviewSet' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'mimeType' | 'previewFrameTimeCode' | 'previewImage' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded' | 'videoUrl'>, limitAppPreviews?: number, _options?: Configuration): Observable<AppPreviewSetResponse> {
        return this.appPreviewSetsGetInstanceWithHttpInfo(id, fieldsAppPreviewSets, include, fieldsAppPreviews, limitAppPreviews, _options).pipe(map((apiResponse: HttpInfo<AppPreviewSetResponse>) => apiResponse.data));
    }

}

import { AppPreviewsApiRequestFactory, AppPreviewsApiResponseProcessor} from "../apis/AppPreviewsApi.ts";
export class ObservableAppPreviewsApi {
    private requestFactory: AppPreviewsApiRequestFactory;
    private responseProcessor: AppPreviewsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: AppPreviewsApiRequestFactory,
        responseProcessor?: AppPreviewsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new AppPreviewsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new AppPreviewsApiResponseProcessor();
    }

    /**
     * @param appPreviewCreateRequest AppPreview representation
     */
    public appPreviewsCreateInstanceWithHttpInfo(appPreviewCreateRequest: AppPreviewCreateRequest, _options?: Configuration): Observable<HttpInfo<AppPreviewResponse>> {
        const requestContextPromise = this.requestFactory.appPreviewsCreateInstance(appPreviewCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appPreviewsCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param appPreviewCreateRequest AppPreview representation
     */
    public appPreviewsCreateInstance(appPreviewCreateRequest: AppPreviewCreateRequest, _options?: Configuration): Observable<AppPreviewResponse> {
        return this.appPreviewsCreateInstanceWithHttpInfo(appPreviewCreateRequest, _options).pipe(map((apiResponse: HttpInfo<AppPreviewResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public appPreviewsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.appPreviewsDeleteInstance(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appPreviewsDeleteInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public appPreviewsDeleteInstance(id: string, _options?: Configuration): Observable<void> {
        return this.appPreviewsDeleteInstanceWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppPreviews the fields to include for returned resources of type appPreviews
     * @param include comma-separated list of relationships to include
     */
    public appPreviewsGetInstanceWithHttpInfo(id: string, fieldsAppPreviews?: Array<'appPreviewSet' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'mimeType' | 'previewFrameTimeCode' | 'previewImage' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded' | 'videoUrl'>, include?: Array<'appPreviewSet'>, _options?: Configuration): Observable<HttpInfo<AppPreviewResponse>> {
        const requestContextPromise = this.requestFactory.appPreviewsGetInstance(id, fieldsAppPreviews, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appPreviewsGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppPreviews the fields to include for returned resources of type appPreviews
     * @param include comma-separated list of relationships to include
     */
    public appPreviewsGetInstance(id: string, fieldsAppPreviews?: Array<'appPreviewSet' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'mimeType' | 'previewFrameTimeCode' | 'previewImage' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded' | 'videoUrl'>, include?: Array<'appPreviewSet'>, _options?: Configuration): Observable<AppPreviewResponse> {
        return this.appPreviewsGetInstanceWithHttpInfo(id, fieldsAppPreviews, include, _options).pipe(map((apiResponse: HttpInfo<AppPreviewResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param appPreviewUpdateRequest AppPreview representation
     */
    public appPreviewsUpdateInstanceWithHttpInfo(id: string, appPreviewUpdateRequest: AppPreviewUpdateRequest, _options?: Configuration): Observable<HttpInfo<AppPreviewResponse>> {
        const requestContextPromise = this.requestFactory.appPreviewsUpdateInstance(id, appPreviewUpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appPreviewsUpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param appPreviewUpdateRequest AppPreview representation
     */
    public appPreviewsUpdateInstance(id: string, appPreviewUpdateRequest: AppPreviewUpdateRequest, _options?: Configuration): Observable<AppPreviewResponse> {
        return this.appPreviewsUpdateInstanceWithHttpInfo(id, appPreviewUpdateRequest, _options).pipe(map((apiResponse: HttpInfo<AppPreviewResponse>) => apiResponse.data));
    }

}

import { AppPricePointsApiRequestFactory, AppPricePointsApiResponseProcessor} from "../apis/AppPricePointsApi.ts";
export class ObservableAppPricePointsApi {
    private requestFactory: AppPricePointsApiRequestFactory;
    private responseProcessor: AppPricePointsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: AppPricePointsApiRequestFactory,
        responseProcessor?: AppPricePointsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new AppPricePointsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new AppPricePointsApiResponseProcessor();
    }

    /**
     * @param filterPriceTier filter by id(s) of related \&#39;priceTier\&#39;
     * @param filterTerritory filter by id(s) of related \&#39;territory\&#39;
     * @param fieldsAppPricePoints the fields to include for returned resources of type appPricePoints
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsTerritories the fields to include for returned resources of type territories
     */
    public appPricePointsGetCollectionWithHttpInfo(filterPriceTier?: Array<string>, filterTerritory?: Array<string>, fieldsAppPricePoints?: Array<'customerPrice' | 'priceTier' | 'proceeds' | 'territory'>, limit?: number, include?: Array<'priceTier' | 'territory'>, fieldsTerritories?: Array<'currency'>, _options?: Configuration): Observable<HttpInfo<AppPricePointsResponse>> {
        const requestContextPromise = this.requestFactory.appPricePointsGetCollection(filterPriceTier, filterTerritory, fieldsAppPricePoints, limit, include, fieldsTerritories, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appPricePointsGetCollectionWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param filterPriceTier filter by id(s) of related \&#39;priceTier\&#39;
     * @param filterTerritory filter by id(s) of related \&#39;territory\&#39;
     * @param fieldsAppPricePoints the fields to include for returned resources of type appPricePoints
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsTerritories the fields to include for returned resources of type territories
     */
    public appPricePointsGetCollection(filterPriceTier?: Array<string>, filterTerritory?: Array<string>, fieldsAppPricePoints?: Array<'customerPrice' | 'priceTier' | 'proceeds' | 'territory'>, limit?: number, include?: Array<'priceTier' | 'territory'>, fieldsTerritories?: Array<'currency'>, _options?: Configuration): Observable<AppPricePointsResponse> {
        return this.appPricePointsGetCollectionWithHttpInfo(filterPriceTier, filterTerritory, fieldsAppPricePoints, limit, include, fieldsTerritories, _options).pipe(map((apiResponse: HttpInfo<AppPricePointsResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppPricePoints the fields to include for returned resources of type appPricePoints
     * @param include comma-separated list of relationships to include
     * @param fieldsTerritories the fields to include for returned resources of type territories
     */
    public appPricePointsGetInstanceWithHttpInfo(id: string, fieldsAppPricePoints?: Array<'customerPrice' | 'priceTier' | 'proceeds' | 'territory'>, include?: Array<'priceTier' | 'territory'>, fieldsTerritories?: Array<'currency'>, _options?: Configuration): Observable<HttpInfo<AppPricePointResponse>> {
        const requestContextPromise = this.requestFactory.appPricePointsGetInstance(id, fieldsAppPricePoints, include, fieldsTerritories, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appPricePointsGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppPricePoints the fields to include for returned resources of type appPricePoints
     * @param include comma-separated list of relationships to include
     * @param fieldsTerritories the fields to include for returned resources of type territories
     */
    public appPricePointsGetInstance(id: string, fieldsAppPricePoints?: Array<'customerPrice' | 'priceTier' | 'proceeds' | 'territory'>, include?: Array<'priceTier' | 'territory'>, fieldsTerritories?: Array<'currency'>, _options?: Configuration): Observable<AppPricePointResponse> {
        return this.appPricePointsGetInstanceWithHttpInfo(id, fieldsAppPricePoints, include, fieldsTerritories, _options).pipe(map((apiResponse: HttpInfo<AppPricePointResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsTerritories the fields to include for returned resources of type territories
     */
    public appPricePointsTerritoryGetToOneRelatedWithHttpInfo(id: string, fieldsTerritories?: Array<'currency'>, _options?: Configuration): Observable<HttpInfo<TerritoryResponse>> {
        const requestContextPromise = this.requestFactory.appPricePointsTerritoryGetToOneRelated(id, fieldsTerritories, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appPricePointsTerritoryGetToOneRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsTerritories the fields to include for returned resources of type territories
     */
    public appPricePointsTerritoryGetToOneRelated(id: string, fieldsTerritories?: Array<'currency'>, _options?: Configuration): Observable<TerritoryResponse> {
        return this.appPricePointsTerritoryGetToOneRelatedWithHttpInfo(id, fieldsTerritories, _options).pipe(map((apiResponse: HttpInfo<TerritoryResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param filterTerritory filter by id(s) of related \&#39;territory\&#39;
     * @param fieldsAppPricePoints the fields to include for returned resources of type appPricePoints
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public appPricePointsV3EqualizationsGetToManyRelatedWithHttpInfo(id: string, filterTerritory?: Array<string>, fieldsAppPricePoints?: Array<'app' | 'customerPrice' | 'equalizations' | 'proceeds' | 'territory'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsTerritories?: Array<'currency'>, limit?: number, include?: Array<'app' | 'territory'>, _options?: Configuration): Observable<HttpInfo<AppPricePointsV3Response>> {
        const requestContextPromise = this.requestFactory.appPricePointsV3EqualizationsGetToManyRelated(id, filterTerritory, fieldsAppPricePoints, fieldsApps, fieldsTerritories, limit, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appPricePointsV3EqualizationsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param filterTerritory filter by id(s) of related \&#39;territory\&#39;
     * @param fieldsAppPricePoints the fields to include for returned resources of type appPricePoints
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public appPricePointsV3EqualizationsGetToManyRelated(id: string, filterTerritory?: Array<string>, fieldsAppPricePoints?: Array<'app' | 'customerPrice' | 'equalizations' | 'proceeds' | 'territory'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsTerritories?: Array<'currency'>, limit?: number, include?: Array<'app' | 'territory'>, _options?: Configuration): Observable<AppPricePointsV3Response> {
        return this.appPricePointsV3EqualizationsGetToManyRelatedWithHttpInfo(id, filterTerritory, fieldsAppPricePoints, fieldsApps, fieldsTerritories, limit, include, _options).pipe(map((apiResponse: HttpInfo<AppPricePointsV3Response>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppPricePoints the fields to include for returned resources of type appPricePoints
     * @param include comma-separated list of relationships to include
     */
    public appPricePointsV3GetInstanceWithHttpInfo(id: string, fieldsAppPricePoints?: Array<'app' | 'customerPrice' | 'equalizations' | 'proceeds' | 'territory'>, include?: Array<'app' | 'territory'>, _options?: Configuration): Observable<HttpInfo<AppPricePointV3Response>> {
        const requestContextPromise = this.requestFactory.appPricePointsV3GetInstance(id, fieldsAppPricePoints, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appPricePointsV3GetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppPricePoints the fields to include for returned resources of type appPricePoints
     * @param include comma-separated list of relationships to include
     */
    public appPricePointsV3GetInstance(id: string, fieldsAppPricePoints?: Array<'app' | 'customerPrice' | 'equalizations' | 'proceeds' | 'territory'>, include?: Array<'app' | 'territory'>, _options?: Configuration): Observable<AppPricePointV3Response> {
        return this.appPricePointsV3GetInstanceWithHttpInfo(id, fieldsAppPricePoints, include, _options).pipe(map((apiResponse: HttpInfo<AppPricePointV3Response>) => apiResponse.data));
    }

}

import { AppPriceSchedulesApiRequestFactory, AppPriceSchedulesApiResponseProcessor} from "../apis/AppPriceSchedulesApi.ts";
export class ObservableAppPriceSchedulesApi {
    private requestFactory: AppPriceSchedulesApiRequestFactory;
    private responseProcessor: AppPriceSchedulesApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: AppPriceSchedulesApiRequestFactory,
        responseProcessor?: AppPriceSchedulesApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new AppPriceSchedulesApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new AppPriceSchedulesApiResponseProcessor();
    }

    /**
     * @param id the id of the requested resource
     * @param filterEndDate filter by attribute \&#39;endDate\&#39;
     * @param filterStartDate filter by attribute \&#39;startDate\&#39;
     * @param filterTerritory filter by id(s) of related \&#39;territory\&#39;
     * @param fieldsAppPrices the fields to include for returned resources of type appPrices
     * @param fieldsAppPricePoints the fields to include for returned resources of type appPricePoints
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public appPriceSchedulesAutomaticPricesGetToManyRelatedWithHttpInfo(id: string, filterEndDate?: Array<string>, filterStartDate?: Array<string>, filterTerritory?: Array<string>, fieldsAppPrices?: Array<'appPricePoint' | 'endDate' | 'manual' | 'startDate' | 'territory'>, fieldsAppPricePoints?: Array<'app' | 'customerPrice' | 'equalizations' | 'proceeds' | 'territory'>, fieldsTerritories?: Array<'currency'>, limit?: number, include?: Array<'appPricePoint' | 'territory'>, _options?: Configuration): Observable<HttpInfo<AppPricesV2Response>> {
        const requestContextPromise = this.requestFactory.appPriceSchedulesAutomaticPricesGetToManyRelated(id, filterEndDate, filterStartDate, filterTerritory, fieldsAppPrices, fieldsAppPricePoints, fieldsTerritories, limit, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appPriceSchedulesAutomaticPricesGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param filterEndDate filter by attribute \&#39;endDate\&#39;
     * @param filterStartDate filter by attribute \&#39;startDate\&#39;
     * @param filterTerritory filter by id(s) of related \&#39;territory\&#39;
     * @param fieldsAppPrices the fields to include for returned resources of type appPrices
     * @param fieldsAppPricePoints the fields to include for returned resources of type appPricePoints
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public appPriceSchedulesAutomaticPricesGetToManyRelated(id: string, filterEndDate?: Array<string>, filterStartDate?: Array<string>, filterTerritory?: Array<string>, fieldsAppPrices?: Array<'appPricePoint' | 'endDate' | 'manual' | 'startDate' | 'territory'>, fieldsAppPricePoints?: Array<'app' | 'customerPrice' | 'equalizations' | 'proceeds' | 'territory'>, fieldsTerritories?: Array<'currency'>, limit?: number, include?: Array<'appPricePoint' | 'territory'>, _options?: Configuration): Observable<AppPricesV2Response> {
        return this.appPriceSchedulesAutomaticPricesGetToManyRelatedWithHttpInfo(id, filterEndDate, filterStartDate, filterTerritory, fieldsAppPrices, fieldsAppPricePoints, fieldsTerritories, limit, include, _options).pipe(map((apiResponse: HttpInfo<AppPricesV2Response>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsTerritories the fields to include for returned resources of type territories
     */
    public appPriceSchedulesBaseTerritoryGetToOneRelatedWithHttpInfo(id: string, fieldsTerritories?: Array<'currency'>, _options?: Configuration): Observable<HttpInfo<TerritoryResponse>> {
        const requestContextPromise = this.requestFactory.appPriceSchedulesBaseTerritoryGetToOneRelated(id, fieldsTerritories, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appPriceSchedulesBaseTerritoryGetToOneRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsTerritories the fields to include for returned resources of type territories
     */
    public appPriceSchedulesBaseTerritoryGetToOneRelated(id: string, fieldsTerritories?: Array<'currency'>, _options?: Configuration): Observable<TerritoryResponse> {
        return this.appPriceSchedulesBaseTerritoryGetToOneRelatedWithHttpInfo(id, fieldsTerritories, _options).pipe(map((apiResponse: HttpInfo<TerritoryResponse>) => apiResponse.data));
    }

    /**
     * @param appPriceScheduleCreateRequest AppPriceSchedule representation
     */
    public appPriceSchedulesCreateInstanceWithHttpInfo(appPriceScheduleCreateRequest: AppPriceScheduleCreateRequest, _options?: Configuration): Observable<HttpInfo<AppPriceScheduleResponse>> {
        const requestContextPromise = this.requestFactory.appPriceSchedulesCreateInstance(appPriceScheduleCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appPriceSchedulesCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param appPriceScheduleCreateRequest AppPriceSchedule representation
     */
    public appPriceSchedulesCreateInstance(appPriceScheduleCreateRequest: AppPriceScheduleCreateRequest, _options?: Configuration): Observable<AppPriceScheduleResponse> {
        return this.appPriceSchedulesCreateInstanceWithHttpInfo(appPriceScheduleCreateRequest, _options).pipe(map((apiResponse: HttpInfo<AppPriceScheduleResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppPriceSchedules the fields to include for returned resources of type appPriceSchedules
     * @param include comma-separated list of relationships to include
     * @param fieldsAppPrices the fields to include for returned resources of type appPrices
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limitAutomaticPrices maximum number of related automaticPrices returned (when they are included)
     * @param limitManualPrices maximum number of related manualPrices returned (when they are included)
     */
    public appPriceSchedulesGetInstanceWithHttpInfo(id: string, fieldsAppPriceSchedules?: Array<'app' | 'automaticPrices' | 'baseTerritory' | 'manualPrices'>, include?: Array<'app' | 'automaticPrices' | 'baseTerritory' | 'manualPrices'>, fieldsAppPrices?: Array<'appPricePoint' | 'endDate' | 'manual' | 'startDate' | 'territory'>, fieldsTerritories?: Array<'currency'>, limitAutomaticPrices?: number, limitManualPrices?: number, _options?: Configuration): Observable<HttpInfo<AppPriceScheduleResponse>> {
        const requestContextPromise = this.requestFactory.appPriceSchedulesGetInstance(id, fieldsAppPriceSchedules, include, fieldsAppPrices, fieldsTerritories, limitAutomaticPrices, limitManualPrices, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appPriceSchedulesGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppPriceSchedules the fields to include for returned resources of type appPriceSchedules
     * @param include comma-separated list of relationships to include
     * @param fieldsAppPrices the fields to include for returned resources of type appPrices
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limitAutomaticPrices maximum number of related automaticPrices returned (when they are included)
     * @param limitManualPrices maximum number of related manualPrices returned (when they are included)
     */
    public appPriceSchedulesGetInstance(id: string, fieldsAppPriceSchedules?: Array<'app' | 'automaticPrices' | 'baseTerritory' | 'manualPrices'>, include?: Array<'app' | 'automaticPrices' | 'baseTerritory' | 'manualPrices'>, fieldsAppPrices?: Array<'appPricePoint' | 'endDate' | 'manual' | 'startDate' | 'territory'>, fieldsTerritories?: Array<'currency'>, limitAutomaticPrices?: number, limitManualPrices?: number, _options?: Configuration): Observable<AppPriceScheduleResponse> {
        return this.appPriceSchedulesGetInstanceWithHttpInfo(id, fieldsAppPriceSchedules, include, fieldsAppPrices, fieldsTerritories, limitAutomaticPrices, limitManualPrices, _options).pipe(map((apiResponse: HttpInfo<AppPriceScheduleResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param filterEndDate filter by attribute \&#39;endDate\&#39;
     * @param filterStartDate filter by attribute \&#39;startDate\&#39;
     * @param filterTerritory filter by id(s) of related \&#39;territory\&#39;
     * @param fieldsAppPrices the fields to include for returned resources of type appPrices
     * @param fieldsAppPricePoints the fields to include for returned resources of type appPricePoints
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public appPriceSchedulesManualPricesGetToManyRelatedWithHttpInfo(id: string, filterEndDate?: Array<string>, filterStartDate?: Array<string>, filterTerritory?: Array<string>, fieldsAppPrices?: Array<'appPricePoint' | 'endDate' | 'manual' | 'startDate' | 'territory'>, fieldsAppPricePoints?: Array<'app' | 'customerPrice' | 'equalizations' | 'proceeds' | 'territory'>, fieldsTerritories?: Array<'currency'>, limit?: number, include?: Array<'appPricePoint' | 'territory'>, _options?: Configuration): Observable<HttpInfo<AppPricesV2Response>> {
        const requestContextPromise = this.requestFactory.appPriceSchedulesManualPricesGetToManyRelated(id, filterEndDate, filterStartDate, filterTerritory, fieldsAppPrices, fieldsAppPricePoints, fieldsTerritories, limit, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appPriceSchedulesManualPricesGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param filterEndDate filter by attribute \&#39;endDate\&#39;
     * @param filterStartDate filter by attribute \&#39;startDate\&#39;
     * @param filterTerritory filter by id(s) of related \&#39;territory\&#39;
     * @param fieldsAppPrices the fields to include for returned resources of type appPrices
     * @param fieldsAppPricePoints the fields to include for returned resources of type appPricePoints
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public appPriceSchedulesManualPricesGetToManyRelated(id: string, filterEndDate?: Array<string>, filterStartDate?: Array<string>, filterTerritory?: Array<string>, fieldsAppPrices?: Array<'appPricePoint' | 'endDate' | 'manual' | 'startDate' | 'territory'>, fieldsAppPricePoints?: Array<'app' | 'customerPrice' | 'equalizations' | 'proceeds' | 'territory'>, fieldsTerritories?: Array<'currency'>, limit?: number, include?: Array<'appPricePoint' | 'territory'>, _options?: Configuration): Observable<AppPricesV2Response> {
        return this.appPriceSchedulesManualPricesGetToManyRelatedWithHttpInfo(id, filterEndDate, filterStartDate, filterTerritory, fieldsAppPrices, fieldsAppPricePoints, fieldsTerritories, limit, include, _options).pipe(map((apiResponse: HttpInfo<AppPricesV2Response>) => apiResponse.data));
    }

}

import { AppPriceTiersApiRequestFactory, AppPriceTiersApiResponseProcessor} from "../apis/AppPriceTiersApi.ts";
export class ObservableAppPriceTiersApi {
    private requestFactory: AppPriceTiersApiRequestFactory;
    private responseProcessor: AppPriceTiersApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: AppPriceTiersApiRequestFactory,
        responseProcessor?: AppPriceTiersApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new AppPriceTiersApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new AppPriceTiersApiResponseProcessor();
    }

    /**
     * @param filterId filter by id(s)
     * @param fieldsAppPriceTiers the fields to include for returned resources of type appPriceTiers
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsAppPricePoints the fields to include for returned resources of type appPricePoints
     * @param limitPricePoints maximum number of related pricePoints returned (when they are included)
     */
    public appPriceTiersGetCollectionWithHttpInfo(filterId?: Array<string>, fieldsAppPriceTiers?: Array<'pricePoints'>, limit?: number, include?: Array<'pricePoints'>, fieldsAppPricePoints?: Array<'customerPrice' | 'priceTier' | 'proceeds' | 'territory'>, limitPricePoints?: number, _options?: Configuration): Observable<HttpInfo<AppPriceTiersResponse>> {
        const requestContextPromise = this.requestFactory.appPriceTiersGetCollection(filterId, fieldsAppPriceTiers, limit, include, fieldsAppPricePoints, limitPricePoints, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appPriceTiersGetCollectionWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param filterId filter by id(s)
     * @param fieldsAppPriceTiers the fields to include for returned resources of type appPriceTiers
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsAppPricePoints the fields to include for returned resources of type appPricePoints
     * @param limitPricePoints maximum number of related pricePoints returned (when they are included)
     */
    public appPriceTiersGetCollection(filterId?: Array<string>, fieldsAppPriceTiers?: Array<'pricePoints'>, limit?: number, include?: Array<'pricePoints'>, fieldsAppPricePoints?: Array<'customerPrice' | 'priceTier' | 'proceeds' | 'territory'>, limitPricePoints?: number, _options?: Configuration): Observable<AppPriceTiersResponse> {
        return this.appPriceTiersGetCollectionWithHttpInfo(filterId, fieldsAppPriceTiers, limit, include, fieldsAppPricePoints, limitPricePoints, _options).pipe(map((apiResponse: HttpInfo<AppPriceTiersResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppPriceTiers the fields to include for returned resources of type appPriceTiers
     * @param include comma-separated list of relationships to include
     * @param fieldsAppPricePoints the fields to include for returned resources of type appPricePoints
     * @param limitPricePoints maximum number of related pricePoints returned (when they are included)
     */
    public appPriceTiersGetInstanceWithHttpInfo(id: string, fieldsAppPriceTiers?: Array<'pricePoints'>, include?: Array<'pricePoints'>, fieldsAppPricePoints?: Array<'customerPrice' | 'priceTier' | 'proceeds' | 'territory'>, limitPricePoints?: number, _options?: Configuration): Observable<HttpInfo<AppPriceTierResponse>> {
        const requestContextPromise = this.requestFactory.appPriceTiersGetInstance(id, fieldsAppPriceTiers, include, fieldsAppPricePoints, limitPricePoints, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appPriceTiersGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppPriceTiers the fields to include for returned resources of type appPriceTiers
     * @param include comma-separated list of relationships to include
     * @param fieldsAppPricePoints the fields to include for returned resources of type appPricePoints
     * @param limitPricePoints maximum number of related pricePoints returned (when they are included)
     */
    public appPriceTiersGetInstance(id: string, fieldsAppPriceTiers?: Array<'pricePoints'>, include?: Array<'pricePoints'>, fieldsAppPricePoints?: Array<'customerPrice' | 'priceTier' | 'proceeds' | 'territory'>, limitPricePoints?: number, _options?: Configuration): Observable<AppPriceTierResponse> {
        return this.appPriceTiersGetInstanceWithHttpInfo(id, fieldsAppPriceTiers, include, fieldsAppPricePoints, limitPricePoints, _options).pipe(map((apiResponse: HttpInfo<AppPriceTierResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param filterTerritory filter by id(s) of related \&#39;territory\&#39;
     * @param fieldsAppPriceTiers the fields to include for returned resources of type appPriceTiers
     * @param fieldsAppPricePoints the fields to include for returned resources of type appPricePoints
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public appPriceTiersPricePointsGetToManyRelatedWithHttpInfo(id: string, filterTerritory?: Array<string>, fieldsAppPriceTiers?: Array<'pricePoints'>, fieldsAppPricePoints?: Array<'customerPrice' | 'priceTier' | 'proceeds' | 'territory'>, fieldsTerritories?: Array<'currency'>, limit?: number, include?: Array<'priceTier' | 'territory'>, _options?: Configuration): Observable<HttpInfo<AppPricePointsResponse>> {
        const requestContextPromise = this.requestFactory.appPriceTiersPricePointsGetToManyRelated(id, filterTerritory, fieldsAppPriceTiers, fieldsAppPricePoints, fieldsTerritories, limit, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appPriceTiersPricePointsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param filterTerritory filter by id(s) of related \&#39;territory\&#39;
     * @param fieldsAppPriceTiers the fields to include for returned resources of type appPriceTiers
     * @param fieldsAppPricePoints the fields to include for returned resources of type appPricePoints
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public appPriceTiersPricePointsGetToManyRelated(id: string, filterTerritory?: Array<string>, fieldsAppPriceTiers?: Array<'pricePoints'>, fieldsAppPricePoints?: Array<'customerPrice' | 'priceTier' | 'proceeds' | 'territory'>, fieldsTerritories?: Array<'currency'>, limit?: number, include?: Array<'priceTier' | 'territory'>, _options?: Configuration): Observable<AppPricePointsResponse> {
        return this.appPriceTiersPricePointsGetToManyRelatedWithHttpInfo(id, filterTerritory, fieldsAppPriceTiers, fieldsAppPricePoints, fieldsTerritories, limit, include, _options).pipe(map((apiResponse: HttpInfo<AppPricePointsResponse>) => apiResponse.data));
    }

}

import { AppPricesApiRequestFactory, AppPricesApiResponseProcessor} from "../apis/AppPricesApi.ts";
export class ObservableAppPricesApi {
    private requestFactory: AppPricesApiRequestFactory;
    private responseProcessor: AppPricesApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: AppPricesApiRequestFactory,
        responseProcessor?: AppPricesApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new AppPricesApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new AppPricesApiResponseProcessor();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppPrices the fields to include for returned resources of type appPrices
     * @param include comma-separated list of relationships to include
     */
    public appPricesGetInstanceWithHttpInfo(id: string, fieldsAppPrices?: Array<'app' | 'priceTier'>, include?: Array<'app' | 'priceTier'>, _options?: Configuration): Observable<HttpInfo<AppPriceResponse>> {
        const requestContextPromise = this.requestFactory.appPricesGetInstance(id, fieldsAppPrices, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appPricesGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppPrices the fields to include for returned resources of type appPrices
     * @param include comma-separated list of relationships to include
     */
    public appPricesGetInstance(id: string, fieldsAppPrices?: Array<'app' | 'priceTier'>, include?: Array<'app' | 'priceTier'>, _options?: Configuration): Observable<AppPriceResponse> {
        return this.appPricesGetInstanceWithHttpInfo(id, fieldsAppPrices, include, _options).pipe(map((apiResponse: HttpInfo<AppPriceResponse>) => apiResponse.data));
    }

}

import { AppScreenshotSetsApiRequestFactory, AppScreenshotSetsApiResponseProcessor} from "../apis/AppScreenshotSetsApi.ts";
export class ObservableAppScreenshotSetsApi {
    private requestFactory: AppScreenshotSetsApiRequestFactory;
    private responseProcessor: AppScreenshotSetsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: AppScreenshotSetsApiRequestFactory,
        responseProcessor?: AppScreenshotSetsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new AppScreenshotSetsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new AppScreenshotSetsApiResponseProcessor();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppScreenshotSets the fields to include for returned resources of type appScreenshotSets
     * @param fieldsAppScreenshots the fields to include for returned resources of type appScreenshots
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public appScreenshotSetsAppScreenshotsGetToManyRelatedWithHttpInfo(id: string, fieldsAppScreenshotSets?: Array<'appCustomProductPageLocalization' | 'appScreenshots' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'screenshotDisplayType'>, fieldsAppScreenshots?: Array<'appScreenshotSet' | 'assetDeliveryState' | 'assetToken' | 'assetType' | 'fileName' | 'fileSize' | 'imageAsset' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, limit?: number, include?: Array<'appScreenshotSet'>, _options?: Configuration): Observable<HttpInfo<AppScreenshotsResponse>> {
        const requestContextPromise = this.requestFactory.appScreenshotSetsAppScreenshotsGetToManyRelated(id, fieldsAppScreenshotSets, fieldsAppScreenshots, limit, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appScreenshotSetsAppScreenshotsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppScreenshotSets the fields to include for returned resources of type appScreenshotSets
     * @param fieldsAppScreenshots the fields to include for returned resources of type appScreenshots
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public appScreenshotSetsAppScreenshotsGetToManyRelated(id: string, fieldsAppScreenshotSets?: Array<'appCustomProductPageLocalization' | 'appScreenshots' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'screenshotDisplayType'>, fieldsAppScreenshots?: Array<'appScreenshotSet' | 'assetDeliveryState' | 'assetToken' | 'assetType' | 'fileName' | 'fileSize' | 'imageAsset' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, limit?: number, include?: Array<'appScreenshotSet'>, _options?: Configuration): Observable<AppScreenshotsResponse> {
        return this.appScreenshotSetsAppScreenshotsGetToManyRelatedWithHttpInfo(id, fieldsAppScreenshotSets, fieldsAppScreenshots, limit, include, _options).pipe(map((apiResponse: HttpInfo<AppScreenshotsResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public appScreenshotSetsAppScreenshotsGetToManyRelationshipWithHttpInfo(id: string, limit?: number, _options?: Configuration): Observable<HttpInfo<AppScreenshotSetAppScreenshotsLinkagesResponse>> {
        const requestContextPromise = this.requestFactory.appScreenshotSetsAppScreenshotsGetToManyRelationship(id, limit, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appScreenshotSetsAppScreenshotsGetToManyRelationshipWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public appScreenshotSetsAppScreenshotsGetToManyRelationship(id: string, limit?: number, _options?: Configuration): Observable<AppScreenshotSetAppScreenshotsLinkagesResponse> {
        return this.appScreenshotSetsAppScreenshotsGetToManyRelationshipWithHttpInfo(id, limit, _options).pipe(map((apiResponse: HttpInfo<AppScreenshotSetAppScreenshotsLinkagesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param appScreenshotSetAppScreenshotsLinkagesRequest List of related linkages
     */
    public appScreenshotSetsAppScreenshotsReplaceToManyRelationshipWithHttpInfo(id: string, appScreenshotSetAppScreenshotsLinkagesRequest: AppScreenshotSetAppScreenshotsLinkagesRequest, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.appScreenshotSetsAppScreenshotsReplaceToManyRelationship(id, appScreenshotSetAppScreenshotsLinkagesRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appScreenshotSetsAppScreenshotsReplaceToManyRelationshipWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param appScreenshotSetAppScreenshotsLinkagesRequest List of related linkages
     */
    public appScreenshotSetsAppScreenshotsReplaceToManyRelationship(id: string, appScreenshotSetAppScreenshotsLinkagesRequest: AppScreenshotSetAppScreenshotsLinkagesRequest, _options?: Configuration): Observable<void> {
        return this.appScreenshotSetsAppScreenshotsReplaceToManyRelationshipWithHttpInfo(id, appScreenshotSetAppScreenshotsLinkagesRequest, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param appScreenshotSetCreateRequest AppScreenshotSet representation
     */
    public appScreenshotSetsCreateInstanceWithHttpInfo(appScreenshotSetCreateRequest: AppScreenshotSetCreateRequest, _options?: Configuration): Observable<HttpInfo<AppScreenshotSetResponse>> {
        const requestContextPromise = this.requestFactory.appScreenshotSetsCreateInstance(appScreenshotSetCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appScreenshotSetsCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param appScreenshotSetCreateRequest AppScreenshotSet representation
     */
    public appScreenshotSetsCreateInstance(appScreenshotSetCreateRequest: AppScreenshotSetCreateRequest, _options?: Configuration): Observable<AppScreenshotSetResponse> {
        return this.appScreenshotSetsCreateInstanceWithHttpInfo(appScreenshotSetCreateRequest, _options).pipe(map((apiResponse: HttpInfo<AppScreenshotSetResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public appScreenshotSetsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.appScreenshotSetsDeleteInstance(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appScreenshotSetsDeleteInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public appScreenshotSetsDeleteInstance(id: string, _options?: Configuration): Observable<void> {
        return this.appScreenshotSetsDeleteInstanceWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppScreenshotSets the fields to include for returned resources of type appScreenshotSets
     * @param include comma-separated list of relationships to include
     * @param fieldsAppScreenshots the fields to include for returned resources of type appScreenshots
     * @param limitAppScreenshots maximum number of related appScreenshots returned (when they are included)
     */
    public appScreenshotSetsGetInstanceWithHttpInfo(id: string, fieldsAppScreenshotSets?: Array<'appCustomProductPageLocalization' | 'appScreenshots' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'screenshotDisplayType'>, include?: Array<'appCustomProductPageLocalization' | 'appScreenshots' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization'>, fieldsAppScreenshots?: Array<'appScreenshotSet' | 'assetDeliveryState' | 'assetToken' | 'assetType' | 'fileName' | 'fileSize' | 'imageAsset' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, limitAppScreenshots?: number, _options?: Configuration): Observable<HttpInfo<AppScreenshotSetResponse>> {
        const requestContextPromise = this.requestFactory.appScreenshotSetsGetInstance(id, fieldsAppScreenshotSets, include, fieldsAppScreenshots, limitAppScreenshots, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appScreenshotSetsGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppScreenshotSets the fields to include for returned resources of type appScreenshotSets
     * @param include comma-separated list of relationships to include
     * @param fieldsAppScreenshots the fields to include for returned resources of type appScreenshots
     * @param limitAppScreenshots maximum number of related appScreenshots returned (when they are included)
     */
    public appScreenshotSetsGetInstance(id: string, fieldsAppScreenshotSets?: Array<'appCustomProductPageLocalization' | 'appScreenshots' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'screenshotDisplayType'>, include?: Array<'appCustomProductPageLocalization' | 'appScreenshots' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization'>, fieldsAppScreenshots?: Array<'appScreenshotSet' | 'assetDeliveryState' | 'assetToken' | 'assetType' | 'fileName' | 'fileSize' | 'imageAsset' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, limitAppScreenshots?: number, _options?: Configuration): Observable<AppScreenshotSetResponse> {
        return this.appScreenshotSetsGetInstanceWithHttpInfo(id, fieldsAppScreenshotSets, include, fieldsAppScreenshots, limitAppScreenshots, _options).pipe(map((apiResponse: HttpInfo<AppScreenshotSetResponse>) => apiResponse.data));
    }

}

import { AppScreenshotsApiRequestFactory, AppScreenshotsApiResponseProcessor} from "../apis/AppScreenshotsApi.ts";
export class ObservableAppScreenshotsApi {
    private requestFactory: AppScreenshotsApiRequestFactory;
    private responseProcessor: AppScreenshotsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: AppScreenshotsApiRequestFactory,
        responseProcessor?: AppScreenshotsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new AppScreenshotsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new AppScreenshotsApiResponseProcessor();
    }

    /**
     * @param appScreenshotCreateRequest AppScreenshot representation
     */
    public appScreenshotsCreateInstanceWithHttpInfo(appScreenshotCreateRequest: AppScreenshotCreateRequest, _options?: Configuration): Observable<HttpInfo<AppScreenshotResponse>> {
        const requestContextPromise = this.requestFactory.appScreenshotsCreateInstance(appScreenshotCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appScreenshotsCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param appScreenshotCreateRequest AppScreenshot representation
     */
    public appScreenshotsCreateInstance(appScreenshotCreateRequest: AppScreenshotCreateRequest, _options?: Configuration): Observable<AppScreenshotResponse> {
        return this.appScreenshotsCreateInstanceWithHttpInfo(appScreenshotCreateRequest, _options).pipe(map((apiResponse: HttpInfo<AppScreenshotResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public appScreenshotsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.appScreenshotsDeleteInstance(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appScreenshotsDeleteInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public appScreenshotsDeleteInstance(id: string, _options?: Configuration): Observable<void> {
        return this.appScreenshotsDeleteInstanceWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppScreenshots the fields to include for returned resources of type appScreenshots
     * @param include comma-separated list of relationships to include
     */
    public appScreenshotsGetInstanceWithHttpInfo(id: string, fieldsAppScreenshots?: Array<'appScreenshotSet' | 'assetDeliveryState' | 'assetToken' | 'assetType' | 'fileName' | 'fileSize' | 'imageAsset' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, include?: Array<'appScreenshotSet'>, _options?: Configuration): Observable<HttpInfo<AppScreenshotResponse>> {
        const requestContextPromise = this.requestFactory.appScreenshotsGetInstance(id, fieldsAppScreenshots, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appScreenshotsGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppScreenshots the fields to include for returned resources of type appScreenshots
     * @param include comma-separated list of relationships to include
     */
    public appScreenshotsGetInstance(id: string, fieldsAppScreenshots?: Array<'appScreenshotSet' | 'assetDeliveryState' | 'assetToken' | 'assetType' | 'fileName' | 'fileSize' | 'imageAsset' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, include?: Array<'appScreenshotSet'>, _options?: Configuration): Observable<AppScreenshotResponse> {
        return this.appScreenshotsGetInstanceWithHttpInfo(id, fieldsAppScreenshots, include, _options).pipe(map((apiResponse: HttpInfo<AppScreenshotResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param appScreenshotUpdateRequest AppScreenshot representation
     */
    public appScreenshotsUpdateInstanceWithHttpInfo(id: string, appScreenshotUpdateRequest: AppScreenshotUpdateRequest, _options?: Configuration): Observable<HttpInfo<AppScreenshotResponse>> {
        const requestContextPromise = this.requestFactory.appScreenshotsUpdateInstance(id, appScreenshotUpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appScreenshotsUpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param appScreenshotUpdateRequest AppScreenshot representation
     */
    public appScreenshotsUpdateInstance(id: string, appScreenshotUpdateRequest: AppScreenshotUpdateRequest, _options?: Configuration): Observable<AppScreenshotResponse> {
        return this.appScreenshotsUpdateInstanceWithHttpInfo(id, appScreenshotUpdateRequest, _options).pipe(map((apiResponse: HttpInfo<AppScreenshotResponse>) => apiResponse.data));
    }

}

import { AppStoreReviewAttachmentsApiRequestFactory, AppStoreReviewAttachmentsApiResponseProcessor} from "../apis/AppStoreReviewAttachmentsApi.ts";
export class ObservableAppStoreReviewAttachmentsApi {
    private requestFactory: AppStoreReviewAttachmentsApiRequestFactory;
    private responseProcessor: AppStoreReviewAttachmentsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: AppStoreReviewAttachmentsApiRequestFactory,
        responseProcessor?: AppStoreReviewAttachmentsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new AppStoreReviewAttachmentsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new AppStoreReviewAttachmentsApiResponseProcessor();
    }

    /**
     * @param appStoreReviewAttachmentCreateRequest AppStoreReviewAttachment representation
     */
    public appStoreReviewAttachmentsCreateInstanceWithHttpInfo(appStoreReviewAttachmentCreateRequest: AppStoreReviewAttachmentCreateRequest, _options?: Configuration): Observable<HttpInfo<AppStoreReviewAttachmentResponse>> {
        const requestContextPromise = this.requestFactory.appStoreReviewAttachmentsCreateInstance(appStoreReviewAttachmentCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appStoreReviewAttachmentsCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param appStoreReviewAttachmentCreateRequest AppStoreReviewAttachment representation
     */
    public appStoreReviewAttachmentsCreateInstance(appStoreReviewAttachmentCreateRequest: AppStoreReviewAttachmentCreateRequest, _options?: Configuration): Observable<AppStoreReviewAttachmentResponse> {
        return this.appStoreReviewAttachmentsCreateInstanceWithHttpInfo(appStoreReviewAttachmentCreateRequest, _options).pipe(map((apiResponse: HttpInfo<AppStoreReviewAttachmentResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public appStoreReviewAttachmentsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.appStoreReviewAttachmentsDeleteInstance(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appStoreReviewAttachmentsDeleteInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public appStoreReviewAttachmentsDeleteInstance(id: string, _options?: Configuration): Observable<void> {
        return this.appStoreReviewAttachmentsDeleteInstanceWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppStoreReviewAttachments the fields to include for returned resources of type appStoreReviewAttachments
     * @param include comma-separated list of relationships to include
     */
    public appStoreReviewAttachmentsGetInstanceWithHttpInfo(id: string, fieldsAppStoreReviewAttachments?: Array<'appStoreReviewDetail' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, include?: Array<'appStoreReviewDetail'>, _options?: Configuration): Observable<HttpInfo<AppStoreReviewAttachmentResponse>> {
        const requestContextPromise = this.requestFactory.appStoreReviewAttachmentsGetInstance(id, fieldsAppStoreReviewAttachments, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appStoreReviewAttachmentsGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppStoreReviewAttachments the fields to include for returned resources of type appStoreReviewAttachments
     * @param include comma-separated list of relationships to include
     */
    public appStoreReviewAttachmentsGetInstance(id: string, fieldsAppStoreReviewAttachments?: Array<'appStoreReviewDetail' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, include?: Array<'appStoreReviewDetail'>, _options?: Configuration): Observable<AppStoreReviewAttachmentResponse> {
        return this.appStoreReviewAttachmentsGetInstanceWithHttpInfo(id, fieldsAppStoreReviewAttachments, include, _options).pipe(map((apiResponse: HttpInfo<AppStoreReviewAttachmentResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param appStoreReviewAttachmentUpdateRequest AppStoreReviewAttachment representation
     */
    public appStoreReviewAttachmentsUpdateInstanceWithHttpInfo(id: string, appStoreReviewAttachmentUpdateRequest: AppStoreReviewAttachmentUpdateRequest, _options?: Configuration): Observable<HttpInfo<AppStoreReviewAttachmentResponse>> {
        const requestContextPromise = this.requestFactory.appStoreReviewAttachmentsUpdateInstance(id, appStoreReviewAttachmentUpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appStoreReviewAttachmentsUpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param appStoreReviewAttachmentUpdateRequest AppStoreReviewAttachment representation
     */
    public appStoreReviewAttachmentsUpdateInstance(id: string, appStoreReviewAttachmentUpdateRequest: AppStoreReviewAttachmentUpdateRequest, _options?: Configuration): Observable<AppStoreReviewAttachmentResponse> {
        return this.appStoreReviewAttachmentsUpdateInstanceWithHttpInfo(id, appStoreReviewAttachmentUpdateRequest, _options).pipe(map((apiResponse: HttpInfo<AppStoreReviewAttachmentResponse>) => apiResponse.data));
    }

}

import { AppStoreReviewDetailsApiRequestFactory, AppStoreReviewDetailsApiResponseProcessor} from "../apis/AppStoreReviewDetailsApi.ts";
export class ObservableAppStoreReviewDetailsApi {
    private requestFactory: AppStoreReviewDetailsApiRequestFactory;
    private responseProcessor: AppStoreReviewDetailsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: AppStoreReviewDetailsApiRequestFactory,
        responseProcessor?: AppStoreReviewDetailsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new AppStoreReviewDetailsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new AppStoreReviewDetailsApiResponseProcessor();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppStoreReviewDetails the fields to include for returned resources of type appStoreReviewDetails
     * @param fieldsAppStoreReviewAttachments the fields to include for returned resources of type appStoreReviewAttachments
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public appStoreReviewDetailsAppStoreReviewAttachmentsGetToManyRelatedWithHttpInfo(id: string, fieldsAppStoreReviewDetails?: Array<'appStoreReviewAttachments' | 'appStoreVersion' | 'contactEmail' | 'contactFirstName' | 'contactLastName' | 'contactPhone' | 'demoAccountName' | 'demoAccountPassword' | 'demoAccountRequired' | 'notes'>, fieldsAppStoreReviewAttachments?: Array<'appStoreReviewDetail' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, limit?: number, include?: Array<'appStoreReviewDetail'>, _options?: Configuration): Observable<HttpInfo<AppStoreReviewAttachmentsResponse>> {
        const requestContextPromise = this.requestFactory.appStoreReviewDetailsAppStoreReviewAttachmentsGetToManyRelated(id, fieldsAppStoreReviewDetails, fieldsAppStoreReviewAttachments, limit, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appStoreReviewDetailsAppStoreReviewAttachmentsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppStoreReviewDetails the fields to include for returned resources of type appStoreReviewDetails
     * @param fieldsAppStoreReviewAttachments the fields to include for returned resources of type appStoreReviewAttachments
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public appStoreReviewDetailsAppStoreReviewAttachmentsGetToManyRelated(id: string, fieldsAppStoreReviewDetails?: Array<'appStoreReviewAttachments' | 'appStoreVersion' | 'contactEmail' | 'contactFirstName' | 'contactLastName' | 'contactPhone' | 'demoAccountName' | 'demoAccountPassword' | 'demoAccountRequired' | 'notes'>, fieldsAppStoreReviewAttachments?: Array<'appStoreReviewDetail' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, limit?: number, include?: Array<'appStoreReviewDetail'>, _options?: Configuration): Observable<AppStoreReviewAttachmentsResponse> {
        return this.appStoreReviewDetailsAppStoreReviewAttachmentsGetToManyRelatedWithHttpInfo(id, fieldsAppStoreReviewDetails, fieldsAppStoreReviewAttachments, limit, include, _options).pipe(map((apiResponse: HttpInfo<AppStoreReviewAttachmentsResponse>) => apiResponse.data));
    }

    /**
     * @param appStoreReviewDetailCreateRequest AppStoreReviewDetail representation
     */
    public appStoreReviewDetailsCreateInstanceWithHttpInfo(appStoreReviewDetailCreateRequest: AppStoreReviewDetailCreateRequest, _options?: Configuration): Observable<HttpInfo<AppStoreReviewDetailResponse>> {
        const requestContextPromise = this.requestFactory.appStoreReviewDetailsCreateInstance(appStoreReviewDetailCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appStoreReviewDetailsCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param appStoreReviewDetailCreateRequest AppStoreReviewDetail representation
     */
    public appStoreReviewDetailsCreateInstance(appStoreReviewDetailCreateRequest: AppStoreReviewDetailCreateRequest, _options?: Configuration): Observable<AppStoreReviewDetailResponse> {
        return this.appStoreReviewDetailsCreateInstanceWithHttpInfo(appStoreReviewDetailCreateRequest, _options).pipe(map((apiResponse: HttpInfo<AppStoreReviewDetailResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppStoreReviewDetails the fields to include for returned resources of type appStoreReviewDetails
     * @param include comma-separated list of relationships to include
     * @param fieldsAppStoreReviewAttachments the fields to include for returned resources of type appStoreReviewAttachments
     * @param limitAppStoreReviewAttachments maximum number of related appStoreReviewAttachments returned (when they are included)
     */
    public appStoreReviewDetailsGetInstanceWithHttpInfo(id: string, fieldsAppStoreReviewDetails?: Array<'appStoreReviewAttachments' | 'appStoreVersion' | 'contactEmail' | 'contactFirstName' | 'contactLastName' | 'contactPhone' | 'demoAccountName' | 'demoAccountPassword' | 'demoAccountRequired' | 'notes'>, include?: Array<'appStoreReviewAttachments' | 'appStoreVersion'>, fieldsAppStoreReviewAttachments?: Array<'appStoreReviewDetail' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, limitAppStoreReviewAttachments?: number, _options?: Configuration): Observable<HttpInfo<AppStoreReviewDetailResponse>> {
        const requestContextPromise = this.requestFactory.appStoreReviewDetailsGetInstance(id, fieldsAppStoreReviewDetails, include, fieldsAppStoreReviewAttachments, limitAppStoreReviewAttachments, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appStoreReviewDetailsGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppStoreReviewDetails the fields to include for returned resources of type appStoreReviewDetails
     * @param include comma-separated list of relationships to include
     * @param fieldsAppStoreReviewAttachments the fields to include for returned resources of type appStoreReviewAttachments
     * @param limitAppStoreReviewAttachments maximum number of related appStoreReviewAttachments returned (when they are included)
     */
    public appStoreReviewDetailsGetInstance(id: string, fieldsAppStoreReviewDetails?: Array<'appStoreReviewAttachments' | 'appStoreVersion' | 'contactEmail' | 'contactFirstName' | 'contactLastName' | 'contactPhone' | 'demoAccountName' | 'demoAccountPassword' | 'demoAccountRequired' | 'notes'>, include?: Array<'appStoreReviewAttachments' | 'appStoreVersion'>, fieldsAppStoreReviewAttachments?: Array<'appStoreReviewDetail' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, limitAppStoreReviewAttachments?: number, _options?: Configuration): Observable<AppStoreReviewDetailResponse> {
        return this.appStoreReviewDetailsGetInstanceWithHttpInfo(id, fieldsAppStoreReviewDetails, include, fieldsAppStoreReviewAttachments, limitAppStoreReviewAttachments, _options).pipe(map((apiResponse: HttpInfo<AppStoreReviewDetailResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param appStoreReviewDetailUpdateRequest AppStoreReviewDetail representation
     */
    public appStoreReviewDetailsUpdateInstanceWithHttpInfo(id: string, appStoreReviewDetailUpdateRequest: AppStoreReviewDetailUpdateRequest, _options?: Configuration): Observable<HttpInfo<AppStoreReviewDetailResponse>> {
        const requestContextPromise = this.requestFactory.appStoreReviewDetailsUpdateInstance(id, appStoreReviewDetailUpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appStoreReviewDetailsUpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param appStoreReviewDetailUpdateRequest AppStoreReviewDetail representation
     */
    public appStoreReviewDetailsUpdateInstance(id: string, appStoreReviewDetailUpdateRequest: AppStoreReviewDetailUpdateRequest, _options?: Configuration): Observable<AppStoreReviewDetailResponse> {
        return this.appStoreReviewDetailsUpdateInstanceWithHttpInfo(id, appStoreReviewDetailUpdateRequest, _options).pipe(map((apiResponse: HttpInfo<AppStoreReviewDetailResponse>) => apiResponse.data));
    }

}

import { AppStoreVersionExperimentTreatmentLocalizationsApiRequestFactory, AppStoreVersionExperimentTreatmentLocalizationsApiResponseProcessor} from "../apis/AppStoreVersionExperimentTreatmentLocalizationsApi.ts";
export class ObservableAppStoreVersionExperimentTreatmentLocalizationsApi {
    private requestFactory: AppStoreVersionExperimentTreatmentLocalizationsApiRequestFactory;
    private responseProcessor: AppStoreVersionExperimentTreatmentLocalizationsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: AppStoreVersionExperimentTreatmentLocalizationsApiRequestFactory,
        responseProcessor?: AppStoreVersionExperimentTreatmentLocalizationsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new AppStoreVersionExperimentTreatmentLocalizationsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new AppStoreVersionExperimentTreatmentLocalizationsApiResponseProcessor();
    }

    /**
     * @param id the id of the requested resource
     * @param filterPreviewType filter by attribute \&#39;previewType\&#39;
     * @param filterAppCustomProductPageLocalization filter by id(s) of related \&#39;appCustomProductPageLocalization\&#39;
     * @param filterAppStoreVersionLocalization filter by id(s) of related \&#39;appStoreVersionLocalization\&#39;
     * @param fieldsAppCustomProductPageLocalizations the fields to include for returned resources of type appCustomProductPageLocalizations
     * @param fieldsAppStoreVersionExperimentTreatmentLocalizations the fields to include for returned resources of type appStoreVersionExperimentTreatmentLocalizations
     * @param fieldsAppPreviews the fields to include for returned resources of type appPreviews
     * @param fieldsAppPreviewSets the fields to include for returned resources of type appPreviewSets
     * @param fieldsAppStoreVersionLocalizations the fields to include for returned resources of type appStoreVersionLocalizations
     * @param limit maximum resources per page
     * @param limitAppPreviews maximum number of related appPreviews returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appStoreVersionExperimentTreatmentLocalizationsAppPreviewSetsGetToManyRelatedWithHttpInfo(id: string, filterPreviewType?: Array<'IPHONE_67' | 'IPHONE_61' | 'IPHONE_65' | 'IPHONE_58' | 'IPHONE_55' | 'IPHONE_47' | 'IPHONE_40' | 'IPHONE_35' | 'IPAD_PRO_3GEN_129' | 'IPAD_PRO_3GEN_11' | 'IPAD_PRO_129' | 'IPAD_105' | 'IPAD_97' | 'DESKTOP' | 'APPLE_TV' | 'APPLE_VISION_PRO'>, filterAppCustomProductPageLocalization?: Array<string>, filterAppStoreVersionLocalization?: Array<string>, fieldsAppCustomProductPageLocalizations?: Array<'appCustomProductPageVersion' | 'appPreviewSets' | 'appScreenshotSets' | 'locale' | 'promotionalText'>, fieldsAppStoreVersionExperimentTreatmentLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersionExperimentTreatment' | 'locale'>, fieldsAppPreviews?: Array<'appPreviewSet' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'mimeType' | 'previewFrameTimeCode' | 'previewImage' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded' | 'videoUrl'>, fieldsAppPreviewSets?: Array<'appCustomProductPageLocalization' | 'appPreviews' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'previewType'>, fieldsAppStoreVersionLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersion' | 'description' | 'keywords' | 'locale' | 'marketingUrl' | 'promotionalText' | 'supportUrl' | 'whatsNew'>, limit?: number, limitAppPreviews?: number, include?: Array<'appCustomProductPageLocalization' | 'appPreviews' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization'>, _options?: Configuration): Observable<HttpInfo<AppPreviewSetsResponse>> {
        const requestContextPromise = this.requestFactory.appStoreVersionExperimentTreatmentLocalizationsAppPreviewSetsGetToManyRelated(id, filterPreviewType, filterAppCustomProductPageLocalization, filterAppStoreVersionLocalization, fieldsAppCustomProductPageLocalizations, fieldsAppStoreVersionExperimentTreatmentLocalizations, fieldsAppPreviews, fieldsAppPreviewSets, fieldsAppStoreVersionLocalizations, limit, limitAppPreviews, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appStoreVersionExperimentTreatmentLocalizationsAppPreviewSetsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param filterPreviewType filter by attribute \&#39;previewType\&#39;
     * @param filterAppCustomProductPageLocalization filter by id(s) of related \&#39;appCustomProductPageLocalization\&#39;
     * @param filterAppStoreVersionLocalization filter by id(s) of related \&#39;appStoreVersionLocalization\&#39;
     * @param fieldsAppCustomProductPageLocalizations the fields to include for returned resources of type appCustomProductPageLocalizations
     * @param fieldsAppStoreVersionExperimentTreatmentLocalizations the fields to include for returned resources of type appStoreVersionExperimentTreatmentLocalizations
     * @param fieldsAppPreviews the fields to include for returned resources of type appPreviews
     * @param fieldsAppPreviewSets the fields to include for returned resources of type appPreviewSets
     * @param fieldsAppStoreVersionLocalizations the fields to include for returned resources of type appStoreVersionLocalizations
     * @param limit maximum resources per page
     * @param limitAppPreviews maximum number of related appPreviews returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appStoreVersionExperimentTreatmentLocalizationsAppPreviewSetsGetToManyRelated(id: string, filterPreviewType?: Array<'IPHONE_67' | 'IPHONE_61' | 'IPHONE_65' | 'IPHONE_58' | 'IPHONE_55' | 'IPHONE_47' | 'IPHONE_40' | 'IPHONE_35' | 'IPAD_PRO_3GEN_129' | 'IPAD_PRO_3GEN_11' | 'IPAD_PRO_129' | 'IPAD_105' | 'IPAD_97' | 'DESKTOP' | 'APPLE_TV' | 'APPLE_VISION_PRO'>, filterAppCustomProductPageLocalization?: Array<string>, filterAppStoreVersionLocalization?: Array<string>, fieldsAppCustomProductPageLocalizations?: Array<'appCustomProductPageVersion' | 'appPreviewSets' | 'appScreenshotSets' | 'locale' | 'promotionalText'>, fieldsAppStoreVersionExperimentTreatmentLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersionExperimentTreatment' | 'locale'>, fieldsAppPreviews?: Array<'appPreviewSet' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'mimeType' | 'previewFrameTimeCode' | 'previewImage' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded' | 'videoUrl'>, fieldsAppPreviewSets?: Array<'appCustomProductPageLocalization' | 'appPreviews' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'previewType'>, fieldsAppStoreVersionLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersion' | 'description' | 'keywords' | 'locale' | 'marketingUrl' | 'promotionalText' | 'supportUrl' | 'whatsNew'>, limit?: number, limitAppPreviews?: number, include?: Array<'appCustomProductPageLocalization' | 'appPreviews' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization'>, _options?: Configuration): Observable<AppPreviewSetsResponse> {
        return this.appStoreVersionExperimentTreatmentLocalizationsAppPreviewSetsGetToManyRelatedWithHttpInfo(id, filterPreviewType, filterAppCustomProductPageLocalization, filterAppStoreVersionLocalization, fieldsAppCustomProductPageLocalizations, fieldsAppStoreVersionExperimentTreatmentLocalizations, fieldsAppPreviews, fieldsAppPreviewSets, fieldsAppStoreVersionLocalizations, limit, limitAppPreviews, include, _options).pipe(map((apiResponse: HttpInfo<AppPreviewSetsResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param filterScreenshotDisplayType filter by attribute \&#39;screenshotDisplayType\&#39;
     * @param filterAppCustomProductPageLocalization filter by id(s) of related \&#39;appCustomProductPageLocalization\&#39;
     * @param filterAppStoreVersionLocalization filter by id(s) of related \&#39;appStoreVersionLocalization\&#39;
     * @param fieldsAppScreenshotSets the fields to include for returned resources of type appScreenshotSets
     * @param fieldsAppCustomProductPageLocalizations the fields to include for returned resources of type appCustomProductPageLocalizations
     * @param fieldsAppStoreVersionExperimentTreatmentLocalizations the fields to include for returned resources of type appStoreVersionExperimentTreatmentLocalizations
     * @param fieldsAppScreenshots the fields to include for returned resources of type appScreenshots
     * @param fieldsAppStoreVersionLocalizations the fields to include for returned resources of type appStoreVersionLocalizations
     * @param limit maximum resources per page
     * @param limitAppScreenshots maximum number of related appScreenshots returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appStoreVersionExperimentTreatmentLocalizationsAppScreenshotSetsGetToManyRelatedWithHttpInfo(id: string, filterScreenshotDisplayType?: Array<'APP_IPHONE_67' | 'APP_IPHONE_61' | 'APP_IPHONE_65' | 'APP_IPHONE_58' | 'APP_IPHONE_55' | 'APP_IPHONE_47' | 'APP_IPHONE_40' | 'APP_IPHONE_35' | 'APP_IPAD_PRO_3GEN_129' | 'APP_IPAD_PRO_3GEN_11' | 'APP_IPAD_PRO_129' | 'APP_IPAD_105' | 'APP_IPAD_97' | 'APP_DESKTOP' | 'APP_WATCH_ULTRA' | 'APP_WATCH_SERIES_7' | 'APP_WATCH_SERIES_4' | 'APP_WATCH_SERIES_3' | 'APP_APPLE_TV' | 'APP_APPLE_VISION_PRO' | 'IMESSAGE_APP_IPHONE_67' | 'IMESSAGE_APP_IPHONE_61' | 'IMESSAGE_APP_IPHONE_65' | 'IMESSAGE_APP_IPHONE_58' | 'IMESSAGE_APP_IPHONE_55' | 'IMESSAGE_APP_IPHONE_47' | 'IMESSAGE_APP_IPHONE_40' | 'IMESSAGE_APP_IPAD_PRO_3GEN_129' | 'IMESSAGE_APP_IPAD_PRO_3GEN_11' | 'IMESSAGE_APP_IPAD_PRO_129' | 'IMESSAGE_APP_IPAD_105' | 'IMESSAGE_APP_IPAD_97'>, filterAppCustomProductPageLocalization?: Array<string>, filterAppStoreVersionLocalization?: Array<string>, fieldsAppScreenshotSets?: Array<'appCustomProductPageLocalization' | 'appScreenshots' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'screenshotDisplayType'>, fieldsAppCustomProductPageLocalizations?: Array<'appCustomProductPageVersion' | 'appPreviewSets' | 'appScreenshotSets' | 'locale' | 'promotionalText'>, fieldsAppStoreVersionExperimentTreatmentLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersionExperimentTreatment' | 'locale'>, fieldsAppScreenshots?: Array<'appScreenshotSet' | 'assetDeliveryState' | 'assetToken' | 'assetType' | 'fileName' | 'fileSize' | 'imageAsset' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, fieldsAppStoreVersionLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersion' | 'description' | 'keywords' | 'locale' | 'marketingUrl' | 'promotionalText' | 'supportUrl' | 'whatsNew'>, limit?: number, limitAppScreenshots?: number, include?: Array<'appCustomProductPageLocalization' | 'appScreenshots' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization'>, _options?: Configuration): Observable<HttpInfo<AppScreenshotSetsResponse>> {
        const requestContextPromise = this.requestFactory.appStoreVersionExperimentTreatmentLocalizationsAppScreenshotSetsGetToManyRelated(id, filterScreenshotDisplayType, filterAppCustomProductPageLocalization, filterAppStoreVersionLocalization, fieldsAppScreenshotSets, fieldsAppCustomProductPageLocalizations, fieldsAppStoreVersionExperimentTreatmentLocalizations, fieldsAppScreenshots, fieldsAppStoreVersionLocalizations, limit, limitAppScreenshots, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appStoreVersionExperimentTreatmentLocalizationsAppScreenshotSetsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param filterScreenshotDisplayType filter by attribute \&#39;screenshotDisplayType\&#39;
     * @param filterAppCustomProductPageLocalization filter by id(s) of related \&#39;appCustomProductPageLocalization\&#39;
     * @param filterAppStoreVersionLocalization filter by id(s) of related \&#39;appStoreVersionLocalization\&#39;
     * @param fieldsAppScreenshotSets the fields to include for returned resources of type appScreenshotSets
     * @param fieldsAppCustomProductPageLocalizations the fields to include for returned resources of type appCustomProductPageLocalizations
     * @param fieldsAppStoreVersionExperimentTreatmentLocalizations the fields to include for returned resources of type appStoreVersionExperimentTreatmentLocalizations
     * @param fieldsAppScreenshots the fields to include for returned resources of type appScreenshots
     * @param fieldsAppStoreVersionLocalizations the fields to include for returned resources of type appStoreVersionLocalizations
     * @param limit maximum resources per page
     * @param limitAppScreenshots maximum number of related appScreenshots returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appStoreVersionExperimentTreatmentLocalizationsAppScreenshotSetsGetToManyRelated(id: string, filterScreenshotDisplayType?: Array<'APP_IPHONE_67' | 'APP_IPHONE_61' | 'APP_IPHONE_65' | 'APP_IPHONE_58' | 'APP_IPHONE_55' | 'APP_IPHONE_47' | 'APP_IPHONE_40' | 'APP_IPHONE_35' | 'APP_IPAD_PRO_3GEN_129' | 'APP_IPAD_PRO_3GEN_11' | 'APP_IPAD_PRO_129' | 'APP_IPAD_105' | 'APP_IPAD_97' | 'APP_DESKTOP' | 'APP_WATCH_ULTRA' | 'APP_WATCH_SERIES_7' | 'APP_WATCH_SERIES_4' | 'APP_WATCH_SERIES_3' | 'APP_APPLE_TV' | 'APP_APPLE_VISION_PRO' | 'IMESSAGE_APP_IPHONE_67' | 'IMESSAGE_APP_IPHONE_61' | 'IMESSAGE_APP_IPHONE_65' | 'IMESSAGE_APP_IPHONE_58' | 'IMESSAGE_APP_IPHONE_55' | 'IMESSAGE_APP_IPHONE_47' | 'IMESSAGE_APP_IPHONE_40' | 'IMESSAGE_APP_IPAD_PRO_3GEN_129' | 'IMESSAGE_APP_IPAD_PRO_3GEN_11' | 'IMESSAGE_APP_IPAD_PRO_129' | 'IMESSAGE_APP_IPAD_105' | 'IMESSAGE_APP_IPAD_97'>, filterAppCustomProductPageLocalization?: Array<string>, filterAppStoreVersionLocalization?: Array<string>, fieldsAppScreenshotSets?: Array<'appCustomProductPageLocalization' | 'appScreenshots' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'screenshotDisplayType'>, fieldsAppCustomProductPageLocalizations?: Array<'appCustomProductPageVersion' | 'appPreviewSets' | 'appScreenshotSets' | 'locale' | 'promotionalText'>, fieldsAppStoreVersionExperimentTreatmentLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersionExperimentTreatment' | 'locale'>, fieldsAppScreenshots?: Array<'appScreenshotSet' | 'assetDeliveryState' | 'assetToken' | 'assetType' | 'fileName' | 'fileSize' | 'imageAsset' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, fieldsAppStoreVersionLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersion' | 'description' | 'keywords' | 'locale' | 'marketingUrl' | 'promotionalText' | 'supportUrl' | 'whatsNew'>, limit?: number, limitAppScreenshots?: number, include?: Array<'appCustomProductPageLocalization' | 'appScreenshots' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization'>, _options?: Configuration): Observable<AppScreenshotSetsResponse> {
        return this.appStoreVersionExperimentTreatmentLocalizationsAppScreenshotSetsGetToManyRelatedWithHttpInfo(id, filterScreenshotDisplayType, filterAppCustomProductPageLocalization, filterAppStoreVersionLocalization, fieldsAppScreenshotSets, fieldsAppCustomProductPageLocalizations, fieldsAppStoreVersionExperimentTreatmentLocalizations, fieldsAppScreenshots, fieldsAppStoreVersionLocalizations, limit, limitAppScreenshots, include, _options).pipe(map((apiResponse: HttpInfo<AppScreenshotSetsResponse>) => apiResponse.data));
    }

    /**
     * @param appStoreVersionExperimentTreatmentLocalizationCreateRequest AppStoreVersionExperimentTreatmentLocalization representation
     */
    public appStoreVersionExperimentTreatmentLocalizationsCreateInstanceWithHttpInfo(appStoreVersionExperimentTreatmentLocalizationCreateRequest: AppStoreVersionExperimentTreatmentLocalizationCreateRequest, _options?: Configuration): Observable<HttpInfo<AppStoreVersionExperimentTreatmentLocalizationResponse>> {
        const requestContextPromise = this.requestFactory.appStoreVersionExperimentTreatmentLocalizationsCreateInstance(appStoreVersionExperimentTreatmentLocalizationCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appStoreVersionExperimentTreatmentLocalizationsCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param appStoreVersionExperimentTreatmentLocalizationCreateRequest AppStoreVersionExperimentTreatmentLocalization representation
     */
    public appStoreVersionExperimentTreatmentLocalizationsCreateInstance(appStoreVersionExperimentTreatmentLocalizationCreateRequest: AppStoreVersionExperimentTreatmentLocalizationCreateRequest, _options?: Configuration): Observable<AppStoreVersionExperimentTreatmentLocalizationResponse> {
        return this.appStoreVersionExperimentTreatmentLocalizationsCreateInstanceWithHttpInfo(appStoreVersionExperimentTreatmentLocalizationCreateRequest, _options).pipe(map((apiResponse: HttpInfo<AppStoreVersionExperimentTreatmentLocalizationResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public appStoreVersionExperimentTreatmentLocalizationsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.appStoreVersionExperimentTreatmentLocalizationsDeleteInstance(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appStoreVersionExperimentTreatmentLocalizationsDeleteInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public appStoreVersionExperimentTreatmentLocalizationsDeleteInstance(id: string, _options?: Configuration): Observable<void> {
        return this.appStoreVersionExperimentTreatmentLocalizationsDeleteInstanceWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppStoreVersionExperimentTreatmentLocalizations the fields to include for returned resources of type appStoreVersionExperimentTreatmentLocalizations
     * @param include comma-separated list of relationships to include
     * @param fieldsAppScreenshotSets the fields to include for returned resources of type appScreenshotSets
     * @param fieldsAppPreviewSets the fields to include for returned resources of type appPreviewSets
     * @param limitAppPreviewSets maximum number of related appPreviewSets returned (when they are included)
     * @param limitAppScreenshotSets maximum number of related appScreenshotSets returned (when they are included)
     */
    public appStoreVersionExperimentTreatmentLocalizationsGetInstanceWithHttpInfo(id: string, fieldsAppStoreVersionExperimentTreatmentLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersionExperimentTreatment' | 'locale'>, include?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersionExperimentTreatment'>, fieldsAppScreenshotSets?: Array<'appCustomProductPageLocalization' | 'appScreenshots' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'screenshotDisplayType'>, fieldsAppPreviewSets?: Array<'appCustomProductPageLocalization' | 'appPreviews' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'previewType'>, limitAppPreviewSets?: number, limitAppScreenshotSets?: number, _options?: Configuration): Observable<HttpInfo<AppStoreVersionExperimentTreatmentLocalizationResponse>> {
        const requestContextPromise = this.requestFactory.appStoreVersionExperimentTreatmentLocalizationsGetInstance(id, fieldsAppStoreVersionExperimentTreatmentLocalizations, include, fieldsAppScreenshotSets, fieldsAppPreviewSets, limitAppPreviewSets, limitAppScreenshotSets, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appStoreVersionExperimentTreatmentLocalizationsGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppStoreVersionExperimentTreatmentLocalizations the fields to include for returned resources of type appStoreVersionExperimentTreatmentLocalizations
     * @param include comma-separated list of relationships to include
     * @param fieldsAppScreenshotSets the fields to include for returned resources of type appScreenshotSets
     * @param fieldsAppPreviewSets the fields to include for returned resources of type appPreviewSets
     * @param limitAppPreviewSets maximum number of related appPreviewSets returned (when they are included)
     * @param limitAppScreenshotSets maximum number of related appScreenshotSets returned (when they are included)
     */
    public appStoreVersionExperimentTreatmentLocalizationsGetInstance(id: string, fieldsAppStoreVersionExperimentTreatmentLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersionExperimentTreatment' | 'locale'>, include?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersionExperimentTreatment'>, fieldsAppScreenshotSets?: Array<'appCustomProductPageLocalization' | 'appScreenshots' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'screenshotDisplayType'>, fieldsAppPreviewSets?: Array<'appCustomProductPageLocalization' | 'appPreviews' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'previewType'>, limitAppPreviewSets?: number, limitAppScreenshotSets?: number, _options?: Configuration): Observable<AppStoreVersionExperimentTreatmentLocalizationResponse> {
        return this.appStoreVersionExperimentTreatmentLocalizationsGetInstanceWithHttpInfo(id, fieldsAppStoreVersionExperimentTreatmentLocalizations, include, fieldsAppScreenshotSets, fieldsAppPreviewSets, limitAppPreviewSets, limitAppScreenshotSets, _options).pipe(map((apiResponse: HttpInfo<AppStoreVersionExperimentTreatmentLocalizationResponse>) => apiResponse.data));
    }

}

import { AppStoreVersionExperimentTreatmentsApiRequestFactory, AppStoreVersionExperimentTreatmentsApiResponseProcessor} from "../apis/AppStoreVersionExperimentTreatmentsApi.ts";
export class ObservableAppStoreVersionExperimentTreatmentsApi {
    private requestFactory: AppStoreVersionExperimentTreatmentsApiRequestFactory;
    private responseProcessor: AppStoreVersionExperimentTreatmentsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: AppStoreVersionExperimentTreatmentsApiRequestFactory,
        responseProcessor?: AppStoreVersionExperimentTreatmentsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new AppStoreVersionExperimentTreatmentsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new AppStoreVersionExperimentTreatmentsApiResponseProcessor();
    }

    /**
     * @param id the id of the requested resource
     * @param filterLocale filter by attribute \&#39;locale\&#39;
     * @param fieldsAppScreenshotSets the fields to include for returned resources of type appScreenshotSets
     * @param fieldsAppStoreVersionExperimentTreatments the fields to include for returned resources of type appStoreVersionExperimentTreatments
     * @param fieldsAppStoreVersionExperimentTreatmentLocalizations the fields to include for returned resources of type appStoreVersionExperimentTreatmentLocalizations
     * @param fieldsAppPreviewSets the fields to include for returned resources of type appPreviewSets
     * @param limit maximum resources per page
     * @param limitAppScreenshotSets maximum number of related appScreenshotSets returned (when they are included)
     * @param limitAppPreviewSets maximum number of related appPreviewSets returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appStoreVersionExperimentTreatmentsAppStoreVersionExperimentTreatmentLocalizationsGetToManyRelatedWithHttpInfo(id: string, filterLocale?: Array<string>, fieldsAppScreenshotSets?: Array<'appCustomProductPageLocalization' | 'appScreenshots' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'screenshotDisplayType'>, fieldsAppStoreVersionExperimentTreatments?: Array<'appIcon' | 'appIconName' | 'appStoreVersionExperiment' | 'appStoreVersionExperimentTreatmentLocalizations' | 'appStoreVersionExperimentV2' | 'name' | 'promotedDate'>, fieldsAppStoreVersionExperimentTreatmentLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersionExperimentTreatment' | 'locale'>, fieldsAppPreviewSets?: Array<'appCustomProductPageLocalization' | 'appPreviews' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'previewType'>, limit?: number, limitAppScreenshotSets?: number, limitAppPreviewSets?: number, include?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersionExperimentTreatment'>, _options?: Configuration): Observable<HttpInfo<AppStoreVersionExperimentTreatmentLocalizationsResponse>> {
        const requestContextPromise = this.requestFactory.appStoreVersionExperimentTreatmentsAppStoreVersionExperimentTreatmentLocalizationsGetToManyRelated(id, filterLocale, fieldsAppScreenshotSets, fieldsAppStoreVersionExperimentTreatments, fieldsAppStoreVersionExperimentTreatmentLocalizations, fieldsAppPreviewSets, limit, limitAppScreenshotSets, limitAppPreviewSets, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appStoreVersionExperimentTreatmentsAppStoreVersionExperimentTreatmentLocalizationsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param filterLocale filter by attribute \&#39;locale\&#39;
     * @param fieldsAppScreenshotSets the fields to include for returned resources of type appScreenshotSets
     * @param fieldsAppStoreVersionExperimentTreatments the fields to include for returned resources of type appStoreVersionExperimentTreatments
     * @param fieldsAppStoreVersionExperimentTreatmentLocalizations the fields to include for returned resources of type appStoreVersionExperimentTreatmentLocalizations
     * @param fieldsAppPreviewSets the fields to include for returned resources of type appPreviewSets
     * @param limit maximum resources per page
     * @param limitAppScreenshotSets maximum number of related appScreenshotSets returned (when they are included)
     * @param limitAppPreviewSets maximum number of related appPreviewSets returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appStoreVersionExperimentTreatmentsAppStoreVersionExperimentTreatmentLocalizationsGetToManyRelated(id: string, filterLocale?: Array<string>, fieldsAppScreenshotSets?: Array<'appCustomProductPageLocalization' | 'appScreenshots' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'screenshotDisplayType'>, fieldsAppStoreVersionExperimentTreatments?: Array<'appIcon' | 'appIconName' | 'appStoreVersionExperiment' | 'appStoreVersionExperimentTreatmentLocalizations' | 'appStoreVersionExperimentV2' | 'name' | 'promotedDate'>, fieldsAppStoreVersionExperimentTreatmentLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersionExperimentTreatment' | 'locale'>, fieldsAppPreviewSets?: Array<'appCustomProductPageLocalization' | 'appPreviews' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'previewType'>, limit?: number, limitAppScreenshotSets?: number, limitAppPreviewSets?: number, include?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersionExperimentTreatment'>, _options?: Configuration): Observable<AppStoreVersionExperimentTreatmentLocalizationsResponse> {
        return this.appStoreVersionExperimentTreatmentsAppStoreVersionExperimentTreatmentLocalizationsGetToManyRelatedWithHttpInfo(id, filterLocale, fieldsAppScreenshotSets, fieldsAppStoreVersionExperimentTreatments, fieldsAppStoreVersionExperimentTreatmentLocalizations, fieldsAppPreviewSets, limit, limitAppScreenshotSets, limitAppPreviewSets, include, _options).pipe(map((apiResponse: HttpInfo<AppStoreVersionExperimentTreatmentLocalizationsResponse>) => apiResponse.data));
    }

    /**
     * @param appStoreVersionExperimentTreatmentCreateRequest AppStoreVersionExperimentTreatment representation
     */
    public appStoreVersionExperimentTreatmentsCreateInstanceWithHttpInfo(appStoreVersionExperimentTreatmentCreateRequest: AppStoreVersionExperimentTreatmentCreateRequest, _options?: Configuration): Observable<HttpInfo<AppStoreVersionExperimentTreatmentResponse>> {
        const requestContextPromise = this.requestFactory.appStoreVersionExperimentTreatmentsCreateInstance(appStoreVersionExperimentTreatmentCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appStoreVersionExperimentTreatmentsCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param appStoreVersionExperimentTreatmentCreateRequest AppStoreVersionExperimentTreatment representation
     */
    public appStoreVersionExperimentTreatmentsCreateInstance(appStoreVersionExperimentTreatmentCreateRequest: AppStoreVersionExperimentTreatmentCreateRequest, _options?: Configuration): Observable<AppStoreVersionExperimentTreatmentResponse> {
        return this.appStoreVersionExperimentTreatmentsCreateInstanceWithHttpInfo(appStoreVersionExperimentTreatmentCreateRequest, _options).pipe(map((apiResponse: HttpInfo<AppStoreVersionExperimentTreatmentResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public appStoreVersionExperimentTreatmentsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.appStoreVersionExperimentTreatmentsDeleteInstance(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appStoreVersionExperimentTreatmentsDeleteInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public appStoreVersionExperimentTreatmentsDeleteInstance(id: string, _options?: Configuration): Observable<void> {
        return this.appStoreVersionExperimentTreatmentsDeleteInstanceWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppStoreVersionExperimentTreatments the fields to include for returned resources of type appStoreVersionExperimentTreatments
     * @param include comma-separated list of relationships to include
     * @param fieldsAppStoreVersionExperimentTreatmentLocalizations the fields to include for returned resources of type appStoreVersionExperimentTreatmentLocalizations
     * @param limitAppStoreVersionExperimentTreatmentLocalizations maximum number of related appStoreVersionExperimentTreatmentLocalizations returned (when they are included)
     */
    public appStoreVersionExperimentTreatmentsGetInstanceWithHttpInfo(id: string, fieldsAppStoreVersionExperimentTreatments?: Array<'appIcon' | 'appIconName' | 'appStoreVersionExperiment' | 'appStoreVersionExperimentTreatmentLocalizations' | 'appStoreVersionExperimentV2' | 'name' | 'promotedDate'>, include?: Array<'appStoreVersionExperiment' | 'appStoreVersionExperimentTreatmentLocalizations' | 'appStoreVersionExperimentV2'>, fieldsAppStoreVersionExperimentTreatmentLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersionExperimentTreatment' | 'locale'>, limitAppStoreVersionExperimentTreatmentLocalizations?: number, _options?: Configuration): Observable<HttpInfo<AppStoreVersionExperimentTreatmentResponse>> {
        const requestContextPromise = this.requestFactory.appStoreVersionExperimentTreatmentsGetInstance(id, fieldsAppStoreVersionExperimentTreatments, include, fieldsAppStoreVersionExperimentTreatmentLocalizations, limitAppStoreVersionExperimentTreatmentLocalizations, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appStoreVersionExperimentTreatmentsGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppStoreVersionExperimentTreatments the fields to include for returned resources of type appStoreVersionExperimentTreatments
     * @param include comma-separated list of relationships to include
     * @param fieldsAppStoreVersionExperimentTreatmentLocalizations the fields to include for returned resources of type appStoreVersionExperimentTreatmentLocalizations
     * @param limitAppStoreVersionExperimentTreatmentLocalizations maximum number of related appStoreVersionExperimentTreatmentLocalizations returned (when they are included)
     */
    public appStoreVersionExperimentTreatmentsGetInstance(id: string, fieldsAppStoreVersionExperimentTreatments?: Array<'appIcon' | 'appIconName' | 'appStoreVersionExperiment' | 'appStoreVersionExperimentTreatmentLocalizations' | 'appStoreVersionExperimentV2' | 'name' | 'promotedDate'>, include?: Array<'appStoreVersionExperiment' | 'appStoreVersionExperimentTreatmentLocalizations' | 'appStoreVersionExperimentV2'>, fieldsAppStoreVersionExperimentTreatmentLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersionExperimentTreatment' | 'locale'>, limitAppStoreVersionExperimentTreatmentLocalizations?: number, _options?: Configuration): Observable<AppStoreVersionExperimentTreatmentResponse> {
        return this.appStoreVersionExperimentTreatmentsGetInstanceWithHttpInfo(id, fieldsAppStoreVersionExperimentTreatments, include, fieldsAppStoreVersionExperimentTreatmentLocalizations, limitAppStoreVersionExperimentTreatmentLocalizations, _options).pipe(map((apiResponse: HttpInfo<AppStoreVersionExperimentTreatmentResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param appStoreVersionExperimentTreatmentUpdateRequest AppStoreVersionExperimentTreatment representation
     */
    public appStoreVersionExperimentTreatmentsUpdateInstanceWithHttpInfo(id: string, appStoreVersionExperimentTreatmentUpdateRequest: AppStoreVersionExperimentTreatmentUpdateRequest, _options?: Configuration): Observable<HttpInfo<AppStoreVersionExperimentTreatmentResponse>> {
        const requestContextPromise = this.requestFactory.appStoreVersionExperimentTreatmentsUpdateInstance(id, appStoreVersionExperimentTreatmentUpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appStoreVersionExperimentTreatmentsUpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param appStoreVersionExperimentTreatmentUpdateRequest AppStoreVersionExperimentTreatment representation
     */
    public appStoreVersionExperimentTreatmentsUpdateInstance(id: string, appStoreVersionExperimentTreatmentUpdateRequest: AppStoreVersionExperimentTreatmentUpdateRequest, _options?: Configuration): Observable<AppStoreVersionExperimentTreatmentResponse> {
        return this.appStoreVersionExperimentTreatmentsUpdateInstanceWithHttpInfo(id, appStoreVersionExperimentTreatmentUpdateRequest, _options).pipe(map((apiResponse: HttpInfo<AppStoreVersionExperimentTreatmentResponse>) => apiResponse.data));
    }

}

import { AppStoreVersionExperimentsApiRequestFactory, AppStoreVersionExperimentsApiResponseProcessor} from "../apis/AppStoreVersionExperimentsApi.ts";
export class ObservableAppStoreVersionExperimentsApi {
    private requestFactory: AppStoreVersionExperimentsApiRequestFactory;
    private responseProcessor: AppStoreVersionExperimentsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: AppStoreVersionExperimentsApiRequestFactory,
        responseProcessor?: AppStoreVersionExperimentsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new AppStoreVersionExperimentsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new AppStoreVersionExperimentsApiResponseProcessor();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppStoreVersionExperiments the fields to include for returned resources of type appStoreVersionExperiments
     * @param fieldsAppStoreVersionExperimentTreatments the fields to include for returned resources of type appStoreVersionExperimentTreatments
     * @param fieldsAppStoreVersionExperimentTreatmentLocalizations the fields to include for returned resources of type appStoreVersionExperimentTreatmentLocalizations
     * @param limit maximum resources per page
     * @param limitAppStoreVersionExperimentTreatmentLocalizations maximum number of related appStoreVersionExperimentTreatmentLocalizations returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appStoreVersionExperimentsAppStoreVersionExperimentTreatmentsGetToManyRelatedWithHttpInfo(id: string, fieldsAppStoreVersionExperiments?: Array<'app' | 'appStoreVersion' | 'appStoreVersionExperimentTreatments' | 'controlVersions' | 'endDate' | 'latestControlVersion' | 'name' | 'platform' | 'reviewRequired' | 'startDate' | 'started' | 'state' | 'trafficProportion'>, fieldsAppStoreVersionExperimentTreatments?: Array<'appIcon' | 'appIconName' | 'appStoreVersionExperiment' | 'appStoreVersionExperimentTreatmentLocalizations' | 'appStoreVersionExperimentV2' | 'name' | 'promotedDate'>, fieldsAppStoreVersionExperimentTreatmentLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersionExperimentTreatment' | 'locale'>, limit?: number, limitAppStoreVersionExperimentTreatmentLocalizations?: number, include?: Array<'appStoreVersionExperiment' | 'appStoreVersionExperimentTreatmentLocalizations' | 'appStoreVersionExperimentV2'>, _options?: Configuration): Observable<HttpInfo<AppStoreVersionExperimentTreatmentsResponse>> {
        const requestContextPromise = this.requestFactory.appStoreVersionExperimentsAppStoreVersionExperimentTreatmentsGetToManyRelated(id, fieldsAppStoreVersionExperiments, fieldsAppStoreVersionExperimentTreatments, fieldsAppStoreVersionExperimentTreatmentLocalizations, limit, limitAppStoreVersionExperimentTreatmentLocalizations, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appStoreVersionExperimentsAppStoreVersionExperimentTreatmentsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppStoreVersionExperiments the fields to include for returned resources of type appStoreVersionExperiments
     * @param fieldsAppStoreVersionExperimentTreatments the fields to include for returned resources of type appStoreVersionExperimentTreatments
     * @param fieldsAppStoreVersionExperimentTreatmentLocalizations the fields to include for returned resources of type appStoreVersionExperimentTreatmentLocalizations
     * @param limit maximum resources per page
     * @param limitAppStoreVersionExperimentTreatmentLocalizations maximum number of related appStoreVersionExperimentTreatmentLocalizations returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appStoreVersionExperimentsAppStoreVersionExperimentTreatmentsGetToManyRelated(id: string, fieldsAppStoreVersionExperiments?: Array<'app' | 'appStoreVersion' | 'appStoreVersionExperimentTreatments' | 'controlVersions' | 'endDate' | 'latestControlVersion' | 'name' | 'platform' | 'reviewRequired' | 'startDate' | 'started' | 'state' | 'trafficProportion'>, fieldsAppStoreVersionExperimentTreatments?: Array<'appIcon' | 'appIconName' | 'appStoreVersionExperiment' | 'appStoreVersionExperimentTreatmentLocalizations' | 'appStoreVersionExperimentV2' | 'name' | 'promotedDate'>, fieldsAppStoreVersionExperimentTreatmentLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersionExperimentTreatment' | 'locale'>, limit?: number, limitAppStoreVersionExperimentTreatmentLocalizations?: number, include?: Array<'appStoreVersionExperiment' | 'appStoreVersionExperimentTreatmentLocalizations' | 'appStoreVersionExperimentV2'>, _options?: Configuration): Observable<AppStoreVersionExperimentTreatmentsResponse> {
        return this.appStoreVersionExperimentsAppStoreVersionExperimentTreatmentsGetToManyRelatedWithHttpInfo(id, fieldsAppStoreVersionExperiments, fieldsAppStoreVersionExperimentTreatments, fieldsAppStoreVersionExperimentTreatmentLocalizations, limit, limitAppStoreVersionExperimentTreatmentLocalizations, include, _options).pipe(map((apiResponse: HttpInfo<AppStoreVersionExperimentTreatmentsResponse>) => apiResponse.data));
    }

    /**
     * @param appStoreVersionExperimentCreateRequest AppStoreVersionExperiment representation
     */
    public appStoreVersionExperimentsCreateInstanceWithHttpInfo(appStoreVersionExperimentCreateRequest: AppStoreVersionExperimentCreateRequest, _options?: Configuration): Observable<HttpInfo<AppStoreVersionExperimentResponse>> {
        const requestContextPromise = this.requestFactory.appStoreVersionExperimentsCreateInstance(appStoreVersionExperimentCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appStoreVersionExperimentsCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param appStoreVersionExperimentCreateRequest AppStoreVersionExperiment representation
     */
    public appStoreVersionExperimentsCreateInstance(appStoreVersionExperimentCreateRequest: AppStoreVersionExperimentCreateRequest, _options?: Configuration): Observable<AppStoreVersionExperimentResponse> {
        return this.appStoreVersionExperimentsCreateInstanceWithHttpInfo(appStoreVersionExperimentCreateRequest, _options).pipe(map((apiResponse: HttpInfo<AppStoreVersionExperimentResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public appStoreVersionExperimentsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.appStoreVersionExperimentsDeleteInstance(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appStoreVersionExperimentsDeleteInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public appStoreVersionExperimentsDeleteInstance(id: string, _options?: Configuration): Observable<void> {
        return this.appStoreVersionExperimentsDeleteInstanceWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppStoreVersionExperiments the fields to include for returned resources of type appStoreVersionExperiments
     * @param include comma-separated list of relationships to include
     * @param fieldsAppStoreVersionExperimentTreatments the fields to include for returned resources of type appStoreVersionExperimentTreatments
     * @param limitAppStoreVersionExperimentTreatments maximum number of related appStoreVersionExperimentTreatments returned (when they are included)
     */
    public appStoreVersionExperimentsGetInstanceWithHttpInfo(id: string, fieldsAppStoreVersionExperiments?: Array<'appStoreVersion' | 'appStoreVersionExperimentTreatments' | 'endDate' | 'name' | 'reviewRequired' | 'startDate' | 'started' | 'state' | 'trafficProportion'>, include?: Array<'appStoreVersion' | 'appStoreVersionExperimentTreatments'>, fieldsAppStoreVersionExperimentTreatments?: Array<'appIcon' | 'appIconName' | 'appStoreVersionExperiment' | 'appStoreVersionExperimentTreatmentLocalizations' | 'appStoreVersionExperimentV2' | 'name' | 'promotedDate'>, limitAppStoreVersionExperimentTreatments?: number, _options?: Configuration): Observable<HttpInfo<AppStoreVersionExperimentResponse>> {
        const requestContextPromise = this.requestFactory.appStoreVersionExperimentsGetInstance(id, fieldsAppStoreVersionExperiments, include, fieldsAppStoreVersionExperimentTreatments, limitAppStoreVersionExperimentTreatments, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appStoreVersionExperimentsGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppStoreVersionExperiments the fields to include for returned resources of type appStoreVersionExperiments
     * @param include comma-separated list of relationships to include
     * @param fieldsAppStoreVersionExperimentTreatments the fields to include for returned resources of type appStoreVersionExperimentTreatments
     * @param limitAppStoreVersionExperimentTreatments maximum number of related appStoreVersionExperimentTreatments returned (when they are included)
     */
    public appStoreVersionExperimentsGetInstance(id: string, fieldsAppStoreVersionExperiments?: Array<'appStoreVersion' | 'appStoreVersionExperimentTreatments' | 'endDate' | 'name' | 'reviewRequired' | 'startDate' | 'started' | 'state' | 'trafficProportion'>, include?: Array<'appStoreVersion' | 'appStoreVersionExperimentTreatments'>, fieldsAppStoreVersionExperimentTreatments?: Array<'appIcon' | 'appIconName' | 'appStoreVersionExperiment' | 'appStoreVersionExperimentTreatmentLocalizations' | 'appStoreVersionExperimentV2' | 'name' | 'promotedDate'>, limitAppStoreVersionExperimentTreatments?: number, _options?: Configuration): Observable<AppStoreVersionExperimentResponse> {
        return this.appStoreVersionExperimentsGetInstanceWithHttpInfo(id, fieldsAppStoreVersionExperiments, include, fieldsAppStoreVersionExperimentTreatments, limitAppStoreVersionExperimentTreatments, _options).pipe(map((apiResponse: HttpInfo<AppStoreVersionExperimentResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param appStoreVersionExperimentUpdateRequest AppStoreVersionExperiment representation
     */
    public appStoreVersionExperimentsUpdateInstanceWithHttpInfo(id: string, appStoreVersionExperimentUpdateRequest: AppStoreVersionExperimentUpdateRequest, _options?: Configuration): Observable<HttpInfo<AppStoreVersionExperimentResponse>> {
        const requestContextPromise = this.requestFactory.appStoreVersionExperimentsUpdateInstance(id, appStoreVersionExperimentUpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appStoreVersionExperimentsUpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param appStoreVersionExperimentUpdateRequest AppStoreVersionExperiment representation
     */
    public appStoreVersionExperimentsUpdateInstance(id: string, appStoreVersionExperimentUpdateRequest: AppStoreVersionExperimentUpdateRequest, _options?: Configuration): Observable<AppStoreVersionExperimentResponse> {
        return this.appStoreVersionExperimentsUpdateInstanceWithHttpInfo(id, appStoreVersionExperimentUpdateRequest, _options).pipe(map((apiResponse: HttpInfo<AppStoreVersionExperimentResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppStoreVersionExperiments the fields to include for returned resources of type appStoreVersionExperiments
     * @param fieldsAppStoreVersionExperimentTreatments the fields to include for returned resources of type appStoreVersionExperimentTreatments
     * @param fieldsAppStoreVersionExperimentTreatmentLocalizations the fields to include for returned resources of type appStoreVersionExperimentTreatmentLocalizations
     * @param limit maximum resources per page
     * @param limitAppStoreVersionExperimentTreatmentLocalizations maximum number of related appStoreVersionExperimentTreatmentLocalizations returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appStoreVersionExperimentsV2AppStoreVersionExperimentTreatmentsGetToManyRelatedWithHttpInfo(id: string, fieldsAppStoreVersionExperiments?: Array<'app' | 'appStoreVersion' | 'appStoreVersionExperimentTreatments' | 'controlVersions' | 'endDate' | 'latestControlVersion' | 'name' | 'platform' | 'reviewRequired' | 'startDate' | 'started' | 'state' | 'trafficProportion'>, fieldsAppStoreVersionExperimentTreatments?: Array<'appIcon' | 'appIconName' | 'appStoreVersionExperiment' | 'appStoreVersionExperimentTreatmentLocalizations' | 'appStoreVersionExperimentV2' | 'name' | 'promotedDate'>, fieldsAppStoreVersionExperimentTreatmentLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersionExperimentTreatment' | 'locale'>, limit?: number, limitAppStoreVersionExperimentTreatmentLocalizations?: number, include?: Array<'appStoreVersionExperiment' | 'appStoreVersionExperimentTreatmentLocalizations' | 'appStoreVersionExperimentV2'>, _options?: Configuration): Observable<HttpInfo<AppStoreVersionExperimentTreatmentsResponse>> {
        const requestContextPromise = this.requestFactory.appStoreVersionExperimentsV2AppStoreVersionExperimentTreatmentsGetToManyRelated(id, fieldsAppStoreVersionExperiments, fieldsAppStoreVersionExperimentTreatments, fieldsAppStoreVersionExperimentTreatmentLocalizations, limit, limitAppStoreVersionExperimentTreatmentLocalizations, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appStoreVersionExperimentsV2AppStoreVersionExperimentTreatmentsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppStoreVersionExperiments the fields to include for returned resources of type appStoreVersionExperiments
     * @param fieldsAppStoreVersionExperimentTreatments the fields to include for returned resources of type appStoreVersionExperimentTreatments
     * @param fieldsAppStoreVersionExperimentTreatmentLocalizations the fields to include for returned resources of type appStoreVersionExperimentTreatmentLocalizations
     * @param limit maximum resources per page
     * @param limitAppStoreVersionExperimentTreatmentLocalizations maximum number of related appStoreVersionExperimentTreatmentLocalizations returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appStoreVersionExperimentsV2AppStoreVersionExperimentTreatmentsGetToManyRelated(id: string, fieldsAppStoreVersionExperiments?: Array<'app' | 'appStoreVersion' | 'appStoreVersionExperimentTreatments' | 'controlVersions' | 'endDate' | 'latestControlVersion' | 'name' | 'platform' | 'reviewRequired' | 'startDate' | 'started' | 'state' | 'trafficProportion'>, fieldsAppStoreVersionExperimentTreatments?: Array<'appIcon' | 'appIconName' | 'appStoreVersionExperiment' | 'appStoreVersionExperimentTreatmentLocalizations' | 'appStoreVersionExperimentV2' | 'name' | 'promotedDate'>, fieldsAppStoreVersionExperimentTreatmentLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersionExperimentTreatment' | 'locale'>, limit?: number, limitAppStoreVersionExperimentTreatmentLocalizations?: number, include?: Array<'appStoreVersionExperiment' | 'appStoreVersionExperimentTreatmentLocalizations' | 'appStoreVersionExperimentV2'>, _options?: Configuration): Observable<AppStoreVersionExperimentTreatmentsResponse> {
        return this.appStoreVersionExperimentsV2AppStoreVersionExperimentTreatmentsGetToManyRelatedWithHttpInfo(id, fieldsAppStoreVersionExperiments, fieldsAppStoreVersionExperimentTreatments, fieldsAppStoreVersionExperimentTreatmentLocalizations, limit, limitAppStoreVersionExperimentTreatmentLocalizations, include, _options).pipe(map((apiResponse: HttpInfo<AppStoreVersionExperimentTreatmentsResponse>) => apiResponse.data));
    }

    /**
     * @param appStoreVersionExperimentV2CreateRequest AppStoreVersionExperiment representation
     */
    public appStoreVersionExperimentsV2CreateInstanceWithHttpInfo(appStoreVersionExperimentV2CreateRequest: AppStoreVersionExperimentV2CreateRequest, _options?: Configuration): Observable<HttpInfo<AppStoreVersionExperimentV2Response>> {
        const requestContextPromise = this.requestFactory.appStoreVersionExperimentsV2CreateInstance(appStoreVersionExperimentV2CreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appStoreVersionExperimentsV2CreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param appStoreVersionExperimentV2CreateRequest AppStoreVersionExperiment representation
     */
    public appStoreVersionExperimentsV2CreateInstance(appStoreVersionExperimentV2CreateRequest: AppStoreVersionExperimentV2CreateRequest, _options?: Configuration): Observable<AppStoreVersionExperimentV2Response> {
        return this.appStoreVersionExperimentsV2CreateInstanceWithHttpInfo(appStoreVersionExperimentV2CreateRequest, _options).pipe(map((apiResponse: HttpInfo<AppStoreVersionExperimentV2Response>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public appStoreVersionExperimentsV2DeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.appStoreVersionExperimentsV2DeleteInstance(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appStoreVersionExperimentsV2DeleteInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public appStoreVersionExperimentsV2DeleteInstance(id: string, _options?: Configuration): Observable<void> {
        return this.appStoreVersionExperimentsV2DeleteInstanceWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppStoreVersionExperiments the fields to include for returned resources of type appStoreVersionExperiments
     * @param include comma-separated list of relationships to include
     * @param fieldsAppStoreVersionExperimentTreatments the fields to include for returned resources of type appStoreVersionExperimentTreatments
     * @param limitAppStoreVersionExperimentTreatments maximum number of related appStoreVersionExperimentTreatments returned (when they are included)
     * @param limitControlVersions maximum number of related controlVersions returned (when they are included)
     */
    public appStoreVersionExperimentsV2GetInstanceWithHttpInfo(id: string, fieldsAppStoreVersionExperiments?: Array<'app' | 'appStoreVersionExperimentTreatments' | 'controlVersions' | 'endDate' | 'latestControlVersion' | 'name' | 'platform' | 'reviewRequired' | 'startDate' | 'started' | 'state' | 'trafficProportion'>, include?: Array<'app' | 'appStoreVersionExperimentTreatments' | 'controlVersions' | 'latestControlVersion'>, fieldsAppStoreVersionExperimentTreatments?: Array<'appIcon' | 'appIconName' | 'appStoreVersionExperiment' | 'appStoreVersionExperimentTreatmentLocalizations' | 'appStoreVersionExperimentV2' | 'name' | 'promotedDate'>, limitAppStoreVersionExperimentTreatments?: number, limitControlVersions?: number, _options?: Configuration): Observable<HttpInfo<AppStoreVersionExperimentV2Response>> {
        const requestContextPromise = this.requestFactory.appStoreVersionExperimentsV2GetInstance(id, fieldsAppStoreVersionExperiments, include, fieldsAppStoreVersionExperimentTreatments, limitAppStoreVersionExperimentTreatments, limitControlVersions, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appStoreVersionExperimentsV2GetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppStoreVersionExperiments the fields to include for returned resources of type appStoreVersionExperiments
     * @param include comma-separated list of relationships to include
     * @param fieldsAppStoreVersionExperimentTreatments the fields to include for returned resources of type appStoreVersionExperimentTreatments
     * @param limitAppStoreVersionExperimentTreatments maximum number of related appStoreVersionExperimentTreatments returned (when they are included)
     * @param limitControlVersions maximum number of related controlVersions returned (when they are included)
     */
    public appStoreVersionExperimentsV2GetInstance(id: string, fieldsAppStoreVersionExperiments?: Array<'app' | 'appStoreVersionExperimentTreatments' | 'controlVersions' | 'endDate' | 'latestControlVersion' | 'name' | 'platform' | 'reviewRequired' | 'startDate' | 'started' | 'state' | 'trafficProportion'>, include?: Array<'app' | 'appStoreVersionExperimentTreatments' | 'controlVersions' | 'latestControlVersion'>, fieldsAppStoreVersionExperimentTreatments?: Array<'appIcon' | 'appIconName' | 'appStoreVersionExperiment' | 'appStoreVersionExperimentTreatmentLocalizations' | 'appStoreVersionExperimentV2' | 'name' | 'promotedDate'>, limitAppStoreVersionExperimentTreatments?: number, limitControlVersions?: number, _options?: Configuration): Observable<AppStoreVersionExperimentV2Response> {
        return this.appStoreVersionExperimentsV2GetInstanceWithHttpInfo(id, fieldsAppStoreVersionExperiments, include, fieldsAppStoreVersionExperimentTreatments, limitAppStoreVersionExperimentTreatments, limitControlVersions, _options).pipe(map((apiResponse: HttpInfo<AppStoreVersionExperimentV2Response>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param appStoreVersionExperimentV2UpdateRequest AppStoreVersionExperiment representation
     */
    public appStoreVersionExperimentsV2UpdateInstanceWithHttpInfo(id: string, appStoreVersionExperimentV2UpdateRequest: AppStoreVersionExperimentV2UpdateRequest, _options?: Configuration): Observable<HttpInfo<AppStoreVersionExperimentV2Response>> {
        const requestContextPromise = this.requestFactory.appStoreVersionExperimentsV2UpdateInstance(id, appStoreVersionExperimentV2UpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appStoreVersionExperimentsV2UpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param appStoreVersionExperimentV2UpdateRequest AppStoreVersionExperiment representation
     */
    public appStoreVersionExperimentsV2UpdateInstance(id: string, appStoreVersionExperimentV2UpdateRequest: AppStoreVersionExperimentV2UpdateRequest, _options?: Configuration): Observable<AppStoreVersionExperimentV2Response> {
        return this.appStoreVersionExperimentsV2UpdateInstanceWithHttpInfo(id, appStoreVersionExperimentV2UpdateRequest, _options).pipe(map((apiResponse: HttpInfo<AppStoreVersionExperimentV2Response>) => apiResponse.data));
    }

}

import { AppStoreVersionLocalizationsApiRequestFactory, AppStoreVersionLocalizationsApiResponseProcessor} from "../apis/AppStoreVersionLocalizationsApi.ts";
export class ObservableAppStoreVersionLocalizationsApi {
    private requestFactory: AppStoreVersionLocalizationsApiRequestFactory;
    private responseProcessor: AppStoreVersionLocalizationsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: AppStoreVersionLocalizationsApiRequestFactory,
        responseProcessor?: AppStoreVersionLocalizationsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new AppStoreVersionLocalizationsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new AppStoreVersionLocalizationsApiResponseProcessor();
    }

    /**
     * @param id the id of the requested resource
     * @param filterPreviewType filter by attribute \&#39;previewType\&#39;
     * @param filterAppCustomProductPageLocalization filter by id(s) of related \&#39;appCustomProductPageLocalization\&#39;
     * @param filterAppStoreVersionExperimentTreatmentLocalization filter by id(s) of related \&#39;appStoreVersionExperimentTreatmentLocalization\&#39;
     * @param fieldsAppCustomProductPageLocalizations the fields to include for returned resources of type appCustomProductPageLocalizations
     * @param fieldsAppStoreVersionExperimentTreatmentLocalizations the fields to include for returned resources of type appStoreVersionExperimentTreatmentLocalizations
     * @param fieldsAppPreviews the fields to include for returned resources of type appPreviews
     * @param fieldsAppPreviewSets the fields to include for returned resources of type appPreviewSets
     * @param fieldsAppStoreVersionLocalizations the fields to include for returned resources of type appStoreVersionLocalizations
     * @param limit maximum resources per page
     * @param limitAppPreviews maximum number of related appPreviews returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appStoreVersionLocalizationsAppPreviewSetsGetToManyRelatedWithHttpInfo(id: string, filterPreviewType?: Array<'IPHONE_67' | 'IPHONE_61' | 'IPHONE_65' | 'IPHONE_58' | 'IPHONE_55' | 'IPHONE_47' | 'IPHONE_40' | 'IPHONE_35' | 'IPAD_PRO_3GEN_129' | 'IPAD_PRO_3GEN_11' | 'IPAD_PRO_129' | 'IPAD_105' | 'IPAD_97' | 'DESKTOP' | 'APPLE_TV' | 'APPLE_VISION_PRO'>, filterAppCustomProductPageLocalization?: Array<string>, filterAppStoreVersionExperimentTreatmentLocalization?: Array<string>, fieldsAppCustomProductPageLocalizations?: Array<'appCustomProductPageVersion' | 'appPreviewSets' | 'appScreenshotSets' | 'locale' | 'promotionalText'>, fieldsAppStoreVersionExperimentTreatmentLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersionExperimentTreatment' | 'locale'>, fieldsAppPreviews?: Array<'appPreviewSet' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'mimeType' | 'previewFrameTimeCode' | 'previewImage' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded' | 'videoUrl'>, fieldsAppPreviewSets?: Array<'appCustomProductPageLocalization' | 'appPreviews' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'previewType'>, fieldsAppStoreVersionLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersion' | 'description' | 'keywords' | 'locale' | 'marketingUrl' | 'promotionalText' | 'supportUrl' | 'whatsNew'>, limit?: number, limitAppPreviews?: number, include?: Array<'appCustomProductPageLocalization' | 'appPreviews' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization'>, _options?: Configuration): Observable<HttpInfo<AppPreviewSetsResponse>> {
        const requestContextPromise = this.requestFactory.appStoreVersionLocalizationsAppPreviewSetsGetToManyRelated(id, filterPreviewType, filterAppCustomProductPageLocalization, filterAppStoreVersionExperimentTreatmentLocalization, fieldsAppCustomProductPageLocalizations, fieldsAppStoreVersionExperimentTreatmentLocalizations, fieldsAppPreviews, fieldsAppPreviewSets, fieldsAppStoreVersionLocalizations, limit, limitAppPreviews, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appStoreVersionLocalizationsAppPreviewSetsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param filterPreviewType filter by attribute \&#39;previewType\&#39;
     * @param filterAppCustomProductPageLocalization filter by id(s) of related \&#39;appCustomProductPageLocalization\&#39;
     * @param filterAppStoreVersionExperimentTreatmentLocalization filter by id(s) of related \&#39;appStoreVersionExperimentTreatmentLocalization\&#39;
     * @param fieldsAppCustomProductPageLocalizations the fields to include for returned resources of type appCustomProductPageLocalizations
     * @param fieldsAppStoreVersionExperimentTreatmentLocalizations the fields to include for returned resources of type appStoreVersionExperimentTreatmentLocalizations
     * @param fieldsAppPreviews the fields to include for returned resources of type appPreviews
     * @param fieldsAppPreviewSets the fields to include for returned resources of type appPreviewSets
     * @param fieldsAppStoreVersionLocalizations the fields to include for returned resources of type appStoreVersionLocalizations
     * @param limit maximum resources per page
     * @param limitAppPreviews maximum number of related appPreviews returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appStoreVersionLocalizationsAppPreviewSetsGetToManyRelated(id: string, filterPreviewType?: Array<'IPHONE_67' | 'IPHONE_61' | 'IPHONE_65' | 'IPHONE_58' | 'IPHONE_55' | 'IPHONE_47' | 'IPHONE_40' | 'IPHONE_35' | 'IPAD_PRO_3GEN_129' | 'IPAD_PRO_3GEN_11' | 'IPAD_PRO_129' | 'IPAD_105' | 'IPAD_97' | 'DESKTOP' | 'APPLE_TV' | 'APPLE_VISION_PRO'>, filterAppCustomProductPageLocalization?: Array<string>, filterAppStoreVersionExperimentTreatmentLocalization?: Array<string>, fieldsAppCustomProductPageLocalizations?: Array<'appCustomProductPageVersion' | 'appPreviewSets' | 'appScreenshotSets' | 'locale' | 'promotionalText'>, fieldsAppStoreVersionExperimentTreatmentLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersionExperimentTreatment' | 'locale'>, fieldsAppPreviews?: Array<'appPreviewSet' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'mimeType' | 'previewFrameTimeCode' | 'previewImage' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded' | 'videoUrl'>, fieldsAppPreviewSets?: Array<'appCustomProductPageLocalization' | 'appPreviews' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'previewType'>, fieldsAppStoreVersionLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersion' | 'description' | 'keywords' | 'locale' | 'marketingUrl' | 'promotionalText' | 'supportUrl' | 'whatsNew'>, limit?: number, limitAppPreviews?: number, include?: Array<'appCustomProductPageLocalization' | 'appPreviews' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization'>, _options?: Configuration): Observable<AppPreviewSetsResponse> {
        return this.appStoreVersionLocalizationsAppPreviewSetsGetToManyRelatedWithHttpInfo(id, filterPreviewType, filterAppCustomProductPageLocalization, filterAppStoreVersionExperimentTreatmentLocalization, fieldsAppCustomProductPageLocalizations, fieldsAppStoreVersionExperimentTreatmentLocalizations, fieldsAppPreviews, fieldsAppPreviewSets, fieldsAppStoreVersionLocalizations, limit, limitAppPreviews, include, _options).pipe(map((apiResponse: HttpInfo<AppPreviewSetsResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param filterScreenshotDisplayType filter by attribute \&#39;screenshotDisplayType\&#39;
     * @param filterAppCustomProductPageLocalization filter by id(s) of related \&#39;appCustomProductPageLocalization\&#39;
     * @param filterAppStoreVersionExperimentTreatmentLocalization filter by id(s) of related \&#39;appStoreVersionExperimentTreatmentLocalization\&#39;
     * @param fieldsAppScreenshotSets the fields to include for returned resources of type appScreenshotSets
     * @param fieldsAppCustomProductPageLocalizations the fields to include for returned resources of type appCustomProductPageLocalizations
     * @param fieldsAppStoreVersionExperimentTreatmentLocalizations the fields to include for returned resources of type appStoreVersionExperimentTreatmentLocalizations
     * @param fieldsAppScreenshots the fields to include for returned resources of type appScreenshots
     * @param fieldsAppStoreVersionLocalizations the fields to include for returned resources of type appStoreVersionLocalizations
     * @param limit maximum resources per page
     * @param limitAppScreenshots maximum number of related appScreenshots returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appStoreVersionLocalizationsAppScreenshotSetsGetToManyRelatedWithHttpInfo(id: string, filterScreenshotDisplayType?: Array<'APP_IPHONE_67' | 'APP_IPHONE_61' | 'APP_IPHONE_65' | 'APP_IPHONE_58' | 'APP_IPHONE_55' | 'APP_IPHONE_47' | 'APP_IPHONE_40' | 'APP_IPHONE_35' | 'APP_IPAD_PRO_3GEN_129' | 'APP_IPAD_PRO_3GEN_11' | 'APP_IPAD_PRO_129' | 'APP_IPAD_105' | 'APP_IPAD_97' | 'APP_DESKTOP' | 'APP_WATCH_ULTRA' | 'APP_WATCH_SERIES_7' | 'APP_WATCH_SERIES_4' | 'APP_WATCH_SERIES_3' | 'APP_APPLE_TV' | 'APP_APPLE_VISION_PRO' | 'IMESSAGE_APP_IPHONE_67' | 'IMESSAGE_APP_IPHONE_61' | 'IMESSAGE_APP_IPHONE_65' | 'IMESSAGE_APP_IPHONE_58' | 'IMESSAGE_APP_IPHONE_55' | 'IMESSAGE_APP_IPHONE_47' | 'IMESSAGE_APP_IPHONE_40' | 'IMESSAGE_APP_IPAD_PRO_3GEN_129' | 'IMESSAGE_APP_IPAD_PRO_3GEN_11' | 'IMESSAGE_APP_IPAD_PRO_129' | 'IMESSAGE_APP_IPAD_105' | 'IMESSAGE_APP_IPAD_97'>, filterAppCustomProductPageLocalization?: Array<string>, filterAppStoreVersionExperimentTreatmentLocalization?: Array<string>, fieldsAppScreenshotSets?: Array<'appCustomProductPageLocalization' | 'appScreenshots' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'screenshotDisplayType'>, fieldsAppCustomProductPageLocalizations?: Array<'appCustomProductPageVersion' | 'appPreviewSets' | 'appScreenshotSets' | 'locale' | 'promotionalText'>, fieldsAppStoreVersionExperimentTreatmentLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersionExperimentTreatment' | 'locale'>, fieldsAppScreenshots?: Array<'appScreenshotSet' | 'assetDeliveryState' | 'assetToken' | 'assetType' | 'fileName' | 'fileSize' | 'imageAsset' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, fieldsAppStoreVersionLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersion' | 'description' | 'keywords' | 'locale' | 'marketingUrl' | 'promotionalText' | 'supportUrl' | 'whatsNew'>, limit?: number, limitAppScreenshots?: number, include?: Array<'appCustomProductPageLocalization' | 'appScreenshots' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization'>, _options?: Configuration): Observable<HttpInfo<AppScreenshotSetsResponse>> {
        const requestContextPromise = this.requestFactory.appStoreVersionLocalizationsAppScreenshotSetsGetToManyRelated(id, filterScreenshotDisplayType, filterAppCustomProductPageLocalization, filterAppStoreVersionExperimentTreatmentLocalization, fieldsAppScreenshotSets, fieldsAppCustomProductPageLocalizations, fieldsAppStoreVersionExperimentTreatmentLocalizations, fieldsAppScreenshots, fieldsAppStoreVersionLocalizations, limit, limitAppScreenshots, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appStoreVersionLocalizationsAppScreenshotSetsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param filterScreenshotDisplayType filter by attribute \&#39;screenshotDisplayType\&#39;
     * @param filterAppCustomProductPageLocalization filter by id(s) of related \&#39;appCustomProductPageLocalization\&#39;
     * @param filterAppStoreVersionExperimentTreatmentLocalization filter by id(s) of related \&#39;appStoreVersionExperimentTreatmentLocalization\&#39;
     * @param fieldsAppScreenshotSets the fields to include for returned resources of type appScreenshotSets
     * @param fieldsAppCustomProductPageLocalizations the fields to include for returned resources of type appCustomProductPageLocalizations
     * @param fieldsAppStoreVersionExperimentTreatmentLocalizations the fields to include for returned resources of type appStoreVersionExperimentTreatmentLocalizations
     * @param fieldsAppScreenshots the fields to include for returned resources of type appScreenshots
     * @param fieldsAppStoreVersionLocalizations the fields to include for returned resources of type appStoreVersionLocalizations
     * @param limit maximum resources per page
     * @param limitAppScreenshots maximum number of related appScreenshots returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appStoreVersionLocalizationsAppScreenshotSetsGetToManyRelated(id: string, filterScreenshotDisplayType?: Array<'APP_IPHONE_67' | 'APP_IPHONE_61' | 'APP_IPHONE_65' | 'APP_IPHONE_58' | 'APP_IPHONE_55' | 'APP_IPHONE_47' | 'APP_IPHONE_40' | 'APP_IPHONE_35' | 'APP_IPAD_PRO_3GEN_129' | 'APP_IPAD_PRO_3GEN_11' | 'APP_IPAD_PRO_129' | 'APP_IPAD_105' | 'APP_IPAD_97' | 'APP_DESKTOP' | 'APP_WATCH_ULTRA' | 'APP_WATCH_SERIES_7' | 'APP_WATCH_SERIES_4' | 'APP_WATCH_SERIES_3' | 'APP_APPLE_TV' | 'APP_APPLE_VISION_PRO' | 'IMESSAGE_APP_IPHONE_67' | 'IMESSAGE_APP_IPHONE_61' | 'IMESSAGE_APP_IPHONE_65' | 'IMESSAGE_APP_IPHONE_58' | 'IMESSAGE_APP_IPHONE_55' | 'IMESSAGE_APP_IPHONE_47' | 'IMESSAGE_APP_IPHONE_40' | 'IMESSAGE_APP_IPAD_PRO_3GEN_129' | 'IMESSAGE_APP_IPAD_PRO_3GEN_11' | 'IMESSAGE_APP_IPAD_PRO_129' | 'IMESSAGE_APP_IPAD_105' | 'IMESSAGE_APP_IPAD_97'>, filterAppCustomProductPageLocalization?: Array<string>, filterAppStoreVersionExperimentTreatmentLocalization?: Array<string>, fieldsAppScreenshotSets?: Array<'appCustomProductPageLocalization' | 'appScreenshots' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'screenshotDisplayType'>, fieldsAppCustomProductPageLocalizations?: Array<'appCustomProductPageVersion' | 'appPreviewSets' | 'appScreenshotSets' | 'locale' | 'promotionalText'>, fieldsAppStoreVersionExperimentTreatmentLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersionExperimentTreatment' | 'locale'>, fieldsAppScreenshots?: Array<'appScreenshotSet' | 'assetDeliveryState' | 'assetToken' | 'assetType' | 'fileName' | 'fileSize' | 'imageAsset' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, fieldsAppStoreVersionLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersion' | 'description' | 'keywords' | 'locale' | 'marketingUrl' | 'promotionalText' | 'supportUrl' | 'whatsNew'>, limit?: number, limitAppScreenshots?: number, include?: Array<'appCustomProductPageLocalization' | 'appScreenshots' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization'>, _options?: Configuration): Observable<AppScreenshotSetsResponse> {
        return this.appStoreVersionLocalizationsAppScreenshotSetsGetToManyRelatedWithHttpInfo(id, filterScreenshotDisplayType, filterAppCustomProductPageLocalization, filterAppStoreVersionExperimentTreatmentLocalization, fieldsAppScreenshotSets, fieldsAppCustomProductPageLocalizations, fieldsAppStoreVersionExperimentTreatmentLocalizations, fieldsAppScreenshots, fieldsAppStoreVersionLocalizations, limit, limitAppScreenshots, include, _options).pipe(map((apiResponse: HttpInfo<AppScreenshotSetsResponse>) => apiResponse.data));
    }

    /**
     * @param appStoreVersionLocalizationCreateRequest AppStoreVersionLocalization representation
     */
    public appStoreVersionLocalizationsCreateInstanceWithHttpInfo(appStoreVersionLocalizationCreateRequest: AppStoreVersionLocalizationCreateRequest, _options?: Configuration): Observable<HttpInfo<AppStoreVersionLocalizationResponse>> {
        const requestContextPromise = this.requestFactory.appStoreVersionLocalizationsCreateInstance(appStoreVersionLocalizationCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appStoreVersionLocalizationsCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param appStoreVersionLocalizationCreateRequest AppStoreVersionLocalization representation
     */
    public appStoreVersionLocalizationsCreateInstance(appStoreVersionLocalizationCreateRequest: AppStoreVersionLocalizationCreateRequest, _options?: Configuration): Observable<AppStoreVersionLocalizationResponse> {
        return this.appStoreVersionLocalizationsCreateInstanceWithHttpInfo(appStoreVersionLocalizationCreateRequest, _options).pipe(map((apiResponse: HttpInfo<AppStoreVersionLocalizationResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public appStoreVersionLocalizationsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.appStoreVersionLocalizationsDeleteInstance(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appStoreVersionLocalizationsDeleteInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public appStoreVersionLocalizationsDeleteInstance(id: string, _options?: Configuration): Observable<void> {
        return this.appStoreVersionLocalizationsDeleteInstanceWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppStoreVersionLocalizations the fields to include for returned resources of type appStoreVersionLocalizations
     * @param include comma-separated list of relationships to include
     * @param fieldsAppScreenshotSets the fields to include for returned resources of type appScreenshotSets
     * @param fieldsAppPreviewSets the fields to include for returned resources of type appPreviewSets
     * @param limitAppPreviewSets maximum number of related appPreviewSets returned (when they are included)
     * @param limitAppScreenshotSets maximum number of related appScreenshotSets returned (when they are included)
     */
    public appStoreVersionLocalizationsGetInstanceWithHttpInfo(id: string, fieldsAppStoreVersionLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersion' | 'description' | 'keywords' | 'locale' | 'marketingUrl' | 'promotionalText' | 'supportUrl' | 'whatsNew'>, include?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersion'>, fieldsAppScreenshotSets?: Array<'appCustomProductPageLocalization' | 'appScreenshots' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'screenshotDisplayType'>, fieldsAppPreviewSets?: Array<'appCustomProductPageLocalization' | 'appPreviews' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'previewType'>, limitAppPreviewSets?: number, limitAppScreenshotSets?: number, _options?: Configuration): Observable<HttpInfo<AppStoreVersionLocalizationResponse>> {
        const requestContextPromise = this.requestFactory.appStoreVersionLocalizationsGetInstance(id, fieldsAppStoreVersionLocalizations, include, fieldsAppScreenshotSets, fieldsAppPreviewSets, limitAppPreviewSets, limitAppScreenshotSets, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appStoreVersionLocalizationsGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppStoreVersionLocalizations the fields to include for returned resources of type appStoreVersionLocalizations
     * @param include comma-separated list of relationships to include
     * @param fieldsAppScreenshotSets the fields to include for returned resources of type appScreenshotSets
     * @param fieldsAppPreviewSets the fields to include for returned resources of type appPreviewSets
     * @param limitAppPreviewSets maximum number of related appPreviewSets returned (when they are included)
     * @param limitAppScreenshotSets maximum number of related appScreenshotSets returned (when they are included)
     */
    public appStoreVersionLocalizationsGetInstance(id: string, fieldsAppStoreVersionLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersion' | 'description' | 'keywords' | 'locale' | 'marketingUrl' | 'promotionalText' | 'supportUrl' | 'whatsNew'>, include?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersion'>, fieldsAppScreenshotSets?: Array<'appCustomProductPageLocalization' | 'appScreenshots' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'screenshotDisplayType'>, fieldsAppPreviewSets?: Array<'appCustomProductPageLocalization' | 'appPreviews' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'previewType'>, limitAppPreviewSets?: number, limitAppScreenshotSets?: number, _options?: Configuration): Observable<AppStoreVersionLocalizationResponse> {
        return this.appStoreVersionLocalizationsGetInstanceWithHttpInfo(id, fieldsAppStoreVersionLocalizations, include, fieldsAppScreenshotSets, fieldsAppPreviewSets, limitAppPreviewSets, limitAppScreenshotSets, _options).pipe(map((apiResponse: HttpInfo<AppStoreVersionLocalizationResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param appStoreVersionLocalizationUpdateRequest AppStoreVersionLocalization representation
     */
    public appStoreVersionLocalizationsUpdateInstanceWithHttpInfo(id: string, appStoreVersionLocalizationUpdateRequest: AppStoreVersionLocalizationUpdateRequest, _options?: Configuration): Observable<HttpInfo<AppStoreVersionLocalizationResponse>> {
        const requestContextPromise = this.requestFactory.appStoreVersionLocalizationsUpdateInstance(id, appStoreVersionLocalizationUpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appStoreVersionLocalizationsUpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param appStoreVersionLocalizationUpdateRequest AppStoreVersionLocalization representation
     */
    public appStoreVersionLocalizationsUpdateInstance(id: string, appStoreVersionLocalizationUpdateRequest: AppStoreVersionLocalizationUpdateRequest, _options?: Configuration): Observable<AppStoreVersionLocalizationResponse> {
        return this.appStoreVersionLocalizationsUpdateInstanceWithHttpInfo(id, appStoreVersionLocalizationUpdateRequest, _options).pipe(map((apiResponse: HttpInfo<AppStoreVersionLocalizationResponse>) => apiResponse.data));
    }

}

import { AppStoreVersionPhasedReleasesApiRequestFactory, AppStoreVersionPhasedReleasesApiResponseProcessor} from "../apis/AppStoreVersionPhasedReleasesApi.ts";
export class ObservableAppStoreVersionPhasedReleasesApi {
    private requestFactory: AppStoreVersionPhasedReleasesApiRequestFactory;
    private responseProcessor: AppStoreVersionPhasedReleasesApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: AppStoreVersionPhasedReleasesApiRequestFactory,
        responseProcessor?: AppStoreVersionPhasedReleasesApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new AppStoreVersionPhasedReleasesApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new AppStoreVersionPhasedReleasesApiResponseProcessor();
    }

    /**
     * @param appStoreVersionPhasedReleaseCreateRequest AppStoreVersionPhasedRelease representation
     */
    public appStoreVersionPhasedReleasesCreateInstanceWithHttpInfo(appStoreVersionPhasedReleaseCreateRequest: AppStoreVersionPhasedReleaseCreateRequest, _options?: Configuration): Observable<HttpInfo<AppStoreVersionPhasedReleaseResponse>> {
        const requestContextPromise = this.requestFactory.appStoreVersionPhasedReleasesCreateInstance(appStoreVersionPhasedReleaseCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appStoreVersionPhasedReleasesCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param appStoreVersionPhasedReleaseCreateRequest AppStoreVersionPhasedRelease representation
     */
    public appStoreVersionPhasedReleasesCreateInstance(appStoreVersionPhasedReleaseCreateRequest: AppStoreVersionPhasedReleaseCreateRequest, _options?: Configuration): Observable<AppStoreVersionPhasedReleaseResponse> {
        return this.appStoreVersionPhasedReleasesCreateInstanceWithHttpInfo(appStoreVersionPhasedReleaseCreateRequest, _options).pipe(map((apiResponse: HttpInfo<AppStoreVersionPhasedReleaseResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public appStoreVersionPhasedReleasesDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.appStoreVersionPhasedReleasesDeleteInstance(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appStoreVersionPhasedReleasesDeleteInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public appStoreVersionPhasedReleasesDeleteInstance(id: string, _options?: Configuration): Observable<void> {
        return this.appStoreVersionPhasedReleasesDeleteInstanceWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param appStoreVersionPhasedReleaseUpdateRequest AppStoreVersionPhasedRelease representation
     */
    public appStoreVersionPhasedReleasesUpdateInstanceWithHttpInfo(id: string, appStoreVersionPhasedReleaseUpdateRequest: AppStoreVersionPhasedReleaseUpdateRequest, _options?: Configuration): Observable<HttpInfo<AppStoreVersionPhasedReleaseResponse>> {
        const requestContextPromise = this.requestFactory.appStoreVersionPhasedReleasesUpdateInstance(id, appStoreVersionPhasedReleaseUpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appStoreVersionPhasedReleasesUpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param appStoreVersionPhasedReleaseUpdateRequest AppStoreVersionPhasedRelease representation
     */
    public appStoreVersionPhasedReleasesUpdateInstance(id: string, appStoreVersionPhasedReleaseUpdateRequest: AppStoreVersionPhasedReleaseUpdateRequest, _options?: Configuration): Observable<AppStoreVersionPhasedReleaseResponse> {
        return this.appStoreVersionPhasedReleasesUpdateInstanceWithHttpInfo(id, appStoreVersionPhasedReleaseUpdateRequest, _options).pipe(map((apiResponse: HttpInfo<AppStoreVersionPhasedReleaseResponse>) => apiResponse.data));
    }

}

import { AppStoreVersionPromotionsApiRequestFactory, AppStoreVersionPromotionsApiResponseProcessor} from "../apis/AppStoreVersionPromotionsApi.ts";
export class ObservableAppStoreVersionPromotionsApi {
    private requestFactory: AppStoreVersionPromotionsApiRequestFactory;
    private responseProcessor: AppStoreVersionPromotionsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: AppStoreVersionPromotionsApiRequestFactory,
        responseProcessor?: AppStoreVersionPromotionsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new AppStoreVersionPromotionsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new AppStoreVersionPromotionsApiResponseProcessor();
    }

    /**
     * @param appStoreVersionPromotionCreateRequest AppStoreVersionPromotion representation
     */
    public appStoreVersionPromotionsCreateInstanceWithHttpInfo(appStoreVersionPromotionCreateRequest: AppStoreVersionPromotionCreateRequest, _options?: Configuration): Observable<HttpInfo<AppStoreVersionPromotionResponse>> {
        const requestContextPromise = this.requestFactory.appStoreVersionPromotionsCreateInstance(appStoreVersionPromotionCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appStoreVersionPromotionsCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param appStoreVersionPromotionCreateRequest AppStoreVersionPromotion representation
     */
    public appStoreVersionPromotionsCreateInstance(appStoreVersionPromotionCreateRequest: AppStoreVersionPromotionCreateRequest, _options?: Configuration): Observable<AppStoreVersionPromotionResponse> {
        return this.appStoreVersionPromotionsCreateInstanceWithHttpInfo(appStoreVersionPromotionCreateRequest, _options).pipe(map((apiResponse: HttpInfo<AppStoreVersionPromotionResponse>) => apiResponse.data));
    }

}

import { AppStoreVersionReleaseRequestsApiRequestFactory, AppStoreVersionReleaseRequestsApiResponseProcessor} from "../apis/AppStoreVersionReleaseRequestsApi.ts";
export class ObservableAppStoreVersionReleaseRequestsApi {
    private requestFactory: AppStoreVersionReleaseRequestsApiRequestFactory;
    private responseProcessor: AppStoreVersionReleaseRequestsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: AppStoreVersionReleaseRequestsApiRequestFactory,
        responseProcessor?: AppStoreVersionReleaseRequestsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new AppStoreVersionReleaseRequestsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new AppStoreVersionReleaseRequestsApiResponseProcessor();
    }

    /**
     * @param appStoreVersionReleaseRequestCreateRequest AppStoreVersionReleaseRequest representation
     */
    public appStoreVersionReleaseRequestsCreateInstanceWithHttpInfo(appStoreVersionReleaseRequestCreateRequest: AppStoreVersionReleaseRequestCreateRequest, _options?: Configuration): Observable<HttpInfo<AppStoreVersionReleaseRequestResponse>> {
        const requestContextPromise = this.requestFactory.appStoreVersionReleaseRequestsCreateInstance(appStoreVersionReleaseRequestCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appStoreVersionReleaseRequestsCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param appStoreVersionReleaseRequestCreateRequest AppStoreVersionReleaseRequest representation
     */
    public appStoreVersionReleaseRequestsCreateInstance(appStoreVersionReleaseRequestCreateRequest: AppStoreVersionReleaseRequestCreateRequest, _options?: Configuration): Observable<AppStoreVersionReleaseRequestResponse> {
        return this.appStoreVersionReleaseRequestsCreateInstanceWithHttpInfo(appStoreVersionReleaseRequestCreateRequest, _options).pipe(map((apiResponse: HttpInfo<AppStoreVersionReleaseRequestResponse>) => apiResponse.data));
    }

}

import { AppStoreVersionSubmissionsApiRequestFactory, AppStoreVersionSubmissionsApiResponseProcessor} from "../apis/AppStoreVersionSubmissionsApi.ts";
export class ObservableAppStoreVersionSubmissionsApi {
    private requestFactory: AppStoreVersionSubmissionsApiRequestFactory;
    private responseProcessor: AppStoreVersionSubmissionsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: AppStoreVersionSubmissionsApiRequestFactory,
        responseProcessor?: AppStoreVersionSubmissionsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new AppStoreVersionSubmissionsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new AppStoreVersionSubmissionsApiResponseProcessor();
    }

    /**
     * @param appStoreVersionSubmissionCreateRequest AppStoreVersionSubmission representation
     */
    public appStoreVersionSubmissionsCreateInstanceWithHttpInfo(appStoreVersionSubmissionCreateRequest: AppStoreVersionSubmissionCreateRequest, _options?: Configuration): Observable<HttpInfo<AppStoreVersionSubmissionResponse>> {
        const requestContextPromise = this.requestFactory.appStoreVersionSubmissionsCreateInstance(appStoreVersionSubmissionCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appStoreVersionSubmissionsCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param appStoreVersionSubmissionCreateRequest AppStoreVersionSubmission representation
     */
    public appStoreVersionSubmissionsCreateInstance(appStoreVersionSubmissionCreateRequest: AppStoreVersionSubmissionCreateRequest, _options?: Configuration): Observable<AppStoreVersionSubmissionResponse> {
        return this.appStoreVersionSubmissionsCreateInstanceWithHttpInfo(appStoreVersionSubmissionCreateRequest, _options).pipe(map((apiResponse: HttpInfo<AppStoreVersionSubmissionResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public appStoreVersionSubmissionsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.appStoreVersionSubmissionsDeleteInstance(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appStoreVersionSubmissionsDeleteInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public appStoreVersionSubmissionsDeleteInstance(id: string, _options?: Configuration): Observable<void> {
        return this.appStoreVersionSubmissionsDeleteInstanceWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

}

import { AppStoreVersionsApiRequestFactory, AppStoreVersionsApiResponseProcessor} from "../apis/AppStoreVersionsApi.ts";
export class ObservableAppStoreVersionsApi {
    private requestFactory: AppStoreVersionsApiRequestFactory;
    private responseProcessor: AppStoreVersionsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: AppStoreVersionsApiRequestFactory,
        responseProcessor?: AppStoreVersionsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new AppStoreVersionsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new AppStoreVersionsApiResponseProcessor();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAgeRatingDeclarations the fields to include for returned resources of type ageRatingDeclarations
     */
    public appStoreVersionsAgeRatingDeclarationGetToOneRelatedWithHttpInfo(id: string, fieldsAgeRatingDeclarations?: Array<'ageRatingOverride' | 'alcoholTobaccoOrDrugUseOrReferences' | 'contests' | 'gambling' | 'gamblingAndContests' | 'gamblingSimulated' | 'horrorOrFearThemes' | 'kidsAgeBand' | 'matureOrSuggestiveThemes' | 'medicalOrTreatmentInformation' | 'profanityOrCrudeHumor' | 'seventeenPlus' | 'sexualContentGraphicAndNudity' | 'sexualContentOrNudity' | 'unrestrictedWebAccess' | 'violenceCartoonOrFantasy' | 'violenceRealistic' | 'violenceRealisticProlongedGraphicOrSadistic'>, _options?: Configuration): Observable<HttpInfo<AgeRatingDeclarationWithoutIncludesResponse>> {
        const requestContextPromise = this.requestFactory.appStoreVersionsAgeRatingDeclarationGetToOneRelated(id, fieldsAgeRatingDeclarations, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appStoreVersionsAgeRatingDeclarationGetToOneRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAgeRatingDeclarations the fields to include for returned resources of type ageRatingDeclarations
     */
    public appStoreVersionsAgeRatingDeclarationGetToOneRelated(id: string, fieldsAgeRatingDeclarations?: Array<'ageRatingOverride' | 'alcoholTobaccoOrDrugUseOrReferences' | 'contests' | 'gambling' | 'gamblingAndContests' | 'gamblingSimulated' | 'horrorOrFearThemes' | 'kidsAgeBand' | 'matureOrSuggestiveThemes' | 'medicalOrTreatmentInformation' | 'profanityOrCrudeHumor' | 'seventeenPlus' | 'sexualContentGraphicAndNudity' | 'sexualContentOrNudity' | 'unrestrictedWebAccess' | 'violenceCartoonOrFantasy' | 'violenceRealistic' | 'violenceRealisticProlongedGraphicOrSadistic'>, _options?: Configuration): Observable<AgeRatingDeclarationWithoutIncludesResponse> {
        return this.appStoreVersionsAgeRatingDeclarationGetToOneRelatedWithHttpInfo(id, fieldsAgeRatingDeclarations, _options).pipe(map((apiResponse: HttpInfo<AgeRatingDeclarationWithoutIncludesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAlternativeDistributionPackages the fields to include for returned resources of type alternativeDistributionPackages
     * @param fieldsAlternativeDistributionPackageVersions the fields to include for returned resources of type alternativeDistributionPackageVersions
     * @param limitVersions maximum number of related versions returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appStoreVersionsAlternativeDistributionPackageGetToOneRelatedWithHttpInfo(id: string, fieldsAlternativeDistributionPackages?: Array<'appStoreVersion' | 'versions'>, fieldsAlternativeDistributionPackageVersions?: Array<'alternativeDistributionPackage' | 'deltas' | 'fileChecksum' | 'state' | 'url' | 'urlExpirationDate' | 'variants' | 'version'>, limitVersions?: number, include?: Array<'versions'>, _options?: Configuration): Observable<HttpInfo<AlternativeDistributionPackageResponse>> {
        const requestContextPromise = this.requestFactory.appStoreVersionsAlternativeDistributionPackageGetToOneRelated(id, fieldsAlternativeDistributionPackages, fieldsAlternativeDistributionPackageVersions, limitVersions, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appStoreVersionsAlternativeDistributionPackageGetToOneRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAlternativeDistributionPackages the fields to include for returned resources of type alternativeDistributionPackages
     * @param fieldsAlternativeDistributionPackageVersions the fields to include for returned resources of type alternativeDistributionPackageVersions
     * @param limitVersions maximum number of related versions returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appStoreVersionsAlternativeDistributionPackageGetToOneRelated(id: string, fieldsAlternativeDistributionPackages?: Array<'appStoreVersion' | 'versions'>, fieldsAlternativeDistributionPackageVersions?: Array<'alternativeDistributionPackage' | 'deltas' | 'fileChecksum' | 'state' | 'url' | 'urlExpirationDate' | 'variants' | 'version'>, limitVersions?: number, include?: Array<'versions'>, _options?: Configuration): Observable<AlternativeDistributionPackageResponse> {
        return this.appStoreVersionsAlternativeDistributionPackageGetToOneRelatedWithHttpInfo(id, fieldsAlternativeDistributionPackages, fieldsAlternativeDistributionPackageVersions, limitVersions, include, _options).pipe(map((apiResponse: HttpInfo<AlternativeDistributionPackageResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppClips the fields to include for returned resources of type appClips
     * @param fieldsAppClipAppStoreReviewDetails the fields to include for returned resources of type appClipAppStoreReviewDetails
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsAppClipDefaultExperiences the fields to include for returned resources of type appClipDefaultExperiences
     * @param fieldsAppClipDefaultExperienceLocalizations the fields to include for returned resources of type appClipDefaultExperienceLocalizations
     * @param limitAppClipDefaultExperienceLocalizations maximum number of related appClipDefaultExperienceLocalizations returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appStoreVersionsAppClipDefaultExperienceGetToOneRelatedWithHttpInfo(id: string, fieldsAppClips?: Array<'app' | 'appClipAdvancedExperiences' | 'appClipDefaultExperiences' | 'bundleId'>, fieldsAppClipAppStoreReviewDetails?: Array<'appClipDefaultExperience' | 'invocationUrls'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsAppClipDefaultExperiences?: Array<'action' | 'appClip' | 'appClipAppStoreReviewDetail' | 'appClipDefaultExperienceLocalizations' | 'appClipDefaultExperienceTemplate' | 'releaseWithAppStoreVersion'>, fieldsAppClipDefaultExperienceLocalizations?: Array<'appClipDefaultExperience' | 'appClipHeaderImage' | 'locale' | 'subtitle'>, limitAppClipDefaultExperienceLocalizations?: number, include?: Array<'appClip' | 'appClipAppStoreReviewDetail' | 'appClipDefaultExperienceLocalizations' | 'releaseWithAppStoreVersion'>, _options?: Configuration): Observable<HttpInfo<AppClipDefaultExperienceResponse>> {
        const requestContextPromise = this.requestFactory.appStoreVersionsAppClipDefaultExperienceGetToOneRelated(id, fieldsAppClips, fieldsAppClipAppStoreReviewDetails, fieldsAppStoreVersions, fieldsAppClipDefaultExperiences, fieldsAppClipDefaultExperienceLocalizations, limitAppClipDefaultExperienceLocalizations, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appStoreVersionsAppClipDefaultExperienceGetToOneRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppClips the fields to include for returned resources of type appClips
     * @param fieldsAppClipAppStoreReviewDetails the fields to include for returned resources of type appClipAppStoreReviewDetails
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsAppClipDefaultExperiences the fields to include for returned resources of type appClipDefaultExperiences
     * @param fieldsAppClipDefaultExperienceLocalizations the fields to include for returned resources of type appClipDefaultExperienceLocalizations
     * @param limitAppClipDefaultExperienceLocalizations maximum number of related appClipDefaultExperienceLocalizations returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appStoreVersionsAppClipDefaultExperienceGetToOneRelated(id: string, fieldsAppClips?: Array<'app' | 'appClipAdvancedExperiences' | 'appClipDefaultExperiences' | 'bundleId'>, fieldsAppClipAppStoreReviewDetails?: Array<'appClipDefaultExperience' | 'invocationUrls'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsAppClipDefaultExperiences?: Array<'action' | 'appClip' | 'appClipAppStoreReviewDetail' | 'appClipDefaultExperienceLocalizations' | 'appClipDefaultExperienceTemplate' | 'releaseWithAppStoreVersion'>, fieldsAppClipDefaultExperienceLocalizations?: Array<'appClipDefaultExperience' | 'appClipHeaderImage' | 'locale' | 'subtitle'>, limitAppClipDefaultExperienceLocalizations?: number, include?: Array<'appClip' | 'appClipAppStoreReviewDetail' | 'appClipDefaultExperienceLocalizations' | 'releaseWithAppStoreVersion'>, _options?: Configuration): Observable<AppClipDefaultExperienceResponse> {
        return this.appStoreVersionsAppClipDefaultExperienceGetToOneRelatedWithHttpInfo(id, fieldsAppClips, fieldsAppClipAppStoreReviewDetails, fieldsAppStoreVersions, fieldsAppClipDefaultExperiences, fieldsAppClipDefaultExperienceLocalizations, limitAppClipDefaultExperienceLocalizations, include, _options).pipe(map((apiResponse: HttpInfo<AppClipDefaultExperienceResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public appStoreVersionsAppClipDefaultExperienceGetToOneRelationshipWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<AppStoreVersionAppClipDefaultExperienceLinkageResponse>> {
        const requestContextPromise = this.requestFactory.appStoreVersionsAppClipDefaultExperienceGetToOneRelationship(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appStoreVersionsAppClipDefaultExperienceGetToOneRelationshipWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public appStoreVersionsAppClipDefaultExperienceGetToOneRelationship(id: string, _options?: Configuration): Observable<AppStoreVersionAppClipDefaultExperienceLinkageResponse> {
        return this.appStoreVersionsAppClipDefaultExperienceGetToOneRelationshipWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<AppStoreVersionAppClipDefaultExperienceLinkageResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param appStoreVersionAppClipDefaultExperienceLinkageRequest Related linkage
     */
    public appStoreVersionsAppClipDefaultExperienceUpdateToOneRelationshipWithHttpInfo(id: string, appStoreVersionAppClipDefaultExperienceLinkageRequest: AppStoreVersionAppClipDefaultExperienceLinkageRequest, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.appStoreVersionsAppClipDefaultExperienceUpdateToOneRelationship(id, appStoreVersionAppClipDefaultExperienceLinkageRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appStoreVersionsAppClipDefaultExperienceUpdateToOneRelationshipWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param appStoreVersionAppClipDefaultExperienceLinkageRequest Related linkage
     */
    public appStoreVersionsAppClipDefaultExperienceUpdateToOneRelationship(id: string, appStoreVersionAppClipDefaultExperienceLinkageRequest: AppStoreVersionAppClipDefaultExperienceLinkageRequest, _options?: Configuration): Observable<void> {
        return this.appStoreVersionsAppClipDefaultExperienceUpdateToOneRelationshipWithHttpInfo(id, appStoreVersionAppClipDefaultExperienceLinkageRequest, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppStoreReviewDetails the fields to include for returned resources of type appStoreReviewDetails
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsAppStoreReviewAttachments the fields to include for returned resources of type appStoreReviewAttachments
     * @param limitAppStoreReviewAttachments maximum number of related appStoreReviewAttachments returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appStoreVersionsAppStoreReviewDetailGetToOneRelatedWithHttpInfo(id: string, fieldsAppStoreReviewDetails?: Array<'appStoreReviewAttachments' | 'appStoreVersion' | 'contactEmail' | 'contactFirstName' | 'contactLastName' | 'contactPhone' | 'demoAccountName' | 'demoAccountPassword' | 'demoAccountRequired' | 'notes'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsAppStoreReviewAttachments?: Array<'appStoreReviewDetail' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, limitAppStoreReviewAttachments?: number, include?: Array<'appStoreReviewAttachments' | 'appStoreVersion'>, _options?: Configuration): Observable<HttpInfo<AppStoreReviewDetailResponse>> {
        const requestContextPromise = this.requestFactory.appStoreVersionsAppStoreReviewDetailGetToOneRelated(id, fieldsAppStoreReviewDetails, fieldsAppStoreVersions, fieldsAppStoreReviewAttachments, limitAppStoreReviewAttachments, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appStoreVersionsAppStoreReviewDetailGetToOneRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppStoreReviewDetails the fields to include for returned resources of type appStoreReviewDetails
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsAppStoreReviewAttachments the fields to include for returned resources of type appStoreReviewAttachments
     * @param limitAppStoreReviewAttachments maximum number of related appStoreReviewAttachments returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appStoreVersionsAppStoreReviewDetailGetToOneRelated(id: string, fieldsAppStoreReviewDetails?: Array<'appStoreReviewAttachments' | 'appStoreVersion' | 'contactEmail' | 'contactFirstName' | 'contactLastName' | 'contactPhone' | 'demoAccountName' | 'demoAccountPassword' | 'demoAccountRequired' | 'notes'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsAppStoreReviewAttachments?: Array<'appStoreReviewDetail' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, limitAppStoreReviewAttachments?: number, include?: Array<'appStoreReviewAttachments' | 'appStoreVersion'>, _options?: Configuration): Observable<AppStoreReviewDetailResponse> {
        return this.appStoreVersionsAppStoreReviewDetailGetToOneRelatedWithHttpInfo(id, fieldsAppStoreReviewDetails, fieldsAppStoreVersions, fieldsAppStoreReviewAttachments, limitAppStoreReviewAttachments, include, _options).pipe(map((apiResponse: HttpInfo<AppStoreReviewDetailResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param filterState filter by attribute \&#39;state\&#39;
     * @param fieldsAppStoreVersionExperiments the fields to include for returned resources of type appStoreVersionExperiments
     * @param fieldsAppStoreVersionExperimentTreatments the fields to include for returned resources of type appStoreVersionExperimentTreatments
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param limit maximum resources per page
     * @param limitAppStoreVersionExperimentTreatments maximum number of related appStoreVersionExperimentTreatments returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appStoreVersionsAppStoreVersionExperimentsGetToManyRelatedWithHttpInfo(id: string, filterState?: Array<'PREPARE_FOR_SUBMISSION' | 'READY_FOR_REVIEW' | 'WAITING_FOR_REVIEW' | 'IN_REVIEW' | 'ACCEPTED' | 'APPROVED' | 'REJECTED' | 'COMPLETED' | 'STOPPED'>, fieldsAppStoreVersionExperiments?: Array<'appStoreVersion' | 'appStoreVersionExperimentTreatments' | 'endDate' | 'name' | 'reviewRequired' | 'startDate' | 'started' | 'state' | 'trafficProportion'>, fieldsAppStoreVersionExperimentTreatments?: Array<'appIcon' | 'appIconName' | 'appStoreVersionExperiment' | 'appStoreVersionExperimentTreatmentLocalizations' | 'appStoreVersionExperimentV2' | 'name' | 'promotedDate'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, limit?: number, limitAppStoreVersionExperimentTreatments?: number, include?: Array<'appStoreVersion' | 'appStoreVersionExperimentTreatments'>, _options?: Configuration): Observable<HttpInfo<AppStoreVersionExperimentsResponse>> {
        const requestContextPromise = this.requestFactory.appStoreVersionsAppStoreVersionExperimentsGetToManyRelated(id, filterState, fieldsAppStoreVersionExperiments, fieldsAppStoreVersionExperimentTreatments, fieldsAppStoreVersions, limit, limitAppStoreVersionExperimentTreatments, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appStoreVersionsAppStoreVersionExperimentsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param filterState filter by attribute \&#39;state\&#39;
     * @param fieldsAppStoreVersionExperiments the fields to include for returned resources of type appStoreVersionExperiments
     * @param fieldsAppStoreVersionExperimentTreatments the fields to include for returned resources of type appStoreVersionExperimentTreatments
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param limit maximum resources per page
     * @param limitAppStoreVersionExperimentTreatments maximum number of related appStoreVersionExperimentTreatments returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appStoreVersionsAppStoreVersionExperimentsGetToManyRelated(id: string, filterState?: Array<'PREPARE_FOR_SUBMISSION' | 'READY_FOR_REVIEW' | 'WAITING_FOR_REVIEW' | 'IN_REVIEW' | 'ACCEPTED' | 'APPROVED' | 'REJECTED' | 'COMPLETED' | 'STOPPED'>, fieldsAppStoreVersionExperiments?: Array<'appStoreVersion' | 'appStoreVersionExperimentTreatments' | 'endDate' | 'name' | 'reviewRequired' | 'startDate' | 'started' | 'state' | 'trafficProportion'>, fieldsAppStoreVersionExperimentTreatments?: Array<'appIcon' | 'appIconName' | 'appStoreVersionExperiment' | 'appStoreVersionExperimentTreatmentLocalizations' | 'appStoreVersionExperimentV2' | 'name' | 'promotedDate'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, limit?: number, limitAppStoreVersionExperimentTreatments?: number, include?: Array<'appStoreVersion' | 'appStoreVersionExperimentTreatments'>, _options?: Configuration): Observable<AppStoreVersionExperimentsResponse> {
        return this.appStoreVersionsAppStoreVersionExperimentsGetToManyRelatedWithHttpInfo(id, filterState, fieldsAppStoreVersionExperiments, fieldsAppStoreVersionExperimentTreatments, fieldsAppStoreVersions, limit, limitAppStoreVersionExperimentTreatments, include, _options).pipe(map((apiResponse: HttpInfo<AppStoreVersionExperimentsResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param filterState filter by attribute \&#39;state\&#39;
     * @param fieldsAppStoreVersionExperiments the fields to include for returned resources of type appStoreVersionExperiments
     * @param fieldsAppStoreVersionExperimentTreatments the fields to include for returned resources of type appStoreVersionExperimentTreatments
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param limit maximum resources per page
     * @param limitControlVersions maximum number of related controlVersions returned (when they are included)
     * @param limitAppStoreVersionExperimentTreatments maximum number of related appStoreVersionExperimentTreatments returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appStoreVersionsAppStoreVersionExperimentsV2GetToManyRelatedWithHttpInfo(id: string, filterState?: Array<'PREPARE_FOR_SUBMISSION' | 'READY_FOR_REVIEW' | 'WAITING_FOR_REVIEW' | 'IN_REVIEW' | 'ACCEPTED' | 'APPROVED' | 'REJECTED' | 'COMPLETED' | 'STOPPED'>, fieldsAppStoreVersionExperiments?: Array<'app' | 'appStoreVersionExperimentTreatments' | 'controlVersions' | 'endDate' | 'latestControlVersion' | 'name' | 'platform' | 'reviewRequired' | 'startDate' | 'started' | 'state' | 'trafficProportion'>, fieldsAppStoreVersionExperimentTreatments?: Array<'appIcon' | 'appIconName' | 'appStoreVersionExperiment' | 'appStoreVersionExperimentTreatmentLocalizations' | 'appStoreVersionExperimentV2' | 'name' | 'promotedDate'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, limit?: number, limitControlVersions?: number, limitAppStoreVersionExperimentTreatments?: number, include?: Array<'app' | 'appStoreVersionExperimentTreatments' | 'controlVersions' | 'latestControlVersion'>, _options?: Configuration): Observable<HttpInfo<AppStoreVersionExperimentsV2Response>> {
        const requestContextPromise = this.requestFactory.appStoreVersionsAppStoreVersionExperimentsV2GetToManyRelated(id, filterState, fieldsAppStoreVersionExperiments, fieldsAppStoreVersionExperimentTreatments, fieldsAppStoreVersions, fieldsApps, limit, limitControlVersions, limitAppStoreVersionExperimentTreatments, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appStoreVersionsAppStoreVersionExperimentsV2GetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param filterState filter by attribute \&#39;state\&#39;
     * @param fieldsAppStoreVersionExperiments the fields to include for returned resources of type appStoreVersionExperiments
     * @param fieldsAppStoreVersionExperimentTreatments the fields to include for returned resources of type appStoreVersionExperimentTreatments
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param limit maximum resources per page
     * @param limitControlVersions maximum number of related controlVersions returned (when they are included)
     * @param limitAppStoreVersionExperimentTreatments maximum number of related appStoreVersionExperimentTreatments returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appStoreVersionsAppStoreVersionExperimentsV2GetToManyRelated(id: string, filterState?: Array<'PREPARE_FOR_SUBMISSION' | 'READY_FOR_REVIEW' | 'WAITING_FOR_REVIEW' | 'IN_REVIEW' | 'ACCEPTED' | 'APPROVED' | 'REJECTED' | 'COMPLETED' | 'STOPPED'>, fieldsAppStoreVersionExperiments?: Array<'app' | 'appStoreVersionExperimentTreatments' | 'controlVersions' | 'endDate' | 'latestControlVersion' | 'name' | 'platform' | 'reviewRequired' | 'startDate' | 'started' | 'state' | 'trafficProportion'>, fieldsAppStoreVersionExperimentTreatments?: Array<'appIcon' | 'appIconName' | 'appStoreVersionExperiment' | 'appStoreVersionExperimentTreatmentLocalizations' | 'appStoreVersionExperimentV2' | 'name' | 'promotedDate'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, limit?: number, limitControlVersions?: number, limitAppStoreVersionExperimentTreatments?: number, include?: Array<'app' | 'appStoreVersionExperimentTreatments' | 'controlVersions' | 'latestControlVersion'>, _options?: Configuration): Observable<AppStoreVersionExperimentsV2Response> {
        return this.appStoreVersionsAppStoreVersionExperimentsV2GetToManyRelatedWithHttpInfo(id, filterState, fieldsAppStoreVersionExperiments, fieldsAppStoreVersionExperimentTreatments, fieldsAppStoreVersions, fieldsApps, limit, limitControlVersions, limitAppStoreVersionExperimentTreatments, include, _options).pipe(map((apiResponse: HttpInfo<AppStoreVersionExperimentsV2Response>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param filterLocale filter by attribute \&#39;locale\&#39;
     * @param fieldsAppScreenshotSets the fields to include for returned resources of type appScreenshotSets
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsAppPreviewSets the fields to include for returned resources of type appPreviewSets
     * @param fieldsAppStoreVersionLocalizations the fields to include for returned resources of type appStoreVersionLocalizations
     * @param limit maximum resources per page
     * @param limitAppScreenshotSets maximum number of related appScreenshotSets returned (when they are included)
     * @param limitAppPreviewSets maximum number of related appPreviewSets returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appStoreVersionsAppStoreVersionLocalizationsGetToManyRelatedWithHttpInfo(id: string, filterLocale?: Array<string>, fieldsAppScreenshotSets?: Array<'appCustomProductPageLocalization' | 'appScreenshots' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'screenshotDisplayType'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsAppPreviewSets?: Array<'appCustomProductPageLocalization' | 'appPreviews' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'previewType'>, fieldsAppStoreVersionLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersion' | 'description' | 'keywords' | 'locale' | 'marketingUrl' | 'promotionalText' | 'supportUrl' | 'whatsNew'>, limit?: number, limitAppScreenshotSets?: number, limitAppPreviewSets?: number, include?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersion'>, _options?: Configuration): Observable<HttpInfo<AppStoreVersionLocalizationsResponse>> {
        const requestContextPromise = this.requestFactory.appStoreVersionsAppStoreVersionLocalizationsGetToManyRelated(id, filterLocale, fieldsAppScreenshotSets, fieldsAppStoreVersions, fieldsAppPreviewSets, fieldsAppStoreVersionLocalizations, limit, limitAppScreenshotSets, limitAppPreviewSets, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appStoreVersionsAppStoreVersionLocalizationsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param filterLocale filter by attribute \&#39;locale\&#39;
     * @param fieldsAppScreenshotSets the fields to include for returned resources of type appScreenshotSets
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsAppPreviewSets the fields to include for returned resources of type appPreviewSets
     * @param fieldsAppStoreVersionLocalizations the fields to include for returned resources of type appStoreVersionLocalizations
     * @param limit maximum resources per page
     * @param limitAppScreenshotSets maximum number of related appScreenshotSets returned (when they are included)
     * @param limitAppPreviewSets maximum number of related appPreviewSets returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appStoreVersionsAppStoreVersionLocalizationsGetToManyRelated(id: string, filterLocale?: Array<string>, fieldsAppScreenshotSets?: Array<'appCustomProductPageLocalization' | 'appScreenshots' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'screenshotDisplayType'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsAppPreviewSets?: Array<'appCustomProductPageLocalization' | 'appPreviews' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'previewType'>, fieldsAppStoreVersionLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersion' | 'description' | 'keywords' | 'locale' | 'marketingUrl' | 'promotionalText' | 'supportUrl' | 'whatsNew'>, limit?: number, limitAppScreenshotSets?: number, limitAppPreviewSets?: number, include?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersion'>, _options?: Configuration): Observable<AppStoreVersionLocalizationsResponse> {
        return this.appStoreVersionsAppStoreVersionLocalizationsGetToManyRelatedWithHttpInfo(id, filterLocale, fieldsAppScreenshotSets, fieldsAppStoreVersions, fieldsAppPreviewSets, fieldsAppStoreVersionLocalizations, limit, limitAppScreenshotSets, limitAppPreviewSets, include, _options).pipe(map((apiResponse: HttpInfo<AppStoreVersionLocalizationsResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppStoreVersionPhasedReleases the fields to include for returned resources of type appStoreVersionPhasedReleases
     */
    public appStoreVersionsAppStoreVersionPhasedReleaseGetToOneRelatedWithHttpInfo(id: string, fieldsAppStoreVersionPhasedReleases?: Array<'appStoreVersion' | 'currentDayNumber' | 'phasedReleaseState' | 'startDate' | 'totalPauseDuration'>, _options?: Configuration): Observable<HttpInfo<AppStoreVersionPhasedReleaseWithoutIncludesResponse>> {
        const requestContextPromise = this.requestFactory.appStoreVersionsAppStoreVersionPhasedReleaseGetToOneRelated(id, fieldsAppStoreVersionPhasedReleases, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appStoreVersionsAppStoreVersionPhasedReleaseGetToOneRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppStoreVersionPhasedReleases the fields to include for returned resources of type appStoreVersionPhasedReleases
     */
    public appStoreVersionsAppStoreVersionPhasedReleaseGetToOneRelated(id: string, fieldsAppStoreVersionPhasedReleases?: Array<'appStoreVersion' | 'currentDayNumber' | 'phasedReleaseState' | 'startDate' | 'totalPauseDuration'>, _options?: Configuration): Observable<AppStoreVersionPhasedReleaseWithoutIncludesResponse> {
        return this.appStoreVersionsAppStoreVersionPhasedReleaseGetToOneRelatedWithHttpInfo(id, fieldsAppStoreVersionPhasedReleases, _options).pipe(map((apiResponse: HttpInfo<AppStoreVersionPhasedReleaseWithoutIncludesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppStoreVersionSubmissions the fields to include for returned resources of type appStoreVersionSubmissions
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param include comma-separated list of relationships to include
     */
    public appStoreVersionsAppStoreVersionSubmissionGetToOneRelatedWithHttpInfo(id: string, fieldsAppStoreVersionSubmissions?: Array<'appStoreVersion'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, include?: Array<'appStoreVersion'>, _options?: Configuration): Observable<HttpInfo<AppStoreVersionSubmissionResponse>> {
        const requestContextPromise = this.requestFactory.appStoreVersionsAppStoreVersionSubmissionGetToOneRelated(id, fieldsAppStoreVersionSubmissions, fieldsAppStoreVersions, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appStoreVersionsAppStoreVersionSubmissionGetToOneRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppStoreVersionSubmissions the fields to include for returned resources of type appStoreVersionSubmissions
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param include comma-separated list of relationships to include
     */
    public appStoreVersionsAppStoreVersionSubmissionGetToOneRelated(id: string, fieldsAppStoreVersionSubmissions?: Array<'appStoreVersion'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, include?: Array<'appStoreVersion'>, _options?: Configuration): Observable<AppStoreVersionSubmissionResponse> {
        return this.appStoreVersionsAppStoreVersionSubmissionGetToOneRelatedWithHttpInfo(id, fieldsAppStoreVersionSubmissions, fieldsAppStoreVersions, include, _options).pipe(map((apiResponse: HttpInfo<AppStoreVersionSubmissionResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBuilds the fields to include for returned resources of type builds
     */
    public appStoreVersionsBuildGetToOneRelatedWithHttpInfo(id: string, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, _options?: Configuration): Observable<HttpInfo<BuildWithoutIncludesResponse>> {
        const requestContextPromise = this.requestFactory.appStoreVersionsBuildGetToOneRelated(id, fieldsBuilds, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appStoreVersionsBuildGetToOneRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBuilds the fields to include for returned resources of type builds
     */
    public appStoreVersionsBuildGetToOneRelated(id: string, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, _options?: Configuration): Observable<BuildWithoutIncludesResponse> {
        return this.appStoreVersionsBuildGetToOneRelatedWithHttpInfo(id, fieldsBuilds, _options).pipe(map((apiResponse: HttpInfo<BuildWithoutIncludesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public appStoreVersionsBuildGetToOneRelationshipWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<AppStoreVersionBuildLinkageResponse>> {
        const requestContextPromise = this.requestFactory.appStoreVersionsBuildGetToOneRelationship(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appStoreVersionsBuildGetToOneRelationshipWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public appStoreVersionsBuildGetToOneRelationship(id: string, _options?: Configuration): Observable<AppStoreVersionBuildLinkageResponse> {
        return this.appStoreVersionsBuildGetToOneRelationshipWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<AppStoreVersionBuildLinkageResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param appStoreVersionBuildLinkageRequest Related linkage
     */
    public appStoreVersionsBuildUpdateToOneRelationshipWithHttpInfo(id: string, appStoreVersionBuildLinkageRequest: AppStoreVersionBuildLinkageRequest, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.appStoreVersionsBuildUpdateToOneRelationship(id, appStoreVersionBuildLinkageRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appStoreVersionsBuildUpdateToOneRelationshipWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param appStoreVersionBuildLinkageRequest Related linkage
     */
    public appStoreVersionsBuildUpdateToOneRelationship(id: string, appStoreVersionBuildLinkageRequest: AppStoreVersionBuildLinkageRequest, _options?: Configuration): Observable<void> {
        return this.appStoreVersionsBuildUpdateToOneRelationshipWithHttpInfo(id, appStoreVersionBuildLinkageRequest, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param appStoreVersionCreateRequest AppStoreVersion representation
     */
    public appStoreVersionsCreateInstanceWithHttpInfo(appStoreVersionCreateRequest: AppStoreVersionCreateRequest, _options?: Configuration): Observable<HttpInfo<AppStoreVersionResponse>> {
        const requestContextPromise = this.requestFactory.appStoreVersionsCreateInstance(appStoreVersionCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appStoreVersionsCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param appStoreVersionCreateRequest AppStoreVersion representation
     */
    public appStoreVersionsCreateInstance(appStoreVersionCreateRequest: AppStoreVersionCreateRequest, _options?: Configuration): Observable<AppStoreVersionResponse> {
        return this.appStoreVersionsCreateInstanceWithHttpInfo(appStoreVersionCreateRequest, _options).pipe(map((apiResponse: HttpInfo<AppStoreVersionResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param filterRating filter by attribute \&#39;rating\&#39;
     * @param filterTerritory filter by attribute \&#39;territory\&#39;
     * @param existsPublishedResponse filter by publishedResponse
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsCustomerReviews the fields to include for returned resources of type customerReviews
     * @param fieldsCustomerReviewResponses the fields to include for returned resources of type customerReviewResponses
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public appStoreVersionsCustomerReviewsGetToManyRelatedWithHttpInfo(id: string, filterRating?: Array<string>, filterTerritory?: Array<'ABW' | 'AFG' | 'AGO' | 'AIA' | 'ALB' | 'AND' | 'ANT' | 'ARE' | 'ARG' | 'ARM' | 'ASM' | 'ATG' | 'AUS' | 'AUT' | 'AZE' | 'BDI' | 'BEL' | 'BEN' | 'BES' | 'BFA' | 'BGD' | 'BGR' | 'BHR' | 'BHS' | 'BIH' | 'BLR' | 'BLZ' | 'BMU' | 'BOL' | 'BRA' | 'BRB' | 'BRN' | 'BTN' | 'BWA' | 'CAF' | 'CAN' | 'CHE' | 'CHL' | 'CHN' | 'CIV' | 'CMR' | 'COD' | 'COG' | 'COK' | 'COL' | 'COM' | 'CPV' | 'CRI' | 'CUB' | 'CUW' | 'CXR' | 'CYM' | 'CYP' | 'CZE' | 'DEU' | 'DJI' | 'DMA' | 'DNK' | 'DOM' | 'DZA' | 'ECU' | 'EGY' | 'ERI' | 'ESP' | 'EST' | 'ETH' | 'FIN' | 'FJI' | 'FLK' | 'FRA' | 'FRO' | 'FSM' | 'GAB' | 'GBR' | 'GEO' | 'GGY' | 'GHA' | 'GIB' | 'GIN' | 'GLP' | 'GMB' | 'GNB' | 'GNQ' | 'GRC' | 'GRD' | 'GRL' | 'GTM' | 'GUF' | 'GUM' | 'GUY' | 'HKG' | 'HND' | 'HRV' | 'HTI' | 'HUN' | 'IDN' | 'IMN' | 'IND' | 'IRL' | 'IRQ' | 'ISL' | 'ISR' | 'ITA' | 'JAM' | 'JEY' | 'JOR' | 'JPN' | 'KAZ' | 'KEN' | 'KGZ' | 'KHM' | 'KIR' | 'KNA' | 'KOR' | 'KWT' | 'LAO' | 'LBN' | 'LBR' | 'LBY' | 'LCA' | 'LIE' | 'LKA' | 'LSO' | 'LTU' | 'LUX' | 'LVA' | 'MAC' | 'MAR' | 'MCO' | 'MDA' | 'MDG' | 'MDV' | 'MEX' | 'MHL' | 'MKD' | 'MLI' | 'MLT' | 'MMR' | 'MNE' | 'MNG' | 'MNP' | 'MOZ' | 'MRT' | 'MSR' | 'MTQ' | 'MUS' | 'MWI' | 'MYS' | 'MYT' | 'NAM' | 'NCL' | 'NER' | 'NFK' | 'NGA' | 'NIC' | 'NIU' | 'NLD' | 'NOR' | 'NPL' | 'NRU' | 'NZL' | 'OMN' | 'PAK' | 'PAN' | 'PER' | 'PHL' | 'PLW' | 'PNG' | 'POL' | 'PRI' | 'PRT' | 'PRY' | 'PSE' | 'PYF' | 'QAT' | 'REU' | 'ROU' | 'RUS' | 'RWA' | 'SAU' | 'SEN' | 'SGP' | 'SHN' | 'SLB' | 'SLE' | 'SLV' | 'SMR' | 'SOM' | 'SPM' | 'SRB' | 'SSD' | 'STP' | 'SUR' | 'SVK' | 'SVN' | 'SWE' | 'SWZ' | 'SXM' | 'SYC' | 'TCA' | 'TCD' | 'TGO' | 'THA' | 'TJK' | 'TKM' | 'TLS' | 'TON' | 'TTO' | 'TUN' | 'TUR' | 'TUV' | 'TWN' | 'TZA' | 'UGA' | 'UKR' | 'UMI' | 'URY' | 'USA' | 'UZB' | 'VAT' | 'VCT' | 'VEN' | 'VGB' | 'VIR' | 'VNM' | 'VUT' | 'WLF' | 'WSM' | 'YEM' | 'ZAF' | 'ZMB' | 'ZWE'>, existsPublishedResponse?: boolean, sort?: Array<'createdDate' | '-createdDate' | 'rating' | '-rating'>, fieldsCustomerReviews?: Array<'body' | 'createdDate' | 'rating' | 'response' | 'reviewerNickname' | 'territory' | 'title'>, fieldsCustomerReviewResponses?: Array<'lastModifiedDate' | 'responseBody' | 'review' | 'state'>, limit?: number, include?: Array<'response'>, _options?: Configuration): Observable<HttpInfo<CustomerReviewsResponse>> {
        const requestContextPromise = this.requestFactory.appStoreVersionsCustomerReviewsGetToManyRelated(id, filterRating, filterTerritory, existsPublishedResponse, sort, fieldsCustomerReviews, fieldsCustomerReviewResponses, limit, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appStoreVersionsCustomerReviewsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param filterRating filter by attribute \&#39;rating\&#39;
     * @param filterTerritory filter by attribute \&#39;territory\&#39;
     * @param existsPublishedResponse filter by publishedResponse
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsCustomerReviews the fields to include for returned resources of type customerReviews
     * @param fieldsCustomerReviewResponses the fields to include for returned resources of type customerReviewResponses
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public appStoreVersionsCustomerReviewsGetToManyRelated(id: string, filterRating?: Array<string>, filterTerritory?: Array<'ABW' | 'AFG' | 'AGO' | 'AIA' | 'ALB' | 'AND' | 'ANT' | 'ARE' | 'ARG' | 'ARM' | 'ASM' | 'ATG' | 'AUS' | 'AUT' | 'AZE' | 'BDI' | 'BEL' | 'BEN' | 'BES' | 'BFA' | 'BGD' | 'BGR' | 'BHR' | 'BHS' | 'BIH' | 'BLR' | 'BLZ' | 'BMU' | 'BOL' | 'BRA' | 'BRB' | 'BRN' | 'BTN' | 'BWA' | 'CAF' | 'CAN' | 'CHE' | 'CHL' | 'CHN' | 'CIV' | 'CMR' | 'COD' | 'COG' | 'COK' | 'COL' | 'COM' | 'CPV' | 'CRI' | 'CUB' | 'CUW' | 'CXR' | 'CYM' | 'CYP' | 'CZE' | 'DEU' | 'DJI' | 'DMA' | 'DNK' | 'DOM' | 'DZA' | 'ECU' | 'EGY' | 'ERI' | 'ESP' | 'EST' | 'ETH' | 'FIN' | 'FJI' | 'FLK' | 'FRA' | 'FRO' | 'FSM' | 'GAB' | 'GBR' | 'GEO' | 'GGY' | 'GHA' | 'GIB' | 'GIN' | 'GLP' | 'GMB' | 'GNB' | 'GNQ' | 'GRC' | 'GRD' | 'GRL' | 'GTM' | 'GUF' | 'GUM' | 'GUY' | 'HKG' | 'HND' | 'HRV' | 'HTI' | 'HUN' | 'IDN' | 'IMN' | 'IND' | 'IRL' | 'IRQ' | 'ISL' | 'ISR' | 'ITA' | 'JAM' | 'JEY' | 'JOR' | 'JPN' | 'KAZ' | 'KEN' | 'KGZ' | 'KHM' | 'KIR' | 'KNA' | 'KOR' | 'KWT' | 'LAO' | 'LBN' | 'LBR' | 'LBY' | 'LCA' | 'LIE' | 'LKA' | 'LSO' | 'LTU' | 'LUX' | 'LVA' | 'MAC' | 'MAR' | 'MCO' | 'MDA' | 'MDG' | 'MDV' | 'MEX' | 'MHL' | 'MKD' | 'MLI' | 'MLT' | 'MMR' | 'MNE' | 'MNG' | 'MNP' | 'MOZ' | 'MRT' | 'MSR' | 'MTQ' | 'MUS' | 'MWI' | 'MYS' | 'MYT' | 'NAM' | 'NCL' | 'NER' | 'NFK' | 'NGA' | 'NIC' | 'NIU' | 'NLD' | 'NOR' | 'NPL' | 'NRU' | 'NZL' | 'OMN' | 'PAK' | 'PAN' | 'PER' | 'PHL' | 'PLW' | 'PNG' | 'POL' | 'PRI' | 'PRT' | 'PRY' | 'PSE' | 'PYF' | 'QAT' | 'REU' | 'ROU' | 'RUS' | 'RWA' | 'SAU' | 'SEN' | 'SGP' | 'SHN' | 'SLB' | 'SLE' | 'SLV' | 'SMR' | 'SOM' | 'SPM' | 'SRB' | 'SSD' | 'STP' | 'SUR' | 'SVK' | 'SVN' | 'SWE' | 'SWZ' | 'SXM' | 'SYC' | 'TCA' | 'TCD' | 'TGO' | 'THA' | 'TJK' | 'TKM' | 'TLS' | 'TON' | 'TTO' | 'TUN' | 'TUR' | 'TUV' | 'TWN' | 'TZA' | 'UGA' | 'UKR' | 'UMI' | 'URY' | 'USA' | 'UZB' | 'VAT' | 'VCT' | 'VEN' | 'VGB' | 'VIR' | 'VNM' | 'VUT' | 'WLF' | 'WSM' | 'YEM' | 'ZAF' | 'ZMB' | 'ZWE'>, existsPublishedResponse?: boolean, sort?: Array<'createdDate' | '-createdDate' | 'rating' | '-rating'>, fieldsCustomerReviews?: Array<'body' | 'createdDate' | 'rating' | 'response' | 'reviewerNickname' | 'territory' | 'title'>, fieldsCustomerReviewResponses?: Array<'lastModifiedDate' | 'responseBody' | 'review' | 'state'>, limit?: number, include?: Array<'response'>, _options?: Configuration): Observable<CustomerReviewsResponse> {
        return this.appStoreVersionsCustomerReviewsGetToManyRelatedWithHttpInfo(id, filterRating, filterTerritory, existsPublishedResponse, sort, fieldsCustomerReviews, fieldsCustomerReviewResponses, limit, include, _options).pipe(map((apiResponse: HttpInfo<CustomerReviewsResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public appStoreVersionsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.appStoreVersionsDeleteInstance(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appStoreVersionsDeleteInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public appStoreVersionsDeleteInstance(id: string, _options?: Configuration): Observable<void> {
        return this.appStoreVersionsDeleteInstanceWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param include comma-separated list of relationships to include
     * @param fieldsAppStoreVersionExperiments the fields to include for returned resources of type appStoreVersionExperiments
     * @param fieldsAppStoreVersionSubmissions the fields to include for returned resources of type appStoreVersionSubmissions
     * @param fieldsAgeRatingDeclarations the fields to include for returned resources of type ageRatingDeclarations
     * @param fieldsAlternativeDistributionPackages the fields to include for returned resources of type alternativeDistributionPackages
     * @param fieldsCustomerReviews the fields to include for returned resources of type customerReviews
     * @param fieldsAppStoreReviewDetails the fields to include for returned resources of type appStoreReviewDetails
     * @param fieldsAppClipDefaultExperiences the fields to include for returned resources of type appClipDefaultExperiences
     * @param fieldsRoutingAppCoverages the fields to include for returned resources of type routingAppCoverages
     * @param fieldsAppStoreVersionPhasedReleases the fields to include for returned resources of type appStoreVersionPhasedReleases
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param fieldsAppStoreVersionLocalizations the fields to include for returned resources of type appStoreVersionLocalizations
     * @param limitAppStoreVersionExperiments maximum number of related appStoreVersionExperiments returned (when they are included)
     * @param limitAppStoreVersionExperimentsV2 maximum number of related appStoreVersionExperimentsV2 returned (when they are included)
     * @param limitAppStoreVersionLocalizations maximum number of related appStoreVersionLocalizations returned (when they are included)
     */
    public appStoreVersionsGetInstanceWithHttpInfo(id: string, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, include?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'build' | 'routingAppCoverage'>, fieldsAppStoreVersionExperiments?: Array<'app' | 'appStoreVersion' | 'appStoreVersionExperimentTreatments' | 'controlVersions' | 'endDate' | 'latestControlVersion' | 'name' | 'platform' | 'reviewRequired' | 'startDate' | 'started' | 'state' | 'trafficProportion'>, fieldsAppStoreVersionSubmissions?: Array<'appStoreVersion'>, fieldsAgeRatingDeclarations?: Array<'ageRatingOverride' | 'alcoholTobaccoOrDrugUseOrReferences' | 'contests' | 'gambling' | 'gamblingAndContests' | 'gamblingSimulated' | 'horrorOrFearThemes' | 'kidsAgeBand' | 'matureOrSuggestiveThemes' | 'medicalOrTreatmentInformation' | 'profanityOrCrudeHumor' | 'seventeenPlus' | 'sexualContentGraphicAndNudity' | 'sexualContentOrNudity' | 'unrestrictedWebAccess' | 'violenceCartoonOrFantasy' | 'violenceRealistic' | 'violenceRealisticProlongedGraphicOrSadistic'>, fieldsAlternativeDistributionPackages?: Array<'appStoreVersion' | 'versions'>, fieldsCustomerReviews?: Array<'body' | 'createdDate' | 'rating' | 'response' | 'reviewerNickname' | 'territory' | 'title'>, fieldsAppStoreReviewDetails?: Array<'appStoreReviewAttachments' | 'appStoreVersion' | 'contactEmail' | 'contactFirstName' | 'contactLastName' | 'contactPhone' | 'demoAccountName' | 'demoAccountPassword' | 'demoAccountRequired' | 'notes'>, fieldsAppClipDefaultExperiences?: Array<'action' | 'appClip' | 'appClipAppStoreReviewDetail' | 'appClipDefaultExperienceLocalizations' | 'appClipDefaultExperienceTemplate' | 'releaseWithAppStoreVersion'>, fieldsRoutingAppCoverages?: Array<'appStoreVersion' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, fieldsAppStoreVersionPhasedReleases?: Array<'appStoreVersion' | 'currentDayNumber' | 'phasedReleaseState' | 'startDate' | 'totalPauseDuration'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, fieldsAppStoreVersionLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersion' | 'description' | 'keywords' | 'locale' | 'marketingUrl' | 'promotionalText' | 'supportUrl' | 'whatsNew'>, limitAppStoreVersionExperiments?: number, limitAppStoreVersionExperimentsV2?: number, limitAppStoreVersionLocalizations?: number, _options?: Configuration): Observable<HttpInfo<AppStoreVersionResponse>> {
        const requestContextPromise = this.requestFactory.appStoreVersionsGetInstance(id, fieldsAppStoreVersions, include, fieldsAppStoreVersionExperiments, fieldsAppStoreVersionSubmissions, fieldsAgeRatingDeclarations, fieldsAlternativeDistributionPackages, fieldsCustomerReviews, fieldsAppStoreReviewDetails, fieldsAppClipDefaultExperiences, fieldsRoutingAppCoverages, fieldsAppStoreVersionPhasedReleases, fieldsBuilds, fieldsAppStoreVersionLocalizations, limitAppStoreVersionExperiments, limitAppStoreVersionExperimentsV2, limitAppStoreVersionLocalizations, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appStoreVersionsGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param include comma-separated list of relationships to include
     * @param fieldsAppStoreVersionExperiments the fields to include for returned resources of type appStoreVersionExperiments
     * @param fieldsAppStoreVersionSubmissions the fields to include for returned resources of type appStoreVersionSubmissions
     * @param fieldsAgeRatingDeclarations the fields to include for returned resources of type ageRatingDeclarations
     * @param fieldsAlternativeDistributionPackages the fields to include for returned resources of type alternativeDistributionPackages
     * @param fieldsCustomerReviews the fields to include for returned resources of type customerReviews
     * @param fieldsAppStoreReviewDetails the fields to include for returned resources of type appStoreReviewDetails
     * @param fieldsAppClipDefaultExperiences the fields to include for returned resources of type appClipDefaultExperiences
     * @param fieldsRoutingAppCoverages the fields to include for returned resources of type routingAppCoverages
     * @param fieldsAppStoreVersionPhasedReleases the fields to include for returned resources of type appStoreVersionPhasedReleases
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param fieldsAppStoreVersionLocalizations the fields to include for returned resources of type appStoreVersionLocalizations
     * @param limitAppStoreVersionExperiments maximum number of related appStoreVersionExperiments returned (when they are included)
     * @param limitAppStoreVersionExperimentsV2 maximum number of related appStoreVersionExperimentsV2 returned (when they are included)
     * @param limitAppStoreVersionLocalizations maximum number of related appStoreVersionLocalizations returned (when they are included)
     */
    public appStoreVersionsGetInstance(id: string, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, include?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'build' | 'routingAppCoverage'>, fieldsAppStoreVersionExperiments?: Array<'app' | 'appStoreVersion' | 'appStoreVersionExperimentTreatments' | 'controlVersions' | 'endDate' | 'latestControlVersion' | 'name' | 'platform' | 'reviewRequired' | 'startDate' | 'started' | 'state' | 'trafficProportion'>, fieldsAppStoreVersionSubmissions?: Array<'appStoreVersion'>, fieldsAgeRatingDeclarations?: Array<'ageRatingOverride' | 'alcoholTobaccoOrDrugUseOrReferences' | 'contests' | 'gambling' | 'gamblingAndContests' | 'gamblingSimulated' | 'horrorOrFearThemes' | 'kidsAgeBand' | 'matureOrSuggestiveThemes' | 'medicalOrTreatmentInformation' | 'profanityOrCrudeHumor' | 'seventeenPlus' | 'sexualContentGraphicAndNudity' | 'sexualContentOrNudity' | 'unrestrictedWebAccess' | 'violenceCartoonOrFantasy' | 'violenceRealistic' | 'violenceRealisticProlongedGraphicOrSadistic'>, fieldsAlternativeDistributionPackages?: Array<'appStoreVersion' | 'versions'>, fieldsCustomerReviews?: Array<'body' | 'createdDate' | 'rating' | 'response' | 'reviewerNickname' | 'territory' | 'title'>, fieldsAppStoreReviewDetails?: Array<'appStoreReviewAttachments' | 'appStoreVersion' | 'contactEmail' | 'contactFirstName' | 'contactLastName' | 'contactPhone' | 'demoAccountName' | 'demoAccountPassword' | 'demoAccountRequired' | 'notes'>, fieldsAppClipDefaultExperiences?: Array<'action' | 'appClip' | 'appClipAppStoreReviewDetail' | 'appClipDefaultExperienceLocalizations' | 'appClipDefaultExperienceTemplate' | 'releaseWithAppStoreVersion'>, fieldsRoutingAppCoverages?: Array<'appStoreVersion' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, fieldsAppStoreVersionPhasedReleases?: Array<'appStoreVersion' | 'currentDayNumber' | 'phasedReleaseState' | 'startDate' | 'totalPauseDuration'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, fieldsAppStoreVersionLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersion' | 'description' | 'keywords' | 'locale' | 'marketingUrl' | 'promotionalText' | 'supportUrl' | 'whatsNew'>, limitAppStoreVersionExperiments?: number, limitAppStoreVersionExperimentsV2?: number, limitAppStoreVersionLocalizations?: number, _options?: Configuration): Observable<AppStoreVersionResponse> {
        return this.appStoreVersionsGetInstanceWithHttpInfo(id, fieldsAppStoreVersions, include, fieldsAppStoreVersionExperiments, fieldsAppStoreVersionSubmissions, fieldsAgeRatingDeclarations, fieldsAlternativeDistributionPackages, fieldsCustomerReviews, fieldsAppStoreReviewDetails, fieldsAppClipDefaultExperiences, fieldsRoutingAppCoverages, fieldsAppStoreVersionPhasedReleases, fieldsBuilds, fieldsAppStoreVersionLocalizations, limitAppStoreVersionExperiments, limitAppStoreVersionExperimentsV2, limitAppStoreVersionLocalizations, _options).pipe(map((apiResponse: HttpInfo<AppStoreVersionResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsRoutingAppCoverages the fields to include for returned resources of type routingAppCoverages
     */
    public appStoreVersionsRoutingAppCoverageGetToOneRelatedWithHttpInfo(id: string, fieldsRoutingAppCoverages?: Array<'appStoreVersion' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, _options?: Configuration): Observable<HttpInfo<RoutingAppCoverageWithoutIncludesResponse>> {
        const requestContextPromise = this.requestFactory.appStoreVersionsRoutingAppCoverageGetToOneRelated(id, fieldsRoutingAppCoverages, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appStoreVersionsRoutingAppCoverageGetToOneRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsRoutingAppCoverages the fields to include for returned resources of type routingAppCoverages
     */
    public appStoreVersionsRoutingAppCoverageGetToOneRelated(id: string, fieldsRoutingAppCoverages?: Array<'appStoreVersion' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, _options?: Configuration): Observable<RoutingAppCoverageWithoutIncludesResponse> {
        return this.appStoreVersionsRoutingAppCoverageGetToOneRelatedWithHttpInfo(id, fieldsRoutingAppCoverages, _options).pipe(map((apiResponse: HttpInfo<RoutingAppCoverageWithoutIncludesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param appStoreVersionUpdateRequest AppStoreVersion representation
     */
    public appStoreVersionsUpdateInstanceWithHttpInfo(id: string, appStoreVersionUpdateRequest: AppStoreVersionUpdateRequest, _options?: Configuration): Observable<HttpInfo<AppStoreVersionResponse>> {
        const requestContextPromise = this.requestFactory.appStoreVersionsUpdateInstance(id, appStoreVersionUpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appStoreVersionsUpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param appStoreVersionUpdateRequest AppStoreVersion representation
     */
    public appStoreVersionsUpdateInstance(id: string, appStoreVersionUpdateRequest: AppStoreVersionUpdateRequest, _options?: Configuration): Observable<AppStoreVersionResponse> {
        return this.appStoreVersionsUpdateInstanceWithHttpInfo(id, appStoreVersionUpdateRequest, _options).pipe(map((apiResponse: HttpInfo<AppStoreVersionResponse>) => apiResponse.data));
    }

}

import { AppsApiRequestFactory, AppsApiResponseProcessor} from "../apis/AppsApi.ts";
export class ObservableAppsApi {
    private requestFactory: AppsApiRequestFactory;
    private responseProcessor: AppsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: AppsApiRequestFactory,
        responseProcessor?: AppsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new AppsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new AppsApiResponseProcessor();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAlternativeDistributionKeys the fields to include for returned resources of type alternativeDistributionKeys
     */
    public appsAlternativeDistributionKeyGetToOneRelatedWithHttpInfo(id: string, fieldsAlternativeDistributionKeys?: Array<'app' | 'publicKey'>, _options?: Configuration): Observable<HttpInfo<AlternativeDistributionKeyResponse>> {
        const requestContextPromise = this.requestFactory.appsAlternativeDistributionKeyGetToOneRelated(id, fieldsAlternativeDistributionKeys, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appsAlternativeDistributionKeyGetToOneRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAlternativeDistributionKeys the fields to include for returned resources of type alternativeDistributionKeys
     */
    public appsAlternativeDistributionKeyGetToOneRelated(id: string, fieldsAlternativeDistributionKeys?: Array<'app' | 'publicKey'>, _options?: Configuration): Observable<AlternativeDistributionKeyResponse> {
        return this.appsAlternativeDistributionKeyGetToOneRelatedWithHttpInfo(id, fieldsAlternativeDistributionKeys, _options).pipe(map((apiResponse: HttpInfo<AlternativeDistributionKeyResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param filterAccessType filter by attribute \&#39;accessType\&#39;
     * @param fieldsAnalyticsReportRequests the fields to include for returned resources of type analyticsReportRequests
     * @param fieldsAnalyticsReports the fields to include for returned resources of type analyticsReports
     * @param limit maximum resources per page
     * @param limitReports maximum number of related reports returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appsAnalyticsReportRequestsGetToManyRelatedWithHttpInfo(id: string, filterAccessType?: Array<'ONE_TIME_SNAPSHOT' | 'ONGOING'>, fieldsAnalyticsReportRequests?: Array<'accessType' | 'app' | 'reports' | 'stoppedDueToInactivity'>, fieldsAnalyticsReports?: Array<'category' | 'instances' | 'name'>, limit?: number, limitReports?: number, include?: Array<'reports'>, _options?: Configuration): Observable<HttpInfo<AnalyticsReportRequestsResponse>> {
        const requestContextPromise = this.requestFactory.appsAnalyticsReportRequestsGetToManyRelated(id, filterAccessType, fieldsAnalyticsReportRequests, fieldsAnalyticsReports, limit, limitReports, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appsAnalyticsReportRequestsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param filterAccessType filter by attribute \&#39;accessType\&#39;
     * @param fieldsAnalyticsReportRequests the fields to include for returned resources of type analyticsReportRequests
     * @param fieldsAnalyticsReports the fields to include for returned resources of type analyticsReports
     * @param limit maximum resources per page
     * @param limitReports maximum number of related reports returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appsAnalyticsReportRequestsGetToManyRelated(id: string, filterAccessType?: Array<'ONE_TIME_SNAPSHOT' | 'ONGOING'>, fieldsAnalyticsReportRequests?: Array<'accessType' | 'app' | 'reports' | 'stoppedDueToInactivity'>, fieldsAnalyticsReports?: Array<'category' | 'instances' | 'name'>, limit?: number, limitReports?: number, include?: Array<'reports'>, _options?: Configuration): Observable<AnalyticsReportRequestsResponse> {
        return this.appsAnalyticsReportRequestsGetToManyRelatedWithHttpInfo(id, filterAccessType, fieldsAnalyticsReportRequests, fieldsAnalyticsReports, limit, limitReports, include, _options).pipe(map((apiResponse: HttpInfo<AnalyticsReportRequestsResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppAvailabilities the fields to include for returned resources of type appAvailabilities
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limitAvailableTerritories maximum number of related availableTerritories returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appsAppAvailabilityGetToOneRelatedWithHttpInfo(id: string, fieldsAppAvailabilities?: Array<'app' | 'availableInNewTerritories' | 'availableTerritories'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsTerritories?: Array<'currency'>, limitAvailableTerritories?: number, include?: Array<'app' | 'availableTerritories'>, _options?: Configuration): Observable<HttpInfo<AppAvailabilityResponse>> {
        const requestContextPromise = this.requestFactory.appsAppAvailabilityGetToOneRelated(id, fieldsAppAvailabilities, fieldsApps, fieldsTerritories, limitAvailableTerritories, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appsAppAvailabilityGetToOneRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppAvailabilities the fields to include for returned resources of type appAvailabilities
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limitAvailableTerritories maximum number of related availableTerritories returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appsAppAvailabilityGetToOneRelated(id: string, fieldsAppAvailabilities?: Array<'app' | 'availableInNewTerritories' | 'availableTerritories'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsTerritories?: Array<'currency'>, limitAvailableTerritories?: number, include?: Array<'app' | 'availableTerritories'>, _options?: Configuration): Observable<AppAvailabilityResponse> {
        return this.appsAppAvailabilityGetToOneRelatedWithHttpInfo(id, fieldsAppAvailabilities, fieldsApps, fieldsTerritories, limitAvailableTerritories, include, _options).pipe(map((apiResponse: HttpInfo<AppAvailabilityResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param filterBundleId filter by attribute \&#39;bundleId\&#39;
     * @param fieldsAppClips the fields to include for returned resources of type appClips
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsAppClipDefaultExperiences the fields to include for returned resources of type appClipDefaultExperiences
     * @param limit maximum resources per page
     * @param limitAppClipDefaultExperiences maximum number of related appClipDefaultExperiences returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appsAppClipsGetToManyRelatedWithHttpInfo(id: string, filterBundleId?: Array<string>, fieldsAppClips?: Array<'app' | 'appClipAdvancedExperiences' | 'appClipDefaultExperiences' | 'bundleId'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsAppClipDefaultExperiences?: Array<'action' | 'appClip' | 'appClipAppStoreReviewDetail' | 'appClipDefaultExperienceLocalizations' | 'appClipDefaultExperienceTemplate' | 'releaseWithAppStoreVersion'>, limit?: number, limitAppClipDefaultExperiences?: number, include?: Array<'app' | 'appClipDefaultExperiences'>, _options?: Configuration): Observable<HttpInfo<AppClipsResponse>> {
        const requestContextPromise = this.requestFactory.appsAppClipsGetToManyRelated(id, filterBundleId, fieldsAppClips, fieldsApps, fieldsAppClipDefaultExperiences, limit, limitAppClipDefaultExperiences, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appsAppClipsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param filterBundleId filter by attribute \&#39;bundleId\&#39;
     * @param fieldsAppClips the fields to include for returned resources of type appClips
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsAppClipDefaultExperiences the fields to include for returned resources of type appClipDefaultExperiences
     * @param limit maximum resources per page
     * @param limitAppClipDefaultExperiences maximum number of related appClipDefaultExperiences returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appsAppClipsGetToManyRelated(id: string, filterBundleId?: Array<string>, fieldsAppClips?: Array<'app' | 'appClipAdvancedExperiences' | 'appClipDefaultExperiences' | 'bundleId'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsAppClipDefaultExperiences?: Array<'action' | 'appClip' | 'appClipAppStoreReviewDetail' | 'appClipDefaultExperienceLocalizations' | 'appClipDefaultExperienceTemplate' | 'releaseWithAppStoreVersion'>, limit?: number, limitAppClipDefaultExperiences?: number, include?: Array<'app' | 'appClipDefaultExperiences'>, _options?: Configuration): Observable<AppClipsResponse> {
        return this.appsAppClipsGetToManyRelatedWithHttpInfo(id, filterBundleId, fieldsAppClips, fieldsApps, fieldsAppClipDefaultExperiences, limit, limitAppClipDefaultExperiences, include, _options).pipe(map((apiResponse: HttpInfo<AppClipsResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param filterVisible filter by attribute \&#39;visible\&#39;
     * @param fieldsAppCustomProductPages the fields to include for returned resources of type appCustomProductPages
     * @param fieldsAppCustomProductPageVersions the fields to include for returned resources of type appCustomProductPageVersions
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param limit maximum resources per page
     * @param limitAppCustomProductPageVersions maximum number of related appCustomProductPageVersions returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appsAppCustomProductPagesGetToManyRelatedWithHttpInfo(id: string, filterVisible?: Array<string>, fieldsAppCustomProductPages?: Array<'app' | 'appCustomProductPageVersions' | 'appStoreVersionTemplate' | 'customProductPageTemplate' | 'name' | 'url' | 'visible'>, fieldsAppCustomProductPageVersions?: Array<'appCustomProductPage' | 'appCustomProductPageLocalizations' | 'state' | 'version'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, limit?: number, limitAppCustomProductPageVersions?: number, include?: Array<'app' | 'appCustomProductPageVersions'>, _options?: Configuration): Observable<HttpInfo<AppCustomProductPagesResponse>> {
        const requestContextPromise = this.requestFactory.appsAppCustomProductPagesGetToManyRelated(id, filterVisible, fieldsAppCustomProductPages, fieldsAppCustomProductPageVersions, fieldsApps, limit, limitAppCustomProductPageVersions, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appsAppCustomProductPagesGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param filterVisible filter by attribute \&#39;visible\&#39;
     * @param fieldsAppCustomProductPages the fields to include for returned resources of type appCustomProductPages
     * @param fieldsAppCustomProductPageVersions the fields to include for returned resources of type appCustomProductPageVersions
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param limit maximum resources per page
     * @param limitAppCustomProductPageVersions maximum number of related appCustomProductPageVersions returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appsAppCustomProductPagesGetToManyRelated(id: string, filterVisible?: Array<string>, fieldsAppCustomProductPages?: Array<'app' | 'appCustomProductPageVersions' | 'appStoreVersionTemplate' | 'customProductPageTemplate' | 'name' | 'url' | 'visible'>, fieldsAppCustomProductPageVersions?: Array<'appCustomProductPage' | 'appCustomProductPageLocalizations' | 'state' | 'version'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, limit?: number, limitAppCustomProductPageVersions?: number, include?: Array<'app' | 'appCustomProductPageVersions'>, _options?: Configuration): Observable<AppCustomProductPagesResponse> {
        return this.appsAppCustomProductPagesGetToManyRelatedWithHttpInfo(id, filterVisible, fieldsAppCustomProductPages, fieldsAppCustomProductPageVersions, fieldsApps, limit, limitAppCustomProductPageVersions, include, _options).pipe(map((apiResponse: HttpInfo<AppCustomProductPagesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param filterPlatform filter by attribute \&#39;platform\&#39;
     * @param filterBuilds filter by id(s) of related \&#39;builds\&#39;
     * @param fieldsAppEncryptionDeclarations the fields to include for returned resources of type appEncryptionDeclarations
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsAppEncryptionDeclarationDocuments the fields to include for returned resources of type appEncryptionDeclarationDocuments
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param limit maximum resources per page
     * @param limitBuilds maximum number of related builds returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appsAppEncryptionDeclarationsGetToManyRelatedWithHttpInfo(id: string, filterPlatform?: Array<'IOS' | 'MAC_OS' | 'TV_OS' | 'VISION_OS'>, filterBuilds?: Array<string>, fieldsAppEncryptionDeclarations?: Array<'app' | 'appDescription' | 'appEncryptionDeclarationDocument' | 'appEncryptionDeclarationState' | 'availableOnFrenchStore' | 'builds' | 'codeValue' | 'containsProprietaryCryptography' | 'containsThirdPartyCryptography' | 'createdDate' | 'documentName' | 'documentType' | 'documentUrl' | 'exempt' | 'platform' | 'uploadedDate' | 'usesEncryption'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsAppEncryptionDeclarationDocuments?: Array<'appEncryptionDeclaration' | 'assetDeliveryState' | 'assetToken' | 'downloadUrl' | 'fileName' | 'fileSize' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, limit?: number, limitBuilds?: number, include?: Array<'app' | 'appEncryptionDeclarationDocument' | 'builds'>, _options?: Configuration): Observable<HttpInfo<AppEncryptionDeclarationsResponse>> {
        const requestContextPromise = this.requestFactory.appsAppEncryptionDeclarationsGetToManyRelated(id, filterPlatform, filterBuilds, fieldsAppEncryptionDeclarations, fieldsApps, fieldsAppEncryptionDeclarationDocuments, fieldsBuilds, limit, limitBuilds, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appsAppEncryptionDeclarationsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param filterPlatform filter by attribute \&#39;platform\&#39;
     * @param filterBuilds filter by id(s) of related \&#39;builds\&#39;
     * @param fieldsAppEncryptionDeclarations the fields to include for returned resources of type appEncryptionDeclarations
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsAppEncryptionDeclarationDocuments the fields to include for returned resources of type appEncryptionDeclarationDocuments
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param limit maximum resources per page
     * @param limitBuilds maximum number of related builds returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appsAppEncryptionDeclarationsGetToManyRelated(id: string, filterPlatform?: Array<'IOS' | 'MAC_OS' | 'TV_OS' | 'VISION_OS'>, filterBuilds?: Array<string>, fieldsAppEncryptionDeclarations?: Array<'app' | 'appDescription' | 'appEncryptionDeclarationDocument' | 'appEncryptionDeclarationState' | 'availableOnFrenchStore' | 'builds' | 'codeValue' | 'containsProprietaryCryptography' | 'containsThirdPartyCryptography' | 'createdDate' | 'documentName' | 'documentType' | 'documentUrl' | 'exempt' | 'platform' | 'uploadedDate' | 'usesEncryption'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsAppEncryptionDeclarationDocuments?: Array<'appEncryptionDeclaration' | 'assetDeliveryState' | 'assetToken' | 'downloadUrl' | 'fileName' | 'fileSize' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, limit?: number, limitBuilds?: number, include?: Array<'app' | 'appEncryptionDeclarationDocument' | 'builds'>, _options?: Configuration): Observable<AppEncryptionDeclarationsResponse> {
        return this.appsAppEncryptionDeclarationsGetToManyRelatedWithHttpInfo(id, filterPlatform, filterBuilds, fieldsAppEncryptionDeclarations, fieldsApps, fieldsAppEncryptionDeclarationDocuments, fieldsBuilds, limit, limitBuilds, include, _options).pipe(map((apiResponse: HttpInfo<AppEncryptionDeclarationsResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param filterEventState filter by attribute \&#39;eventState\&#39;
     * @param filterId filter by id(s)
     * @param fieldsAppEventLocalizations the fields to include for returned resources of type appEventLocalizations
     * @param fieldsAppEvents the fields to include for returned resources of type appEvents
     * @param limit maximum resources per page
     * @param limitLocalizations maximum number of related localizations returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appsAppEventsGetToManyRelatedWithHttpInfo(id: string, filterEventState?: Array<'DRAFT' | 'READY_FOR_REVIEW' | 'WAITING_FOR_REVIEW' | 'IN_REVIEW' | 'REJECTED' | 'ACCEPTED' | 'APPROVED' | 'PUBLISHED' | 'PAST' | 'ARCHIVED'>, filterId?: Array<string>, fieldsAppEventLocalizations?: Array<'appEvent' | 'appEventScreenshots' | 'appEventVideoClips' | 'locale' | 'longDescription' | 'name' | 'shortDescription'>, fieldsAppEvents?: Array<'app' | 'archivedTerritorySchedules' | 'badge' | 'deepLink' | 'eventState' | 'localizations' | 'primaryLocale' | 'priority' | 'purchaseRequirement' | 'purpose' | 'referenceName' | 'territorySchedules'>, limit?: number, limitLocalizations?: number, include?: Array<'localizations'>, _options?: Configuration): Observable<HttpInfo<AppEventsResponse>> {
        const requestContextPromise = this.requestFactory.appsAppEventsGetToManyRelated(id, filterEventState, filterId, fieldsAppEventLocalizations, fieldsAppEvents, limit, limitLocalizations, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appsAppEventsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param filterEventState filter by attribute \&#39;eventState\&#39;
     * @param filterId filter by id(s)
     * @param fieldsAppEventLocalizations the fields to include for returned resources of type appEventLocalizations
     * @param fieldsAppEvents the fields to include for returned resources of type appEvents
     * @param limit maximum resources per page
     * @param limitLocalizations maximum number of related localizations returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appsAppEventsGetToManyRelated(id: string, filterEventState?: Array<'DRAFT' | 'READY_FOR_REVIEW' | 'WAITING_FOR_REVIEW' | 'IN_REVIEW' | 'REJECTED' | 'ACCEPTED' | 'APPROVED' | 'PUBLISHED' | 'PAST' | 'ARCHIVED'>, filterId?: Array<string>, fieldsAppEventLocalizations?: Array<'appEvent' | 'appEventScreenshots' | 'appEventVideoClips' | 'locale' | 'longDescription' | 'name' | 'shortDescription'>, fieldsAppEvents?: Array<'app' | 'archivedTerritorySchedules' | 'badge' | 'deepLink' | 'eventState' | 'localizations' | 'primaryLocale' | 'priority' | 'purchaseRequirement' | 'purpose' | 'referenceName' | 'territorySchedules'>, limit?: number, limitLocalizations?: number, include?: Array<'localizations'>, _options?: Configuration): Observable<AppEventsResponse> {
        return this.appsAppEventsGetToManyRelatedWithHttpInfo(id, filterEventState, filterId, fieldsAppEventLocalizations, fieldsAppEvents, limit, limitLocalizations, include, _options).pipe(map((apiResponse: HttpInfo<AppEventsResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAgeRatingDeclarations the fields to include for returned resources of type ageRatingDeclarations
     * @param fieldsAppInfos the fields to include for returned resources of type appInfos
     * @param fieldsAppInfoLocalizations the fields to include for returned resources of type appInfoLocalizations
     * @param fieldsAppCategories the fields to include for returned resources of type appCategories
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param limit maximum resources per page
     * @param limitAppInfoLocalizations maximum number of related appInfoLocalizations returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appsAppInfosGetToManyRelatedWithHttpInfo(id: string, fieldsAgeRatingDeclarations?: Array<'ageRatingOverride' | 'alcoholTobaccoOrDrugUseOrReferences' | 'contests' | 'gambling' | 'gamblingAndContests' | 'gamblingSimulated' | 'horrorOrFearThemes' | 'kidsAgeBand' | 'matureOrSuggestiveThemes' | 'medicalOrTreatmentInformation' | 'profanityOrCrudeHumor' | 'seventeenPlus' | 'sexualContentGraphicAndNudity' | 'sexualContentOrNudity' | 'unrestrictedWebAccess' | 'violenceCartoonOrFantasy' | 'violenceRealistic' | 'violenceRealisticProlongedGraphicOrSadistic'>, fieldsAppInfos?: Array<'ageRatingDeclaration' | 'app' | 'appInfoLocalizations' | 'appStoreAgeRating' | 'appStoreState' | 'brazilAgeRating' | 'brazilAgeRatingV2' | 'kidsAgeBand' | 'primaryCategory' | 'primarySubcategoryOne' | 'primarySubcategoryTwo' | 'secondaryCategory' | 'secondarySubcategoryOne' | 'secondarySubcategoryTwo' | 'state'>, fieldsAppInfoLocalizations?: Array<'appInfo' | 'locale' | 'name' | 'privacyChoicesUrl' | 'privacyPolicyText' | 'privacyPolicyUrl' | 'subtitle'>, fieldsAppCategories?: Array<'parent' | 'platforms' | 'subcategories'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, limit?: number, limitAppInfoLocalizations?: number, include?: Array<'ageRatingDeclaration' | 'app' | 'appInfoLocalizations' | 'primaryCategory' | 'primarySubcategoryOne' | 'primarySubcategoryTwo' | 'secondaryCategory' | 'secondarySubcategoryOne' | 'secondarySubcategoryTwo'>, _options?: Configuration): Observable<HttpInfo<AppInfosResponse>> {
        const requestContextPromise = this.requestFactory.appsAppInfosGetToManyRelated(id, fieldsAgeRatingDeclarations, fieldsAppInfos, fieldsAppInfoLocalizations, fieldsAppCategories, fieldsApps, limit, limitAppInfoLocalizations, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appsAppInfosGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAgeRatingDeclarations the fields to include for returned resources of type ageRatingDeclarations
     * @param fieldsAppInfos the fields to include for returned resources of type appInfos
     * @param fieldsAppInfoLocalizations the fields to include for returned resources of type appInfoLocalizations
     * @param fieldsAppCategories the fields to include for returned resources of type appCategories
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param limit maximum resources per page
     * @param limitAppInfoLocalizations maximum number of related appInfoLocalizations returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appsAppInfosGetToManyRelated(id: string, fieldsAgeRatingDeclarations?: Array<'ageRatingOverride' | 'alcoholTobaccoOrDrugUseOrReferences' | 'contests' | 'gambling' | 'gamblingAndContests' | 'gamblingSimulated' | 'horrorOrFearThemes' | 'kidsAgeBand' | 'matureOrSuggestiveThemes' | 'medicalOrTreatmentInformation' | 'profanityOrCrudeHumor' | 'seventeenPlus' | 'sexualContentGraphicAndNudity' | 'sexualContentOrNudity' | 'unrestrictedWebAccess' | 'violenceCartoonOrFantasy' | 'violenceRealistic' | 'violenceRealisticProlongedGraphicOrSadistic'>, fieldsAppInfos?: Array<'ageRatingDeclaration' | 'app' | 'appInfoLocalizations' | 'appStoreAgeRating' | 'appStoreState' | 'brazilAgeRating' | 'brazilAgeRatingV2' | 'kidsAgeBand' | 'primaryCategory' | 'primarySubcategoryOne' | 'primarySubcategoryTwo' | 'secondaryCategory' | 'secondarySubcategoryOne' | 'secondarySubcategoryTwo' | 'state'>, fieldsAppInfoLocalizations?: Array<'appInfo' | 'locale' | 'name' | 'privacyChoicesUrl' | 'privacyPolicyText' | 'privacyPolicyUrl' | 'subtitle'>, fieldsAppCategories?: Array<'parent' | 'platforms' | 'subcategories'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, limit?: number, limitAppInfoLocalizations?: number, include?: Array<'ageRatingDeclaration' | 'app' | 'appInfoLocalizations' | 'primaryCategory' | 'primarySubcategoryOne' | 'primarySubcategoryTwo' | 'secondaryCategory' | 'secondarySubcategoryOne' | 'secondarySubcategoryTwo'>, _options?: Configuration): Observable<AppInfosResponse> {
        return this.appsAppInfosGetToManyRelatedWithHttpInfo(id, fieldsAgeRatingDeclarations, fieldsAppInfos, fieldsAppInfoLocalizations, fieldsAppCategories, fieldsApps, limit, limitAppInfoLocalizations, include, _options).pipe(map((apiResponse: HttpInfo<AppInfosResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param filterTerritory filter by id(s) of related \&#39;territory\&#39;
     * @param fieldsAppPricePoints the fields to include for returned resources of type appPricePoints
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public appsAppPricePointsGetToManyRelatedWithHttpInfo(id: string, filterTerritory?: Array<string>, fieldsAppPricePoints?: Array<'app' | 'customerPrice' | 'equalizations' | 'proceeds' | 'territory'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsTerritories?: Array<'currency'>, limit?: number, include?: Array<'app' | 'territory'>, _options?: Configuration): Observable<HttpInfo<AppPricePointsV3Response>> {
        const requestContextPromise = this.requestFactory.appsAppPricePointsGetToManyRelated(id, filterTerritory, fieldsAppPricePoints, fieldsApps, fieldsTerritories, limit, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appsAppPricePointsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param filterTerritory filter by id(s) of related \&#39;territory\&#39;
     * @param fieldsAppPricePoints the fields to include for returned resources of type appPricePoints
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public appsAppPricePointsGetToManyRelated(id: string, filterTerritory?: Array<string>, fieldsAppPricePoints?: Array<'app' | 'customerPrice' | 'equalizations' | 'proceeds' | 'territory'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsTerritories?: Array<'currency'>, limit?: number, include?: Array<'app' | 'territory'>, _options?: Configuration): Observable<AppPricePointsV3Response> {
        return this.appsAppPricePointsGetToManyRelatedWithHttpInfo(id, filterTerritory, fieldsAppPricePoints, fieldsApps, fieldsTerritories, limit, include, _options).pipe(map((apiResponse: HttpInfo<AppPricePointsV3Response>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppPrices the fields to include for returned resources of type appPrices
     * @param fieldsAppPriceSchedules the fields to include for returned resources of type appPriceSchedules
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limitManualPrices maximum number of related manualPrices returned (when they are included)
     * @param limitAutomaticPrices maximum number of related automaticPrices returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appsAppPriceScheduleGetToOneRelatedWithHttpInfo(id: string, fieldsAppPrices?: Array<'appPricePoint' | 'endDate' | 'manual' | 'startDate' | 'territory'>, fieldsAppPriceSchedules?: Array<'app' | 'automaticPrices' | 'baseTerritory' | 'manualPrices'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsTerritories?: Array<'currency'>, limitManualPrices?: number, limitAutomaticPrices?: number, include?: Array<'app' | 'automaticPrices' | 'baseTerritory' | 'manualPrices'>, _options?: Configuration): Observable<HttpInfo<AppPriceScheduleResponse>> {
        const requestContextPromise = this.requestFactory.appsAppPriceScheduleGetToOneRelated(id, fieldsAppPrices, fieldsAppPriceSchedules, fieldsApps, fieldsTerritories, limitManualPrices, limitAutomaticPrices, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appsAppPriceScheduleGetToOneRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppPrices the fields to include for returned resources of type appPrices
     * @param fieldsAppPriceSchedules the fields to include for returned resources of type appPriceSchedules
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limitManualPrices maximum number of related manualPrices returned (when they are included)
     * @param limitAutomaticPrices maximum number of related automaticPrices returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appsAppPriceScheduleGetToOneRelated(id: string, fieldsAppPrices?: Array<'appPricePoint' | 'endDate' | 'manual' | 'startDate' | 'territory'>, fieldsAppPriceSchedules?: Array<'app' | 'automaticPrices' | 'baseTerritory' | 'manualPrices'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsTerritories?: Array<'currency'>, limitManualPrices?: number, limitAutomaticPrices?: number, include?: Array<'app' | 'automaticPrices' | 'baseTerritory' | 'manualPrices'>, _options?: Configuration): Observable<AppPriceScheduleResponse> {
        return this.appsAppPriceScheduleGetToOneRelatedWithHttpInfo(id, fieldsAppPrices, fieldsAppPriceSchedules, fieldsApps, fieldsTerritories, limitManualPrices, limitAutomaticPrices, include, _options).pipe(map((apiResponse: HttpInfo<AppPriceScheduleResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param filterState filter by attribute \&#39;state\&#39;
     * @param fieldsAppStoreVersionExperiments the fields to include for returned resources of type appStoreVersionExperiments
     * @param fieldsAppStoreVersionExperimentTreatments the fields to include for returned resources of type appStoreVersionExperimentTreatments
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param limit maximum resources per page
     * @param limitControlVersions maximum number of related controlVersions returned (when they are included)
     * @param limitAppStoreVersionExperimentTreatments maximum number of related appStoreVersionExperimentTreatments returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appsAppStoreVersionExperimentsV2GetToManyRelatedWithHttpInfo(id: string, filterState?: Array<'PREPARE_FOR_SUBMISSION' | 'READY_FOR_REVIEW' | 'WAITING_FOR_REVIEW' | 'IN_REVIEW' | 'ACCEPTED' | 'APPROVED' | 'REJECTED' | 'COMPLETED' | 'STOPPED'>, fieldsAppStoreVersionExperiments?: Array<'app' | 'appStoreVersionExperimentTreatments' | 'controlVersions' | 'endDate' | 'latestControlVersion' | 'name' | 'platform' | 'reviewRequired' | 'startDate' | 'started' | 'state' | 'trafficProportion'>, fieldsAppStoreVersionExperimentTreatments?: Array<'appIcon' | 'appIconName' | 'appStoreVersionExperiment' | 'appStoreVersionExperimentTreatmentLocalizations' | 'appStoreVersionExperimentV2' | 'name' | 'promotedDate'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, limit?: number, limitControlVersions?: number, limitAppStoreVersionExperimentTreatments?: number, include?: Array<'app' | 'appStoreVersionExperimentTreatments' | 'controlVersions' | 'latestControlVersion'>, _options?: Configuration): Observable<HttpInfo<AppStoreVersionExperimentsV2Response>> {
        const requestContextPromise = this.requestFactory.appsAppStoreVersionExperimentsV2GetToManyRelated(id, filterState, fieldsAppStoreVersionExperiments, fieldsAppStoreVersionExperimentTreatments, fieldsAppStoreVersions, fieldsApps, limit, limitControlVersions, limitAppStoreVersionExperimentTreatments, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appsAppStoreVersionExperimentsV2GetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param filterState filter by attribute \&#39;state\&#39;
     * @param fieldsAppStoreVersionExperiments the fields to include for returned resources of type appStoreVersionExperiments
     * @param fieldsAppStoreVersionExperimentTreatments the fields to include for returned resources of type appStoreVersionExperimentTreatments
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param limit maximum resources per page
     * @param limitControlVersions maximum number of related controlVersions returned (when they are included)
     * @param limitAppStoreVersionExperimentTreatments maximum number of related appStoreVersionExperimentTreatments returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appsAppStoreVersionExperimentsV2GetToManyRelated(id: string, filterState?: Array<'PREPARE_FOR_SUBMISSION' | 'READY_FOR_REVIEW' | 'WAITING_FOR_REVIEW' | 'IN_REVIEW' | 'ACCEPTED' | 'APPROVED' | 'REJECTED' | 'COMPLETED' | 'STOPPED'>, fieldsAppStoreVersionExperiments?: Array<'app' | 'appStoreVersionExperimentTreatments' | 'controlVersions' | 'endDate' | 'latestControlVersion' | 'name' | 'platform' | 'reviewRequired' | 'startDate' | 'started' | 'state' | 'trafficProportion'>, fieldsAppStoreVersionExperimentTreatments?: Array<'appIcon' | 'appIconName' | 'appStoreVersionExperiment' | 'appStoreVersionExperimentTreatmentLocalizations' | 'appStoreVersionExperimentV2' | 'name' | 'promotedDate'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, limit?: number, limitControlVersions?: number, limitAppStoreVersionExperimentTreatments?: number, include?: Array<'app' | 'appStoreVersionExperimentTreatments' | 'controlVersions' | 'latestControlVersion'>, _options?: Configuration): Observable<AppStoreVersionExperimentsV2Response> {
        return this.appsAppStoreVersionExperimentsV2GetToManyRelatedWithHttpInfo(id, filterState, fieldsAppStoreVersionExperiments, fieldsAppStoreVersionExperimentTreatments, fieldsAppStoreVersions, fieldsApps, limit, limitControlVersions, limitAppStoreVersionExperimentTreatments, include, _options).pipe(map((apiResponse: HttpInfo<AppStoreVersionExperimentsV2Response>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param filterAppStoreState filter by attribute \&#39;appStoreState\&#39;
     * @param filterAppVersionState filter by attribute \&#39;appVersionState\&#39;
     * @param filterPlatform filter by attribute \&#39;platform\&#39;
     * @param filterVersionString filter by attribute \&#39;versionString\&#39;
     * @param filterId filter by id(s)
     * @param fieldsAgeRatingDeclarations the fields to include for returned resources of type ageRatingDeclarations
     * @param fieldsAppStoreReviewDetails the fields to include for returned resources of type appStoreReviewDetails
     * @param fieldsAppStoreVersionLocalizations the fields to include for returned resources of type appStoreVersionLocalizations
     * @param fieldsAppStoreVersionExperiments the fields to include for returned resources of type appStoreVersionExperiments
     * @param fieldsAppStoreVersionSubmissions the fields to include for returned resources of type appStoreVersionSubmissions
     * @param fieldsAlternativeDistributionPackages the fields to include for returned resources of type alternativeDistributionPackages
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsRoutingAppCoverages the fields to include for returned resources of type routingAppCoverages
     * @param fieldsAppClipDefaultExperiences the fields to include for returned resources of type appClipDefaultExperiences
     * @param fieldsAppStoreVersionPhasedReleases the fields to include for returned resources of type appStoreVersionPhasedReleases
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param limit maximum resources per page
     * @param limitAppStoreVersionLocalizations maximum number of related appStoreVersionLocalizations returned (when they are included)
     * @param limitAppStoreVersionExperiments maximum number of related appStoreVersionExperiments returned (when they are included)
     * @param limitAppStoreVersionExperimentsV2 maximum number of related appStoreVersionExperimentsV2 returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appsAppStoreVersionsGetToManyRelatedWithHttpInfo(id: string, filterAppStoreState?: Array<'ACCEPTED' | 'DEVELOPER_REMOVED_FROM_SALE' | 'DEVELOPER_REJECTED' | 'IN_REVIEW' | 'INVALID_BINARY' | 'METADATA_REJECTED' | 'PENDING_APPLE_RELEASE' | 'PENDING_CONTRACT' | 'PENDING_DEVELOPER_RELEASE' | 'PREPARE_FOR_SUBMISSION' | 'PREORDER_READY_FOR_SALE' | 'PROCESSING_FOR_APP_STORE' | 'READY_FOR_REVIEW' | 'READY_FOR_SALE' | 'REJECTED' | 'REMOVED_FROM_SALE' | 'WAITING_FOR_EXPORT_COMPLIANCE' | 'WAITING_FOR_REVIEW' | 'REPLACED_WITH_NEW_VERSION' | 'NOT_APPLICABLE'>, filterAppVersionState?: Array<'ACCEPTED' | 'DEVELOPER_REJECTED' | 'IN_REVIEW' | 'INVALID_BINARY' | 'METADATA_REJECTED' | 'PENDING_APPLE_RELEASE' | 'PENDING_DEVELOPER_RELEASE' | 'PREPARE_FOR_SUBMISSION' | 'PROCESSING_FOR_DISTRIBUTION' | 'READY_FOR_DISTRIBUTION' | 'READY_FOR_REVIEW' | 'REJECTED' | 'REPLACED_WITH_NEW_VERSION' | 'WAITING_FOR_EXPORT_COMPLIANCE' | 'WAITING_FOR_REVIEW'>, filterPlatform?: Array<'IOS' | 'MAC_OS' | 'TV_OS' | 'VISION_OS'>, filterVersionString?: Array<string>, filterId?: Array<string>, fieldsAgeRatingDeclarations?: Array<'ageRatingOverride' | 'alcoholTobaccoOrDrugUseOrReferences' | 'contests' | 'gambling' | 'gamblingAndContests' | 'gamblingSimulated' | 'horrorOrFearThemes' | 'kidsAgeBand' | 'matureOrSuggestiveThemes' | 'medicalOrTreatmentInformation' | 'profanityOrCrudeHumor' | 'seventeenPlus' | 'sexualContentGraphicAndNudity' | 'sexualContentOrNudity' | 'unrestrictedWebAccess' | 'violenceCartoonOrFantasy' | 'violenceRealistic' | 'violenceRealisticProlongedGraphicOrSadistic'>, fieldsAppStoreReviewDetails?: Array<'appStoreReviewAttachments' | 'appStoreVersion' | 'contactEmail' | 'contactFirstName' | 'contactLastName' | 'contactPhone' | 'demoAccountName' | 'demoAccountPassword' | 'demoAccountRequired' | 'notes'>, fieldsAppStoreVersionLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersion' | 'description' | 'keywords' | 'locale' | 'marketingUrl' | 'promotionalText' | 'supportUrl' | 'whatsNew'>, fieldsAppStoreVersionExperiments?: Array<'app' | 'appStoreVersion' | 'appStoreVersionExperimentTreatments' | 'controlVersions' | 'endDate' | 'latestControlVersion' | 'name' | 'platform' | 'reviewRequired' | 'startDate' | 'started' | 'state' | 'trafficProportion'>, fieldsAppStoreVersionSubmissions?: Array<'appStoreVersion'>, fieldsAlternativeDistributionPackages?: Array<'appStoreVersion' | 'versions'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsRoutingAppCoverages?: Array<'appStoreVersion' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, fieldsAppClipDefaultExperiences?: Array<'action' | 'appClip' | 'appClipAppStoreReviewDetail' | 'appClipDefaultExperienceLocalizations' | 'appClipDefaultExperienceTemplate' | 'releaseWithAppStoreVersion'>, fieldsAppStoreVersionPhasedReleases?: Array<'appStoreVersion' | 'currentDayNumber' | 'phasedReleaseState' | 'startDate' | 'totalPauseDuration'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, limit?: number, limitAppStoreVersionLocalizations?: number, limitAppStoreVersionExperiments?: number, limitAppStoreVersionExperimentsV2?: number, include?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'build' | 'routingAppCoverage'>, _options?: Configuration): Observable<HttpInfo<AppStoreVersionsResponse>> {
        const requestContextPromise = this.requestFactory.appsAppStoreVersionsGetToManyRelated(id, filterAppStoreState, filterAppVersionState, filterPlatform, filterVersionString, filterId, fieldsAgeRatingDeclarations, fieldsAppStoreReviewDetails, fieldsAppStoreVersionLocalizations, fieldsAppStoreVersionExperiments, fieldsAppStoreVersionSubmissions, fieldsAlternativeDistributionPackages, fieldsAppStoreVersions, fieldsApps, fieldsRoutingAppCoverages, fieldsAppClipDefaultExperiences, fieldsAppStoreVersionPhasedReleases, fieldsBuilds, limit, limitAppStoreVersionLocalizations, limitAppStoreVersionExperiments, limitAppStoreVersionExperimentsV2, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appsAppStoreVersionsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param filterAppStoreState filter by attribute \&#39;appStoreState\&#39;
     * @param filterAppVersionState filter by attribute \&#39;appVersionState\&#39;
     * @param filterPlatform filter by attribute \&#39;platform\&#39;
     * @param filterVersionString filter by attribute \&#39;versionString\&#39;
     * @param filterId filter by id(s)
     * @param fieldsAgeRatingDeclarations the fields to include for returned resources of type ageRatingDeclarations
     * @param fieldsAppStoreReviewDetails the fields to include for returned resources of type appStoreReviewDetails
     * @param fieldsAppStoreVersionLocalizations the fields to include for returned resources of type appStoreVersionLocalizations
     * @param fieldsAppStoreVersionExperiments the fields to include for returned resources of type appStoreVersionExperiments
     * @param fieldsAppStoreVersionSubmissions the fields to include for returned resources of type appStoreVersionSubmissions
     * @param fieldsAlternativeDistributionPackages the fields to include for returned resources of type alternativeDistributionPackages
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsRoutingAppCoverages the fields to include for returned resources of type routingAppCoverages
     * @param fieldsAppClipDefaultExperiences the fields to include for returned resources of type appClipDefaultExperiences
     * @param fieldsAppStoreVersionPhasedReleases the fields to include for returned resources of type appStoreVersionPhasedReleases
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param limit maximum resources per page
     * @param limitAppStoreVersionLocalizations maximum number of related appStoreVersionLocalizations returned (when they are included)
     * @param limitAppStoreVersionExperiments maximum number of related appStoreVersionExperiments returned (when they are included)
     * @param limitAppStoreVersionExperimentsV2 maximum number of related appStoreVersionExperimentsV2 returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appsAppStoreVersionsGetToManyRelated(id: string, filterAppStoreState?: Array<'ACCEPTED' | 'DEVELOPER_REMOVED_FROM_SALE' | 'DEVELOPER_REJECTED' | 'IN_REVIEW' | 'INVALID_BINARY' | 'METADATA_REJECTED' | 'PENDING_APPLE_RELEASE' | 'PENDING_CONTRACT' | 'PENDING_DEVELOPER_RELEASE' | 'PREPARE_FOR_SUBMISSION' | 'PREORDER_READY_FOR_SALE' | 'PROCESSING_FOR_APP_STORE' | 'READY_FOR_REVIEW' | 'READY_FOR_SALE' | 'REJECTED' | 'REMOVED_FROM_SALE' | 'WAITING_FOR_EXPORT_COMPLIANCE' | 'WAITING_FOR_REVIEW' | 'REPLACED_WITH_NEW_VERSION' | 'NOT_APPLICABLE'>, filterAppVersionState?: Array<'ACCEPTED' | 'DEVELOPER_REJECTED' | 'IN_REVIEW' | 'INVALID_BINARY' | 'METADATA_REJECTED' | 'PENDING_APPLE_RELEASE' | 'PENDING_DEVELOPER_RELEASE' | 'PREPARE_FOR_SUBMISSION' | 'PROCESSING_FOR_DISTRIBUTION' | 'READY_FOR_DISTRIBUTION' | 'READY_FOR_REVIEW' | 'REJECTED' | 'REPLACED_WITH_NEW_VERSION' | 'WAITING_FOR_EXPORT_COMPLIANCE' | 'WAITING_FOR_REVIEW'>, filterPlatform?: Array<'IOS' | 'MAC_OS' | 'TV_OS' | 'VISION_OS'>, filterVersionString?: Array<string>, filterId?: Array<string>, fieldsAgeRatingDeclarations?: Array<'ageRatingOverride' | 'alcoholTobaccoOrDrugUseOrReferences' | 'contests' | 'gambling' | 'gamblingAndContests' | 'gamblingSimulated' | 'horrorOrFearThemes' | 'kidsAgeBand' | 'matureOrSuggestiveThemes' | 'medicalOrTreatmentInformation' | 'profanityOrCrudeHumor' | 'seventeenPlus' | 'sexualContentGraphicAndNudity' | 'sexualContentOrNudity' | 'unrestrictedWebAccess' | 'violenceCartoonOrFantasy' | 'violenceRealistic' | 'violenceRealisticProlongedGraphicOrSadistic'>, fieldsAppStoreReviewDetails?: Array<'appStoreReviewAttachments' | 'appStoreVersion' | 'contactEmail' | 'contactFirstName' | 'contactLastName' | 'contactPhone' | 'demoAccountName' | 'demoAccountPassword' | 'demoAccountRequired' | 'notes'>, fieldsAppStoreVersionLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersion' | 'description' | 'keywords' | 'locale' | 'marketingUrl' | 'promotionalText' | 'supportUrl' | 'whatsNew'>, fieldsAppStoreVersionExperiments?: Array<'app' | 'appStoreVersion' | 'appStoreVersionExperimentTreatments' | 'controlVersions' | 'endDate' | 'latestControlVersion' | 'name' | 'platform' | 'reviewRequired' | 'startDate' | 'started' | 'state' | 'trafficProportion'>, fieldsAppStoreVersionSubmissions?: Array<'appStoreVersion'>, fieldsAlternativeDistributionPackages?: Array<'appStoreVersion' | 'versions'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsRoutingAppCoverages?: Array<'appStoreVersion' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, fieldsAppClipDefaultExperiences?: Array<'action' | 'appClip' | 'appClipAppStoreReviewDetail' | 'appClipDefaultExperienceLocalizations' | 'appClipDefaultExperienceTemplate' | 'releaseWithAppStoreVersion'>, fieldsAppStoreVersionPhasedReleases?: Array<'appStoreVersion' | 'currentDayNumber' | 'phasedReleaseState' | 'startDate' | 'totalPauseDuration'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, limit?: number, limitAppStoreVersionLocalizations?: number, limitAppStoreVersionExperiments?: number, limitAppStoreVersionExperimentsV2?: number, include?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'build' | 'routingAppCoverage'>, _options?: Configuration): Observable<AppStoreVersionsResponse> {
        return this.appsAppStoreVersionsGetToManyRelatedWithHttpInfo(id, filterAppStoreState, filterAppVersionState, filterPlatform, filterVersionString, filterId, fieldsAgeRatingDeclarations, fieldsAppStoreReviewDetails, fieldsAppStoreVersionLocalizations, fieldsAppStoreVersionExperiments, fieldsAppStoreVersionSubmissions, fieldsAlternativeDistributionPackages, fieldsAppStoreVersions, fieldsApps, fieldsRoutingAppCoverages, fieldsAppClipDefaultExperiences, fieldsAppStoreVersionPhasedReleases, fieldsBuilds, limit, limitAppStoreVersionLocalizations, limitAppStoreVersionExperiments, limitAppStoreVersionExperimentsV2, include, _options).pipe(map((apiResponse: HttpInfo<AppStoreVersionsResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limit maximum resources per page
     */
    public appsAvailableTerritoriesGetToManyRelatedWithHttpInfo(id: string, fieldsTerritories?: Array<'currency'>, limit?: number, _options?: Configuration): Observable<HttpInfo<TerritoriesResponse>> {
        const requestContextPromise = this.requestFactory.appsAvailableTerritoriesGetToManyRelated(id, fieldsTerritories, limit, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appsAvailableTerritoriesGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limit maximum resources per page
     */
    public appsAvailableTerritoriesGetToManyRelated(id: string, fieldsTerritories?: Array<'currency'>, limit?: number, _options?: Configuration): Observable<TerritoriesResponse> {
        return this.appsAvailableTerritoriesGetToManyRelatedWithHttpInfo(id, fieldsTerritories, limit, _options).pipe(map((apiResponse: HttpInfo<TerritoriesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBetaAppLocalizations the fields to include for returned resources of type betaAppLocalizations
     * @param limit maximum resources per page
     */
    public appsBetaAppLocalizationsGetToManyRelatedWithHttpInfo(id: string, fieldsBetaAppLocalizations?: Array<'app' | 'description' | 'feedbackEmail' | 'locale' | 'marketingUrl' | 'privacyPolicyUrl' | 'tvOsPrivacyPolicy'>, limit?: number, _options?: Configuration): Observable<HttpInfo<BetaAppLocalizationsWithoutIncludesResponse>> {
        const requestContextPromise = this.requestFactory.appsBetaAppLocalizationsGetToManyRelated(id, fieldsBetaAppLocalizations, limit, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appsBetaAppLocalizationsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBetaAppLocalizations the fields to include for returned resources of type betaAppLocalizations
     * @param limit maximum resources per page
     */
    public appsBetaAppLocalizationsGetToManyRelated(id: string, fieldsBetaAppLocalizations?: Array<'app' | 'description' | 'feedbackEmail' | 'locale' | 'marketingUrl' | 'privacyPolicyUrl' | 'tvOsPrivacyPolicy'>, limit?: number, _options?: Configuration): Observable<BetaAppLocalizationsWithoutIncludesResponse> {
        return this.appsBetaAppLocalizationsGetToManyRelatedWithHttpInfo(id, fieldsBetaAppLocalizations, limit, _options).pipe(map((apiResponse: HttpInfo<BetaAppLocalizationsWithoutIncludesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBetaAppReviewDetails the fields to include for returned resources of type betaAppReviewDetails
     */
    public appsBetaAppReviewDetailGetToOneRelatedWithHttpInfo(id: string, fieldsBetaAppReviewDetails?: Array<'app' | 'contactEmail' | 'contactFirstName' | 'contactLastName' | 'contactPhone' | 'demoAccountName' | 'demoAccountPassword' | 'demoAccountRequired' | 'notes'>, _options?: Configuration): Observable<HttpInfo<BetaAppReviewDetailWithoutIncludesResponse>> {
        const requestContextPromise = this.requestFactory.appsBetaAppReviewDetailGetToOneRelated(id, fieldsBetaAppReviewDetails, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appsBetaAppReviewDetailGetToOneRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBetaAppReviewDetails the fields to include for returned resources of type betaAppReviewDetails
     */
    public appsBetaAppReviewDetailGetToOneRelated(id: string, fieldsBetaAppReviewDetails?: Array<'app' | 'contactEmail' | 'contactFirstName' | 'contactLastName' | 'contactPhone' | 'demoAccountName' | 'demoAccountPassword' | 'demoAccountRequired' | 'notes'>, _options?: Configuration): Observable<BetaAppReviewDetailWithoutIncludesResponse> {
        return this.appsBetaAppReviewDetailGetToOneRelatedWithHttpInfo(id, fieldsBetaAppReviewDetails, _options).pipe(map((apiResponse: HttpInfo<BetaAppReviewDetailWithoutIncludesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBetaGroups the fields to include for returned resources of type betaGroups
     * @param limit maximum resources per page
     */
    public appsBetaGroupsGetToManyRelatedWithHttpInfo(id: string, fieldsBetaGroups?: Array<'app' | 'betaTesters' | 'builds' | 'createdDate' | 'feedbackEnabled' | 'hasAccessToAllBuilds' | 'iosBuildsAvailableForAppleSiliconMac' | 'isInternalGroup' | 'name' | 'publicLink' | 'publicLinkEnabled' | 'publicLinkId' | 'publicLinkLimit' | 'publicLinkLimitEnabled'>, limit?: number, _options?: Configuration): Observable<HttpInfo<BetaGroupsWithoutIncludesResponse>> {
        const requestContextPromise = this.requestFactory.appsBetaGroupsGetToManyRelated(id, fieldsBetaGroups, limit, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appsBetaGroupsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBetaGroups the fields to include for returned resources of type betaGroups
     * @param limit maximum resources per page
     */
    public appsBetaGroupsGetToManyRelated(id: string, fieldsBetaGroups?: Array<'app' | 'betaTesters' | 'builds' | 'createdDate' | 'feedbackEnabled' | 'hasAccessToAllBuilds' | 'iosBuildsAvailableForAppleSiliconMac' | 'isInternalGroup' | 'name' | 'publicLink' | 'publicLinkEnabled' | 'publicLinkId' | 'publicLinkLimit' | 'publicLinkLimitEnabled'>, limit?: number, _options?: Configuration): Observable<BetaGroupsWithoutIncludesResponse> {
        return this.appsBetaGroupsGetToManyRelatedWithHttpInfo(id, fieldsBetaGroups, limit, _options).pipe(map((apiResponse: HttpInfo<BetaGroupsWithoutIncludesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBetaLicenseAgreements the fields to include for returned resources of type betaLicenseAgreements
     */
    public appsBetaLicenseAgreementGetToOneRelatedWithHttpInfo(id: string, fieldsBetaLicenseAgreements?: Array<'agreementText' | 'app'>, _options?: Configuration): Observable<HttpInfo<BetaLicenseAgreementWithoutIncludesResponse>> {
        const requestContextPromise = this.requestFactory.appsBetaLicenseAgreementGetToOneRelated(id, fieldsBetaLicenseAgreements, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appsBetaLicenseAgreementGetToOneRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBetaLicenseAgreements the fields to include for returned resources of type betaLicenseAgreements
     */
    public appsBetaLicenseAgreementGetToOneRelated(id: string, fieldsBetaLicenseAgreements?: Array<'agreementText' | 'app'>, _options?: Configuration): Observable<BetaLicenseAgreementWithoutIncludesResponse> {
        return this.appsBetaLicenseAgreementGetToOneRelatedWithHttpInfo(id, fieldsBetaLicenseAgreements, _options).pipe(map((apiResponse: HttpInfo<BetaLicenseAgreementWithoutIncludesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum number of groups to return per page
     * @param groupBy the dimension by which to group the results
     * @param filterBetaTesters filter by \&#39;betaTesters\&#39; relationship dimension
     * @param period the duration of the reporting period
     */
    public appsBetaTesterUsagesGetMetricsWithHttpInfo(id: string, limit?: number, groupBy?: Array<'betaTesters'>, filterBetaTesters?: string, period?: 'P7D' | 'P30D' | 'P90D' | 'P365D', _options?: Configuration): Observable<HttpInfo<AppsBetaTesterUsagesV1MetricResponse>> {
        const requestContextPromise = this.requestFactory.appsBetaTesterUsagesGetMetrics(id, limit, groupBy, filterBetaTesters, period, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appsBetaTesterUsagesGetMetricsWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum number of groups to return per page
     * @param groupBy the dimension by which to group the results
     * @param filterBetaTesters filter by \&#39;betaTesters\&#39; relationship dimension
     * @param period the duration of the reporting period
     */
    public appsBetaTesterUsagesGetMetrics(id: string, limit?: number, groupBy?: Array<'betaTesters'>, filterBetaTesters?: string, period?: 'P7D' | 'P30D' | 'P90D' | 'P365D', _options?: Configuration): Observable<AppsBetaTesterUsagesV1MetricResponse> {
        return this.appsBetaTesterUsagesGetMetricsWithHttpInfo(id, limit, groupBy, filterBetaTesters, period, _options).pipe(map((apiResponse: HttpInfo<AppsBetaTesterUsagesV1MetricResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param appBetaTestersLinkagesRequest List of related linkages
     */
    public appsBetaTestersDeleteToManyRelationshipWithHttpInfo(id: string, appBetaTestersLinkagesRequest: AppBetaTestersLinkagesRequest, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.appsBetaTestersDeleteToManyRelationship(id, appBetaTestersLinkagesRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appsBetaTestersDeleteToManyRelationshipWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param appBetaTestersLinkagesRequest List of related linkages
     */
    public appsBetaTestersDeleteToManyRelationship(id: string, appBetaTestersLinkagesRequest: AppBetaTestersLinkagesRequest, _options?: Configuration): Observable<void> {
        return this.appsBetaTestersDeleteToManyRelationshipWithHttpInfo(id, appBetaTestersLinkagesRequest, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param limit maximum resources per page
     */
    public appsBuildsGetToManyRelatedWithHttpInfo(id: string, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, limit?: number, _options?: Configuration): Observable<HttpInfo<BuildsWithoutIncludesResponse>> {
        const requestContextPromise = this.requestFactory.appsBuildsGetToManyRelated(id, fieldsBuilds, limit, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appsBuildsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param limit maximum resources per page
     */
    public appsBuildsGetToManyRelated(id: string, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, limit?: number, _options?: Configuration): Observable<BuildsWithoutIncludesResponse> {
        return this.appsBuildsGetToManyRelatedWithHttpInfo(id, fieldsBuilds, limit, _options).pipe(map((apiResponse: HttpInfo<BuildsWithoutIncludesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCiProducts the fields to include for returned resources of type ciProducts
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsScmRepositories the fields to include for returned resources of type scmRepositories
     * @param fieldsBundleIds the fields to include for returned resources of type bundleIds
     * @param limitPrimaryRepositories maximum number of related primaryRepositories returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appsCiProductGetToOneRelatedWithHttpInfo(id: string, fieldsCiProducts?: Array<'additionalRepositories' | 'app' | 'buildRuns' | 'bundleId' | 'createdDate' | 'name' | 'primaryRepositories' | 'productType' | 'workflows'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsScmRepositories?: Array<'defaultBranch' | 'gitReferences' | 'httpCloneUrl' | 'lastAccessedDate' | 'ownerName' | 'pullRequests' | 'repositoryName' | 'scmProvider' | 'sshCloneUrl'>, fieldsBundleIds?: Array<'app' | 'bundleIdCapabilities' | 'identifier' | 'name' | 'platform' | 'profiles' | 'seedId'>, limitPrimaryRepositories?: number, include?: Array<'app' | 'bundleId' | 'primaryRepositories'>, _options?: Configuration): Observable<HttpInfo<CiProductResponse>> {
        const requestContextPromise = this.requestFactory.appsCiProductGetToOneRelated(id, fieldsCiProducts, fieldsApps, fieldsScmRepositories, fieldsBundleIds, limitPrimaryRepositories, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appsCiProductGetToOneRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCiProducts the fields to include for returned resources of type ciProducts
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsScmRepositories the fields to include for returned resources of type scmRepositories
     * @param fieldsBundleIds the fields to include for returned resources of type bundleIds
     * @param limitPrimaryRepositories maximum number of related primaryRepositories returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appsCiProductGetToOneRelated(id: string, fieldsCiProducts?: Array<'additionalRepositories' | 'app' | 'buildRuns' | 'bundleId' | 'createdDate' | 'name' | 'primaryRepositories' | 'productType' | 'workflows'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsScmRepositories?: Array<'defaultBranch' | 'gitReferences' | 'httpCloneUrl' | 'lastAccessedDate' | 'ownerName' | 'pullRequests' | 'repositoryName' | 'scmProvider' | 'sshCloneUrl'>, fieldsBundleIds?: Array<'app' | 'bundleIdCapabilities' | 'identifier' | 'name' | 'platform' | 'profiles' | 'seedId'>, limitPrimaryRepositories?: number, include?: Array<'app' | 'bundleId' | 'primaryRepositories'>, _options?: Configuration): Observable<CiProductResponse> {
        return this.appsCiProductGetToOneRelatedWithHttpInfo(id, fieldsCiProducts, fieldsApps, fieldsScmRepositories, fieldsBundleIds, limitPrimaryRepositories, include, _options).pipe(map((apiResponse: HttpInfo<CiProductResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param filterRating filter by attribute \&#39;rating\&#39;
     * @param filterTerritory filter by attribute \&#39;territory\&#39;
     * @param existsPublishedResponse filter by publishedResponse
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsCustomerReviews the fields to include for returned resources of type customerReviews
     * @param fieldsCustomerReviewResponses the fields to include for returned resources of type customerReviewResponses
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public appsCustomerReviewsGetToManyRelatedWithHttpInfo(id: string, filterRating?: Array<string>, filterTerritory?: Array<'ABW' | 'AFG' | 'AGO' | 'AIA' | 'ALB' | 'AND' | 'ANT' | 'ARE' | 'ARG' | 'ARM' | 'ASM' | 'ATG' | 'AUS' | 'AUT' | 'AZE' | 'BDI' | 'BEL' | 'BEN' | 'BES' | 'BFA' | 'BGD' | 'BGR' | 'BHR' | 'BHS' | 'BIH' | 'BLR' | 'BLZ' | 'BMU' | 'BOL' | 'BRA' | 'BRB' | 'BRN' | 'BTN' | 'BWA' | 'CAF' | 'CAN' | 'CHE' | 'CHL' | 'CHN' | 'CIV' | 'CMR' | 'COD' | 'COG' | 'COK' | 'COL' | 'COM' | 'CPV' | 'CRI' | 'CUB' | 'CUW' | 'CXR' | 'CYM' | 'CYP' | 'CZE' | 'DEU' | 'DJI' | 'DMA' | 'DNK' | 'DOM' | 'DZA' | 'ECU' | 'EGY' | 'ERI' | 'ESP' | 'EST' | 'ETH' | 'FIN' | 'FJI' | 'FLK' | 'FRA' | 'FRO' | 'FSM' | 'GAB' | 'GBR' | 'GEO' | 'GGY' | 'GHA' | 'GIB' | 'GIN' | 'GLP' | 'GMB' | 'GNB' | 'GNQ' | 'GRC' | 'GRD' | 'GRL' | 'GTM' | 'GUF' | 'GUM' | 'GUY' | 'HKG' | 'HND' | 'HRV' | 'HTI' | 'HUN' | 'IDN' | 'IMN' | 'IND' | 'IRL' | 'IRQ' | 'ISL' | 'ISR' | 'ITA' | 'JAM' | 'JEY' | 'JOR' | 'JPN' | 'KAZ' | 'KEN' | 'KGZ' | 'KHM' | 'KIR' | 'KNA' | 'KOR' | 'KWT' | 'LAO' | 'LBN' | 'LBR' | 'LBY' | 'LCA' | 'LIE' | 'LKA' | 'LSO' | 'LTU' | 'LUX' | 'LVA' | 'MAC' | 'MAR' | 'MCO' | 'MDA' | 'MDG' | 'MDV' | 'MEX' | 'MHL' | 'MKD' | 'MLI' | 'MLT' | 'MMR' | 'MNE' | 'MNG' | 'MNP' | 'MOZ' | 'MRT' | 'MSR' | 'MTQ' | 'MUS' | 'MWI' | 'MYS' | 'MYT' | 'NAM' | 'NCL' | 'NER' | 'NFK' | 'NGA' | 'NIC' | 'NIU' | 'NLD' | 'NOR' | 'NPL' | 'NRU' | 'NZL' | 'OMN' | 'PAK' | 'PAN' | 'PER' | 'PHL' | 'PLW' | 'PNG' | 'POL' | 'PRI' | 'PRT' | 'PRY' | 'PSE' | 'PYF' | 'QAT' | 'REU' | 'ROU' | 'RUS' | 'RWA' | 'SAU' | 'SEN' | 'SGP' | 'SHN' | 'SLB' | 'SLE' | 'SLV' | 'SMR' | 'SOM' | 'SPM' | 'SRB' | 'SSD' | 'STP' | 'SUR' | 'SVK' | 'SVN' | 'SWE' | 'SWZ' | 'SXM' | 'SYC' | 'TCA' | 'TCD' | 'TGO' | 'THA' | 'TJK' | 'TKM' | 'TLS' | 'TON' | 'TTO' | 'TUN' | 'TUR' | 'TUV' | 'TWN' | 'TZA' | 'UGA' | 'UKR' | 'UMI' | 'URY' | 'USA' | 'UZB' | 'VAT' | 'VCT' | 'VEN' | 'VGB' | 'VIR' | 'VNM' | 'VUT' | 'WLF' | 'WSM' | 'YEM' | 'ZAF' | 'ZMB' | 'ZWE'>, existsPublishedResponse?: boolean, sort?: Array<'createdDate' | '-createdDate' | 'rating' | '-rating'>, fieldsCustomerReviews?: Array<'body' | 'createdDate' | 'rating' | 'response' | 'reviewerNickname' | 'territory' | 'title'>, fieldsCustomerReviewResponses?: Array<'lastModifiedDate' | 'responseBody' | 'review' | 'state'>, limit?: number, include?: Array<'response'>, _options?: Configuration): Observable<HttpInfo<CustomerReviewsResponse>> {
        const requestContextPromise = this.requestFactory.appsCustomerReviewsGetToManyRelated(id, filterRating, filterTerritory, existsPublishedResponse, sort, fieldsCustomerReviews, fieldsCustomerReviewResponses, limit, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appsCustomerReviewsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param filterRating filter by attribute \&#39;rating\&#39;
     * @param filterTerritory filter by attribute \&#39;territory\&#39;
     * @param existsPublishedResponse filter by publishedResponse
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsCustomerReviews the fields to include for returned resources of type customerReviews
     * @param fieldsCustomerReviewResponses the fields to include for returned resources of type customerReviewResponses
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public appsCustomerReviewsGetToManyRelated(id: string, filterRating?: Array<string>, filterTerritory?: Array<'ABW' | 'AFG' | 'AGO' | 'AIA' | 'ALB' | 'AND' | 'ANT' | 'ARE' | 'ARG' | 'ARM' | 'ASM' | 'ATG' | 'AUS' | 'AUT' | 'AZE' | 'BDI' | 'BEL' | 'BEN' | 'BES' | 'BFA' | 'BGD' | 'BGR' | 'BHR' | 'BHS' | 'BIH' | 'BLR' | 'BLZ' | 'BMU' | 'BOL' | 'BRA' | 'BRB' | 'BRN' | 'BTN' | 'BWA' | 'CAF' | 'CAN' | 'CHE' | 'CHL' | 'CHN' | 'CIV' | 'CMR' | 'COD' | 'COG' | 'COK' | 'COL' | 'COM' | 'CPV' | 'CRI' | 'CUB' | 'CUW' | 'CXR' | 'CYM' | 'CYP' | 'CZE' | 'DEU' | 'DJI' | 'DMA' | 'DNK' | 'DOM' | 'DZA' | 'ECU' | 'EGY' | 'ERI' | 'ESP' | 'EST' | 'ETH' | 'FIN' | 'FJI' | 'FLK' | 'FRA' | 'FRO' | 'FSM' | 'GAB' | 'GBR' | 'GEO' | 'GGY' | 'GHA' | 'GIB' | 'GIN' | 'GLP' | 'GMB' | 'GNB' | 'GNQ' | 'GRC' | 'GRD' | 'GRL' | 'GTM' | 'GUF' | 'GUM' | 'GUY' | 'HKG' | 'HND' | 'HRV' | 'HTI' | 'HUN' | 'IDN' | 'IMN' | 'IND' | 'IRL' | 'IRQ' | 'ISL' | 'ISR' | 'ITA' | 'JAM' | 'JEY' | 'JOR' | 'JPN' | 'KAZ' | 'KEN' | 'KGZ' | 'KHM' | 'KIR' | 'KNA' | 'KOR' | 'KWT' | 'LAO' | 'LBN' | 'LBR' | 'LBY' | 'LCA' | 'LIE' | 'LKA' | 'LSO' | 'LTU' | 'LUX' | 'LVA' | 'MAC' | 'MAR' | 'MCO' | 'MDA' | 'MDG' | 'MDV' | 'MEX' | 'MHL' | 'MKD' | 'MLI' | 'MLT' | 'MMR' | 'MNE' | 'MNG' | 'MNP' | 'MOZ' | 'MRT' | 'MSR' | 'MTQ' | 'MUS' | 'MWI' | 'MYS' | 'MYT' | 'NAM' | 'NCL' | 'NER' | 'NFK' | 'NGA' | 'NIC' | 'NIU' | 'NLD' | 'NOR' | 'NPL' | 'NRU' | 'NZL' | 'OMN' | 'PAK' | 'PAN' | 'PER' | 'PHL' | 'PLW' | 'PNG' | 'POL' | 'PRI' | 'PRT' | 'PRY' | 'PSE' | 'PYF' | 'QAT' | 'REU' | 'ROU' | 'RUS' | 'RWA' | 'SAU' | 'SEN' | 'SGP' | 'SHN' | 'SLB' | 'SLE' | 'SLV' | 'SMR' | 'SOM' | 'SPM' | 'SRB' | 'SSD' | 'STP' | 'SUR' | 'SVK' | 'SVN' | 'SWE' | 'SWZ' | 'SXM' | 'SYC' | 'TCA' | 'TCD' | 'TGO' | 'THA' | 'TJK' | 'TKM' | 'TLS' | 'TON' | 'TTO' | 'TUN' | 'TUR' | 'TUV' | 'TWN' | 'TZA' | 'UGA' | 'UKR' | 'UMI' | 'URY' | 'USA' | 'UZB' | 'VAT' | 'VCT' | 'VEN' | 'VGB' | 'VIR' | 'VNM' | 'VUT' | 'WLF' | 'WSM' | 'YEM' | 'ZAF' | 'ZMB' | 'ZWE'>, existsPublishedResponse?: boolean, sort?: Array<'createdDate' | '-createdDate' | 'rating' | '-rating'>, fieldsCustomerReviews?: Array<'body' | 'createdDate' | 'rating' | 'response' | 'reviewerNickname' | 'territory' | 'title'>, fieldsCustomerReviewResponses?: Array<'lastModifiedDate' | 'responseBody' | 'review' | 'state'>, limit?: number, include?: Array<'response'>, _options?: Configuration): Observable<CustomerReviewsResponse> {
        return this.appsCustomerReviewsGetToManyRelatedWithHttpInfo(id, filterRating, filterTerritory, existsPublishedResponse, sort, fieldsCustomerReviews, fieldsCustomerReviewResponses, limit, include, _options).pipe(map((apiResponse: HttpInfo<CustomerReviewsResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsEndUserLicenseAgreements the fields to include for returned resources of type endUserLicenseAgreements
     */
    public appsEndUserLicenseAgreementGetToOneRelatedWithHttpInfo(id: string, fieldsEndUserLicenseAgreements?: Array<'agreementText' | 'app' | 'territories'>, _options?: Configuration): Observable<HttpInfo<EndUserLicenseAgreementWithoutIncludesResponse>> {
        const requestContextPromise = this.requestFactory.appsEndUserLicenseAgreementGetToOneRelated(id, fieldsEndUserLicenseAgreements, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appsEndUserLicenseAgreementGetToOneRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsEndUserLicenseAgreements the fields to include for returned resources of type endUserLicenseAgreements
     */
    public appsEndUserLicenseAgreementGetToOneRelated(id: string, fieldsEndUserLicenseAgreements?: Array<'agreementText' | 'app' | 'territories'>, _options?: Configuration): Observable<EndUserLicenseAgreementWithoutIncludesResponse> {
        return this.appsEndUserLicenseAgreementGetToOneRelatedWithHttpInfo(id, fieldsEndUserLicenseAgreements, _options).pipe(map((apiResponse: HttpInfo<EndUserLicenseAgreementWithoutIncludesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterAchievementReleases the fields to include for returned resources of type gameCenterAchievementReleases
     * @param fieldsGameCenterLeaderboardSetReleases the fields to include for returned resources of type gameCenterLeaderboardSetReleases
     * @param fieldsGameCenterLeaderboardSets the fields to include for returned resources of type gameCenterLeaderboardSets
     * @param fieldsGameCenterGroups the fields to include for returned resources of type gameCenterGroups
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     * @param fieldsGameCenterAppVersions the fields to include for returned resources of type gameCenterAppVersions
     * @param fieldsGameCenterAchievements the fields to include for returned resources of type gameCenterAchievements
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsGameCenterLeaderboardReleases the fields to include for returned resources of type gameCenterLeaderboardReleases
     * @param limitGameCenterAppVersions maximum number of related gameCenterAppVersions returned (when they are included)
     * @param limitGameCenterLeaderboards maximum number of related gameCenterLeaderboards returned (when they are included)
     * @param limitGameCenterLeaderboardSets maximum number of related gameCenterLeaderboardSets returned (when they are included)
     * @param limitGameCenterAchievements maximum number of related gameCenterAchievements returned (when they are included)
     * @param limitAchievementReleases maximum number of related achievementReleases returned (when they are included)
     * @param limitLeaderboardReleases maximum number of related leaderboardReleases returned (when they are included)
     * @param limitLeaderboardSetReleases maximum number of related leaderboardSetReleases returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appsGameCenterDetailGetToOneRelatedWithHttpInfo(id: string, fieldsGameCenterAchievementReleases?: Array<'gameCenterAchievement' | 'gameCenterDetail' | 'live'>, fieldsGameCenterLeaderboardSetReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboardSet' | 'live'>, fieldsGameCenterLeaderboardSets?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'referenceName' | 'releases' | 'vendorIdentifier'>, fieldsGameCenterGroups?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'referenceName'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, fieldsGameCenterAppVersions?: Array<'appStoreVersion' | 'compatibilityVersions' | 'enabled'>, fieldsGameCenterAchievements?: Array<'archived' | 'gameCenterDetail' | 'gameCenterGroup' | 'groupAchievement' | 'localizations' | 'points' | 'referenceName' | 'releases' | 'repeatable' | 'showBeforeEarned' | 'vendorIdentifier'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsGameCenterLeaderboardReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboard' | 'live'>, limitGameCenterAppVersions?: number, limitGameCenterLeaderboards?: number, limitGameCenterLeaderboardSets?: number, limitGameCenterAchievements?: number, limitAchievementReleases?: number, limitLeaderboardReleases?: number, limitLeaderboardSetReleases?: number, include?: Array<'achievementReleases' | 'app' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, _options?: Configuration): Observable<HttpInfo<GameCenterDetailResponse>> {
        const requestContextPromise = this.requestFactory.appsGameCenterDetailGetToOneRelated(id, fieldsGameCenterAchievementReleases, fieldsGameCenterLeaderboardSetReleases, fieldsGameCenterLeaderboardSets, fieldsGameCenterGroups, fieldsGameCenterDetails, fieldsGameCenterLeaderboards, fieldsGameCenterAppVersions, fieldsGameCenterAchievements, fieldsApps, fieldsGameCenterLeaderboardReleases, limitGameCenterAppVersions, limitGameCenterLeaderboards, limitGameCenterLeaderboardSets, limitGameCenterAchievements, limitAchievementReleases, limitLeaderboardReleases, limitLeaderboardSetReleases, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appsGameCenterDetailGetToOneRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterAchievementReleases the fields to include for returned resources of type gameCenterAchievementReleases
     * @param fieldsGameCenterLeaderboardSetReleases the fields to include for returned resources of type gameCenterLeaderboardSetReleases
     * @param fieldsGameCenterLeaderboardSets the fields to include for returned resources of type gameCenterLeaderboardSets
     * @param fieldsGameCenterGroups the fields to include for returned resources of type gameCenterGroups
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     * @param fieldsGameCenterAppVersions the fields to include for returned resources of type gameCenterAppVersions
     * @param fieldsGameCenterAchievements the fields to include for returned resources of type gameCenterAchievements
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsGameCenterLeaderboardReleases the fields to include for returned resources of type gameCenterLeaderboardReleases
     * @param limitGameCenterAppVersions maximum number of related gameCenterAppVersions returned (when they are included)
     * @param limitGameCenterLeaderboards maximum number of related gameCenterLeaderboards returned (when they are included)
     * @param limitGameCenterLeaderboardSets maximum number of related gameCenterLeaderboardSets returned (when they are included)
     * @param limitGameCenterAchievements maximum number of related gameCenterAchievements returned (when they are included)
     * @param limitAchievementReleases maximum number of related achievementReleases returned (when they are included)
     * @param limitLeaderboardReleases maximum number of related leaderboardReleases returned (when they are included)
     * @param limitLeaderboardSetReleases maximum number of related leaderboardSetReleases returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appsGameCenterDetailGetToOneRelated(id: string, fieldsGameCenterAchievementReleases?: Array<'gameCenterAchievement' | 'gameCenterDetail' | 'live'>, fieldsGameCenterLeaderboardSetReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboardSet' | 'live'>, fieldsGameCenterLeaderboardSets?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'referenceName' | 'releases' | 'vendorIdentifier'>, fieldsGameCenterGroups?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'referenceName'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, fieldsGameCenterAppVersions?: Array<'appStoreVersion' | 'compatibilityVersions' | 'enabled'>, fieldsGameCenterAchievements?: Array<'archived' | 'gameCenterDetail' | 'gameCenterGroup' | 'groupAchievement' | 'localizations' | 'points' | 'referenceName' | 'releases' | 'repeatable' | 'showBeforeEarned' | 'vendorIdentifier'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsGameCenterLeaderboardReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboard' | 'live'>, limitGameCenterAppVersions?: number, limitGameCenterLeaderboards?: number, limitGameCenterLeaderboardSets?: number, limitGameCenterAchievements?: number, limitAchievementReleases?: number, limitLeaderboardReleases?: number, limitLeaderboardSetReleases?: number, include?: Array<'achievementReleases' | 'app' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, _options?: Configuration): Observable<GameCenterDetailResponse> {
        return this.appsGameCenterDetailGetToOneRelatedWithHttpInfo(id, fieldsGameCenterAchievementReleases, fieldsGameCenterLeaderboardSetReleases, fieldsGameCenterLeaderboardSets, fieldsGameCenterGroups, fieldsGameCenterDetails, fieldsGameCenterLeaderboards, fieldsGameCenterAppVersions, fieldsGameCenterAchievements, fieldsApps, fieldsGameCenterLeaderboardReleases, limitGameCenterAppVersions, limitGameCenterLeaderboards, limitGameCenterLeaderboardSets, limitGameCenterAchievements, limitAchievementReleases, limitLeaderboardReleases, limitLeaderboardSetReleases, include, _options).pipe(map((apiResponse: HttpInfo<GameCenterDetailResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param filterPlatform filter by attribute \&#39;platform\&#39;
     * @param filterVersionString filter by attribute \&#39;versionString\&#39;
     * @param filterId filter by id(s)
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsGameCenterEnabledVersions the fields to include for returned resources of type gameCenterEnabledVersions
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param limit maximum resources per page
     * @param limitCompatibleVersions maximum number of related compatibleVersions returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appsGameCenterEnabledVersionsGetToManyRelatedWithHttpInfo(id: string, filterPlatform?: Array<'IOS' | 'MAC_OS' | 'TV_OS' | 'VISION_OS'>, filterVersionString?: Array<string>, filterId?: Array<string>, sort?: Array<'versionString' | '-versionString'>, fieldsGameCenterEnabledVersions?: Array<'app' | 'compatibleVersions' | 'iconAsset' | 'platform' | 'versionString'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, limit?: number, limitCompatibleVersions?: number, include?: Array<'app' | 'compatibleVersions'>, _options?: Configuration): Observable<HttpInfo<GameCenterEnabledVersionsResponse>> {
        const requestContextPromise = this.requestFactory.appsGameCenterEnabledVersionsGetToManyRelated(id, filterPlatform, filterVersionString, filterId, sort, fieldsGameCenterEnabledVersions, fieldsApps, limit, limitCompatibleVersions, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appsGameCenterEnabledVersionsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param filterPlatform filter by attribute \&#39;platform\&#39;
     * @param filterVersionString filter by attribute \&#39;versionString\&#39;
     * @param filterId filter by id(s)
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsGameCenterEnabledVersions the fields to include for returned resources of type gameCenterEnabledVersions
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param limit maximum resources per page
     * @param limitCompatibleVersions maximum number of related compatibleVersions returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appsGameCenterEnabledVersionsGetToManyRelated(id: string, filterPlatform?: Array<'IOS' | 'MAC_OS' | 'TV_OS' | 'VISION_OS'>, filterVersionString?: Array<string>, filterId?: Array<string>, sort?: Array<'versionString' | '-versionString'>, fieldsGameCenterEnabledVersions?: Array<'app' | 'compatibleVersions' | 'iconAsset' | 'platform' | 'versionString'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, limit?: number, limitCompatibleVersions?: number, include?: Array<'app' | 'compatibleVersions'>, _options?: Configuration): Observable<GameCenterEnabledVersionsResponse> {
        return this.appsGameCenterEnabledVersionsGetToManyRelatedWithHttpInfo(id, filterPlatform, filterVersionString, filterId, sort, fieldsGameCenterEnabledVersions, fieldsApps, limit, limitCompatibleVersions, include, _options).pipe(map((apiResponse: HttpInfo<GameCenterEnabledVersionsResponse>) => apiResponse.data));
    }

    /**
     * @param filterAppStoreVersionsAppStoreState filter by attribute \&#39;appStoreVersions.appStoreState\&#39;
     * @param filterAppStoreVersionsAppVersionState filter by attribute \&#39;appStoreVersions.appVersionState\&#39;
     * @param filterAppStoreVersionsPlatform filter by attribute \&#39;appStoreVersions.platform\&#39;
     * @param filterBundleId filter by attribute \&#39;bundleId\&#39;
     * @param filterName filter by attribute \&#39;name\&#39;
     * @param filterSku filter by attribute \&#39;sku\&#39;
     * @param filterAppStoreVersions filter by id(s) of related \&#39;appStoreVersions\&#39;
     * @param filterId filter by id(s)
     * @param existsGameCenterEnabledVersions filter by existence or non-existence of related \&#39;gameCenterEnabledVersions\&#39;
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsBetaAppReviewDetails the fields to include for returned resources of type betaAppReviewDetails
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsAppPriceSchedules the fields to include for returned resources of type appPriceSchedules
     * @param fieldsCiProducts the fields to include for returned resources of type ciProducts
     * @param fieldsAlternativeDistributionKeys the fields to include for returned resources of type alternativeDistributionKeys
     * @param fieldsReviewSubmissions the fields to include for returned resources of type reviewSubmissions
     * @param fieldsBetaGroups the fields to include for returned resources of type betaGroups
     * @param fieldsPromotedPurchases the fields to include for returned resources of type promotedPurchases
     * @param fieldsAppAvailabilities the fields to include for returned resources of type appAvailabilities
     * @param fieldsCustomerReviews the fields to include for returned resources of type customerReviews
     * @param fieldsAppEvents the fields to include for returned resources of type appEvents
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param fieldsBetaLicenseAgreements the fields to include for returned resources of type betaLicenseAgreements
     * @param fieldsMarketplaceSearchDetails the fields to include for returned resources of type marketplaceSearchDetails
     * @param fieldsAppClips the fields to include for returned resources of type appClips
     * @param fieldsAppInfos the fields to include for returned resources of type appInfos
     * @param fieldsBetaAppLocalizations the fields to include for returned resources of type betaAppLocalizations
     * @param fieldsAppPricePoints the fields to include for returned resources of type appPricePoints
     * @param fieldsInAppPurchases the fields to include for returned resources of type inAppPurchases
     * @param fieldsPreReleaseVersions the fields to include for returned resources of type preReleaseVersions
     * @param fieldsSubscriptionGroups the fields to include for returned resources of type subscriptionGroups
     * @param fieldsAnalyticsReportRequests the fields to include for returned resources of type analyticsReportRequests
     * @param fieldsAppPrices the fields to include for returned resources of type appPrices
     * @param fieldsAppPreOrders the fields to include for returned resources of type appPreOrders
     * @param fieldsAppStoreVersionExperiments the fields to include for returned resources of type appStoreVersionExperiments
     * @param fieldsGameCenterEnabledVersions the fields to include for returned resources of type gameCenterEnabledVersions
     * @param fieldsSubscriptionGracePeriods the fields to include for returned resources of type subscriptionGracePeriods
     * @param fieldsEndUserLicenseAgreements the fields to include for returned resources of type endUserLicenseAgreements
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsAppCustomProductPages the fields to include for returned resources of type appCustomProductPages
     * @param fieldsAppEncryptionDeclarations the fields to include for returned resources of type appEncryptionDeclarations
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param fieldsPerfPowerMetrics the fields to include for returned resources of type perfPowerMetrics
     * @param limitAppClips maximum number of related appClips returned (when they are included)
     * @param limitAppCustomProductPages maximum number of related appCustomProductPages returned (when they are included)
     * @param limitAppEncryptionDeclarations maximum number of related appEncryptionDeclarations returned (when they are included)
     * @param limitAppEvents maximum number of related appEvents returned (when they are included)
     * @param limitAppInfos maximum number of related appInfos returned (when they are included)
     * @param limitAppStoreVersionExperimentsV2 maximum number of related appStoreVersionExperimentsV2 returned (when they are included)
     * @param limitAppStoreVersions maximum number of related appStoreVersions returned (when they are included)
     * @param limitAvailableTerritories maximum number of related availableTerritories returned (when they are included)
     * @param limitBetaAppLocalizations maximum number of related betaAppLocalizations returned (when they are included)
     * @param limitBetaGroups maximum number of related betaGroups returned (when they are included)
     * @param limitBuilds maximum number of related builds returned (when they are included)
     * @param limitGameCenterEnabledVersions maximum number of related gameCenterEnabledVersions returned (when they are included)
     * @param limitInAppPurchases maximum number of related inAppPurchases returned (when they are included)
     * @param limitInAppPurchasesV2 maximum number of related inAppPurchasesV2 returned (when they are included)
     * @param limitPreReleaseVersions maximum number of related preReleaseVersions returned (when they are included)
     * @param limitPrices maximum number of related prices returned (when they are included)
     * @param limitPromotedPurchases maximum number of related promotedPurchases returned (when they are included)
     * @param limitReviewSubmissions maximum number of related reviewSubmissions returned (when they are included)
     * @param limitSubscriptionGroups maximum number of related subscriptionGroups returned (when they are included)
     */
    public appsGetCollectionWithHttpInfo(filterAppStoreVersionsAppStoreState?: Array<'ACCEPTED' | 'DEVELOPER_REMOVED_FROM_SALE' | 'DEVELOPER_REJECTED' | 'IN_REVIEW' | 'INVALID_BINARY' | 'METADATA_REJECTED' | 'PENDING_APPLE_RELEASE' | 'PENDING_CONTRACT' | 'PENDING_DEVELOPER_RELEASE' | 'PREPARE_FOR_SUBMISSION' | 'PREORDER_READY_FOR_SALE' | 'PROCESSING_FOR_APP_STORE' | 'READY_FOR_REVIEW' | 'READY_FOR_SALE' | 'REJECTED' | 'REMOVED_FROM_SALE' | 'WAITING_FOR_EXPORT_COMPLIANCE' | 'WAITING_FOR_REVIEW' | 'REPLACED_WITH_NEW_VERSION' | 'NOT_APPLICABLE'>, filterAppStoreVersionsAppVersionState?: Array<'ACCEPTED' | 'DEVELOPER_REJECTED' | 'IN_REVIEW' | 'INVALID_BINARY' | 'METADATA_REJECTED' | 'PENDING_APPLE_RELEASE' | 'PENDING_DEVELOPER_RELEASE' | 'PREPARE_FOR_SUBMISSION' | 'PROCESSING_FOR_DISTRIBUTION' | 'READY_FOR_DISTRIBUTION' | 'READY_FOR_REVIEW' | 'REJECTED' | 'REPLACED_WITH_NEW_VERSION' | 'WAITING_FOR_EXPORT_COMPLIANCE' | 'WAITING_FOR_REVIEW'>, filterAppStoreVersionsPlatform?: Array<'IOS' | 'MAC_OS' | 'TV_OS' | 'VISION_OS'>, filterBundleId?: Array<string>, filterName?: Array<string>, filterSku?: Array<string>, filterAppStoreVersions?: Array<string>, filterId?: Array<string>, existsGameCenterEnabledVersions?: boolean, sort?: Array<'bundleId' | '-bundleId' | 'name' | '-name' | 'sku' | '-sku'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, limit?: number, include?: Array<'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'builds' | 'ciProduct' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'preOrder' | 'preReleaseVersions' | 'prices' | 'promotedPurchases' | 'reviewSubmissions' | 'subscriptionGracePeriod' | 'subscriptionGroups'>, fieldsBetaAppReviewDetails?: Array<'app' | 'contactEmail' | 'contactFirstName' | 'contactLastName' | 'contactPhone' | 'demoAccountName' | 'demoAccountPassword' | 'demoAccountRequired' | 'notes'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsAppPriceSchedules?: Array<'app' | 'automaticPrices' | 'baseTerritory' | 'manualPrices'>, fieldsCiProducts?: Array<'additionalRepositories' | 'app' | 'buildRuns' | 'bundleId' | 'createdDate' | 'name' | 'primaryRepositories' | 'productType' | 'workflows'>, fieldsAlternativeDistributionKeys?: Array<'app' | 'publicKey'>, fieldsReviewSubmissions?: Array<'app' | 'appStoreVersionForReview' | 'canceled' | 'items' | 'lastUpdatedByActor' | 'platform' | 'state' | 'submitted' | 'submittedByActor' | 'submittedDate'>, fieldsBetaGroups?: Array<'app' | 'betaTesters' | 'builds' | 'createdDate' | 'feedbackEnabled' | 'hasAccessToAllBuilds' | 'iosBuildsAvailableForAppleSiliconMac' | 'isInternalGroup' | 'name' | 'publicLink' | 'publicLinkEnabled' | 'publicLinkId' | 'publicLinkLimit' | 'publicLinkLimitEnabled'>, fieldsPromotedPurchases?: Array<'app' | 'enabled' | 'inAppPurchaseV2' | 'promotionImages' | 'state' | 'subscription' | 'visibleForAllUsers'>, fieldsAppAvailabilities?: Array<'app' | 'availableInNewTerritories' | 'availableTerritories'>, fieldsCustomerReviews?: Array<'body' | 'createdDate' | 'rating' | 'response' | 'reviewerNickname' | 'territory' | 'title'>, fieldsAppEvents?: Array<'app' | 'archivedTerritorySchedules' | 'badge' | 'deepLink' | 'eventState' | 'localizations' | 'primaryLocale' | 'priority' | 'purchaseRequirement' | 'purpose' | 'referenceName' | 'territorySchedules'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, fieldsBetaLicenseAgreements?: Array<'agreementText' | 'app'>, fieldsMarketplaceSearchDetails?: Array<'app' | 'catalogUrl'>, fieldsAppClips?: Array<'app' | 'appClipAdvancedExperiences' | 'appClipDefaultExperiences' | 'bundleId'>, fieldsAppInfos?: Array<'ageRatingDeclaration' | 'app' | 'appInfoLocalizations' | 'appStoreAgeRating' | 'appStoreState' | 'brazilAgeRating' | 'brazilAgeRatingV2' | 'kidsAgeBand' | 'primaryCategory' | 'primarySubcategoryOne' | 'primarySubcategoryTwo' | 'secondaryCategory' | 'secondarySubcategoryOne' | 'secondarySubcategoryTwo' | 'state'>, fieldsBetaAppLocalizations?: Array<'app' | 'description' | 'feedbackEmail' | 'locale' | 'marketingUrl' | 'privacyPolicyUrl' | 'tvOsPrivacyPolicy'>, fieldsAppPricePoints?: Array<'app' | 'customerPrice' | 'equalizations' | 'priceTier' | 'proceeds' | 'territory'>, fieldsInAppPurchases?: Array<'app' | 'appStoreReviewScreenshot' | 'apps' | 'content' | 'contentHosting' | 'familySharable' | 'iapPriceSchedule' | 'inAppPurchaseAvailability' | 'inAppPurchaseLocalizations' | 'inAppPurchaseType' | 'name' | 'pricePoints' | 'productId' | 'promotedPurchase' | 'referenceName' | 'reviewNote' | 'state'>, fieldsPreReleaseVersions?: Array<'app' | 'builds' | 'platform' | 'version'>, fieldsSubscriptionGroups?: Array<'app' | 'referenceName' | 'subscriptionGroupLocalizations' | 'subscriptions'>, fieldsAnalyticsReportRequests?: Array<'accessType' | 'app' | 'reports' | 'stoppedDueToInactivity'>, fieldsAppPrices?: Array<'app' | 'priceTier'>, fieldsAppPreOrders?: Array<'app' | 'appReleaseDate' | 'preOrderAvailableDate'>, fieldsAppStoreVersionExperiments?: Array<'app' | 'appStoreVersionExperimentTreatments' | 'controlVersions' | 'endDate' | 'latestControlVersion' | 'name' | 'platform' | 'reviewRequired' | 'startDate' | 'started' | 'state' | 'trafficProportion'>, fieldsGameCenterEnabledVersions?: Array<'app' | 'compatibleVersions' | 'iconAsset' | 'platform' | 'versionString'>, fieldsSubscriptionGracePeriods?: Array<'duration' | 'optIn' | 'renewalType' | 'sandboxOptIn'>, fieldsEndUserLicenseAgreements?: Array<'agreementText' | 'app' | 'territories'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsAppCustomProductPages?: Array<'app' | 'appCustomProductPageVersions' | 'appStoreVersionTemplate' | 'customProductPageTemplate' | 'name' | 'url' | 'visible'>, fieldsAppEncryptionDeclarations?: Array<'app' | 'appDescription' | 'appEncryptionDeclarationDocument' | 'appEncryptionDeclarationState' | 'availableOnFrenchStore' | 'builds' | 'codeValue' | 'containsProprietaryCryptography' | 'containsThirdPartyCryptography' | 'createdDate' | 'documentName' | 'documentType' | 'documentUrl' | 'exempt' | 'platform' | 'uploadedDate' | 'usesEncryption'>, fieldsTerritories?: Array<'currency'>, fieldsPerfPowerMetrics?: Array<'deviceType' | 'metricType' | 'platform'>, limitAppClips?: number, limitAppCustomProductPages?: number, limitAppEncryptionDeclarations?: number, limitAppEvents?: number, limitAppInfos?: number, limitAppStoreVersionExperimentsV2?: number, limitAppStoreVersions?: number, limitAvailableTerritories?: number, limitBetaAppLocalizations?: number, limitBetaGroups?: number, limitBuilds?: number, limitGameCenterEnabledVersions?: number, limitInAppPurchases?: number, limitInAppPurchasesV2?: number, limitPreReleaseVersions?: number, limitPrices?: number, limitPromotedPurchases?: number, limitReviewSubmissions?: number, limitSubscriptionGroups?: number, _options?: Configuration): Observable<HttpInfo<AppsResponse>> {
        const requestContextPromise = this.requestFactory.appsGetCollection(filterAppStoreVersionsAppStoreState, filterAppStoreVersionsAppVersionState, filterAppStoreVersionsPlatform, filterBundleId, filterName, filterSku, filterAppStoreVersions, filterId, existsGameCenterEnabledVersions, sort, fieldsApps, limit, include, fieldsBetaAppReviewDetails, fieldsGameCenterDetails, fieldsAppPriceSchedules, fieldsCiProducts, fieldsAlternativeDistributionKeys, fieldsReviewSubmissions, fieldsBetaGroups, fieldsPromotedPurchases, fieldsAppAvailabilities, fieldsCustomerReviews, fieldsAppEvents, fieldsBuilds, fieldsBetaLicenseAgreements, fieldsMarketplaceSearchDetails, fieldsAppClips, fieldsAppInfos, fieldsBetaAppLocalizations, fieldsAppPricePoints, fieldsInAppPurchases, fieldsPreReleaseVersions, fieldsSubscriptionGroups, fieldsAnalyticsReportRequests, fieldsAppPrices, fieldsAppPreOrders, fieldsAppStoreVersionExperiments, fieldsGameCenterEnabledVersions, fieldsSubscriptionGracePeriods, fieldsEndUserLicenseAgreements, fieldsAppStoreVersions, fieldsAppCustomProductPages, fieldsAppEncryptionDeclarations, fieldsTerritories, fieldsPerfPowerMetrics, limitAppClips, limitAppCustomProductPages, limitAppEncryptionDeclarations, limitAppEvents, limitAppInfos, limitAppStoreVersionExperimentsV2, limitAppStoreVersions, limitAvailableTerritories, limitBetaAppLocalizations, limitBetaGroups, limitBuilds, limitGameCenterEnabledVersions, limitInAppPurchases, limitInAppPurchasesV2, limitPreReleaseVersions, limitPrices, limitPromotedPurchases, limitReviewSubmissions, limitSubscriptionGroups, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appsGetCollectionWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param filterAppStoreVersionsAppStoreState filter by attribute \&#39;appStoreVersions.appStoreState\&#39;
     * @param filterAppStoreVersionsAppVersionState filter by attribute \&#39;appStoreVersions.appVersionState\&#39;
     * @param filterAppStoreVersionsPlatform filter by attribute \&#39;appStoreVersions.platform\&#39;
     * @param filterBundleId filter by attribute \&#39;bundleId\&#39;
     * @param filterName filter by attribute \&#39;name\&#39;
     * @param filterSku filter by attribute \&#39;sku\&#39;
     * @param filterAppStoreVersions filter by id(s) of related \&#39;appStoreVersions\&#39;
     * @param filterId filter by id(s)
     * @param existsGameCenterEnabledVersions filter by existence or non-existence of related \&#39;gameCenterEnabledVersions\&#39;
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsBetaAppReviewDetails the fields to include for returned resources of type betaAppReviewDetails
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsAppPriceSchedules the fields to include for returned resources of type appPriceSchedules
     * @param fieldsCiProducts the fields to include for returned resources of type ciProducts
     * @param fieldsAlternativeDistributionKeys the fields to include for returned resources of type alternativeDistributionKeys
     * @param fieldsReviewSubmissions the fields to include for returned resources of type reviewSubmissions
     * @param fieldsBetaGroups the fields to include for returned resources of type betaGroups
     * @param fieldsPromotedPurchases the fields to include for returned resources of type promotedPurchases
     * @param fieldsAppAvailabilities the fields to include for returned resources of type appAvailabilities
     * @param fieldsCustomerReviews the fields to include for returned resources of type customerReviews
     * @param fieldsAppEvents the fields to include for returned resources of type appEvents
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param fieldsBetaLicenseAgreements the fields to include for returned resources of type betaLicenseAgreements
     * @param fieldsMarketplaceSearchDetails the fields to include for returned resources of type marketplaceSearchDetails
     * @param fieldsAppClips the fields to include for returned resources of type appClips
     * @param fieldsAppInfos the fields to include for returned resources of type appInfos
     * @param fieldsBetaAppLocalizations the fields to include for returned resources of type betaAppLocalizations
     * @param fieldsAppPricePoints the fields to include for returned resources of type appPricePoints
     * @param fieldsInAppPurchases the fields to include for returned resources of type inAppPurchases
     * @param fieldsPreReleaseVersions the fields to include for returned resources of type preReleaseVersions
     * @param fieldsSubscriptionGroups the fields to include for returned resources of type subscriptionGroups
     * @param fieldsAnalyticsReportRequests the fields to include for returned resources of type analyticsReportRequests
     * @param fieldsAppPrices the fields to include for returned resources of type appPrices
     * @param fieldsAppPreOrders the fields to include for returned resources of type appPreOrders
     * @param fieldsAppStoreVersionExperiments the fields to include for returned resources of type appStoreVersionExperiments
     * @param fieldsGameCenterEnabledVersions the fields to include for returned resources of type gameCenterEnabledVersions
     * @param fieldsSubscriptionGracePeriods the fields to include for returned resources of type subscriptionGracePeriods
     * @param fieldsEndUserLicenseAgreements the fields to include for returned resources of type endUserLicenseAgreements
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsAppCustomProductPages the fields to include for returned resources of type appCustomProductPages
     * @param fieldsAppEncryptionDeclarations the fields to include for returned resources of type appEncryptionDeclarations
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param fieldsPerfPowerMetrics the fields to include for returned resources of type perfPowerMetrics
     * @param limitAppClips maximum number of related appClips returned (when they are included)
     * @param limitAppCustomProductPages maximum number of related appCustomProductPages returned (when they are included)
     * @param limitAppEncryptionDeclarations maximum number of related appEncryptionDeclarations returned (when they are included)
     * @param limitAppEvents maximum number of related appEvents returned (when they are included)
     * @param limitAppInfos maximum number of related appInfos returned (when they are included)
     * @param limitAppStoreVersionExperimentsV2 maximum number of related appStoreVersionExperimentsV2 returned (when they are included)
     * @param limitAppStoreVersions maximum number of related appStoreVersions returned (when they are included)
     * @param limitAvailableTerritories maximum number of related availableTerritories returned (when they are included)
     * @param limitBetaAppLocalizations maximum number of related betaAppLocalizations returned (when they are included)
     * @param limitBetaGroups maximum number of related betaGroups returned (when they are included)
     * @param limitBuilds maximum number of related builds returned (when they are included)
     * @param limitGameCenterEnabledVersions maximum number of related gameCenterEnabledVersions returned (when they are included)
     * @param limitInAppPurchases maximum number of related inAppPurchases returned (when they are included)
     * @param limitInAppPurchasesV2 maximum number of related inAppPurchasesV2 returned (when they are included)
     * @param limitPreReleaseVersions maximum number of related preReleaseVersions returned (when they are included)
     * @param limitPrices maximum number of related prices returned (when they are included)
     * @param limitPromotedPurchases maximum number of related promotedPurchases returned (when they are included)
     * @param limitReviewSubmissions maximum number of related reviewSubmissions returned (when they are included)
     * @param limitSubscriptionGroups maximum number of related subscriptionGroups returned (when they are included)
     */
    public appsGetCollection(filterAppStoreVersionsAppStoreState?: Array<'ACCEPTED' | 'DEVELOPER_REMOVED_FROM_SALE' | 'DEVELOPER_REJECTED' | 'IN_REVIEW' | 'INVALID_BINARY' | 'METADATA_REJECTED' | 'PENDING_APPLE_RELEASE' | 'PENDING_CONTRACT' | 'PENDING_DEVELOPER_RELEASE' | 'PREPARE_FOR_SUBMISSION' | 'PREORDER_READY_FOR_SALE' | 'PROCESSING_FOR_APP_STORE' | 'READY_FOR_REVIEW' | 'READY_FOR_SALE' | 'REJECTED' | 'REMOVED_FROM_SALE' | 'WAITING_FOR_EXPORT_COMPLIANCE' | 'WAITING_FOR_REVIEW' | 'REPLACED_WITH_NEW_VERSION' | 'NOT_APPLICABLE'>, filterAppStoreVersionsAppVersionState?: Array<'ACCEPTED' | 'DEVELOPER_REJECTED' | 'IN_REVIEW' | 'INVALID_BINARY' | 'METADATA_REJECTED' | 'PENDING_APPLE_RELEASE' | 'PENDING_DEVELOPER_RELEASE' | 'PREPARE_FOR_SUBMISSION' | 'PROCESSING_FOR_DISTRIBUTION' | 'READY_FOR_DISTRIBUTION' | 'READY_FOR_REVIEW' | 'REJECTED' | 'REPLACED_WITH_NEW_VERSION' | 'WAITING_FOR_EXPORT_COMPLIANCE' | 'WAITING_FOR_REVIEW'>, filterAppStoreVersionsPlatform?: Array<'IOS' | 'MAC_OS' | 'TV_OS' | 'VISION_OS'>, filterBundleId?: Array<string>, filterName?: Array<string>, filterSku?: Array<string>, filterAppStoreVersions?: Array<string>, filterId?: Array<string>, existsGameCenterEnabledVersions?: boolean, sort?: Array<'bundleId' | '-bundleId' | 'name' | '-name' | 'sku' | '-sku'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, limit?: number, include?: Array<'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'builds' | 'ciProduct' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'preOrder' | 'preReleaseVersions' | 'prices' | 'promotedPurchases' | 'reviewSubmissions' | 'subscriptionGracePeriod' | 'subscriptionGroups'>, fieldsBetaAppReviewDetails?: Array<'app' | 'contactEmail' | 'contactFirstName' | 'contactLastName' | 'contactPhone' | 'demoAccountName' | 'demoAccountPassword' | 'demoAccountRequired' | 'notes'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsAppPriceSchedules?: Array<'app' | 'automaticPrices' | 'baseTerritory' | 'manualPrices'>, fieldsCiProducts?: Array<'additionalRepositories' | 'app' | 'buildRuns' | 'bundleId' | 'createdDate' | 'name' | 'primaryRepositories' | 'productType' | 'workflows'>, fieldsAlternativeDistributionKeys?: Array<'app' | 'publicKey'>, fieldsReviewSubmissions?: Array<'app' | 'appStoreVersionForReview' | 'canceled' | 'items' | 'lastUpdatedByActor' | 'platform' | 'state' | 'submitted' | 'submittedByActor' | 'submittedDate'>, fieldsBetaGroups?: Array<'app' | 'betaTesters' | 'builds' | 'createdDate' | 'feedbackEnabled' | 'hasAccessToAllBuilds' | 'iosBuildsAvailableForAppleSiliconMac' | 'isInternalGroup' | 'name' | 'publicLink' | 'publicLinkEnabled' | 'publicLinkId' | 'publicLinkLimit' | 'publicLinkLimitEnabled'>, fieldsPromotedPurchases?: Array<'app' | 'enabled' | 'inAppPurchaseV2' | 'promotionImages' | 'state' | 'subscription' | 'visibleForAllUsers'>, fieldsAppAvailabilities?: Array<'app' | 'availableInNewTerritories' | 'availableTerritories'>, fieldsCustomerReviews?: Array<'body' | 'createdDate' | 'rating' | 'response' | 'reviewerNickname' | 'territory' | 'title'>, fieldsAppEvents?: Array<'app' | 'archivedTerritorySchedules' | 'badge' | 'deepLink' | 'eventState' | 'localizations' | 'primaryLocale' | 'priority' | 'purchaseRequirement' | 'purpose' | 'referenceName' | 'territorySchedules'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, fieldsBetaLicenseAgreements?: Array<'agreementText' | 'app'>, fieldsMarketplaceSearchDetails?: Array<'app' | 'catalogUrl'>, fieldsAppClips?: Array<'app' | 'appClipAdvancedExperiences' | 'appClipDefaultExperiences' | 'bundleId'>, fieldsAppInfos?: Array<'ageRatingDeclaration' | 'app' | 'appInfoLocalizations' | 'appStoreAgeRating' | 'appStoreState' | 'brazilAgeRating' | 'brazilAgeRatingV2' | 'kidsAgeBand' | 'primaryCategory' | 'primarySubcategoryOne' | 'primarySubcategoryTwo' | 'secondaryCategory' | 'secondarySubcategoryOne' | 'secondarySubcategoryTwo' | 'state'>, fieldsBetaAppLocalizations?: Array<'app' | 'description' | 'feedbackEmail' | 'locale' | 'marketingUrl' | 'privacyPolicyUrl' | 'tvOsPrivacyPolicy'>, fieldsAppPricePoints?: Array<'app' | 'customerPrice' | 'equalizations' | 'priceTier' | 'proceeds' | 'territory'>, fieldsInAppPurchases?: Array<'app' | 'appStoreReviewScreenshot' | 'apps' | 'content' | 'contentHosting' | 'familySharable' | 'iapPriceSchedule' | 'inAppPurchaseAvailability' | 'inAppPurchaseLocalizations' | 'inAppPurchaseType' | 'name' | 'pricePoints' | 'productId' | 'promotedPurchase' | 'referenceName' | 'reviewNote' | 'state'>, fieldsPreReleaseVersions?: Array<'app' | 'builds' | 'platform' | 'version'>, fieldsSubscriptionGroups?: Array<'app' | 'referenceName' | 'subscriptionGroupLocalizations' | 'subscriptions'>, fieldsAnalyticsReportRequests?: Array<'accessType' | 'app' | 'reports' | 'stoppedDueToInactivity'>, fieldsAppPrices?: Array<'app' | 'priceTier'>, fieldsAppPreOrders?: Array<'app' | 'appReleaseDate' | 'preOrderAvailableDate'>, fieldsAppStoreVersionExperiments?: Array<'app' | 'appStoreVersionExperimentTreatments' | 'controlVersions' | 'endDate' | 'latestControlVersion' | 'name' | 'platform' | 'reviewRequired' | 'startDate' | 'started' | 'state' | 'trafficProportion'>, fieldsGameCenterEnabledVersions?: Array<'app' | 'compatibleVersions' | 'iconAsset' | 'platform' | 'versionString'>, fieldsSubscriptionGracePeriods?: Array<'duration' | 'optIn' | 'renewalType' | 'sandboxOptIn'>, fieldsEndUserLicenseAgreements?: Array<'agreementText' | 'app' | 'territories'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsAppCustomProductPages?: Array<'app' | 'appCustomProductPageVersions' | 'appStoreVersionTemplate' | 'customProductPageTemplate' | 'name' | 'url' | 'visible'>, fieldsAppEncryptionDeclarations?: Array<'app' | 'appDescription' | 'appEncryptionDeclarationDocument' | 'appEncryptionDeclarationState' | 'availableOnFrenchStore' | 'builds' | 'codeValue' | 'containsProprietaryCryptography' | 'containsThirdPartyCryptography' | 'createdDate' | 'documentName' | 'documentType' | 'documentUrl' | 'exempt' | 'platform' | 'uploadedDate' | 'usesEncryption'>, fieldsTerritories?: Array<'currency'>, fieldsPerfPowerMetrics?: Array<'deviceType' | 'metricType' | 'platform'>, limitAppClips?: number, limitAppCustomProductPages?: number, limitAppEncryptionDeclarations?: number, limitAppEvents?: number, limitAppInfos?: number, limitAppStoreVersionExperimentsV2?: number, limitAppStoreVersions?: number, limitAvailableTerritories?: number, limitBetaAppLocalizations?: number, limitBetaGroups?: number, limitBuilds?: number, limitGameCenterEnabledVersions?: number, limitInAppPurchases?: number, limitInAppPurchasesV2?: number, limitPreReleaseVersions?: number, limitPrices?: number, limitPromotedPurchases?: number, limitReviewSubmissions?: number, limitSubscriptionGroups?: number, _options?: Configuration): Observable<AppsResponse> {
        return this.appsGetCollectionWithHttpInfo(filterAppStoreVersionsAppStoreState, filterAppStoreVersionsAppVersionState, filterAppStoreVersionsPlatform, filterBundleId, filterName, filterSku, filterAppStoreVersions, filterId, existsGameCenterEnabledVersions, sort, fieldsApps, limit, include, fieldsBetaAppReviewDetails, fieldsGameCenterDetails, fieldsAppPriceSchedules, fieldsCiProducts, fieldsAlternativeDistributionKeys, fieldsReviewSubmissions, fieldsBetaGroups, fieldsPromotedPurchases, fieldsAppAvailabilities, fieldsCustomerReviews, fieldsAppEvents, fieldsBuilds, fieldsBetaLicenseAgreements, fieldsMarketplaceSearchDetails, fieldsAppClips, fieldsAppInfos, fieldsBetaAppLocalizations, fieldsAppPricePoints, fieldsInAppPurchases, fieldsPreReleaseVersions, fieldsSubscriptionGroups, fieldsAnalyticsReportRequests, fieldsAppPrices, fieldsAppPreOrders, fieldsAppStoreVersionExperiments, fieldsGameCenterEnabledVersions, fieldsSubscriptionGracePeriods, fieldsEndUserLicenseAgreements, fieldsAppStoreVersions, fieldsAppCustomProductPages, fieldsAppEncryptionDeclarations, fieldsTerritories, fieldsPerfPowerMetrics, limitAppClips, limitAppCustomProductPages, limitAppEncryptionDeclarations, limitAppEvents, limitAppInfos, limitAppStoreVersionExperimentsV2, limitAppStoreVersions, limitAvailableTerritories, limitBetaAppLocalizations, limitBetaGroups, limitBuilds, limitGameCenterEnabledVersions, limitInAppPurchases, limitInAppPurchasesV2, limitPreReleaseVersions, limitPrices, limitPromotedPurchases, limitReviewSubmissions, limitSubscriptionGroups, _options).pipe(map((apiResponse: HttpInfo<AppsResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param include comma-separated list of relationships to include
     * @param fieldsBetaAppReviewDetails the fields to include for returned resources of type betaAppReviewDetails
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsAppPriceSchedules the fields to include for returned resources of type appPriceSchedules
     * @param fieldsCiProducts the fields to include for returned resources of type ciProducts
     * @param fieldsAlternativeDistributionKeys the fields to include for returned resources of type alternativeDistributionKeys
     * @param fieldsReviewSubmissions the fields to include for returned resources of type reviewSubmissions
     * @param fieldsBetaGroups the fields to include for returned resources of type betaGroups
     * @param fieldsPromotedPurchases the fields to include for returned resources of type promotedPurchases
     * @param fieldsAppAvailabilities the fields to include for returned resources of type appAvailabilities
     * @param fieldsCustomerReviews the fields to include for returned resources of type customerReviews
     * @param fieldsAppEvents the fields to include for returned resources of type appEvents
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param fieldsBetaLicenseAgreements the fields to include for returned resources of type betaLicenseAgreements
     * @param fieldsMarketplaceSearchDetails the fields to include for returned resources of type marketplaceSearchDetails
     * @param fieldsAppClips the fields to include for returned resources of type appClips
     * @param fieldsAppInfos the fields to include for returned resources of type appInfos
     * @param fieldsBetaAppLocalizations the fields to include for returned resources of type betaAppLocalizations
     * @param fieldsAppPricePoints the fields to include for returned resources of type appPricePoints
     * @param fieldsInAppPurchases the fields to include for returned resources of type inAppPurchases
     * @param fieldsPreReleaseVersions the fields to include for returned resources of type preReleaseVersions
     * @param fieldsSubscriptionGroups the fields to include for returned resources of type subscriptionGroups
     * @param fieldsAnalyticsReportRequests the fields to include for returned resources of type analyticsReportRequests
     * @param fieldsAppPrices the fields to include for returned resources of type appPrices
     * @param fieldsAppPreOrders the fields to include for returned resources of type appPreOrders
     * @param fieldsAppStoreVersionExperiments the fields to include for returned resources of type appStoreVersionExperiments
     * @param fieldsGameCenterEnabledVersions the fields to include for returned resources of type gameCenterEnabledVersions
     * @param fieldsSubscriptionGracePeriods the fields to include for returned resources of type subscriptionGracePeriods
     * @param fieldsEndUserLicenseAgreements the fields to include for returned resources of type endUserLicenseAgreements
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsAppCustomProductPages the fields to include for returned resources of type appCustomProductPages
     * @param fieldsAppEncryptionDeclarations the fields to include for returned resources of type appEncryptionDeclarations
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param fieldsPerfPowerMetrics the fields to include for returned resources of type perfPowerMetrics
     * @param limitAppClips maximum number of related appClips returned (when they are included)
     * @param limitAppCustomProductPages maximum number of related appCustomProductPages returned (when they are included)
     * @param limitAppEncryptionDeclarations maximum number of related appEncryptionDeclarations returned (when they are included)
     * @param limitAppEvents maximum number of related appEvents returned (when they are included)
     * @param limitAppInfos maximum number of related appInfos returned (when they are included)
     * @param limitAppStoreVersionExperimentsV2 maximum number of related appStoreVersionExperimentsV2 returned (when they are included)
     * @param limitAppStoreVersions maximum number of related appStoreVersions returned (when they are included)
     * @param limitAvailableTerritories maximum number of related availableTerritories returned (when they are included)
     * @param limitBetaAppLocalizations maximum number of related betaAppLocalizations returned (when they are included)
     * @param limitBetaGroups maximum number of related betaGroups returned (when they are included)
     * @param limitBuilds maximum number of related builds returned (when they are included)
     * @param limitGameCenterEnabledVersions maximum number of related gameCenterEnabledVersions returned (when they are included)
     * @param limitInAppPurchases maximum number of related inAppPurchases returned (when they are included)
     * @param limitInAppPurchasesV2 maximum number of related inAppPurchasesV2 returned (when they are included)
     * @param limitPreReleaseVersions maximum number of related preReleaseVersions returned (when they are included)
     * @param limitPrices maximum number of related prices returned (when they are included)
     * @param limitPromotedPurchases maximum number of related promotedPurchases returned (when they are included)
     * @param limitReviewSubmissions maximum number of related reviewSubmissions returned (when they are included)
     * @param limitSubscriptionGroups maximum number of related subscriptionGroups returned (when they are included)
     */
    public appsGetInstanceWithHttpInfo(id: string, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, include?: Array<'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'builds' | 'ciProduct' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'preOrder' | 'preReleaseVersions' | 'prices' | 'promotedPurchases' | 'reviewSubmissions' | 'subscriptionGracePeriod' | 'subscriptionGroups'>, fieldsBetaAppReviewDetails?: Array<'app' | 'contactEmail' | 'contactFirstName' | 'contactLastName' | 'contactPhone' | 'demoAccountName' | 'demoAccountPassword' | 'demoAccountRequired' | 'notes'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsAppPriceSchedules?: Array<'app' | 'automaticPrices' | 'baseTerritory' | 'manualPrices'>, fieldsCiProducts?: Array<'additionalRepositories' | 'app' | 'buildRuns' | 'bundleId' | 'createdDate' | 'name' | 'primaryRepositories' | 'productType' | 'workflows'>, fieldsAlternativeDistributionKeys?: Array<'app' | 'publicKey'>, fieldsReviewSubmissions?: Array<'app' | 'appStoreVersionForReview' | 'canceled' | 'items' | 'lastUpdatedByActor' | 'platform' | 'state' | 'submitted' | 'submittedByActor' | 'submittedDate'>, fieldsBetaGroups?: Array<'app' | 'betaTesters' | 'builds' | 'createdDate' | 'feedbackEnabled' | 'hasAccessToAllBuilds' | 'iosBuildsAvailableForAppleSiliconMac' | 'isInternalGroup' | 'name' | 'publicLink' | 'publicLinkEnabled' | 'publicLinkId' | 'publicLinkLimit' | 'publicLinkLimitEnabled'>, fieldsPromotedPurchases?: Array<'app' | 'enabled' | 'inAppPurchaseV2' | 'promotionImages' | 'state' | 'subscription' | 'visibleForAllUsers'>, fieldsAppAvailabilities?: Array<'app' | 'availableInNewTerritories' | 'availableTerritories'>, fieldsCustomerReviews?: Array<'body' | 'createdDate' | 'rating' | 'response' | 'reviewerNickname' | 'territory' | 'title'>, fieldsAppEvents?: Array<'app' | 'archivedTerritorySchedules' | 'badge' | 'deepLink' | 'eventState' | 'localizations' | 'primaryLocale' | 'priority' | 'purchaseRequirement' | 'purpose' | 'referenceName' | 'territorySchedules'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, fieldsBetaLicenseAgreements?: Array<'agreementText' | 'app'>, fieldsMarketplaceSearchDetails?: Array<'app' | 'catalogUrl'>, fieldsAppClips?: Array<'app' | 'appClipAdvancedExperiences' | 'appClipDefaultExperiences' | 'bundleId'>, fieldsAppInfos?: Array<'ageRatingDeclaration' | 'app' | 'appInfoLocalizations' | 'appStoreAgeRating' | 'appStoreState' | 'brazilAgeRating' | 'brazilAgeRatingV2' | 'kidsAgeBand' | 'primaryCategory' | 'primarySubcategoryOne' | 'primarySubcategoryTwo' | 'secondaryCategory' | 'secondarySubcategoryOne' | 'secondarySubcategoryTwo' | 'state'>, fieldsBetaAppLocalizations?: Array<'app' | 'description' | 'feedbackEmail' | 'locale' | 'marketingUrl' | 'privacyPolicyUrl' | 'tvOsPrivacyPolicy'>, fieldsAppPricePoints?: Array<'app' | 'customerPrice' | 'equalizations' | 'priceTier' | 'proceeds' | 'territory'>, fieldsInAppPurchases?: Array<'app' | 'appStoreReviewScreenshot' | 'apps' | 'content' | 'contentHosting' | 'familySharable' | 'iapPriceSchedule' | 'inAppPurchaseAvailability' | 'inAppPurchaseLocalizations' | 'inAppPurchaseType' | 'name' | 'pricePoints' | 'productId' | 'promotedPurchase' | 'referenceName' | 'reviewNote' | 'state'>, fieldsPreReleaseVersions?: Array<'app' | 'builds' | 'platform' | 'version'>, fieldsSubscriptionGroups?: Array<'app' | 'referenceName' | 'subscriptionGroupLocalizations' | 'subscriptions'>, fieldsAnalyticsReportRequests?: Array<'accessType' | 'app' | 'reports' | 'stoppedDueToInactivity'>, fieldsAppPrices?: Array<'app' | 'priceTier'>, fieldsAppPreOrders?: Array<'app' | 'appReleaseDate' | 'preOrderAvailableDate'>, fieldsAppStoreVersionExperiments?: Array<'app' | 'appStoreVersionExperimentTreatments' | 'controlVersions' | 'endDate' | 'latestControlVersion' | 'name' | 'platform' | 'reviewRequired' | 'startDate' | 'started' | 'state' | 'trafficProportion'>, fieldsGameCenterEnabledVersions?: Array<'app' | 'compatibleVersions' | 'iconAsset' | 'platform' | 'versionString'>, fieldsSubscriptionGracePeriods?: Array<'duration' | 'optIn' | 'renewalType' | 'sandboxOptIn'>, fieldsEndUserLicenseAgreements?: Array<'agreementText' | 'app' | 'territories'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsAppCustomProductPages?: Array<'app' | 'appCustomProductPageVersions' | 'appStoreVersionTemplate' | 'customProductPageTemplate' | 'name' | 'url' | 'visible'>, fieldsAppEncryptionDeclarations?: Array<'app' | 'appDescription' | 'appEncryptionDeclarationDocument' | 'appEncryptionDeclarationState' | 'availableOnFrenchStore' | 'builds' | 'codeValue' | 'containsProprietaryCryptography' | 'containsThirdPartyCryptography' | 'createdDate' | 'documentName' | 'documentType' | 'documentUrl' | 'exempt' | 'platform' | 'uploadedDate' | 'usesEncryption'>, fieldsTerritories?: Array<'currency'>, fieldsPerfPowerMetrics?: Array<'deviceType' | 'metricType' | 'platform'>, limitAppClips?: number, limitAppCustomProductPages?: number, limitAppEncryptionDeclarations?: number, limitAppEvents?: number, limitAppInfos?: number, limitAppStoreVersionExperimentsV2?: number, limitAppStoreVersions?: number, limitAvailableTerritories?: number, limitBetaAppLocalizations?: number, limitBetaGroups?: number, limitBuilds?: number, limitGameCenterEnabledVersions?: number, limitInAppPurchases?: number, limitInAppPurchasesV2?: number, limitPreReleaseVersions?: number, limitPrices?: number, limitPromotedPurchases?: number, limitReviewSubmissions?: number, limitSubscriptionGroups?: number, _options?: Configuration): Observable<HttpInfo<AppResponse>> {
        const requestContextPromise = this.requestFactory.appsGetInstance(id, fieldsApps, include, fieldsBetaAppReviewDetails, fieldsGameCenterDetails, fieldsAppPriceSchedules, fieldsCiProducts, fieldsAlternativeDistributionKeys, fieldsReviewSubmissions, fieldsBetaGroups, fieldsPromotedPurchases, fieldsAppAvailabilities, fieldsCustomerReviews, fieldsAppEvents, fieldsBuilds, fieldsBetaLicenseAgreements, fieldsMarketplaceSearchDetails, fieldsAppClips, fieldsAppInfos, fieldsBetaAppLocalizations, fieldsAppPricePoints, fieldsInAppPurchases, fieldsPreReleaseVersions, fieldsSubscriptionGroups, fieldsAnalyticsReportRequests, fieldsAppPrices, fieldsAppPreOrders, fieldsAppStoreVersionExperiments, fieldsGameCenterEnabledVersions, fieldsSubscriptionGracePeriods, fieldsEndUserLicenseAgreements, fieldsAppStoreVersions, fieldsAppCustomProductPages, fieldsAppEncryptionDeclarations, fieldsTerritories, fieldsPerfPowerMetrics, limitAppClips, limitAppCustomProductPages, limitAppEncryptionDeclarations, limitAppEvents, limitAppInfos, limitAppStoreVersionExperimentsV2, limitAppStoreVersions, limitAvailableTerritories, limitBetaAppLocalizations, limitBetaGroups, limitBuilds, limitGameCenterEnabledVersions, limitInAppPurchases, limitInAppPurchasesV2, limitPreReleaseVersions, limitPrices, limitPromotedPurchases, limitReviewSubmissions, limitSubscriptionGroups, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appsGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param include comma-separated list of relationships to include
     * @param fieldsBetaAppReviewDetails the fields to include for returned resources of type betaAppReviewDetails
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsAppPriceSchedules the fields to include for returned resources of type appPriceSchedules
     * @param fieldsCiProducts the fields to include for returned resources of type ciProducts
     * @param fieldsAlternativeDistributionKeys the fields to include for returned resources of type alternativeDistributionKeys
     * @param fieldsReviewSubmissions the fields to include for returned resources of type reviewSubmissions
     * @param fieldsBetaGroups the fields to include for returned resources of type betaGroups
     * @param fieldsPromotedPurchases the fields to include for returned resources of type promotedPurchases
     * @param fieldsAppAvailabilities the fields to include for returned resources of type appAvailabilities
     * @param fieldsCustomerReviews the fields to include for returned resources of type customerReviews
     * @param fieldsAppEvents the fields to include for returned resources of type appEvents
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param fieldsBetaLicenseAgreements the fields to include for returned resources of type betaLicenseAgreements
     * @param fieldsMarketplaceSearchDetails the fields to include for returned resources of type marketplaceSearchDetails
     * @param fieldsAppClips the fields to include for returned resources of type appClips
     * @param fieldsAppInfos the fields to include for returned resources of type appInfos
     * @param fieldsBetaAppLocalizations the fields to include for returned resources of type betaAppLocalizations
     * @param fieldsAppPricePoints the fields to include for returned resources of type appPricePoints
     * @param fieldsInAppPurchases the fields to include for returned resources of type inAppPurchases
     * @param fieldsPreReleaseVersions the fields to include for returned resources of type preReleaseVersions
     * @param fieldsSubscriptionGroups the fields to include for returned resources of type subscriptionGroups
     * @param fieldsAnalyticsReportRequests the fields to include for returned resources of type analyticsReportRequests
     * @param fieldsAppPrices the fields to include for returned resources of type appPrices
     * @param fieldsAppPreOrders the fields to include for returned resources of type appPreOrders
     * @param fieldsAppStoreVersionExperiments the fields to include for returned resources of type appStoreVersionExperiments
     * @param fieldsGameCenterEnabledVersions the fields to include for returned resources of type gameCenterEnabledVersions
     * @param fieldsSubscriptionGracePeriods the fields to include for returned resources of type subscriptionGracePeriods
     * @param fieldsEndUserLicenseAgreements the fields to include for returned resources of type endUserLicenseAgreements
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsAppCustomProductPages the fields to include for returned resources of type appCustomProductPages
     * @param fieldsAppEncryptionDeclarations the fields to include for returned resources of type appEncryptionDeclarations
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param fieldsPerfPowerMetrics the fields to include for returned resources of type perfPowerMetrics
     * @param limitAppClips maximum number of related appClips returned (when they are included)
     * @param limitAppCustomProductPages maximum number of related appCustomProductPages returned (when they are included)
     * @param limitAppEncryptionDeclarations maximum number of related appEncryptionDeclarations returned (when they are included)
     * @param limitAppEvents maximum number of related appEvents returned (when they are included)
     * @param limitAppInfos maximum number of related appInfos returned (when they are included)
     * @param limitAppStoreVersionExperimentsV2 maximum number of related appStoreVersionExperimentsV2 returned (when they are included)
     * @param limitAppStoreVersions maximum number of related appStoreVersions returned (when they are included)
     * @param limitAvailableTerritories maximum number of related availableTerritories returned (when they are included)
     * @param limitBetaAppLocalizations maximum number of related betaAppLocalizations returned (when they are included)
     * @param limitBetaGroups maximum number of related betaGroups returned (when they are included)
     * @param limitBuilds maximum number of related builds returned (when they are included)
     * @param limitGameCenterEnabledVersions maximum number of related gameCenterEnabledVersions returned (when they are included)
     * @param limitInAppPurchases maximum number of related inAppPurchases returned (when they are included)
     * @param limitInAppPurchasesV2 maximum number of related inAppPurchasesV2 returned (when they are included)
     * @param limitPreReleaseVersions maximum number of related preReleaseVersions returned (when they are included)
     * @param limitPrices maximum number of related prices returned (when they are included)
     * @param limitPromotedPurchases maximum number of related promotedPurchases returned (when they are included)
     * @param limitReviewSubmissions maximum number of related reviewSubmissions returned (when they are included)
     * @param limitSubscriptionGroups maximum number of related subscriptionGroups returned (when they are included)
     */
    public appsGetInstance(id: string, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, include?: Array<'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'builds' | 'ciProduct' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'preOrder' | 'preReleaseVersions' | 'prices' | 'promotedPurchases' | 'reviewSubmissions' | 'subscriptionGracePeriod' | 'subscriptionGroups'>, fieldsBetaAppReviewDetails?: Array<'app' | 'contactEmail' | 'contactFirstName' | 'contactLastName' | 'contactPhone' | 'demoAccountName' | 'demoAccountPassword' | 'demoAccountRequired' | 'notes'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsAppPriceSchedules?: Array<'app' | 'automaticPrices' | 'baseTerritory' | 'manualPrices'>, fieldsCiProducts?: Array<'additionalRepositories' | 'app' | 'buildRuns' | 'bundleId' | 'createdDate' | 'name' | 'primaryRepositories' | 'productType' | 'workflows'>, fieldsAlternativeDistributionKeys?: Array<'app' | 'publicKey'>, fieldsReviewSubmissions?: Array<'app' | 'appStoreVersionForReview' | 'canceled' | 'items' | 'lastUpdatedByActor' | 'platform' | 'state' | 'submitted' | 'submittedByActor' | 'submittedDate'>, fieldsBetaGroups?: Array<'app' | 'betaTesters' | 'builds' | 'createdDate' | 'feedbackEnabled' | 'hasAccessToAllBuilds' | 'iosBuildsAvailableForAppleSiliconMac' | 'isInternalGroup' | 'name' | 'publicLink' | 'publicLinkEnabled' | 'publicLinkId' | 'publicLinkLimit' | 'publicLinkLimitEnabled'>, fieldsPromotedPurchases?: Array<'app' | 'enabled' | 'inAppPurchaseV2' | 'promotionImages' | 'state' | 'subscription' | 'visibleForAllUsers'>, fieldsAppAvailabilities?: Array<'app' | 'availableInNewTerritories' | 'availableTerritories'>, fieldsCustomerReviews?: Array<'body' | 'createdDate' | 'rating' | 'response' | 'reviewerNickname' | 'territory' | 'title'>, fieldsAppEvents?: Array<'app' | 'archivedTerritorySchedules' | 'badge' | 'deepLink' | 'eventState' | 'localizations' | 'primaryLocale' | 'priority' | 'purchaseRequirement' | 'purpose' | 'referenceName' | 'territorySchedules'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, fieldsBetaLicenseAgreements?: Array<'agreementText' | 'app'>, fieldsMarketplaceSearchDetails?: Array<'app' | 'catalogUrl'>, fieldsAppClips?: Array<'app' | 'appClipAdvancedExperiences' | 'appClipDefaultExperiences' | 'bundleId'>, fieldsAppInfos?: Array<'ageRatingDeclaration' | 'app' | 'appInfoLocalizations' | 'appStoreAgeRating' | 'appStoreState' | 'brazilAgeRating' | 'brazilAgeRatingV2' | 'kidsAgeBand' | 'primaryCategory' | 'primarySubcategoryOne' | 'primarySubcategoryTwo' | 'secondaryCategory' | 'secondarySubcategoryOne' | 'secondarySubcategoryTwo' | 'state'>, fieldsBetaAppLocalizations?: Array<'app' | 'description' | 'feedbackEmail' | 'locale' | 'marketingUrl' | 'privacyPolicyUrl' | 'tvOsPrivacyPolicy'>, fieldsAppPricePoints?: Array<'app' | 'customerPrice' | 'equalizations' | 'priceTier' | 'proceeds' | 'territory'>, fieldsInAppPurchases?: Array<'app' | 'appStoreReviewScreenshot' | 'apps' | 'content' | 'contentHosting' | 'familySharable' | 'iapPriceSchedule' | 'inAppPurchaseAvailability' | 'inAppPurchaseLocalizations' | 'inAppPurchaseType' | 'name' | 'pricePoints' | 'productId' | 'promotedPurchase' | 'referenceName' | 'reviewNote' | 'state'>, fieldsPreReleaseVersions?: Array<'app' | 'builds' | 'platform' | 'version'>, fieldsSubscriptionGroups?: Array<'app' | 'referenceName' | 'subscriptionGroupLocalizations' | 'subscriptions'>, fieldsAnalyticsReportRequests?: Array<'accessType' | 'app' | 'reports' | 'stoppedDueToInactivity'>, fieldsAppPrices?: Array<'app' | 'priceTier'>, fieldsAppPreOrders?: Array<'app' | 'appReleaseDate' | 'preOrderAvailableDate'>, fieldsAppStoreVersionExperiments?: Array<'app' | 'appStoreVersionExperimentTreatments' | 'controlVersions' | 'endDate' | 'latestControlVersion' | 'name' | 'platform' | 'reviewRequired' | 'startDate' | 'started' | 'state' | 'trafficProportion'>, fieldsGameCenterEnabledVersions?: Array<'app' | 'compatibleVersions' | 'iconAsset' | 'platform' | 'versionString'>, fieldsSubscriptionGracePeriods?: Array<'duration' | 'optIn' | 'renewalType' | 'sandboxOptIn'>, fieldsEndUserLicenseAgreements?: Array<'agreementText' | 'app' | 'territories'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsAppCustomProductPages?: Array<'app' | 'appCustomProductPageVersions' | 'appStoreVersionTemplate' | 'customProductPageTemplate' | 'name' | 'url' | 'visible'>, fieldsAppEncryptionDeclarations?: Array<'app' | 'appDescription' | 'appEncryptionDeclarationDocument' | 'appEncryptionDeclarationState' | 'availableOnFrenchStore' | 'builds' | 'codeValue' | 'containsProprietaryCryptography' | 'containsThirdPartyCryptography' | 'createdDate' | 'documentName' | 'documentType' | 'documentUrl' | 'exempt' | 'platform' | 'uploadedDate' | 'usesEncryption'>, fieldsTerritories?: Array<'currency'>, fieldsPerfPowerMetrics?: Array<'deviceType' | 'metricType' | 'platform'>, limitAppClips?: number, limitAppCustomProductPages?: number, limitAppEncryptionDeclarations?: number, limitAppEvents?: number, limitAppInfos?: number, limitAppStoreVersionExperimentsV2?: number, limitAppStoreVersions?: number, limitAvailableTerritories?: number, limitBetaAppLocalizations?: number, limitBetaGroups?: number, limitBuilds?: number, limitGameCenterEnabledVersions?: number, limitInAppPurchases?: number, limitInAppPurchasesV2?: number, limitPreReleaseVersions?: number, limitPrices?: number, limitPromotedPurchases?: number, limitReviewSubmissions?: number, limitSubscriptionGroups?: number, _options?: Configuration): Observable<AppResponse> {
        return this.appsGetInstanceWithHttpInfo(id, fieldsApps, include, fieldsBetaAppReviewDetails, fieldsGameCenterDetails, fieldsAppPriceSchedules, fieldsCiProducts, fieldsAlternativeDistributionKeys, fieldsReviewSubmissions, fieldsBetaGroups, fieldsPromotedPurchases, fieldsAppAvailabilities, fieldsCustomerReviews, fieldsAppEvents, fieldsBuilds, fieldsBetaLicenseAgreements, fieldsMarketplaceSearchDetails, fieldsAppClips, fieldsAppInfos, fieldsBetaAppLocalizations, fieldsAppPricePoints, fieldsInAppPurchases, fieldsPreReleaseVersions, fieldsSubscriptionGroups, fieldsAnalyticsReportRequests, fieldsAppPrices, fieldsAppPreOrders, fieldsAppStoreVersionExperiments, fieldsGameCenterEnabledVersions, fieldsSubscriptionGracePeriods, fieldsEndUserLicenseAgreements, fieldsAppStoreVersions, fieldsAppCustomProductPages, fieldsAppEncryptionDeclarations, fieldsTerritories, fieldsPerfPowerMetrics, limitAppClips, limitAppCustomProductPages, limitAppEncryptionDeclarations, limitAppEvents, limitAppInfos, limitAppStoreVersionExperimentsV2, limitAppStoreVersions, limitAvailableTerritories, limitBetaAppLocalizations, limitBetaGroups, limitBuilds, limitGameCenterEnabledVersions, limitInAppPurchases, limitInAppPurchasesV2, limitPreReleaseVersions, limitPrices, limitPromotedPurchases, limitReviewSubmissions, limitSubscriptionGroups, _options).pipe(map((apiResponse: HttpInfo<AppResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param filterInAppPurchaseType filter by attribute \&#39;inAppPurchaseType\&#39;
     * @param filterCanBeSubmitted filter by canBeSubmitted
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsInAppPurchases the fields to include for returned resources of type inAppPurchases
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param limit maximum resources per page
     * @param limitApps maximum number of related apps returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appsInAppPurchasesGetToManyRelatedWithHttpInfo(id: string, filterInAppPurchaseType?: Array<'AUTOMATICALLY_RENEWABLE_SUBSCRIPTION' | 'NON_CONSUMABLE' | 'CONSUMABLE' | 'NON_RENEWING_SUBSCRIPTION' | 'FREE_SUBSCRIPTION'>, filterCanBeSubmitted?: Array<string>, sort?: Array<'inAppPurchaseType' | '-inAppPurchaseType' | 'productId' | '-productId' | 'referenceName' | '-referenceName'>, fieldsInAppPurchases?: Array<'apps' | 'inAppPurchaseType' | 'productId' | 'referenceName' | 'state'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, limit?: number, limitApps?: number, include?: Array<'apps'>, _options?: Configuration): Observable<HttpInfo<InAppPurchasesResponse>> {
        const requestContextPromise = this.requestFactory.appsInAppPurchasesGetToManyRelated(id, filterInAppPurchaseType, filterCanBeSubmitted, sort, fieldsInAppPurchases, fieldsApps, limit, limitApps, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appsInAppPurchasesGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param filterInAppPurchaseType filter by attribute \&#39;inAppPurchaseType\&#39;
     * @param filterCanBeSubmitted filter by canBeSubmitted
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsInAppPurchases the fields to include for returned resources of type inAppPurchases
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param limit maximum resources per page
     * @param limitApps maximum number of related apps returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appsInAppPurchasesGetToManyRelated(id: string, filterInAppPurchaseType?: Array<'AUTOMATICALLY_RENEWABLE_SUBSCRIPTION' | 'NON_CONSUMABLE' | 'CONSUMABLE' | 'NON_RENEWING_SUBSCRIPTION' | 'FREE_SUBSCRIPTION'>, filterCanBeSubmitted?: Array<string>, sort?: Array<'inAppPurchaseType' | '-inAppPurchaseType' | 'productId' | '-productId' | 'referenceName' | '-referenceName'>, fieldsInAppPurchases?: Array<'apps' | 'inAppPurchaseType' | 'productId' | 'referenceName' | 'state'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, limit?: number, limitApps?: number, include?: Array<'apps'>, _options?: Configuration): Observable<InAppPurchasesResponse> {
        return this.appsInAppPurchasesGetToManyRelatedWithHttpInfo(id, filterInAppPurchaseType, filterCanBeSubmitted, sort, fieldsInAppPurchases, fieldsApps, limit, limitApps, include, _options).pipe(map((apiResponse: HttpInfo<InAppPurchasesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param filterInAppPurchaseType filter by attribute \&#39;inAppPurchaseType\&#39;
     * @param filterName filter by attribute \&#39;name\&#39;
     * @param filterProductId filter by attribute \&#39;productId\&#39;
     * @param filterState filter by attribute \&#39;state\&#39;
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsInAppPurchaseAppStoreReviewScreenshots the fields to include for returned resources of type inAppPurchaseAppStoreReviewScreenshots
     * @param fieldsInAppPurchaseAvailabilities the fields to include for returned resources of type inAppPurchaseAvailabilities
     * @param fieldsPromotedPurchases the fields to include for returned resources of type promotedPurchases
     * @param fieldsInAppPurchaseLocalizations the fields to include for returned resources of type inAppPurchaseLocalizations
     * @param fieldsInAppPurchases the fields to include for returned resources of type inAppPurchases
     * @param fieldsInAppPurchasePriceSchedules the fields to include for returned resources of type inAppPurchasePriceSchedules
     * @param fieldsInAppPurchaseContents the fields to include for returned resources of type inAppPurchaseContents
     * @param limit maximum resources per page
     * @param limitInAppPurchaseLocalizations maximum number of related inAppPurchaseLocalizations returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appsInAppPurchasesV2GetToManyRelatedWithHttpInfo(id: string, filterInAppPurchaseType?: Array<'CONSUMABLE' | 'NON_CONSUMABLE' | 'NON_RENEWING_SUBSCRIPTION'>, filterName?: Array<string>, filterProductId?: Array<string>, filterState?: Array<'MISSING_METADATA' | 'WAITING_FOR_UPLOAD' | 'PROCESSING_CONTENT' | 'READY_TO_SUBMIT' | 'WAITING_FOR_REVIEW' | 'IN_REVIEW' | 'DEVELOPER_ACTION_NEEDED' | 'PENDING_BINARY_APPROVAL' | 'APPROVED' | 'DEVELOPER_REMOVED_FROM_SALE' | 'REMOVED_FROM_SALE' | 'REJECTED'>, sort?: Array<'inAppPurchaseType' | '-inAppPurchaseType' | 'name' | '-name'>, fieldsInAppPurchaseAppStoreReviewScreenshots?: Array<'assetDeliveryState' | 'assetToken' | 'assetType' | 'fileName' | 'fileSize' | 'imageAsset' | 'inAppPurchaseV2' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, fieldsInAppPurchaseAvailabilities?: Array<'availableInNewTerritories' | 'availableTerritories' | 'inAppPurchase'>, fieldsPromotedPurchases?: Array<'app' | 'enabled' | 'inAppPurchaseV2' | 'promotionImages' | 'state' | 'subscription' | 'visibleForAllUsers'>, fieldsInAppPurchaseLocalizations?: Array<'description' | 'inAppPurchaseV2' | 'locale' | 'name' | 'state'>, fieldsInAppPurchases?: Array<'app' | 'appStoreReviewScreenshot' | 'content' | 'contentHosting' | 'familySharable' | 'iapPriceSchedule' | 'inAppPurchaseAvailability' | 'inAppPurchaseLocalizations' | 'inAppPurchaseType' | 'name' | 'productId' | 'promotedPurchase' | 'reviewNote' | 'state'>, fieldsInAppPurchasePriceSchedules?: Array<'automaticPrices' | 'baseTerritory' | 'inAppPurchase' | 'manualPrices'>, fieldsInAppPurchaseContents?: Array<'fileName' | 'fileSize' | 'inAppPurchaseV2' | 'lastModifiedDate' | 'url'>, limit?: number, limitInAppPurchaseLocalizations?: number, include?: Array<'appStoreReviewScreenshot' | 'content' | 'iapPriceSchedule' | 'inAppPurchaseAvailability' | 'inAppPurchaseLocalizations' | 'promotedPurchase'>, _options?: Configuration): Observable<HttpInfo<InAppPurchasesV2Response>> {
        const requestContextPromise = this.requestFactory.appsInAppPurchasesV2GetToManyRelated(id, filterInAppPurchaseType, filterName, filterProductId, filterState, sort, fieldsInAppPurchaseAppStoreReviewScreenshots, fieldsInAppPurchaseAvailabilities, fieldsPromotedPurchases, fieldsInAppPurchaseLocalizations, fieldsInAppPurchases, fieldsInAppPurchasePriceSchedules, fieldsInAppPurchaseContents, limit, limitInAppPurchaseLocalizations, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appsInAppPurchasesV2GetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param filterInAppPurchaseType filter by attribute \&#39;inAppPurchaseType\&#39;
     * @param filterName filter by attribute \&#39;name\&#39;
     * @param filterProductId filter by attribute \&#39;productId\&#39;
     * @param filterState filter by attribute \&#39;state\&#39;
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsInAppPurchaseAppStoreReviewScreenshots the fields to include for returned resources of type inAppPurchaseAppStoreReviewScreenshots
     * @param fieldsInAppPurchaseAvailabilities the fields to include for returned resources of type inAppPurchaseAvailabilities
     * @param fieldsPromotedPurchases the fields to include for returned resources of type promotedPurchases
     * @param fieldsInAppPurchaseLocalizations the fields to include for returned resources of type inAppPurchaseLocalizations
     * @param fieldsInAppPurchases the fields to include for returned resources of type inAppPurchases
     * @param fieldsInAppPurchasePriceSchedules the fields to include for returned resources of type inAppPurchasePriceSchedules
     * @param fieldsInAppPurchaseContents the fields to include for returned resources of type inAppPurchaseContents
     * @param limit maximum resources per page
     * @param limitInAppPurchaseLocalizations maximum number of related inAppPurchaseLocalizations returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appsInAppPurchasesV2GetToManyRelated(id: string, filterInAppPurchaseType?: Array<'CONSUMABLE' | 'NON_CONSUMABLE' | 'NON_RENEWING_SUBSCRIPTION'>, filterName?: Array<string>, filterProductId?: Array<string>, filterState?: Array<'MISSING_METADATA' | 'WAITING_FOR_UPLOAD' | 'PROCESSING_CONTENT' | 'READY_TO_SUBMIT' | 'WAITING_FOR_REVIEW' | 'IN_REVIEW' | 'DEVELOPER_ACTION_NEEDED' | 'PENDING_BINARY_APPROVAL' | 'APPROVED' | 'DEVELOPER_REMOVED_FROM_SALE' | 'REMOVED_FROM_SALE' | 'REJECTED'>, sort?: Array<'inAppPurchaseType' | '-inAppPurchaseType' | 'name' | '-name'>, fieldsInAppPurchaseAppStoreReviewScreenshots?: Array<'assetDeliveryState' | 'assetToken' | 'assetType' | 'fileName' | 'fileSize' | 'imageAsset' | 'inAppPurchaseV2' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, fieldsInAppPurchaseAvailabilities?: Array<'availableInNewTerritories' | 'availableTerritories' | 'inAppPurchase'>, fieldsPromotedPurchases?: Array<'app' | 'enabled' | 'inAppPurchaseV2' | 'promotionImages' | 'state' | 'subscription' | 'visibleForAllUsers'>, fieldsInAppPurchaseLocalizations?: Array<'description' | 'inAppPurchaseV2' | 'locale' | 'name' | 'state'>, fieldsInAppPurchases?: Array<'app' | 'appStoreReviewScreenshot' | 'content' | 'contentHosting' | 'familySharable' | 'iapPriceSchedule' | 'inAppPurchaseAvailability' | 'inAppPurchaseLocalizations' | 'inAppPurchaseType' | 'name' | 'productId' | 'promotedPurchase' | 'reviewNote' | 'state'>, fieldsInAppPurchasePriceSchedules?: Array<'automaticPrices' | 'baseTerritory' | 'inAppPurchase' | 'manualPrices'>, fieldsInAppPurchaseContents?: Array<'fileName' | 'fileSize' | 'inAppPurchaseV2' | 'lastModifiedDate' | 'url'>, limit?: number, limitInAppPurchaseLocalizations?: number, include?: Array<'appStoreReviewScreenshot' | 'content' | 'iapPriceSchedule' | 'inAppPurchaseAvailability' | 'inAppPurchaseLocalizations' | 'promotedPurchase'>, _options?: Configuration): Observable<InAppPurchasesV2Response> {
        return this.appsInAppPurchasesV2GetToManyRelatedWithHttpInfo(id, filterInAppPurchaseType, filterName, filterProductId, filterState, sort, fieldsInAppPurchaseAppStoreReviewScreenshots, fieldsInAppPurchaseAvailabilities, fieldsPromotedPurchases, fieldsInAppPurchaseLocalizations, fieldsInAppPurchases, fieldsInAppPurchasePriceSchedules, fieldsInAppPurchaseContents, limit, limitInAppPurchaseLocalizations, include, _options).pipe(map((apiResponse: HttpInfo<InAppPurchasesV2Response>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsMarketplaceSearchDetails the fields to include for returned resources of type marketplaceSearchDetails
     */
    public appsMarketplaceSearchDetailGetToOneRelatedWithHttpInfo(id: string, fieldsMarketplaceSearchDetails?: Array<'app' | 'catalogUrl'>, _options?: Configuration): Observable<HttpInfo<MarketplaceSearchDetailResponse>> {
        const requestContextPromise = this.requestFactory.appsMarketplaceSearchDetailGetToOneRelated(id, fieldsMarketplaceSearchDetails, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appsMarketplaceSearchDetailGetToOneRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsMarketplaceSearchDetails the fields to include for returned resources of type marketplaceSearchDetails
     */
    public appsMarketplaceSearchDetailGetToOneRelated(id: string, fieldsMarketplaceSearchDetails?: Array<'app' | 'catalogUrl'>, _options?: Configuration): Observable<MarketplaceSearchDetailResponse> {
        return this.appsMarketplaceSearchDetailGetToOneRelatedWithHttpInfo(id, fieldsMarketplaceSearchDetails, _options).pipe(map((apiResponse: HttpInfo<MarketplaceSearchDetailResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param filterDeviceType filter by attribute \&#39;deviceType\&#39;
     * @param filterMetricType filter by attribute \&#39;metricType\&#39;
     * @param filterPlatform filter by attribute \&#39;platform\&#39;
     */
    public appsPerfPowerMetricsGetToManyRelatedWithHttpInfo(id: string, filterDeviceType?: Array<string>, filterMetricType?: Array<'DISK' | 'HANG' | 'BATTERY' | 'LAUNCH' | 'MEMORY' | 'ANIMATION' | 'TERMINATION'>, filterPlatform?: Array<'IOS'>, _options?: Configuration): Observable<HttpInfo<XcodeMetrics>> {
        const requestContextPromise = this.requestFactory.appsPerfPowerMetricsGetToManyRelated(id, filterDeviceType, filterMetricType, filterPlatform, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appsPerfPowerMetricsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param filterDeviceType filter by attribute \&#39;deviceType\&#39;
     * @param filterMetricType filter by attribute \&#39;metricType\&#39;
     * @param filterPlatform filter by attribute \&#39;platform\&#39;
     */
    public appsPerfPowerMetricsGetToManyRelated(id: string, filterDeviceType?: Array<string>, filterMetricType?: Array<'DISK' | 'HANG' | 'BATTERY' | 'LAUNCH' | 'MEMORY' | 'ANIMATION' | 'TERMINATION'>, filterPlatform?: Array<'IOS'>, _options?: Configuration): Observable<XcodeMetrics> {
        return this.appsPerfPowerMetricsGetToManyRelatedWithHttpInfo(id, filterDeviceType, filterMetricType, filterPlatform, _options).pipe(map((apiResponse: HttpInfo<XcodeMetrics>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppPreOrders the fields to include for returned resources of type appPreOrders
     */
    public appsPreOrderGetToOneRelatedWithHttpInfo(id: string, fieldsAppPreOrders?: Array<'app' | 'appReleaseDate' | 'preOrderAvailableDate'>, _options?: Configuration): Observable<HttpInfo<AppPreOrderWithoutIncludesResponse>> {
        const requestContextPromise = this.requestFactory.appsPreOrderGetToOneRelated(id, fieldsAppPreOrders, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appsPreOrderGetToOneRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppPreOrders the fields to include for returned resources of type appPreOrders
     */
    public appsPreOrderGetToOneRelated(id: string, fieldsAppPreOrders?: Array<'app' | 'appReleaseDate' | 'preOrderAvailableDate'>, _options?: Configuration): Observable<AppPreOrderWithoutIncludesResponse> {
        return this.appsPreOrderGetToOneRelatedWithHttpInfo(id, fieldsAppPreOrders, _options).pipe(map((apiResponse: HttpInfo<AppPreOrderWithoutIncludesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsPreReleaseVersions the fields to include for returned resources of type preReleaseVersions
     * @param limit maximum resources per page
     */
    public appsPreReleaseVersionsGetToManyRelatedWithHttpInfo(id: string, fieldsPreReleaseVersions?: Array<'app' | 'builds' | 'platform' | 'version'>, limit?: number, _options?: Configuration): Observable<HttpInfo<PreReleaseVersionsWithoutIncludesResponse>> {
        const requestContextPromise = this.requestFactory.appsPreReleaseVersionsGetToManyRelated(id, fieldsPreReleaseVersions, limit, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appsPreReleaseVersionsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsPreReleaseVersions the fields to include for returned resources of type preReleaseVersions
     * @param limit maximum resources per page
     */
    public appsPreReleaseVersionsGetToManyRelated(id: string, fieldsPreReleaseVersions?: Array<'app' | 'builds' | 'platform' | 'version'>, limit?: number, _options?: Configuration): Observable<PreReleaseVersionsWithoutIncludesResponse> {
        return this.appsPreReleaseVersionsGetToManyRelatedWithHttpInfo(id, fieldsPreReleaseVersions, limit, _options).pipe(map((apiResponse: HttpInfo<PreReleaseVersionsWithoutIncludesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param filterPriceTier filter by id(s) of related \&#39;priceTier\&#39;
     * @param filterTerritory filter by id(s) of related \&#39;territory\&#39;
     * @param fieldsAppPriceTiers the fields to include for returned resources of type appPriceTiers
     * @param fieldsAppPricePoints the fields to include for returned resources of type appPricePoints
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public appsPricePointsGetToManyRelatedWithHttpInfo(id: string, filterPriceTier?: Array<string>, filterTerritory?: Array<string>, fieldsAppPriceTiers?: Array<'pricePoints'>, fieldsAppPricePoints?: Array<'app' | 'customerPrice' | 'priceTier' | 'proceeds' | 'territory'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsTerritories?: Array<'currency'>, limit?: number, include?: Array<'app' | 'priceTier' | 'territory'>, _options?: Configuration): Observable<HttpInfo<AppPricePointsV2Response>> {
        const requestContextPromise = this.requestFactory.appsPricePointsGetToManyRelated(id, filterPriceTier, filterTerritory, fieldsAppPriceTiers, fieldsAppPricePoints, fieldsApps, fieldsTerritories, limit, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appsPricePointsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param filterPriceTier filter by id(s) of related \&#39;priceTier\&#39;
     * @param filterTerritory filter by id(s) of related \&#39;territory\&#39;
     * @param fieldsAppPriceTiers the fields to include for returned resources of type appPriceTiers
     * @param fieldsAppPricePoints the fields to include for returned resources of type appPricePoints
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public appsPricePointsGetToManyRelated(id: string, filterPriceTier?: Array<string>, filterTerritory?: Array<string>, fieldsAppPriceTiers?: Array<'pricePoints'>, fieldsAppPricePoints?: Array<'app' | 'customerPrice' | 'priceTier' | 'proceeds' | 'territory'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsTerritories?: Array<'currency'>, limit?: number, include?: Array<'app' | 'priceTier' | 'territory'>, _options?: Configuration): Observable<AppPricePointsV2Response> {
        return this.appsPricePointsGetToManyRelatedWithHttpInfo(id, filterPriceTier, filterTerritory, fieldsAppPriceTiers, fieldsAppPricePoints, fieldsApps, fieldsTerritories, limit, include, _options).pipe(map((apiResponse: HttpInfo<AppPricePointsV2Response>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppPriceTiers the fields to include for returned resources of type appPriceTiers
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsAppPrices the fields to include for returned resources of type appPrices
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public appsPricesGetToManyRelatedWithHttpInfo(id: string, fieldsAppPriceTiers?: Array<'pricePoints'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsAppPrices?: Array<'app' | 'priceTier'>, limit?: number, include?: Array<'app' | 'priceTier'>, _options?: Configuration): Observable<HttpInfo<AppPricesResponse>> {
        const requestContextPromise = this.requestFactory.appsPricesGetToManyRelated(id, fieldsAppPriceTiers, fieldsApps, fieldsAppPrices, limit, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appsPricesGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppPriceTiers the fields to include for returned resources of type appPriceTiers
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsAppPrices the fields to include for returned resources of type appPrices
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public appsPricesGetToManyRelated(id: string, fieldsAppPriceTiers?: Array<'pricePoints'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsAppPrices?: Array<'app' | 'priceTier'>, limit?: number, include?: Array<'app' | 'priceTier'>, _options?: Configuration): Observable<AppPricesResponse> {
        return this.appsPricesGetToManyRelatedWithHttpInfo(id, fieldsAppPriceTiers, fieldsApps, fieldsAppPrices, limit, include, _options).pipe(map((apiResponse: HttpInfo<AppPricesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsPromotedPurchases the fields to include for returned resources of type promotedPurchases
     * @param fieldsSubscriptions the fields to include for returned resources of type subscriptions
     * @param fieldsInAppPurchases the fields to include for returned resources of type inAppPurchases
     * @param fieldsPromotedPurchaseImages the fields to include for returned resources of type promotedPurchaseImages
     * @param limit maximum resources per page
     * @param limitPromotionImages maximum number of related promotionImages returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appsPromotedPurchasesGetToManyRelatedWithHttpInfo(id: string, fieldsPromotedPurchases?: Array<'app' | 'enabled' | 'inAppPurchaseV2' | 'promotionImages' | 'state' | 'subscription' | 'visibleForAllUsers'>, fieldsSubscriptions?: Array<'appStoreReviewScreenshot' | 'familySharable' | 'group' | 'groupLevel' | 'introductoryOffers' | 'name' | 'offerCodes' | 'pricePoints' | 'prices' | 'productId' | 'promotedPurchase' | 'promotionalOffers' | 'reviewNote' | 'state' | 'subscriptionAvailability' | 'subscriptionLocalizations' | 'subscriptionPeriod'>, fieldsInAppPurchases?: Array<'app' | 'appStoreReviewScreenshot' | 'content' | 'contentHosting' | 'familySharable' | 'iapPriceSchedule' | 'inAppPurchaseAvailability' | 'inAppPurchaseLocalizations' | 'inAppPurchaseType' | 'name' | 'pricePoints' | 'productId' | 'promotedPurchase' | 'reviewNote' | 'state'>, fieldsPromotedPurchaseImages?: Array<'assetToken' | 'assetType' | 'fileName' | 'fileSize' | 'imageAsset' | 'promotedPurchase' | 'sourceFileChecksum' | 'state' | 'uploadOperations' | 'uploaded'>, limit?: number, limitPromotionImages?: number, include?: Array<'inAppPurchaseV2' | 'promotionImages' | 'subscription'>, _options?: Configuration): Observable<HttpInfo<PromotedPurchasesResponse>> {
        const requestContextPromise = this.requestFactory.appsPromotedPurchasesGetToManyRelated(id, fieldsPromotedPurchases, fieldsSubscriptions, fieldsInAppPurchases, fieldsPromotedPurchaseImages, limit, limitPromotionImages, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appsPromotedPurchasesGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsPromotedPurchases the fields to include for returned resources of type promotedPurchases
     * @param fieldsSubscriptions the fields to include for returned resources of type subscriptions
     * @param fieldsInAppPurchases the fields to include for returned resources of type inAppPurchases
     * @param fieldsPromotedPurchaseImages the fields to include for returned resources of type promotedPurchaseImages
     * @param limit maximum resources per page
     * @param limitPromotionImages maximum number of related promotionImages returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appsPromotedPurchasesGetToManyRelated(id: string, fieldsPromotedPurchases?: Array<'app' | 'enabled' | 'inAppPurchaseV2' | 'promotionImages' | 'state' | 'subscription' | 'visibleForAllUsers'>, fieldsSubscriptions?: Array<'appStoreReviewScreenshot' | 'familySharable' | 'group' | 'groupLevel' | 'introductoryOffers' | 'name' | 'offerCodes' | 'pricePoints' | 'prices' | 'productId' | 'promotedPurchase' | 'promotionalOffers' | 'reviewNote' | 'state' | 'subscriptionAvailability' | 'subscriptionLocalizations' | 'subscriptionPeriod'>, fieldsInAppPurchases?: Array<'app' | 'appStoreReviewScreenshot' | 'content' | 'contentHosting' | 'familySharable' | 'iapPriceSchedule' | 'inAppPurchaseAvailability' | 'inAppPurchaseLocalizations' | 'inAppPurchaseType' | 'name' | 'pricePoints' | 'productId' | 'promotedPurchase' | 'reviewNote' | 'state'>, fieldsPromotedPurchaseImages?: Array<'assetToken' | 'assetType' | 'fileName' | 'fileSize' | 'imageAsset' | 'promotedPurchase' | 'sourceFileChecksum' | 'state' | 'uploadOperations' | 'uploaded'>, limit?: number, limitPromotionImages?: number, include?: Array<'inAppPurchaseV2' | 'promotionImages' | 'subscription'>, _options?: Configuration): Observable<PromotedPurchasesResponse> {
        return this.appsPromotedPurchasesGetToManyRelatedWithHttpInfo(id, fieldsPromotedPurchases, fieldsSubscriptions, fieldsInAppPurchases, fieldsPromotedPurchaseImages, limit, limitPromotionImages, include, _options).pipe(map((apiResponse: HttpInfo<PromotedPurchasesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public appsPromotedPurchasesGetToManyRelationshipWithHttpInfo(id: string, limit?: number, _options?: Configuration): Observable<HttpInfo<AppPromotedPurchasesLinkagesResponse>> {
        const requestContextPromise = this.requestFactory.appsPromotedPurchasesGetToManyRelationship(id, limit, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appsPromotedPurchasesGetToManyRelationshipWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public appsPromotedPurchasesGetToManyRelationship(id: string, limit?: number, _options?: Configuration): Observable<AppPromotedPurchasesLinkagesResponse> {
        return this.appsPromotedPurchasesGetToManyRelationshipWithHttpInfo(id, limit, _options).pipe(map((apiResponse: HttpInfo<AppPromotedPurchasesLinkagesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param appPromotedPurchasesLinkagesRequest List of related linkages
     */
    public appsPromotedPurchasesReplaceToManyRelationshipWithHttpInfo(id: string, appPromotedPurchasesLinkagesRequest: AppPromotedPurchasesLinkagesRequest, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.appsPromotedPurchasesReplaceToManyRelationship(id, appPromotedPurchasesLinkagesRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appsPromotedPurchasesReplaceToManyRelationshipWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param appPromotedPurchasesLinkagesRequest List of related linkages
     */
    public appsPromotedPurchasesReplaceToManyRelationship(id: string, appPromotedPurchasesLinkagesRequest: AppPromotedPurchasesLinkagesRequest, _options?: Configuration): Observable<void> {
        return this.appsPromotedPurchasesReplaceToManyRelationshipWithHttpInfo(id, appPromotedPurchasesLinkagesRequest, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param filterPlatform filter by attribute \&#39;platform\&#39;
     * @param filterState filter by attribute \&#39;state\&#39;
     * @param fieldsReviewSubmissionItems the fields to include for returned resources of type reviewSubmissionItems
     * @param fieldsActors the fields to include for returned resources of type actors
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsReviewSubmissions the fields to include for returned resources of type reviewSubmissions
     * @param limit maximum resources per page
     * @param limitItems maximum number of related items returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appsReviewSubmissionsGetToManyRelatedWithHttpInfo(id: string, filterPlatform?: Array<'IOS' | 'MAC_OS' | 'TV_OS' | 'VISION_OS'>, filterState?: Array<'READY_FOR_REVIEW' | 'WAITING_FOR_REVIEW' | 'IN_REVIEW' | 'UNRESOLVED_ISSUES' | 'CANCELING' | 'COMPLETING' | 'COMPLETE'>, fieldsReviewSubmissionItems?: Array<'appCustomProductPageVersion' | 'appEvent' | 'appStoreVersion' | 'appStoreVersionExperiment' | 'appStoreVersionExperimentV2' | 'removed' | 'resolved' | 'reviewSubmission' | 'state'>, fieldsActors?: Array<'actorType' | 'apiKeyId' | 'userEmail' | 'userFirstName' | 'userLastName'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsReviewSubmissions?: Array<'app' | 'appStoreVersionForReview' | 'canceled' | 'items' | 'lastUpdatedByActor' | 'platform' | 'state' | 'submitted' | 'submittedByActor' | 'submittedDate'>, limit?: number, limitItems?: number, include?: Array<'app' | 'appStoreVersionForReview' | 'items' | 'lastUpdatedByActor' | 'submittedByActor'>, _options?: Configuration): Observable<HttpInfo<ReviewSubmissionsResponse>> {
        const requestContextPromise = this.requestFactory.appsReviewSubmissionsGetToManyRelated(id, filterPlatform, filterState, fieldsReviewSubmissionItems, fieldsActors, fieldsAppStoreVersions, fieldsApps, fieldsReviewSubmissions, limit, limitItems, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appsReviewSubmissionsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param filterPlatform filter by attribute \&#39;platform\&#39;
     * @param filterState filter by attribute \&#39;state\&#39;
     * @param fieldsReviewSubmissionItems the fields to include for returned resources of type reviewSubmissionItems
     * @param fieldsActors the fields to include for returned resources of type actors
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsReviewSubmissions the fields to include for returned resources of type reviewSubmissions
     * @param limit maximum resources per page
     * @param limitItems maximum number of related items returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appsReviewSubmissionsGetToManyRelated(id: string, filterPlatform?: Array<'IOS' | 'MAC_OS' | 'TV_OS' | 'VISION_OS'>, filterState?: Array<'READY_FOR_REVIEW' | 'WAITING_FOR_REVIEW' | 'IN_REVIEW' | 'UNRESOLVED_ISSUES' | 'CANCELING' | 'COMPLETING' | 'COMPLETE'>, fieldsReviewSubmissionItems?: Array<'appCustomProductPageVersion' | 'appEvent' | 'appStoreVersion' | 'appStoreVersionExperiment' | 'appStoreVersionExperimentV2' | 'removed' | 'resolved' | 'reviewSubmission' | 'state'>, fieldsActors?: Array<'actorType' | 'apiKeyId' | 'userEmail' | 'userFirstName' | 'userLastName'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsReviewSubmissions?: Array<'app' | 'appStoreVersionForReview' | 'canceled' | 'items' | 'lastUpdatedByActor' | 'platform' | 'state' | 'submitted' | 'submittedByActor' | 'submittedDate'>, limit?: number, limitItems?: number, include?: Array<'app' | 'appStoreVersionForReview' | 'items' | 'lastUpdatedByActor' | 'submittedByActor'>, _options?: Configuration): Observable<ReviewSubmissionsResponse> {
        return this.appsReviewSubmissionsGetToManyRelatedWithHttpInfo(id, filterPlatform, filterState, fieldsReviewSubmissionItems, fieldsActors, fieldsAppStoreVersions, fieldsApps, fieldsReviewSubmissions, limit, limitItems, include, _options).pipe(map((apiResponse: HttpInfo<ReviewSubmissionsResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsSubscriptionGracePeriods the fields to include for returned resources of type subscriptionGracePeriods
     */
    public appsSubscriptionGracePeriodGetToOneRelatedWithHttpInfo(id: string, fieldsSubscriptionGracePeriods?: Array<'duration' | 'optIn' | 'renewalType' | 'sandboxOptIn'>, _options?: Configuration): Observable<HttpInfo<SubscriptionGracePeriodResponse>> {
        const requestContextPromise = this.requestFactory.appsSubscriptionGracePeriodGetToOneRelated(id, fieldsSubscriptionGracePeriods, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appsSubscriptionGracePeriodGetToOneRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsSubscriptionGracePeriods the fields to include for returned resources of type subscriptionGracePeriods
     */
    public appsSubscriptionGracePeriodGetToOneRelated(id: string, fieldsSubscriptionGracePeriods?: Array<'duration' | 'optIn' | 'renewalType' | 'sandboxOptIn'>, _options?: Configuration): Observable<SubscriptionGracePeriodResponse> {
        return this.appsSubscriptionGracePeriodGetToOneRelatedWithHttpInfo(id, fieldsSubscriptionGracePeriods, _options).pipe(map((apiResponse: HttpInfo<SubscriptionGracePeriodResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param filterReferenceName filter by attribute \&#39;referenceName\&#39;
     * @param filterSubscriptionsState filter by attribute \&#39;subscriptions.state\&#39;
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsSubscriptions the fields to include for returned resources of type subscriptions
     * @param fieldsSubscriptionGroups the fields to include for returned resources of type subscriptionGroups
     * @param fieldsSubscriptionGroupLocalizations the fields to include for returned resources of type subscriptionGroupLocalizations
     * @param limit maximum resources per page
     * @param limitSubscriptions maximum number of related subscriptions returned (when they are included)
     * @param limitSubscriptionGroupLocalizations maximum number of related subscriptionGroupLocalizations returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appsSubscriptionGroupsGetToManyRelatedWithHttpInfo(id: string, filterReferenceName?: Array<string>, filterSubscriptionsState?: Array<'MISSING_METADATA' | 'READY_TO_SUBMIT' | 'WAITING_FOR_REVIEW' | 'IN_REVIEW' | 'DEVELOPER_ACTION_NEEDED' | 'PENDING_BINARY_APPROVAL' | 'APPROVED' | 'DEVELOPER_REMOVED_FROM_SALE' | 'REMOVED_FROM_SALE' | 'REJECTED'>, sort?: Array<'referenceName' | '-referenceName'>, fieldsSubscriptions?: Array<'appStoreReviewScreenshot' | 'familySharable' | 'group' | 'groupLevel' | 'introductoryOffers' | 'name' | 'offerCodes' | 'pricePoints' | 'prices' | 'productId' | 'promotedPurchase' | 'promotionalOffers' | 'reviewNote' | 'state' | 'subscriptionAvailability' | 'subscriptionLocalizations' | 'subscriptionPeriod'>, fieldsSubscriptionGroups?: Array<'app' | 'referenceName' | 'subscriptionGroupLocalizations' | 'subscriptions'>, fieldsSubscriptionGroupLocalizations?: Array<'customAppName' | 'locale' | 'name' | 'state' | 'subscriptionGroup'>, limit?: number, limitSubscriptions?: number, limitSubscriptionGroupLocalizations?: number, include?: Array<'subscriptionGroupLocalizations' | 'subscriptions'>, _options?: Configuration): Observable<HttpInfo<SubscriptionGroupsResponse>> {
        const requestContextPromise = this.requestFactory.appsSubscriptionGroupsGetToManyRelated(id, filterReferenceName, filterSubscriptionsState, sort, fieldsSubscriptions, fieldsSubscriptionGroups, fieldsSubscriptionGroupLocalizations, limit, limitSubscriptions, limitSubscriptionGroupLocalizations, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appsSubscriptionGroupsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param filterReferenceName filter by attribute \&#39;referenceName\&#39;
     * @param filterSubscriptionsState filter by attribute \&#39;subscriptions.state\&#39;
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsSubscriptions the fields to include for returned resources of type subscriptions
     * @param fieldsSubscriptionGroups the fields to include for returned resources of type subscriptionGroups
     * @param fieldsSubscriptionGroupLocalizations the fields to include for returned resources of type subscriptionGroupLocalizations
     * @param limit maximum resources per page
     * @param limitSubscriptions maximum number of related subscriptions returned (when they are included)
     * @param limitSubscriptionGroupLocalizations maximum number of related subscriptionGroupLocalizations returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appsSubscriptionGroupsGetToManyRelated(id: string, filterReferenceName?: Array<string>, filterSubscriptionsState?: Array<'MISSING_METADATA' | 'READY_TO_SUBMIT' | 'WAITING_FOR_REVIEW' | 'IN_REVIEW' | 'DEVELOPER_ACTION_NEEDED' | 'PENDING_BINARY_APPROVAL' | 'APPROVED' | 'DEVELOPER_REMOVED_FROM_SALE' | 'REMOVED_FROM_SALE' | 'REJECTED'>, sort?: Array<'referenceName' | '-referenceName'>, fieldsSubscriptions?: Array<'appStoreReviewScreenshot' | 'familySharable' | 'group' | 'groupLevel' | 'introductoryOffers' | 'name' | 'offerCodes' | 'pricePoints' | 'prices' | 'productId' | 'promotedPurchase' | 'promotionalOffers' | 'reviewNote' | 'state' | 'subscriptionAvailability' | 'subscriptionLocalizations' | 'subscriptionPeriod'>, fieldsSubscriptionGroups?: Array<'app' | 'referenceName' | 'subscriptionGroupLocalizations' | 'subscriptions'>, fieldsSubscriptionGroupLocalizations?: Array<'customAppName' | 'locale' | 'name' | 'state' | 'subscriptionGroup'>, limit?: number, limitSubscriptions?: number, limitSubscriptionGroupLocalizations?: number, include?: Array<'subscriptionGroupLocalizations' | 'subscriptions'>, _options?: Configuration): Observable<SubscriptionGroupsResponse> {
        return this.appsSubscriptionGroupsGetToManyRelatedWithHttpInfo(id, filterReferenceName, filterSubscriptionsState, sort, fieldsSubscriptions, fieldsSubscriptionGroups, fieldsSubscriptionGroupLocalizations, limit, limitSubscriptions, limitSubscriptionGroupLocalizations, include, _options).pipe(map((apiResponse: HttpInfo<SubscriptionGroupsResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param appUpdateRequest App representation
     */
    public appsUpdateInstanceWithHttpInfo(id: string, appUpdateRequest: AppUpdateRequest, _options?: Configuration): Observable<HttpInfo<AppResponse>> {
        const requestContextPromise = this.requestFactory.appsUpdateInstance(id, appUpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appsUpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param appUpdateRequest App representation
     */
    public appsUpdateInstance(id: string, appUpdateRequest: AppUpdateRequest, _options?: Configuration): Observable<AppResponse> {
        return this.appsUpdateInstanceWithHttpInfo(id, appUpdateRequest, _options).pipe(map((apiResponse: HttpInfo<AppResponse>) => apiResponse.data));
    }

}

import { BetaAppClipInvocationLocalizationsApiRequestFactory, BetaAppClipInvocationLocalizationsApiResponseProcessor} from "../apis/BetaAppClipInvocationLocalizationsApi.ts";
export class ObservableBetaAppClipInvocationLocalizationsApi {
    private requestFactory: BetaAppClipInvocationLocalizationsApiRequestFactory;
    private responseProcessor: BetaAppClipInvocationLocalizationsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: BetaAppClipInvocationLocalizationsApiRequestFactory,
        responseProcessor?: BetaAppClipInvocationLocalizationsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new BetaAppClipInvocationLocalizationsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new BetaAppClipInvocationLocalizationsApiResponseProcessor();
    }

    /**
     * @param betaAppClipInvocationLocalizationCreateRequest BetaAppClipInvocationLocalization representation
     */
    public betaAppClipInvocationLocalizationsCreateInstanceWithHttpInfo(betaAppClipInvocationLocalizationCreateRequest: BetaAppClipInvocationLocalizationCreateRequest, _options?: Configuration): Observable<HttpInfo<BetaAppClipInvocationLocalizationResponse>> {
        const requestContextPromise = this.requestFactory.betaAppClipInvocationLocalizationsCreateInstance(betaAppClipInvocationLocalizationCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.betaAppClipInvocationLocalizationsCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param betaAppClipInvocationLocalizationCreateRequest BetaAppClipInvocationLocalization representation
     */
    public betaAppClipInvocationLocalizationsCreateInstance(betaAppClipInvocationLocalizationCreateRequest: BetaAppClipInvocationLocalizationCreateRequest, _options?: Configuration): Observable<BetaAppClipInvocationLocalizationResponse> {
        return this.betaAppClipInvocationLocalizationsCreateInstanceWithHttpInfo(betaAppClipInvocationLocalizationCreateRequest, _options).pipe(map((apiResponse: HttpInfo<BetaAppClipInvocationLocalizationResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public betaAppClipInvocationLocalizationsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.betaAppClipInvocationLocalizationsDeleteInstance(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.betaAppClipInvocationLocalizationsDeleteInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public betaAppClipInvocationLocalizationsDeleteInstance(id: string, _options?: Configuration): Observable<void> {
        return this.betaAppClipInvocationLocalizationsDeleteInstanceWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param betaAppClipInvocationLocalizationUpdateRequest BetaAppClipInvocationLocalization representation
     */
    public betaAppClipInvocationLocalizationsUpdateInstanceWithHttpInfo(id: string, betaAppClipInvocationLocalizationUpdateRequest: BetaAppClipInvocationLocalizationUpdateRequest, _options?: Configuration): Observable<HttpInfo<BetaAppClipInvocationLocalizationResponse>> {
        const requestContextPromise = this.requestFactory.betaAppClipInvocationLocalizationsUpdateInstance(id, betaAppClipInvocationLocalizationUpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.betaAppClipInvocationLocalizationsUpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param betaAppClipInvocationLocalizationUpdateRequest BetaAppClipInvocationLocalization representation
     */
    public betaAppClipInvocationLocalizationsUpdateInstance(id: string, betaAppClipInvocationLocalizationUpdateRequest: BetaAppClipInvocationLocalizationUpdateRequest, _options?: Configuration): Observable<BetaAppClipInvocationLocalizationResponse> {
        return this.betaAppClipInvocationLocalizationsUpdateInstanceWithHttpInfo(id, betaAppClipInvocationLocalizationUpdateRequest, _options).pipe(map((apiResponse: HttpInfo<BetaAppClipInvocationLocalizationResponse>) => apiResponse.data));
    }

}

import { BetaAppClipInvocationsApiRequestFactory, BetaAppClipInvocationsApiResponseProcessor} from "../apis/BetaAppClipInvocationsApi.ts";
export class ObservableBetaAppClipInvocationsApi {
    private requestFactory: BetaAppClipInvocationsApiRequestFactory;
    private responseProcessor: BetaAppClipInvocationsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: BetaAppClipInvocationsApiRequestFactory,
        responseProcessor?: BetaAppClipInvocationsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new BetaAppClipInvocationsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new BetaAppClipInvocationsApiResponseProcessor();
    }

    /**
     * @param betaAppClipInvocationCreateRequest BetaAppClipInvocation representation
     */
    public betaAppClipInvocationsCreateInstanceWithHttpInfo(betaAppClipInvocationCreateRequest: BetaAppClipInvocationCreateRequest, _options?: Configuration): Observable<HttpInfo<BetaAppClipInvocationResponse>> {
        const requestContextPromise = this.requestFactory.betaAppClipInvocationsCreateInstance(betaAppClipInvocationCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.betaAppClipInvocationsCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param betaAppClipInvocationCreateRequest BetaAppClipInvocation representation
     */
    public betaAppClipInvocationsCreateInstance(betaAppClipInvocationCreateRequest: BetaAppClipInvocationCreateRequest, _options?: Configuration): Observable<BetaAppClipInvocationResponse> {
        return this.betaAppClipInvocationsCreateInstanceWithHttpInfo(betaAppClipInvocationCreateRequest, _options).pipe(map((apiResponse: HttpInfo<BetaAppClipInvocationResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public betaAppClipInvocationsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.betaAppClipInvocationsDeleteInstance(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.betaAppClipInvocationsDeleteInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public betaAppClipInvocationsDeleteInstance(id: string, _options?: Configuration): Observable<void> {
        return this.betaAppClipInvocationsDeleteInstanceWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBetaAppClipInvocations the fields to include for returned resources of type betaAppClipInvocations
     * @param include comma-separated list of relationships to include
     * @param limitBetaAppClipInvocationLocalizations maximum number of related betaAppClipInvocationLocalizations returned (when they are included)
     */
    public betaAppClipInvocationsGetInstanceWithHttpInfo(id: string, fieldsBetaAppClipInvocations?: Array<'betaAppClipInvocationLocalizations' | 'buildBundle' | 'url'>, include?: Array<'betaAppClipInvocationLocalizations'>, limitBetaAppClipInvocationLocalizations?: number, _options?: Configuration): Observable<HttpInfo<BetaAppClipInvocationResponse>> {
        const requestContextPromise = this.requestFactory.betaAppClipInvocationsGetInstance(id, fieldsBetaAppClipInvocations, include, limitBetaAppClipInvocationLocalizations, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.betaAppClipInvocationsGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBetaAppClipInvocations the fields to include for returned resources of type betaAppClipInvocations
     * @param include comma-separated list of relationships to include
     * @param limitBetaAppClipInvocationLocalizations maximum number of related betaAppClipInvocationLocalizations returned (when they are included)
     */
    public betaAppClipInvocationsGetInstance(id: string, fieldsBetaAppClipInvocations?: Array<'betaAppClipInvocationLocalizations' | 'buildBundle' | 'url'>, include?: Array<'betaAppClipInvocationLocalizations'>, limitBetaAppClipInvocationLocalizations?: number, _options?: Configuration): Observable<BetaAppClipInvocationResponse> {
        return this.betaAppClipInvocationsGetInstanceWithHttpInfo(id, fieldsBetaAppClipInvocations, include, limitBetaAppClipInvocationLocalizations, _options).pipe(map((apiResponse: HttpInfo<BetaAppClipInvocationResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param betaAppClipInvocationUpdateRequest BetaAppClipInvocation representation
     */
    public betaAppClipInvocationsUpdateInstanceWithHttpInfo(id: string, betaAppClipInvocationUpdateRequest: BetaAppClipInvocationUpdateRequest, _options?: Configuration): Observable<HttpInfo<BetaAppClipInvocationResponse>> {
        const requestContextPromise = this.requestFactory.betaAppClipInvocationsUpdateInstance(id, betaAppClipInvocationUpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.betaAppClipInvocationsUpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param betaAppClipInvocationUpdateRequest BetaAppClipInvocation representation
     */
    public betaAppClipInvocationsUpdateInstance(id: string, betaAppClipInvocationUpdateRequest: BetaAppClipInvocationUpdateRequest, _options?: Configuration): Observable<BetaAppClipInvocationResponse> {
        return this.betaAppClipInvocationsUpdateInstanceWithHttpInfo(id, betaAppClipInvocationUpdateRequest, _options).pipe(map((apiResponse: HttpInfo<BetaAppClipInvocationResponse>) => apiResponse.data));
    }

}

import { BetaAppLocalizationsApiRequestFactory, BetaAppLocalizationsApiResponseProcessor} from "../apis/BetaAppLocalizationsApi.ts";
export class ObservableBetaAppLocalizationsApi {
    private requestFactory: BetaAppLocalizationsApiRequestFactory;
    private responseProcessor: BetaAppLocalizationsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: BetaAppLocalizationsApiRequestFactory,
        responseProcessor?: BetaAppLocalizationsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new BetaAppLocalizationsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new BetaAppLocalizationsApiResponseProcessor();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsApps the fields to include for returned resources of type apps
     */
    public betaAppLocalizationsAppGetToOneRelatedWithHttpInfo(id: string, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, _options?: Configuration): Observable<HttpInfo<AppWithoutIncludesResponse>> {
        const requestContextPromise = this.requestFactory.betaAppLocalizationsAppGetToOneRelated(id, fieldsApps, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.betaAppLocalizationsAppGetToOneRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsApps the fields to include for returned resources of type apps
     */
    public betaAppLocalizationsAppGetToOneRelated(id: string, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, _options?: Configuration): Observable<AppWithoutIncludesResponse> {
        return this.betaAppLocalizationsAppGetToOneRelatedWithHttpInfo(id, fieldsApps, _options).pipe(map((apiResponse: HttpInfo<AppWithoutIncludesResponse>) => apiResponse.data));
    }

    /**
     * @param betaAppLocalizationCreateRequest BetaAppLocalization representation
     */
    public betaAppLocalizationsCreateInstanceWithHttpInfo(betaAppLocalizationCreateRequest: BetaAppLocalizationCreateRequest, _options?: Configuration): Observable<HttpInfo<BetaAppLocalizationResponse>> {
        const requestContextPromise = this.requestFactory.betaAppLocalizationsCreateInstance(betaAppLocalizationCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.betaAppLocalizationsCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param betaAppLocalizationCreateRequest BetaAppLocalization representation
     */
    public betaAppLocalizationsCreateInstance(betaAppLocalizationCreateRequest: BetaAppLocalizationCreateRequest, _options?: Configuration): Observable<BetaAppLocalizationResponse> {
        return this.betaAppLocalizationsCreateInstanceWithHttpInfo(betaAppLocalizationCreateRequest, _options).pipe(map((apiResponse: HttpInfo<BetaAppLocalizationResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public betaAppLocalizationsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.betaAppLocalizationsDeleteInstance(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.betaAppLocalizationsDeleteInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public betaAppLocalizationsDeleteInstance(id: string, _options?: Configuration): Observable<void> {
        return this.betaAppLocalizationsDeleteInstanceWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param filterLocale filter by attribute \&#39;locale\&#39;
     * @param filterApp filter by id(s) of related \&#39;app\&#39;
     * @param fieldsBetaAppLocalizations the fields to include for returned resources of type betaAppLocalizations
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsApps the fields to include for returned resources of type apps
     */
    public betaAppLocalizationsGetCollectionWithHttpInfo(filterLocale?: Array<string>, filterApp?: Array<string>, fieldsBetaAppLocalizations?: Array<'app' | 'description' | 'feedbackEmail' | 'locale' | 'marketingUrl' | 'privacyPolicyUrl' | 'tvOsPrivacyPolicy'>, limit?: number, include?: Array<'app'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, _options?: Configuration): Observable<HttpInfo<BetaAppLocalizationsResponse>> {
        const requestContextPromise = this.requestFactory.betaAppLocalizationsGetCollection(filterLocale, filterApp, fieldsBetaAppLocalizations, limit, include, fieldsApps, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.betaAppLocalizationsGetCollectionWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param filterLocale filter by attribute \&#39;locale\&#39;
     * @param filterApp filter by id(s) of related \&#39;app\&#39;
     * @param fieldsBetaAppLocalizations the fields to include for returned resources of type betaAppLocalizations
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsApps the fields to include for returned resources of type apps
     */
    public betaAppLocalizationsGetCollection(filterLocale?: Array<string>, filterApp?: Array<string>, fieldsBetaAppLocalizations?: Array<'app' | 'description' | 'feedbackEmail' | 'locale' | 'marketingUrl' | 'privacyPolicyUrl' | 'tvOsPrivacyPolicy'>, limit?: number, include?: Array<'app'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, _options?: Configuration): Observable<BetaAppLocalizationsResponse> {
        return this.betaAppLocalizationsGetCollectionWithHttpInfo(filterLocale, filterApp, fieldsBetaAppLocalizations, limit, include, fieldsApps, _options).pipe(map((apiResponse: HttpInfo<BetaAppLocalizationsResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBetaAppLocalizations the fields to include for returned resources of type betaAppLocalizations
     * @param include comma-separated list of relationships to include
     * @param fieldsApps the fields to include for returned resources of type apps
     */
    public betaAppLocalizationsGetInstanceWithHttpInfo(id: string, fieldsBetaAppLocalizations?: Array<'app' | 'description' | 'feedbackEmail' | 'locale' | 'marketingUrl' | 'privacyPolicyUrl' | 'tvOsPrivacyPolicy'>, include?: Array<'app'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, _options?: Configuration): Observable<HttpInfo<BetaAppLocalizationResponse>> {
        const requestContextPromise = this.requestFactory.betaAppLocalizationsGetInstance(id, fieldsBetaAppLocalizations, include, fieldsApps, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.betaAppLocalizationsGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBetaAppLocalizations the fields to include for returned resources of type betaAppLocalizations
     * @param include comma-separated list of relationships to include
     * @param fieldsApps the fields to include for returned resources of type apps
     */
    public betaAppLocalizationsGetInstance(id: string, fieldsBetaAppLocalizations?: Array<'app' | 'description' | 'feedbackEmail' | 'locale' | 'marketingUrl' | 'privacyPolicyUrl' | 'tvOsPrivacyPolicy'>, include?: Array<'app'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, _options?: Configuration): Observable<BetaAppLocalizationResponse> {
        return this.betaAppLocalizationsGetInstanceWithHttpInfo(id, fieldsBetaAppLocalizations, include, fieldsApps, _options).pipe(map((apiResponse: HttpInfo<BetaAppLocalizationResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param betaAppLocalizationUpdateRequest BetaAppLocalization representation
     */
    public betaAppLocalizationsUpdateInstanceWithHttpInfo(id: string, betaAppLocalizationUpdateRequest: BetaAppLocalizationUpdateRequest, _options?: Configuration): Observable<HttpInfo<BetaAppLocalizationResponse>> {
        const requestContextPromise = this.requestFactory.betaAppLocalizationsUpdateInstance(id, betaAppLocalizationUpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.betaAppLocalizationsUpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param betaAppLocalizationUpdateRequest BetaAppLocalization representation
     */
    public betaAppLocalizationsUpdateInstance(id: string, betaAppLocalizationUpdateRequest: BetaAppLocalizationUpdateRequest, _options?: Configuration): Observable<BetaAppLocalizationResponse> {
        return this.betaAppLocalizationsUpdateInstanceWithHttpInfo(id, betaAppLocalizationUpdateRequest, _options).pipe(map((apiResponse: HttpInfo<BetaAppLocalizationResponse>) => apiResponse.data));
    }

}

import { BetaAppReviewDetailsApiRequestFactory, BetaAppReviewDetailsApiResponseProcessor} from "../apis/BetaAppReviewDetailsApi.ts";
export class ObservableBetaAppReviewDetailsApi {
    private requestFactory: BetaAppReviewDetailsApiRequestFactory;
    private responseProcessor: BetaAppReviewDetailsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: BetaAppReviewDetailsApiRequestFactory,
        responseProcessor?: BetaAppReviewDetailsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new BetaAppReviewDetailsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new BetaAppReviewDetailsApiResponseProcessor();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsApps the fields to include for returned resources of type apps
     */
    public betaAppReviewDetailsAppGetToOneRelatedWithHttpInfo(id: string, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, _options?: Configuration): Observable<HttpInfo<AppWithoutIncludesResponse>> {
        const requestContextPromise = this.requestFactory.betaAppReviewDetailsAppGetToOneRelated(id, fieldsApps, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.betaAppReviewDetailsAppGetToOneRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsApps the fields to include for returned resources of type apps
     */
    public betaAppReviewDetailsAppGetToOneRelated(id: string, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, _options?: Configuration): Observable<AppWithoutIncludesResponse> {
        return this.betaAppReviewDetailsAppGetToOneRelatedWithHttpInfo(id, fieldsApps, _options).pipe(map((apiResponse: HttpInfo<AppWithoutIncludesResponse>) => apiResponse.data));
    }

    /**
     * @param filterApp filter by id(s) of related \&#39;app\&#39;
     * @param fieldsBetaAppReviewDetails the fields to include for returned resources of type betaAppReviewDetails
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsApps the fields to include for returned resources of type apps
     */
    public betaAppReviewDetailsGetCollectionWithHttpInfo(filterApp: Array<string>, fieldsBetaAppReviewDetails?: Array<'app' | 'contactEmail' | 'contactFirstName' | 'contactLastName' | 'contactPhone' | 'demoAccountName' | 'demoAccountPassword' | 'demoAccountRequired' | 'notes'>, limit?: number, include?: Array<'app'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, _options?: Configuration): Observable<HttpInfo<BetaAppReviewDetailsResponse>> {
        const requestContextPromise = this.requestFactory.betaAppReviewDetailsGetCollection(filterApp, fieldsBetaAppReviewDetails, limit, include, fieldsApps, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.betaAppReviewDetailsGetCollectionWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param filterApp filter by id(s) of related \&#39;app\&#39;
     * @param fieldsBetaAppReviewDetails the fields to include for returned resources of type betaAppReviewDetails
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsApps the fields to include for returned resources of type apps
     */
    public betaAppReviewDetailsGetCollection(filterApp: Array<string>, fieldsBetaAppReviewDetails?: Array<'app' | 'contactEmail' | 'contactFirstName' | 'contactLastName' | 'contactPhone' | 'demoAccountName' | 'demoAccountPassword' | 'demoAccountRequired' | 'notes'>, limit?: number, include?: Array<'app'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, _options?: Configuration): Observable<BetaAppReviewDetailsResponse> {
        return this.betaAppReviewDetailsGetCollectionWithHttpInfo(filterApp, fieldsBetaAppReviewDetails, limit, include, fieldsApps, _options).pipe(map((apiResponse: HttpInfo<BetaAppReviewDetailsResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBetaAppReviewDetails the fields to include for returned resources of type betaAppReviewDetails
     * @param include comma-separated list of relationships to include
     * @param fieldsApps the fields to include for returned resources of type apps
     */
    public betaAppReviewDetailsGetInstanceWithHttpInfo(id: string, fieldsBetaAppReviewDetails?: Array<'app' | 'contactEmail' | 'contactFirstName' | 'contactLastName' | 'contactPhone' | 'demoAccountName' | 'demoAccountPassword' | 'demoAccountRequired' | 'notes'>, include?: Array<'app'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, _options?: Configuration): Observable<HttpInfo<BetaAppReviewDetailResponse>> {
        const requestContextPromise = this.requestFactory.betaAppReviewDetailsGetInstance(id, fieldsBetaAppReviewDetails, include, fieldsApps, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.betaAppReviewDetailsGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBetaAppReviewDetails the fields to include for returned resources of type betaAppReviewDetails
     * @param include comma-separated list of relationships to include
     * @param fieldsApps the fields to include for returned resources of type apps
     */
    public betaAppReviewDetailsGetInstance(id: string, fieldsBetaAppReviewDetails?: Array<'app' | 'contactEmail' | 'contactFirstName' | 'contactLastName' | 'contactPhone' | 'demoAccountName' | 'demoAccountPassword' | 'demoAccountRequired' | 'notes'>, include?: Array<'app'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, _options?: Configuration): Observable<BetaAppReviewDetailResponse> {
        return this.betaAppReviewDetailsGetInstanceWithHttpInfo(id, fieldsBetaAppReviewDetails, include, fieldsApps, _options).pipe(map((apiResponse: HttpInfo<BetaAppReviewDetailResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param betaAppReviewDetailUpdateRequest BetaAppReviewDetail representation
     */
    public betaAppReviewDetailsUpdateInstanceWithHttpInfo(id: string, betaAppReviewDetailUpdateRequest: BetaAppReviewDetailUpdateRequest, _options?: Configuration): Observable<HttpInfo<BetaAppReviewDetailResponse>> {
        const requestContextPromise = this.requestFactory.betaAppReviewDetailsUpdateInstance(id, betaAppReviewDetailUpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.betaAppReviewDetailsUpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param betaAppReviewDetailUpdateRequest BetaAppReviewDetail representation
     */
    public betaAppReviewDetailsUpdateInstance(id: string, betaAppReviewDetailUpdateRequest: BetaAppReviewDetailUpdateRequest, _options?: Configuration): Observable<BetaAppReviewDetailResponse> {
        return this.betaAppReviewDetailsUpdateInstanceWithHttpInfo(id, betaAppReviewDetailUpdateRequest, _options).pipe(map((apiResponse: HttpInfo<BetaAppReviewDetailResponse>) => apiResponse.data));
    }

}

import { BetaAppReviewSubmissionsApiRequestFactory, BetaAppReviewSubmissionsApiResponseProcessor} from "../apis/BetaAppReviewSubmissionsApi.ts";
export class ObservableBetaAppReviewSubmissionsApi {
    private requestFactory: BetaAppReviewSubmissionsApiRequestFactory;
    private responseProcessor: BetaAppReviewSubmissionsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: BetaAppReviewSubmissionsApiRequestFactory,
        responseProcessor?: BetaAppReviewSubmissionsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new BetaAppReviewSubmissionsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new BetaAppReviewSubmissionsApiResponseProcessor();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBuilds the fields to include for returned resources of type builds
     */
    public betaAppReviewSubmissionsBuildGetToOneRelatedWithHttpInfo(id: string, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, _options?: Configuration): Observable<HttpInfo<BuildWithoutIncludesResponse>> {
        const requestContextPromise = this.requestFactory.betaAppReviewSubmissionsBuildGetToOneRelated(id, fieldsBuilds, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.betaAppReviewSubmissionsBuildGetToOneRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBuilds the fields to include for returned resources of type builds
     */
    public betaAppReviewSubmissionsBuildGetToOneRelated(id: string, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, _options?: Configuration): Observable<BuildWithoutIncludesResponse> {
        return this.betaAppReviewSubmissionsBuildGetToOneRelatedWithHttpInfo(id, fieldsBuilds, _options).pipe(map((apiResponse: HttpInfo<BuildWithoutIncludesResponse>) => apiResponse.data));
    }

    /**
     * @param betaAppReviewSubmissionCreateRequest BetaAppReviewSubmission representation
     */
    public betaAppReviewSubmissionsCreateInstanceWithHttpInfo(betaAppReviewSubmissionCreateRequest: BetaAppReviewSubmissionCreateRequest, _options?: Configuration): Observable<HttpInfo<BetaAppReviewSubmissionResponse>> {
        const requestContextPromise = this.requestFactory.betaAppReviewSubmissionsCreateInstance(betaAppReviewSubmissionCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.betaAppReviewSubmissionsCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param betaAppReviewSubmissionCreateRequest BetaAppReviewSubmission representation
     */
    public betaAppReviewSubmissionsCreateInstance(betaAppReviewSubmissionCreateRequest: BetaAppReviewSubmissionCreateRequest, _options?: Configuration): Observable<BetaAppReviewSubmissionResponse> {
        return this.betaAppReviewSubmissionsCreateInstanceWithHttpInfo(betaAppReviewSubmissionCreateRequest, _options).pipe(map((apiResponse: HttpInfo<BetaAppReviewSubmissionResponse>) => apiResponse.data));
    }

    /**
     * @param filterBuild filter by id(s) of related \&#39;build\&#39;
     * @param filterBetaReviewState filter by attribute \&#39;betaReviewState\&#39;
     * @param fieldsBetaAppReviewSubmissions the fields to include for returned resources of type betaAppReviewSubmissions
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsBuilds the fields to include for returned resources of type builds
     */
    public betaAppReviewSubmissionsGetCollectionWithHttpInfo(filterBuild: Array<string>, filterBetaReviewState?: Array<'WAITING_FOR_REVIEW' | 'IN_REVIEW' | 'REJECTED' | 'APPROVED'>, fieldsBetaAppReviewSubmissions?: Array<'betaReviewState' | 'build' | 'submittedDate'>, limit?: number, include?: Array<'build'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, _options?: Configuration): Observable<HttpInfo<BetaAppReviewSubmissionsResponse>> {
        const requestContextPromise = this.requestFactory.betaAppReviewSubmissionsGetCollection(filterBuild, filterBetaReviewState, fieldsBetaAppReviewSubmissions, limit, include, fieldsBuilds, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.betaAppReviewSubmissionsGetCollectionWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param filterBuild filter by id(s) of related \&#39;build\&#39;
     * @param filterBetaReviewState filter by attribute \&#39;betaReviewState\&#39;
     * @param fieldsBetaAppReviewSubmissions the fields to include for returned resources of type betaAppReviewSubmissions
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsBuilds the fields to include for returned resources of type builds
     */
    public betaAppReviewSubmissionsGetCollection(filterBuild: Array<string>, filterBetaReviewState?: Array<'WAITING_FOR_REVIEW' | 'IN_REVIEW' | 'REJECTED' | 'APPROVED'>, fieldsBetaAppReviewSubmissions?: Array<'betaReviewState' | 'build' | 'submittedDate'>, limit?: number, include?: Array<'build'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, _options?: Configuration): Observable<BetaAppReviewSubmissionsResponse> {
        return this.betaAppReviewSubmissionsGetCollectionWithHttpInfo(filterBuild, filterBetaReviewState, fieldsBetaAppReviewSubmissions, limit, include, fieldsBuilds, _options).pipe(map((apiResponse: HttpInfo<BetaAppReviewSubmissionsResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBetaAppReviewSubmissions the fields to include for returned resources of type betaAppReviewSubmissions
     * @param include comma-separated list of relationships to include
     * @param fieldsBuilds the fields to include for returned resources of type builds
     */
    public betaAppReviewSubmissionsGetInstanceWithHttpInfo(id: string, fieldsBetaAppReviewSubmissions?: Array<'betaReviewState' | 'build' | 'submittedDate'>, include?: Array<'build'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, _options?: Configuration): Observable<HttpInfo<BetaAppReviewSubmissionResponse>> {
        const requestContextPromise = this.requestFactory.betaAppReviewSubmissionsGetInstance(id, fieldsBetaAppReviewSubmissions, include, fieldsBuilds, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.betaAppReviewSubmissionsGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBetaAppReviewSubmissions the fields to include for returned resources of type betaAppReviewSubmissions
     * @param include comma-separated list of relationships to include
     * @param fieldsBuilds the fields to include for returned resources of type builds
     */
    public betaAppReviewSubmissionsGetInstance(id: string, fieldsBetaAppReviewSubmissions?: Array<'betaReviewState' | 'build' | 'submittedDate'>, include?: Array<'build'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, _options?: Configuration): Observable<BetaAppReviewSubmissionResponse> {
        return this.betaAppReviewSubmissionsGetInstanceWithHttpInfo(id, fieldsBetaAppReviewSubmissions, include, fieldsBuilds, _options).pipe(map((apiResponse: HttpInfo<BetaAppReviewSubmissionResponse>) => apiResponse.data));
    }

}

import { BetaBuildLocalizationsApiRequestFactory, BetaBuildLocalizationsApiResponseProcessor} from "../apis/BetaBuildLocalizationsApi.ts";
export class ObservableBetaBuildLocalizationsApi {
    private requestFactory: BetaBuildLocalizationsApiRequestFactory;
    private responseProcessor: BetaBuildLocalizationsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: BetaBuildLocalizationsApiRequestFactory,
        responseProcessor?: BetaBuildLocalizationsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new BetaBuildLocalizationsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new BetaBuildLocalizationsApiResponseProcessor();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBuilds the fields to include for returned resources of type builds
     */
    public betaBuildLocalizationsBuildGetToOneRelatedWithHttpInfo(id: string, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, _options?: Configuration): Observable<HttpInfo<BuildWithoutIncludesResponse>> {
        const requestContextPromise = this.requestFactory.betaBuildLocalizationsBuildGetToOneRelated(id, fieldsBuilds, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.betaBuildLocalizationsBuildGetToOneRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBuilds the fields to include for returned resources of type builds
     */
    public betaBuildLocalizationsBuildGetToOneRelated(id: string, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, _options?: Configuration): Observable<BuildWithoutIncludesResponse> {
        return this.betaBuildLocalizationsBuildGetToOneRelatedWithHttpInfo(id, fieldsBuilds, _options).pipe(map((apiResponse: HttpInfo<BuildWithoutIncludesResponse>) => apiResponse.data));
    }

    /**
     * @param betaBuildLocalizationCreateRequest BetaBuildLocalization representation
     */
    public betaBuildLocalizationsCreateInstanceWithHttpInfo(betaBuildLocalizationCreateRequest: BetaBuildLocalizationCreateRequest, _options?: Configuration): Observable<HttpInfo<BetaBuildLocalizationResponse>> {
        const requestContextPromise = this.requestFactory.betaBuildLocalizationsCreateInstance(betaBuildLocalizationCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.betaBuildLocalizationsCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param betaBuildLocalizationCreateRequest BetaBuildLocalization representation
     */
    public betaBuildLocalizationsCreateInstance(betaBuildLocalizationCreateRequest: BetaBuildLocalizationCreateRequest, _options?: Configuration): Observable<BetaBuildLocalizationResponse> {
        return this.betaBuildLocalizationsCreateInstanceWithHttpInfo(betaBuildLocalizationCreateRequest, _options).pipe(map((apiResponse: HttpInfo<BetaBuildLocalizationResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public betaBuildLocalizationsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.betaBuildLocalizationsDeleteInstance(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.betaBuildLocalizationsDeleteInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public betaBuildLocalizationsDeleteInstance(id: string, _options?: Configuration): Observable<void> {
        return this.betaBuildLocalizationsDeleteInstanceWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param filterLocale filter by attribute \&#39;locale\&#39;
     * @param filterBuild filter by id(s) of related \&#39;build\&#39;
     * @param fieldsBetaBuildLocalizations the fields to include for returned resources of type betaBuildLocalizations
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsBuilds the fields to include for returned resources of type builds
     */
    public betaBuildLocalizationsGetCollectionWithHttpInfo(filterLocale?: Array<string>, filterBuild?: Array<string>, fieldsBetaBuildLocalizations?: Array<'build' | 'locale' | 'whatsNew'>, limit?: number, include?: Array<'build'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, _options?: Configuration): Observable<HttpInfo<BetaBuildLocalizationsResponse>> {
        const requestContextPromise = this.requestFactory.betaBuildLocalizationsGetCollection(filterLocale, filterBuild, fieldsBetaBuildLocalizations, limit, include, fieldsBuilds, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.betaBuildLocalizationsGetCollectionWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param filterLocale filter by attribute \&#39;locale\&#39;
     * @param filterBuild filter by id(s) of related \&#39;build\&#39;
     * @param fieldsBetaBuildLocalizations the fields to include for returned resources of type betaBuildLocalizations
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsBuilds the fields to include for returned resources of type builds
     */
    public betaBuildLocalizationsGetCollection(filterLocale?: Array<string>, filterBuild?: Array<string>, fieldsBetaBuildLocalizations?: Array<'build' | 'locale' | 'whatsNew'>, limit?: number, include?: Array<'build'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, _options?: Configuration): Observable<BetaBuildLocalizationsResponse> {
        return this.betaBuildLocalizationsGetCollectionWithHttpInfo(filterLocale, filterBuild, fieldsBetaBuildLocalizations, limit, include, fieldsBuilds, _options).pipe(map((apiResponse: HttpInfo<BetaBuildLocalizationsResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBetaBuildLocalizations the fields to include for returned resources of type betaBuildLocalizations
     * @param include comma-separated list of relationships to include
     * @param fieldsBuilds the fields to include for returned resources of type builds
     */
    public betaBuildLocalizationsGetInstanceWithHttpInfo(id: string, fieldsBetaBuildLocalizations?: Array<'build' | 'locale' | 'whatsNew'>, include?: Array<'build'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, _options?: Configuration): Observable<HttpInfo<BetaBuildLocalizationResponse>> {
        const requestContextPromise = this.requestFactory.betaBuildLocalizationsGetInstance(id, fieldsBetaBuildLocalizations, include, fieldsBuilds, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.betaBuildLocalizationsGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBetaBuildLocalizations the fields to include for returned resources of type betaBuildLocalizations
     * @param include comma-separated list of relationships to include
     * @param fieldsBuilds the fields to include for returned resources of type builds
     */
    public betaBuildLocalizationsGetInstance(id: string, fieldsBetaBuildLocalizations?: Array<'build' | 'locale' | 'whatsNew'>, include?: Array<'build'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, _options?: Configuration): Observable<BetaBuildLocalizationResponse> {
        return this.betaBuildLocalizationsGetInstanceWithHttpInfo(id, fieldsBetaBuildLocalizations, include, fieldsBuilds, _options).pipe(map((apiResponse: HttpInfo<BetaBuildLocalizationResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param betaBuildLocalizationUpdateRequest BetaBuildLocalization representation
     */
    public betaBuildLocalizationsUpdateInstanceWithHttpInfo(id: string, betaBuildLocalizationUpdateRequest: BetaBuildLocalizationUpdateRequest, _options?: Configuration): Observable<HttpInfo<BetaBuildLocalizationResponse>> {
        const requestContextPromise = this.requestFactory.betaBuildLocalizationsUpdateInstance(id, betaBuildLocalizationUpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.betaBuildLocalizationsUpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param betaBuildLocalizationUpdateRequest BetaBuildLocalization representation
     */
    public betaBuildLocalizationsUpdateInstance(id: string, betaBuildLocalizationUpdateRequest: BetaBuildLocalizationUpdateRequest, _options?: Configuration): Observable<BetaBuildLocalizationResponse> {
        return this.betaBuildLocalizationsUpdateInstanceWithHttpInfo(id, betaBuildLocalizationUpdateRequest, _options).pipe(map((apiResponse: HttpInfo<BetaBuildLocalizationResponse>) => apiResponse.data));
    }

}

import { BetaGroupsApiRequestFactory, BetaGroupsApiResponseProcessor} from "../apis/BetaGroupsApi.ts";
export class ObservableBetaGroupsApi {
    private requestFactory: BetaGroupsApiRequestFactory;
    private responseProcessor: BetaGroupsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: BetaGroupsApiRequestFactory,
        responseProcessor?: BetaGroupsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new BetaGroupsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new BetaGroupsApiResponseProcessor();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsApps the fields to include for returned resources of type apps
     */
    public betaGroupsAppGetToOneRelatedWithHttpInfo(id: string, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, _options?: Configuration): Observable<HttpInfo<AppWithoutIncludesResponse>> {
        const requestContextPromise = this.requestFactory.betaGroupsAppGetToOneRelated(id, fieldsApps, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.betaGroupsAppGetToOneRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsApps the fields to include for returned resources of type apps
     */
    public betaGroupsAppGetToOneRelated(id: string, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, _options?: Configuration): Observable<AppWithoutIncludesResponse> {
        return this.betaGroupsAppGetToOneRelatedWithHttpInfo(id, fieldsApps, _options).pipe(map((apiResponse: HttpInfo<AppWithoutIncludesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum number of groups to return per page
     * @param groupBy the dimension by which to group the results
     * @param filterBetaTesters filter by \&#39;betaTesters\&#39; relationship dimension
     * @param period the duration of the reporting period
     */
    public betaGroupsBetaTesterUsagesGetMetricsWithHttpInfo(id: string, limit?: number, groupBy?: Array<'betaTesters'>, filterBetaTesters?: string, period?: 'P7D' | 'P30D' | 'P90D' | 'P365D', _options?: Configuration): Observable<HttpInfo<AppsBetaTesterUsagesV1MetricResponse>> {
        const requestContextPromise = this.requestFactory.betaGroupsBetaTesterUsagesGetMetrics(id, limit, groupBy, filterBetaTesters, period, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.betaGroupsBetaTesterUsagesGetMetricsWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum number of groups to return per page
     * @param groupBy the dimension by which to group the results
     * @param filterBetaTesters filter by \&#39;betaTesters\&#39; relationship dimension
     * @param period the duration of the reporting period
     */
    public betaGroupsBetaTesterUsagesGetMetrics(id: string, limit?: number, groupBy?: Array<'betaTesters'>, filterBetaTesters?: string, period?: 'P7D' | 'P30D' | 'P90D' | 'P365D', _options?: Configuration): Observable<AppsBetaTesterUsagesV1MetricResponse> {
        return this.betaGroupsBetaTesterUsagesGetMetricsWithHttpInfo(id, limit, groupBy, filterBetaTesters, period, _options).pipe(map((apiResponse: HttpInfo<AppsBetaTesterUsagesV1MetricResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param betaGroupBetaTestersLinkagesRequest List of related linkages
     */
    public betaGroupsBetaTestersCreateToManyRelationshipWithHttpInfo(id: string, betaGroupBetaTestersLinkagesRequest: BetaGroupBetaTestersLinkagesRequest, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.betaGroupsBetaTestersCreateToManyRelationship(id, betaGroupBetaTestersLinkagesRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.betaGroupsBetaTestersCreateToManyRelationshipWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param betaGroupBetaTestersLinkagesRequest List of related linkages
     */
    public betaGroupsBetaTestersCreateToManyRelationship(id: string, betaGroupBetaTestersLinkagesRequest: BetaGroupBetaTestersLinkagesRequest, _options?: Configuration): Observable<void> {
        return this.betaGroupsBetaTestersCreateToManyRelationshipWithHttpInfo(id, betaGroupBetaTestersLinkagesRequest, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param betaGroupBetaTestersLinkagesRequest List of related linkages
     */
    public betaGroupsBetaTestersDeleteToManyRelationshipWithHttpInfo(id: string, betaGroupBetaTestersLinkagesRequest: BetaGroupBetaTestersLinkagesRequest, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.betaGroupsBetaTestersDeleteToManyRelationship(id, betaGroupBetaTestersLinkagesRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.betaGroupsBetaTestersDeleteToManyRelationshipWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param betaGroupBetaTestersLinkagesRequest List of related linkages
     */
    public betaGroupsBetaTestersDeleteToManyRelationship(id: string, betaGroupBetaTestersLinkagesRequest: BetaGroupBetaTestersLinkagesRequest, _options?: Configuration): Observable<void> {
        return this.betaGroupsBetaTestersDeleteToManyRelationshipWithHttpInfo(id, betaGroupBetaTestersLinkagesRequest, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBetaTesters the fields to include for returned resources of type betaTesters
     * @param limit maximum resources per page
     */
    public betaGroupsBetaTestersGetToManyRelatedWithHttpInfo(id: string, fieldsBetaTesters?: Array<'apps' | 'betaGroups' | 'builds' | 'email' | 'firstName' | 'inviteType' | 'lastName'>, limit?: number, _options?: Configuration): Observable<HttpInfo<BetaTestersWithoutIncludesResponse>> {
        const requestContextPromise = this.requestFactory.betaGroupsBetaTestersGetToManyRelated(id, fieldsBetaTesters, limit, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.betaGroupsBetaTestersGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBetaTesters the fields to include for returned resources of type betaTesters
     * @param limit maximum resources per page
     */
    public betaGroupsBetaTestersGetToManyRelated(id: string, fieldsBetaTesters?: Array<'apps' | 'betaGroups' | 'builds' | 'email' | 'firstName' | 'inviteType' | 'lastName'>, limit?: number, _options?: Configuration): Observable<BetaTestersWithoutIncludesResponse> {
        return this.betaGroupsBetaTestersGetToManyRelatedWithHttpInfo(id, fieldsBetaTesters, limit, _options).pipe(map((apiResponse: HttpInfo<BetaTestersWithoutIncludesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public betaGroupsBetaTestersGetToManyRelationshipWithHttpInfo(id: string, limit?: number, _options?: Configuration): Observable<HttpInfo<BetaGroupBetaTestersLinkagesResponse>> {
        const requestContextPromise = this.requestFactory.betaGroupsBetaTestersGetToManyRelationship(id, limit, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.betaGroupsBetaTestersGetToManyRelationshipWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public betaGroupsBetaTestersGetToManyRelationship(id: string, limit?: number, _options?: Configuration): Observable<BetaGroupBetaTestersLinkagesResponse> {
        return this.betaGroupsBetaTestersGetToManyRelationshipWithHttpInfo(id, limit, _options).pipe(map((apiResponse: HttpInfo<BetaGroupBetaTestersLinkagesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param betaGroupBuildsLinkagesRequest List of related linkages
     */
    public betaGroupsBuildsCreateToManyRelationshipWithHttpInfo(id: string, betaGroupBuildsLinkagesRequest: BetaGroupBuildsLinkagesRequest, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.betaGroupsBuildsCreateToManyRelationship(id, betaGroupBuildsLinkagesRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.betaGroupsBuildsCreateToManyRelationshipWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param betaGroupBuildsLinkagesRequest List of related linkages
     */
    public betaGroupsBuildsCreateToManyRelationship(id: string, betaGroupBuildsLinkagesRequest: BetaGroupBuildsLinkagesRequest, _options?: Configuration): Observable<void> {
        return this.betaGroupsBuildsCreateToManyRelationshipWithHttpInfo(id, betaGroupBuildsLinkagesRequest, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param betaGroupBuildsLinkagesRequest List of related linkages
     */
    public betaGroupsBuildsDeleteToManyRelationshipWithHttpInfo(id: string, betaGroupBuildsLinkagesRequest: BetaGroupBuildsLinkagesRequest, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.betaGroupsBuildsDeleteToManyRelationship(id, betaGroupBuildsLinkagesRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.betaGroupsBuildsDeleteToManyRelationshipWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param betaGroupBuildsLinkagesRequest List of related linkages
     */
    public betaGroupsBuildsDeleteToManyRelationship(id: string, betaGroupBuildsLinkagesRequest: BetaGroupBuildsLinkagesRequest, _options?: Configuration): Observable<void> {
        return this.betaGroupsBuildsDeleteToManyRelationshipWithHttpInfo(id, betaGroupBuildsLinkagesRequest, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param limit maximum resources per page
     */
    public betaGroupsBuildsGetToManyRelatedWithHttpInfo(id: string, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, limit?: number, _options?: Configuration): Observable<HttpInfo<BuildsWithoutIncludesResponse>> {
        const requestContextPromise = this.requestFactory.betaGroupsBuildsGetToManyRelated(id, fieldsBuilds, limit, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.betaGroupsBuildsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param limit maximum resources per page
     */
    public betaGroupsBuildsGetToManyRelated(id: string, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, limit?: number, _options?: Configuration): Observable<BuildsWithoutIncludesResponse> {
        return this.betaGroupsBuildsGetToManyRelatedWithHttpInfo(id, fieldsBuilds, limit, _options).pipe(map((apiResponse: HttpInfo<BuildsWithoutIncludesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public betaGroupsBuildsGetToManyRelationshipWithHttpInfo(id: string, limit?: number, _options?: Configuration): Observable<HttpInfo<BetaGroupBuildsLinkagesResponse>> {
        const requestContextPromise = this.requestFactory.betaGroupsBuildsGetToManyRelationship(id, limit, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.betaGroupsBuildsGetToManyRelationshipWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public betaGroupsBuildsGetToManyRelationship(id: string, limit?: number, _options?: Configuration): Observable<BetaGroupBuildsLinkagesResponse> {
        return this.betaGroupsBuildsGetToManyRelationshipWithHttpInfo(id, limit, _options).pipe(map((apiResponse: HttpInfo<BetaGroupBuildsLinkagesResponse>) => apiResponse.data));
    }

    /**
     * @param betaGroupCreateRequest BetaGroup representation
     */
    public betaGroupsCreateInstanceWithHttpInfo(betaGroupCreateRequest: BetaGroupCreateRequest, _options?: Configuration): Observable<HttpInfo<BetaGroupResponse>> {
        const requestContextPromise = this.requestFactory.betaGroupsCreateInstance(betaGroupCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.betaGroupsCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param betaGroupCreateRequest BetaGroup representation
     */
    public betaGroupsCreateInstance(betaGroupCreateRequest: BetaGroupCreateRequest, _options?: Configuration): Observable<BetaGroupResponse> {
        return this.betaGroupsCreateInstanceWithHttpInfo(betaGroupCreateRequest, _options).pipe(map((apiResponse: HttpInfo<BetaGroupResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public betaGroupsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.betaGroupsDeleteInstance(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.betaGroupsDeleteInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public betaGroupsDeleteInstance(id: string, _options?: Configuration): Observable<void> {
        return this.betaGroupsDeleteInstanceWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param filterIsInternalGroup filter by attribute \&#39;isInternalGroup\&#39;
     * @param filterName filter by attribute \&#39;name\&#39;
     * @param filterPublicLink filter by attribute \&#39;publicLink\&#39;
     * @param filterPublicLinkEnabled filter by attribute \&#39;publicLinkEnabled\&#39;
     * @param filterPublicLinkLimitEnabled filter by attribute \&#39;publicLinkLimitEnabled\&#39;
     * @param filterApp filter by id(s) of related \&#39;app\&#39;
     * @param filterBuilds filter by id(s) of related \&#39;builds\&#39;
     * @param filterId filter by id(s)
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsBetaGroups the fields to include for returned resources of type betaGroups
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsBetaTesters the fields to include for returned resources of type betaTesters
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param limitBetaTesters maximum number of related betaTesters returned (when they are included)
     * @param limitBuilds maximum number of related builds returned (when they are included)
     */
    public betaGroupsGetCollectionWithHttpInfo(filterIsInternalGroup?: Array<string>, filterName?: Array<string>, filterPublicLink?: Array<string>, filterPublicLinkEnabled?: Array<string>, filterPublicLinkLimitEnabled?: Array<string>, filterApp?: Array<string>, filterBuilds?: Array<string>, filterId?: Array<string>, sort?: Array<'createdDate' | '-createdDate' | 'name' | '-name' | 'publicLinkEnabled' | '-publicLinkEnabled' | 'publicLinkLimit' | '-publicLinkLimit'>, fieldsBetaGroups?: Array<'app' | 'betaTesters' | 'builds' | 'createdDate' | 'feedbackEnabled' | 'hasAccessToAllBuilds' | 'iosBuildsAvailableForAppleSiliconMac' | 'isInternalGroup' | 'name' | 'publicLink' | 'publicLinkEnabled' | 'publicLinkId' | 'publicLinkLimit' | 'publicLinkLimitEnabled'>, limit?: number, include?: Array<'app' | 'betaTesters' | 'builds'>, fieldsBetaTesters?: Array<'apps' | 'betaGroups' | 'builds' | 'email' | 'firstName' | 'inviteType' | 'lastName'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, limitBetaTesters?: number, limitBuilds?: number, _options?: Configuration): Observable<HttpInfo<BetaGroupsResponse>> {
        const requestContextPromise = this.requestFactory.betaGroupsGetCollection(filterIsInternalGroup, filterName, filterPublicLink, filterPublicLinkEnabled, filterPublicLinkLimitEnabled, filterApp, filterBuilds, filterId, sort, fieldsBetaGroups, limit, include, fieldsBetaTesters, fieldsApps, fieldsBuilds, limitBetaTesters, limitBuilds, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.betaGroupsGetCollectionWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param filterIsInternalGroup filter by attribute \&#39;isInternalGroup\&#39;
     * @param filterName filter by attribute \&#39;name\&#39;
     * @param filterPublicLink filter by attribute \&#39;publicLink\&#39;
     * @param filterPublicLinkEnabled filter by attribute \&#39;publicLinkEnabled\&#39;
     * @param filterPublicLinkLimitEnabled filter by attribute \&#39;publicLinkLimitEnabled\&#39;
     * @param filterApp filter by id(s) of related \&#39;app\&#39;
     * @param filterBuilds filter by id(s) of related \&#39;builds\&#39;
     * @param filterId filter by id(s)
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsBetaGroups the fields to include for returned resources of type betaGroups
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsBetaTesters the fields to include for returned resources of type betaTesters
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param limitBetaTesters maximum number of related betaTesters returned (when they are included)
     * @param limitBuilds maximum number of related builds returned (when they are included)
     */
    public betaGroupsGetCollection(filterIsInternalGroup?: Array<string>, filterName?: Array<string>, filterPublicLink?: Array<string>, filterPublicLinkEnabled?: Array<string>, filterPublicLinkLimitEnabled?: Array<string>, filterApp?: Array<string>, filterBuilds?: Array<string>, filterId?: Array<string>, sort?: Array<'createdDate' | '-createdDate' | 'name' | '-name' | 'publicLinkEnabled' | '-publicLinkEnabled' | 'publicLinkLimit' | '-publicLinkLimit'>, fieldsBetaGroups?: Array<'app' | 'betaTesters' | 'builds' | 'createdDate' | 'feedbackEnabled' | 'hasAccessToAllBuilds' | 'iosBuildsAvailableForAppleSiliconMac' | 'isInternalGroup' | 'name' | 'publicLink' | 'publicLinkEnabled' | 'publicLinkId' | 'publicLinkLimit' | 'publicLinkLimitEnabled'>, limit?: number, include?: Array<'app' | 'betaTesters' | 'builds'>, fieldsBetaTesters?: Array<'apps' | 'betaGroups' | 'builds' | 'email' | 'firstName' | 'inviteType' | 'lastName'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, limitBetaTesters?: number, limitBuilds?: number, _options?: Configuration): Observable<BetaGroupsResponse> {
        return this.betaGroupsGetCollectionWithHttpInfo(filterIsInternalGroup, filterName, filterPublicLink, filterPublicLinkEnabled, filterPublicLinkLimitEnabled, filterApp, filterBuilds, filterId, sort, fieldsBetaGroups, limit, include, fieldsBetaTesters, fieldsApps, fieldsBuilds, limitBetaTesters, limitBuilds, _options).pipe(map((apiResponse: HttpInfo<BetaGroupsResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBetaGroups the fields to include for returned resources of type betaGroups
     * @param include comma-separated list of relationships to include
     * @param fieldsBetaTesters the fields to include for returned resources of type betaTesters
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param limitBetaTesters maximum number of related betaTesters returned (when they are included)
     * @param limitBuilds maximum number of related builds returned (when they are included)
     */
    public betaGroupsGetInstanceWithHttpInfo(id: string, fieldsBetaGroups?: Array<'app' | 'betaTesters' | 'builds' | 'createdDate' | 'feedbackEnabled' | 'hasAccessToAllBuilds' | 'iosBuildsAvailableForAppleSiliconMac' | 'isInternalGroup' | 'name' | 'publicLink' | 'publicLinkEnabled' | 'publicLinkId' | 'publicLinkLimit' | 'publicLinkLimitEnabled'>, include?: Array<'app' | 'betaTesters' | 'builds'>, fieldsBetaTesters?: Array<'apps' | 'betaGroups' | 'builds' | 'email' | 'firstName' | 'inviteType' | 'lastName'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, limitBetaTesters?: number, limitBuilds?: number, _options?: Configuration): Observable<HttpInfo<BetaGroupResponse>> {
        const requestContextPromise = this.requestFactory.betaGroupsGetInstance(id, fieldsBetaGroups, include, fieldsBetaTesters, fieldsApps, fieldsBuilds, limitBetaTesters, limitBuilds, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.betaGroupsGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBetaGroups the fields to include for returned resources of type betaGroups
     * @param include comma-separated list of relationships to include
     * @param fieldsBetaTesters the fields to include for returned resources of type betaTesters
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param limitBetaTesters maximum number of related betaTesters returned (when they are included)
     * @param limitBuilds maximum number of related builds returned (when they are included)
     */
    public betaGroupsGetInstance(id: string, fieldsBetaGroups?: Array<'app' | 'betaTesters' | 'builds' | 'createdDate' | 'feedbackEnabled' | 'hasAccessToAllBuilds' | 'iosBuildsAvailableForAppleSiliconMac' | 'isInternalGroup' | 'name' | 'publicLink' | 'publicLinkEnabled' | 'publicLinkId' | 'publicLinkLimit' | 'publicLinkLimitEnabled'>, include?: Array<'app' | 'betaTesters' | 'builds'>, fieldsBetaTesters?: Array<'apps' | 'betaGroups' | 'builds' | 'email' | 'firstName' | 'inviteType' | 'lastName'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, limitBetaTesters?: number, limitBuilds?: number, _options?: Configuration): Observable<BetaGroupResponse> {
        return this.betaGroupsGetInstanceWithHttpInfo(id, fieldsBetaGroups, include, fieldsBetaTesters, fieldsApps, fieldsBuilds, limitBetaTesters, limitBuilds, _options).pipe(map((apiResponse: HttpInfo<BetaGroupResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param betaGroupUpdateRequest BetaGroup representation
     */
    public betaGroupsUpdateInstanceWithHttpInfo(id: string, betaGroupUpdateRequest: BetaGroupUpdateRequest, _options?: Configuration): Observable<HttpInfo<BetaGroupResponse>> {
        const requestContextPromise = this.requestFactory.betaGroupsUpdateInstance(id, betaGroupUpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.betaGroupsUpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param betaGroupUpdateRequest BetaGroup representation
     */
    public betaGroupsUpdateInstance(id: string, betaGroupUpdateRequest: BetaGroupUpdateRequest, _options?: Configuration): Observable<BetaGroupResponse> {
        return this.betaGroupsUpdateInstanceWithHttpInfo(id, betaGroupUpdateRequest, _options).pipe(map((apiResponse: HttpInfo<BetaGroupResponse>) => apiResponse.data));
    }

}

import { BetaLicenseAgreementsApiRequestFactory, BetaLicenseAgreementsApiResponseProcessor} from "../apis/BetaLicenseAgreementsApi.ts";
export class ObservableBetaLicenseAgreementsApi {
    private requestFactory: BetaLicenseAgreementsApiRequestFactory;
    private responseProcessor: BetaLicenseAgreementsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: BetaLicenseAgreementsApiRequestFactory,
        responseProcessor?: BetaLicenseAgreementsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new BetaLicenseAgreementsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new BetaLicenseAgreementsApiResponseProcessor();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsApps the fields to include for returned resources of type apps
     */
    public betaLicenseAgreementsAppGetToOneRelatedWithHttpInfo(id: string, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, _options?: Configuration): Observable<HttpInfo<AppWithoutIncludesResponse>> {
        const requestContextPromise = this.requestFactory.betaLicenseAgreementsAppGetToOneRelated(id, fieldsApps, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.betaLicenseAgreementsAppGetToOneRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsApps the fields to include for returned resources of type apps
     */
    public betaLicenseAgreementsAppGetToOneRelated(id: string, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, _options?: Configuration): Observable<AppWithoutIncludesResponse> {
        return this.betaLicenseAgreementsAppGetToOneRelatedWithHttpInfo(id, fieldsApps, _options).pipe(map((apiResponse: HttpInfo<AppWithoutIncludesResponse>) => apiResponse.data));
    }

    /**
     * @param filterApp filter by id(s) of related \&#39;app\&#39;
     * @param fieldsBetaLicenseAgreements the fields to include for returned resources of type betaLicenseAgreements
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsApps the fields to include for returned resources of type apps
     */
    public betaLicenseAgreementsGetCollectionWithHttpInfo(filterApp?: Array<string>, fieldsBetaLicenseAgreements?: Array<'agreementText' | 'app'>, limit?: number, include?: Array<'app'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, _options?: Configuration): Observable<HttpInfo<BetaLicenseAgreementsResponse>> {
        const requestContextPromise = this.requestFactory.betaLicenseAgreementsGetCollection(filterApp, fieldsBetaLicenseAgreements, limit, include, fieldsApps, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.betaLicenseAgreementsGetCollectionWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param filterApp filter by id(s) of related \&#39;app\&#39;
     * @param fieldsBetaLicenseAgreements the fields to include for returned resources of type betaLicenseAgreements
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsApps the fields to include for returned resources of type apps
     */
    public betaLicenseAgreementsGetCollection(filterApp?: Array<string>, fieldsBetaLicenseAgreements?: Array<'agreementText' | 'app'>, limit?: number, include?: Array<'app'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, _options?: Configuration): Observable<BetaLicenseAgreementsResponse> {
        return this.betaLicenseAgreementsGetCollectionWithHttpInfo(filterApp, fieldsBetaLicenseAgreements, limit, include, fieldsApps, _options).pipe(map((apiResponse: HttpInfo<BetaLicenseAgreementsResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBetaLicenseAgreements the fields to include for returned resources of type betaLicenseAgreements
     * @param include comma-separated list of relationships to include
     * @param fieldsApps the fields to include for returned resources of type apps
     */
    public betaLicenseAgreementsGetInstanceWithHttpInfo(id: string, fieldsBetaLicenseAgreements?: Array<'agreementText' | 'app'>, include?: Array<'app'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, _options?: Configuration): Observable<HttpInfo<BetaLicenseAgreementResponse>> {
        const requestContextPromise = this.requestFactory.betaLicenseAgreementsGetInstance(id, fieldsBetaLicenseAgreements, include, fieldsApps, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.betaLicenseAgreementsGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBetaLicenseAgreements the fields to include for returned resources of type betaLicenseAgreements
     * @param include comma-separated list of relationships to include
     * @param fieldsApps the fields to include for returned resources of type apps
     */
    public betaLicenseAgreementsGetInstance(id: string, fieldsBetaLicenseAgreements?: Array<'agreementText' | 'app'>, include?: Array<'app'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, _options?: Configuration): Observable<BetaLicenseAgreementResponse> {
        return this.betaLicenseAgreementsGetInstanceWithHttpInfo(id, fieldsBetaLicenseAgreements, include, fieldsApps, _options).pipe(map((apiResponse: HttpInfo<BetaLicenseAgreementResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param betaLicenseAgreementUpdateRequest BetaLicenseAgreement representation
     */
    public betaLicenseAgreementsUpdateInstanceWithHttpInfo(id: string, betaLicenseAgreementUpdateRequest: BetaLicenseAgreementUpdateRequest, _options?: Configuration): Observable<HttpInfo<BetaLicenseAgreementResponse>> {
        const requestContextPromise = this.requestFactory.betaLicenseAgreementsUpdateInstance(id, betaLicenseAgreementUpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.betaLicenseAgreementsUpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param betaLicenseAgreementUpdateRequest BetaLicenseAgreement representation
     */
    public betaLicenseAgreementsUpdateInstance(id: string, betaLicenseAgreementUpdateRequest: BetaLicenseAgreementUpdateRequest, _options?: Configuration): Observable<BetaLicenseAgreementResponse> {
        return this.betaLicenseAgreementsUpdateInstanceWithHttpInfo(id, betaLicenseAgreementUpdateRequest, _options).pipe(map((apiResponse: HttpInfo<BetaLicenseAgreementResponse>) => apiResponse.data));
    }

}

import { BetaTesterInvitationsApiRequestFactory, BetaTesterInvitationsApiResponseProcessor} from "../apis/BetaTesterInvitationsApi.ts";
export class ObservableBetaTesterInvitationsApi {
    private requestFactory: BetaTesterInvitationsApiRequestFactory;
    private responseProcessor: BetaTesterInvitationsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: BetaTesterInvitationsApiRequestFactory,
        responseProcessor?: BetaTesterInvitationsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new BetaTesterInvitationsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new BetaTesterInvitationsApiResponseProcessor();
    }

    /**
     * @param betaTesterInvitationCreateRequest BetaTesterInvitation representation
     */
    public betaTesterInvitationsCreateInstanceWithHttpInfo(betaTesterInvitationCreateRequest: BetaTesterInvitationCreateRequest, _options?: Configuration): Observable<HttpInfo<BetaTesterInvitationResponse>> {
        const requestContextPromise = this.requestFactory.betaTesterInvitationsCreateInstance(betaTesterInvitationCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.betaTesterInvitationsCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param betaTesterInvitationCreateRequest BetaTesterInvitation representation
     */
    public betaTesterInvitationsCreateInstance(betaTesterInvitationCreateRequest: BetaTesterInvitationCreateRequest, _options?: Configuration): Observable<BetaTesterInvitationResponse> {
        return this.betaTesterInvitationsCreateInstanceWithHttpInfo(betaTesterInvitationCreateRequest, _options).pipe(map((apiResponse: HttpInfo<BetaTesterInvitationResponse>) => apiResponse.data));
    }

}

import { BetaTestersApiRequestFactory, BetaTestersApiResponseProcessor} from "../apis/BetaTestersApi.ts";
export class ObservableBetaTestersApi {
    private requestFactory: BetaTestersApiRequestFactory;
    private responseProcessor: BetaTestersApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: BetaTestersApiRequestFactory,
        responseProcessor?: BetaTestersApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new BetaTestersApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new BetaTestersApiResponseProcessor();
    }

    /**
     * @param id the id of the requested resource
     * @param betaTesterAppsLinkagesRequest List of related linkages
     */
    public betaTestersAppsDeleteToManyRelationshipWithHttpInfo(id: string, betaTesterAppsLinkagesRequest: BetaTesterAppsLinkagesRequest, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.betaTestersAppsDeleteToManyRelationship(id, betaTesterAppsLinkagesRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.betaTestersAppsDeleteToManyRelationshipWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param betaTesterAppsLinkagesRequest List of related linkages
     */
    public betaTestersAppsDeleteToManyRelationship(id: string, betaTesterAppsLinkagesRequest: BetaTesterAppsLinkagesRequest, _options?: Configuration): Observable<void> {
        return this.betaTestersAppsDeleteToManyRelationshipWithHttpInfo(id, betaTesterAppsLinkagesRequest, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param limit maximum resources per page
     */
    public betaTestersAppsGetToManyRelatedWithHttpInfo(id: string, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, limit?: number, _options?: Configuration): Observable<HttpInfo<AppsWithoutIncludesResponse>> {
        const requestContextPromise = this.requestFactory.betaTestersAppsGetToManyRelated(id, fieldsApps, limit, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.betaTestersAppsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param limit maximum resources per page
     */
    public betaTestersAppsGetToManyRelated(id: string, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, limit?: number, _options?: Configuration): Observable<AppsWithoutIncludesResponse> {
        return this.betaTestersAppsGetToManyRelatedWithHttpInfo(id, fieldsApps, limit, _options).pipe(map((apiResponse: HttpInfo<AppsWithoutIncludesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public betaTestersAppsGetToManyRelationshipWithHttpInfo(id: string, limit?: number, _options?: Configuration): Observable<HttpInfo<BetaTesterAppsLinkagesResponse>> {
        const requestContextPromise = this.requestFactory.betaTestersAppsGetToManyRelationship(id, limit, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.betaTestersAppsGetToManyRelationshipWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public betaTestersAppsGetToManyRelationship(id: string, limit?: number, _options?: Configuration): Observable<BetaTesterAppsLinkagesResponse> {
        return this.betaTestersAppsGetToManyRelationshipWithHttpInfo(id, limit, _options).pipe(map((apiResponse: HttpInfo<BetaTesterAppsLinkagesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param betaTesterBetaGroupsLinkagesRequest List of related linkages
     */
    public betaTestersBetaGroupsCreateToManyRelationshipWithHttpInfo(id: string, betaTesterBetaGroupsLinkagesRequest: BetaTesterBetaGroupsLinkagesRequest, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.betaTestersBetaGroupsCreateToManyRelationship(id, betaTesterBetaGroupsLinkagesRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.betaTestersBetaGroupsCreateToManyRelationshipWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param betaTesterBetaGroupsLinkagesRequest List of related linkages
     */
    public betaTestersBetaGroupsCreateToManyRelationship(id: string, betaTesterBetaGroupsLinkagesRequest: BetaTesterBetaGroupsLinkagesRequest, _options?: Configuration): Observable<void> {
        return this.betaTestersBetaGroupsCreateToManyRelationshipWithHttpInfo(id, betaTesterBetaGroupsLinkagesRequest, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param betaTesterBetaGroupsLinkagesRequest List of related linkages
     */
    public betaTestersBetaGroupsDeleteToManyRelationshipWithHttpInfo(id: string, betaTesterBetaGroupsLinkagesRequest: BetaTesterBetaGroupsLinkagesRequest, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.betaTestersBetaGroupsDeleteToManyRelationship(id, betaTesterBetaGroupsLinkagesRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.betaTestersBetaGroupsDeleteToManyRelationshipWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param betaTesterBetaGroupsLinkagesRequest List of related linkages
     */
    public betaTestersBetaGroupsDeleteToManyRelationship(id: string, betaTesterBetaGroupsLinkagesRequest: BetaTesterBetaGroupsLinkagesRequest, _options?: Configuration): Observable<void> {
        return this.betaTestersBetaGroupsDeleteToManyRelationshipWithHttpInfo(id, betaTesterBetaGroupsLinkagesRequest, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBetaGroups the fields to include for returned resources of type betaGroups
     * @param limit maximum resources per page
     */
    public betaTestersBetaGroupsGetToManyRelatedWithHttpInfo(id: string, fieldsBetaGroups?: Array<'app' | 'betaTesters' | 'builds' | 'createdDate' | 'feedbackEnabled' | 'hasAccessToAllBuilds' | 'iosBuildsAvailableForAppleSiliconMac' | 'isInternalGroup' | 'name' | 'publicLink' | 'publicLinkEnabled' | 'publicLinkId' | 'publicLinkLimit' | 'publicLinkLimitEnabled'>, limit?: number, _options?: Configuration): Observable<HttpInfo<BetaGroupsWithoutIncludesResponse>> {
        const requestContextPromise = this.requestFactory.betaTestersBetaGroupsGetToManyRelated(id, fieldsBetaGroups, limit, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.betaTestersBetaGroupsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBetaGroups the fields to include for returned resources of type betaGroups
     * @param limit maximum resources per page
     */
    public betaTestersBetaGroupsGetToManyRelated(id: string, fieldsBetaGroups?: Array<'app' | 'betaTesters' | 'builds' | 'createdDate' | 'feedbackEnabled' | 'hasAccessToAllBuilds' | 'iosBuildsAvailableForAppleSiliconMac' | 'isInternalGroup' | 'name' | 'publicLink' | 'publicLinkEnabled' | 'publicLinkId' | 'publicLinkLimit' | 'publicLinkLimitEnabled'>, limit?: number, _options?: Configuration): Observable<BetaGroupsWithoutIncludesResponse> {
        return this.betaTestersBetaGroupsGetToManyRelatedWithHttpInfo(id, fieldsBetaGroups, limit, _options).pipe(map((apiResponse: HttpInfo<BetaGroupsWithoutIncludesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public betaTestersBetaGroupsGetToManyRelationshipWithHttpInfo(id: string, limit?: number, _options?: Configuration): Observable<HttpInfo<BetaTesterBetaGroupsLinkagesResponse>> {
        const requestContextPromise = this.requestFactory.betaTestersBetaGroupsGetToManyRelationship(id, limit, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.betaTestersBetaGroupsGetToManyRelationshipWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public betaTestersBetaGroupsGetToManyRelationship(id: string, limit?: number, _options?: Configuration): Observable<BetaTesterBetaGroupsLinkagesResponse> {
        return this.betaTestersBetaGroupsGetToManyRelationshipWithHttpInfo(id, limit, _options).pipe(map((apiResponse: HttpInfo<BetaTesterBetaGroupsLinkagesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param filterApps filter by \&#39;apps\&#39; relationship dimension
     * @param limit maximum number of groups to return per page
     * @param period the duration of the reporting period
     */
    public betaTestersBetaTesterUsagesGetMetricsWithHttpInfo(id: string, filterApps: string, limit?: number, period?: 'P7D' | 'P30D' | 'P90D' | 'P365D', _options?: Configuration): Observable<HttpInfo<BetaTesterUsagesV1MetricResponse>> {
        const requestContextPromise = this.requestFactory.betaTestersBetaTesterUsagesGetMetrics(id, filterApps, limit, period, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.betaTestersBetaTesterUsagesGetMetricsWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param filterApps filter by \&#39;apps\&#39; relationship dimension
     * @param limit maximum number of groups to return per page
     * @param period the duration of the reporting period
     */
    public betaTestersBetaTesterUsagesGetMetrics(id: string, filterApps: string, limit?: number, period?: 'P7D' | 'P30D' | 'P90D' | 'P365D', _options?: Configuration): Observable<BetaTesterUsagesV1MetricResponse> {
        return this.betaTestersBetaTesterUsagesGetMetricsWithHttpInfo(id, filterApps, limit, period, _options).pipe(map((apiResponse: HttpInfo<BetaTesterUsagesV1MetricResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param betaTesterBuildsLinkagesRequest List of related linkages
     */
    public betaTestersBuildsCreateToManyRelationshipWithHttpInfo(id: string, betaTesterBuildsLinkagesRequest: BetaTesterBuildsLinkagesRequest, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.betaTestersBuildsCreateToManyRelationship(id, betaTesterBuildsLinkagesRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.betaTestersBuildsCreateToManyRelationshipWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param betaTesterBuildsLinkagesRequest List of related linkages
     */
    public betaTestersBuildsCreateToManyRelationship(id: string, betaTesterBuildsLinkagesRequest: BetaTesterBuildsLinkagesRequest, _options?: Configuration): Observable<void> {
        return this.betaTestersBuildsCreateToManyRelationshipWithHttpInfo(id, betaTesterBuildsLinkagesRequest, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param betaTesterBuildsLinkagesRequest List of related linkages
     */
    public betaTestersBuildsDeleteToManyRelationshipWithHttpInfo(id: string, betaTesterBuildsLinkagesRequest: BetaTesterBuildsLinkagesRequest, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.betaTestersBuildsDeleteToManyRelationship(id, betaTesterBuildsLinkagesRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.betaTestersBuildsDeleteToManyRelationshipWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param betaTesterBuildsLinkagesRequest List of related linkages
     */
    public betaTestersBuildsDeleteToManyRelationship(id: string, betaTesterBuildsLinkagesRequest: BetaTesterBuildsLinkagesRequest, _options?: Configuration): Observable<void> {
        return this.betaTestersBuildsDeleteToManyRelationshipWithHttpInfo(id, betaTesterBuildsLinkagesRequest, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param limit maximum resources per page
     */
    public betaTestersBuildsGetToManyRelatedWithHttpInfo(id: string, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, limit?: number, _options?: Configuration): Observable<HttpInfo<BuildsWithoutIncludesResponse>> {
        const requestContextPromise = this.requestFactory.betaTestersBuildsGetToManyRelated(id, fieldsBuilds, limit, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.betaTestersBuildsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param limit maximum resources per page
     */
    public betaTestersBuildsGetToManyRelated(id: string, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, limit?: number, _options?: Configuration): Observable<BuildsWithoutIncludesResponse> {
        return this.betaTestersBuildsGetToManyRelatedWithHttpInfo(id, fieldsBuilds, limit, _options).pipe(map((apiResponse: HttpInfo<BuildsWithoutIncludesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public betaTestersBuildsGetToManyRelationshipWithHttpInfo(id: string, limit?: number, _options?: Configuration): Observable<HttpInfo<BetaTesterBuildsLinkagesResponse>> {
        const requestContextPromise = this.requestFactory.betaTestersBuildsGetToManyRelationship(id, limit, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.betaTestersBuildsGetToManyRelationshipWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public betaTestersBuildsGetToManyRelationship(id: string, limit?: number, _options?: Configuration): Observable<BetaTesterBuildsLinkagesResponse> {
        return this.betaTestersBuildsGetToManyRelationshipWithHttpInfo(id, limit, _options).pipe(map((apiResponse: HttpInfo<BetaTesterBuildsLinkagesResponse>) => apiResponse.data));
    }

    /**
     * @param betaTesterCreateRequest BetaTester representation
     */
    public betaTestersCreateInstanceWithHttpInfo(betaTesterCreateRequest: BetaTesterCreateRequest, _options?: Configuration): Observable<HttpInfo<BetaTesterResponse>> {
        const requestContextPromise = this.requestFactory.betaTestersCreateInstance(betaTesterCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.betaTestersCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param betaTesterCreateRequest BetaTester representation
     */
    public betaTestersCreateInstance(betaTesterCreateRequest: BetaTesterCreateRequest, _options?: Configuration): Observable<BetaTesterResponse> {
        return this.betaTestersCreateInstanceWithHttpInfo(betaTesterCreateRequest, _options).pipe(map((apiResponse: HttpInfo<BetaTesterResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public betaTestersDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.betaTestersDeleteInstance(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.betaTestersDeleteInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public betaTestersDeleteInstance(id: string, _options?: Configuration): Observable<void> {
        return this.betaTestersDeleteInstanceWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param filterEmail filter by attribute \&#39;email\&#39;
     * @param filterFirstName filter by attribute \&#39;firstName\&#39;
     * @param filterInviteType filter by attribute \&#39;inviteType\&#39;
     * @param filterLastName filter by attribute \&#39;lastName\&#39;
     * @param filterApps filter by id(s) of related \&#39;apps\&#39;
     * @param filterBetaGroups filter by id(s) of related \&#39;betaGroups\&#39;
     * @param filterBuilds filter by id(s) of related \&#39;builds\&#39;
     * @param filterId filter by id(s)
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsBetaTesters the fields to include for returned resources of type betaTesters
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param fieldsBetaGroups the fields to include for returned resources of type betaGroups
     * @param limitApps maximum number of related apps returned (when they are included)
     * @param limitBetaGroups maximum number of related betaGroups returned (when they are included)
     * @param limitBuilds maximum number of related builds returned (when they are included)
     */
    public betaTestersGetCollectionWithHttpInfo(filterEmail?: Array<string>, filterFirstName?: Array<string>, filterInviteType?: Array<'EMAIL' | 'PUBLIC_LINK'>, filterLastName?: Array<string>, filterApps?: Array<string>, filterBetaGroups?: Array<string>, filterBuilds?: Array<string>, filterId?: Array<string>, sort?: Array<'email' | '-email' | 'firstName' | '-firstName' | 'inviteType' | '-inviteType' | 'lastName' | '-lastName'>, fieldsBetaTesters?: Array<'apps' | 'betaGroups' | 'builds' | 'email' | 'firstName' | 'inviteType' | 'lastName'>, limit?: number, include?: Array<'apps' | 'betaGroups' | 'builds'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, fieldsBetaGroups?: Array<'app' | 'betaTesters' | 'builds' | 'createdDate' | 'feedbackEnabled' | 'hasAccessToAllBuilds' | 'iosBuildsAvailableForAppleSiliconMac' | 'isInternalGroup' | 'name' | 'publicLink' | 'publicLinkEnabled' | 'publicLinkId' | 'publicLinkLimit' | 'publicLinkLimitEnabled'>, limitApps?: number, limitBetaGroups?: number, limitBuilds?: number, _options?: Configuration): Observable<HttpInfo<BetaTestersResponse>> {
        const requestContextPromise = this.requestFactory.betaTestersGetCollection(filterEmail, filterFirstName, filterInviteType, filterLastName, filterApps, filterBetaGroups, filterBuilds, filterId, sort, fieldsBetaTesters, limit, include, fieldsApps, fieldsBuilds, fieldsBetaGroups, limitApps, limitBetaGroups, limitBuilds, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.betaTestersGetCollectionWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param filterEmail filter by attribute \&#39;email\&#39;
     * @param filterFirstName filter by attribute \&#39;firstName\&#39;
     * @param filterInviteType filter by attribute \&#39;inviteType\&#39;
     * @param filterLastName filter by attribute \&#39;lastName\&#39;
     * @param filterApps filter by id(s) of related \&#39;apps\&#39;
     * @param filterBetaGroups filter by id(s) of related \&#39;betaGroups\&#39;
     * @param filterBuilds filter by id(s) of related \&#39;builds\&#39;
     * @param filterId filter by id(s)
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsBetaTesters the fields to include for returned resources of type betaTesters
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param fieldsBetaGroups the fields to include for returned resources of type betaGroups
     * @param limitApps maximum number of related apps returned (when they are included)
     * @param limitBetaGroups maximum number of related betaGroups returned (when they are included)
     * @param limitBuilds maximum number of related builds returned (when they are included)
     */
    public betaTestersGetCollection(filterEmail?: Array<string>, filterFirstName?: Array<string>, filterInviteType?: Array<'EMAIL' | 'PUBLIC_LINK'>, filterLastName?: Array<string>, filterApps?: Array<string>, filterBetaGroups?: Array<string>, filterBuilds?: Array<string>, filterId?: Array<string>, sort?: Array<'email' | '-email' | 'firstName' | '-firstName' | 'inviteType' | '-inviteType' | 'lastName' | '-lastName'>, fieldsBetaTesters?: Array<'apps' | 'betaGroups' | 'builds' | 'email' | 'firstName' | 'inviteType' | 'lastName'>, limit?: number, include?: Array<'apps' | 'betaGroups' | 'builds'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, fieldsBetaGroups?: Array<'app' | 'betaTesters' | 'builds' | 'createdDate' | 'feedbackEnabled' | 'hasAccessToAllBuilds' | 'iosBuildsAvailableForAppleSiliconMac' | 'isInternalGroup' | 'name' | 'publicLink' | 'publicLinkEnabled' | 'publicLinkId' | 'publicLinkLimit' | 'publicLinkLimitEnabled'>, limitApps?: number, limitBetaGroups?: number, limitBuilds?: number, _options?: Configuration): Observable<BetaTestersResponse> {
        return this.betaTestersGetCollectionWithHttpInfo(filterEmail, filterFirstName, filterInviteType, filterLastName, filterApps, filterBetaGroups, filterBuilds, filterId, sort, fieldsBetaTesters, limit, include, fieldsApps, fieldsBuilds, fieldsBetaGroups, limitApps, limitBetaGroups, limitBuilds, _options).pipe(map((apiResponse: HttpInfo<BetaTestersResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBetaTesters the fields to include for returned resources of type betaTesters
     * @param include comma-separated list of relationships to include
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param fieldsBetaGroups the fields to include for returned resources of type betaGroups
     * @param limitApps maximum number of related apps returned (when they are included)
     * @param limitBetaGroups maximum number of related betaGroups returned (when they are included)
     * @param limitBuilds maximum number of related builds returned (when they are included)
     */
    public betaTestersGetInstanceWithHttpInfo(id: string, fieldsBetaTesters?: Array<'apps' | 'betaGroups' | 'builds' | 'email' | 'firstName' | 'inviteType' | 'lastName'>, include?: Array<'apps' | 'betaGroups' | 'builds'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, fieldsBetaGroups?: Array<'app' | 'betaTesters' | 'builds' | 'createdDate' | 'feedbackEnabled' | 'hasAccessToAllBuilds' | 'iosBuildsAvailableForAppleSiliconMac' | 'isInternalGroup' | 'name' | 'publicLink' | 'publicLinkEnabled' | 'publicLinkId' | 'publicLinkLimit' | 'publicLinkLimitEnabled'>, limitApps?: number, limitBetaGroups?: number, limitBuilds?: number, _options?: Configuration): Observable<HttpInfo<BetaTesterResponse>> {
        const requestContextPromise = this.requestFactory.betaTestersGetInstance(id, fieldsBetaTesters, include, fieldsApps, fieldsBuilds, fieldsBetaGroups, limitApps, limitBetaGroups, limitBuilds, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.betaTestersGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBetaTesters the fields to include for returned resources of type betaTesters
     * @param include comma-separated list of relationships to include
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param fieldsBetaGroups the fields to include for returned resources of type betaGroups
     * @param limitApps maximum number of related apps returned (when they are included)
     * @param limitBetaGroups maximum number of related betaGroups returned (when they are included)
     * @param limitBuilds maximum number of related builds returned (when they are included)
     */
    public betaTestersGetInstance(id: string, fieldsBetaTesters?: Array<'apps' | 'betaGroups' | 'builds' | 'email' | 'firstName' | 'inviteType' | 'lastName'>, include?: Array<'apps' | 'betaGroups' | 'builds'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, fieldsBetaGroups?: Array<'app' | 'betaTesters' | 'builds' | 'createdDate' | 'feedbackEnabled' | 'hasAccessToAllBuilds' | 'iosBuildsAvailableForAppleSiliconMac' | 'isInternalGroup' | 'name' | 'publicLink' | 'publicLinkEnabled' | 'publicLinkId' | 'publicLinkLimit' | 'publicLinkLimitEnabled'>, limitApps?: number, limitBetaGroups?: number, limitBuilds?: number, _options?: Configuration): Observable<BetaTesterResponse> {
        return this.betaTestersGetInstanceWithHttpInfo(id, fieldsBetaTesters, include, fieldsApps, fieldsBuilds, fieldsBetaGroups, limitApps, limitBetaGroups, limitBuilds, _options).pipe(map((apiResponse: HttpInfo<BetaTesterResponse>) => apiResponse.data));
    }

}

import { BuildBetaDetailsApiRequestFactory, BuildBetaDetailsApiResponseProcessor} from "../apis/BuildBetaDetailsApi.ts";
export class ObservableBuildBetaDetailsApi {
    private requestFactory: BuildBetaDetailsApiRequestFactory;
    private responseProcessor: BuildBetaDetailsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: BuildBetaDetailsApiRequestFactory,
        responseProcessor?: BuildBetaDetailsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new BuildBetaDetailsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new BuildBetaDetailsApiResponseProcessor();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBuilds the fields to include for returned resources of type builds
     */
    public buildBetaDetailsBuildGetToOneRelatedWithHttpInfo(id: string, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, _options?: Configuration): Observable<HttpInfo<BuildWithoutIncludesResponse>> {
        const requestContextPromise = this.requestFactory.buildBetaDetailsBuildGetToOneRelated(id, fieldsBuilds, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.buildBetaDetailsBuildGetToOneRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBuilds the fields to include for returned resources of type builds
     */
    public buildBetaDetailsBuildGetToOneRelated(id: string, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, _options?: Configuration): Observable<BuildWithoutIncludesResponse> {
        return this.buildBetaDetailsBuildGetToOneRelatedWithHttpInfo(id, fieldsBuilds, _options).pipe(map((apiResponse: HttpInfo<BuildWithoutIncludesResponse>) => apiResponse.data));
    }

    /**
     * @param filterBuild filter by id(s) of related \&#39;build\&#39;
     * @param filterId filter by id(s)
     * @param fieldsBuildBetaDetails the fields to include for returned resources of type buildBetaDetails
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsBuilds the fields to include for returned resources of type builds
     */
    public buildBetaDetailsGetCollectionWithHttpInfo(filterBuild?: Array<string>, filterId?: Array<string>, fieldsBuildBetaDetails?: Array<'autoNotifyEnabled' | 'build' | 'externalBuildState' | 'internalBuildState'>, limit?: number, include?: Array<'build'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, _options?: Configuration): Observable<HttpInfo<BuildBetaDetailsResponse>> {
        const requestContextPromise = this.requestFactory.buildBetaDetailsGetCollection(filterBuild, filterId, fieldsBuildBetaDetails, limit, include, fieldsBuilds, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.buildBetaDetailsGetCollectionWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param filterBuild filter by id(s) of related \&#39;build\&#39;
     * @param filterId filter by id(s)
     * @param fieldsBuildBetaDetails the fields to include for returned resources of type buildBetaDetails
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsBuilds the fields to include for returned resources of type builds
     */
    public buildBetaDetailsGetCollection(filterBuild?: Array<string>, filterId?: Array<string>, fieldsBuildBetaDetails?: Array<'autoNotifyEnabled' | 'build' | 'externalBuildState' | 'internalBuildState'>, limit?: number, include?: Array<'build'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, _options?: Configuration): Observable<BuildBetaDetailsResponse> {
        return this.buildBetaDetailsGetCollectionWithHttpInfo(filterBuild, filterId, fieldsBuildBetaDetails, limit, include, fieldsBuilds, _options).pipe(map((apiResponse: HttpInfo<BuildBetaDetailsResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBuildBetaDetails the fields to include for returned resources of type buildBetaDetails
     * @param include comma-separated list of relationships to include
     * @param fieldsBuilds the fields to include for returned resources of type builds
     */
    public buildBetaDetailsGetInstanceWithHttpInfo(id: string, fieldsBuildBetaDetails?: Array<'autoNotifyEnabled' | 'build' | 'externalBuildState' | 'internalBuildState'>, include?: Array<'build'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, _options?: Configuration): Observable<HttpInfo<BuildBetaDetailResponse>> {
        const requestContextPromise = this.requestFactory.buildBetaDetailsGetInstance(id, fieldsBuildBetaDetails, include, fieldsBuilds, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.buildBetaDetailsGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBuildBetaDetails the fields to include for returned resources of type buildBetaDetails
     * @param include comma-separated list of relationships to include
     * @param fieldsBuilds the fields to include for returned resources of type builds
     */
    public buildBetaDetailsGetInstance(id: string, fieldsBuildBetaDetails?: Array<'autoNotifyEnabled' | 'build' | 'externalBuildState' | 'internalBuildState'>, include?: Array<'build'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, _options?: Configuration): Observable<BuildBetaDetailResponse> {
        return this.buildBetaDetailsGetInstanceWithHttpInfo(id, fieldsBuildBetaDetails, include, fieldsBuilds, _options).pipe(map((apiResponse: HttpInfo<BuildBetaDetailResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param buildBetaDetailUpdateRequest BuildBetaDetail representation
     */
    public buildBetaDetailsUpdateInstanceWithHttpInfo(id: string, buildBetaDetailUpdateRequest: BuildBetaDetailUpdateRequest, _options?: Configuration): Observable<HttpInfo<BuildBetaDetailResponse>> {
        const requestContextPromise = this.requestFactory.buildBetaDetailsUpdateInstance(id, buildBetaDetailUpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.buildBetaDetailsUpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param buildBetaDetailUpdateRequest BuildBetaDetail representation
     */
    public buildBetaDetailsUpdateInstance(id: string, buildBetaDetailUpdateRequest: BuildBetaDetailUpdateRequest, _options?: Configuration): Observable<BuildBetaDetailResponse> {
        return this.buildBetaDetailsUpdateInstanceWithHttpInfo(id, buildBetaDetailUpdateRequest, _options).pipe(map((apiResponse: HttpInfo<BuildBetaDetailResponse>) => apiResponse.data));
    }

}

import { BuildBetaNotificationsApiRequestFactory, BuildBetaNotificationsApiResponseProcessor} from "../apis/BuildBetaNotificationsApi.ts";
export class ObservableBuildBetaNotificationsApi {
    private requestFactory: BuildBetaNotificationsApiRequestFactory;
    private responseProcessor: BuildBetaNotificationsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: BuildBetaNotificationsApiRequestFactory,
        responseProcessor?: BuildBetaNotificationsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new BuildBetaNotificationsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new BuildBetaNotificationsApiResponseProcessor();
    }

    /**
     * @param buildBetaNotificationCreateRequest BuildBetaNotification representation
     */
    public buildBetaNotificationsCreateInstanceWithHttpInfo(buildBetaNotificationCreateRequest: BuildBetaNotificationCreateRequest, _options?: Configuration): Observable<HttpInfo<BuildBetaNotificationResponse>> {
        const requestContextPromise = this.requestFactory.buildBetaNotificationsCreateInstance(buildBetaNotificationCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.buildBetaNotificationsCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param buildBetaNotificationCreateRequest BuildBetaNotification representation
     */
    public buildBetaNotificationsCreateInstance(buildBetaNotificationCreateRequest: BuildBetaNotificationCreateRequest, _options?: Configuration): Observable<BuildBetaNotificationResponse> {
        return this.buildBetaNotificationsCreateInstanceWithHttpInfo(buildBetaNotificationCreateRequest, _options).pipe(map((apiResponse: HttpInfo<BuildBetaNotificationResponse>) => apiResponse.data));
    }

}

import { BuildBundlesApiRequestFactory, BuildBundlesApiResponseProcessor} from "../apis/BuildBundlesApi.ts";
export class ObservableBuildBundlesApi {
    private requestFactory: BuildBundlesApiRequestFactory;
    private responseProcessor: BuildBundlesApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: BuildBundlesApiRequestFactory,
        responseProcessor?: BuildBundlesApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new BuildBundlesApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new BuildBundlesApiResponseProcessor();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppClipDomainStatuses the fields to include for returned resources of type appClipDomainStatuses
     */
    public buildBundlesAppClipDomainCacheStatusGetToOneRelatedWithHttpInfo(id: string, fieldsAppClipDomainStatuses?: Array<'domains' | 'lastUpdatedDate'>, _options?: Configuration): Observable<HttpInfo<AppClipDomainStatusResponse>> {
        const requestContextPromise = this.requestFactory.buildBundlesAppClipDomainCacheStatusGetToOneRelated(id, fieldsAppClipDomainStatuses, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.buildBundlesAppClipDomainCacheStatusGetToOneRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppClipDomainStatuses the fields to include for returned resources of type appClipDomainStatuses
     */
    public buildBundlesAppClipDomainCacheStatusGetToOneRelated(id: string, fieldsAppClipDomainStatuses?: Array<'domains' | 'lastUpdatedDate'>, _options?: Configuration): Observable<AppClipDomainStatusResponse> {
        return this.buildBundlesAppClipDomainCacheStatusGetToOneRelatedWithHttpInfo(id, fieldsAppClipDomainStatuses, _options).pipe(map((apiResponse: HttpInfo<AppClipDomainStatusResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppClipDomainStatuses the fields to include for returned resources of type appClipDomainStatuses
     */
    public buildBundlesAppClipDomainDebugStatusGetToOneRelatedWithHttpInfo(id: string, fieldsAppClipDomainStatuses?: Array<'domains' | 'lastUpdatedDate'>, _options?: Configuration): Observable<HttpInfo<AppClipDomainStatusResponse>> {
        const requestContextPromise = this.requestFactory.buildBundlesAppClipDomainDebugStatusGetToOneRelated(id, fieldsAppClipDomainStatuses, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.buildBundlesAppClipDomainDebugStatusGetToOneRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppClipDomainStatuses the fields to include for returned resources of type appClipDomainStatuses
     */
    public buildBundlesAppClipDomainDebugStatusGetToOneRelated(id: string, fieldsAppClipDomainStatuses?: Array<'domains' | 'lastUpdatedDate'>, _options?: Configuration): Observable<AppClipDomainStatusResponse> {
        return this.buildBundlesAppClipDomainDebugStatusGetToOneRelatedWithHttpInfo(id, fieldsAppClipDomainStatuses, _options).pipe(map((apiResponse: HttpInfo<AppClipDomainStatusResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBetaAppClipInvocations the fields to include for returned resources of type betaAppClipInvocations
     * @param fieldsBetaAppClipInvocationLocalizations the fields to include for returned resources of type betaAppClipInvocationLocalizations
     * @param limit maximum resources per page
     * @param limitBetaAppClipInvocationLocalizations maximum number of related betaAppClipInvocationLocalizations returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public buildBundlesBetaAppClipInvocationsGetToManyRelatedWithHttpInfo(id: string, fieldsBetaAppClipInvocations?: Array<'betaAppClipInvocationLocalizations' | 'buildBundle' | 'url'>, fieldsBetaAppClipInvocationLocalizations?: Array<'betaAppClipInvocation' | 'locale' | 'title'>, limit?: number, limitBetaAppClipInvocationLocalizations?: number, include?: Array<'betaAppClipInvocationLocalizations'>, _options?: Configuration): Observable<HttpInfo<BetaAppClipInvocationsResponse>> {
        const requestContextPromise = this.requestFactory.buildBundlesBetaAppClipInvocationsGetToManyRelated(id, fieldsBetaAppClipInvocations, fieldsBetaAppClipInvocationLocalizations, limit, limitBetaAppClipInvocationLocalizations, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.buildBundlesBetaAppClipInvocationsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBetaAppClipInvocations the fields to include for returned resources of type betaAppClipInvocations
     * @param fieldsBetaAppClipInvocationLocalizations the fields to include for returned resources of type betaAppClipInvocationLocalizations
     * @param limit maximum resources per page
     * @param limitBetaAppClipInvocationLocalizations maximum number of related betaAppClipInvocationLocalizations returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public buildBundlesBetaAppClipInvocationsGetToManyRelated(id: string, fieldsBetaAppClipInvocations?: Array<'betaAppClipInvocationLocalizations' | 'buildBundle' | 'url'>, fieldsBetaAppClipInvocationLocalizations?: Array<'betaAppClipInvocation' | 'locale' | 'title'>, limit?: number, limitBetaAppClipInvocationLocalizations?: number, include?: Array<'betaAppClipInvocationLocalizations'>, _options?: Configuration): Observable<BetaAppClipInvocationsResponse> {
        return this.buildBundlesBetaAppClipInvocationsGetToManyRelatedWithHttpInfo(id, fieldsBetaAppClipInvocations, fieldsBetaAppClipInvocationLocalizations, limit, limitBetaAppClipInvocationLocalizations, include, _options).pipe(map((apiResponse: HttpInfo<BetaAppClipInvocationsResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBuildBundleFileSizes the fields to include for returned resources of type buildBundleFileSizes
     * @param limit maximum resources per page
     */
    public buildBundlesBuildBundleFileSizesGetToManyRelatedWithHttpInfo(id: string, fieldsBuildBundleFileSizes?: Array<'deviceModel' | 'downloadBytes' | 'installBytes' | 'osVersion'>, limit?: number, _options?: Configuration): Observable<HttpInfo<BuildBundleFileSizesResponse>> {
        const requestContextPromise = this.requestFactory.buildBundlesBuildBundleFileSizesGetToManyRelated(id, fieldsBuildBundleFileSizes, limit, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.buildBundlesBuildBundleFileSizesGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBuildBundleFileSizes the fields to include for returned resources of type buildBundleFileSizes
     * @param limit maximum resources per page
     */
    public buildBundlesBuildBundleFileSizesGetToManyRelated(id: string, fieldsBuildBundleFileSizes?: Array<'deviceModel' | 'downloadBytes' | 'installBytes' | 'osVersion'>, limit?: number, _options?: Configuration): Observable<BuildBundleFileSizesResponse> {
        return this.buildBundlesBuildBundleFileSizesGetToManyRelatedWithHttpInfo(id, fieldsBuildBundleFileSizes, limit, _options).pipe(map((apiResponse: HttpInfo<BuildBundleFileSizesResponse>) => apiResponse.data));
    }

}

import { BuildsApiRequestFactory, BuildsApiResponseProcessor} from "../apis/BuildsApi.ts";
export class ObservableBuildsApi {
    private requestFactory: BuildsApiRequestFactory;
    private responseProcessor: BuildsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: BuildsApiRequestFactory,
        responseProcessor?: BuildsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new BuildsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new BuildsApiResponseProcessor();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppEncryptionDeclarations the fields to include for returned resources of type appEncryptionDeclarations
     */
    public buildsAppEncryptionDeclarationGetToOneRelatedWithHttpInfo(id: string, fieldsAppEncryptionDeclarations?: Array<'app' | 'appDescription' | 'appEncryptionDeclarationDocument' | 'appEncryptionDeclarationState' | 'availableOnFrenchStore' | 'builds' | 'codeValue' | 'containsProprietaryCryptography' | 'containsThirdPartyCryptography' | 'createdDate' | 'documentName' | 'documentType' | 'documentUrl' | 'exempt' | 'platform' | 'uploadedDate' | 'usesEncryption'>, _options?: Configuration): Observable<HttpInfo<AppEncryptionDeclarationWithoutIncludesResponse>> {
        const requestContextPromise = this.requestFactory.buildsAppEncryptionDeclarationGetToOneRelated(id, fieldsAppEncryptionDeclarations, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.buildsAppEncryptionDeclarationGetToOneRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppEncryptionDeclarations the fields to include for returned resources of type appEncryptionDeclarations
     */
    public buildsAppEncryptionDeclarationGetToOneRelated(id: string, fieldsAppEncryptionDeclarations?: Array<'app' | 'appDescription' | 'appEncryptionDeclarationDocument' | 'appEncryptionDeclarationState' | 'availableOnFrenchStore' | 'builds' | 'codeValue' | 'containsProprietaryCryptography' | 'containsThirdPartyCryptography' | 'createdDate' | 'documentName' | 'documentType' | 'documentUrl' | 'exempt' | 'platform' | 'uploadedDate' | 'usesEncryption'>, _options?: Configuration): Observable<AppEncryptionDeclarationWithoutIncludesResponse> {
        return this.buildsAppEncryptionDeclarationGetToOneRelatedWithHttpInfo(id, fieldsAppEncryptionDeclarations, _options).pipe(map((apiResponse: HttpInfo<AppEncryptionDeclarationWithoutIncludesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public buildsAppEncryptionDeclarationGetToOneRelationshipWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<BuildAppEncryptionDeclarationLinkageResponse>> {
        const requestContextPromise = this.requestFactory.buildsAppEncryptionDeclarationGetToOneRelationship(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.buildsAppEncryptionDeclarationGetToOneRelationshipWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public buildsAppEncryptionDeclarationGetToOneRelationship(id: string, _options?: Configuration): Observable<BuildAppEncryptionDeclarationLinkageResponse> {
        return this.buildsAppEncryptionDeclarationGetToOneRelationshipWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<BuildAppEncryptionDeclarationLinkageResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param buildAppEncryptionDeclarationLinkageRequest Related linkage
     */
    public buildsAppEncryptionDeclarationUpdateToOneRelationshipWithHttpInfo(id: string, buildAppEncryptionDeclarationLinkageRequest: BuildAppEncryptionDeclarationLinkageRequest, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.buildsAppEncryptionDeclarationUpdateToOneRelationship(id, buildAppEncryptionDeclarationLinkageRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.buildsAppEncryptionDeclarationUpdateToOneRelationshipWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param buildAppEncryptionDeclarationLinkageRequest Related linkage
     */
    public buildsAppEncryptionDeclarationUpdateToOneRelationship(id: string, buildAppEncryptionDeclarationLinkageRequest: BuildAppEncryptionDeclarationLinkageRequest, _options?: Configuration): Observable<void> {
        return this.buildsAppEncryptionDeclarationUpdateToOneRelationshipWithHttpInfo(id, buildAppEncryptionDeclarationLinkageRequest, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsApps the fields to include for returned resources of type apps
     */
    public buildsAppGetToOneRelatedWithHttpInfo(id: string, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, _options?: Configuration): Observable<HttpInfo<AppWithoutIncludesResponse>> {
        const requestContextPromise = this.requestFactory.buildsAppGetToOneRelated(id, fieldsApps, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.buildsAppGetToOneRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsApps the fields to include for returned resources of type apps
     */
    public buildsAppGetToOneRelated(id: string, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, _options?: Configuration): Observable<AppWithoutIncludesResponse> {
        return this.buildsAppGetToOneRelatedWithHttpInfo(id, fieldsApps, _options).pipe(map((apiResponse: HttpInfo<AppWithoutIncludesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAgeRatingDeclarations the fields to include for returned resources of type ageRatingDeclarations
     * @param fieldsAppStoreReviewDetails the fields to include for returned resources of type appStoreReviewDetails
     * @param fieldsAppStoreVersionLocalizations the fields to include for returned resources of type appStoreVersionLocalizations
     * @param fieldsAppStoreVersionExperiments the fields to include for returned resources of type appStoreVersionExperiments
     * @param fieldsAppStoreVersionSubmissions the fields to include for returned resources of type appStoreVersionSubmissions
     * @param fieldsAlternativeDistributionPackages the fields to include for returned resources of type alternativeDistributionPackages
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsRoutingAppCoverages the fields to include for returned resources of type routingAppCoverages
     * @param fieldsAppClipDefaultExperiences the fields to include for returned resources of type appClipDefaultExperiences
     * @param fieldsAppStoreVersionPhasedReleases the fields to include for returned resources of type appStoreVersionPhasedReleases
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param limitAppStoreVersionLocalizations maximum number of related appStoreVersionLocalizations returned (when they are included)
     * @param limitAppStoreVersionExperiments maximum number of related appStoreVersionExperiments returned (when they are included)
     * @param limitAppStoreVersionExperimentsV2 maximum number of related appStoreVersionExperimentsV2 returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public buildsAppStoreVersionGetToOneRelatedWithHttpInfo(id: string, fieldsAgeRatingDeclarations?: Array<'ageRatingOverride' | 'alcoholTobaccoOrDrugUseOrReferences' | 'contests' | 'gambling' | 'gamblingAndContests' | 'gamblingSimulated' | 'horrorOrFearThemes' | 'kidsAgeBand' | 'matureOrSuggestiveThemes' | 'medicalOrTreatmentInformation' | 'profanityOrCrudeHumor' | 'seventeenPlus' | 'sexualContentGraphicAndNudity' | 'sexualContentOrNudity' | 'unrestrictedWebAccess' | 'violenceCartoonOrFantasy' | 'violenceRealistic' | 'violenceRealisticProlongedGraphicOrSadistic'>, fieldsAppStoreReviewDetails?: Array<'appStoreReviewAttachments' | 'appStoreVersion' | 'contactEmail' | 'contactFirstName' | 'contactLastName' | 'contactPhone' | 'demoAccountName' | 'demoAccountPassword' | 'demoAccountRequired' | 'notes'>, fieldsAppStoreVersionLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersion' | 'description' | 'keywords' | 'locale' | 'marketingUrl' | 'promotionalText' | 'supportUrl' | 'whatsNew'>, fieldsAppStoreVersionExperiments?: Array<'app' | 'appStoreVersion' | 'appStoreVersionExperimentTreatments' | 'controlVersions' | 'endDate' | 'latestControlVersion' | 'name' | 'platform' | 'reviewRequired' | 'startDate' | 'started' | 'state' | 'trafficProportion'>, fieldsAppStoreVersionSubmissions?: Array<'appStoreVersion'>, fieldsAlternativeDistributionPackages?: Array<'appStoreVersion' | 'versions'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsRoutingAppCoverages?: Array<'appStoreVersion' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, fieldsAppClipDefaultExperiences?: Array<'action' | 'appClip' | 'appClipAppStoreReviewDetail' | 'appClipDefaultExperienceLocalizations' | 'appClipDefaultExperienceTemplate' | 'releaseWithAppStoreVersion'>, fieldsAppStoreVersionPhasedReleases?: Array<'appStoreVersion' | 'currentDayNumber' | 'phasedReleaseState' | 'startDate' | 'totalPauseDuration'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, limitAppStoreVersionLocalizations?: number, limitAppStoreVersionExperiments?: number, limitAppStoreVersionExperimentsV2?: number, include?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'build' | 'routingAppCoverage'>, _options?: Configuration): Observable<HttpInfo<AppStoreVersionResponse>> {
        const requestContextPromise = this.requestFactory.buildsAppStoreVersionGetToOneRelated(id, fieldsAgeRatingDeclarations, fieldsAppStoreReviewDetails, fieldsAppStoreVersionLocalizations, fieldsAppStoreVersionExperiments, fieldsAppStoreVersionSubmissions, fieldsAlternativeDistributionPackages, fieldsAppStoreVersions, fieldsApps, fieldsRoutingAppCoverages, fieldsAppClipDefaultExperiences, fieldsAppStoreVersionPhasedReleases, fieldsBuilds, limitAppStoreVersionLocalizations, limitAppStoreVersionExperiments, limitAppStoreVersionExperimentsV2, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.buildsAppStoreVersionGetToOneRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAgeRatingDeclarations the fields to include for returned resources of type ageRatingDeclarations
     * @param fieldsAppStoreReviewDetails the fields to include for returned resources of type appStoreReviewDetails
     * @param fieldsAppStoreVersionLocalizations the fields to include for returned resources of type appStoreVersionLocalizations
     * @param fieldsAppStoreVersionExperiments the fields to include for returned resources of type appStoreVersionExperiments
     * @param fieldsAppStoreVersionSubmissions the fields to include for returned resources of type appStoreVersionSubmissions
     * @param fieldsAlternativeDistributionPackages the fields to include for returned resources of type alternativeDistributionPackages
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsRoutingAppCoverages the fields to include for returned resources of type routingAppCoverages
     * @param fieldsAppClipDefaultExperiences the fields to include for returned resources of type appClipDefaultExperiences
     * @param fieldsAppStoreVersionPhasedReleases the fields to include for returned resources of type appStoreVersionPhasedReleases
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param limitAppStoreVersionLocalizations maximum number of related appStoreVersionLocalizations returned (when they are included)
     * @param limitAppStoreVersionExperiments maximum number of related appStoreVersionExperiments returned (when they are included)
     * @param limitAppStoreVersionExperimentsV2 maximum number of related appStoreVersionExperimentsV2 returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public buildsAppStoreVersionGetToOneRelated(id: string, fieldsAgeRatingDeclarations?: Array<'ageRatingOverride' | 'alcoholTobaccoOrDrugUseOrReferences' | 'contests' | 'gambling' | 'gamblingAndContests' | 'gamblingSimulated' | 'horrorOrFearThemes' | 'kidsAgeBand' | 'matureOrSuggestiveThemes' | 'medicalOrTreatmentInformation' | 'profanityOrCrudeHumor' | 'seventeenPlus' | 'sexualContentGraphicAndNudity' | 'sexualContentOrNudity' | 'unrestrictedWebAccess' | 'violenceCartoonOrFantasy' | 'violenceRealistic' | 'violenceRealisticProlongedGraphicOrSadistic'>, fieldsAppStoreReviewDetails?: Array<'appStoreReviewAttachments' | 'appStoreVersion' | 'contactEmail' | 'contactFirstName' | 'contactLastName' | 'contactPhone' | 'demoAccountName' | 'demoAccountPassword' | 'demoAccountRequired' | 'notes'>, fieldsAppStoreVersionLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersion' | 'description' | 'keywords' | 'locale' | 'marketingUrl' | 'promotionalText' | 'supportUrl' | 'whatsNew'>, fieldsAppStoreVersionExperiments?: Array<'app' | 'appStoreVersion' | 'appStoreVersionExperimentTreatments' | 'controlVersions' | 'endDate' | 'latestControlVersion' | 'name' | 'platform' | 'reviewRequired' | 'startDate' | 'started' | 'state' | 'trafficProportion'>, fieldsAppStoreVersionSubmissions?: Array<'appStoreVersion'>, fieldsAlternativeDistributionPackages?: Array<'appStoreVersion' | 'versions'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsRoutingAppCoverages?: Array<'appStoreVersion' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, fieldsAppClipDefaultExperiences?: Array<'action' | 'appClip' | 'appClipAppStoreReviewDetail' | 'appClipDefaultExperienceLocalizations' | 'appClipDefaultExperienceTemplate' | 'releaseWithAppStoreVersion'>, fieldsAppStoreVersionPhasedReleases?: Array<'appStoreVersion' | 'currentDayNumber' | 'phasedReleaseState' | 'startDate' | 'totalPauseDuration'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, limitAppStoreVersionLocalizations?: number, limitAppStoreVersionExperiments?: number, limitAppStoreVersionExperimentsV2?: number, include?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'build' | 'routingAppCoverage'>, _options?: Configuration): Observable<AppStoreVersionResponse> {
        return this.buildsAppStoreVersionGetToOneRelatedWithHttpInfo(id, fieldsAgeRatingDeclarations, fieldsAppStoreReviewDetails, fieldsAppStoreVersionLocalizations, fieldsAppStoreVersionExperiments, fieldsAppStoreVersionSubmissions, fieldsAlternativeDistributionPackages, fieldsAppStoreVersions, fieldsApps, fieldsRoutingAppCoverages, fieldsAppClipDefaultExperiences, fieldsAppStoreVersionPhasedReleases, fieldsBuilds, limitAppStoreVersionLocalizations, limitAppStoreVersionExperiments, limitAppStoreVersionExperimentsV2, include, _options).pipe(map((apiResponse: HttpInfo<AppStoreVersionResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBetaAppReviewSubmissions the fields to include for returned resources of type betaAppReviewSubmissions
     */
    public buildsBetaAppReviewSubmissionGetToOneRelatedWithHttpInfo(id: string, fieldsBetaAppReviewSubmissions?: Array<'betaReviewState' | 'build' | 'submittedDate'>, _options?: Configuration): Observable<HttpInfo<BetaAppReviewSubmissionWithoutIncludesResponse>> {
        const requestContextPromise = this.requestFactory.buildsBetaAppReviewSubmissionGetToOneRelated(id, fieldsBetaAppReviewSubmissions, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.buildsBetaAppReviewSubmissionGetToOneRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBetaAppReviewSubmissions the fields to include for returned resources of type betaAppReviewSubmissions
     */
    public buildsBetaAppReviewSubmissionGetToOneRelated(id: string, fieldsBetaAppReviewSubmissions?: Array<'betaReviewState' | 'build' | 'submittedDate'>, _options?: Configuration): Observable<BetaAppReviewSubmissionWithoutIncludesResponse> {
        return this.buildsBetaAppReviewSubmissionGetToOneRelatedWithHttpInfo(id, fieldsBetaAppReviewSubmissions, _options).pipe(map((apiResponse: HttpInfo<BetaAppReviewSubmissionWithoutIncludesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBetaBuildLocalizations the fields to include for returned resources of type betaBuildLocalizations
     * @param limit maximum resources per page
     */
    public buildsBetaBuildLocalizationsGetToManyRelatedWithHttpInfo(id: string, fieldsBetaBuildLocalizations?: Array<'build' | 'locale' | 'whatsNew'>, limit?: number, _options?: Configuration): Observable<HttpInfo<BetaBuildLocalizationsWithoutIncludesResponse>> {
        const requestContextPromise = this.requestFactory.buildsBetaBuildLocalizationsGetToManyRelated(id, fieldsBetaBuildLocalizations, limit, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.buildsBetaBuildLocalizationsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBetaBuildLocalizations the fields to include for returned resources of type betaBuildLocalizations
     * @param limit maximum resources per page
     */
    public buildsBetaBuildLocalizationsGetToManyRelated(id: string, fieldsBetaBuildLocalizations?: Array<'build' | 'locale' | 'whatsNew'>, limit?: number, _options?: Configuration): Observable<BetaBuildLocalizationsWithoutIncludesResponse> {
        return this.buildsBetaBuildLocalizationsGetToManyRelatedWithHttpInfo(id, fieldsBetaBuildLocalizations, limit, _options).pipe(map((apiResponse: HttpInfo<BetaBuildLocalizationsWithoutIncludesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum number of groups to return per page
     */
    public buildsBetaBuildUsagesGetMetricsWithHttpInfo(id: string, limit?: number, _options?: Configuration): Observable<HttpInfo<BetaBuildUsagesV1MetricResponse>> {
        const requestContextPromise = this.requestFactory.buildsBetaBuildUsagesGetMetrics(id, limit, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.buildsBetaBuildUsagesGetMetricsWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum number of groups to return per page
     */
    public buildsBetaBuildUsagesGetMetrics(id: string, limit?: number, _options?: Configuration): Observable<BetaBuildUsagesV1MetricResponse> {
        return this.buildsBetaBuildUsagesGetMetricsWithHttpInfo(id, limit, _options).pipe(map((apiResponse: HttpInfo<BetaBuildUsagesV1MetricResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param buildBetaGroupsLinkagesRequest List of related linkages
     */
    public buildsBetaGroupsCreateToManyRelationshipWithHttpInfo(id: string, buildBetaGroupsLinkagesRequest: BuildBetaGroupsLinkagesRequest, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.buildsBetaGroupsCreateToManyRelationship(id, buildBetaGroupsLinkagesRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.buildsBetaGroupsCreateToManyRelationshipWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param buildBetaGroupsLinkagesRequest List of related linkages
     */
    public buildsBetaGroupsCreateToManyRelationship(id: string, buildBetaGroupsLinkagesRequest: BuildBetaGroupsLinkagesRequest, _options?: Configuration): Observable<void> {
        return this.buildsBetaGroupsCreateToManyRelationshipWithHttpInfo(id, buildBetaGroupsLinkagesRequest, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param buildBetaGroupsLinkagesRequest List of related linkages
     */
    public buildsBetaGroupsDeleteToManyRelationshipWithHttpInfo(id: string, buildBetaGroupsLinkagesRequest: BuildBetaGroupsLinkagesRequest, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.buildsBetaGroupsDeleteToManyRelationship(id, buildBetaGroupsLinkagesRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.buildsBetaGroupsDeleteToManyRelationshipWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param buildBetaGroupsLinkagesRequest List of related linkages
     */
    public buildsBetaGroupsDeleteToManyRelationship(id: string, buildBetaGroupsLinkagesRequest: BuildBetaGroupsLinkagesRequest, _options?: Configuration): Observable<void> {
        return this.buildsBetaGroupsDeleteToManyRelationshipWithHttpInfo(id, buildBetaGroupsLinkagesRequest, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBuildBetaDetails the fields to include for returned resources of type buildBetaDetails
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param include comma-separated list of relationships to include
     */
    public buildsBuildBetaDetailGetToOneRelatedWithHttpInfo(id: string, fieldsBuildBetaDetails?: Array<'autoNotifyEnabled' | 'build' | 'externalBuildState' | 'internalBuildState'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, include?: Array<'build'>, _options?: Configuration): Observable<HttpInfo<BuildBetaDetailResponse>> {
        const requestContextPromise = this.requestFactory.buildsBuildBetaDetailGetToOneRelated(id, fieldsBuildBetaDetails, fieldsBuilds, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.buildsBuildBetaDetailGetToOneRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBuildBetaDetails the fields to include for returned resources of type buildBetaDetails
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param include comma-separated list of relationships to include
     */
    public buildsBuildBetaDetailGetToOneRelated(id: string, fieldsBuildBetaDetails?: Array<'autoNotifyEnabled' | 'build' | 'externalBuildState' | 'internalBuildState'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, include?: Array<'build'>, _options?: Configuration): Observable<BuildBetaDetailResponse> {
        return this.buildsBuildBetaDetailGetToOneRelatedWithHttpInfo(id, fieldsBuildBetaDetails, fieldsBuilds, include, _options).pipe(map((apiResponse: HttpInfo<BuildBetaDetailResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param filterDiagnosticType filter by attribute \&#39;diagnosticType\&#39;
     * @param fieldsDiagnosticSignatures the fields to include for returned resources of type diagnosticSignatures
     * @param limit maximum resources per page
     */
    public buildsDiagnosticSignaturesGetToManyRelatedWithHttpInfo(id: string, filterDiagnosticType?: Array<'DISK_WRITES' | 'HANGS'>, fieldsDiagnosticSignatures?: Array<'diagnosticType' | 'logs' | 'signature' | 'weight'>, limit?: number, _options?: Configuration): Observable<HttpInfo<DiagnosticSignaturesResponse>> {
        const requestContextPromise = this.requestFactory.buildsDiagnosticSignaturesGetToManyRelated(id, filterDiagnosticType, fieldsDiagnosticSignatures, limit, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.buildsDiagnosticSignaturesGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param filterDiagnosticType filter by attribute \&#39;diagnosticType\&#39;
     * @param fieldsDiagnosticSignatures the fields to include for returned resources of type diagnosticSignatures
     * @param limit maximum resources per page
     */
    public buildsDiagnosticSignaturesGetToManyRelated(id: string, filterDiagnosticType?: Array<'DISK_WRITES' | 'HANGS'>, fieldsDiagnosticSignatures?: Array<'diagnosticType' | 'logs' | 'signature' | 'weight'>, limit?: number, _options?: Configuration): Observable<DiagnosticSignaturesResponse> {
        return this.buildsDiagnosticSignaturesGetToManyRelatedWithHttpInfo(id, filterDiagnosticType, fieldsDiagnosticSignatures, limit, _options).pipe(map((apiResponse: HttpInfo<DiagnosticSignaturesResponse>) => apiResponse.data));
    }

    /**
     * @param filterBetaAppReviewSubmissionBetaReviewState filter by attribute \&#39;betaAppReviewSubmission.betaReviewState\&#39;
     * @param filterBuildAudienceType filter by attribute \&#39;buildAudienceType\&#39;
     * @param filterExpired filter by attribute \&#39;expired\&#39;
     * @param filterPreReleaseVersionPlatform filter by attribute \&#39;preReleaseVersion.platform\&#39;
     * @param filterPreReleaseVersionVersion filter by attribute \&#39;preReleaseVersion.version\&#39;
     * @param filterProcessingState filter by attribute \&#39;processingState\&#39;
     * @param filterUsesNonExemptEncryption filter by attribute \&#39;usesNonExemptEncryption\&#39;
     * @param filterVersion filter by attribute \&#39;version\&#39;
     * @param filterApp filter by id(s) of related \&#39;app\&#39;
     * @param filterAppStoreVersion filter by id(s) of related \&#39;appStoreVersion\&#39;
     * @param filterBetaGroups filter by id(s) of related \&#39;betaGroups\&#39;
     * @param filterPreReleaseVersion filter by id(s) of related \&#39;preReleaseVersion\&#39;
     * @param filterId filter by id(s)
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsDiagnosticSignatures the fields to include for returned resources of type diagnosticSignatures
     * @param fieldsBuildIcons the fields to include for returned resources of type buildIcons
     * @param fieldsBuildBetaDetails the fields to include for returned resources of type buildBetaDetails
     * @param fieldsBetaAppReviewSubmissions the fields to include for returned resources of type betaAppReviewSubmissions
     * @param fieldsBetaTesters the fields to include for returned resources of type betaTesters
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsBetaBuildLocalizations the fields to include for returned resources of type betaBuildLocalizations
     * @param fieldsPreReleaseVersions the fields to include for returned resources of type preReleaseVersions
     * @param fieldsAppEncryptionDeclarations the fields to include for returned resources of type appEncryptionDeclarations
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsPerfPowerMetrics the fields to include for returned resources of type perfPowerMetrics
     * @param limitBetaBuildLocalizations maximum number of related betaBuildLocalizations returned (when they are included)
     * @param limitBetaGroups maximum number of related betaGroups returned (when they are included)
     * @param limitBuildBundles maximum number of related buildBundles returned (when they are included)
     * @param limitIcons maximum number of related icons returned (when they are included)
     * @param limitIndividualTesters maximum number of related individualTesters returned (when they are included)
     */
    public buildsGetCollectionWithHttpInfo(filterBetaAppReviewSubmissionBetaReviewState?: Array<'WAITING_FOR_REVIEW' | 'IN_REVIEW' | 'REJECTED' | 'APPROVED'>, filterBuildAudienceType?: Array<'INTERNAL_ONLY' | 'APP_STORE_ELIGIBLE'>, filterExpired?: Array<string>, filterPreReleaseVersionPlatform?: Array<'IOS' | 'MAC_OS' | 'TV_OS' | 'VISION_OS'>, filterPreReleaseVersionVersion?: Array<string>, filterProcessingState?: Array<'PROCESSING' | 'FAILED' | 'INVALID' | 'VALID'>, filterUsesNonExemptEncryption?: Array<string>, filterVersion?: Array<string>, filterApp?: Array<string>, filterAppStoreVersion?: Array<string>, filterBetaGroups?: Array<string>, filterPreReleaseVersion?: Array<string>, filterId?: Array<string>, sort?: Array<'preReleaseVersion' | '-preReleaseVersion' | 'uploadedDate' | '-uploadedDate' | 'version' | '-version'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, limit?: number, include?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildBetaDetail' | 'buildBundles' | 'icons' | 'individualTesters' | 'preReleaseVersion'>, fieldsDiagnosticSignatures?: Array<'diagnosticType' | 'logs' | 'signature' | 'weight'>, fieldsBuildIcons?: Array<'iconAsset' | 'iconType' | 'name'>, fieldsBuildBetaDetails?: Array<'autoNotifyEnabled' | 'build' | 'externalBuildState' | 'internalBuildState'>, fieldsBetaAppReviewSubmissions?: Array<'betaReviewState' | 'build' | 'submittedDate'>, fieldsBetaTesters?: Array<'apps' | 'betaGroups' | 'builds' | 'email' | 'firstName' | 'inviteType' | 'lastName'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsBetaBuildLocalizations?: Array<'build' | 'locale' | 'whatsNew'>, fieldsPreReleaseVersions?: Array<'app' | 'builds' | 'platform' | 'version'>, fieldsAppEncryptionDeclarations?: Array<'app' | 'appDescription' | 'appEncryptionDeclarationDocument' | 'appEncryptionDeclarationState' | 'availableOnFrenchStore' | 'builds' | 'codeValue' | 'containsProprietaryCryptography' | 'containsThirdPartyCryptography' | 'createdDate' | 'documentName' | 'documentType' | 'documentUrl' | 'exempt' | 'platform' | 'uploadedDate' | 'usesEncryption'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsPerfPowerMetrics?: Array<'deviceType' | 'metricType' | 'platform'>, limitBetaBuildLocalizations?: number, limitBetaGroups?: number, limitBuildBundles?: number, limitIcons?: number, limitIndividualTesters?: number, _options?: Configuration): Observable<HttpInfo<BuildsResponse>> {
        const requestContextPromise = this.requestFactory.buildsGetCollection(filterBetaAppReviewSubmissionBetaReviewState, filterBuildAudienceType, filterExpired, filterPreReleaseVersionPlatform, filterPreReleaseVersionVersion, filterProcessingState, filterUsesNonExemptEncryption, filterVersion, filterApp, filterAppStoreVersion, filterBetaGroups, filterPreReleaseVersion, filterId, sort, fieldsBuilds, limit, include, fieldsDiagnosticSignatures, fieldsBuildIcons, fieldsBuildBetaDetails, fieldsBetaAppReviewSubmissions, fieldsBetaTesters, fieldsAppStoreVersions, fieldsBetaBuildLocalizations, fieldsPreReleaseVersions, fieldsAppEncryptionDeclarations, fieldsApps, fieldsPerfPowerMetrics, limitBetaBuildLocalizations, limitBetaGroups, limitBuildBundles, limitIcons, limitIndividualTesters, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.buildsGetCollectionWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param filterBetaAppReviewSubmissionBetaReviewState filter by attribute \&#39;betaAppReviewSubmission.betaReviewState\&#39;
     * @param filterBuildAudienceType filter by attribute \&#39;buildAudienceType\&#39;
     * @param filterExpired filter by attribute \&#39;expired\&#39;
     * @param filterPreReleaseVersionPlatform filter by attribute \&#39;preReleaseVersion.platform\&#39;
     * @param filterPreReleaseVersionVersion filter by attribute \&#39;preReleaseVersion.version\&#39;
     * @param filterProcessingState filter by attribute \&#39;processingState\&#39;
     * @param filterUsesNonExemptEncryption filter by attribute \&#39;usesNonExemptEncryption\&#39;
     * @param filterVersion filter by attribute \&#39;version\&#39;
     * @param filterApp filter by id(s) of related \&#39;app\&#39;
     * @param filterAppStoreVersion filter by id(s) of related \&#39;appStoreVersion\&#39;
     * @param filterBetaGroups filter by id(s) of related \&#39;betaGroups\&#39;
     * @param filterPreReleaseVersion filter by id(s) of related \&#39;preReleaseVersion\&#39;
     * @param filterId filter by id(s)
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsDiagnosticSignatures the fields to include for returned resources of type diagnosticSignatures
     * @param fieldsBuildIcons the fields to include for returned resources of type buildIcons
     * @param fieldsBuildBetaDetails the fields to include for returned resources of type buildBetaDetails
     * @param fieldsBetaAppReviewSubmissions the fields to include for returned resources of type betaAppReviewSubmissions
     * @param fieldsBetaTesters the fields to include for returned resources of type betaTesters
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsBetaBuildLocalizations the fields to include for returned resources of type betaBuildLocalizations
     * @param fieldsPreReleaseVersions the fields to include for returned resources of type preReleaseVersions
     * @param fieldsAppEncryptionDeclarations the fields to include for returned resources of type appEncryptionDeclarations
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsPerfPowerMetrics the fields to include for returned resources of type perfPowerMetrics
     * @param limitBetaBuildLocalizations maximum number of related betaBuildLocalizations returned (when they are included)
     * @param limitBetaGroups maximum number of related betaGroups returned (when they are included)
     * @param limitBuildBundles maximum number of related buildBundles returned (when they are included)
     * @param limitIcons maximum number of related icons returned (when they are included)
     * @param limitIndividualTesters maximum number of related individualTesters returned (when they are included)
     */
    public buildsGetCollection(filterBetaAppReviewSubmissionBetaReviewState?: Array<'WAITING_FOR_REVIEW' | 'IN_REVIEW' | 'REJECTED' | 'APPROVED'>, filterBuildAudienceType?: Array<'INTERNAL_ONLY' | 'APP_STORE_ELIGIBLE'>, filterExpired?: Array<string>, filterPreReleaseVersionPlatform?: Array<'IOS' | 'MAC_OS' | 'TV_OS' | 'VISION_OS'>, filterPreReleaseVersionVersion?: Array<string>, filterProcessingState?: Array<'PROCESSING' | 'FAILED' | 'INVALID' | 'VALID'>, filterUsesNonExemptEncryption?: Array<string>, filterVersion?: Array<string>, filterApp?: Array<string>, filterAppStoreVersion?: Array<string>, filterBetaGroups?: Array<string>, filterPreReleaseVersion?: Array<string>, filterId?: Array<string>, sort?: Array<'preReleaseVersion' | '-preReleaseVersion' | 'uploadedDate' | '-uploadedDate' | 'version' | '-version'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, limit?: number, include?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildBetaDetail' | 'buildBundles' | 'icons' | 'individualTesters' | 'preReleaseVersion'>, fieldsDiagnosticSignatures?: Array<'diagnosticType' | 'logs' | 'signature' | 'weight'>, fieldsBuildIcons?: Array<'iconAsset' | 'iconType' | 'name'>, fieldsBuildBetaDetails?: Array<'autoNotifyEnabled' | 'build' | 'externalBuildState' | 'internalBuildState'>, fieldsBetaAppReviewSubmissions?: Array<'betaReviewState' | 'build' | 'submittedDate'>, fieldsBetaTesters?: Array<'apps' | 'betaGroups' | 'builds' | 'email' | 'firstName' | 'inviteType' | 'lastName'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsBetaBuildLocalizations?: Array<'build' | 'locale' | 'whatsNew'>, fieldsPreReleaseVersions?: Array<'app' | 'builds' | 'platform' | 'version'>, fieldsAppEncryptionDeclarations?: Array<'app' | 'appDescription' | 'appEncryptionDeclarationDocument' | 'appEncryptionDeclarationState' | 'availableOnFrenchStore' | 'builds' | 'codeValue' | 'containsProprietaryCryptography' | 'containsThirdPartyCryptography' | 'createdDate' | 'documentName' | 'documentType' | 'documentUrl' | 'exempt' | 'platform' | 'uploadedDate' | 'usesEncryption'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsPerfPowerMetrics?: Array<'deviceType' | 'metricType' | 'platform'>, limitBetaBuildLocalizations?: number, limitBetaGroups?: number, limitBuildBundles?: number, limitIcons?: number, limitIndividualTesters?: number, _options?: Configuration): Observable<BuildsResponse> {
        return this.buildsGetCollectionWithHttpInfo(filterBetaAppReviewSubmissionBetaReviewState, filterBuildAudienceType, filterExpired, filterPreReleaseVersionPlatform, filterPreReleaseVersionVersion, filterProcessingState, filterUsesNonExemptEncryption, filterVersion, filterApp, filterAppStoreVersion, filterBetaGroups, filterPreReleaseVersion, filterId, sort, fieldsBuilds, limit, include, fieldsDiagnosticSignatures, fieldsBuildIcons, fieldsBuildBetaDetails, fieldsBetaAppReviewSubmissions, fieldsBetaTesters, fieldsAppStoreVersions, fieldsBetaBuildLocalizations, fieldsPreReleaseVersions, fieldsAppEncryptionDeclarations, fieldsApps, fieldsPerfPowerMetrics, limitBetaBuildLocalizations, limitBetaGroups, limitBuildBundles, limitIcons, limitIndividualTesters, _options).pipe(map((apiResponse: HttpInfo<BuildsResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param include comma-separated list of relationships to include
     * @param fieldsDiagnosticSignatures the fields to include for returned resources of type diagnosticSignatures
     * @param fieldsBuildIcons the fields to include for returned resources of type buildIcons
     * @param fieldsBuildBetaDetails the fields to include for returned resources of type buildBetaDetails
     * @param fieldsBetaAppReviewSubmissions the fields to include for returned resources of type betaAppReviewSubmissions
     * @param fieldsBetaTesters the fields to include for returned resources of type betaTesters
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsBetaBuildLocalizations the fields to include for returned resources of type betaBuildLocalizations
     * @param fieldsPreReleaseVersions the fields to include for returned resources of type preReleaseVersions
     * @param fieldsAppEncryptionDeclarations the fields to include for returned resources of type appEncryptionDeclarations
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsPerfPowerMetrics the fields to include for returned resources of type perfPowerMetrics
     * @param limitBetaBuildLocalizations maximum number of related betaBuildLocalizations returned (when they are included)
     * @param limitBetaGroups maximum number of related betaGroups returned (when they are included)
     * @param limitBuildBundles maximum number of related buildBundles returned (when they are included)
     * @param limitIcons maximum number of related icons returned (when they are included)
     * @param limitIndividualTesters maximum number of related individualTesters returned (when they are included)
     */
    public buildsGetInstanceWithHttpInfo(id: string, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, include?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildBetaDetail' | 'buildBundles' | 'icons' | 'individualTesters' | 'preReleaseVersion'>, fieldsDiagnosticSignatures?: Array<'diagnosticType' | 'logs' | 'signature' | 'weight'>, fieldsBuildIcons?: Array<'iconAsset' | 'iconType' | 'name'>, fieldsBuildBetaDetails?: Array<'autoNotifyEnabled' | 'build' | 'externalBuildState' | 'internalBuildState'>, fieldsBetaAppReviewSubmissions?: Array<'betaReviewState' | 'build' | 'submittedDate'>, fieldsBetaTesters?: Array<'apps' | 'betaGroups' | 'builds' | 'email' | 'firstName' | 'inviteType' | 'lastName'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsBetaBuildLocalizations?: Array<'build' | 'locale' | 'whatsNew'>, fieldsPreReleaseVersions?: Array<'app' | 'builds' | 'platform' | 'version'>, fieldsAppEncryptionDeclarations?: Array<'app' | 'appDescription' | 'appEncryptionDeclarationDocument' | 'appEncryptionDeclarationState' | 'availableOnFrenchStore' | 'builds' | 'codeValue' | 'containsProprietaryCryptography' | 'containsThirdPartyCryptography' | 'createdDate' | 'documentName' | 'documentType' | 'documentUrl' | 'exempt' | 'platform' | 'uploadedDate' | 'usesEncryption'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsPerfPowerMetrics?: Array<'deviceType' | 'metricType' | 'platform'>, limitBetaBuildLocalizations?: number, limitBetaGroups?: number, limitBuildBundles?: number, limitIcons?: number, limitIndividualTesters?: number, _options?: Configuration): Observable<HttpInfo<BuildResponse>> {
        const requestContextPromise = this.requestFactory.buildsGetInstance(id, fieldsBuilds, include, fieldsDiagnosticSignatures, fieldsBuildIcons, fieldsBuildBetaDetails, fieldsBetaAppReviewSubmissions, fieldsBetaTesters, fieldsAppStoreVersions, fieldsBetaBuildLocalizations, fieldsPreReleaseVersions, fieldsAppEncryptionDeclarations, fieldsApps, fieldsPerfPowerMetrics, limitBetaBuildLocalizations, limitBetaGroups, limitBuildBundles, limitIcons, limitIndividualTesters, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.buildsGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param include comma-separated list of relationships to include
     * @param fieldsDiagnosticSignatures the fields to include for returned resources of type diagnosticSignatures
     * @param fieldsBuildIcons the fields to include for returned resources of type buildIcons
     * @param fieldsBuildBetaDetails the fields to include for returned resources of type buildBetaDetails
     * @param fieldsBetaAppReviewSubmissions the fields to include for returned resources of type betaAppReviewSubmissions
     * @param fieldsBetaTesters the fields to include for returned resources of type betaTesters
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsBetaBuildLocalizations the fields to include for returned resources of type betaBuildLocalizations
     * @param fieldsPreReleaseVersions the fields to include for returned resources of type preReleaseVersions
     * @param fieldsAppEncryptionDeclarations the fields to include for returned resources of type appEncryptionDeclarations
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsPerfPowerMetrics the fields to include for returned resources of type perfPowerMetrics
     * @param limitBetaBuildLocalizations maximum number of related betaBuildLocalizations returned (when they are included)
     * @param limitBetaGroups maximum number of related betaGroups returned (when they are included)
     * @param limitBuildBundles maximum number of related buildBundles returned (when they are included)
     * @param limitIcons maximum number of related icons returned (when they are included)
     * @param limitIndividualTesters maximum number of related individualTesters returned (when they are included)
     */
    public buildsGetInstance(id: string, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, include?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildBetaDetail' | 'buildBundles' | 'icons' | 'individualTesters' | 'preReleaseVersion'>, fieldsDiagnosticSignatures?: Array<'diagnosticType' | 'logs' | 'signature' | 'weight'>, fieldsBuildIcons?: Array<'iconAsset' | 'iconType' | 'name'>, fieldsBuildBetaDetails?: Array<'autoNotifyEnabled' | 'build' | 'externalBuildState' | 'internalBuildState'>, fieldsBetaAppReviewSubmissions?: Array<'betaReviewState' | 'build' | 'submittedDate'>, fieldsBetaTesters?: Array<'apps' | 'betaGroups' | 'builds' | 'email' | 'firstName' | 'inviteType' | 'lastName'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsBetaBuildLocalizations?: Array<'build' | 'locale' | 'whatsNew'>, fieldsPreReleaseVersions?: Array<'app' | 'builds' | 'platform' | 'version'>, fieldsAppEncryptionDeclarations?: Array<'app' | 'appDescription' | 'appEncryptionDeclarationDocument' | 'appEncryptionDeclarationState' | 'availableOnFrenchStore' | 'builds' | 'codeValue' | 'containsProprietaryCryptography' | 'containsThirdPartyCryptography' | 'createdDate' | 'documentName' | 'documentType' | 'documentUrl' | 'exempt' | 'platform' | 'uploadedDate' | 'usesEncryption'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsPerfPowerMetrics?: Array<'deviceType' | 'metricType' | 'platform'>, limitBetaBuildLocalizations?: number, limitBetaGroups?: number, limitBuildBundles?: number, limitIcons?: number, limitIndividualTesters?: number, _options?: Configuration): Observable<BuildResponse> {
        return this.buildsGetInstanceWithHttpInfo(id, fieldsBuilds, include, fieldsDiagnosticSignatures, fieldsBuildIcons, fieldsBuildBetaDetails, fieldsBetaAppReviewSubmissions, fieldsBetaTesters, fieldsAppStoreVersions, fieldsBetaBuildLocalizations, fieldsPreReleaseVersions, fieldsAppEncryptionDeclarations, fieldsApps, fieldsPerfPowerMetrics, limitBetaBuildLocalizations, limitBetaGroups, limitBuildBundles, limitIcons, limitIndividualTesters, _options).pipe(map((apiResponse: HttpInfo<BuildResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBuildIcons the fields to include for returned resources of type buildIcons
     * @param limit maximum resources per page
     */
    public buildsIconsGetToManyRelatedWithHttpInfo(id: string, fieldsBuildIcons?: Array<'iconAsset' | 'iconType' | 'name'>, limit?: number, _options?: Configuration): Observable<HttpInfo<BuildIconsWithoutIncludesResponse>> {
        const requestContextPromise = this.requestFactory.buildsIconsGetToManyRelated(id, fieldsBuildIcons, limit, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.buildsIconsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBuildIcons the fields to include for returned resources of type buildIcons
     * @param limit maximum resources per page
     */
    public buildsIconsGetToManyRelated(id: string, fieldsBuildIcons?: Array<'iconAsset' | 'iconType' | 'name'>, limit?: number, _options?: Configuration): Observable<BuildIconsWithoutIncludesResponse> {
        return this.buildsIconsGetToManyRelatedWithHttpInfo(id, fieldsBuildIcons, limit, _options).pipe(map((apiResponse: HttpInfo<BuildIconsWithoutIncludesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param buildIndividualTestersLinkagesRequest List of related linkages
     */
    public buildsIndividualTestersCreateToManyRelationshipWithHttpInfo(id: string, buildIndividualTestersLinkagesRequest: BuildIndividualTestersLinkagesRequest, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.buildsIndividualTestersCreateToManyRelationship(id, buildIndividualTestersLinkagesRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.buildsIndividualTestersCreateToManyRelationshipWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param buildIndividualTestersLinkagesRequest List of related linkages
     */
    public buildsIndividualTestersCreateToManyRelationship(id: string, buildIndividualTestersLinkagesRequest: BuildIndividualTestersLinkagesRequest, _options?: Configuration): Observable<void> {
        return this.buildsIndividualTestersCreateToManyRelationshipWithHttpInfo(id, buildIndividualTestersLinkagesRequest, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param buildIndividualTestersLinkagesRequest List of related linkages
     */
    public buildsIndividualTestersDeleteToManyRelationshipWithHttpInfo(id: string, buildIndividualTestersLinkagesRequest: BuildIndividualTestersLinkagesRequest, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.buildsIndividualTestersDeleteToManyRelationship(id, buildIndividualTestersLinkagesRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.buildsIndividualTestersDeleteToManyRelationshipWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param buildIndividualTestersLinkagesRequest List of related linkages
     */
    public buildsIndividualTestersDeleteToManyRelationship(id: string, buildIndividualTestersLinkagesRequest: BuildIndividualTestersLinkagesRequest, _options?: Configuration): Observable<void> {
        return this.buildsIndividualTestersDeleteToManyRelationshipWithHttpInfo(id, buildIndividualTestersLinkagesRequest, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBetaTesters the fields to include for returned resources of type betaTesters
     * @param limit maximum resources per page
     */
    public buildsIndividualTestersGetToManyRelatedWithHttpInfo(id: string, fieldsBetaTesters?: Array<'apps' | 'betaGroups' | 'builds' | 'email' | 'firstName' | 'inviteType' | 'lastName'>, limit?: number, _options?: Configuration): Observable<HttpInfo<BetaTestersWithoutIncludesResponse>> {
        const requestContextPromise = this.requestFactory.buildsIndividualTestersGetToManyRelated(id, fieldsBetaTesters, limit, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.buildsIndividualTestersGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBetaTesters the fields to include for returned resources of type betaTesters
     * @param limit maximum resources per page
     */
    public buildsIndividualTestersGetToManyRelated(id: string, fieldsBetaTesters?: Array<'apps' | 'betaGroups' | 'builds' | 'email' | 'firstName' | 'inviteType' | 'lastName'>, limit?: number, _options?: Configuration): Observable<BetaTestersWithoutIncludesResponse> {
        return this.buildsIndividualTestersGetToManyRelatedWithHttpInfo(id, fieldsBetaTesters, limit, _options).pipe(map((apiResponse: HttpInfo<BetaTestersWithoutIncludesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public buildsIndividualTestersGetToManyRelationshipWithHttpInfo(id: string, limit?: number, _options?: Configuration): Observable<HttpInfo<BuildIndividualTestersLinkagesResponse>> {
        const requestContextPromise = this.requestFactory.buildsIndividualTestersGetToManyRelationship(id, limit, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.buildsIndividualTestersGetToManyRelationshipWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public buildsIndividualTestersGetToManyRelationship(id: string, limit?: number, _options?: Configuration): Observable<BuildIndividualTestersLinkagesResponse> {
        return this.buildsIndividualTestersGetToManyRelationshipWithHttpInfo(id, limit, _options).pipe(map((apiResponse: HttpInfo<BuildIndividualTestersLinkagesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param filterDeviceType filter by attribute \&#39;deviceType\&#39;
     * @param filterMetricType filter by attribute \&#39;metricType\&#39;
     * @param filterPlatform filter by attribute \&#39;platform\&#39;
     */
    public buildsPerfPowerMetricsGetToManyRelatedWithHttpInfo(id: string, filterDeviceType?: Array<string>, filterMetricType?: Array<'DISK' | 'HANG' | 'BATTERY' | 'LAUNCH' | 'MEMORY' | 'ANIMATION' | 'TERMINATION'>, filterPlatform?: Array<'IOS'>, _options?: Configuration): Observable<HttpInfo<XcodeMetrics>> {
        const requestContextPromise = this.requestFactory.buildsPerfPowerMetricsGetToManyRelated(id, filterDeviceType, filterMetricType, filterPlatform, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.buildsPerfPowerMetricsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param filterDeviceType filter by attribute \&#39;deviceType\&#39;
     * @param filterMetricType filter by attribute \&#39;metricType\&#39;
     * @param filterPlatform filter by attribute \&#39;platform\&#39;
     */
    public buildsPerfPowerMetricsGetToManyRelated(id: string, filterDeviceType?: Array<string>, filterMetricType?: Array<'DISK' | 'HANG' | 'BATTERY' | 'LAUNCH' | 'MEMORY' | 'ANIMATION' | 'TERMINATION'>, filterPlatform?: Array<'IOS'>, _options?: Configuration): Observable<XcodeMetrics> {
        return this.buildsPerfPowerMetricsGetToManyRelatedWithHttpInfo(id, filterDeviceType, filterMetricType, filterPlatform, _options).pipe(map((apiResponse: HttpInfo<XcodeMetrics>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsPreReleaseVersions the fields to include for returned resources of type preReleaseVersions
     */
    public buildsPreReleaseVersionGetToOneRelatedWithHttpInfo(id: string, fieldsPreReleaseVersions?: Array<'app' | 'builds' | 'platform' | 'version'>, _options?: Configuration): Observable<HttpInfo<PrereleaseVersionWithoutIncludesResponse>> {
        const requestContextPromise = this.requestFactory.buildsPreReleaseVersionGetToOneRelated(id, fieldsPreReleaseVersions, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.buildsPreReleaseVersionGetToOneRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsPreReleaseVersions the fields to include for returned resources of type preReleaseVersions
     */
    public buildsPreReleaseVersionGetToOneRelated(id: string, fieldsPreReleaseVersions?: Array<'app' | 'builds' | 'platform' | 'version'>, _options?: Configuration): Observable<PrereleaseVersionWithoutIncludesResponse> {
        return this.buildsPreReleaseVersionGetToOneRelatedWithHttpInfo(id, fieldsPreReleaseVersions, _options).pipe(map((apiResponse: HttpInfo<PrereleaseVersionWithoutIncludesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param buildUpdateRequest Build representation
     */
    public buildsUpdateInstanceWithHttpInfo(id: string, buildUpdateRequest: BuildUpdateRequest, _options?: Configuration): Observable<HttpInfo<BuildResponse>> {
        const requestContextPromise = this.requestFactory.buildsUpdateInstance(id, buildUpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.buildsUpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param buildUpdateRequest Build representation
     */
    public buildsUpdateInstance(id: string, buildUpdateRequest: BuildUpdateRequest, _options?: Configuration): Observable<BuildResponse> {
        return this.buildsUpdateInstanceWithHttpInfo(id, buildUpdateRequest, _options).pipe(map((apiResponse: HttpInfo<BuildResponse>) => apiResponse.data));
    }

}

import { BundleIdCapabilitiesApiRequestFactory, BundleIdCapabilitiesApiResponseProcessor} from "../apis/BundleIdCapabilitiesApi.ts";
export class ObservableBundleIdCapabilitiesApi {
    private requestFactory: BundleIdCapabilitiesApiRequestFactory;
    private responseProcessor: BundleIdCapabilitiesApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: BundleIdCapabilitiesApiRequestFactory,
        responseProcessor?: BundleIdCapabilitiesApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new BundleIdCapabilitiesApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new BundleIdCapabilitiesApiResponseProcessor();
    }

    /**
     * @param bundleIdCapabilityCreateRequest BundleIdCapability representation
     */
    public bundleIdCapabilitiesCreateInstanceWithHttpInfo(bundleIdCapabilityCreateRequest: BundleIdCapabilityCreateRequest, _options?: Configuration): Observable<HttpInfo<BundleIdCapabilityResponse>> {
        const requestContextPromise = this.requestFactory.bundleIdCapabilitiesCreateInstance(bundleIdCapabilityCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.bundleIdCapabilitiesCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param bundleIdCapabilityCreateRequest BundleIdCapability representation
     */
    public bundleIdCapabilitiesCreateInstance(bundleIdCapabilityCreateRequest: BundleIdCapabilityCreateRequest, _options?: Configuration): Observable<BundleIdCapabilityResponse> {
        return this.bundleIdCapabilitiesCreateInstanceWithHttpInfo(bundleIdCapabilityCreateRequest, _options).pipe(map((apiResponse: HttpInfo<BundleIdCapabilityResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public bundleIdCapabilitiesDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.bundleIdCapabilitiesDeleteInstance(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.bundleIdCapabilitiesDeleteInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public bundleIdCapabilitiesDeleteInstance(id: string, _options?: Configuration): Observable<void> {
        return this.bundleIdCapabilitiesDeleteInstanceWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param bundleIdCapabilityUpdateRequest BundleIdCapability representation
     */
    public bundleIdCapabilitiesUpdateInstanceWithHttpInfo(id: string, bundleIdCapabilityUpdateRequest: BundleIdCapabilityUpdateRequest, _options?: Configuration): Observable<HttpInfo<BundleIdCapabilityResponse>> {
        const requestContextPromise = this.requestFactory.bundleIdCapabilitiesUpdateInstance(id, bundleIdCapabilityUpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.bundleIdCapabilitiesUpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param bundleIdCapabilityUpdateRequest BundleIdCapability representation
     */
    public bundleIdCapabilitiesUpdateInstance(id: string, bundleIdCapabilityUpdateRequest: BundleIdCapabilityUpdateRequest, _options?: Configuration): Observable<BundleIdCapabilityResponse> {
        return this.bundleIdCapabilitiesUpdateInstanceWithHttpInfo(id, bundleIdCapabilityUpdateRequest, _options).pipe(map((apiResponse: HttpInfo<BundleIdCapabilityResponse>) => apiResponse.data));
    }

}

import { BundleIdsApiRequestFactory, BundleIdsApiResponseProcessor} from "../apis/BundleIdsApi.ts";
export class ObservableBundleIdsApi {
    private requestFactory: BundleIdsApiRequestFactory;
    private responseProcessor: BundleIdsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: BundleIdsApiRequestFactory,
        responseProcessor?: BundleIdsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new BundleIdsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new BundleIdsApiResponseProcessor();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsApps the fields to include for returned resources of type apps
     */
    public bundleIdsAppGetToOneRelatedWithHttpInfo(id: string, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, _options?: Configuration): Observable<HttpInfo<AppWithoutIncludesResponse>> {
        const requestContextPromise = this.requestFactory.bundleIdsAppGetToOneRelated(id, fieldsApps, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.bundleIdsAppGetToOneRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsApps the fields to include for returned resources of type apps
     */
    public bundleIdsAppGetToOneRelated(id: string, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, _options?: Configuration): Observable<AppWithoutIncludesResponse> {
        return this.bundleIdsAppGetToOneRelatedWithHttpInfo(id, fieldsApps, _options).pipe(map((apiResponse: HttpInfo<AppWithoutIncludesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBundleIdCapabilities the fields to include for returned resources of type bundleIdCapabilities
     * @param limit maximum resources per page
     */
    public bundleIdsBundleIdCapabilitiesGetToManyRelatedWithHttpInfo(id: string, fieldsBundleIdCapabilities?: Array<'bundleId' | 'capabilityType' | 'settings'>, limit?: number, _options?: Configuration): Observable<HttpInfo<BundleIdCapabilitiesWithoutIncludesResponse>> {
        const requestContextPromise = this.requestFactory.bundleIdsBundleIdCapabilitiesGetToManyRelated(id, fieldsBundleIdCapabilities, limit, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.bundleIdsBundleIdCapabilitiesGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBundleIdCapabilities the fields to include for returned resources of type bundleIdCapabilities
     * @param limit maximum resources per page
     */
    public bundleIdsBundleIdCapabilitiesGetToManyRelated(id: string, fieldsBundleIdCapabilities?: Array<'bundleId' | 'capabilityType' | 'settings'>, limit?: number, _options?: Configuration): Observable<BundleIdCapabilitiesWithoutIncludesResponse> {
        return this.bundleIdsBundleIdCapabilitiesGetToManyRelatedWithHttpInfo(id, fieldsBundleIdCapabilities, limit, _options).pipe(map((apiResponse: HttpInfo<BundleIdCapabilitiesWithoutIncludesResponse>) => apiResponse.data));
    }

    /**
     * @param bundleIdCreateRequest BundleId representation
     */
    public bundleIdsCreateInstanceWithHttpInfo(bundleIdCreateRequest: BundleIdCreateRequest, _options?: Configuration): Observable<HttpInfo<BundleIdResponse>> {
        const requestContextPromise = this.requestFactory.bundleIdsCreateInstance(bundleIdCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.bundleIdsCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param bundleIdCreateRequest BundleId representation
     */
    public bundleIdsCreateInstance(bundleIdCreateRequest: BundleIdCreateRequest, _options?: Configuration): Observable<BundleIdResponse> {
        return this.bundleIdsCreateInstanceWithHttpInfo(bundleIdCreateRequest, _options).pipe(map((apiResponse: HttpInfo<BundleIdResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public bundleIdsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.bundleIdsDeleteInstance(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.bundleIdsDeleteInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public bundleIdsDeleteInstance(id: string, _options?: Configuration): Observable<void> {
        return this.bundleIdsDeleteInstanceWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param filterIdentifier filter by attribute \&#39;identifier\&#39;
     * @param filterName filter by attribute \&#39;name\&#39;
     * @param filterPlatform filter by attribute \&#39;platform\&#39;
     * @param filterSeedId filter by attribute \&#39;seedId\&#39;
     * @param filterId filter by id(s)
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsBundleIds the fields to include for returned resources of type bundleIds
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsBundleIdCapabilities the fields to include for returned resources of type bundleIdCapabilities
     * @param fieldsProfiles the fields to include for returned resources of type profiles
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param limitBundleIdCapabilities maximum number of related bundleIdCapabilities returned (when they are included)
     * @param limitProfiles maximum number of related profiles returned (when they are included)
     */
    public bundleIdsGetCollectionWithHttpInfo(filterIdentifier?: Array<string>, filterName?: Array<string>, filterPlatform?: Array<'IOS' | 'MAC_OS'>, filterSeedId?: Array<string>, filterId?: Array<string>, sort?: Array<'id' | '-id' | 'identifier' | '-identifier' | 'name' | '-name' | 'platform' | '-platform' | 'seedId' | '-seedId'>, fieldsBundleIds?: Array<'app' | 'bundleIdCapabilities' | 'identifier' | 'name' | 'platform' | 'profiles' | 'seedId'>, limit?: number, include?: Array<'app' | 'bundleIdCapabilities' | 'profiles'>, fieldsBundleIdCapabilities?: Array<'bundleId' | 'capabilityType' | 'settings'>, fieldsProfiles?: Array<'bundleId' | 'certificates' | 'createdDate' | 'devices' | 'expirationDate' | 'name' | 'platform' | 'profileContent' | 'profileState' | 'profileType' | 'uuid'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, limitBundleIdCapabilities?: number, limitProfiles?: number, _options?: Configuration): Observable<HttpInfo<BundleIdsResponse>> {
        const requestContextPromise = this.requestFactory.bundleIdsGetCollection(filterIdentifier, filterName, filterPlatform, filterSeedId, filterId, sort, fieldsBundleIds, limit, include, fieldsBundleIdCapabilities, fieldsProfiles, fieldsApps, limitBundleIdCapabilities, limitProfiles, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.bundleIdsGetCollectionWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param filterIdentifier filter by attribute \&#39;identifier\&#39;
     * @param filterName filter by attribute \&#39;name\&#39;
     * @param filterPlatform filter by attribute \&#39;platform\&#39;
     * @param filterSeedId filter by attribute \&#39;seedId\&#39;
     * @param filterId filter by id(s)
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsBundleIds the fields to include for returned resources of type bundleIds
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsBundleIdCapabilities the fields to include for returned resources of type bundleIdCapabilities
     * @param fieldsProfiles the fields to include for returned resources of type profiles
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param limitBundleIdCapabilities maximum number of related bundleIdCapabilities returned (when they are included)
     * @param limitProfiles maximum number of related profiles returned (when they are included)
     */
    public bundleIdsGetCollection(filterIdentifier?: Array<string>, filterName?: Array<string>, filterPlatform?: Array<'IOS' | 'MAC_OS'>, filterSeedId?: Array<string>, filterId?: Array<string>, sort?: Array<'id' | '-id' | 'identifier' | '-identifier' | 'name' | '-name' | 'platform' | '-platform' | 'seedId' | '-seedId'>, fieldsBundleIds?: Array<'app' | 'bundleIdCapabilities' | 'identifier' | 'name' | 'platform' | 'profiles' | 'seedId'>, limit?: number, include?: Array<'app' | 'bundleIdCapabilities' | 'profiles'>, fieldsBundleIdCapabilities?: Array<'bundleId' | 'capabilityType' | 'settings'>, fieldsProfiles?: Array<'bundleId' | 'certificates' | 'createdDate' | 'devices' | 'expirationDate' | 'name' | 'platform' | 'profileContent' | 'profileState' | 'profileType' | 'uuid'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, limitBundleIdCapabilities?: number, limitProfiles?: number, _options?: Configuration): Observable<BundleIdsResponse> {
        return this.bundleIdsGetCollectionWithHttpInfo(filterIdentifier, filterName, filterPlatform, filterSeedId, filterId, sort, fieldsBundleIds, limit, include, fieldsBundleIdCapabilities, fieldsProfiles, fieldsApps, limitBundleIdCapabilities, limitProfiles, _options).pipe(map((apiResponse: HttpInfo<BundleIdsResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBundleIds the fields to include for returned resources of type bundleIds
     * @param include comma-separated list of relationships to include
     * @param fieldsBundleIdCapabilities the fields to include for returned resources of type bundleIdCapabilities
     * @param fieldsProfiles the fields to include for returned resources of type profiles
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param limitBundleIdCapabilities maximum number of related bundleIdCapabilities returned (when they are included)
     * @param limitProfiles maximum number of related profiles returned (when they are included)
     */
    public bundleIdsGetInstanceWithHttpInfo(id: string, fieldsBundleIds?: Array<'app' | 'bundleIdCapabilities' | 'identifier' | 'name' | 'platform' | 'profiles' | 'seedId'>, include?: Array<'app' | 'bundleIdCapabilities' | 'profiles'>, fieldsBundleIdCapabilities?: Array<'bundleId' | 'capabilityType' | 'settings'>, fieldsProfiles?: Array<'bundleId' | 'certificates' | 'createdDate' | 'devices' | 'expirationDate' | 'name' | 'platform' | 'profileContent' | 'profileState' | 'profileType' | 'uuid'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, limitBundleIdCapabilities?: number, limitProfiles?: number, _options?: Configuration): Observable<HttpInfo<BundleIdResponse>> {
        const requestContextPromise = this.requestFactory.bundleIdsGetInstance(id, fieldsBundleIds, include, fieldsBundleIdCapabilities, fieldsProfiles, fieldsApps, limitBundleIdCapabilities, limitProfiles, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.bundleIdsGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBundleIds the fields to include for returned resources of type bundleIds
     * @param include comma-separated list of relationships to include
     * @param fieldsBundleIdCapabilities the fields to include for returned resources of type bundleIdCapabilities
     * @param fieldsProfiles the fields to include for returned resources of type profiles
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param limitBundleIdCapabilities maximum number of related bundleIdCapabilities returned (when they are included)
     * @param limitProfiles maximum number of related profiles returned (when they are included)
     */
    public bundleIdsGetInstance(id: string, fieldsBundleIds?: Array<'app' | 'bundleIdCapabilities' | 'identifier' | 'name' | 'platform' | 'profiles' | 'seedId'>, include?: Array<'app' | 'bundleIdCapabilities' | 'profiles'>, fieldsBundleIdCapabilities?: Array<'bundleId' | 'capabilityType' | 'settings'>, fieldsProfiles?: Array<'bundleId' | 'certificates' | 'createdDate' | 'devices' | 'expirationDate' | 'name' | 'platform' | 'profileContent' | 'profileState' | 'profileType' | 'uuid'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, limitBundleIdCapabilities?: number, limitProfiles?: number, _options?: Configuration): Observable<BundleIdResponse> {
        return this.bundleIdsGetInstanceWithHttpInfo(id, fieldsBundleIds, include, fieldsBundleIdCapabilities, fieldsProfiles, fieldsApps, limitBundleIdCapabilities, limitProfiles, _options).pipe(map((apiResponse: HttpInfo<BundleIdResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsProfiles the fields to include for returned resources of type profiles
     * @param limit maximum resources per page
     */
    public bundleIdsProfilesGetToManyRelatedWithHttpInfo(id: string, fieldsProfiles?: Array<'bundleId' | 'certificates' | 'createdDate' | 'devices' | 'expirationDate' | 'name' | 'platform' | 'profileContent' | 'profileState' | 'profileType' | 'uuid'>, limit?: number, _options?: Configuration): Observable<HttpInfo<ProfilesWithoutIncludesResponse>> {
        const requestContextPromise = this.requestFactory.bundleIdsProfilesGetToManyRelated(id, fieldsProfiles, limit, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.bundleIdsProfilesGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsProfiles the fields to include for returned resources of type profiles
     * @param limit maximum resources per page
     */
    public bundleIdsProfilesGetToManyRelated(id: string, fieldsProfiles?: Array<'bundleId' | 'certificates' | 'createdDate' | 'devices' | 'expirationDate' | 'name' | 'platform' | 'profileContent' | 'profileState' | 'profileType' | 'uuid'>, limit?: number, _options?: Configuration): Observable<ProfilesWithoutIncludesResponse> {
        return this.bundleIdsProfilesGetToManyRelatedWithHttpInfo(id, fieldsProfiles, limit, _options).pipe(map((apiResponse: HttpInfo<ProfilesWithoutIncludesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param bundleIdUpdateRequest BundleId representation
     */
    public bundleIdsUpdateInstanceWithHttpInfo(id: string, bundleIdUpdateRequest: BundleIdUpdateRequest, _options?: Configuration): Observable<HttpInfo<BundleIdResponse>> {
        const requestContextPromise = this.requestFactory.bundleIdsUpdateInstance(id, bundleIdUpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.bundleIdsUpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param bundleIdUpdateRequest BundleId representation
     */
    public bundleIdsUpdateInstance(id: string, bundleIdUpdateRequest: BundleIdUpdateRequest, _options?: Configuration): Observable<BundleIdResponse> {
        return this.bundleIdsUpdateInstanceWithHttpInfo(id, bundleIdUpdateRequest, _options).pipe(map((apiResponse: HttpInfo<BundleIdResponse>) => apiResponse.data));
    }

}

import { CertificatesApiRequestFactory, CertificatesApiResponseProcessor} from "../apis/CertificatesApi.ts";
export class ObservableCertificatesApi {
    private requestFactory: CertificatesApiRequestFactory;
    private responseProcessor: CertificatesApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: CertificatesApiRequestFactory,
        responseProcessor?: CertificatesApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new CertificatesApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new CertificatesApiResponseProcessor();
    }

    /**
     * @param certificateCreateRequest Certificate representation
     */
    public certificatesCreateInstanceWithHttpInfo(certificateCreateRequest: CertificateCreateRequest, _options?: Configuration): Observable<HttpInfo<CertificateResponse>> {
        const requestContextPromise = this.requestFactory.certificatesCreateInstance(certificateCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.certificatesCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param certificateCreateRequest Certificate representation
     */
    public certificatesCreateInstance(certificateCreateRequest: CertificateCreateRequest, _options?: Configuration): Observable<CertificateResponse> {
        return this.certificatesCreateInstanceWithHttpInfo(certificateCreateRequest, _options).pipe(map((apiResponse: HttpInfo<CertificateResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public certificatesDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.certificatesDeleteInstance(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.certificatesDeleteInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public certificatesDeleteInstance(id: string, _options?: Configuration): Observable<void> {
        return this.certificatesDeleteInstanceWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param filterCertificateType filter by attribute \&#39;certificateType\&#39;
     * @param filterDisplayName filter by attribute \&#39;displayName\&#39;
     * @param filterSerialNumber filter by attribute \&#39;serialNumber\&#39;
     * @param filterId filter by id(s)
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsCertificates the fields to include for returned resources of type certificates
     * @param limit maximum resources per page
     */
    public certificatesGetCollectionWithHttpInfo(filterCertificateType?: Array<'IOS_DEVELOPMENT' | 'IOS_DISTRIBUTION' | 'MAC_APP_DISTRIBUTION' | 'MAC_INSTALLER_DISTRIBUTION' | 'MAC_APP_DEVELOPMENT' | 'DEVELOPER_ID_KEXT' | 'DEVELOPER_ID_APPLICATION' | 'DEVELOPMENT' | 'DISTRIBUTION' | 'PASS_TYPE_ID' | 'PASS_TYPE_ID_WITH_NFC'>, filterDisplayName?: Array<string>, filterSerialNumber?: Array<string>, filterId?: Array<string>, sort?: Array<'certificateType' | '-certificateType' | 'displayName' | '-displayName' | 'id' | '-id' | 'serialNumber' | '-serialNumber'>, fieldsCertificates?: Array<'certificateContent' | 'certificateType' | 'csrContent' | 'displayName' | 'expirationDate' | 'name' | 'platform' | 'serialNumber'>, limit?: number, _options?: Configuration): Observable<HttpInfo<CertificatesResponse>> {
        const requestContextPromise = this.requestFactory.certificatesGetCollection(filterCertificateType, filterDisplayName, filterSerialNumber, filterId, sort, fieldsCertificates, limit, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.certificatesGetCollectionWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param filterCertificateType filter by attribute \&#39;certificateType\&#39;
     * @param filterDisplayName filter by attribute \&#39;displayName\&#39;
     * @param filterSerialNumber filter by attribute \&#39;serialNumber\&#39;
     * @param filterId filter by id(s)
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsCertificates the fields to include for returned resources of type certificates
     * @param limit maximum resources per page
     */
    public certificatesGetCollection(filterCertificateType?: Array<'IOS_DEVELOPMENT' | 'IOS_DISTRIBUTION' | 'MAC_APP_DISTRIBUTION' | 'MAC_INSTALLER_DISTRIBUTION' | 'MAC_APP_DEVELOPMENT' | 'DEVELOPER_ID_KEXT' | 'DEVELOPER_ID_APPLICATION' | 'DEVELOPMENT' | 'DISTRIBUTION' | 'PASS_TYPE_ID' | 'PASS_TYPE_ID_WITH_NFC'>, filterDisplayName?: Array<string>, filterSerialNumber?: Array<string>, filterId?: Array<string>, sort?: Array<'certificateType' | '-certificateType' | 'displayName' | '-displayName' | 'id' | '-id' | 'serialNumber' | '-serialNumber'>, fieldsCertificates?: Array<'certificateContent' | 'certificateType' | 'csrContent' | 'displayName' | 'expirationDate' | 'name' | 'platform' | 'serialNumber'>, limit?: number, _options?: Configuration): Observable<CertificatesResponse> {
        return this.certificatesGetCollectionWithHttpInfo(filterCertificateType, filterDisplayName, filterSerialNumber, filterId, sort, fieldsCertificates, limit, _options).pipe(map((apiResponse: HttpInfo<CertificatesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCertificates the fields to include for returned resources of type certificates
     */
    public certificatesGetInstanceWithHttpInfo(id: string, fieldsCertificates?: Array<'certificateContent' | 'certificateType' | 'csrContent' | 'displayName' | 'expirationDate' | 'name' | 'platform' | 'serialNumber'>, _options?: Configuration): Observable<HttpInfo<CertificateResponse>> {
        const requestContextPromise = this.requestFactory.certificatesGetInstance(id, fieldsCertificates, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.certificatesGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCertificates the fields to include for returned resources of type certificates
     */
    public certificatesGetInstance(id: string, fieldsCertificates?: Array<'certificateContent' | 'certificateType' | 'csrContent' | 'displayName' | 'expirationDate' | 'name' | 'platform' | 'serialNumber'>, _options?: Configuration): Observable<CertificateResponse> {
        return this.certificatesGetInstanceWithHttpInfo(id, fieldsCertificates, _options).pipe(map((apiResponse: HttpInfo<CertificateResponse>) => apiResponse.data));
    }

}

import { CiArtifactsApiRequestFactory, CiArtifactsApiResponseProcessor} from "../apis/CiArtifactsApi.ts";
export class ObservableCiArtifactsApi {
    private requestFactory: CiArtifactsApiRequestFactory;
    private responseProcessor: CiArtifactsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: CiArtifactsApiRequestFactory,
        responseProcessor?: CiArtifactsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new CiArtifactsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new CiArtifactsApiResponseProcessor();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCiArtifacts the fields to include for returned resources of type ciArtifacts
     */
    public ciArtifactsGetInstanceWithHttpInfo(id: string, fieldsCiArtifacts?: Array<'downloadUrl' | 'fileName' | 'fileSize' | 'fileType'>, _options?: Configuration): Observable<HttpInfo<CiArtifactResponse>> {
        const requestContextPromise = this.requestFactory.ciArtifactsGetInstance(id, fieldsCiArtifacts, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.ciArtifactsGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCiArtifacts the fields to include for returned resources of type ciArtifacts
     */
    public ciArtifactsGetInstance(id: string, fieldsCiArtifacts?: Array<'downloadUrl' | 'fileName' | 'fileSize' | 'fileType'>, _options?: Configuration): Observable<CiArtifactResponse> {
        return this.ciArtifactsGetInstanceWithHttpInfo(id, fieldsCiArtifacts, _options).pipe(map((apiResponse: HttpInfo<CiArtifactResponse>) => apiResponse.data));
    }

}

import { CiBuildActionsApiRequestFactory, CiBuildActionsApiResponseProcessor} from "../apis/CiBuildActionsApi.ts";
export class ObservableCiBuildActionsApi {
    private requestFactory: CiBuildActionsApiRequestFactory;
    private responseProcessor: CiBuildActionsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: CiBuildActionsApiRequestFactory,
        responseProcessor?: CiBuildActionsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new CiBuildActionsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new CiBuildActionsApiResponseProcessor();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCiArtifacts the fields to include for returned resources of type ciArtifacts
     * @param limit maximum resources per page
     */
    public ciBuildActionsArtifactsGetToManyRelatedWithHttpInfo(id: string, fieldsCiArtifacts?: Array<'downloadUrl' | 'fileName' | 'fileSize' | 'fileType'>, limit?: number, _options?: Configuration): Observable<HttpInfo<CiArtifactsResponse>> {
        const requestContextPromise = this.requestFactory.ciBuildActionsArtifactsGetToManyRelated(id, fieldsCiArtifacts, limit, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.ciBuildActionsArtifactsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCiArtifacts the fields to include for returned resources of type ciArtifacts
     * @param limit maximum resources per page
     */
    public ciBuildActionsArtifactsGetToManyRelated(id: string, fieldsCiArtifacts?: Array<'downloadUrl' | 'fileName' | 'fileSize' | 'fileType'>, limit?: number, _options?: Configuration): Observable<CiArtifactsResponse> {
        return this.ciBuildActionsArtifactsGetToManyRelatedWithHttpInfo(id, fieldsCiArtifacts, limit, _options).pipe(map((apiResponse: HttpInfo<CiArtifactsResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsScmGitReferences the fields to include for returned resources of type scmGitReferences
     * @param fieldsCiBuildRuns the fields to include for returned resources of type ciBuildRuns
     * @param fieldsCiWorkflows the fields to include for returned resources of type ciWorkflows
     * @param fieldsScmPullRequests the fields to include for returned resources of type scmPullRequests
     * @param fieldsCiProducts the fields to include for returned resources of type ciProducts
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param limitBuilds maximum number of related builds returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public ciBuildActionsBuildRunGetToOneRelatedWithHttpInfo(id: string, fieldsScmGitReferences?: Array<'canonicalName' | 'isDeleted' | 'kind' | 'name' | 'repository'>, fieldsCiBuildRuns?: Array<'actions' | 'buildRun' | 'builds' | 'cancelReason' | 'clean' | 'completionStatus' | 'createdDate' | 'destinationBranch' | 'destinationCommit' | 'executionProgress' | 'finishedDate' | 'isPullRequestBuild' | 'issueCounts' | 'number' | 'product' | 'pullRequest' | 'sourceBranchOrTag' | 'sourceCommit' | 'startReason' | 'startedDate' | 'workflow'>, fieldsCiWorkflows?: Array<'actions' | 'branchStartCondition' | 'buildRuns' | 'clean' | 'containerFilePath' | 'description' | 'isEnabled' | 'isLockedForEditing' | 'lastModifiedDate' | 'macOsVersion' | 'manualBranchStartCondition' | 'manualPullRequestStartCondition' | 'manualTagStartCondition' | 'name' | 'product' | 'pullRequestStartCondition' | 'repository' | 'scheduledStartCondition' | 'tagStartCondition' | 'xcodeVersion'>, fieldsScmPullRequests?: Array<'destinationBranchName' | 'destinationRepositoryName' | 'destinationRepositoryOwner' | 'isClosed' | 'isCrossRepository' | 'number' | 'repository' | 'sourceBranchName' | 'sourceRepositoryName' | 'sourceRepositoryOwner' | 'title' | 'webUrl'>, fieldsCiProducts?: Array<'additionalRepositories' | 'app' | 'buildRuns' | 'bundleId' | 'createdDate' | 'name' | 'primaryRepositories' | 'productType' | 'workflows'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, limitBuilds?: number, include?: Array<'builds' | 'destinationBranch' | 'product' | 'pullRequest' | 'sourceBranchOrTag' | 'workflow'>, _options?: Configuration): Observable<HttpInfo<CiBuildRunResponse>> {
        const requestContextPromise = this.requestFactory.ciBuildActionsBuildRunGetToOneRelated(id, fieldsScmGitReferences, fieldsCiBuildRuns, fieldsCiWorkflows, fieldsScmPullRequests, fieldsCiProducts, fieldsBuilds, limitBuilds, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.ciBuildActionsBuildRunGetToOneRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsScmGitReferences the fields to include for returned resources of type scmGitReferences
     * @param fieldsCiBuildRuns the fields to include for returned resources of type ciBuildRuns
     * @param fieldsCiWorkflows the fields to include for returned resources of type ciWorkflows
     * @param fieldsScmPullRequests the fields to include for returned resources of type scmPullRequests
     * @param fieldsCiProducts the fields to include for returned resources of type ciProducts
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param limitBuilds maximum number of related builds returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public ciBuildActionsBuildRunGetToOneRelated(id: string, fieldsScmGitReferences?: Array<'canonicalName' | 'isDeleted' | 'kind' | 'name' | 'repository'>, fieldsCiBuildRuns?: Array<'actions' | 'buildRun' | 'builds' | 'cancelReason' | 'clean' | 'completionStatus' | 'createdDate' | 'destinationBranch' | 'destinationCommit' | 'executionProgress' | 'finishedDate' | 'isPullRequestBuild' | 'issueCounts' | 'number' | 'product' | 'pullRequest' | 'sourceBranchOrTag' | 'sourceCommit' | 'startReason' | 'startedDate' | 'workflow'>, fieldsCiWorkflows?: Array<'actions' | 'branchStartCondition' | 'buildRuns' | 'clean' | 'containerFilePath' | 'description' | 'isEnabled' | 'isLockedForEditing' | 'lastModifiedDate' | 'macOsVersion' | 'manualBranchStartCondition' | 'manualPullRequestStartCondition' | 'manualTagStartCondition' | 'name' | 'product' | 'pullRequestStartCondition' | 'repository' | 'scheduledStartCondition' | 'tagStartCondition' | 'xcodeVersion'>, fieldsScmPullRequests?: Array<'destinationBranchName' | 'destinationRepositoryName' | 'destinationRepositoryOwner' | 'isClosed' | 'isCrossRepository' | 'number' | 'repository' | 'sourceBranchName' | 'sourceRepositoryName' | 'sourceRepositoryOwner' | 'title' | 'webUrl'>, fieldsCiProducts?: Array<'additionalRepositories' | 'app' | 'buildRuns' | 'bundleId' | 'createdDate' | 'name' | 'primaryRepositories' | 'productType' | 'workflows'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, limitBuilds?: number, include?: Array<'builds' | 'destinationBranch' | 'product' | 'pullRequest' | 'sourceBranchOrTag' | 'workflow'>, _options?: Configuration): Observable<CiBuildRunResponse> {
        return this.ciBuildActionsBuildRunGetToOneRelatedWithHttpInfo(id, fieldsScmGitReferences, fieldsCiBuildRuns, fieldsCiWorkflows, fieldsScmPullRequests, fieldsCiProducts, fieldsBuilds, limitBuilds, include, _options).pipe(map((apiResponse: HttpInfo<CiBuildRunResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCiBuildActions the fields to include for returned resources of type ciBuildActions
     * @param include comma-separated list of relationships to include
     * @param fieldsCiIssues the fields to include for returned resources of type ciIssues
     * @param fieldsCiBuildRuns the fields to include for returned resources of type ciBuildRuns
     * @param fieldsCiTestResults the fields to include for returned resources of type ciTestResults
     * @param fieldsCiArtifacts the fields to include for returned resources of type ciArtifacts
     */
    public ciBuildActionsGetInstanceWithHttpInfo(id: string, fieldsCiBuildActions?: Array<'actionType' | 'artifacts' | 'buildRun' | 'completionStatus' | 'executionProgress' | 'finishedDate' | 'isRequiredToPass' | 'issueCounts' | 'issues' | 'name' | 'startedDate' | 'testResults'>, include?: Array<'buildRun'>, fieldsCiIssues?: Array<'category' | 'fileSource' | 'issueType' | 'message'>, fieldsCiBuildRuns?: Array<'actions' | 'buildRun' | 'builds' | 'cancelReason' | 'clean' | 'completionStatus' | 'createdDate' | 'destinationBranch' | 'destinationCommit' | 'executionProgress' | 'finishedDate' | 'isPullRequestBuild' | 'issueCounts' | 'number' | 'product' | 'pullRequest' | 'sourceBranchOrTag' | 'sourceCommit' | 'startReason' | 'startedDate' | 'workflow'>, fieldsCiTestResults?: Array<'className' | 'destinationTestResults' | 'fileSource' | 'message' | 'name' | 'status'>, fieldsCiArtifacts?: Array<'downloadUrl' | 'fileName' | 'fileSize' | 'fileType'>, _options?: Configuration): Observable<HttpInfo<CiBuildActionResponse>> {
        const requestContextPromise = this.requestFactory.ciBuildActionsGetInstance(id, fieldsCiBuildActions, include, fieldsCiIssues, fieldsCiBuildRuns, fieldsCiTestResults, fieldsCiArtifacts, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.ciBuildActionsGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCiBuildActions the fields to include for returned resources of type ciBuildActions
     * @param include comma-separated list of relationships to include
     * @param fieldsCiIssues the fields to include for returned resources of type ciIssues
     * @param fieldsCiBuildRuns the fields to include for returned resources of type ciBuildRuns
     * @param fieldsCiTestResults the fields to include for returned resources of type ciTestResults
     * @param fieldsCiArtifacts the fields to include for returned resources of type ciArtifacts
     */
    public ciBuildActionsGetInstance(id: string, fieldsCiBuildActions?: Array<'actionType' | 'artifacts' | 'buildRun' | 'completionStatus' | 'executionProgress' | 'finishedDate' | 'isRequiredToPass' | 'issueCounts' | 'issues' | 'name' | 'startedDate' | 'testResults'>, include?: Array<'buildRun'>, fieldsCiIssues?: Array<'category' | 'fileSource' | 'issueType' | 'message'>, fieldsCiBuildRuns?: Array<'actions' | 'buildRun' | 'builds' | 'cancelReason' | 'clean' | 'completionStatus' | 'createdDate' | 'destinationBranch' | 'destinationCommit' | 'executionProgress' | 'finishedDate' | 'isPullRequestBuild' | 'issueCounts' | 'number' | 'product' | 'pullRequest' | 'sourceBranchOrTag' | 'sourceCommit' | 'startReason' | 'startedDate' | 'workflow'>, fieldsCiTestResults?: Array<'className' | 'destinationTestResults' | 'fileSource' | 'message' | 'name' | 'status'>, fieldsCiArtifacts?: Array<'downloadUrl' | 'fileName' | 'fileSize' | 'fileType'>, _options?: Configuration): Observable<CiBuildActionResponse> {
        return this.ciBuildActionsGetInstanceWithHttpInfo(id, fieldsCiBuildActions, include, fieldsCiIssues, fieldsCiBuildRuns, fieldsCiTestResults, fieldsCiArtifacts, _options).pipe(map((apiResponse: HttpInfo<CiBuildActionResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCiIssues the fields to include for returned resources of type ciIssues
     * @param limit maximum resources per page
     */
    public ciBuildActionsIssuesGetToManyRelatedWithHttpInfo(id: string, fieldsCiIssues?: Array<'category' | 'fileSource' | 'issueType' | 'message'>, limit?: number, _options?: Configuration): Observable<HttpInfo<CiIssuesResponse>> {
        const requestContextPromise = this.requestFactory.ciBuildActionsIssuesGetToManyRelated(id, fieldsCiIssues, limit, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.ciBuildActionsIssuesGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCiIssues the fields to include for returned resources of type ciIssues
     * @param limit maximum resources per page
     */
    public ciBuildActionsIssuesGetToManyRelated(id: string, fieldsCiIssues?: Array<'category' | 'fileSource' | 'issueType' | 'message'>, limit?: number, _options?: Configuration): Observable<CiIssuesResponse> {
        return this.ciBuildActionsIssuesGetToManyRelatedWithHttpInfo(id, fieldsCiIssues, limit, _options).pipe(map((apiResponse: HttpInfo<CiIssuesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCiTestResults the fields to include for returned resources of type ciTestResults
     * @param limit maximum resources per page
     */
    public ciBuildActionsTestResultsGetToManyRelatedWithHttpInfo(id: string, fieldsCiTestResults?: Array<'className' | 'destinationTestResults' | 'fileSource' | 'message' | 'name' | 'status'>, limit?: number, _options?: Configuration): Observable<HttpInfo<CiTestResultsResponse>> {
        const requestContextPromise = this.requestFactory.ciBuildActionsTestResultsGetToManyRelated(id, fieldsCiTestResults, limit, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.ciBuildActionsTestResultsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCiTestResults the fields to include for returned resources of type ciTestResults
     * @param limit maximum resources per page
     */
    public ciBuildActionsTestResultsGetToManyRelated(id: string, fieldsCiTestResults?: Array<'className' | 'destinationTestResults' | 'fileSource' | 'message' | 'name' | 'status'>, limit?: number, _options?: Configuration): Observable<CiTestResultsResponse> {
        return this.ciBuildActionsTestResultsGetToManyRelatedWithHttpInfo(id, fieldsCiTestResults, limit, _options).pipe(map((apiResponse: HttpInfo<CiTestResultsResponse>) => apiResponse.data));
    }

}

import { CiBuildRunsApiRequestFactory, CiBuildRunsApiResponseProcessor} from "../apis/CiBuildRunsApi.ts";
export class ObservableCiBuildRunsApi {
    private requestFactory: CiBuildRunsApiRequestFactory;
    private responseProcessor: CiBuildRunsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: CiBuildRunsApiRequestFactory,
        responseProcessor?: CiBuildRunsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new CiBuildRunsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new CiBuildRunsApiResponseProcessor();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCiBuildRuns the fields to include for returned resources of type ciBuildRuns
     * @param fieldsCiBuildActions the fields to include for returned resources of type ciBuildActions
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public ciBuildRunsActionsGetToManyRelatedWithHttpInfo(id: string, fieldsCiBuildRuns?: Array<'actions' | 'buildRun' | 'builds' | 'cancelReason' | 'clean' | 'completionStatus' | 'createdDate' | 'destinationBranch' | 'destinationCommit' | 'executionProgress' | 'finishedDate' | 'isPullRequestBuild' | 'issueCounts' | 'number' | 'product' | 'pullRequest' | 'sourceBranchOrTag' | 'sourceCommit' | 'startReason' | 'startedDate' | 'workflow'>, fieldsCiBuildActions?: Array<'actionType' | 'artifacts' | 'buildRun' | 'completionStatus' | 'executionProgress' | 'finishedDate' | 'isRequiredToPass' | 'issueCounts' | 'issues' | 'name' | 'startedDate' | 'testResults'>, limit?: number, include?: Array<'buildRun'>, _options?: Configuration): Observable<HttpInfo<CiBuildActionsResponse>> {
        const requestContextPromise = this.requestFactory.ciBuildRunsActionsGetToManyRelated(id, fieldsCiBuildRuns, fieldsCiBuildActions, limit, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.ciBuildRunsActionsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCiBuildRuns the fields to include for returned resources of type ciBuildRuns
     * @param fieldsCiBuildActions the fields to include for returned resources of type ciBuildActions
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public ciBuildRunsActionsGetToManyRelated(id: string, fieldsCiBuildRuns?: Array<'actions' | 'buildRun' | 'builds' | 'cancelReason' | 'clean' | 'completionStatus' | 'createdDate' | 'destinationBranch' | 'destinationCommit' | 'executionProgress' | 'finishedDate' | 'isPullRequestBuild' | 'issueCounts' | 'number' | 'product' | 'pullRequest' | 'sourceBranchOrTag' | 'sourceCommit' | 'startReason' | 'startedDate' | 'workflow'>, fieldsCiBuildActions?: Array<'actionType' | 'artifacts' | 'buildRun' | 'completionStatus' | 'executionProgress' | 'finishedDate' | 'isRequiredToPass' | 'issueCounts' | 'issues' | 'name' | 'startedDate' | 'testResults'>, limit?: number, include?: Array<'buildRun'>, _options?: Configuration): Observable<CiBuildActionsResponse> {
        return this.ciBuildRunsActionsGetToManyRelatedWithHttpInfo(id, fieldsCiBuildRuns, fieldsCiBuildActions, limit, include, _options).pipe(map((apiResponse: HttpInfo<CiBuildActionsResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param filterBetaAppReviewSubmissionBetaReviewState filter by attribute \&#39;betaAppReviewSubmission.betaReviewState\&#39;
     * @param filterBuildAudienceType filter by attribute \&#39;buildAudienceType\&#39;
     * @param filterExpired filter by attribute \&#39;expired\&#39;
     * @param filterPreReleaseVersionPlatform filter by attribute \&#39;preReleaseVersion.platform\&#39;
     * @param filterPreReleaseVersionVersion filter by attribute \&#39;preReleaseVersion.version\&#39;
     * @param filterProcessingState filter by attribute \&#39;processingState\&#39;
     * @param filterUsesNonExemptEncryption filter by attribute \&#39;usesNonExemptEncryption\&#39;
     * @param filterVersion filter by attribute \&#39;version\&#39;
     * @param filterApp filter by id(s) of related \&#39;app\&#39;
     * @param filterAppStoreVersion filter by id(s) of related \&#39;appStoreVersion\&#39;
     * @param filterBetaGroups filter by id(s) of related \&#39;betaGroups\&#39;
     * @param filterPreReleaseVersion filter by id(s) of related \&#39;preReleaseVersion\&#39;
     * @param filterId filter by id(s)
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsBuildBundles the fields to include for returned resources of type buildBundles
     * @param fieldsBuildIcons the fields to include for returned resources of type buildIcons
     * @param fieldsBetaAppReviewSubmissions the fields to include for returned resources of type betaAppReviewSubmissions
     * @param fieldsBuildBetaDetails the fields to include for returned resources of type buildBetaDetails
     * @param fieldsBetaTesters the fields to include for returned resources of type betaTesters
     * @param fieldsPreReleaseVersions the fields to include for returned resources of type preReleaseVersions
     * @param fieldsBetaBuildLocalizations the fields to include for returned resources of type betaBuildLocalizations
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsAppEncryptionDeclarations the fields to include for returned resources of type appEncryptionDeclarations
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param fieldsBetaGroups the fields to include for returned resources of type betaGroups
     * @param limit maximum resources per page
     * @param limitIndividualTesters maximum number of related individualTesters returned (when they are included)
     * @param limitBetaGroups maximum number of related betaGroups returned (when they are included)
     * @param limitBetaBuildLocalizations maximum number of related betaBuildLocalizations returned (when they are included)
     * @param limitIcons maximum number of related icons returned (when they are included)
     * @param limitBuildBundles maximum number of related buildBundles returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public ciBuildRunsBuildsGetToManyRelatedWithHttpInfo(id: string, filterBetaAppReviewSubmissionBetaReviewState?: Array<'WAITING_FOR_REVIEW' | 'IN_REVIEW' | 'REJECTED' | 'APPROVED'>, filterBuildAudienceType?: Array<'INTERNAL_ONLY' | 'APP_STORE_ELIGIBLE'>, filterExpired?: Array<string>, filterPreReleaseVersionPlatform?: Array<'IOS' | 'MAC_OS' | 'TV_OS' | 'VISION_OS'>, filterPreReleaseVersionVersion?: Array<string>, filterProcessingState?: Array<'PROCESSING' | 'FAILED' | 'INVALID' | 'VALID'>, filterUsesNonExemptEncryption?: Array<string>, filterVersion?: Array<string>, filterApp?: Array<string>, filterAppStoreVersion?: Array<string>, filterBetaGroups?: Array<string>, filterPreReleaseVersion?: Array<string>, filterId?: Array<string>, sort?: Array<'preReleaseVersion' | '-preReleaseVersion' | 'uploadedDate' | '-uploadedDate' | 'version' | '-version'>, fieldsBuildBundles?: Array<'appClipDomainCacheStatus' | 'appClipDomainDebugStatus' | 'betaAppClipInvocations' | 'buildBundleFileSizes' | 'bundleId' | 'bundleType' | 'dSYMUrl' | 'deviceProtocols' | 'entitlements' | 'fileName' | 'hasOnDemandResources' | 'hasPrerenderedIcon' | 'hasSirikit' | 'includesSymbols' | 'isIosBuildMacAppStoreCompatible' | 'locales' | 'platformBuild' | 'requiredCapabilities' | 'sdkBuild' | 'supportedArchitectures' | 'usesLocationServices'>, fieldsBuildIcons?: Array<'iconAsset' | 'iconType' | 'name'>, fieldsBetaAppReviewSubmissions?: Array<'betaReviewState' | 'build' | 'submittedDate'>, fieldsBuildBetaDetails?: Array<'autoNotifyEnabled' | 'build' | 'externalBuildState' | 'internalBuildState'>, fieldsBetaTesters?: Array<'apps' | 'betaGroups' | 'builds' | 'email' | 'firstName' | 'inviteType' | 'lastName'>, fieldsPreReleaseVersions?: Array<'app' | 'builds' | 'platform' | 'version'>, fieldsBetaBuildLocalizations?: Array<'build' | 'locale' | 'whatsNew'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsAppEncryptionDeclarations?: Array<'app' | 'appDescription' | 'appEncryptionDeclarationDocument' | 'appEncryptionDeclarationState' | 'availableOnFrenchStore' | 'builds' | 'codeValue' | 'containsProprietaryCryptography' | 'containsThirdPartyCryptography' | 'createdDate' | 'documentName' | 'documentType' | 'documentUrl' | 'exempt' | 'platform' | 'uploadedDate' | 'usesEncryption'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, fieldsBetaGroups?: Array<'app' | 'betaTesters' | 'builds' | 'createdDate' | 'feedbackEnabled' | 'hasAccessToAllBuilds' | 'iosBuildsAvailableForAppleSiliconMac' | 'isInternalGroup' | 'name' | 'publicLink' | 'publicLinkEnabled' | 'publicLinkId' | 'publicLinkLimit' | 'publicLinkLimitEnabled'>, limit?: number, limitIndividualTesters?: number, limitBetaGroups?: number, limitBetaBuildLocalizations?: number, limitIcons?: number, limitBuildBundles?: number, include?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildBetaDetail' | 'buildBundles' | 'icons' | 'individualTesters' | 'preReleaseVersion'>, _options?: Configuration): Observable<HttpInfo<BuildsResponse>> {
        const requestContextPromise = this.requestFactory.ciBuildRunsBuildsGetToManyRelated(id, filterBetaAppReviewSubmissionBetaReviewState, filterBuildAudienceType, filterExpired, filterPreReleaseVersionPlatform, filterPreReleaseVersionVersion, filterProcessingState, filterUsesNonExemptEncryption, filterVersion, filterApp, filterAppStoreVersion, filterBetaGroups, filterPreReleaseVersion, filterId, sort, fieldsBuildBundles, fieldsBuildIcons, fieldsBetaAppReviewSubmissions, fieldsBuildBetaDetails, fieldsBetaTesters, fieldsPreReleaseVersions, fieldsBetaBuildLocalizations, fieldsAppStoreVersions, fieldsAppEncryptionDeclarations, fieldsApps, fieldsBuilds, fieldsBetaGroups, limit, limitIndividualTesters, limitBetaGroups, limitBetaBuildLocalizations, limitIcons, limitBuildBundles, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.ciBuildRunsBuildsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param filterBetaAppReviewSubmissionBetaReviewState filter by attribute \&#39;betaAppReviewSubmission.betaReviewState\&#39;
     * @param filterBuildAudienceType filter by attribute \&#39;buildAudienceType\&#39;
     * @param filterExpired filter by attribute \&#39;expired\&#39;
     * @param filterPreReleaseVersionPlatform filter by attribute \&#39;preReleaseVersion.platform\&#39;
     * @param filterPreReleaseVersionVersion filter by attribute \&#39;preReleaseVersion.version\&#39;
     * @param filterProcessingState filter by attribute \&#39;processingState\&#39;
     * @param filterUsesNonExemptEncryption filter by attribute \&#39;usesNonExemptEncryption\&#39;
     * @param filterVersion filter by attribute \&#39;version\&#39;
     * @param filterApp filter by id(s) of related \&#39;app\&#39;
     * @param filterAppStoreVersion filter by id(s) of related \&#39;appStoreVersion\&#39;
     * @param filterBetaGroups filter by id(s) of related \&#39;betaGroups\&#39;
     * @param filterPreReleaseVersion filter by id(s) of related \&#39;preReleaseVersion\&#39;
     * @param filterId filter by id(s)
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsBuildBundles the fields to include for returned resources of type buildBundles
     * @param fieldsBuildIcons the fields to include for returned resources of type buildIcons
     * @param fieldsBetaAppReviewSubmissions the fields to include for returned resources of type betaAppReviewSubmissions
     * @param fieldsBuildBetaDetails the fields to include for returned resources of type buildBetaDetails
     * @param fieldsBetaTesters the fields to include for returned resources of type betaTesters
     * @param fieldsPreReleaseVersions the fields to include for returned resources of type preReleaseVersions
     * @param fieldsBetaBuildLocalizations the fields to include for returned resources of type betaBuildLocalizations
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsAppEncryptionDeclarations the fields to include for returned resources of type appEncryptionDeclarations
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param fieldsBetaGroups the fields to include for returned resources of type betaGroups
     * @param limit maximum resources per page
     * @param limitIndividualTesters maximum number of related individualTesters returned (when they are included)
     * @param limitBetaGroups maximum number of related betaGroups returned (when they are included)
     * @param limitBetaBuildLocalizations maximum number of related betaBuildLocalizations returned (when they are included)
     * @param limitIcons maximum number of related icons returned (when they are included)
     * @param limitBuildBundles maximum number of related buildBundles returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public ciBuildRunsBuildsGetToManyRelated(id: string, filterBetaAppReviewSubmissionBetaReviewState?: Array<'WAITING_FOR_REVIEW' | 'IN_REVIEW' | 'REJECTED' | 'APPROVED'>, filterBuildAudienceType?: Array<'INTERNAL_ONLY' | 'APP_STORE_ELIGIBLE'>, filterExpired?: Array<string>, filterPreReleaseVersionPlatform?: Array<'IOS' | 'MAC_OS' | 'TV_OS' | 'VISION_OS'>, filterPreReleaseVersionVersion?: Array<string>, filterProcessingState?: Array<'PROCESSING' | 'FAILED' | 'INVALID' | 'VALID'>, filterUsesNonExemptEncryption?: Array<string>, filterVersion?: Array<string>, filterApp?: Array<string>, filterAppStoreVersion?: Array<string>, filterBetaGroups?: Array<string>, filterPreReleaseVersion?: Array<string>, filterId?: Array<string>, sort?: Array<'preReleaseVersion' | '-preReleaseVersion' | 'uploadedDate' | '-uploadedDate' | 'version' | '-version'>, fieldsBuildBundles?: Array<'appClipDomainCacheStatus' | 'appClipDomainDebugStatus' | 'betaAppClipInvocations' | 'buildBundleFileSizes' | 'bundleId' | 'bundleType' | 'dSYMUrl' | 'deviceProtocols' | 'entitlements' | 'fileName' | 'hasOnDemandResources' | 'hasPrerenderedIcon' | 'hasSirikit' | 'includesSymbols' | 'isIosBuildMacAppStoreCompatible' | 'locales' | 'platformBuild' | 'requiredCapabilities' | 'sdkBuild' | 'supportedArchitectures' | 'usesLocationServices'>, fieldsBuildIcons?: Array<'iconAsset' | 'iconType' | 'name'>, fieldsBetaAppReviewSubmissions?: Array<'betaReviewState' | 'build' | 'submittedDate'>, fieldsBuildBetaDetails?: Array<'autoNotifyEnabled' | 'build' | 'externalBuildState' | 'internalBuildState'>, fieldsBetaTesters?: Array<'apps' | 'betaGroups' | 'builds' | 'email' | 'firstName' | 'inviteType' | 'lastName'>, fieldsPreReleaseVersions?: Array<'app' | 'builds' | 'platform' | 'version'>, fieldsBetaBuildLocalizations?: Array<'build' | 'locale' | 'whatsNew'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsAppEncryptionDeclarations?: Array<'app' | 'appDescription' | 'appEncryptionDeclarationDocument' | 'appEncryptionDeclarationState' | 'availableOnFrenchStore' | 'builds' | 'codeValue' | 'containsProprietaryCryptography' | 'containsThirdPartyCryptography' | 'createdDate' | 'documentName' | 'documentType' | 'documentUrl' | 'exempt' | 'platform' | 'uploadedDate' | 'usesEncryption'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, fieldsBetaGroups?: Array<'app' | 'betaTesters' | 'builds' | 'createdDate' | 'feedbackEnabled' | 'hasAccessToAllBuilds' | 'iosBuildsAvailableForAppleSiliconMac' | 'isInternalGroup' | 'name' | 'publicLink' | 'publicLinkEnabled' | 'publicLinkId' | 'publicLinkLimit' | 'publicLinkLimitEnabled'>, limit?: number, limitIndividualTesters?: number, limitBetaGroups?: number, limitBetaBuildLocalizations?: number, limitIcons?: number, limitBuildBundles?: number, include?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildBetaDetail' | 'buildBundles' | 'icons' | 'individualTesters' | 'preReleaseVersion'>, _options?: Configuration): Observable<BuildsResponse> {
        return this.ciBuildRunsBuildsGetToManyRelatedWithHttpInfo(id, filterBetaAppReviewSubmissionBetaReviewState, filterBuildAudienceType, filterExpired, filterPreReleaseVersionPlatform, filterPreReleaseVersionVersion, filterProcessingState, filterUsesNonExemptEncryption, filterVersion, filterApp, filterAppStoreVersion, filterBetaGroups, filterPreReleaseVersion, filterId, sort, fieldsBuildBundles, fieldsBuildIcons, fieldsBetaAppReviewSubmissions, fieldsBuildBetaDetails, fieldsBetaTesters, fieldsPreReleaseVersions, fieldsBetaBuildLocalizations, fieldsAppStoreVersions, fieldsAppEncryptionDeclarations, fieldsApps, fieldsBuilds, fieldsBetaGroups, limit, limitIndividualTesters, limitBetaGroups, limitBetaBuildLocalizations, limitIcons, limitBuildBundles, include, _options).pipe(map((apiResponse: HttpInfo<BuildsResponse>) => apiResponse.data));
    }

    /**
     * @param ciBuildRunCreateRequest CiBuildRun representation
     */
    public ciBuildRunsCreateInstanceWithHttpInfo(ciBuildRunCreateRequest: CiBuildRunCreateRequest, _options?: Configuration): Observable<HttpInfo<CiBuildRunResponse>> {
        const requestContextPromise = this.requestFactory.ciBuildRunsCreateInstance(ciBuildRunCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.ciBuildRunsCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param ciBuildRunCreateRequest CiBuildRun representation
     */
    public ciBuildRunsCreateInstance(ciBuildRunCreateRequest: CiBuildRunCreateRequest, _options?: Configuration): Observable<CiBuildRunResponse> {
        return this.ciBuildRunsCreateInstanceWithHttpInfo(ciBuildRunCreateRequest, _options).pipe(map((apiResponse: HttpInfo<CiBuildRunResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCiBuildRuns the fields to include for returned resources of type ciBuildRuns
     * @param include comma-separated list of relationships to include
     * @param fieldsCiBuildActions the fields to include for returned resources of type ciBuildActions
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param limitBuilds maximum number of related builds returned (when they are included)
     */
    public ciBuildRunsGetInstanceWithHttpInfo(id: string, fieldsCiBuildRuns?: Array<'actions' | 'buildRun' | 'builds' | 'cancelReason' | 'clean' | 'completionStatus' | 'createdDate' | 'destinationBranch' | 'destinationCommit' | 'executionProgress' | 'finishedDate' | 'isPullRequestBuild' | 'issueCounts' | 'number' | 'product' | 'pullRequest' | 'sourceBranchOrTag' | 'sourceCommit' | 'startReason' | 'startedDate' | 'workflow'>, include?: Array<'builds' | 'destinationBranch' | 'product' | 'pullRequest' | 'sourceBranchOrTag' | 'workflow'>, fieldsCiBuildActions?: Array<'actionType' | 'artifacts' | 'buildRun' | 'completionStatus' | 'executionProgress' | 'finishedDate' | 'isRequiredToPass' | 'issueCounts' | 'issues' | 'name' | 'startedDate' | 'testResults'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, limitBuilds?: number, _options?: Configuration): Observable<HttpInfo<CiBuildRunResponse>> {
        const requestContextPromise = this.requestFactory.ciBuildRunsGetInstance(id, fieldsCiBuildRuns, include, fieldsCiBuildActions, fieldsBuilds, limitBuilds, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.ciBuildRunsGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCiBuildRuns the fields to include for returned resources of type ciBuildRuns
     * @param include comma-separated list of relationships to include
     * @param fieldsCiBuildActions the fields to include for returned resources of type ciBuildActions
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param limitBuilds maximum number of related builds returned (when they are included)
     */
    public ciBuildRunsGetInstance(id: string, fieldsCiBuildRuns?: Array<'actions' | 'buildRun' | 'builds' | 'cancelReason' | 'clean' | 'completionStatus' | 'createdDate' | 'destinationBranch' | 'destinationCommit' | 'executionProgress' | 'finishedDate' | 'isPullRequestBuild' | 'issueCounts' | 'number' | 'product' | 'pullRequest' | 'sourceBranchOrTag' | 'sourceCommit' | 'startReason' | 'startedDate' | 'workflow'>, include?: Array<'builds' | 'destinationBranch' | 'product' | 'pullRequest' | 'sourceBranchOrTag' | 'workflow'>, fieldsCiBuildActions?: Array<'actionType' | 'artifacts' | 'buildRun' | 'completionStatus' | 'executionProgress' | 'finishedDate' | 'isRequiredToPass' | 'issueCounts' | 'issues' | 'name' | 'startedDate' | 'testResults'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, limitBuilds?: number, _options?: Configuration): Observable<CiBuildRunResponse> {
        return this.ciBuildRunsGetInstanceWithHttpInfo(id, fieldsCiBuildRuns, include, fieldsCiBuildActions, fieldsBuilds, limitBuilds, _options).pipe(map((apiResponse: HttpInfo<CiBuildRunResponse>) => apiResponse.data));
    }

}

import { CiIssuesApiRequestFactory, CiIssuesApiResponseProcessor} from "../apis/CiIssuesApi.ts";
export class ObservableCiIssuesApi {
    private requestFactory: CiIssuesApiRequestFactory;
    private responseProcessor: CiIssuesApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: CiIssuesApiRequestFactory,
        responseProcessor?: CiIssuesApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new CiIssuesApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new CiIssuesApiResponseProcessor();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCiIssues the fields to include for returned resources of type ciIssues
     */
    public ciIssuesGetInstanceWithHttpInfo(id: string, fieldsCiIssues?: Array<'category' | 'fileSource' | 'issueType' | 'message'>, _options?: Configuration): Observable<HttpInfo<CiIssueResponse>> {
        const requestContextPromise = this.requestFactory.ciIssuesGetInstance(id, fieldsCiIssues, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.ciIssuesGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCiIssues the fields to include for returned resources of type ciIssues
     */
    public ciIssuesGetInstance(id: string, fieldsCiIssues?: Array<'category' | 'fileSource' | 'issueType' | 'message'>, _options?: Configuration): Observable<CiIssueResponse> {
        return this.ciIssuesGetInstanceWithHttpInfo(id, fieldsCiIssues, _options).pipe(map((apiResponse: HttpInfo<CiIssueResponse>) => apiResponse.data));
    }

}

import { CiMacOsVersionsApiRequestFactory, CiMacOsVersionsApiResponseProcessor} from "../apis/CiMacOsVersionsApi.ts";
export class ObservableCiMacOsVersionsApi {
    private requestFactory: CiMacOsVersionsApiRequestFactory;
    private responseProcessor: CiMacOsVersionsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: CiMacOsVersionsApiRequestFactory,
        responseProcessor?: CiMacOsVersionsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new CiMacOsVersionsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new CiMacOsVersionsApiResponseProcessor();
    }

    /**
     * @param fieldsCiMacOsVersions the fields to include for returned resources of type ciMacOsVersions
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsCiXcodeVersions the fields to include for returned resources of type ciXcodeVersions
     * @param limitXcodeVersions maximum number of related xcodeVersions returned (when they are included)
     */
    public ciMacOsVersionsGetCollectionWithHttpInfo(fieldsCiMacOsVersions?: Array<'name' | 'version' | 'xcodeVersions'>, limit?: number, include?: Array<'xcodeVersions'>, fieldsCiXcodeVersions?: Array<'macOsVersions' | 'name' | 'testDestinations' | 'version'>, limitXcodeVersions?: number, _options?: Configuration): Observable<HttpInfo<CiMacOsVersionsResponse>> {
        const requestContextPromise = this.requestFactory.ciMacOsVersionsGetCollection(fieldsCiMacOsVersions, limit, include, fieldsCiXcodeVersions, limitXcodeVersions, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.ciMacOsVersionsGetCollectionWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param fieldsCiMacOsVersions the fields to include for returned resources of type ciMacOsVersions
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsCiXcodeVersions the fields to include for returned resources of type ciXcodeVersions
     * @param limitXcodeVersions maximum number of related xcodeVersions returned (when they are included)
     */
    public ciMacOsVersionsGetCollection(fieldsCiMacOsVersions?: Array<'name' | 'version' | 'xcodeVersions'>, limit?: number, include?: Array<'xcodeVersions'>, fieldsCiXcodeVersions?: Array<'macOsVersions' | 'name' | 'testDestinations' | 'version'>, limitXcodeVersions?: number, _options?: Configuration): Observable<CiMacOsVersionsResponse> {
        return this.ciMacOsVersionsGetCollectionWithHttpInfo(fieldsCiMacOsVersions, limit, include, fieldsCiXcodeVersions, limitXcodeVersions, _options).pipe(map((apiResponse: HttpInfo<CiMacOsVersionsResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCiMacOsVersions the fields to include for returned resources of type ciMacOsVersions
     * @param include comma-separated list of relationships to include
     * @param fieldsCiXcodeVersions the fields to include for returned resources of type ciXcodeVersions
     * @param limitXcodeVersions maximum number of related xcodeVersions returned (when they are included)
     */
    public ciMacOsVersionsGetInstanceWithHttpInfo(id: string, fieldsCiMacOsVersions?: Array<'name' | 'version' | 'xcodeVersions'>, include?: Array<'xcodeVersions'>, fieldsCiXcodeVersions?: Array<'macOsVersions' | 'name' | 'testDestinations' | 'version'>, limitXcodeVersions?: number, _options?: Configuration): Observable<HttpInfo<CiMacOsVersionResponse>> {
        const requestContextPromise = this.requestFactory.ciMacOsVersionsGetInstance(id, fieldsCiMacOsVersions, include, fieldsCiXcodeVersions, limitXcodeVersions, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.ciMacOsVersionsGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCiMacOsVersions the fields to include for returned resources of type ciMacOsVersions
     * @param include comma-separated list of relationships to include
     * @param fieldsCiXcodeVersions the fields to include for returned resources of type ciXcodeVersions
     * @param limitXcodeVersions maximum number of related xcodeVersions returned (when they are included)
     */
    public ciMacOsVersionsGetInstance(id: string, fieldsCiMacOsVersions?: Array<'name' | 'version' | 'xcodeVersions'>, include?: Array<'xcodeVersions'>, fieldsCiXcodeVersions?: Array<'macOsVersions' | 'name' | 'testDestinations' | 'version'>, limitXcodeVersions?: number, _options?: Configuration): Observable<CiMacOsVersionResponse> {
        return this.ciMacOsVersionsGetInstanceWithHttpInfo(id, fieldsCiMacOsVersions, include, fieldsCiXcodeVersions, limitXcodeVersions, _options).pipe(map((apiResponse: HttpInfo<CiMacOsVersionResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCiXcodeVersions the fields to include for returned resources of type ciXcodeVersions
     * @param fieldsCiMacOsVersions the fields to include for returned resources of type ciMacOsVersions
     * @param limit maximum resources per page
     * @param limitMacOsVersions maximum number of related macOsVersions returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public ciMacOsVersionsXcodeVersionsGetToManyRelatedWithHttpInfo(id: string, fieldsCiXcodeVersions?: Array<'macOsVersions' | 'name' | 'testDestinations' | 'version'>, fieldsCiMacOsVersions?: Array<'name' | 'version' | 'xcodeVersions'>, limit?: number, limitMacOsVersions?: number, include?: Array<'macOsVersions'>, _options?: Configuration): Observable<HttpInfo<CiXcodeVersionsResponse>> {
        const requestContextPromise = this.requestFactory.ciMacOsVersionsXcodeVersionsGetToManyRelated(id, fieldsCiXcodeVersions, fieldsCiMacOsVersions, limit, limitMacOsVersions, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.ciMacOsVersionsXcodeVersionsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCiXcodeVersions the fields to include for returned resources of type ciXcodeVersions
     * @param fieldsCiMacOsVersions the fields to include for returned resources of type ciMacOsVersions
     * @param limit maximum resources per page
     * @param limitMacOsVersions maximum number of related macOsVersions returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public ciMacOsVersionsXcodeVersionsGetToManyRelated(id: string, fieldsCiXcodeVersions?: Array<'macOsVersions' | 'name' | 'testDestinations' | 'version'>, fieldsCiMacOsVersions?: Array<'name' | 'version' | 'xcodeVersions'>, limit?: number, limitMacOsVersions?: number, include?: Array<'macOsVersions'>, _options?: Configuration): Observable<CiXcodeVersionsResponse> {
        return this.ciMacOsVersionsXcodeVersionsGetToManyRelatedWithHttpInfo(id, fieldsCiXcodeVersions, fieldsCiMacOsVersions, limit, limitMacOsVersions, include, _options).pipe(map((apiResponse: HttpInfo<CiXcodeVersionsResponse>) => apiResponse.data));
    }

}

import { CiProductsApiRequestFactory, CiProductsApiResponseProcessor} from "../apis/CiProductsApi.ts";
export class ObservableCiProductsApi {
    private requestFactory: CiProductsApiRequestFactory;
    private responseProcessor: CiProductsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: CiProductsApiRequestFactory,
        responseProcessor?: CiProductsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new CiProductsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new CiProductsApiResponseProcessor();
    }

    /**
     * @param id the id of the requested resource
     * @param filterId filter by id(s)
     * @param fieldsScmGitReferences the fields to include for returned resources of type scmGitReferences
     * @param fieldsScmProviders the fields to include for returned resources of type scmProviders
     * @param fieldsScmRepositories the fields to include for returned resources of type scmRepositories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public ciProductsAdditionalRepositoriesGetToManyRelatedWithHttpInfo(id: string, filterId?: Array<string>, fieldsScmGitReferences?: Array<'canonicalName' | 'isDeleted' | 'kind' | 'name' | 'repository'>, fieldsScmProviders?: Array<'repositories' | 'scmProviderType' | 'url'>, fieldsScmRepositories?: Array<'defaultBranch' | 'gitReferences' | 'httpCloneUrl' | 'lastAccessedDate' | 'ownerName' | 'pullRequests' | 'repositoryName' | 'scmProvider' | 'sshCloneUrl'>, limit?: number, include?: Array<'defaultBranch' | 'scmProvider'>, _options?: Configuration): Observable<HttpInfo<ScmRepositoriesResponse>> {
        const requestContextPromise = this.requestFactory.ciProductsAdditionalRepositoriesGetToManyRelated(id, filterId, fieldsScmGitReferences, fieldsScmProviders, fieldsScmRepositories, limit, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.ciProductsAdditionalRepositoriesGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param filterId filter by id(s)
     * @param fieldsScmGitReferences the fields to include for returned resources of type scmGitReferences
     * @param fieldsScmProviders the fields to include for returned resources of type scmProviders
     * @param fieldsScmRepositories the fields to include for returned resources of type scmRepositories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public ciProductsAdditionalRepositoriesGetToManyRelated(id: string, filterId?: Array<string>, fieldsScmGitReferences?: Array<'canonicalName' | 'isDeleted' | 'kind' | 'name' | 'repository'>, fieldsScmProviders?: Array<'repositories' | 'scmProviderType' | 'url'>, fieldsScmRepositories?: Array<'defaultBranch' | 'gitReferences' | 'httpCloneUrl' | 'lastAccessedDate' | 'ownerName' | 'pullRequests' | 'repositoryName' | 'scmProvider' | 'sshCloneUrl'>, limit?: number, include?: Array<'defaultBranch' | 'scmProvider'>, _options?: Configuration): Observable<ScmRepositoriesResponse> {
        return this.ciProductsAdditionalRepositoriesGetToManyRelatedWithHttpInfo(id, filterId, fieldsScmGitReferences, fieldsScmProviders, fieldsScmRepositories, limit, include, _options).pipe(map((apiResponse: HttpInfo<ScmRepositoriesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBetaAppReviewDetails the fields to include for returned resources of type betaAppReviewDetails
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsCiProducts the fields to include for returned resources of type ciProducts
     * @param fieldsReviewSubmissions the fields to include for returned resources of type reviewSubmissions
     * @param fieldsBetaGroups the fields to include for returned resources of type betaGroups
     * @param fieldsPromotedPurchases the fields to include for returned resources of type promotedPurchases
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsAppEvents the fields to include for returned resources of type appEvents
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param fieldsBetaLicenseAgreements the fields to include for returned resources of type betaLicenseAgreements
     * @param fieldsAppClips the fields to include for returned resources of type appClips
     * @param fieldsBetaAppLocalizations the fields to include for returned resources of type betaAppLocalizations
     * @param fieldsAppInfos the fields to include for returned resources of type appInfos
     * @param fieldsPreReleaseVersions the fields to include for returned resources of type preReleaseVersions
     * @param fieldsInAppPurchases the fields to include for returned resources of type inAppPurchases
     * @param fieldsSubscriptionGroups the fields to include for returned resources of type subscriptionGroups
     * @param fieldsAppPreOrders the fields to include for returned resources of type appPreOrders
     * @param fieldsAppPrices the fields to include for returned resources of type appPrices
     * @param fieldsGameCenterEnabledVersions the fields to include for returned resources of type gameCenterEnabledVersions
     * @param fieldsAppStoreVersionExperiments the fields to include for returned resources of type appStoreVersionExperiments
     * @param fieldsSubscriptionGracePeriods the fields to include for returned resources of type subscriptionGracePeriods
     * @param fieldsEndUserLicenseAgreements the fields to include for returned resources of type endUserLicenseAgreements
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsAppEncryptionDeclarations the fields to include for returned resources of type appEncryptionDeclarations
     * @param fieldsAppCustomProductPages the fields to include for returned resources of type appCustomProductPages
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limitAppEncryptionDeclarations maximum number of related appEncryptionDeclarations returned (when they are included)
     * @param limitBetaGroups maximum number of related betaGroups returned (when they are included)
     * @param limitAppStoreVersions maximum number of related appStoreVersions returned (when they are included)
     * @param limitPreReleaseVersions maximum number of related preReleaseVersions returned (when they are included)
     * @param limitBetaAppLocalizations maximum number of related betaAppLocalizations returned (when they are included)
     * @param limitBuilds maximum number of related builds returned (when they are included)
     * @param limitAppInfos maximum number of related appInfos returned (when they are included)
     * @param limitAppClips maximum number of related appClips returned (when they are included)
     * @param limitPrices maximum number of related prices returned (when they are included)
     * @param limitAvailableTerritories maximum number of related availableTerritories returned (when they are included)
     * @param limitInAppPurchases maximum number of related inAppPurchases returned (when they are included)
     * @param limitSubscriptionGroups maximum number of related subscriptionGroups returned (when they are included)
     * @param limitGameCenterEnabledVersions maximum number of related gameCenterEnabledVersions returned (when they are included)
     * @param limitAppCustomProductPages maximum number of related appCustomProductPages returned (when they are included)
     * @param limitInAppPurchasesV2 maximum number of related inAppPurchasesV2 returned (when they are included)
     * @param limitPromotedPurchases maximum number of related promotedPurchases returned (when they are included)
     * @param limitAppEvents maximum number of related appEvents returned (when they are included)
     * @param limitReviewSubmissions maximum number of related reviewSubmissions returned (when they are included)
     * @param limitAppStoreVersionExperimentsV2 maximum number of related appStoreVersionExperimentsV2 returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public ciProductsAppGetToOneRelatedWithHttpInfo(id: string, fieldsBetaAppReviewDetails?: Array<'app' | 'contactEmail' | 'contactFirstName' | 'contactLastName' | 'contactPhone' | 'demoAccountName' | 'demoAccountPassword' | 'demoAccountRequired' | 'notes'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsCiProducts?: Array<'additionalRepositories' | 'app' | 'buildRuns' | 'bundleId' | 'createdDate' | 'name' | 'primaryRepositories' | 'productType' | 'workflows'>, fieldsReviewSubmissions?: Array<'app' | 'appStoreVersionForReview' | 'canceled' | 'items' | 'lastUpdatedByActor' | 'platform' | 'state' | 'submitted' | 'submittedByActor' | 'submittedDate'>, fieldsBetaGroups?: Array<'app' | 'betaTesters' | 'builds' | 'createdDate' | 'feedbackEnabled' | 'hasAccessToAllBuilds' | 'iosBuildsAvailableForAppleSiliconMac' | 'isInternalGroup' | 'name' | 'publicLink' | 'publicLinkEnabled' | 'publicLinkId' | 'publicLinkLimit' | 'publicLinkLimitEnabled'>, fieldsPromotedPurchases?: Array<'app' | 'enabled' | 'inAppPurchaseV2' | 'promotionImages' | 'state' | 'subscription' | 'visibleForAllUsers'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsAppEvents?: Array<'app' | 'archivedTerritorySchedules' | 'badge' | 'deepLink' | 'eventState' | 'localizations' | 'primaryLocale' | 'priority' | 'purchaseRequirement' | 'purpose' | 'referenceName' | 'territorySchedules'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, fieldsBetaLicenseAgreements?: Array<'agreementText' | 'app'>, fieldsAppClips?: Array<'app' | 'appClipAdvancedExperiences' | 'appClipDefaultExperiences' | 'bundleId'>, fieldsBetaAppLocalizations?: Array<'app' | 'description' | 'feedbackEmail' | 'locale' | 'marketingUrl' | 'privacyPolicyUrl' | 'tvOsPrivacyPolicy'>, fieldsAppInfos?: Array<'ageRatingDeclaration' | 'app' | 'appInfoLocalizations' | 'appStoreAgeRating' | 'appStoreState' | 'brazilAgeRating' | 'brazilAgeRatingV2' | 'kidsAgeBand' | 'primaryCategory' | 'primarySubcategoryOne' | 'primarySubcategoryTwo' | 'secondaryCategory' | 'secondarySubcategoryOne' | 'secondarySubcategoryTwo' | 'state'>, fieldsPreReleaseVersions?: Array<'app' | 'builds' | 'platform' | 'version'>, fieldsInAppPurchases?: Array<'app' | 'appStoreReviewScreenshot' | 'apps' | 'content' | 'contentHosting' | 'familySharable' | 'iapPriceSchedule' | 'inAppPurchaseAvailability' | 'inAppPurchaseLocalizations' | 'inAppPurchaseType' | 'name' | 'pricePoints' | 'productId' | 'promotedPurchase' | 'referenceName' | 'reviewNote' | 'state'>, fieldsSubscriptionGroups?: Array<'app' | 'referenceName' | 'subscriptionGroupLocalizations' | 'subscriptions'>, fieldsAppPreOrders?: Array<'app' | 'appReleaseDate' | 'preOrderAvailableDate'>, fieldsAppPrices?: Array<'app' | 'priceTier'>, fieldsGameCenterEnabledVersions?: Array<'app' | 'compatibleVersions' | 'iconAsset' | 'platform' | 'versionString'>, fieldsAppStoreVersionExperiments?: Array<'app' | 'appStoreVersionExperimentTreatments' | 'controlVersions' | 'endDate' | 'latestControlVersion' | 'name' | 'platform' | 'reviewRequired' | 'startDate' | 'started' | 'state' | 'trafficProportion'>, fieldsSubscriptionGracePeriods?: Array<'duration' | 'optIn' | 'renewalType' | 'sandboxOptIn'>, fieldsEndUserLicenseAgreements?: Array<'agreementText' | 'app' | 'territories'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsAppEncryptionDeclarations?: Array<'app' | 'appDescription' | 'appEncryptionDeclarationDocument' | 'appEncryptionDeclarationState' | 'availableOnFrenchStore' | 'builds' | 'codeValue' | 'containsProprietaryCryptography' | 'containsThirdPartyCryptography' | 'createdDate' | 'documentName' | 'documentType' | 'documentUrl' | 'exempt' | 'platform' | 'uploadedDate' | 'usesEncryption'>, fieldsAppCustomProductPages?: Array<'app' | 'appCustomProductPageVersions' | 'appStoreVersionTemplate' | 'customProductPageTemplate' | 'name' | 'url' | 'visible'>, fieldsTerritories?: Array<'currency'>, limitAppEncryptionDeclarations?: number, limitBetaGroups?: number, limitAppStoreVersions?: number, limitPreReleaseVersions?: number, limitBetaAppLocalizations?: number, limitBuilds?: number, limitAppInfos?: number, limitAppClips?: number, limitPrices?: number, limitAvailableTerritories?: number, limitInAppPurchases?: number, limitSubscriptionGroups?: number, limitGameCenterEnabledVersions?: number, limitAppCustomProductPages?: number, limitInAppPurchasesV2?: number, limitPromotedPurchases?: number, limitAppEvents?: number, limitReviewSubmissions?: number, limitAppStoreVersionExperimentsV2?: number, include?: Array<'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'builds' | 'ciProduct' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'preOrder' | 'preReleaseVersions' | 'prices' | 'promotedPurchases' | 'reviewSubmissions' | 'subscriptionGracePeriod' | 'subscriptionGroups'>, _options?: Configuration): Observable<HttpInfo<AppResponse>> {
        const requestContextPromise = this.requestFactory.ciProductsAppGetToOneRelated(id, fieldsBetaAppReviewDetails, fieldsGameCenterDetails, fieldsCiProducts, fieldsReviewSubmissions, fieldsBetaGroups, fieldsPromotedPurchases, fieldsApps, fieldsAppEvents, fieldsBuilds, fieldsBetaLicenseAgreements, fieldsAppClips, fieldsBetaAppLocalizations, fieldsAppInfos, fieldsPreReleaseVersions, fieldsInAppPurchases, fieldsSubscriptionGroups, fieldsAppPreOrders, fieldsAppPrices, fieldsGameCenterEnabledVersions, fieldsAppStoreVersionExperiments, fieldsSubscriptionGracePeriods, fieldsEndUserLicenseAgreements, fieldsAppStoreVersions, fieldsAppEncryptionDeclarations, fieldsAppCustomProductPages, fieldsTerritories, limitAppEncryptionDeclarations, limitBetaGroups, limitAppStoreVersions, limitPreReleaseVersions, limitBetaAppLocalizations, limitBuilds, limitAppInfos, limitAppClips, limitPrices, limitAvailableTerritories, limitInAppPurchases, limitSubscriptionGroups, limitGameCenterEnabledVersions, limitAppCustomProductPages, limitInAppPurchasesV2, limitPromotedPurchases, limitAppEvents, limitReviewSubmissions, limitAppStoreVersionExperimentsV2, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.ciProductsAppGetToOneRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBetaAppReviewDetails the fields to include for returned resources of type betaAppReviewDetails
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsCiProducts the fields to include for returned resources of type ciProducts
     * @param fieldsReviewSubmissions the fields to include for returned resources of type reviewSubmissions
     * @param fieldsBetaGroups the fields to include for returned resources of type betaGroups
     * @param fieldsPromotedPurchases the fields to include for returned resources of type promotedPurchases
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsAppEvents the fields to include for returned resources of type appEvents
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param fieldsBetaLicenseAgreements the fields to include for returned resources of type betaLicenseAgreements
     * @param fieldsAppClips the fields to include for returned resources of type appClips
     * @param fieldsBetaAppLocalizations the fields to include for returned resources of type betaAppLocalizations
     * @param fieldsAppInfos the fields to include for returned resources of type appInfos
     * @param fieldsPreReleaseVersions the fields to include for returned resources of type preReleaseVersions
     * @param fieldsInAppPurchases the fields to include for returned resources of type inAppPurchases
     * @param fieldsSubscriptionGroups the fields to include for returned resources of type subscriptionGroups
     * @param fieldsAppPreOrders the fields to include for returned resources of type appPreOrders
     * @param fieldsAppPrices the fields to include for returned resources of type appPrices
     * @param fieldsGameCenterEnabledVersions the fields to include for returned resources of type gameCenterEnabledVersions
     * @param fieldsAppStoreVersionExperiments the fields to include for returned resources of type appStoreVersionExperiments
     * @param fieldsSubscriptionGracePeriods the fields to include for returned resources of type subscriptionGracePeriods
     * @param fieldsEndUserLicenseAgreements the fields to include for returned resources of type endUserLicenseAgreements
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsAppEncryptionDeclarations the fields to include for returned resources of type appEncryptionDeclarations
     * @param fieldsAppCustomProductPages the fields to include for returned resources of type appCustomProductPages
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limitAppEncryptionDeclarations maximum number of related appEncryptionDeclarations returned (when they are included)
     * @param limitBetaGroups maximum number of related betaGroups returned (when they are included)
     * @param limitAppStoreVersions maximum number of related appStoreVersions returned (when they are included)
     * @param limitPreReleaseVersions maximum number of related preReleaseVersions returned (when they are included)
     * @param limitBetaAppLocalizations maximum number of related betaAppLocalizations returned (when they are included)
     * @param limitBuilds maximum number of related builds returned (when they are included)
     * @param limitAppInfos maximum number of related appInfos returned (when they are included)
     * @param limitAppClips maximum number of related appClips returned (when they are included)
     * @param limitPrices maximum number of related prices returned (when they are included)
     * @param limitAvailableTerritories maximum number of related availableTerritories returned (when they are included)
     * @param limitInAppPurchases maximum number of related inAppPurchases returned (when they are included)
     * @param limitSubscriptionGroups maximum number of related subscriptionGroups returned (when they are included)
     * @param limitGameCenterEnabledVersions maximum number of related gameCenterEnabledVersions returned (when they are included)
     * @param limitAppCustomProductPages maximum number of related appCustomProductPages returned (when they are included)
     * @param limitInAppPurchasesV2 maximum number of related inAppPurchasesV2 returned (when they are included)
     * @param limitPromotedPurchases maximum number of related promotedPurchases returned (when they are included)
     * @param limitAppEvents maximum number of related appEvents returned (when they are included)
     * @param limitReviewSubmissions maximum number of related reviewSubmissions returned (when they are included)
     * @param limitAppStoreVersionExperimentsV2 maximum number of related appStoreVersionExperimentsV2 returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public ciProductsAppGetToOneRelated(id: string, fieldsBetaAppReviewDetails?: Array<'app' | 'contactEmail' | 'contactFirstName' | 'contactLastName' | 'contactPhone' | 'demoAccountName' | 'demoAccountPassword' | 'demoAccountRequired' | 'notes'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsCiProducts?: Array<'additionalRepositories' | 'app' | 'buildRuns' | 'bundleId' | 'createdDate' | 'name' | 'primaryRepositories' | 'productType' | 'workflows'>, fieldsReviewSubmissions?: Array<'app' | 'appStoreVersionForReview' | 'canceled' | 'items' | 'lastUpdatedByActor' | 'platform' | 'state' | 'submitted' | 'submittedByActor' | 'submittedDate'>, fieldsBetaGroups?: Array<'app' | 'betaTesters' | 'builds' | 'createdDate' | 'feedbackEnabled' | 'hasAccessToAllBuilds' | 'iosBuildsAvailableForAppleSiliconMac' | 'isInternalGroup' | 'name' | 'publicLink' | 'publicLinkEnabled' | 'publicLinkId' | 'publicLinkLimit' | 'publicLinkLimitEnabled'>, fieldsPromotedPurchases?: Array<'app' | 'enabled' | 'inAppPurchaseV2' | 'promotionImages' | 'state' | 'subscription' | 'visibleForAllUsers'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsAppEvents?: Array<'app' | 'archivedTerritorySchedules' | 'badge' | 'deepLink' | 'eventState' | 'localizations' | 'primaryLocale' | 'priority' | 'purchaseRequirement' | 'purpose' | 'referenceName' | 'territorySchedules'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, fieldsBetaLicenseAgreements?: Array<'agreementText' | 'app'>, fieldsAppClips?: Array<'app' | 'appClipAdvancedExperiences' | 'appClipDefaultExperiences' | 'bundleId'>, fieldsBetaAppLocalizations?: Array<'app' | 'description' | 'feedbackEmail' | 'locale' | 'marketingUrl' | 'privacyPolicyUrl' | 'tvOsPrivacyPolicy'>, fieldsAppInfos?: Array<'ageRatingDeclaration' | 'app' | 'appInfoLocalizations' | 'appStoreAgeRating' | 'appStoreState' | 'brazilAgeRating' | 'brazilAgeRatingV2' | 'kidsAgeBand' | 'primaryCategory' | 'primarySubcategoryOne' | 'primarySubcategoryTwo' | 'secondaryCategory' | 'secondarySubcategoryOne' | 'secondarySubcategoryTwo' | 'state'>, fieldsPreReleaseVersions?: Array<'app' | 'builds' | 'platform' | 'version'>, fieldsInAppPurchases?: Array<'app' | 'appStoreReviewScreenshot' | 'apps' | 'content' | 'contentHosting' | 'familySharable' | 'iapPriceSchedule' | 'inAppPurchaseAvailability' | 'inAppPurchaseLocalizations' | 'inAppPurchaseType' | 'name' | 'pricePoints' | 'productId' | 'promotedPurchase' | 'referenceName' | 'reviewNote' | 'state'>, fieldsSubscriptionGroups?: Array<'app' | 'referenceName' | 'subscriptionGroupLocalizations' | 'subscriptions'>, fieldsAppPreOrders?: Array<'app' | 'appReleaseDate' | 'preOrderAvailableDate'>, fieldsAppPrices?: Array<'app' | 'priceTier'>, fieldsGameCenterEnabledVersions?: Array<'app' | 'compatibleVersions' | 'iconAsset' | 'platform' | 'versionString'>, fieldsAppStoreVersionExperiments?: Array<'app' | 'appStoreVersionExperimentTreatments' | 'controlVersions' | 'endDate' | 'latestControlVersion' | 'name' | 'platform' | 'reviewRequired' | 'startDate' | 'started' | 'state' | 'trafficProportion'>, fieldsSubscriptionGracePeriods?: Array<'duration' | 'optIn' | 'renewalType' | 'sandboxOptIn'>, fieldsEndUserLicenseAgreements?: Array<'agreementText' | 'app' | 'territories'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsAppEncryptionDeclarations?: Array<'app' | 'appDescription' | 'appEncryptionDeclarationDocument' | 'appEncryptionDeclarationState' | 'availableOnFrenchStore' | 'builds' | 'codeValue' | 'containsProprietaryCryptography' | 'containsThirdPartyCryptography' | 'createdDate' | 'documentName' | 'documentType' | 'documentUrl' | 'exempt' | 'platform' | 'uploadedDate' | 'usesEncryption'>, fieldsAppCustomProductPages?: Array<'app' | 'appCustomProductPageVersions' | 'appStoreVersionTemplate' | 'customProductPageTemplate' | 'name' | 'url' | 'visible'>, fieldsTerritories?: Array<'currency'>, limitAppEncryptionDeclarations?: number, limitBetaGroups?: number, limitAppStoreVersions?: number, limitPreReleaseVersions?: number, limitBetaAppLocalizations?: number, limitBuilds?: number, limitAppInfos?: number, limitAppClips?: number, limitPrices?: number, limitAvailableTerritories?: number, limitInAppPurchases?: number, limitSubscriptionGroups?: number, limitGameCenterEnabledVersions?: number, limitAppCustomProductPages?: number, limitInAppPurchasesV2?: number, limitPromotedPurchases?: number, limitAppEvents?: number, limitReviewSubmissions?: number, limitAppStoreVersionExperimentsV2?: number, include?: Array<'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'builds' | 'ciProduct' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'preOrder' | 'preReleaseVersions' | 'prices' | 'promotedPurchases' | 'reviewSubmissions' | 'subscriptionGracePeriod' | 'subscriptionGroups'>, _options?: Configuration): Observable<AppResponse> {
        return this.ciProductsAppGetToOneRelatedWithHttpInfo(id, fieldsBetaAppReviewDetails, fieldsGameCenterDetails, fieldsCiProducts, fieldsReviewSubmissions, fieldsBetaGroups, fieldsPromotedPurchases, fieldsApps, fieldsAppEvents, fieldsBuilds, fieldsBetaLicenseAgreements, fieldsAppClips, fieldsBetaAppLocalizations, fieldsAppInfos, fieldsPreReleaseVersions, fieldsInAppPurchases, fieldsSubscriptionGroups, fieldsAppPreOrders, fieldsAppPrices, fieldsGameCenterEnabledVersions, fieldsAppStoreVersionExperiments, fieldsSubscriptionGracePeriods, fieldsEndUserLicenseAgreements, fieldsAppStoreVersions, fieldsAppEncryptionDeclarations, fieldsAppCustomProductPages, fieldsTerritories, limitAppEncryptionDeclarations, limitBetaGroups, limitAppStoreVersions, limitPreReleaseVersions, limitBetaAppLocalizations, limitBuilds, limitAppInfos, limitAppClips, limitPrices, limitAvailableTerritories, limitInAppPurchases, limitSubscriptionGroups, limitGameCenterEnabledVersions, limitAppCustomProductPages, limitInAppPurchasesV2, limitPromotedPurchases, limitAppEvents, limitReviewSubmissions, limitAppStoreVersionExperimentsV2, include, _options).pipe(map((apiResponse: HttpInfo<AppResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param filterBuilds filter by id(s) of related \&#39;builds\&#39;
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsScmGitReferences the fields to include for returned resources of type scmGitReferences
     * @param fieldsCiBuildRuns the fields to include for returned resources of type ciBuildRuns
     * @param fieldsCiWorkflows the fields to include for returned resources of type ciWorkflows
     * @param fieldsScmPullRequests the fields to include for returned resources of type scmPullRequests
     * @param fieldsCiProducts the fields to include for returned resources of type ciProducts
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param limit maximum resources per page
     * @param limitBuilds maximum number of related builds returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public ciProductsBuildRunsGetToManyRelatedWithHttpInfo(id: string, filterBuilds?: Array<string>, sort?: Array<'number' | '-number'>, fieldsScmGitReferences?: Array<'canonicalName' | 'isDeleted' | 'kind' | 'name' | 'repository'>, fieldsCiBuildRuns?: Array<'actions' | 'buildRun' | 'builds' | 'cancelReason' | 'clean' | 'completionStatus' | 'createdDate' | 'destinationBranch' | 'destinationCommit' | 'executionProgress' | 'finishedDate' | 'isPullRequestBuild' | 'issueCounts' | 'number' | 'product' | 'pullRequest' | 'sourceBranchOrTag' | 'sourceCommit' | 'startReason' | 'startedDate' | 'workflow'>, fieldsCiWorkflows?: Array<'actions' | 'branchStartCondition' | 'buildRuns' | 'clean' | 'containerFilePath' | 'description' | 'isEnabled' | 'isLockedForEditing' | 'lastModifiedDate' | 'macOsVersion' | 'manualBranchStartCondition' | 'manualPullRequestStartCondition' | 'manualTagStartCondition' | 'name' | 'product' | 'pullRequestStartCondition' | 'repository' | 'scheduledStartCondition' | 'tagStartCondition' | 'xcodeVersion'>, fieldsScmPullRequests?: Array<'destinationBranchName' | 'destinationRepositoryName' | 'destinationRepositoryOwner' | 'isClosed' | 'isCrossRepository' | 'number' | 'repository' | 'sourceBranchName' | 'sourceRepositoryName' | 'sourceRepositoryOwner' | 'title' | 'webUrl'>, fieldsCiProducts?: Array<'additionalRepositories' | 'app' | 'buildRuns' | 'bundleId' | 'createdDate' | 'name' | 'primaryRepositories' | 'productType' | 'workflows'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, limit?: number, limitBuilds?: number, include?: Array<'builds' | 'destinationBranch' | 'product' | 'pullRequest' | 'sourceBranchOrTag' | 'workflow'>, _options?: Configuration): Observable<HttpInfo<CiBuildRunsResponse>> {
        const requestContextPromise = this.requestFactory.ciProductsBuildRunsGetToManyRelated(id, filterBuilds, sort, fieldsScmGitReferences, fieldsCiBuildRuns, fieldsCiWorkflows, fieldsScmPullRequests, fieldsCiProducts, fieldsBuilds, limit, limitBuilds, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.ciProductsBuildRunsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param filterBuilds filter by id(s) of related \&#39;builds\&#39;
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsScmGitReferences the fields to include for returned resources of type scmGitReferences
     * @param fieldsCiBuildRuns the fields to include for returned resources of type ciBuildRuns
     * @param fieldsCiWorkflows the fields to include for returned resources of type ciWorkflows
     * @param fieldsScmPullRequests the fields to include for returned resources of type scmPullRequests
     * @param fieldsCiProducts the fields to include for returned resources of type ciProducts
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param limit maximum resources per page
     * @param limitBuilds maximum number of related builds returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public ciProductsBuildRunsGetToManyRelated(id: string, filterBuilds?: Array<string>, sort?: Array<'number' | '-number'>, fieldsScmGitReferences?: Array<'canonicalName' | 'isDeleted' | 'kind' | 'name' | 'repository'>, fieldsCiBuildRuns?: Array<'actions' | 'buildRun' | 'builds' | 'cancelReason' | 'clean' | 'completionStatus' | 'createdDate' | 'destinationBranch' | 'destinationCommit' | 'executionProgress' | 'finishedDate' | 'isPullRequestBuild' | 'issueCounts' | 'number' | 'product' | 'pullRequest' | 'sourceBranchOrTag' | 'sourceCommit' | 'startReason' | 'startedDate' | 'workflow'>, fieldsCiWorkflows?: Array<'actions' | 'branchStartCondition' | 'buildRuns' | 'clean' | 'containerFilePath' | 'description' | 'isEnabled' | 'isLockedForEditing' | 'lastModifiedDate' | 'macOsVersion' | 'manualBranchStartCondition' | 'manualPullRequestStartCondition' | 'manualTagStartCondition' | 'name' | 'product' | 'pullRequestStartCondition' | 'repository' | 'scheduledStartCondition' | 'tagStartCondition' | 'xcodeVersion'>, fieldsScmPullRequests?: Array<'destinationBranchName' | 'destinationRepositoryName' | 'destinationRepositoryOwner' | 'isClosed' | 'isCrossRepository' | 'number' | 'repository' | 'sourceBranchName' | 'sourceRepositoryName' | 'sourceRepositoryOwner' | 'title' | 'webUrl'>, fieldsCiProducts?: Array<'additionalRepositories' | 'app' | 'buildRuns' | 'bundleId' | 'createdDate' | 'name' | 'primaryRepositories' | 'productType' | 'workflows'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, limit?: number, limitBuilds?: number, include?: Array<'builds' | 'destinationBranch' | 'product' | 'pullRequest' | 'sourceBranchOrTag' | 'workflow'>, _options?: Configuration): Observable<CiBuildRunsResponse> {
        return this.ciProductsBuildRunsGetToManyRelatedWithHttpInfo(id, filterBuilds, sort, fieldsScmGitReferences, fieldsCiBuildRuns, fieldsCiWorkflows, fieldsScmPullRequests, fieldsCiProducts, fieldsBuilds, limit, limitBuilds, include, _options).pipe(map((apiResponse: HttpInfo<CiBuildRunsResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public ciProductsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.ciProductsDeleteInstance(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.ciProductsDeleteInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public ciProductsDeleteInstance(id: string, _options?: Configuration): Observable<void> {
        return this.ciProductsDeleteInstanceWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param filterProductType filter by attribute \&#39;productType\&#39;
     * @param filterApp filter by id(s) of related \&#39;app\&#39;
     * @param fieldsCiProducts the fields to include for returned resources of type ciProducts
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsCiBuildRuns the fields to include for returned resources of type ciBuildRuns
     * @param fieldsCiWorkflows the fields to include for returned resources of type ciWorkflows
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsScmRepositories the fields to include for returned resources of type scmRepositories
     * @param limitPrimaryRepositories maximum number of related primaryRepositories returned (when they are included)
     */
    public ciProductsGetCollectionWithHttpInfo(filterProductType?: Array<'APP' | 'FRAMEWORK'>, filterApp?: Array<string>, fieldsCiProducts?: Array<'additionalRepositories' | 'app' | 'buildRuns' | 'bundleId' | 'createdDate' | 'name' | 'primaryRepositories' | 'productType' | 'workflows'>, limit?: number, include?: Array<'app' | 'bundleId' | 'primaryRepositories'>, fieldsCiBuildRuns?: Array<'actions' | 'buildRun' | 'builds' | 'cancelReason' | 'clean' | 'completionStatus' | 'createdDate' | 'destinationBranch' | 'destinationCommit' | 'executionProgress' | 'finishedDate' | 'isPullRequestBuild' | 'issueCounts' | 'number' | 'product' | 'pullRequest' | 'sourceBranchOrTag' | 'sourceCommit' | 'startReason' | 'startedDate' | 'workflow'>, fieldsCiWorkflows?: Array<'actions' | 'branchStartCondition' | 'buildRuns' | 'clean' | 'containerFilePath' | 'description' | 'isEnabled' | 'isLockedForEditing' | 'lastModifiedDate' | 'macOsVersion' | 'manualBranchStartCondition' | 'manualPullRequestStartCondition' | 'manualTagStartCondition' | 'name' | 'product' | 'pullRequestStartCondition' | 'repository' | 'scheduledStartCondition' | 'tagStartCondition' | 'xcodeVersion'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsScmRepositories?: Array<'defaultBranch' | 'gitReferences' | 'httpCloneUrl' | 'lastAccessedDate' | 'ownerName' | 'pullRequests' | 'repositoryName' | 'scmProvider' | 'sshCloneUrl'>, limitPrimaryRepositories?: number, _options?: Configuration): Observable<HttpInfo<CiProductsResponse>> {
        const requestContextPromise = this.requestFactory.ciProductsGetCollection(filterProductType, filterApp, fieldsCiProducts, limit, include, fieldsCiBuildRuns, fieldsCiWorkflows, fieldsApps, fieldsScmRepositories, limitPrimaryRepositories, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.ciProductsGetCollectionWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param filterProductType filter by attribute \&#39;productType\&#39;
     * @param filterApp filter by id(s) of related \&#39;app\&#39;
     * @param fieldsCiProducts the fields to include for returned resources of type ciProducts
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsCiBuildRuns the fields to include for returned resources of type ciBuildRuns
     * @param fieldsCiWorkflows the fields to include for returned resources of type ciWorkflows
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsScmRepositories the fields to include for returned resources of type scmRepositories
     * @param limitPrimaryRepositories maximum number of related primaryRepositories returned (when they are included)
     */
    public ciProductsGetCollection(filterProductType?: Array<'APP' | 'FRAMEWORK'>, filterApp?: Array<string>, fieldsCiProducts?: Array<'additionalRepositories' | 'app' | 'buildRuns' | 'bundleId' | 'createdDate' | 'name' | 'primaryRepositories' | 'productType' | 'workflows'>, limit?: number, include?: Array<'app' | 'bundleId' | 'primaryRepositories'>, fieldsCiBuildRuns?: Array<'actions' | 'buildRun' | 'builds' | 'cancelReason' | 'clean' | 'completionStatus' | 'createdDate' | 'destinationBranch' | 'destinationCommit' | 'executionProgress' | 'finishedDate' | 'isPullRequestBuild' | 'issueCounts' | 'number' | 'product' | 'pullRequest' | 'sourceBranchOrTag' | 'sourceCommit' | 'startReason' | 'startedDate' | 'workflow'>, fieldsCiWorkflows?: Array<'actions' | 'branchStartCondition' | 'buildRuns' | 'clean' | 'containerFilePath' | 'description' | 'isEnabled' | 'isLockedForEditing' | 'lastModifiedDate' | 'macOsVersion' | 'manualBranchStartCondition' | 'manualPullRequestStartCondition' | 'manualTagStartCondition' | 'name' | 'product' | 'pullRequestStartCondition' | 'repository' | 'scheduledStartCondition' | 'tagStartCondition' | 'xcodeVersion'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsScmRepositories?: Array<'defaultBranch' | 'gitReferences' | 'httpCloneUrl' | 'lastAccessedDate' | 'ownerName' | 'pullRequests' | 'repositoryName' | 'scmProvider' | 'sshCloneUrl'>, limitPrimaryRepositories?: number, _options?: Configuration): Observable<CiProductsResponse> {
        return this.ciProductsGetCollectionWithHttpInfo(filterProductType, filterApp, fieldsCiProducts, limit, include, fieldsCiBuildRuns, fieldsCiWorkflows, fieldsApps, fieldsScmRepositories, limitPrimaryRepositories, _options).pipe(map((apiResponse: HttpInfo<CiProductsResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCiProducts the fields to include for returned resources of type ciProducts
     * @param include comma-separated list of relationships to include
     * @param fieldsCiBuildRuns the fields to include for returned resources of type ciBuildRuns
     * @param fieldsCiWorkflows the fields to include for returned resources of type ciWorkflows
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsScmRepositories the fields to include for returned resources of type scmRepositories
     * @param limitPrimaryRepositories maximum number of related primaryRepositories returned (when they are included)
     */
    public ciProductsGetInstanceWithHttpInfo(id: string, fieldsCiProducts?: Array<'additionalRepositories' | 'app' | 'buildRuns' | 'bundleId' | 'createdDate' | 'name' | 'primaryRepositories' | 'productType' | 'workflows'>, include?: Array<'app' | 'bundleId' | 'primaryRepositories'>, fieldsCiBuildRuns?: Array<'actions' | 'buildRun' | 'builds' | 'cancelReason' | 'clean' | 'completionStatus' | 'createdDate' | 'destinationBranch' | 'destinationCommit' | 'executionProgress' | 'finishedDate' | 'isPullRequestBuild' | 'issueCounts' | 'number' | 'product' | 'pullRequest' | 'sourceBranchOrTag' | 'sourceCommit' | 'startReason' | 'startedDate' | 'workflow'>, fieldsCiWorkflows?: Array<'actions' | 'branchStartCondition' | 'buildRuns' | 'clean' | 'containerFilePath' | 'description' | 'isEnabled' | 'isLockedForEditing' | 'lastModifiedDate' | 'macOsVersion' | 'manualBranchStartCondition' | 'manualPullRequestStartCondition' | 'manualTagStartCondition' | 'name' | 'product' | 'pullRequestStartCondition' | 'repository' | 'scheduledStartCondition' | 'tagStartCondition' | 'xcodeVersion'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsScmRepositories?: Array<'defaultBranch' | 'gitReferences' | 'httpCloneUrl' | 'lastAccessedDate' | 'ownerName' | 'pullRequests' | 'repositoryName' | 'scmProvider' | 'sshCloneUrl'>, limitPrimaryRepositories?: number, _options?: Configuration): Observable<HttpInfo<CiProductResponse>> {
        const requestContextPromise = this.requestFactory.ciProductsGetInstance(id, fieldsCiProducts, include, fieldsCiBuildRuns, fieldsCiWorkflows, fieldsApps, fieldsScmRepositories, limitPrimaryRepositories, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.ciProductsGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCiProducts the fields to include for returned resources of type ciProducts
     * @param include comma-separated list of relationships to include
     * @param fieldsCiBuildRuns the fields to include for returned resources of type ciBuildRuns
     * @param fieldsCiWorkflows the fields to include for returned resources of type ciWorkflows
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsScmRepositories the fields to include for returned resources of type scmRepositories
     * @param limitPrimaryRepositories maximum number of related primaryRepositories returned (when they are included)
     */
    public ciProductsGetInstance(id: string, fieldsCiProducts?: Array<'additionalRepositories' | 'app' | 'buildRuns' | 'bundleId' | 'createdDate' | 'name' | 'primaryRepositories' | 'productType' | 'workflows'>, include?: Array<'app' | 'bundleId' | 'primaryRepositories'>, fieldsCiBuildRuns?: Array<'actions' | 'buildRun' | 'builds' | 'cancelReason' | 'clean' | 'completionStatus' | 'createdDate' | 'destinationBranch' | 'destinationCommit' | 'executionProgress' | 'finishedDate' | 'isPullRequestBuild' | 'issueCounts' | 'number' | 'product' | 'pullRequest' | 'sourceBranchOrTag' | 'sourceCommit' | 'startReason' | 'startedDate' | 'workflow'>, fieldsCiWorkflows?: Array<'actions' | 'branchStartCondition' | 'buildRuns' | 'clean' | 'containerFilePath' | 'description' | 'isEnabled' | 'isLockedForEditing' | 'lastModifiedDate' | 'macOsVersion' | 'manualBranchStartCondition' | 'manualPullRequestStartCondition' | 'manualTagStartCondition' | 'name' | 'product' | 'pullRequestStartCondition' | 'repository' | 'scheduledStartCondition' | 'tagStartCondition' | 'xcodeVersion'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsScmRepositories?: Array<'defaultBranch' | 'gitReferences' | 'httpCloneUrl' | 'lastAccessedDate' | 'ownerName' | 'pullRequests' | 'repositoryName' | 'scmProvider' | 'sshCloneUrl'>, limitPrimaryRepositories?: number, _options?: Configuration): Observable<CiProductResponse> {
        return this.ciProductsGetInstanceWithHttpInfo(id, fieldsCiProducts, include, fieldsCiBuildRuns, fieldsCiWorkflows, fieldsApps, fieldsScmRepositories, limitPrimaryRepositories, _options).pipe(map((apiResponse: HttpInfo<CiProductResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param filterId filter by id(s)
     * @param fieldsScmGitReferences the fields to include for returned resources of type scmGitReferences
     * @param fieldsScmProviders the fields to include for returned resources of type scmProviders
     * @param fieldsScmRepositories the fields to include for returned resources of type scmRepositories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public ciProductsPrimaryRepositoriesGetToManyRelatedWithHttpInfo(id: string, filterId?: Array<string>, fieldsScmGitReferences?: Array<'canonicalName' | 'isDeleted' | 'kind' | 'name' | 'repository'>, fieldsScmProviders?: Array<'repositories' | 'scmProviderType' | 'url'>, fieldsScmRepositories?: Array<'defaultBranch' | 'gitReferences' | 'httpCloneUrl' | 'lastAccessedDate' | 'ownerName' | 'pullRequests' | 'repositoryName' | 'scmProvider' | 'sshCloneUrl'>, limit?: number, include?: Array<'defaultBranch' | 'scmProvider'>, _options?: Configuration): Observable<HttpInfo<ScmRepositoriesResponse>> {
        const requestContextPromise = this.requestFactory.ciProductsPrimaryRepositoriesGetToManyRelated(id, filterId, fieldsScmGitReferences, fieldsScmProviders, fieldsScmRepositories, limit, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.ciProductsPrimaryRepositoriesGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param filterId filter by id(s)
     * @param fieldsScmGitReferences the fields to include for returned resources of type scmGitReferences
     * @param fieldsScmProviders the fields to include for returned resources of type scmProviders
     * @param fieldsScmRepositories the fields to include for returned resources of type scmRepositories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public ciProductsPrimaryRepositoriesGetToManyRelated(id: string, filterId?: Array<string>, fieldsScmGitReferences?: Array<'canonicalName' | 'isDeleted' | 'kind' | 'name' | 'repository'>, fieldsScmProviders?: Array<'repositories' | 'scmProviderType' | 'url'>, fieldsScmRepositories?: Array<'defaultBranch' | 'gitReferences' | 'httpCloneUrl' | 'lastAccessedDate' | 'ownerName' | 'pullRequests' | 'repositoryName' | 'scmProvider' | 'sshCloneUrl'>, limit?: number, include?: Array<'defaultBranch' | 'scmProvider'>, _options?: Configuration): Observable<ScmRepositoriesResponse> {
        return this.ciProductsPrimaryRepositoriesGetToManyRelatedWithHttpInfo(id, filterId, fieldsScmGitReferences, fieldsScmProviders, fieldsScmRepositories, limit, include, _options).pipe(map((apiResponse: HttpInfo<ScmRepositoriesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCiXcodeVersions the fields to include for returned resources of type ciXcodeVersions
     * @param fieldsCiWorkflows the fields to include for returned resources of type ciWorkflows
     * @param fieldsCiMacOsVersions the fields to include for returned resources of type ciMacOsVersions
     * @param fieldsCiProducts the fields to include for returned resources of type ciProducts
     * @param fieldsScmRepositories the fields to include for returned resources of type scmRepositories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public ciProductsWorkflowsGetToManyRelatedWithHttpInfo(id: string, fieldsCiXcodeVersions?: Array<'macOsVersions' | 'name' | 'testDestinations' | 'version'>, fieldsCiWorkflows?: Array<'actions' | 'branchStartCondition' | 'buildRuns' | 'clean' | 'containerFilePath' | 'description' | 'isEnabled' | 'isLockedForEditing' | 'lastModifiedDate' | 'macOsVersion' | 'manualBranchStartCondition' | 'manualPullRequestStartCondition' | 'manualTagStartCondition' | 'name' | 'product' | 'pullRequestStartCondition' | 'repository' | 'scheduledStartCondition' | 'tagStartCondition' | 'xcodeVersion'>, fieldsCiMacOsVersions?: Array<'name' | 'version' | 'xcodeVersions'>, fieldsCiProducts?: Array<'additionalRepositories' | 'app' | 'buildRuns' | 'bundleId' | 'createdDate' | 'name' | 'primaryRepositories' | 'productType' | 'workflows'>, fieldsScmRepositories?: Array<'defaultBranch' | 'gitReferences' | 'httpCloneUrl' | 'lastAccessedDate' | 'ownerName' | 'pullRequests' | 'repositoryName' | 'scmProvider' | 'sshCloneUrl'>, limit?: number, include?: Array<'macOsVersion' | 'product' | 'repository' | 'xcodeVersion'>, _options?: Configuration): Observable<HttpInfo<CiWorkflowsResponse>> {
        const requestContextPromise = this.requestFactory.ciProductsWorkflowsGetToManyRelated(id, fieldsCiXcodeVersions, fieldsCiWorkflows, fieldsCiMacOsVersions, fieldsCiProducts, fieldsScmRepositories, limit, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.ciProductsWorkflowsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCiXcodeVersions the fields to include for returned resources of type ciXcodeVersions
     * @param fieldsCiWorkflows the fields to include for returned resources of type ciWorkflows
     * @param fieldsCiMacOsVersions the fields to include for returned resources of type ciMacOsVersions
     * @param fieldsCiProducts the fields to include for returned resources of type ciProducts
     * @param fieldsScmRepositories the fields to include for returned resources of type scmRepositories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public ciProductsWorkflowsGetToManyRelated(id: string, fieldsCiXcodeVersions?: Array<'macOsVersions' | 'name' | 'testDestinations' | 'version'>, fieldsCiWorkflows?: Array<'actions' | 'branchStartCondition' | 'buildRuns' | 'clean' | 'containerFilePath' | 'description' | 'isEnabled' | 'isLockedForEditing' | 'lastModifiedDate' | 'macOsVersion' | 'manualBranchStartCondition' | 'manualPullRequestStartCondition' | 'manualTagStartCondition' | 'name' | 'product' | 'pullRequestStartCondition' | 'repository' | 'scheduledStartCondition' | 'tagStartCondition' | 'xcodeVersion'>, fieldsCiMacOsVersions?: Array<'name' | 'version' | 'xcodeVersions'>, fieldsCiProducts?: Array<'additionalRepositories' | 'app' | 'buildRuns' | 'bundleId' | 'createdDate' | 'name' | 'primaryRepositories' | 'productType' | 'workflows'>, fieldsScmRepositories?: Array<'defaultBranch' | 'gitReferences' | 'httpCloneUrl' | 'lastAccessedDate' | 'ownerName' | 'pullRequests' | 'repositoryName' | 'scmProvider' | 'sshCloneUrl'>, limit?: number, include?: Array<'macOsVersion' | 'product' | 'repository' | 'xcodeVersion'>, _options?: Configuration): Observable<CiWorkflowsResponse> {
        return this.ciProductsWorkflowsGetToManyRelatedWithHttpInfo(id, fieldsCiXcodeVersions, fieldsCiWorkflows, fieldsCiMacOsVersions, fieldsCiProducts, fieldsScmRepositories, limit, include, _options).pipe(map((apiResponse: HttpInfo<CiWorkflowsResponse>) => apiResponse.data));
    }

}

import { CiTestResultsApiRequestFactory, CiTestResultsApiResponseProcessor} from "../apis/CiTestResultsApi.ts";
export class ObservableCiTestResultsApi {
    private requestFactory: CiTestResultsApiRequestFactory;
    private responseProcessor: CiTestResultsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: CiTestResultsApiRequestFactory,
        responseProcessor?: CiTestResultsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new CiTestResultsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new CiTestResultsApiResponseProcessor();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCiTestResults the fields to include for returned resources of type ciTestResults
     */
    public ciTestResultsGetInstanceWithHttpInfo(id: string, fieldsCiTestResults?: Array<'className' | 'destinationTestResults' | 'fileSource' | 'message' | 'name' | 'status'>, _options?: Configuration): Observable<HttpInfo<CiTestResultResponse>> {
        const requestContextPromise = this.requestFactory.ciTestResultsGetInstance(id, fieldsCiTestResults, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.ciTestResultsGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCiTestResults the fields to include for returned resources of type ciTestResults
     */
    public ciTestResultsGetInstance(id: string, fieldsCiTestResults?: Array<'className' | 'destinationTestResults' | 'fileSource' | 'message' | 'name' | 'status'>, _options?: Configuration): Observable<CiTestResultResponse> {
        return this.ciTestResultsGetInstanceWithHttpInfo(id, fieldsCiTestResults, _options).pipe(map((apiResponse: HttpInfo<CiTestResultResponse>) => apiResponse.data));
    }

}

import { CiWorkflowsApiRequestFactory, CiWorkflowsApiResponseProcessor} from "../apis/CiWorkflowsApi.ts";
export class ObservableCiWorkflowsApi {
    private requestFactory: CiWorkflowsApiRequestFactory;
    private responseProcessor: CiWorkflowsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: CiWorkflowsApiRequestFactory,
        responseProcessor?: CiWorkflowsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new CiWorkflowsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new CiWorkflowsApiResponseProcessor();
    }

    /**
     * @param id the id of the requested resource
     * @param filterBuilds filter by id(s) of related \&#39;builds\&#39;
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsScmGitReferences the fields to include for returned resources of type scmGitReferences
     * @param fieldsCiBuildRuns the fields to include for returned resources of type ciBuildRuns
     * @param fieldsCiWorkflows the fields to include for returned resources of type ciWorkflows
     * @param fieldsScmPullRequests the fields to include for returned resources of type scmPullRequests
     * @param fieldsCiProducts the fields to include for returned resources of type ciProducts
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param limit maximum resources per page
     * @param limitBuilds maximum number of related builds returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public ciWorkflowsBuildRunsGetToManyRelatedWithHttpInfo(id: string, filterBuilds?: Array<string>, sort?: Array<'number' | '-number'>, fieldsScmGitReferences?: Array<'canonicalName' | 'isDeleted' | 'kind' | 'name' | 'repository'>, fieldsCiBuildRuns?: Array<'actions' | 'buildRun' | 'builds' | 'cancelReason' | 'clean' | 'completionStatus' | 'createdDate' | 'destinationBranch' | 'destinationCommit' | 'executionProgress' | 'finishedDate' | 'isPullRequestBuild' | 'issueCounts' | 'number' | 'product' | 'pullRequest' | 'sourceBranchOrTag' | 'sourceCommit' | 'startReason' | 'startedDate' | 'workflow'>, fieldsCiWorkflows?: Array<'actions' | 'branchStartCondition' | 'buildRuns' | 'clean' | 'containerFilePath' | 'description' | 'isEnabled' | 'isLockedForEditing' | 'lastModifiedDate' | 'macOsVersion' | 'manualBranchStartCondition' | 'manualPullRequestStartCondition' | 'manualTagStartCondition' | 'name' | 'product' | 'pullRequestStartCondition' | 'repository' | 'scheduledStartCondition' | 'tagStartCondition' | 'xcodeVersion'>, fieldsScmPullRequests?: Array<'destinationBranchName' | 'destinationRepositoryName' | 'destinationRepositoryOwner' | 'isClosed' | 'isCrossRepository' | 'number' | 'repository' | 'sourceBranchName' | 'sourceRepositoryName' | 'sourceRepositoryOwner' | 'title' | 'webUrl'>, fieldsCiProducts?: Array<'additionalRepositories' | 'app' | 'buildRuns' | 'bundleId' | 'createdDate' | 'name' | 'primaryRepositories' | 'productType' | 'workflows'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, limit?: number, limitBuilds?: number, include?: Array<'builds' | 'destinationBranch' | 'product' | 'pullRequest' | 'sourceBranchOrTag' | 'workflow'>, _options?: Configuration): Observable<HttpInfo<CiBuildRunsResponse>> {
        const requestContextPromise = this.requestFactory.ciWorkflowsBuildRunsGetToManyRelated(id, filterBuilds, sort, fieldsScmGitReferences, fieldsCiBuildRuns, fieldsCiWorkflows, fieldsScmPullRequests, fieldsCiProducts, fieldsBuilds, limit, limitBuilds, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.ciWorkflowsBuildRunsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param filterBuilds filter by id(s) of related \&#39;builds\&#39;
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsScmGitReferences the fields to include for returned resources of type scmGitReferences
     * @param fieldsCiBuildRuns the fields to include for returned resources of type ciBuildRuns
     * @param fieldsCiWorkflows the fields to include for returned resources of type ciWorkflows
     * @param fieldsScmPullRequests the fields to include for returned resources of type scmPullRequests
     * @param fieldsCiProducts the fields to include for returned resources of type ciProducts
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param limit maximum resources per page
     * @param limitBuilds maximum number of related builds returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public ciWorkflowsBuildRunsGetToManyRelated(id: string, filterBuilds?: Array<string>, sort?: Array<'number' | '-number'>, fieldsScmGitReferences?: Array<'canonicalName' | 'isDeleted' | 'kind' | 'name' | 'repository'>, fieldsCiBuildRuns?: Array<'actions' | 'buildRun' | 'builds' | 'cancelReason' | 'clean' | 'completionStatus' | 'createdDate' | 'destinationBranch' | 'destinationCommit' | 'executionProgress' | 'finishedDate' | 'isPullRequestBuild' | 'issueCounts' | 'number' | 'product' | 'pullRequest' | 'sourceBranchOrTag' | 'sourceCommit' | 'startReason' | 'startedDate' | 'workflow'>, fieldsCiWorkflows?: Array<'actions' | 'branchStartCondition' | 'buildRuns' | 'clean' | 'containerFilePath' | 'description' | 'isEnabled' | 'isLockedForEditing' | 'lastModifiedDate' | 'macOsVersion' | 'manualBranchStartCondition' | 'manualPullRequestStartCondition' | 'manualTagStartCondition' | 'name' | 'product' | 'pullRequestStartCondition' | 'repository' | 'scheduledStartCondition' | 'tagStartCondition' | 'xcodeVersion'>, fieldsScmPullRequests?: Array<'destinationBranchName' | 'destinationRepositoryName' | 'destinationRepositoryOwner' | 'isClosed' | 'isCrossRepository' | 'number' | 'repository' | 'sourceBranchName' | 'sourceRepositoryName' | 'sourceRepositoryOwner' | 'title' | 'webUrl'>, fieldsCiProducts?: Array<'additionalRepositories' | 'app' | 'buildRuns' | 'bundleId' | 'createdDate' | 'name' | 'primaryRepositories' | 'productType' | 'workflows'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, limit?: number, limitBuilds?: number, include?: Array<'builds' | 'destinationBranch' | 'product' | 'pullRequest' | 'sourceBranchOrTag' | 'workflow'>, _options?: Configuration): Observable<CiBuildRunsResponse> {
        return this.ciWorkflowsBuildRunsGetToManyRelatedWithHttpInfo(id, filterBuilds, sort, fieldsScmGitReferences, fieldsCiBuildRuns, fieldsCiWorkflows, fieldsScmPullRequests, fieldsCiProducts, fieldsBuilds, limit, limitBuilds, include, _options).pipe(map((apiResponse: HttpInfo<CiBuildRunsResponse>) => apiResponse.data));
    }

    /**
     * @param ciWorkflowCreateRequest CiWorkflow representation
     */
    public ciWorkflowsCreateInstanceWithHttpInfo(ciWorkflowCreateRequest: CiWorkflowCreateRequest, _options?: Configuration): Observable<HttpInfo<CiWorkflowResponse>> {
        const requestContextPromise = this.requestFactory.ciWorkflowsCreateInstance(ciWorkflowCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.ciWorkflowsCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param ciWorkflowCreateRequest CiWorkflow representation
     */
    public ciWorkflowsCreateInstance(ciWorkflowCreateRequest: CiWorkflowCreateRequest, _options?: Configuration): Observable<CiWorkflowResponse> {
        return this.ciWorkflowsCreateInstanceWithHttpInfo(ciWorkflowCreateRequest, _options).pipe(map((apiResponse: HttpInfo<CiWorkflowResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public ciWorkflowsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.ciWorkflowsDeleteInstance(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.ciWorkflowsDeleteInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public ciWorkflowsDeleteInstance(id: string, _options?: Configuration): Observable<void> {
        return this.ciWorkflowsDeleteInstanceWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCiWorkflows the fields to include for returned resources of type ciWorkflows
     * @param include comma-separated list of relationships to include
     * @param fieldsCiBuildRuns the fields to include for returned resources of type ciBuildRuns
     * @param fieldsScmRepositories the fields to include for returned resources of type scmRepositories
     */
    public ciWorkflowsGetInstanceWithHttpInfo(id: string, fieldsCiWorkflows?: Array<'actions' | 'branchStartCondition' | 'buildRuns' | 'clean' | 'containerFilePath' | 'description' | 'isEnabled' | 'isLockedForEditing' | 'lastModifiedDate' | 'macOsVersion' | 'manualBranchStartCondition' | 'manualPullRequestStartCondition' | 'manualTagStartCondition' | 'name' | 'product' | 'pullRequestStartCondition' | 'repository' | 'scheduledStartCondition' | 'tagStartCondition' | 'xcodeVersion'>, include?: Array<'macOsVersion' | 'product' | 'repository' | 'xcodeVersion'>, fieldsCiBuildRuns?: Array<'actions' | 'buildRun' | 'builds' | 'cancelReason' | 'clean' | 'completionStatus' | 'createdDate' | 'destinationBranch' | 'destinationCommit' | 'executionProgress' | 'finishedDate' | 'isPullRequestBuild' | 'issueCounts' | 'number' | 'product' | 'pullRequest' | 'sourceBranchOrTag' | 'sourceCommit' | 'startReason' | 'startedDate' | 'workflow'>, fieldsScmRepositories?: Array<'defaultBranch' | 'gitReferences' | 'httpCloneUrl' | 'lastAccessedDate' | 'ownerName' | 'pullRequests' | 'repositoryName' | 'scmProvider' | 'sshCloneUrl'>, _options?: Configuration): Observable<HttpInfo<CiWorkflowResponse>> {
        const requestContextPromise = this.requestFactory.ciWorkflowsGetInstance(id, fieldsCiWorkflows, include, fieldsCiBuildRuns, fieldsScmRepositories, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.ciWorkflowsGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCiWorkflows the fields to include for returned resources of type ciWorkflows
     * @param include comma-separated list of relationships to include
     * @param fieldsCiBuildRuns the fields to include for returned resources of type ciBuildRuns
     * @param fieldsScmRepositories the fields to include for returned resources of type scmRepositories
     */
    public ciWorkflowsGetInstance(id: string, fieldsCiWorkflows?: Array<'actions' | 'branchStartCondition' | 'buildRuns' | 'clean' | 'containerFilePath' | 'description' | 'isEnabled' | 'isLockedForEditing' | 'lastModifiedDate' | 'macOsVersion' | 'manualBranchStartCondition' | 'manualPullRequestStartCondition' | 'manualTagStartCondition' | 'name' | 'product' | 'pullRequestStartCondition' | 'repository' | 'scheduledStartCondition' | 'tagStartCondition' | 'xcodeVersion'>, include?: Array<'macOsVersion' | 'product' | 'repository' | 'xcodeVersion'>, fieldsCiBuildRuns?: Array<'actions' | 'buildRun' | 'builds' | 'cancelReason' | 'clean' | 'completionStatus' | 'createdDate' | 'destinationBranch' | 'destinationCommit' | 'executionProgress' | 'finishedDate' | 'isPullRequestBuild' | 'issueCounts' | 'number' | 'product' | 'pullRequest' | 'sourceBranchOrTag' | 'sourceCommit' | 'startReason' | 'startedDate' | 'workflow'>, fieldsScmRepositories?: Array<'defaultBranch' | 'gitReferences' | 'httpCloneUrl' | 'lastAccessedDate' | 'ownerName' | 'pullRequests' | 'repositoryName' | 'scmProvider' | 'sshCloneUrl'>, _options?: Configuration): Observable<CiWorkflowResponse> {
        return this.ciWorkflowsGetInstanceWithHttpInfo(id, fieldsCiWorkflows, include, fieldsCiBuildRuns, fieldsScmRepositories, _options).pipe(map((apiResponse: HttpInfo<CiWorkflowResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsScmGitReferences the fields to include for returned resources of type scmGitReferences
     * @param fieldsScmProviders the fields to include for returned resources of type scmProviders
     * @param fieldsScmRepositories the fields to include for returned resources of type scmRepositories
     * @param include comma-separated list of relationships to include
     */
    public ciWorkflowsRepositoryGetToOneRelatedWithHttpInfo(id: string, fieldsScmGitReferences?: Array<'canonicalName' | 'isDeleted' | 'kind' | 'name' | 'repository'>, fieldsScmProviders?: Array<'repositories' | 'scmProviderType' | 'url'>, fieldsScmRepositories?: Array<'defaultBranch' | 'gitReferences' | 'httpCloneUrl' | 'lastAccessedDate' | 'ownerName' | 'pullRequests' | 'repositoryName' | 'scmProvider' | 'sshCloneUrl'>, include?: Array<'defaultBranch' | 'scmProvider'>, _options?: Configuration): Observable<HttpInfo<ScmRepositoryResponse>> {
        const requestContextPromise = this.requestFactory.ciWorkflowsRepositoryGetToOneRelated(id, fieldsScmGitReferences, fieldsScmProviders, fieldsScmRepositories, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.ciWorkflowsRepositoryGetToOneRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsScmGitReferences the fields to include for returned resources of type scmGitReferences
     * @param fieldsScmProviders the fields to include for returned resources of type scmProviders
     * @param fieldsScmRepositories the fields to include for returned resources of type scmRepositories
     * @param include comma-separated list of relationships to include
     */
    public ciWorkflowsRepositoryGetToOneRelated(id: string, fieldsScmGitReferences?: Array<'canonicalName' | 'isDeleted' | 'kind' | 'name' | 'repository'>, fieldsScmProviders?: Array<'repositories' | 'scmProviderType' | 'url'>, fieldsScmRepositories?: Array<'defaultBranch' | 'gitReferences' | 'httpCloneUrl' | 'lastAccessedDate' | 'ownerName' | 'pullRequests' | 'repositoryName' | 'scmProvider' | 'sshCloneUrl'>, include?: Array<'defaultBranch' | 'scmProvider'>, _options?: Configuration): Observable<ScmRepositoryResponse> {
        return this.ciWorkflowsRepositoryGetToOneRelatedWithHttpInfo(id, fieldsScmGitReferences, fieldsScmProviders, fieldsScmRepositories, include, _options).pipe(map((apiResponse: HttpInfo<ScmRepositoryResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param ciWorkflowUpdateRequest CiWorkflow representation
     */
    public ciWorkflowsUpdateInstanceWithHttpInfo(id: string, ciWorkflowUpdateRequest: CiWorkflowUpdateRequest, _options?: Configuration): Observable<HttpInfo<CiWorkflowResponse>> {
        const requestContextPromise = this.requestFactory.ciWorkflowsUpdateInstance(id, ciWorkflowUpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.ciWorkflowsUpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param ciWorkflowUpdateRequest CiWorkflow representation
     */
    public ciWorkflowsUpdateInstance(id: string, ciWorkflowUpdateRequest: CiWorkflowUpdateRequest, _options?: Configuration): Observable<CiWorkflowResponse> {
        return this.ciWorkflowsUpdateInstanceWithHttpInfo(id, ciWorkflowUpdateRequest, _options).pipe(map((apiResponse: HttpInfo<CiWorkflowResponse>) => apiResponse.data));
    }

}

import { CiXcodeVersionsApiRequestFactory, CiXcodeVersionsApiResponseProcessor} from "../apis/CiXcodeVersionsApi.ts";
export class ObservableCiXcodeVersionsApi {
    private requestFactory: CiXcodeVersionsApiRequestFactory;
    private responseProcessor: CiXcodeVersionsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: CiXcodeVersionsApiRequestFactory,
        responseProcessor?: CiXcodeVersionsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new CiXcodeVersionsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new CiXcodeVersionsApiResponseProcessor();
    }

    /**
     * @param fieldsCiXcodeVersions the fields to include for returned resources of type ciXcodeVersions
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsCiMacOsVersions the fields to include for returned resources of type ciMacOsVersions
     * @param limitMacOsVersions maximum number of related macOsVersions returned (when they are included)
     */
    public ciXcodeVersionsGetCollectionWithHttpInfo(fieldsCiXcodeVersions?: Array<'macOsVersions' | 'name' | 'testDestinations' | 'version'>, limit?: number, include?: Array<'macOsVersions'>, fieldsCiMacOsVersions?: Array<'name' | 'version' | 'xcodeVersions'>, limitMacOsVersions?: number, _options?: Configuration): Observable<HttpInfo<CiXcodeVersionsResponse>> {
        const requestContextPromise = this.requestFactory.ciXcodeVersionsGetCollection(fieldsCiXcodeVersions, limit, include, fieldsCiMacOsVersions, limitMacOsVersions, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.ciXcodeVersionsGetCollectionWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param fieldsCiXcodeVersions the fields to include for returned resources of type ciXcodeVersions
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsCiMacOsVersions the fields to include for returned resources of type ciMacOsVersions
     * @param limitMacOsVersions maximum number of related macOsVersions returned (when they are included)
     */
    public ciXcodeVersionsGetCollection(fieldsCiXcodeVersions?: Array<'macOsVersions' | 'name' | 'testDestinations' | 'version'>, limit?: number, include?: Array<'macOsVersions'>, fieldsCiMacOsVersions?: Array<'name' | 'version' | 'xcodeVersions'>, limitMacOsVersions?: number, _options?: Configuration): Observable<CiXcodeVersionsResponse> {
        return this.ciXcodeVersionsGetCollectionWithHttpInfo(fieldsCiXcodeVersions, limit, include, fieldsCiMacOsVersions, limitMacOsVersions, _options).pipe(map((apiResponse: HttpInfo<CiXcodeVersionsResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCiXcodeVersions the fields to include for returned resources of type ciXcodeVersions
     * @param include comma-separated list of relationships to include
     * @param fieldsCiMacOsVersions the fields to include for returned resources of type ciMacOsVersions
     * @param limitMacOsVersions maximum number of related macOsVersions returned (when they are included)
     */
    public ciXcodeVersionsGetInstanceWithHttpInfo(id: string, fieldsCiXcodeVersions?: Array<'macOsVersions' | 'name' | 'testDestinations' | 'version'>, include?: Array<'macOsVersions'>, fieldsCiMacOsVersions?: Array<'name' | 'version' | 'xcodeVersions'>, limitMacOsVersions?: number, _options?: Configuration): Observable<HttpInfo<CiXcodeVersionResponse>> {
        const requestContextPromise = this.requestFactory.ciXcodeVersionsGetInstance(id, fieldsCiXcodeVersions, include, fieldsCiMacOsVersions, limitMacOsVersions, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.ciXcodeVersionsGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCiXcodeVersions the fields to include for returned resources of type ciXcodeVersions
     * @param include comma-separated list of relationships to include
     * @param fieldsCiMacOsVersions the fields to include for returned resources of type ciMacOsVersions
     * @param limitMacOsVersions maximum number of related macOsVersions returned (when they are included)
     */
    public ciXcodeVersionsGetInstance(id: string, fieldsCiXcodeVersions?: Array<'macOsVersions' | 'name' | 'testDestinations' | 'version'>, include?: Array<'macOsVersions'>, fieldsCiMacOsVersions?: Array<'name' | 'version' | 'xcodeVersions'>, limitMacOsVersions?: number, _options?: Configuration): Observable<CiXcodeVersionResponse> {
        return this.ciXcodeVersionsGetInstanceWithHttpInfo(id, fieldsCiXcodeVersions, include, fieldsCiMacOsVersions, limitMacOsVersions, _options).pipe(map((apiResponse: HttpInfo<CiXcodeVersionResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCiXcodeVersions the fields to include for returned resources of type ciXcodeVersions
     * @param fieldsCiMacOsVersions the fields to include for returned resources of type ciMacOsVersions
     * @param limit maximum resources per page
     * @param limitXcodeVersions maximum number of related xcodeVersions returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public ciXcodeVersionsMacOsVersionsGetToManyRelatedWithHttpInfo(id: string, fieldsCiXcodeVersions?: Array<'macOsVersions' | 'name' | 'testDestinations' | 'version'>, fieldsCiMacOsVersions?: Array<'name' | 'version' | 'xcodeVersions'>, limit?: number, limitXcodeVersions?: number, include?: Array<'xcodeVersions'>, _options?: Configuration): Observable<HttpInfo<CiMacOsVersionsResponse>> {
        const requestContextPromise = this.requestFactory.ciXcodeVersionsMacOsVersionsGetToManyRelated(id, fieldsCiXcodeVersions, fieldsCiMacOsVersions, limit, limitXcodeVersions, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.ciXcodeVersionsMacOsVersionsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCiXcodeVersions the fields to include for returned resources of type ciXcodeVersions
     * @param fieldsCiMacOsVersions the fields to include for returned resources of type ciMacOsVersions
     * @param limit maximum resources per page
     * @param limitXcodeVersions maximum number of related xcodeVersions returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public ciXcodeVersionsMacOsVersionsGetToManyRelated(id: string, fieldsCiXcodeVersions?: Array<'macOsVersions' | 'name' | 'testDestinations' | 'version'>, fieldsCiMacOsVersions?: Array<'name' | 'version' | 'xcodeVersions'>, limit?: number, limitXcodeVersions?: number, include?: Array<'xcodeVersions'>, _options?: Configuration): Observable<CiMacOsVersionsResponse> {
        return this.ciXcodeVersionsMacOsVersionsGetToManyRelatedWithHttpInfo(id, fieldsCiXcodeVersions, fieldsCiMacOsVersions, limit, limitXcodeVersions, include, _options).pipe(map((apiResponse: HttpInfo<CiMacOsVersionsResponse>) => apiResponse.data));
    }

}

import { CustomerReviewResponsesApiRequestFactory, CustomerReviewResponsesApiResponseProcessor} from "../apis/CustomerReviewResponsesApi.ts";
export class ObservableCustomerReviewResponsesApi {
    private requestFactory: CustomerReviewResponsesApiRequestFactory;
    private responseProcessor: CustomerReviewResponsesApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: CustomerReviewResponsesApiRequestFactory,
        responseProcessor?: CustomerReviewResponsesApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new CustomerReviewResponsesApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new CustomerReviewResponsesApiResponseProcessor();
    }

    /**
     * @param customerReviewResponseV1CreateRequest CustomerReviewResponse representation
     */
    public customerReviewResponsesCreateInstanceWithHttpInfo(customerReviewResponseV1CreateRequest: CustomerReviewResponseV1CreateRequest, _options?: Configuration): Observable<HttpInfo<CustomerReviewResponseV1Response>> {
        const requestContextPromise = this.requestFactory.customerReviewResponsesCreateInstance(customerReviewResponseV1CreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.customerReviewResponsesCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param customerReviewResponseV1CreateRequest CustomerReviewResponse representation
     */
    public customerReviewResponsesCreateInstance(customerReviewResponseV1CreateRequest: CustomerReviewResponseV1CreateRequest, _options?: Configuration): Observable<CustomerReviewResponseV1Response> {
        return this.customerReviewResponsesCreateInstanceWithHttpInfo(customerReviewResponseV1CreateRequest, _options).pipe(map((apiResponse: HttpInfo<CustomerReviewResponseV1Response>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public customerReviewResponsesDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.customerReviewResponsesDeleteInstance(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.customerReviewResponsesDeleteInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public customerReviewResponsesDeleteInstance(id: string, _options?: Configuration): Observable<void> {
        return this.customerReviewResponsesDeleteInstanceWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCustomerReviewResponses the fields to include for returned resources of type customerReviewResponses
     * @param include comma-separated list of relationships to include
     */
    public customerReviewResponsesGetInstanceWithHttpInfo(id: string, fieldsCustomerReviewResponses?: Array<'lastModifiedDate' | 'responseBody' | 'review' | 'state'>, include?: Array<'review'>, _options?: Configuration): Observable<HttpInfo<CustomerReviewResponseV1Response>> {
        const requestContextPromise = this.requestFactory.customerReviewResponsesGetInstance(id, fieldsCustomerReviewResponses, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.customerReviewResponsesGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCustomerReviewResponses the fields to include for returned resources of type customerReviewResponses
     * @param include comma-separated list of relationships to include
     */
    public customerReviewResponsesGetInstance(id: string, fieldsCustomerReviewResponses?: Array<'lastModifiedDate' | 'responseBody' | 'review' | 'state'>, include?: Array<'review'>, _options?: Configuration): Observable<CustomerReviewResponseV1Response> {
        return this.customerReviewResponsesGetInstanceWithHttpInfo(id, fieldsCustomerReviewResponses, include, _options).pipe(map((apiResponse: HttpInfo<CustomerReviewResponseV1Response>) => apiResponse.data));
    }

}

import { CustomerReviewsApiRequestFactory, CustomerReviewsApiResponseProcessor} from "../apis/CustomerReviewsApi.ts";
export class ObservableCustomerReviewsApi {
    private requestFactory: CustomerReviewsApiRequestFactory;
    private responseProcessor: CustomerReviewsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: CustomerReviewsApiRequestFactory,
        responseProcessor?: CustomerReviewsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new CustomerReviewsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new CustomerReviewsApiResponseProcessor();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCustomerReviews the fields to include for returned resources of type customerReviews
     * @param include comma-separated list of relationships to include
     * @param fieldsCustomerReviewResponses the fields to include for returned resources of type customerReviewResponses
     */
    public customerReviewsGetInstanceWithHttpInfo(id: string, fieldsCustomerReviews?: Array<'body' | 'createdDate' | 'rating' | 'response' | 'reviewerNickname' | 'territory' | 'title'>, include?: Array<'response'>, fieldsCustomerReviewResponses?: Array<'lastModifiedDate' | 'responseBody' | 'review' | 'state'>, _options?: Configuration): Observable<HttpInfo<CustomerReviewResponse>> {
        const requestContextPromise = this.requestFactory.customerReviewsGetInstance(id, fieldsCustomerReviews, include, fieldsCustomerReviewResponses, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.customerReviewsGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCustomerReviews the fields to include for returned resources of type customerReviews
     * @param include comma-separated list of relationships to include
     * @param fieldsCustomerReviewResponses the fields to include for returned resources of type customerReviewResponses
     */
    public customerReviewsGetInstance(id: string, fieldsCustomerReviews?: Array<'body' | 'createdDate' | 'rating' | 'response' | 'reviewerNickname' | 'territory' | 'title'>, include?: Array<'response'>, fieldsCustomerReviewResponses?: Array<'lastModifiedDate' | 'responseBody' | 'review' | 'state'>, _options?: Configuration): Observable<CustomerReviewResponse> {
        return this.customerReviewsGetInstanceWithHttpInfo(id, fieldsCustomerReviews, include, fieldsCustomerReviewResponses, _options).pipe(map((apiResponse: HttpInfo<CustomerReviewResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCustomerReviews the fields to include for returned resources of type customerReviews
     * @param fieldsCustomerReviewResponses the fields to include for returned resources of type customerReviewResponses
     * @param include comma-separated list of relationships to include
     */
    public customerReviewsResponseGetToOneRelatedWithHttpInfo(id: string, fieldsCustomerReviews?: Array<'body' | 'createdDate' | 'rating' | 'response' | 'reviewerNickname' | 'territory' | 'title'>, fieldsCustomerReviewResponses?: Array<'lastModifiedDate' | 'responseBody' | 'review' | 'state'>, include?: Array<'review'>, _options?: Configuration): Observable<HttpInfo<CustomerReviewResponseV1Response>> {
        const requestContextPromise = this.requestFactory.customerReviewsResponseGetToOneRelated(id, fieldsCustomerReviews, fieldsCustomerReviewResponses, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.customerReviewsResponseGetToOneRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCustomerReviews the fields to include for returned resources of type customerReviews
     * @param fieldsCustomerReviewResponses the fields to include for returned resources of type customerReviewResponses
     * @param include comma-separated list of relationships to include
     */
    public customerReviewsResponseGetToOneRelated(id: string, fieldsCustomerReviews?: Array<'body' | 'createdDate' | 'rating' | 'response' | 'reviewerNickname' | 'territory' | 'title'>, fieldsCustomerReviewResponses?: Array<'lastModifiedDate' | 'responseBody' | 'review' | 'state'>, include?: Array<'review'>, _options?: Configuration): Observable<CustomerReviewResponseV1Response> {
        return this.customerReviewsResponseGetToOneRelatedWithHttpInfo(id, fieldsCustomerReviews, fieldsCustomerReviewResponses, include, _options).pipe(map((apiResponse: HttpInfo<CustomerReviewResponseV1Response>) => apiResponse.data));
    }

}

import { DevicesApiRequestFactory, DevicesApiResponseProcessor} from "../apis/DevicesApi.ts";
export class ObservableDevicesApi {
    private requestFactory: DevicesApiRequestFactory;
    private responseProcessor: DevicesApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: DevicesApiRequestFactory,
        responseProcessor?: DevicesApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new DevicesApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new DevicesApiResponseProcessor();
    }

    /**
     * @param deviceCreateRequest Device representation
     */
    public devicesCreateInstanceWithHttpInfo(deviceCreateRequest: DeviceCreateRequest, _options?: Configuration): Observable<HttpInfo<DeviceResponse>> {
        const requestContextPromise = this.requestFactory.devicesCreateInstance(deviceCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.devicesCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param deviceCreateRequest Device representation
     */
    public devicesCreateInstance(deviceCreateRequest: DeviceCreateRequest, _options?: Configuration): Observable<DeviceResponse> {
        return this.devicesCreateInstanceWithHttpInfo(deviceCreateRequest, _options).pipe(map((apiResponse: HttpInfo<DeviceResponse>) => apiResponse.data));
    }

    /**
     * @param filterName filter by attribute \&#39;name\&#39;
     * @param filterPlatform filter by attribute \&#39;platform\&#39;
     * @param filterStatus filter by attribute \&#39;status\&#39;
     * @param filterUdid filter by attribute \&#39;udid\&#39;
     * @param filterId filter by id(s)
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsDevices the fields to include for returned resources of type devices
     * @param limit maximum resources per page
     */
    public devicesGetCollectionWithHttpInfo(filterName?: Array<string>, filterPlatform?: Array<'IOS' | 'MAC_OS'>, filterStatus?: Array<'ENABLED' | 'DISABLED'>, filterUdid?: Array<string>, filterId?: Array<string>, sort?: Array<'id' | '-id' | 'name' | '-name' | 'platform' | '-platform' | 'status' | '-status' | 'udid' | '-udid'>, fieldsDevices?: Array<'addedDate' | 'deviceClass' | 'model' | 'name' | 'platform' | 'status' | 'udid'>, limit?: number, _options?: Configuration): Observable<HttpInfo<DevicesResponse>> {
        const requestContextPromise = this.requestFactory.devicesGetCollection(filterName, filterPlatform, filterStatus, filterUdid, filterId, sort, fieldsDevices, limit, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.devicesGetCollectionWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param filterName filter by attribute \&#39;name\&#39;
     * @param filterPlatform filter by attribute \&#39;platform\&#39;
     * @param filterStatus filter by attribute \&#39;status\&#39;
     * @param filterUdid filter by attribute \&#39;udid\&#39;
     * @param filterId filter by id(s)
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsDevices the fields to include for returned resources of type devices
     * @param limit maximum resources per page
     */
    public devicesGetCollection(filterName?: Array<string>, filterPlatform?: Array<'IOS' | 'MAC_OS'>, filterStatus?: Array<'ENABLED' | 'DISABLED'>, filterUdid?: Array<string>, filterId?: Array<string>, sort?: Array<'id' | '-id' | 'name' | '-name' | 'platform' | '-platform' | 'status' | '-status' | 'udid' | '-udid'>, fieldsDevices?: Array<'addedDate' | 'deviceClass' | 'model' | 'name' | 'platform' | 'status' | 'udid'>, limit?: number, _options?: Configuration): Observable<DevicesResponse> {
        return this.devicesGetCollectionWithHttpInfo(filterName, filterPlatform, filterStatus, filterUdid, filterId, sort, fieldsDevices, limit, _options).pipe(map((apiResponse: HttpInfo<DevicesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsDevices the fields to include for returned resources of type devices
     */
    public devicesGetInstanceWithHttpInfo(id: string, fieldsDevices?: Array<'addedDate' | 'deviceClass' | 'model' | 'name' | 'platform' | 'status' | 'udid'>, _options?: Configuration): Observable<HttpInfo<DeviceResponse>> {
        const requestContextPromise = this.requestFactory.devicesGetInstance(id, fieldsDevices, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.devicesGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsDevices the fields to include for returned resources of type devices
     */
    public devicesGetInstance(id: string, fieldsDevices?: Array<'addedDate' | 'deviceClass' | 'model' | 'name' | 'platform' | 'status' | 'udid'>, _options?: Configuration): Observable<DeviceResponse> {
        return this.devicesGetInstanceWithHttpInfo(id, fieldsDevices, _options).pipe(map((apiResponse: HttpInfo<DeviceResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param deviceUpdateRequest Device representation
     */
    public devicesUpdateInstanceWithHttpInfo(id: string, deviceUpdateRequest: DeviceUpdateRequest, _options?: Configuration): Observable<HttpInfo<DeviceResponse>> {
        const requestContextPromise = this.requestFactory.devicesUpdateInstance(id, deviceUpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.devicesUpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param deviceUpdateRequest Device representation
     */
    public devicesUpdateInstance(id: string, deviceUpdateRequest: DeviceUpdateRequest, _options?: Configuration): Observable<DeviceResponse> {
        return this.devicesUpdateInstanceWithHttpInfo(id, deviceUpdateRequest, _options).pipe(map((apiResponse: HttpInfo<DeviceResponse>) => apiResponse.data));
    }

}

import { DiagnosticSignaturesApiRequestFactory, DiagnosticSignaturesApiResponseProcessor} from "../apis/DiagnosticSignaturesApi.ts";
export class ObservableDiagnosticSignaturesApi {
    private requestFactory: DiagnosticSignaturesApiRequestFactory;
    private responseProcessor: DiagnosticSignaturesApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: DiagnosticSignaturesApiRequestFactory,
        responseProcessor?: DiagnosticSignaturesApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new DiagnosticSignaturesApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new DiagnosticSignaturesApiResponseProcessor();
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public diagnosticSignaturesLogsGetToManyRelatedWithHttpInfo(id: string, limit?: number, _options?: Configuration): Observable<HttpInfo<DiagnosticLogs>> {
        const requestContextPromise = this.requestFactory.diagnosticSignaturesLogsGetToManyRelated(id, limit, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.diagnosticSignaturesLogsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public diagnosticSignaturesLogsGetToManyRelated(id: string, limit?: number, _options?: Configuration): Observable<DiagnosticLogs> {
        return this.diagnosticSignaturesLogsGetToManyRelatedWithHttpInfo(id, limit, _options).pipe(map((apiResponse: HttpInfo<DiagnosticLogs>) => apiResponse.data));
    }

}

import { EndAppAvailabilityPreOrdersApiRequestFactory, EndAppAvailabilityPreOrdersApiResponseProcessor} from "../apis/EndAppAvailabilityPreOrdersApi.ts";
export class ObservableEndAppAvailabilityPreOrdersApi {
    private requestFactory: EndAppAvailabilityPreOrdersApiRequestFactory;
    private responseProcessor: EndAppAvailabilityPreOrdersApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: EndAppAvailabilityPreOrdersApiRequestFactory,
        responseProcessor?: EndAppAvailabilityPreOrdersApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new EndAppAvailabilityPreOrdersApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new EndAppAvailabilityPreOrdersApiResponseProcessor();
    }

    /**
     * @param endAppAvailabilityPreOrderCreateRequest EndAppAvailabilityPreOrder representation
     */
    public endAppAvailabilityPreOrdersCreateInstanceWithHttpInfo(endAppAvailabilityPreOrderCreateRequest: EndAppAvailabilityPreOrderCreateRequest, _options?: Configuration): Observable<HttpInfo<EndAppAvailabilityPreOrderResponse>> {
        const requestContextPromise = this.requestFactory.endAppAvailabilityPreOrdersCreateInstance(endAppAvailabilityPreOrderCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.endAppAvailabilityPreOrdersCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param endAppAvailabilityPreOrderCreateRequest EndAppAvailabilityPreOrder representation
     */
    public endAppAvailabilityPreOrdersCreateInstance(endAppAvailabilityPreOrderCreateRequest: EndAppAvailabilityPreOrderCreateRequest, _options?: Configuration): Observable<EndAppAvailabilityPreOrderResponse> {
        return this.endAppAvailabilityPreOrdersCreateInstanceWithHttpInfo(endAppAvailabilityPreOrderCreateRequest, _options).pipe(map((apiResponse: HttpInfo<EndAppAvailabilityPreOrderResponse>) => apiResponse.data));
    }

}

import { EndUserLicenseAgreementsApiRequestFactory, EndUserLicenseAgreementsApiResponseProcessor} from "../apis/EndUserLicenseAgreementsApi.ts";
export class ObservableEndUserLicenseAgreementsApi {
    private requestFactory: EndUserLicenseAgreementsApiRequestFactory;
    private responseProcessor: EndUserLicenseAgreementsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: EndUserLicenseAgreementsApiRequestFactory,
        responseProcessor?: EndUserLicenseAgreementsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new EndUserLicenseAgreementsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new EndUserLicenseAgreementsApiResponseProcessor();
    }

    /**
     * @param endUserLicenseAgreementCreateRequest EndUserLicenseAgreement representation
     */
    public endUserLicenseAgreementsCreateInstanceWithHttpInfo(endUserLicenseAgreementCreateRequest: EndUserLicenseAgreementCreateRequest, _options?: Configuration): Observable<HttpInfo<EndUserLicenseAgreementResponse>> {
        const requestContextPromise = this.requestFactory.endUserLicenseAgreementsCreateInstance(endUserLicenseAgreementCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.endUserLicenseAgreementsCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param endUserLicenseAgreementCreateRequest EndUserLicenseAgreement representation
     */
    public endUserLicenseAgreementsCreateInstance(endUserLicenseAgreementCreateRequest: EndUserLicenseAgreementCreateRequest, _options?: Configuration): Observable<EndUserLicenseAgreementResponse> {
        return this.endUserLicenseAgreementsCreateInstanceWithHttpInfo(endUserLicenseAgreementCreateRequest, _options).pipe(map((apiResponse: HttpInfo<EndUserLicenseAgreementResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public endUserLicenseAgreementsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.endUserLicenseAgreementsDeleteInstance(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.endUserLicenseAgreementsDeleteInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public endUserLicenseAgreementsDeleteInstance(id: string, _options?: Configuration): Observable<void> {
        return this.endUserLicenseAgreementsDeleteInstanceWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsEndUserLicenseAgreements the fields to include for returned resources of type endUserLicenseAgreements
     * @param include comma-separated list of relationships to include
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limitTerritories maximum number of related territories returned (when they are included)
     */
    public endUserLicenseAgreementsGetInstanceWithHttpInfo(id: string, fieldsEndUserLicenseAgreements?: Array<'agreementText' | 'app' | 'territories'>, include?: Array<'app' | 'territories'>, fieldsTerritories?: Array<'currency'>, limitTerritories?: number, _options?: Configuration): Observable<HttpInfo<EndUserLicenseAgreementResponse>> {
        const requestContextPromise = this.requestFactory.endUserLicenseAgreementsGetInstance(id, fieldsEndUserLicenseAgreements, include, fieldsTerritories, limitTerritories, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.endUserLicenseAgreementsGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsEndUserLicenseAgreements the fields to include for returned resources of type endUserLicenseAgreements
     * @param include comma-separated list of relationships to include
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limitTerritories maximum number of related territories returned (when they are included)
     */
    public endUserLicenseAgreementsGetInstance(id: string, fieldsEndUserLicenseAgreements?: Array<'agreementText' | 'app' | 'territories'>, include?: Array<'app' | 'territories'>, fieldsTerritories?: Array<'currency'>, limitTerritories?: number, _options?: Configuration): Observable<EndUserLicenseAgreementResponse> {
        return this.endUserLicenseAgreementsGetInstanceWithHttpInfo(id, fieldsEndUserLicenseAgreements, include, fieldsTerritories, limitTerritories, _options).pipe(map((apiResponse: HttpInfo<EndUserLicenseAgreementResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limit maximum resources per page
     */
    public endUserLicenseAgreementsTerritoriesGetToManyRelatedWithHttpInfo(id: string, fieldsTerritories?: Array<'currency'>, limit?: number, _options?: Configuration): Observable<HttpInfo<TerritoriesWithoutIncludesResponse>> {
        const requestContextPromise = this.requestFactory.endUserLicenseAgreementsTerritoriesGetToManyRelated(id, fieldsTerritories, limit, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.endUserLicenseAgreementsTerritoriesGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limit maximum resources per page
     */
    public endUserLicenseAgreementsTerritoriesGetToManyRelated(id: string, fieldsTerritories?: Array<'currency'>, limit?: number, _options?: Configuration): Observable<TerritoriesWithoutIncludesResponse> {
        return this.endUserLicenseAgreementsTerritoriesGetToManyRelatedWithHttpInfo(id, fieldsTerritories, limit, _options).pipe(map((apiResponse: HttpInfo<TerritoriesWithoutIncludesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param endUserLicenseAgreementUpdateRequest EndUserLicenseAgreement representation
     */
    public endUserLicenseAgreementsUpdateInstanceWithHttpInfo(id: string, endUserLicenseAgreementUpdateRequest: EndUserLicenseAgreementUpdateRequest, _options?: Configuration): Observable<HttpInfo<EndUserLicenseAgreementResponse>> {
        const requestContextPromise = this.requestFactory.endUserLicenseAgreementsUpdateInstance(id, endUserLicenseAgreementUpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.endUserLicenseAgreementsUpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param endUserLicenseAgreementUpdateRequest EndUserLicenseAgreement representation
     */
    public endUserLicenseAgreementsUpdateInstance(id: string, endUserLicenseAgreementUpdateRequest: EndUserLicenseAgreementUpdateRequest, _options?: Configuration): Observable<EndUserLicenseAgreementResponse> {
        return this.endUserLicenseAgreementsUpdateInstanceWithHttpInfo(id, endUserLicenseAgreementUpdateRequest, _options).pipe(map((apiResponse: HttpInfo<EndUserLicenseAgreementResponse>) => apiResponse.data));
    }

}

import { FinanceReportsApiRequestFactory, FinanceReportsApiResponseProcessor} from "../apis/FinanceReportsApi.ts";
export class ObservableFinanceReportsApi {
    private requestFactory: FinanceReportsApiRequestFactory;
    private responseProcessor: FinanceReportsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: FinanceReportsApiRequestFactory,
        responseProcessor?: FinanceReportsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new FinanceReportsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new FinanceReportsApiResponseProcessor();
    }

    /**
     * @param filterRegionCode filter by attribute \&#39;regionCode\&#39;
     * @param filterReportDate filter by attribute \&#39;reportDate\&#39;
     * @param filterReportType filter by attribute \&#39;reportType\&#39;
     * @param filterVendorNumber filter by attribute \&#39;vendorNumber\&#39;
     */
    public financeReportsGetCollectionWithHttpInfo(filterRegionCode: Array<string>, filterReportDate: Array<string>, filterReportType: Array<'FINANCIAL' | 'FINANCE_DETAIL'>, filterVendorNumber: Array<string>, _options?: Configuration): Observable<HttpInfo<HttpFile>> {
        const requestContextPromise = this.requestFactory.financeReportsGetCollection(filterRegionCode, filterReportDate, filterReportType, filterVendorNumber, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.financeReportsGetCollectionWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param filterRegionCode filter by attribute \&#39;regionCode\&#39;
     * @param filterReportDate filter by attribute \&#39;reportDate\&#39;
     * @param filterReportType filter by attribute \&#39;reportType\&#39;
     * @param filterVendorNumber filter by attribute \&#39;vendorNumber\&#39;
     */
    public financeReportsGetCollection(filterRegionCode: Array<string>, filterReportDate: Array<string>, filterReportType: Array<'FINANCIAL' | 'FINANCE_DETAIL'>, filterVendorNumber: Array<string>, _options?: Configuration): Observable<HttpFile> {
        return this.financeReportsGetCollectionWithHttpInfo(filterRegionCode, filterReportDate, filterReportType, filterVendorNumber, _options).pipe(map((apiResponse: HttpInfo<HttpFile>) => apiResponse.data));
    }

}

import { GameCenterAchievementImagesApiRequestFactory, GameCenterAchievementImagesApiResponseProcessor} from "../apis/GameCenterAchievementImagesApi.ts";
export class ObservableGameCenterAchievementImagesApi {
    private requestFactory: GameCenterAchievementImagesApiRequestFactory;
    private responseProcessor: GameCenterAchievementImagesApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: GameCenterAchievementImagesApiRequestFactory,
        responseProcessor?: GameCenterAchievementImagesApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new GameCenterAchievementImagesApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new GameCenterAchievementImagesApiResponseProcessor();
    }

    /**
     * @param gameCenterAchievementImageCreateRequest GameCenterAchievementImage representation
     */
    public gameCenterAchievementImagesCreateInstanceWithHttpInfo(gameCenterAchievementImageCreateRequest: GameCenterAchievementImageCreateRequest, _options?: Configuration): Observable<HttpInfo<GameCenterAchievementImageResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterAchievementImagesCreateInstance(gameCenterAchievementImageCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterAchievementImagesCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param gameCenterAchievementImageCreateRequest GameCenterAchievementImage representation
     */
    public gameCenterAchievementImagesCreateInstance(gameCenterAchievementImageCreateRequest: GameCenterAchievementImageCreateRequest, _options?: Configuration): Observable<GameCenterAchievementImageResponse> {
        return this.gameCenterAchievementImagesCreateInstanceWithHttpInfo(gameCenterAchievementImageCreateRequest, _options).pipe(map((apiResponse: HttpInfo<GameCenterAchievementImageResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterAchievementImagesDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.gameCenterAchievementImagesDeleteInstance(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterAchievementImagesDeleteInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterAchievementImagesDeleteInstance(id: string, _options?: Configuration): Observable<void> {
        return this.gameCenterAchievementImagesDeleteInstanceWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterAchievementImages the fields to include for returned resources of type gameCenterAchievementImages
     * @param include comma-separated list of relationships to include
     */
    public gameCenterAchievementImagesGetInstanceWithHttpInfo(id: string, fieldsGameCenterAchievementImages?: Array<'assetDeliveryState' | 'fileName' | 'fileSize' | 'gameCenterAchievementLocalization' | 'imageAsset' | 'uploadOperations' | 'uploaded'>, include?: Array<'gameCenterAchievementLocalization'>, _options?: Configuration): Observable<HttpInfo<GameCenterAchievementImageResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterAchievementImagesGetInstance(id, fieldsGameCenterAchievementImages, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterAchievementImagesGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterAchievementImages the fields to include for returned resources of type gameCenterAchievementImages
     * @param include comma-separated list of relationships to include
     */
    public gameCenterAchievementImagesGetInstance(id: string, fieldsGameCenterAchievementImages?: Array<'assetDeliveryState' | 'fileName' | 'fileSize' | 'gameCenterAchievementLocalization' | 'imageAsset' | 'uploadOperations' | 'uploaded'>, include?: Array<'gameCenterAchievementLocalization'>, _options?: Configuration): Observable<GameCenterAchievementImageResponse> {
        return this.gameCenterAchievementImagesGetInstanceWithHttpInfo(id, fieldsGameCenterAchievementImages, include, _options).pipe(map((apiResponse: HttpInfo<GameCenterAchievementImageResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterAchievementImageUpdateRequest GameCenterAchievementImage representation
     */
    public gameCenterAchievementImagesUpdateInstanceWithHttpInfo(id: string, gameCenterAchievementImageUpdateRequest: GameCenterAchievementImageUpdateRequest, _options?: Configuration): Observable<HttpInfo<GameCenterAchievementImageResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterAchievementImagesUpdateInstance(id, gameCenterAchievementImageUpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterAchievementImagesUpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterAchievementImageUpdateRequest GameCenterAchievementImage representation
     */
    public gameCenterAchievementImagesUpdateInstance(id: string, gameCenterAchievementImageUpdateRequest: GameCenterAchievementImageUpdateRequest, _options?: Configuration): Observable<GameCenterAchievementImageResponse> {
        return this.gameCenterAchievementImagesUpdateInstanceWithHttpInfo(id, gameCenterAchievementImageUpdateRequest, _options).pipe(map((apiResponse: HttpInfo<GameCenterAchievementImageResponse>) => apiResponse.data));
    }

}

import { GameCenterAchievementLocalizationsApiRequestFactory, GameCenterAchievementLocalizationsApiResponseProcessor} from "../apis/GameCenterAchievementLocalizationsApi.ts";
export class ObservableGameCenterAchievementLocalizationsApi {
    private requestFactory: GameCenterAchievementLocalizationsApiRequestFactory;
    private responseProcessor: GameCenterAchievementLocalizationsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: GameCenterAchievementLocalizationsApiRequestFactory,
        responseProcessor?: GameCenterAchievementLocalizationsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new GameCenterAchievementLocalizationsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new GameCenterAchievementLocalizationsApiResponseProcessor();
    }

    /**
     * @param gameCenterAchievementLocalizationCreateRequest GameCenterAchievementLocalization representation
     */
    public gameCenterAchievementLocalizationsCreateInstanceWithHttpInfo(gameCenterAchievementLocalizationCreateRequest: GameCenterAchievementLocalizationCreateRequest, _options?: Configuration): Observable<HttpInfo<GameCenterAchievementLocalizationResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterAchievementLocalizationsCreateInstance(gameCenterAchievementLocalizationCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterAchievementLocalizationsCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param gameCenterAchievementLocalizationCreateRequest GameCenterAchievementLocalization representation
     */
    public gameCenterAchievementLocalizationsCreateInstance(gameCenterAchievementLocalizationCreateRequest: GameCenterAchievementLocalizationCreateRequest, _options?: Configuration): Observable<GameCenterAchievementLocalizationResponse> {
        return this.gameCenterAchievementLocalizationsCreateInstanceWithHttpInfo(gameCenterAchievementLocalizationCreateRequest, _options).pipe(map((apiResponse: HttpInfo<GameCenterAchievementLocalizationResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterAchievementLocalizationsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.gameCenterAchievementLocalizationsDeleteInstance(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterAchievementLocalizationsDeleteInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterAchievementLocalizationsDeleteInstance(id: string, _options?: Configuration): Observable<void> {
        return this.gameCenterAchievementLocalizationsDeleteInstanceWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterAchievementReleases the fields to include for returned resources of type gameCenterAchievementReleases
     * @param fieldsGameCenterGroups the fields to include for returned resources of type gameCenterGroups
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterAchievementLocalizations the fields to include for returned resources of type gameCenterAchievementLocalizations
     * @param fieldsGameCenterAchievements the fields to include for returned resources of type gameCenterAchievements
     * @param limitLocalizations maximum number of related localizations returned (when they are included)
     * @param limitReleases maximum number of related releases returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public gameCenterAchievementLocalizationsGameCenterAchievementGetToOneRelatedWithHttpInfo(id: string, fieldsGameCenterAchievementReleases?: Array<'gameCenterAchievement' | 'gameCenterDetail' | 'live'>, fieldsGameCenterGroups?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'referenceName'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterAchievementLocalizations?: Array<'afterEarnedDescription' | 'beforeEarnedDescription' | 'gameCenterAchievement' | 'gameCenterAchievementImage' | 'locale' | 'name'>, fieldsGameCenterAchievements?: Array<'archived' | 'gameCenterDetail' | 'gameCenterGroup' | 'groupAchievement' | 'localizations' | 'points' | 'referenceName' | 'releases' | 'repeatable' | 'showBeforeEarned' | 'vendorIdentifier'>, limitLocalizations?: number, limitReleases?: number, include?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'groupAchievement' | 'localizations' | 'releases'>, _options?: Configuration): Observable<HttpInfo<GameCenterAchievementResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterAchievementLocalizationsGameCenterAchievementGetToOneRelated(id, fieldsGameCenterAchievementReleases, fieldsGameCenterGroups, fieldsGameCenterDetails, fieldsGameCenterAchievementLocalizations, fieldsGameCenterAchievements, limitLocalizations, limitReleases, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterAchievementLocalizationsGameCenterAchievementGetToOneRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterAchievementReleases the fields to include for returned resources of type gameCenterAchievementReleases
     * @param fieldsGameCenterGroups the fields to include for returned resources of type gameCenterGroups
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterAchievementLocalizations the fields to include for returned resources of type gameCenterAchievementLocalizations
     * @param fieldsGameCenterAchievements the fields to include for returned resources of type gameCenterAchievements
     * @param limitLocalizations maximum number of related localizations returned (when they are included)
     * @param limitReleases maximum number of related releases returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public gameCenterAchievementLocalizationsGameCenterAchievementGetToOneRelated(id: string, fieldsGameCenterAchievementReleases?: Array<'gameCenterAchievement' | 'gameCenterDetail' | 'live'>, fieldsGameCenterGroups?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'referenceName'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterAchievementLocalizations?: Array<'afterEarnedDescription' | 'beforeEarnedDescription' | 'gameCenterAchievement' | 'gameCenterAchievementImage' | 'locale' | 'name'>, fieldsGameCenterAchievements?: Array<'archived' | 'gameCenterDetail' | 'gameCenterGroup' | 'groupAchievement' | 'localizations' | 'points' | 'referenceName' | 'releases' | 'repeatable' | 'showBeforeEarned' | 'vendorIdentifier'>, limitLocalizations?: number, limitReleases?: number, include?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'groupAchievement' | 'localizations' | 'releases'>, _options?: Configuration): Observable<GameCenterAchievementResponse> {
        return this.gameCenterAchievementLocalizationsGameCenterAchievementGetToOneRelatedWithHttpInfo(id, fieldsGameCenterAchievementReleases, fieldsGameCenterGroups, fieldsGameCenterDetails, fieldsGameCenterAchievementLocalizations, fieldsGameCenterAchievements, limitLocalizations, limitReleases, include, _options).pipe(map((apiResponse: HttpInfo<GameCenterAchievementResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterAchievementImages the fields to include for returned resources of type gameCenterAchievementImages
     * @param fieldsGameCenterAchievementLocalizations the fields to include for returned resources of type gameCenterAchievementLocalizations
     * @param include comma-separated list of relationships to include
     */
    public gameCenterAchievementLocalizationsGameCenterAchievementImageGetToOneRelatedWithHttpInfo(id: string, fieldsGameCenterAchievementImages?: Array<'assetDeliveryState' | 'fileName' | 'fileSize' | 'gameCenterAchievementLocalization' | 'imageAsset' | 'uploadOperations' | 'uploaded'>, fieldsGameCenterAchievementLocalizations?: Array<'afterEarnedDescription' | 'beforeEarnedDescription' | 'gameCenterAchievement' | 'gameCenterAchievementImage' | 'locale' | 'name'>, include?: Array<'gameCenterAchievementLocalization'>, _options?: Configuration): Observable<HttpInfo<GameCenterAchievementImageResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterAchievementLocalizationsGameCenterAchievementImageGetToOneRelated(id, fieldsGameCenterAchievementImages, fieldsGameCenterAchievementLocalizations, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterAchievementLocalizationsGameCenterAchievementImageGetToOneRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterAchievementImages the fields to include for returned resources of type gameCenterAchievementImages
     * @param fieldsGameCenterAchievementLocalizations the fields to include for returned resources of type gameCenterAchievementLocalizations
     * @param include comma-separated list of relationships to include
     */
    public gameCenterAchievementLocalizationsGameCenterAchievementImageGetToOneRelated(id: string, fieldsGameCenterAchievementImages?: Array<'assetDeliveryState' | 'fileName' | 'fileSize' | 'gameCenterAchievementLocalization' | 'imageAsset' | 'uploadOperations' | 'uploaded'>, fieldsGameCenterAchievementLocalizations?: Array<'afterEarnedDescription' | 'beforeEarnedDescription' | 'gameCenterAchievement' | 'gameCenterAchievementImage' | 'locale' | 'name'>, include?: Array<'gameCenterAchievementLocalization'>, _options?: Configuration): Observable<GameCenterAchievementImageResponse> {
        return this.gameCenterAchievementLocalizationsGameCenterAchievementImageGetToOneRelatedWithHttpInfo(id, fieldsGameCenterAchievementImages, fieldsGameCenterAchievementLocalizations, include, _options).pipe(map((apiResponse: HttpInfo<GameCenterAchievementImageResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterAchievementLocalizations the fields to include for returned resources of type gameCenterAchievementLocalizations
     * @param include comma-separated list of relationships to include
     * @param fieldsGameCenterAchievementImages the fields to include for returned resources of type gameCenterAchievementImages
     * @param fieldsGameCenterAchievements the fields to include for returned resources of type gameCenterAchievements
     */
    public gameCenterAchievementLocalizationsGetInstanceWithHttpInfo(id: string, fieldsGameCenterAchievementLocalizations?: Array<'afterEarnedDescription' | 'beforeEarnedDescription' | 'gameCenterAchievement' | 'gameCenterAchievementImage' | 'locale' | 'name'>, include?: Array<'gameCenterAchievement' | 'gameCenterAchievementImage'>, fieldsGameCenterAchievementImages?: Array<'assetDeliveryState' | 'fileName' | 'fileSize' | 'gameCenterAchievementLocalization' | 'imageAsset' | 'uploadOperations' | 'uploaded'>, fieldsGameCenterAchievements?: Array<'archived' | 'gameCenterDetail' | 'gameCenterGroup' | 'groupAchievement' | 'localizations' | 'points' | 'referenceName' | 'releases' | 'repeatable' | 'showBeforeEarned' | 'vendorIdentifier'>, _options?: Configuration): Observable<HttpInfo<GameCenterAchievementLocalizationResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterAchievementLocalizationsGetInstance(id, fieldsGameCenterAchievementLocalizations, include, fieldsGameCenterAchievementImages, fieldsGameCenterAchievements, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterAchievementLocalizationsGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterAchievementLocalizations the fields to include for returned resources of type gameCenterAchievementLocalizations
     * @param include comma-separated list of relationships to include
     * @param fieldsGameCenterAchievementImages the fields to include for returned resources of type gameCenterAchievementImages
     * @param fieldsGameCenterAchievements the fields to include for returned resources of type gameCenterAchievements
     */
    public gameCenterAchievementLocalizationsGetInstance(id: string, fieldsGameCenterAchievementLocalizations?: Array<'afterEarnedDescription' | 'beforeEarnedDescription' | 'gameCenterAchievement' | 'gameCenterAchievementImage' | 'locale' | 'name'>, include?: Array<'gameCenterAchievement' | 'gameCenterAchievementImage'>, fieldsGameCenterAchievementImages?: Array<'assetDeliveryState' | 'fileName' | 'fileSize' | 'gameCenterAchievementLocalization' | 'imageAsset' | 'uploadOperations' | 'uploaded'>, fieldsGameCenterAchievements?: Array<'archived' | 'gameCenterDetail' | 'gameCenterGroup' | 'groupAchievement' | 'localizations' | 'points' | 'referenceName' | 'releases' | 'repeatable' | 'showBeforeEarned' | 'vendorIdentifier'>, _options?: Configuration): Observable<GameCenterAchievementLocalizationResponse> {
        return this.gameCenterAchievementLocalizationsGetInstanceWithHttpInfo(id, fieldsGameCenterAchievementLocalizations, include, fieldsGameCenterAchievementImages, fieldsGameCenterAchievements, _options).pipe(map((apiResponse: HttpInfo<GameCenterAchievementLocalizationResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterAchievementLocalizationUpdateRequest GameCenterAchievementLocalization representation
     */
    public gameCenterAchievementLocalizationsUpdateInstanceWithHttpInfo(id: string, gameCenterAchievementLocalizationUpdateRequest: GameCenterAchievementLocalizationUpdateRequest, _options?: Configuration): Observable<HttpInfo<GameCenterAchievementLocalizationResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterAchievementLocalizationsUpdateInstance(id, gameCenterAchievementLocalizationUpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterAchievementLocalizationsUpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterAchievementLocalizationUpdateRequest GameCenterAchievementLocalization representation
     */
    public gameCenterAchievementLocalizationsUpdateInstance(id: string, gameCenterAchievementLocalizationUpdateRequest: GameCenterAchievementLocalizationUpdateRequest, _options?: Configuration): Observable<GameCenterAchievementLocalizationResponse> {
        return this.gameCenterAchievementLocalizationsUpdateInstanceWithHttpInfo(id, gameCenterAchievementLocalizationUpdateRequest, _options).pipe(map((apiResponse: HttpInfo<GameCenterAchievementLocalizationResponse>) => apiResponse.data));
    }

}

import { GameCenterAchievementReleasesApiRequestFactory, GameCenterAchievementReleasesApiResponseProcessor} from "../apis/GameCenterAchievementReleasesApi.ts";
export class ObservableGameCenterAchievementReleasesApi {
    private requestFactory: GameCenterAchievementReleasesApiRequestFactory;
    private responseProcessor: GameCenterAchievementReleasesApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: GameCenterAchievementReleasesApiRequestFactory,
        responseProcessor?: GameCenterAchievementReleasesApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new GameCenterAchievementReleasesApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new GameCenterAchievementReleasesApiResponseProcessor();
    }

    /**
     * @param gameCenterAchievementReleaseCreateRequest GameCenterAchievementRelease representation
     */
    public gameCenterAchievementReleasesCreateInstanceWithHttpInfo(gameCenterAchievementReleaseCreateRequest: GameCenterAchievementReleaseCreateRequest, _options?: Configuration): Observable<HttpInfo<GameCenterAchievementReleaseResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterAchievementReleasesCreateInstance(gameCenterAchievementReleaseCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterAchievementReleasesCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param gameCenterAchievementReleaseCreateRequest GameCenterAchievementRelease representation
     */
    public gameCenterAchievementReleasesCreateInstance(gameCenterAchievementReleaseCreateRequest: GameCenterAchievementReleaseCreateRequest, _options?: Configuration): Observable<GameCenterAchievementReleaseResponse> {
        return this.gameCenterAchievementReleasesCreateInstanceWithHttpInfo(gameCenterAchievementReleaseCreateRequest, _options).pipe(map((apiResponse: HttpInfo<GameCenterAchievementReleaseResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterAchievementReleasesDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.gameCenterAchievementReleasesDeleteInstance(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterAchievementReleasesDeleteInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterAchievementReleasesDeleteInstance(id: string, _options?: Configuration): Observable<void> {
        return this.gameCenterAchievementReleasesDeleteInstanceWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterAchievementReleases the fields to include for returned resources of type gameCenterAchievementReleases
     * @param include comma-separated list of relationships to include
     */
    public gameCenterAchievementReleasesGetInstanceWithHttpInfo(id: string, fieldsGameCenterAchievementReleases?: Array<'gameCenterAchievement' | 'gameCenterDetail' | 'live'>, include?: Array<'gameCenterAchievement' | 'gameCenterDetail'>, _options?: Configuration): Observable<HttpInfo<GameCenterAchievementReleaseResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterAchievementReleasesGetInstance(id, fieldsGameCenterAchievementReleases, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterAchievementReleasesGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterAchievementReleases the fields to include for returned resources of type gameCenterAchievementReleases
     * @param include comma-separated list of relationships to include
     */
    public gameCenterAchievementReleasesGetInstance(id: string, fieldsGameCenterAchievementReleases?: Array<'gameCenterAchievement' | 'gameCenterDetail' | 'live'>, include?: Array<'gameCenterAchievement' | 'gameCenterDetail'>, _options?: Configuration): Observable<GameCenterAchievementReleaseResponse> {
        return this.gameCenterAchievementReleasesGetInstanceWithHttpInfo(id, fieldsGameCenterAchievementReleases, include, _options).pipe(map((apiResponse: HttpInfo<GameCenterAchievementReleaseResponse>) => apiResponse.data));
    }

}

import { GameCenterAchievementsApiRequestFactory, GameCenterAchievementsApiResponseProcessor} from "../apis/GameCenterAchievementsApi.ts";
export class ObservableGameCenterAchievementsApi {
    private requestFactory: GameCenterAchievementsApiRequestFactory;
    private responseProcessor: GameCenterAchievementsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: GameCenterAchievementsApiRequestFactory,
        responseProcessor?: GameCenterAchievementsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new GameCenterAchievementsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new GameCenterAchievementsApiResponseProcessor();
    }

    /**
     * @param gameCenterAchievementCreateRequest GameCenterAchievement representation
     */
    public gameCenterAchievementsCreateInstanceWithHttpInfo(gameCenterAchievementCreateRequest: GameCenterAchievementCreateRequest, _options?: Configuration): Observable<HttpInfo<GameCenterAchievementResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterAchievementsCreateInstance(gameCenterAchievementCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterAchievementsCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param gameCenterAchievementCreateRequest GameCenterAchievement representation
     */
    public gameCenterAchievementsCreateInstance(gameCenterAchievementCreateRequest: GameCenterAchievementCreateRequest, _options?: Configuration): Observable<GameCenterAchievementResponse> {
        return this.gameCenterAchievementsCreateInstanceWithHttpInfo(gameCenterAchievementCreateRequest, _options).pipe(map((apiResponse: HttpInfo<GameCenterAchievementResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterAchievementsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.gameCenterAchievementsDeleteInstance(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterAchievementsDeleteInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterAchievementsDeleteInstance(id: string, _options?: Configuration): Observable<void> {
        return this.gameCenterAchievementsDeleteInstanceWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterAchievements the fields to include for returned resources of type gameCenterAchievements
     * @param include comma-separated list of relationships to include
     * @param fieldsGameCenterAchievementReleases the fields to include for returned resources of type gameCenterAchievementReleases
     * @param fieldsGameCenterAchievementLocalizations the fields to include for returned resources of type gameCenterAchievementLocalizations
     * @param limitLocalizations maximum number of related localizations returned (when they are included)
     * @param limitReleases maximum number of related releases returned (when they are included)
     */
    public gameCenterAchievementsGetInstanceWithHttpInfo(id: string, fieldsGameCenterAchievements?: Array<'archived' | 'gameCenterDetail' | 'gameCenterGroup' | 'groupAchievement' | 'localizations' | 'points' | 'referenceName' | 'releases' | 'repeatable' | 'showBeforeEarned' | 'vendorIdentifier'>, include?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'groupAchievement' | 'localizations' | 'releases'>, fieldsGameCenterAchievementReleases?: Array<'gameCenterAchievement' | 'gameCenterDetail' | 'live'>, fieldsGameCenterAchievementLocalizations?: Array<'afterEarnedDescription' | 'beforeEarnedDescription' | 'gameCenterAchievement' | 'gameCenterAchievementImage' | 'locale' | 'name'>, limitLocalizations?: number, limitReleases?: number, _options?: Configuration): Observable<HttpInfo<GameCenterAchievementResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterAchievementsGetInstance(id, fieldsGameCenterAchievements, include, fieldsGameCenterAchievementReleases, fieldsGameCenterAchievementLocalizations, limitLocalizations, limitReleases, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterAchievementsGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterAchievements the fields to include for returned resources of type gameCenterAchievements
     * @param include comma-separated list of relationships to include
     * @param fieldsGameCenterAchievementReleases the fields to include for returned resources of type gameCenterAchievementReleases
     * @param fieldsGameCenterAchievementLocalizations the fields to include for returned resources of type gameCenterAchievementLocalizations
     * @param limitLocalizations maximum number of related localizations returned (when they are included)
     * @param limitReleases maximum number of related releases returned (when they are included)
     */
    public gameCenterAchievementsGetInstance(id: string, fieldsGameCenterAchievements?: Array<'archived' | 'gameCenterDetail' | 'gameCenterGroup' | 'groupAchievement' | 'localizations' | 'points' | 'referenceName' | 'releases' | 'repeatable' | 'showBeforeEarned' | 'vendorIdentifier'>, include?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'groupAchievement' | 'localizations' | 'releases'>, fieldsGameCenterAchievementReleases?: Array<'gameCenterAchievement' | 'gameCenterDetail' | 'live'>, fieldsGameCenterAchievementLocalizations?: Array<'afterEarnedDescription' | 'beforeEarnedDescription' | 'gameCenterAchievement' | 'gameCenterAchievementImage' | 'locale' | 'name'>, limitLocalizations?: number, limitReleases?: number, _options?: Configuration): Observable<GameCenterAchievementResponse> {
        return this.gameCenterAchievementsGetInstanceWithHttpInfo(id, fieldsGameCenterAchievements, include, fieldsGameCenterAchievementReleases, fieldsGameCenterAchievementLocalizations, limitLocalizations, limitReleases, _options).pipe(map((apiResponse: HttpInfo<GameCenterAchievementResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterAchievementReleases the fields to include for returned resources of type gameCenterAchievementReleases
     * @param fieldsGameCenterGroups the fields to include for returned resources of type gameCenterGroups
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterAchievementLocalizations the fields to include for returned resources of type gameCenterAchievementLocalizations
     * @param fieldsGameCenterAchievements the fields to include for returned resources of type gameCenterAchievements
     * @param limitLocalizations maximum number of related localizations returned (when they are included)
     * @param limitReleases maximum number of related releases returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public gameCenterAchievementsGroupAchievementGetToOneRelatedWithHttpInfo(id: string, fieldsGameCenterAchievementReleases?: Array<'gameCenterAchievement' | 'gameCenterDetail' | 'live'>, fieldsGameCenterGroups?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'referenceName'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterAchievementLocalizations?: Array<'afterEarnedDescription' | 'beforeEarnedDescription' | 'gameCenterAchievement' | 'gameCenterAchievementImage' | 'locale' | 'name'>, fieldsGameCenterAchievements?: Array<'archived' | 'gameCenterDetail' | 'gameCenterGroup' | 'groupAchievement' | 'localizations' | 'points' | 'referenceName' | 'releases' | 'repeatable' | 'showBeforeEarned' | 'vendorIdentifier'>, limitLocalizations?: number, limitReleases?: number, include?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'groupAchievement' | 'localizations' | 'releases'>, _options?: Configuration): Observable<HttpInfo<GameCenterAchievementResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterAchievementsGroupAchievementGetToOneRelated(id, fieldsGameCenterAchievementReleases, fieldsGameCenterGroups, fieldsGameCenterDetails, fieldsGameCenterAchievementLocalizations, fieldsGameCenterAchievements, limitLocalizations, limitReleases, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterAchievementsGroupAchievementGetToOneRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterAchievementReleases the fields to include for returned resources of type gameCenterAchievementReleases
     * @param fieldsGameCenterGroups the fields to include for returned resources of type gameCenterGroups
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterAchievementLocalizations the fields to include for returned resources of type gameCenterAchievementLocalizations
     * @param fieldsGameCenterAchievements the fields to include for returned resources of type gameCenterAchievements
     * @param limitLocalizations maximum number of related localizations returned (when they are included)
     * @param limitReleases maximum number of related releases returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public gameCenterAchievementsGroupAchievementGetToOneRelated(id: string, fieldsGameCenterAchievementReleases?: Array<'gameCenterAchievement' | 'gameCenterDetail' | 'live'>, fieldsGameCenterGroups?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'referenceName'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterAchievementLocalizations?: Array<'afterEarnedDescription' | 'beforeEarnedDescription' | 'gameCenterAchievement' | 'gameCenterAchievementImage' | 'locale' | 'name'>, fieldsGameCenterAchievements?: Array<'archived' | 'gameCenterDetail' | 'gameCenterGroup' | 'groupAchievement' | 'localizations' | 'points' | 'referenceName' | 'releases' | 'repeatable' | 'showBeforeEarned' | 'vendorIdentifier'>, limitLocalizations?: number, limitReleases?: number, include?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'groupAchievement' | 'localizations' | 'releases'>, _options?: Configuration): Observable<GameCenterAchievementResponse> {
        return this.gameCenterAchievementsGroupAchievementGetToOneRelatedWithHttpInfo(id, fieldsGameCenterAchievementReleases, fieldsGameCenterGroups, fieldsGameCenterDetails, fieldsGameCenterAchievementLocalizations, fieldsGameCenterAchievements, limitLocalizations, limitReleases, include, _options).pipe(map((apiResponse: HttpInfo<GameCenterAchievementResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterAchievementsGroupAchievementGetToOneRelationshipWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<GameCenterAchievementGroupAchievementLinkageResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterAchievementsGroupAchievementGetToOneRelationship(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterAchievementsGroupAchievementGetToOneRelationshipWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterAchievementsGroupAchievementGetToOneRelationship(id: string, _options?: Configuration): Observable<GameCenterAchievementGroupAchievementLinkageResponse> {
        return this.gameCenterAchievementsGroupAchievementGetToOneRelationshipWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<GameCenterAchievementGroupAchievementLinkageResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterAchievementGroupAchievementLinkageRequest Related linkage
     */
    public gameCenterAchievementsGroupAchievementUpdateToOneRelationshipWithHttpInfo(id: string, gameCenterAchievementGroupAchievementLinkageRequest: GameCenterAchievementGroupAchievementLinkageRequest, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.gameCenterAchievementsGroupAchievementUpdateToOneRelationship(id, gameCenterAchievementGroupAchievementLinkageRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterAchievementsGroupAchievementUpdateToOneRelationshipWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterAchievementGroupAchievementLinkageRequest Related linkage
     */
    public gameCenterAchievementsGroupAchievementUpdateToOneRelationship(id: string, gameCenterAchievementGroupAchievementLinkageRequest: GameCenterAchievementGroupAchievementLinkageRequest, _options?: Configuration): Observable<void> {
        return this.gameCenterAchievementsGroupAchievementUpdateToOneRelationshipWithHttpInfo(id, gameCenterAchievementGroupAchievementLinkageRequest, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterAchievementImages the fields to include for returned resources of type gameCenterAchievementImages
     * @param fieldsGameCenterAchievementLocalizations the fields to include for returned resources of type gameCenterAchievementLocalizations
     * @param fieldsGameCenterAchievements the fields to include for returned resources of type gameCenterAchievements
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public gameCenterAchievementsLocalizationsGetToManyRelatedWithHttpInfo(id: string, fieldsGameCenterAchievementImages?: Array<'assetDeliveryState' | 'fileName' | 'fileSize' | 'gameCenterAchievementLocalization' | 'imageAsset' | 'uploadOperations' | 'uploaded'>, fieldsGameCenterAchievementLocalizations?: Array<'afterEarnedDescription' | 'beforeEarnedDescription' | 'gameCenterAchievement' | 'gameCenterAchievementImage' | 'locale' | 'name'>, fieldsGameCenterAchievements?: Array<'archived' | 'gameCenterDetail' | 'gameCenterGroup' | 'groupAchievement' | 'localizations' | 'points' | 'referenceName' | 'releases' | 'repeatable' | 'showBeforeEarned' | 'vendorIdentifier'>, limit?: number, include?: Array<'gameCenterAchievement' | 'gameCenterAchievementImage'>, _options?: Configuration): Observable<HttpInfo<GameCenterAchievementLocalizationsResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterAchievementsLocalizationsGetToManyRelated(id, fieldsGameCenterAchievementImages, fieldsGameCenterAchievementLocalizations, fieldsGameCenterAchievements, limit, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterAchievementsLocalizationsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterAchievementImages the fields to include for returned resources of type gameCenterAchievementImages
     * @param fieldsGameCenterAchievementLocalizations the fields to include for returned resources of type gameCenterAchievementLocalizations
     * @param fieldsGameCenterAchievements the fields to include for returned resources of type gameCenterAchievements
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public gameCenterAchievementsLocalizationsGetToManyRelated(id: string, fieldsGameCenterAchievementImages?: Array<'assetDeliveryState' | 'fileName' | 'fileSize' | 'gameCenterAchievementLocalization' | 'imageAsset' | 'uploadOperations' | 'uploaded'>, fieldsGameCenterAchievementLocalizations?: Array<'afterEarnedDescription' | 'beforeEarnedDescription' | 'gameCenterAchievement' | 'gameCenterAchievementImage' | 'locale' | 'name'>, fieldsGameCenterAchievements?: Array<'archived' | 'gameCenterDetail' | 'gameCenterGroup' | 'groupAchievement' | 'localizations' | 'points' | 'referenceName' | 'releases' | 'repeatable' | 'showBeforeEarned' | 'vendorIdentifier'>, limit?: number, include?: Array<'gameCenterAchievement' | 'gameCenterAchievementImage'>, _options?: Configuration): Observable<GameCenterAchievementLocalizationsResponse> {
        return this.gameCenterAchievementsLocalizationsGetToManyRelatedWithHttpInfo(id, fieldsGameCenterAchievementImages, fieldsGameCenterAchievementLocalizations, fieldsGameCenterAchievements, limit, include, _options).pipe(map((apiResponse: HttpInfo<GameCenterAchievementLocalizationsResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param filterLive filter by attribute \&#39;live\&#39;
     * @param filterGameCenterDetail filter by id(s) of related \&#39;gameCenterDetail\&#39;
     * @param fieldsGameCenterAchievementReleases the fields to include for returned resources of type gameCenterAchievementReleases
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterAchievements the fields to include for returned resources of type gameCenterAchievements
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public gameCenterAchievementsReleasesGetToManyRelatedWithHttpInfo(id: string, filterLive?: Array<string>, filterGameCenterDetail?: Array<string>, fieldsGameCenterAchievementReleases?: Array<'gameCenterAchievement' | 'gameCenterDetail' | 'live'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterAchievements?: Array<'archived' | 'gameCenterDetail' | 'gameCenterGroup' | 'groupAchievement' | 'localizations' | 'points' | 'referenceName' | 'releases' | 'repeatable' | 'showBeforeEarned' | 'vendorIdentifier'>, limit?: number, include?: Array<'gameCenterAchievement' | 'gameCenterDetail'>, _options?: Configuration): Observable<HttpInfo<GameCenterAchievementReleasesResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterAchievementsReleasesGetToManyRelated(id, filterLive, filterGameCenterDetail, fieldsGameCenterAchievementReleases, fieldsGameCenterDetails, fieldsGameCenterAchievements, limit, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterAchievementsReleasesGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param filterLive filter by attribute \&#39;live\&#39;
     * @param filterGameCenterDetail filter by id(s) of related \&#39;gameCenterDetail\&#39;
     * @param fieldsGameCenterAchievementReleases the fields to include for returned resources of type gameCenterAchievementReleases
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterAchievements the fields to include for returned resources of type gameCenterAchievements
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public gameCenterAchievementsReleasesGetToManyRelated(id: string, filterLive?: Array<string>, filterGameCenterDetail?: Array<string>, fieldsGameCenterAchievementReleases?: Array<'gameCenterAchievement' | 'gameCenterDetail' | 'live'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterAchievements?: Array<'archived' | 'gameCenterDetail' | 'gameCenterGroup' | 'groupAchievement' | 'localizations' | 'points' | 'referenceName' | 'releases' | 'repeatable' | 'showBeforeEarned' | 'vendorIdentifier'>, limit?: number, include?: Array<'gameCenterAchievement' | 'gameCenterDetail'>, _options?: Configuration): Observable<GameCenterAchievementReleasesResponse> {
        return this.gameCenterAchievementsReleasesGetToManyRelatedWithHttpInfo(id, filterLive, filterGameCenterDetail, fieldsGameCenterAchievementReleases, fieldsGameCenterDetails, fieldsGameCenterAchievements, limit, include, _options).pipe(map((apiResponse: HttpInfo<GameCenterAchievementReleasesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterAchievementUpdateRequest GameCenterAchievement representation
     */
    public gameCenterAchievementsUpdateInstanceWithHttpInfo(id: string, gameCenterAchievementUpdateRequest: GameCenterAchievementUpdateRequest, _options?: Configuration): Observable<HttpInfo<GameCenterAchievementResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterAchievementsUpdateInstance(id, gameCenterAchievementUpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterAchievementsUpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterAchievementUpdateRequest GameCenterAchievement representation
     */
    public gameCenterAchievementsUpdateInstance(id: string, gameCenterAchievementUpdateRequest: GameCenterAchievementUpdateRequest, _options?: Configuration): Observable<GameCenterAchievementResponse> {
        return this.gameCenterAchievementsUpdateInstanceWithHttpInfo(id, gameCenterAchievementUpdateRequest, _options).pipe(map((apiResponse: HttpInfo<GameCenterAchievementResponse>) => apiResponse.data));
    }

}

import { GameCenterAppVersionsApiRequestFactory, GameCenterAppVersionsApiResponseProcessor} from "../apis/GameCenterAppVersionsApi.ts";
export class ObservableGameCenterAppVersionsApi {
    private requestFactory: GameCenterAppVersionsApiRequestFactory;
    private responseProcessor: GameCenterAppVersionsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: GameCenterAppVersionsApiRequestFactory,
        responseProcessor?: GameCenterAppVersionsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new GameCenterAppVersionsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new GameCenterAppVersionsApiResponseProcessor();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAgeRatingDeclarations the fields to include for returned resources of type ageRatingDeclarations
     * @param fieldsAppStoreReviewDetails the fields to include for returned resources of type appStoreReviewDetails
     * @param fieldsAppStoreVersionLocalizations the fields to include for returned resources of type appStoreVersionLocalizations
     * @param fieldsAppStoreVersionExperiments the fields to include for returned resources of type appStoreVersionExperiments
     * @param fieldsAppStoreVersionSubmissions the fields to include for returned resources of type appStoreVersionSubmissions
     * @param fieldsAlternativeDistributionPackages the fields to include for returned resources of type alternativeDistributionPackages
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsRoutingAppCoverages the fields to include for returned resources of type routingAppCoverages
     * @param fieldsAppClipDefaultExperiences the fields to include for returned resources of type appClipDefaultExperiences
     * @param fieldsAppStoreVersionPhasedReleases the fields to include for returned resources of type appStoreVersionPhasedReleases
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param limitAppStoreVersionLocalizations maximum number of related appStoreVersionLocalizations returned (when they are included)
     * @param limitAppStoreVersionExperiments maximum number of related appStoreVersionExperiments returned (when they are included)
     * @param limitAppStoreVersionExperimentsV2 maximum number of related appStoreVersionExperimentsV2 returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public gameCenterAppVersionsAppStoreVersionGetToOneRelatedWithHttpInfo(id: string, fieldsAgeRatingDeclarations?: Array<'ageRatingOverride' | 'alcoholTobaccoOrDrugUseOrReferences' | 'contests' | 'gambling' | 'gamblingAndContests' | 'gamblingSimulated' | 'horrorOrFearThemes' | 'kidsAgeBand' | 'matureOrSuggestiveThemes' | 'medicalOrTreatmentInformation' | 'profanityOrCrudeHumor' | 'seventeenPlus' | 'sexualContentGraphicAndNudity' | 'sexualContentOrNudity' | 'unrestrictedWebAccess' | 'violenceCartoonOrFantasy' | 'violenceRealistic' | 'violenceRealisticProlongedGraphicOrSadistic'>, fieldsAppStoreReviewDetails?: Array<'appStoreReviewAttachments' | 'appStoreVersion' | 'contactEmail' | 'contactFirstName' | 'contactLastName' | 'contactPhone' | 'demoAccountName' | 'demoAccountPassword' | 'demoAccountRequired' | 'notes'>, fieldsAppStoreVersionLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersion' | 'description' | 'keywords' | 'locale' | 'marketingUrl' | 'promotionalText' | 'supportUrl' | 'whatsNew'>, fieldsAppStoreVersionExperiments?: Array<'app' | 'appStoreVersion' | 'appStoreVersionExperimentTreatments' | 'controlVersions' | 'endDate' | 'latestControlVersion' | 'name' | 'platform' | 'reviewRequired' | 'startDate' | 'started' | 'state' | 'trafficProportion'>, fieldsAppStoreVersionSubmissions?: Array<'appStoreVersion'>, fieldsAlternativeDistributionPackages?: Array<'appStoreVersion' | 'versions'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsRoutingAppCoverages?: Array<'appStoreVersion' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, fieldsAppClipDefaultExperiences?: Array<'action' | 'appClip' | 'appClipAppStoreReviewDetail' | 'appClipDefaultExperienceLocalizations' | 'appClipDefaultExperienceTemplate' | 'releaseWithAppStoreVersion'>, fieldsAppStoreVersionPhasedReleases?: Array<'appStoreVersion' | 'currentDayNumber' | 'phasedReleaseState' | 'startDate' | 'totalPauseDuration'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, limitAppStoreVersionLocalizations?: number, limitAppStoreVersionExperiments?: number, limitAppStoreVersionExperimentsV2?: number, include?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'build' | 'routingAppCoverage'>, _options?: Configuration): Observable<HttpInfo<AppStoreVersionResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterAppVersionsAppStoreVersionGetToOneRelated(id, fieldsAgeRatingDeclarations, fieldsAppStoreReviewDetails, fieldsAppStoreVersionLocalizations, fieldsAppStoreVersionExperiments, fieldsAppStoreVersionSubmissions, fieldsAlternativeDistributionPackages, fieldsAppStoreVersions, fieldsApps, fieldsRoutingAppCoverages, fieldsAppClipDefaultExperiences, fieldsAppStoreVersionPhasedReleases, fieldsBuilds, limitAppStoreVersionLocalizations, limitAppStoreVersionExperiments, limitAppStoreVersionExperimentsV2, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterAppVersionsAppStoreVersionGetToOneRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAgeRatingDeclarations the fields to include for returned resources of type ageRatingDeclarations
     * @param fieldsAppStoreReviewDetails the fields to include for returned resources of type appStoreReviewDetails
     * @param fieldsAppStoreVersionLocalizations the fields to include for returned resources of type appStoreVersionLocalizations
     * @param fieldsAppStoreVersionExperiments the fields to include for returned resources of type appStoreVersionExperiments
     * @param fieldsAppStoreVersionSubmissions the fields to include for returned resources of type appStoreVersionSubmissions
     * @param fieldsAlternativeDistributionPackages the fields to include for returned resources of type alternativeDistributionPackages
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsRoutingAppCoverages the fields to include for returned resources of type routingAppCoverages
     * @param fieldsAppClipDefaultExperiences the fields to include for returned resources of type appClipDefaultExperiences
     * @param fieldsAppStoreVersionPhasedReleases the fields to include for returned resources of type appStoreVersionPhasedReleases
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param limitAppStoreVersionLocalizations maximum number of related appStoreVersionLocalizations returned (when they are included)
     * @param limitAppStoreVersionExperiments maximum number of related appStoreVersionExperiments returned (when they are included)
     * @param limitAppStoreVersionExperimentsV2 maximum number of related appStoreVersionExperimentsV2 returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public gameCenterAppVersionsAppStoreVersionGetToOneRelated(id: string, fieldsAgeRatingDeclarations?: Array<'ageRatingOverride' | 'alcoholTobaccoOrDrugUseOrReferences' | 'contests' | 'gambling' | 'gamblingAndContests' | 'gamblingSimulated' | 'horrorOrFearThemes' | 'kidsAgeBand' | 'matureOrSuggestiveThemes' | 'medicalOrTreatmentInformation' | 'profanityOrCrudeHumor' | 'seventeenPlus' | 'sexualContentGraphicAndNudity' | 'sexualContentOrNudity' | 'unrestrictedWebAccess' | 'violenceCartoonOrFantasy' | 'violenceRealistic' | 'violenceRealisticProlongedGraphicOrSadistic'>, fieldsAppStoreReviewDetails?: Array<'appStoreReviewAttachments' | 'appStoreVersion' | 'contactEmail' | 'contactFirstName' | 'contactLastName' | 'contactPhone' | 'demoAccountName' | 'demoAccountPassword' | 'demoAccountRequired' | 'notes'>, fieldsAppStoreVersionLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersion' | 'description' | 'keywords' | 'locale' | 'marketingUrl' | 'promotionalText' | 'supportUrl' | 'whatsNew'>, fieldsAppStoreVersionExperiments?: Array<'app' | 'appStoreVersion' | 'appStoreVersionExperimentTreatments' | 'controlVersions' | 'endDate' | 'latestControlVersion' | 'name' | 'platform' | 'reviewRequired' | 'startDate' | 'started' | 'state' | 'trafficProportion'>, fieldsAppStoreVersionSubmissions?: Array<'appStoreVersion'>, fieldsAlternativeDistributionPackages?: Array<'appStoreVersion' | 'versions'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsRoutingAppCoverages?: Array<'appStoreVersion' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, fieldsAppClipDefaultExperiences?: Array<'action' | 'appClip' | 'appClipAppStoreReviewDetail' | 'appClipDefaultExperienceLocalizations' | 'appClipDefaultExperienceTemplate' | 'releaseWithAppStoreVersion'>, fieldsAppStoreVersionPhasedReleases?: Array<'appStoreVersion' | 'currentDayNumber' | 'phasedReleaseState' | 'startDate' | 'totalPauseDuration'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, limitAppStoreVersionLocalizations?: number, limitAppStoreVersionExperiments?: number, limitAppStoreVersionExperimentsV2?: number, include?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'build' | 'routingAppCoverage'>, _options?: Configuration): Observable<AppStoreVersionResponse> {
        return this.gameCenterAppVersionsAppStoreVersionGetToOneRelatedWithHttpInfo(id, fieldsAgeRatingDeclarations, fieldsAppStoreReviewDetails, fieldsAppStoreVersionLocalizations, fieldsAppStoreVersionExperiments, fieldsAppStoreVersionSubmissions, fieldsAlternativeDistributionPackages, fieldsAppStoreVersions, fieldsApps, fieldsRoutingAppCoverages, fieldsAppClipDefaultExperiences, fieldsAppStoreVersionPhasedReleases, fieldsBuilds, limitAppStoreVersionLocalizations, limitAppStoreVersionExperiments, limitAppStoreVersionExperimentsV2, include, _options).pipe(map((apiResponse: HttpInfo<AppStoreVersionResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterAppVersionCompatibilityVersionsLinkagesRequest List of related linkages
     */
    public gameCenterAppVersionsCompatibilityVersionsCreateToManyRelationshipWithHttpInfo(id: string, gameCenterAppVersionCompatibilityVersionsLinkagesRequest: GameCenterAppVersionCompatibilityVersionsLinkagesRequest, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.gameCenterAppVersionsCompatibilityVersionsCreateToManyRelationship(id, gameCenterAppVersionCompatibilityVersionsLinkagesRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterAppVersionsCompatibilityVersionsCreateToManyRelationshipWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterAppVersionCompatibilityVersionsLinkagesRequest List of related linkages
     */
    public gameCenterAppVersionsCompatibilityVersionsCreateToManyRelationship(id: string, gameCenterAppVersionCompatibilityVersionsLinkagesRequest: GameCenterAppVersionCompatibilityVersionsLinkagesRequest, _options?: Configuration): Observable<void> {
        return this.gameCenterAppVersionsCompatibilityVersionsCreateToManyRelationshipWithHttpInfo(id, gameCenterAppVersionCompatibilityVersionsLinkagesRequest, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterAppVersionCompatibilityVersionsLinkagesRequest List of related linkages
     */
    public gameCenterAppVersionsCompatibilityVersionsDeleteToManyRelationshipWithHttpInfo(id: string, gameCenterAppVersionCompatibilityVersionsLinkagesRequest: GameCenterAppVersionCompatibilityVersionsLinkagesRequest, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.gameCenterAppVersionsCompatibilityVersionsDeleteToManyRelationship(id, gameCenterAppVersionCompatibilityVersionsLinkagesRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterAppVersionsCompatibilityVersionsDeleteToManyRelationshipWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterAppVersionCompatibilityVersionsLinkagesRequest List of related linkages
     */
    public gameCenterAppVersionsCompatibilityVersionsDeleteToManyRelationship(id: string, gameCenterAppVersionCompatibilityVersionsLinkagesRequest: GameCenterAppVersionCompatibilityVersionsLinkagesRequest, _options?: Configuration): Observable<void> {
        return this.gameCenterAppVersionsCompatibilityVersionsDeleteToManyRelationshipWithHttpInfo(id, gameCenterAppVersionCompatibilityVersionsLinkagesRequest, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param filterEnabled filter by attribute \&#39;enabled\&#39;
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsGameCenterAppVersions the fields to include for returned resources of type gameCenterAppVersions
     * @param limit maximum resources per page
     * @param limitCompatibilityVersions maximum number of related compatibilityVersions returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public gameCenterAppVersionsCompatibilityVersionsGetToManyRelatedWithHttpInfo(id: string, filterEnabled?: Array<string>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsGameCenterAppVersions?: Array<'appStoreVersion' | 'compatibilityVersions' | 'enabled'>, limit?: number, limitCompatibilityVersions?: number, include?: Array<'appStoreVersion' | 'compatibilityVersions'>, _options?: Configuration): Observable<HttpInfo<GameCenterAppVersionsResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterAppVersionsCompatibilityVersionsGetToManyRelated(id, filterEnabled, fieldsAppStoreVersions, fieldsGameCenterAppVersions, limit, limitCompatibilityVersions, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterAppVersionsCompatibilityVersionsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param filterEnabled filter by attribute \&#39;enabled\&#39;
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsGameCenterAppVersions the fields to include for returned resources of type gameCenterAppVersions
     * @param limit maximum resources per page
     * @param limitCompatibilityVersions maximum number of related compatibilityVersions returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public gameCenterAppVersionsCompatibilityVersionsGetToManyRelated(id: string, filterEnabled?: Array<string>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsGameCenterAppVersions?: Array<'appStoreVersion' | 'compatibilityVersions' | 'enabled'>, limit?: number, limitCompatibilityVersions?: number, include?: Array<'appStoreVersion' | 'compatibilityVersions'>, _options?: Configuration): Observable<GameCenterAppVersionsResponse> {
        return this.gameCenterAppVersionsCompatibilityVersionsGetToManyRelatedWithHttpInfo(id, filterEnabled, fieldsAppStoreVersions, fieldsGameCenterAppVersions, limit, limitCompatibilityVersions, include, _options).pipe(map((apiResponse: HttpInfo<GameCenterAppVersionsResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public gameCenterAppVersionsCompatibilityVersionsGetToManyRelationshipWithHttpInfo(id: string, limit?: number, _options?: Configuration): Observable<HttpInfo<GameCenterAppVersionCompatibilityVersionsLinkagesResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterAppVersionsCompatibilityVersionsGetToManyRelationship(id, limit, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterAppVersionsCompatibilityVersionsGetToManyRelationshipWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public gameCenterAppVersionsCompatibilityVersionsGetToManyRelationship(id: string, limit?: number, _options?: Configuration): Observable<GameCenterAppVersionCompatibilityVersionsLinkagesResponse> {
        return this.gameCenterAppVersionsCompatibilityVersionsGetToManyRelationshipWithHttpInfo(id, limit, _options).pipe(map((apiResponse: HttpInfo<GameCenterAppVersionCompatibilityVersionsLinkagesResponse>) => apiResponse.data));
    }

    /**
     * @param gameCenterAppVersionCreateRequest GameCenterAppVersion representation
     */
    public gameCenterAppVersionsCreateInstanceWithHttpInfo(gameCenterAppVersionCreateRequest: GameCenterAppVersionCreateRequest, _options?: Configuration): Observable<HttpInfo<GameCenterAppVersionResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterAppVersionsCreateInstance(gameCenterAppVersionCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterAppVersionsCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param gameCenterAppVersionCreateRequest GameCenterAppVersion representation
     */
    public gameCenterAppVersionsCreateInstance(gameCenterAppVersionCreateRequest: GameCenterAppVersionCreateRequest, _options?: Configuration): Observable<GameCenterAppVersionResponse> {
        return this.gameCenterAppVersionsCreateInstanceWithHttpInfo(gameCenterAppVersionCreateRequest, _options).pipe(map((apiResponse: HttpInfo<GameCenterAppVersionResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterAppVersions the fields to include for returned resources of type gameCenterAppVersions
     * @param include comma-separated list of relationships to include
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param limitCompatibilityVersions maximum number of related compatibilityVersions returned (when they are included)
     */
    public gameCenterAppVersionsGetInstanceWithHttpInfo(id: string, fieldsGameCenterAppVersions?: Array<'appStoreVersion' | 'compatibilityVersions' | 'enabled'>, include?: Array<'appStoreVersion' | 'compatibilityVersions'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, limitCompatibilityVersions?: number, _options?: Configuration): Observable<HttpInfo<GameCenterAppVersionResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterAppVersionsGetInstance(id, fieldsGameCenterAppVersions, include, fieldsAppStoreVersions, limitCompatibilityVersions, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterAppVersionsGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterAppVersions the fields to include for returned resources of type gameCenterAppVersions
     * @param include comma-separated list of relationships to include
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param limitCompatibilityVersions maximum number of related compatibilityVersions returned (when they are included)
     */
    public gameCenterAppVersionsGetInstance(id: string, fieldsGameCenterAppVersions?: Array<'appStoreVersion' | 'compatibilityVersions' | 'enabled'>, include?: Array<'appStoreVersion' | 'compatibilityVersions'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, limitCompatibilityVersions?: number, _options?: Configuration): Observable<GameCenterAppVersionResponse> {
        return this.gameCenterAppVersionsGetInstanceWithHttpInfo(id, fieldsGameCenterAppVersions, include, fieldsAppStoreVersions, limitCompatibilityVersions, _options).pipe(map((apiResponse: HttpInfo<GameCenterAppVersionResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterAppVersionUpdateRequest GameCenterAppVersion representation
     */
    public gameCenterAppVersionsUpdateInstanceWithHttpInfo(id: string, gameCenterAppVersionUpdateRequest: GameCenterAppVersionUpdateRequest, _options?: Configuration): Observable<HttpInfo<GameCenterAppVersionResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterAppVersionsUpdateInstance(id, gameCenterAppVersionUpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterAppVersionsUpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterAppVersionUpdateRequest GameCenterAppVersion representation
     */
    public gameCenterAppVersionsUpdateInstance(id: string, gameCenterAppVersionUpdateRequest: GameCenterAppVersionUpdateRequest, _options?: Configuration): Observable<GameCenterAppVersionResponse> {
        return this.gameCenterAppVersionsUpdateInstanceWithHttpInfo(id, gameCenterAppVersionUpdateRequest, _options).pipe(map((apiResponse: HttpInfo<GameCenterAppVersionResponse>) => apiResponse.data));
    }

}

import { GameCenterDetailsApiRequestFactory, GameCenterDetailsApiResponseProcessor} from "../apis/GameCenterDetailsApi.ts";
export class ObservableGameCenterDetailsApi {
    private requestFactory: GameCenterDetailsApiRequestFactory;
    private responseProcessor: GameCenterDetailsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: GameCenterDetailsApiRequestFactory,
        responseProcessor?: GameCenterDetailsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new GameCenterDetailsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new GameCenterDetailsApiResponseProcessor();
    }

    /**
     * @param id the id of the requested resource
     * @param filterLive filter by attribute \&#39;live\&#39;
     * @param filterGameCenterAchievement filter by id(s) of related \&#39;gameCenterAchievement\&#39;
     * @param fieldsGameCenterAchievementReleases the fields to include for returned resources of type gameCenterAchievementReleases
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterAchievements the fields to include for returned resources of type gameCenterAchievements
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public gameCenterDetailsAchievementReleasesGetToManyRelatedWithHttpInfo(id: string, filterLive?: Array<string>, filterGameCenterAchievement?: Array<string>, fieldsGameCenterAchievementReleases?: Array<'gameCenterAchievement' | 'gameCenterDetail' | 'live'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterAchievements?: Array<'archived' | 'gameCenterDetail' | 'gameCenterGroup' | 'groupAchievement' | 'localizations' | 'points' | 'referenceName' | 'releases' | 'repeatable' | 'showBeforeEarned' | 'vendorIdentifier'>, limit?: number, include?: Array<'gameCenterAchievement' | 'gameCenterDetail'>, _options?: Configuration): Observable<HttpInfo<GameCenterAchievementReleasesResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterDetailsAchievementReleasesGetToManyRelated(id, filterLive, filterGameCenterAchievement, fieldsGameCenterAchievementReleases, fieldsGameCenterDetails, fieldsGameCenterAchievements, limit, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterDetailsAchievementReleasesGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param filterLive filter by attribute \&#39;live\&#39;
     * @param filterGameCenterAchievement filter by id(s) of related \&#39;gameCenterAchievement\&#39;
     * @param fieldsGameCenterAchievementReleases the fields to include for returned resources of type gameCenterAchievementReleases
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterAchievements the fields to include for returned resources of type gameCenterAchievements
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public gameCenterDetailsAchievementReleasesGetToManyRelated(id: string, filterLive?: Array<string>, filterGameCenterAchievement?: Array<string>, fieldsGameCenterAchievementReleases?: Array<'gameCenterAchievement' | 'gameCenterDetail' | 'live'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterAchievements?: Array<'archived' | 'gameCenterDetail' | 'gameCenterGroup' | 'groupAchievement' | 'localizations' | 'points' | 'referenceName' | 'releases' | 'repeatable' | 'showBeforeEarned' | 'vendorIdentifier'>, limit?: number, include?: Array<'gameCenterAchievement' | 'gameCenterDetail'>, _options?: Configuration): Observable<GameCenterAchievementReleasesResponse> {
        return this.gameCenterDetailsAchievementReleasesGetToManyRelatedWithHttpInfo(id, filterLive, filterGameCenterAchievement, fieldsGameCenterAchievementReleases, fieldsGameCenterDetails, fieldsGameCenterAchievements, limit, include, _options).pipe(map((apiResponse: HttpInfo<GameCenterAchievementReleasesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param granularity the granularity of the per-group dataset
     * @param limit maximum number of groups to return per page
     * @param groupBy the dimension by which to group the results
     * @param filterResult filter by \&#39;result\&#39; attribute dimension
     * @param sort comma-separated list of sort expressions; metrics will be sorted as specified
     */
    public gameCenterDetailsClassicMatchmakingRequestsGetMetricsWithHttpInfo(id: string, granularity: 'P1D' | 'PT1H' | 'PT15M', limit?: number, groupBy?: Array<'result'>, filterResult?: 'MATCHED' | 'CANCELED' | 'EXPIRED', sort?: Array<'averageSecondsInQueue' | '-averageSecondsInQueue' | 'count' | '-count' | 'p50SecondsInQueue' | '-p50SecondsInQueue' | 'p95SecondsInQueue' | '-p95SecondsInQueue'>, _options?: Configuration): Observable<HttpInfo<GameCenterMatchmakingAppRequestsV1MetricResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterDetailsClassicMatchmakingRequestsGetMetrics(id, granularity, limit, groupBy, filterResult, sort, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterDetailsClassicMatchmakingRequestsGetMetricsWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param granularity the granularity of the per-group dataset
     * @param limit maximum number of groups to return per page
     * @param groupBy the dimension by which to group the results
     * @param filterResult filter by \&#39;result\&#39; attribute dimension
     * @param sort comma-separated list of sort expressions; metrics will be sorted as specified
     */
    public gameCenterDetailsClassicMatchmakingRequestsGetMetrics(id: string, granularity: 'P1D' | 'PT1H' | 'PT15M', limit?: number, groupBy?: Array<'result'>, filterResult?: 'MATCHED' | 'CANCELED' | 'EXPIRED', sort?: Array<'averageSecondsInQueue' | '-averageSecondsInQueue' | 'count' | '-count' | 'p50SecondsInQueue' | '-p50SecondsInQueue' | 'p95SecondsInQueue' | '-p95SecondsInQueue'>, _options?: Configuration): Observable<GameCenterMatchmakingAppRequestsV1MetricResponse> {
        return this.gameCenterDetailsClassicMatchmakingRequestsGetMetricsWithHttpInfo(id, granularity, limit, groupBy, filterResult, sort, _options).pipe(map((apiResponse: HttpInfo<GameCenterMatchmakingAppRequestsV1MetricResponse>) => apiResponse.data));
    }

    /**
     * @param gameCenterDetailCreateRequest GameCenterDetail representation
     */
    public gameCenterDetailsCreateInstanceWithHttpInfo(gameCenterDetailCreateRequest: GameCenterDetailCreateRequest, _options?: Configuration): Observable<HttpInfo<GameCenterDetailResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterDetailsCreateInstance(gameCenterDetailCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterDetailsCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param gameCenterDetailCreateRequest GameCenterDetail representation
     */
    public gameCenterDetailsCreateInstance(gameCenterDetailCreateRequest: GameCenterDetailCreateRequest, _options?: Configuration): Observable<GameCenterDetailResponse> {
        return this.gameCenterDetailsCreateInstanceWithHttpInfo(gameCenterDetailCreateRequest, _options).pipe(map((apiResponse: HttpInfo<GameCenterDetailResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param filterArchived filter by attribute \&#39;archived\&#39;
     * @param filterReferenceName filter by attribute \&#39;referenceName\&#39;
     * @param filterId filter by id(s)
     * @param fieldsGameCenterAchievementReleases the fields to include for returned resources of type gameCenterAchievementReleases
     * @param fieldsGameCenterGroups the fields to include for returned resources of type gameCenterGroups
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterAchievementLocalizations the fields to include for returned resources of type gameCenterAchievementLocalizations
     * @param fieldsGameCenterAchievements the fields to include for returned resources of type gameCenterAchievements
     * @param limit maximum resources per page
     * @param limitLocalizations maximum number of related localizations returned (when they are included)
     * @param limitReleases maximum number of related releases returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public gameCenterDetailsGameCenterAchievementsGetToManyRelatedWithHttpInfo(id: string, filterArchived?: Array<string>, filterReferenceName?: Array<string>, filterId?: Array<string>, fieldsGameCenterAchievementReleases?: Array<'gameCenterAchievement' | 'gameCenterDetail' | 'live'>, fieldsGameCenterGroups?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'referenceName'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterAchievementLocalizations?: Array<'afterEarnedDescription' | 'beforeEarnedDescription' | 'gameCenterAchievement' | 'gameCenterAchievementImage' | 'locale' | 'name'>, fieldsGameCenterAchievements?: Array<'archived' | 'gameCenterDetail' | 'gameCenterGroup' | 'groupAchievement' | 'localizations' | 'points' | 'referenceName' | 'releases' | 'repeatable' | 'showBeforeEarned' | 'vendorIdentifier'>, limit?: number, limitLocalizations?: number, limitReleases?: number, include?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'groupAchievement' | 'localizations' | 'releases'>, _options?: Configuration): Observable<HttpInfo<GameCenterAchievementsResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterDetailsGameCenterAchievementsGetToManyRelated(id, filterArchived, filterReferenceName, filterId, fieldsGameCenterAchievementReleases, fieldsGameCenterGroups, fieldsGameCenterDetails, fieldsGameCenterAchievementLocalizations, fieldsGameCenterAchievements, limit, limitLocalizations, limitReleases, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterDetailsGameCenterAchievementsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param filterArchived filter by attribute \&#39;archived\&#39;
     * @param filterReferenceName filter by attribute \&#39;referenceName\&#39;
     * @param filterId filter by id(s)
     * @param fieldsGameCenterAchievementReleases the fields to include for returned resources of type gameCenterAchievementReleases
     * @param fieldsGameCenterGroups the fields to include for returned resources of type gameCenterGroups
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterAchievementLocalizations the fields to include for returned resources of type gameCenterAchievementLocalizations
     * @param fieldsGameCenterAchievements the fields to include for returned resources of type gameCenterAchievements
     * @param limit maximum resources per page
     * @param limitLocalizations maximum number of related localizations returned (when they are included)
     * @param limitReleases maximum number of related releases returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public gameCenterDetailsGameCenterAchievementsGetToManyRelated(id: string, filterArchived?: Array<string>, filterReferenceName?: Array<string>, filterId?: Array<string>, fieldsGameCenterAchievementReleases?: Array<'gameCenterAchievement' | 'gameCenterDetail' | 'live'>, fieldsGameCenterGroups?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'referenceName'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterAchievementLocalizations?: Array<'afterEarnedDescription' | 'beforeEarnedDescription' | 'gameCenterAchievement' | 'gameCenterAchievementImage' | 'locale' | 'name'>, fieldsGameCenterAchievements?: Array<'archived' | 'gameCenterDetail' | 'gameCenterGroup' | 'groupAchievement' | 'localizations' | 'points' | 'referenceName' | 'releases' | 'repeatable' | 'showBeforeEarned' | 'vendorIdentifier'>, limit?: number, limitLocalizations?: number, limitReleases?: number, include?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'groupAchievement' | 'localizations' | 'releases'>, _options?: Configuration): Observable<GameCenterAchievementsResponse> {
        return this.gameCenterDetailsGameCenterAchievementsGetToManyRelatedWithHttpInfo(id, filterArchived, filterReferenceName, filterId, fieldsGameCenterAchievementReleases, fieldsGameCenterGroups, fieldsGameCenterDetails, fieldsGameCenterAchievementLocalizations, fieldsGameCenterAchievements, limit, limitLocalizations, limitReleases, include, _options).pipe(map((apiResponse: HttpInfo<GameCenterAchievementsResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public gameCenterDetailsGameCenterAchievementsGetToManyRelationshipWithHttpInfo(id: string, limit?: number, _options?: Configuration): Observable<HttpInfo<GameCenterDetailGameCenterAchievementsLinkagesResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterDetailsGameCenterAchievementsGetToManyRelationship(id, limit, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterDetailsGameCenterAchievementsGetToManyRelationshipWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public gameCenterDetailsGameCenterAchievementsGetToManyRelationship(id: string, limit?: number, _options?: Configuration): Observable<GameCenterDetailGameCenterAchievementsLinkagesResponse> {
        return this.gameCenterDetailsGameCenterAchievementsGetToManyRelationshipWithHttpInfo(id, limit, _options).pipe(map((apiResponse: HttpInfo<GameCenterDetailGameCenterAchievementsLinkagesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterDetailGameCenterAchievementsLinkagesRequest List of related linkages
     */
    public gameCenterDetailsGameCenterAchievementsReplaceToManyRelationshipWithHttpInfo(id: string, gameCenterDetailGameCenterAchievementsLinkagesRequest: GameCenterDetailGameCenterAchievementsLinkagesRequest, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.gameCenterDetailsGameCenterAchievementsReplaceToManyRelationship(id, gameCenterDetailGameCenterAchievementsLinkagesRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterDetailsGameCenterAchievementsReplaceToManyRelationshipWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterDetailGameCenterAchievementsLinkagesRequest List of related linkages
     */
    public gameCenterDetailsGameCenterAchievementsReplaceToManyRelationship(id: string, gameCenterDetailGameCenterAchievementsLinkagesRequest: GameCenterDetailGameCenterAchievementsLinkagesRequest, _options?: Configuration): Observable<void> {
        return this.gameCenterDetailsGameCenterAchievementsReplaceToManyRelationshipWithHttpInfo(id, gameCenterDetailGameCenterAchievementsLinkagesRequest, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param filterEnabled filter by attribute \&#39;enabled\&#39;
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsGameCenterAppVersions the fields to include for returned resources of type gameCenterAppVersions
     * @param limit maximum resources per page
     * @param limitCompatibilityVersions maximum number of related compatibilityVersions returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public gameCenterDetailsGameCenterAppVersionsGetToManyRelatedWithHttpInfo(id: string, filterEnabled?: Array<string>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsGameCenterAppVersions?: Array<'appStoreVersion' | 'compatibilityVersions' | 'enabled'>, limit?: number, limitCompatibilityVersions?: number, include?: Array<'appStoreVersion' | 'compatibilityVersions'>, _options?: Configuration): Observable<HttpInfo<GameCenterAppVersionsResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterDetailsGameCenterAppVersionsGetToManyRelated(id, filterEnabled, fieldsAppStoreVersions, fieldsGameCenterAppVersions, limit, limitCompatibilityVersions, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterDetailsGameCenterAppVersionsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param filterEnabled filter by attribute \&#39;enabled\&#39;
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsGameCenterAppVersions the fields to include for returned resources of type gameCenterAppVersions
     * @param limit maximum resources per page
     * @param limitCompatibilityVersions maximum number of related compatibilityVersions returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public gameCenterDetailsGameCenterAppVersionsGetToManyRelated(id: string, filterEnabled?: Array<string>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsGameCenterAppVersions?: Array<'appStoreVersion' | 'compatibilityVersions' | 'enabled'>, limit?: number, limitCompatibilityVersions?: number, include?: Array<'appStoreVersion' | 'compatibilityVersions'>, _options?: Configuration): Observable<GameCenterAppVersionsResponse> {
        return this.gameCenterDetailsGameCenterAppVersionsGetToManyRelatedWithHttpInfo(id, filterEnabled, fieldsAppStoreVersions, fieldsGameCenterAppVersions, limit, limitCompatibilityVersions, include, _options).pipe(map((apiResponse: HttpInfo<GameCenterAppVersionsResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterLeaderboardSets the fields to include for returned resources of type gameCenterLeaderboardSets
     * @param fieldsGameCenterGroups the fields to include for returned resources of type gameCenterGroups
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     * @param fieldsGameCenterAchievements the fields to include for returned resources of type gameCenterAchievements
     * @param limitGameCenterDetails maximum number of related gameCenterDetails returned (when they are included)
     * @param limitGameCenterLeaderboards maximum number of related gameCenterLeaderboards returned (when they are included)
     * @param limitGameCenterLeaderboardSets maximum number of related gameCenterLeaderboardSets returned (when they are included)
     * @param limitGameCenterAchievements maximum number of related gameCenterAchievements returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public gameCenterDetailsGameCenterGroupGetToOneRelatedWithHttpInfo(id: string, fieldsGameCenterLeaderboardSets?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'referenceName' | 'releases' | 'vendorIdentifier'>, fieldsGameCenterGroups?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'referenceName'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, fieldsGameCenterAchievements?: Array<'archived' | 'gameCenterDetail' | 'gameCenterGroup' | 'groupAchievement' | 'localizations' | 'points' | 'referenceName' | 'releases' | 'repeatable' | 'showBeforeEarned' | 'vendorIdentifier'>, limitGameCenterDetails?: number, limitGameCenterLeaderboards?: number, limitGameCenterLeaderboardSets?: number, limitGameCenterAchievements?: number, include?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards'>, _options?: Configuration): Observable<HttpInfo<GameCenterGroupResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterDetailsGameCenterGroupGetToOneRelated(id, fieldsGameCenterLeaderboardSets, fieldsGameCenterGroups, fieldsGameCenterDetails, fieldsGameCenterLeaderboards, fieldsGameCenterAchievements, limitGameCenterDetails, limitGameCenterLeaderboards, limitGameCenterLeaderboardSets, limitGameCenterAchievements, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterDetailsGameCenterGroupGetToOneRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterLeaderboardSets the fields to include for returned resources of type gameCenterLeaderboardSets
     * @param fieldsGameCenterGroups the fields to include for returned resources of type gameCenterGroups
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     * @param fieldsGameCenterAchievements the fields to include for returned resources of type gameCenterAchievements
     * @param limitGameCenterDetails maximum number of related gameCenterDetails returned (when they are included)
     * @param limitGameCenterLeaderboards maximum number of related gameCenterLeaderboards returned (when they are included)
     * @param limitGameCenterLeaderboardSets maximum number of related gameCenterLeaderboardSets returned (when they are included)
     * @param limitGameCenterAchievements maximum number of related gameCenterAchievements returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public gameCenterDetailsGameCenterGroupGetToOneRelated(id: string, fieldsGameCenterLeaderboardSets?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'referenceName' | 'releases' | 'vendorIdentifier'>, fieldsGameCenterGroups?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'referenceName'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, fieldsGameCenterAchievements?: Array<'archived' | 'gameCenterDetail' | 'gameCenterGroup' | 'groupAchievement' | 'localizations' | 'points' | 'referenceName' | 'releases' | 'repeatable' | 'showBeforeEarned' | 'vendorIdentifier'>, limitGameCenterDetails?: number, limitGameCenterLeaderboards?: number, limitGameCenterLeaderboardSets?: number, limitGameCenterAchievements?: number, include?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards'>, _options?: Configuration): Observable<GameCenterGroupResponse> {
        return this.gameCenterDetailsGameCenterGroupGetToOneRelatedWithHttpInfo(id, fieldsGameCenterLeaderboardSets, fieldsGameCenterGroups, fieldsGameCenterDetails, fieldsGameCenterLeaderboards, fieldsGameCenterAchievements, limitGameCenterDetails, limitGameCenterLeaderboards, limitGameCenterLeaderboardSets, limitGameCenterAchievements, include, _options).pipe(map((apiResponse: HttpInfo<GameCenterGroupResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param filterReferenceName filter by attribute \&#39;referenceName\&#39;
     * @param filterId filter by id(s)
     * @param fieldsGameCenterLeaderboardSetLocalizations the fields to include for returned resources of type gameCenterLeaderboardSetLocalizations
     * @param fieldsGameCenterLeaderboardSetReleases the fields to include for returned resources of type gameCenterLeaderboardSetReleases
     * @param fieldsGameCenterLeaderboardSets the fields to include for returned resources of type gameCenterLeaderboardSets
     * @param fieldsGameCenterGroups the fields to include for returned resources of type gameCenterGroups
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     * @param limit maximum resources per page
     * @param limitLocalizations maximum number of related localizations returned (when they are included)
     * @param limitGameCenterLeaderboards maximum number of related gameCenterLeaderboards returned (when they are included)
     * @param limitReleases maximum number of related releases returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public gameCenterDetailsGameCenterLeaderboardSetsGetToManyRelatedWithHttpInfo(id: string, filterReferenceName?: Array<string>, filterId?: Array<string>, fieldsGameCenterLeaderboardSetLocalizations?: Array<'gameCenterLeaderboardSet' | 'gameCenterLeaderboardSetImage' | 'locale' | 'name'>, fieldsGameCenterLeaderboardSetReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboardSet' | 'live'>, fieldsGameCenterLeaderboardSets?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'referenceName' | 'releases' | 'vendorIdentifier'>, fieldsGameCenterGroups?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'referenceName'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, limit?: number, limitLocalizations?: number, limitGameCenterLeaderboards?: number, limitReleases?: number, include?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'releases'>, _options?: Configuration): Observable<HttpInfo<GameCenterLeaderboardSetsResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterDetailsGameCenterLeaderboardSetsGetToManyRelated(id, filterReferenceName, filterId, fieldsGameCenterLeaderboardSetLocalizations, fieldsGameCenterLeaderboardSetReleases, fieldsGameCenterLeaderboardSets, fieldsGameCenterGroups, fieldsGameCenterDetails, fieldsGameCenterLeaderboards, limit, limitLocalizations, limitGameCenterLeaderboards, limitReleases, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterDetailsGameCenterLeaderboardSetsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param filterReferenceName filter by attribute \&#39;referenceName\&#39;
     * @param filterId filter by id(s)
     * @param fieldsGameCenterLeaderboardSetLocalizations the fields to include for returned resources of type gameCenterLeaderboardSetLocalizations
     * @param fieldsGameCenterLeaderboardSetReleases the fields to include for returned resources of type gameCenterLeaderboardSetReleases
     * @param fieldsGameCenterLeaderboardSets the fields to include for returned resources of type gameCenterLeaderboardSets
     * @param fieldsGameCenterGroups the fields to include for returned resources of type gameCenterGroups
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     * @param limit maximum resources per page
     * @param limitLocalizations maximum number of related localizations returned (when they are included)
     * @param limitGameCenterLeaderboards maximum number of related gameCenterLeaderboards returned (when they are included)
     * @param limitReleases maximum number of related releases returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public gameCenterDetailsGameCenterLeaderboardSetsGetToManyRelated(id: string, filterReferenceName?: Array<string>, filterId?: Array<string>, fieldsGameCenterLeaderboardSetLocalizations?: Array<'gameCenterLeaderboardSet' | 'gameCenterLeaderboardSetImage' | 'locale' | 'name'>, fieldsGameCenterLeaderboardSetReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboardSet' | 'live'>, fieldsGameCenterLeaderboardSets?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'referenceName' | 'releases' | 'vendorIdentifier'>, fieldsGameCenterGroups?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'referenceName'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, limit?: number, limitLocalizations?: number, limitGameCenterLeaderboards?: number, limitReleases?: number, include?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'releases'>, _options?: Configuration): Observable<GameCenterLeaderboardSetsResponse> {
        return this.gameCenterDetailsGameCenterLeaderboardSetsGetToManyRelatedWithHttpInfo(id, filterReferenceName, filterId, fieldsGameCenterLeaderboardSetLocalizations, fieldsGameCenterLeaderboardSetReleases, fieldsGameCenterLeaderboardSets, fieldsGameCenterGroups, fieldsGameCenterDetails, fieldsGameCenterLeaderboards, limit, limitLocalizations, limitGameCenterLeaderboards, limitReleases, include, _options).pipe(map((apiResponse: HttpInfo<GameCenterLeaderboardSetsResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public gameCenterDetailsGameCenterLeaderboardSetsGetToManyRelationshipWithHttpInfo(id: string, limit?: number, _options?: Configuration): Observable<HttpInfo<GameCenterDetailGameCenterLeaderboardSetsLinkagesResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterDetailsGameCenterLeaderboardSetsGetToManyRelationship(id, limit, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterDetailsGameCenterLeaderboardSetsGetToManyRelationshipWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public gameCenterDetailsGameCenterLeaderboardSetsGetToManyRelationship(id: string, limit?: number, _options?: Configuration): Observable<GameCenterDetailGameCenterLeaderboardSetsLinkagesResponse> {
        return this.gameCenterDetailsGameCenterLeaderboardSetsGetToManyRelationshipWithHttpInfo(id, limit, _options).pipe(map((apiResponse: HttpInfo<GameCenterDetailGameCenterLeaderboardSetsLinkagesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterDetailGameCenterLeaderboardSetsLinkagesRequest List of related linkages
     */
    public gameCenterDetailsGameCenterLeaderboardSetsReplaceToManyRelationshipWithHttpInfo(id: string, gameCenterDetailGameCenterLeaderboardSetsLinkagesRequest: GameCenterDetailGameCenterLeaderboardSetsLinkagesRequest, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.gameCenterDetailsGameCenterLeaderboardSetsReplaceToManyRelationship(id, gameCenterDetailGameCenterLeaderboardSetsLinkagesRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterDetailsGameCenterLeaderboardSetsReplaceToManyRelationshipWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterDetailGameCenterLeaderboardSetsLinkagesRequest List of related linkages
     */
    public gameCenterDetailsGameCenterLeaderboardSetsReplaceToManyRelationship(id: string, gameCenterDetailGameCenterLeaderboardSetsLinkagesRequest: GameCenterDetailGameCenterLeaderboardSetsLinkagesRequest, _options?: Configuration): Observable<void> {
        return this.gameCenterDetailsGameCenterLeaderboardSetsReplaceToManyRelationshipWithHttpInfo(id, gameCenterDetailGameCenterLeaderboardSetsLinkagesRequest, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param filterArchived filter by attribute \&#39;archived\&#39;
     * @param filterReferenceName filter by attribute \&#39;referenceName\&#39;
     * @param filterId filter by id(s)
     * @param fieldsGameCenterLeaderboardLocalizations the fields to include for returned resources of type gameCenterLeaderboardLocalizations
     * @param fieldsGameCenterLeaderboardSets the fields to include for returned resources of type gameCenterLeaderboardSets
     * @param fieldsGameCenterGroups the fields to include for returned resources of type gameCenterGroups
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     * @param fieldsGameCenterLeaderboardReleases the fields to include for returned resources of type gameCenterLeaderboardReleases
     * @param limit maximum resources per page
     * @param limitGameCenterLeaderboardSets maximum number of related gameCenterLeaderboardSets returned (when they are included)
     * @param limitLocalizations maximum number of related localizations returned (when they are included)
     * @param limitReleases maximum number of related releases returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public gameCenterDetailsGameCenterLeaderboardsGetToManyRelatedWithHttpInfo(id: string, filterArchived?: Array<string>, filterReferenceName?: Array<string>, filterId?: Array<string>, fieldsGameCenterLeaderboardLocalizations?: Array<'formatterOverride' | 'formatterSuffix' | 'formatterSuffixSingular' | 'gameCenterLeaderboard' | 'gameCenterLeaderboardImage' | 'locale' | 'name'>, fieldsGameCenterLeaderboardSets?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'referenceName' | 'releases' | 'vendorIdentifier'>, fieldsGameCenterGroups?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'referenceName'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, fieldsGameCenterLeaderboardReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboard' | 'live'>, limit?: number, limitGameCenterLeaderboardSets?: number, limitLocalizations?: number, limitReleases?: number, include?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'releases'>, _options?: Configuration): Observable<HttpInfo<GameCenterLeaderboardsResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterDetailsGameCenterLeaderboardsGetToManyRelated(id, filterArchived, filterReferenceName, filterId, fieldsGameCenterLeaderboardLocalizations, fieldsGameCenterLeaderboardSets, fieldsGameCenterGroups, fieldsGameCenterDetails, fieldsGameCenterLeaderboards, fieldsGameCenterLeaderboardReleases, limit, limitGameCenterLeaderboardSets, limitLocalizations, limitReleases, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterDetailsGameCenterLeaderboardsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param filterArchived filter by attribute \&#39;archived\&#39;
     * @param filterReferenceName filter by attribute \&#39;referenceName\&#39;
     * @param filterId filter by id(s)
     * @param fieldsGameCenterLeaderboardLocalizations the fields to include for returned resources of type gameCenterLeaderboardLocalizations
     * @param fieldsGameCenterLeaderboardSets the fields to include for returned resources of type gameCenterLeaderboardSets
     * @param fieldsGameCenterGroups the fields to include for returned resources of type gameCenterGroups
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     * @param fieldsGameCenterLeaderboardReleases the fields to include for returned resources of type gameCenterLeaderboardReleases
     * @param limit maximum resources per page
     * @param limitGameCenterLeaderboardSets maximum number of related gameCenterLeaderboardSets returned (when they are included)
     * @param limitLocalizations maximum number of related localizations returned (when they are included)
     * @param limitReleases maximum number of related releases returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public gameCenterDetailsGameCenterLeaderboardsGetToManyRelated(id: string, filterArchived?: Array<string>, filterReferenceName?: Array<string>, filterId?: Array<string>, fieldsGameCenterLeaderboardLocalizations?: Array<'formatterOverride' | 'formatterSuffix' | 'formatterSuffixSingular' | 'gameCenterLeaderboard' | 'gameCenterLeaderboardImage' | 'locale' | 'name'>, fieldsGameCenterLeaderboardSets?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'referenceName' | 'releases' | 'vendorIdentifier'>, fieldsGameCenterGroups?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'referenceName'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, fieldsGameCenterLeaderboardReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboard' | 'live'>, limit?: number, limitGameCenterLeaderboardSets?: number, limitLocalizations?: number, limitReleases?: number, include?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'releases'>, _options?: Configuration): Observable<GameCenterLeaderboardsResponse> {
        return this.gameCenterDetailsGameCenterLeaderboardsGetToManyRelatedWithHttpInfo(id, filterArchived, filterReferenceName, filterId, fieldsGameCenterLeaderboardLocalizations, fieldsGameCenterLeaderboardSets, fieldsGameCenterGroups, fieldsGameCenterDetails, fieldsGameCenterLeaderboards, fieldsGameCenterLeaderboardReleases, limit, limitGameCenterLeaderboardSets, limitLocalizations, limitReleases, include, _options).pipe(map((apiResponse: HttpInfo<GameCenterLeaderboardsResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public gameCenterDetailsGameCenterLeaderboardsGetToManyRelationshipWithHttpInfo(id: string, limit?: number, _options?: Configuration): Observable<HttpInfo<GameCenterDetailGameCenterLeaderboardsLinkagesResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterDetailsGameCenterLeaderboardsGetToManyRelationship(id, limit, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterDetailsGameCenterLeaderboardsGetToManyRelationshipWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public gameCenterDetailsGameCenterLeaderboardsGetToManyRelationship(id: string, limit?: number, _options?: Configuration): Observable<GameCenterDetailGameCenterLeaderboardsLinkagesResponse> {
        return this.gameCenterDetailsGameCenterLeaderboardsGetToManyRelationshipWithHttpInfo(id, limit, _options).pipe(map((apiResponse: HttpInfo<GameCenterDetailGameCenterLeaderboardsLinkagesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterDetailGameCenterLeaderboardsLinkagesRequest List of related linkages
     */
    public gameCenterDetailsGameCenterLeaderboardsReplaceToManyRelationshipWithHttpInfo(id: string, gameCenterDetailGameCenterLeaderboardsLinkagesRequest: GameCenterDetailGameCenterLeaderboardsLinkagesRequest, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.gameCenterDetailsGameCenterLeaderboardsReplaceToManyRelationship(id, gameCenterDetailGameCenterLeaderboardsLinkagesRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterDetailsGameCenterLeaderboardsReplaceToManyRelationshipWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterDetailGameCenterLeaderboardsLinkagesRequest List of related linkages
     */
    public gameCenterDetailsGameCenterLeaderboardsReplaceToManyRelationship(id: string, gameCenterDetailGameCenterLeaderboardsLinkagesRequest: GameCenterDetailGameCenterLeaderboardsLinkagesRequest, _options?: Configuration): Observable<void> {
        return this.gameCenterDetailsGameCenterLeaderboardsReplaceToManyRelationshipWithHttpInfo(id, gameCenterDetailGameCenterLeaderboardsLinkagesRequest, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param include comma-separated list of relationships to include
     * @param fieldsGameCenterAchievementReleases the fields to include for returned resources of type gameCenterAchievementReleases
     * @param fieldsGameCenterLeaderboardSetReleases the fields to include for returned resources of type gameCenterLeaderboardSetReleases
     * @param fieldsGameCenterLeaderboardSets the fields to include for returned resources of type gameCenterLeaderboardSets
     * @param fieldsGameCenterGroups the fields to include for returned resources of type gameCenterGroups
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     * @param fieldsGameCenterAchievements the fields to include for returned resources of type gameCenterAchievements
     * @param fieldsGameCenterAppVersions the fields to include for returned resources of type gameCenterAppVersions
     * @param fieldsGameCenterLeaderboardReleases the fields to include for returned resources of type gameCenterLeaderboardReleases
     * @param limitAchievementReleases maximum number of related achievementReleases returned (when they are included)
     * @param limitGameCenterAchievements maximum number of related gameCenterAchievements returned (when they are included)
     * @param limitGameCenterAppVersions maximum number of related gameCenterAppVersions returned (when they are included)
     * @param limitGameCenterLeaderboardSets maximum number of related gameCenterLeaderboardSets returned (when they are included)
     * @param limitGameCenterLeaderboards maximum number of related gameCenterLeaderboards returned (when they are included)
     * @param limitLeaderboardReleases maximum number of related leaderboardReleases returned (when they are included)
     * @param limitLeaderboardSetReleases maximum number of related leaderboardSetReleases returned (when they are included)
     */
    public gameCenterDetailsGetInstanceWithHttpInfo(id: string, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, include?: Array<'achievementReleases' | 'app' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterAchievementReleases?: Array<'gameCenterAchievement' | 'gameCenterDetail' | 'live'>, fieldsGameCenterLeaderboardSetReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboardSet' | 'live'>, fieldsGameCenterLeaderboardSets?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'referenceName' | 'releases' | 'vendorIdentifier'>, fieldsGameCenterGroups?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'referenceName'>, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, fieldsGameCenterAchievements?: Array<'archived' | 'gameCenterDetail' | 'gameCenterGroup' | 'groupAchievement' | 'localizations' | 'points' | 'referenceName' | 'releases' | 'repeatable' | 'showBeforeEarned' | 'vendorIdentifier'>, fieldsGameCenterAppVersions?: Array<'appStoreVersion' | 'compatibilityVersions' | 'enabled'>, fieldsGameCenterLeaderboardReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboard' | 'live'>, limitAchievementReleases?: number, limitGameCenterAchievements?: number, limitGameCenterAppVersions?: number, limitGameCenterLeaderboardSets?: number, limitGameCenterLeaderboards?: number, limitLeaderboardReleases?: number, limitLeaderboardSetReleases?: number, _options?: Configuration): Observable<HttpInfo<GameCenterDetailResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterDetailsGetInstance(id, fieldsGameCenterDetails, include, fieldsGameCenterAchievementReleases, fieldsGameCenterLeaderboardSetReleases, fieldsGameCenterLeaderboardSets, fieldsGameCenterGroups, fieldsGameCenterLeaderboards, fieldsGameCenterAchievements, fieldsGameCenterAppVersions, fieldsGameCenterLeaderboardReleases, limitAchievementReleases, limitGameCenterAchievements, limitGameCenterAppVersions, limitGameCenterLeaderboardSets, limitGameCenterLeaderboards, limitLeaderboardReleases, limitLeaderboardSetReleases, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterDetailsGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param include comma-separated list of relationships to include
     * @param fieldsGameCenterAchievementReleases the fields to include for returned resources of type gameCenterAchievementReleases
     * @param fieldsGameCenterLeaderboardSetReleases the fields to include for returned resources of type gameCenterLeaderboardSetReleases
     * @param fieldsGameCenterLeaderboardSets the fields to include for returned resources of type gameCenterLeaderboardSets
     * @param fieldsGameCenterGroups the fields to include for returned resources of type gameCenterGroups
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     * @param fieldsGameCenterAchievements the fields to include for returned resources of type gameCenterAchievements
     * @param fieldsGameCenterAppVersions the fields to include for returned resources of type gameCenterAppVersions
     * @param fieldsGameCenterLeaderboardReleases the fields to include for returned resources of type gameCenterLeaderboardReleases
     * @param limitAchievementReleases maximum number of related achievementReleases returned (when they are included)
     * @param limitGameCenterAchievements maximum number of related gameCenterAchievements returned (when they are included)
     * @param limitGameCenterAppVersions maximum number of related gameCenterAppVersions returned (when they are included)
     * @param limitGameCenterLeaderboardSets maximum number of related gameCenterLeaderboardSets returned (when they are included)
     * @param limitGameCenterLeaderboards maximum number of related gameCenterLeaderboards returned (when they are included)
     * @param limitLeaderboardReleases maximum number of related leaderboardReleases returned (when they are included)
     * @param limitLeaderboardSetReleases maximum number of related leaderboardSetReleases returned (when they are included)
     */
    public gameCenterDetailsGetInstance(id: string, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, include?: Array<'achievementReleases' | 'app' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterAchievementReleases?: Array<'gameCenterAchievement' | 'gameCenterDetail' | 'live'>, fieldsGameCenterLeaderboardSetReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboardSet' | 'live'>, fieldsGameCenterLeaderboardSets?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'referenceName' | 'releases' | 'vendorIdentifier'>, fieldsGameCenterGroups?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'referenceName'>, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, fieldsGameCenterAchievements?: Array<'archived' | 'gameCenterDetail' | 'gameCenterGroup' | 'groupAchievement' | 'localizations' | 'points' | 'referenceName' | 'releases' | 'repeatable' | 'showBeforeEarned' | 'vendorIdentifier'>, fieldsGameCenterAppVersions?: Array<'appStoreVersion' | 'compatibilityVersions' | 'enabled'>, fieldsGameCenterLeaderboardReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboard' | 'live'>, limitAchievementReleases?: number, limitGameCenterAchievements?: number, limitGameCenterAppVersions?: number, limitGameCenterLeaderboardSets?: number, limitGameCenterLeaderboards?: number, limitLeaderboardReleases?: number, limitLeaderboardSetReleases?: number, _options?: Configuration): Observable<GameCenterDetailResponse> {
        return this.gameCenterDetailsGetInstanceWithHttpInfo(id, fieldsGameCenterDetails, include, fieldsGameCenterAchievementReleases, fieldsGameCenterLeaderboardSetReleases, fieldsGameCenterLeaderboardSets, fieldsGameCenterGroups, fieldsGameCenterLeaderboards, fieldsGameCenterAchievements, fieldsGameCenterAppVersions, fieldsGameCenterLeaderboardReleases, limitAchievementReleases, limitGameCenterAchievements, limitGameCenterAppVersions, limitGameCenterLeaderboardSets, limitGameCenterLeaderboards, limitLeaderboardReleases, limitLeaderboardSetReleases, _options).pipe(map((apiResponse: HttpInfo<GameCenterDetailResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param filterLive filter by attribute \&#39;live\&#39;
     * @param filterGameCenterLeaderboard filter by id(s) of related \&#39;gameCenterLeaderboard\&#39;
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     * @param fieldsGameCenterLeaderboardReleases the fields to include for returned resources of type gameCenterLeaderboardReleases
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public gameCenterDetailsLeaderboardReleasesGetToManyRelatedWithHttpInfo(id: string, filterLive?: Array<string>, filterGameCenterLeaderboard?: Array<string>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, fieldsGameCenterLeaderboardReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboard' | 'live'>, limit?: number, include?: Array<'gameCenterDetail' | 'gameCenterLeaderboard'>, _options?: Configuration): Observable<HttpInfo<GameCenterLeaderboardReleasesResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterDetailsLeaderboardReleasesGetToManyRelated(id, filterLive, filterGameCenterLeaderboard, fieldsGameCenterDetails, fieldsGameCenterLeaderboards, fieldsGameCenterLeaderboardReleases, limit, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterDetailsLeaderboardReleasesGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param filterLive filter by attribute \&#39;live\&#39;
     * @param filterGameCenterLeaderboard filter by id(s) of related \&#39;gameCenterLeaderboard\&#39;
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     * @param fieldsGameCenterLeaderboardReleases the fields to include for returned resources of type gameCenterLeaderboardReleases
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public gameCenterDetailsLeaderboardReleasesGetToManyRelated(id: string, filterLive?: Array<string>, filterGameCenterLeaderboard?: Array<string>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, fieldsGameCenterLeaderboardReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboard' | 'live'>, limit?: number, include?: Array<'gameCenterDetail' | 'gameCenterLeaderboard'>, _options?: Configuration): Observable<GameCenterLeaderboardReleasesResponse> {
        return this.gameCenterDetailsLeaderboardReleasesGetToManyRelatedWithHttpInfo(id, filterLive, filterGameCenterLeaderboard, fieldsGameCenterDetails, fieldsGameCenterLeaderboards, fieldsGameCenterLeaderboardReleases, limit, include, _options).pipe(map((apiResponse: HttpInfo<GameCenterLeaderboardReleasesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param filterLive filter by attribute \&#39;live\&#39;
     * @param filterGameCenterLeaderboardSet filter by id(s) of related \&#39;gameCenterLeaderboardSet\&#39;
     * @param fieldsGameCenterLeaderboardSetReleases the fields to include for returned resources of type gameCenterLeaderboardSetReleases
     * @param fieldsGameCenterLeaderboardSets the fields to include for returned resources of type gameCenterLeaderboardSets
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public gameCenterDetailsLeaderboardSetReleasesGetToManyRelatedWithHttpInfo(id: string, filterLive?: Array<string>, filterGameCenterLeaderboardSet?: Array<string>, fieldsGameCenterLeaderboardSetReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboardSet' | 'live'>, fieldsGameCenterLeaderboardSets?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'referenceName' | 'releases' | 'vendorIdentifier'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, limit?: number, include?: Array<'gameCenterDetail' | 'gameCenterLeaderboardSet'>, _options?: Configuration): Observable<HttpInfo<GameCenterLeaderboardSetReleasesResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterDetailsLeaderboardSetReleasesGetToManyRelated(id, filterLive, filterGameCenterLeaderboardSet, fieldsGameCenterLeaderboardSetReleases, fieldsGameCenterLeaderboardSets, fieldsGameCenterDetails, limit, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterDetailsLeaderboardSetReleasesGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param filterLive filter by attribute \&#39;live\&#39;
     * @param filterGameCenterLeaderboardSet filter by id(s) of related \&#39;gameCenterLeaderboardSet\&#39;
     * @param fieldsGameCenterLeaderboardSetReleases the fields to include for returned resources of type gameCenterLeaderboardSetReleases
     * @param fieldsGameCenterLeaderboardSets the fields to include for returned resources of type gameCenterLeaderboardSets
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public gameCenterDetailsLeaderboardSetReleasesGetToManyRelated(id: string, filterLive?: Array<string>, filterGameCenterLeaderboardSet?: Array<string>, fieldsGameCenterLeaderboardSetReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboardSet' | 'live'>, fieldsGameCenterLeaderboardSets?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'referenceName' | 'releases' | 'vendorIdentifier'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, limit?: number, include?: Array<'gameCenterDetail' | 'gameCenterLeaderboardSet'>, _options?: Configuration): Observable<GameCenterLeaderboardSetReleasesResponse> {
        return this.gameCenterDetailsLeaderboardSetReleasesGetToManyRelatedWithHttpInfo(id, filterLive, filterGameCenterLeaderboardSet, fieldsGameCenterLeaderboardSetReleases, fieldsGameCenterLeaderboardSets, fieldsGameCenterDetails, limit, include, _options).pipe(map((apiResponse: HttpInfo<GameCenterLeaderboardSetReleasesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param granularity the granularity of the per-group dataset
     * @param limit maximum number of groups to return per page
     * @param groupBy the dimension by which to group the results
     * @param filterResult filter by \&#39;result\&#39; attribute dimension
     * @param sort comma-separated list of sort expressions; metrics will be sorted as specified
     */
    public gameCenterDetailsRuleBasedMatchmakingRequestsGetMetricsWithHttpInfo(id: string, granularity: 'P1D' | 'PT1H' | 'PT15M', limit?: number, groupBy?: Array<'result'>, filterResult?: 'MATCHED' | 'CANCELED' | 'EXPIRED', sort?: Array<'averageSecondsInQueue' | '-averageSecondsInQueue' | 'count' | '-count' | 'p50SecondsInQueue' | '-p50SecondsInQueue' | 'p95SecondsInQueue' | '-p95SecondsInQueue'>, _options?: Configuration): Observable<HttpInfo<GameCenterMatchmakingAppRequestsV1MetricResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterDetailsRuleBasedMatchmakingRequestsGetMetrics(id, granularity, limit, groupBy, filterResult, sort, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterDetailsRuleBasedMatchmakingRequestsGetMetricsWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param granularity the granularity of the per-group dataset
     * @param limit maximum number of groups to return per page
     * @param groupBy the dimension by which to group the results
     * @param filterResult filter by \&#39;result\&#39; attribute dimension
     * @param sort comma-separated list of sort expressions; metrics will be sorted as specified
     */
    public gameCenterDetailsRuleBasedMatchmakingRequestsGetMetrics(id: string, granularity: 'P1D' | 'PT1H' | 'PT15M', limit?: number, groupBy?: Array<'result'>, filterResult?: 'MATCHED' | 'CANCELED' | 'EXPIRED', sort?: Array<'averageSecondsInQueue' | '-averageSecondsInQueue' | 'count' | '-count' | 'p50SecondsInQueue' | '-p50SecondsInQueue' | 'p95SecondsInQueue' | '-p95SecondsInQueue'>, _options?: Configuration): Observable<GameCenterMatchmakingAppRequestsV1MetricResponse> {
        return this.gameCenterDetailsRuleBasedMatchmakingRequestsGetMetricsWithHttpInfo(id, granularity, limit, groupBy, filterResult, sort, _options).pipe(map((apiResponse: HttpInfo<GameCenterMatchmakingAppRequestsV1MetricResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterDetailUpdateRequest GameCenterDetail representation
     */
    public gameCenterDetailsUpdateInstanceWithHttpInfo(id: string, gameCenterDetailUpdateRequest: GameCenterDetailUpdateRequest, _options?: Configuration): Observable<HttpInfo<GameCenterDetailResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterDetailsUpdateInstance(id, gameCenterDetailUpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterDetailsUpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterDetailUpdateRequest GameCenterDetail representation
     */
    public gameCenterDetailsUpdateInstance(id: string, gameCenterDetailUpdateRequest: GameCenterDetailUpdateRequest, _options?: Configuration): Observable<GameCenterDetailResponse> {
        return this.gameCenterDetailsUpdateInstanceWithHttpInfo(id, gameCenterDetailUpdateRequest, _options).pipe(map((apiResponse: HttpInfo<GameCenterDetailResponse>) => apiResponse.data));
    }

}

import { GameCenterEnabledVersionsApiRequestFactory, GameCenterEnabledVersionsApiResponseProcessor} from "../apis/GameCenterEnabledVersionsApi.ts";
export class ObservableGameCenterEnabledVersionsApi {
    private requestFactory: GameCenterEnabledVersionsApiRequestFactory;
    private responseProcessor: GameCenterEnabledVersionsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: GameCenterEnabledVersionsApiRequestFactory,
        responseProcessor?: GameCenterEnabledVersionsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new GameCenterEnabledVersionsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new GameCenterEnabledVersionsApiResponseProcessor();
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterEnabledVersionCompatibleVersionsLinkagesRequest List of related linkages
     */
    public gameCenterEnabledVersionsCompatibleVersionsCreateToManyRelationshipWithHttpInfo(id: string, gameCenterEnabledVersionCompatibleVersionsLinkagesRequest: GameCenterEnabledVersionCompatibleVersionsLinkagesRequest, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.gameCenterEnabledVersionsCompatibleVersionsCreateToManyRelationship(id, gameCenterEnabledVersionCompatibleVersionsLinkagesRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterEnabledVersionsCompatibleVersionsCreateToManyRelationshipWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterEnabledVersionCompatibleVersionsLinkagesRequest List of related linkages
     */
    public gameCenterEnabledVersionsCompatibleVersionsCreateToManyRelationship(id: string, gameCenterEnabledVersionCompatibleVersionsLinkagesRequest: GameCenterEnabledVersionCompatibleVersionsLinkagesRequest, _options?: Configuration): Observable<void> {
        return this.gameCenterEnabledVersionsCompatibleVersionsCreateToManyRelationshipWithHttpInfo(id, gameCenterEnabledVersionCompatibleVersionsLinkagesRequest, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterEnabledVersionCompatibleVersionsLinkagesRequest List of related linkages
     */
    public gameCenterEnabledVersionsCompatibleVersionsDeleteToManyRelationshipWithHttpInfo(id: string, gameCenterEnabledVersionCompatibleVersionsLinkagesRequest: GameCenterEnabledVersionCompatibleVersionsLinkagesRequest, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.gameCenterEnabledVersionsCompatibleVersionsDeleteToManyRelationship(id, gameCenterEnabledVersionCompatibleVersionsLinkagesRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterEnabledVersionsCompatibleVersionsDeleteToManyRelationshipWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterEnabledVersionCompatibleVersionsLinkagesRequest List of related linkages
     */
    public gameCenterEnabledVersionsCompatibleVersionsDeleteToManyRelationship(id: string, gameCenterEnabledVersionCompatibleVersionsLinkagesRequest: GameCenterEnabledVersionCompatibleVersionsLinkagesRequest, _options?: Configuration): Observable<void> {
        return this.gameCenterEnabledVersionsCompatibleVersionsDeleteToManyRelationshipWithHttpInfo(id, gameCenterEnabledVersionCompatibleVersionsLinkagesRequest, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param filterPlatform filter by attribute \&#39;platform\&#39;
     * @param filterVersionString filter by attribute \&#39;versionString\&#39;
     * @param filterApp filter by id(s) of related \&#39;app\&#39;
     * @param filterId filter by id(s)
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsGameCenterEnabledVersions the fields to include for returned resources of type gameCenterEnabledVersions
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param limit maximum resources per page
     * @param limitCompatibleVersions maximum number of related compatibleVersions returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public gameCenterEnabledVersionsCompatibleVersionsGetToManyRelatedWithHttpInfo(id: string, filterPlatform?: Array<'IOS' | 'MAC_OS' | 'TV_OS' | 'VISION_OS'>, filterVersionString?: Array<string>, filterApp?: Array<string>, filterId?: Array<string>, sort?: Array<'versionString' | '-versionString'>, fieldsGameCenterEnabledVersions?: Array<'app' | 'compatibleVersions' | 'iconAsset' | 'platform' | 'versionString'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, limit?: number, limitCompatibleVersions?: number, include?: Array<'app' | 'compatibleVersions'>, _options?: Configuration): Observable<HttpInfo<GameCenterEnabledVersionsResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterEnabledVersionsCompatibleVersionsGetToManyRelated(id, filterPlatform, filterVersionString, filterApp, filterId, sort, fieldsGameCenterEnabledVersions, fieldsApps, limit, limitCompatibleVersions, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterEnabledVersionsCompatibleVersionsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param filterPlatform filter by attribute \&#39;platform\&#39;
     * @param filterVersionString filter by attribute \&#39;versionString\&#39;
     * @param filterApp filter by id(s) of related \&#39;app\&#39;
     * @param filterId filter by id(s)
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsGameCenterEnabledVersions the fields to include for returned resources of type gameCenterEnabledVersions
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param limit maximum resources per page
     * @param limitCompatibleVersions maximum number of related compatibleVersions returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public gameCenterEnabledVersionsCompatibleVersionsGetToManyRelated(id: string, filterPlatform?: Array<'IOS' | 'MAC_OS' | 'TV_OS' | 'VISION_OS'>, filterVersionString?: Array<string>, filterApp?: Array<string>, filterId?: Array<string>, sort?: Array<'versionString' | '-versionString'>, fieldsGameCenterEnabledVersions?: Array<'app' | 'compatibleVersions' | 'iconAsset' | 'platform' | 'versionString'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, limit?: number, limitCompatibleVersions?: number, include?: Array<'app' | 'compatibleVersions'>, _options?: Configuration): Observable<GameCenterEnabledVersionsResponse> {
        return this.gameCenterEnabledVersionsCompatibleVersionsGetToManyRelatedWithHttpInfo(id, filterPlatform, filterVersionString, filterApp, filterId, sort, fieldsGameCenterEnabledVersions, fieldsApps, limit, limitCompatibleVersions, include, _options).pipe(map((apiResponse: HttpInfo<GameCenterEnabledVersionsResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public gameCenterEnabledVersionsCompatibleVersionsGetToManyRelationshipWithHttpInfo(id: string, limit?: number, _options?: Configuration): Observable<HttpInfo<GameCenterEnabledVersionCompatibleVersionsLinkagesResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterEnabledVersionsCompatibleVersionsGetToManyRelationship(id, limit, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterEnabledVersionsCompatibleVersionsGetToManyRelationshipWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public gameCenterEnabledVersionsCompatibleVersionsGetToManyRelationship(id: string, limit?: number, _options?: Configuration): Observable<GameCenterEnabledVersionCompatibleVersionsLinkagesResponse> {
        return this.gameCenterEnabledVersionsCompatibleVersionsGetToManyRelationshipWithHttpInfo(id, limit, _options).pipe(map((apiResponse: HttpInfo<GameCenterEnabledVersionCompatibleVersionsLinkagesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterEnabledVersionCompatibleVersionsLinkagesRequest List of related linkages
     */
    public gameCenterEnabledVersionsCompatibleVersionsReplaceToManyRelationshipWithHttpInfo(id: string, gameCenterEnabledVersionCompatibleVersionsLinkagesRequest: GameCenterEnabledVersionCompatibleVersionsLinkagesRequest, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.gameCenterEnabledVersionsCompatibleVersionsReplaceToManyRelationship(id, gameCenterEnabledVersionCompatibleVersionsLinkagesRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterEnabledVersionsCompatibleVersionsReplaceToManyRelationshipWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterEnabledVersionCompatibleVersionsLinkagesRequest List of related linkages
     */
    public gameCenterEnabledVersionsCompatibleVersionsReplaceToManyRelationship(id: string, gameCenterEnabledVersionCompatibleVersionsLinkagesRequest: GameCenterEnabledVersionCompatibleVersionsLinkagesRequest, _options?: Configuration): Observable<void> {
        return this.gameCenterEnabledVersionsCompatibleVersionsReplaceToManyRelationshipWithHttpInfo(id, gameCenterEnabledVersionCompatibleVersionsLinkagesRequest, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

}

import { GameCenterGroupsApiRequestFactory, GameCenterGroupsApiResponseProcessor} from "../apis/GameCenterGroupsApi.ts";
export class ObservableGameCenterGroupsApi {
    private requestFactory: GameCenterGroupsApiRequestFactory;
    private responseProcessor: GameCenterGroupsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: GameCenterGroupsApiRequestFactory,
        responseProcessor?: GameCenterGroupsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new GameCenterGroupsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new GameCenterGroupsApiResponseProcessor();
    }

    /**
     * @param gameCenterGroupCreateRequest GameCenterGroup representation
     */
    public gameCenterGroupsCreateInstanceWithHttpInfo(gameCenterGroupCreateRequest: GameCenterGroupCreateRequest, _options?: Configuration): Observable<HttpInfo<GameCenterGroupResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterGroupsCreateInstance(gameCenterGroupCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterGroupsCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param gameCenterGroupCreateRequest GameCenterGroup representation
     */
    public gameCenterGroupsCreateInstance(gameCenterGroupCreateRequest: GameCenterGroupCreateRequest, _options?: Configuration): Observable<GameCenterGroupResponse> {
        return this.gameCenterGroupsCreateInstanceWithHttpInfo(gameCenterGroupCreateRequest, _options).pipe(map((apiResponse: HttpInfo<GameCenterGroupResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterGroupsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.gameCenterGroupsDeleteInstance(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterGroupsDeleteInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterGroupsDeleteInstance(id: string, _options?: Configuration): Observable<void> {
        return this.gameCenterGroupsDeleteInstanceWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param filterArchived filter by attribute \&#39;archived\&#39;
     * @param filterReferenceName filter by attribute \&#39;referenceName\&#39;
     * @param filterId filter by id(s)
     * @param fieldsGameCenterAchievementReleases the fields to include for returned resources of type gameCenterAchievementReleases
     * @param fieldsGameCenterGroups the fields to include for returned resources of type gameCenterGroups
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterAchievementLocalizations the fields to include for returned resources of type gameCenterAchievementLocalizations
     * @param fieldsGameCenterAchievements the fields to include for returned resources of type gameCenterAchievements
     * @param limit maximum resources per page
     * @param limitLocalizations maximum number of related localizations returned (when they are included)
     * @param limitReleases maximum number of related releases returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public gameCenterGroupsGameCenterAchievementsGetToManyRelatedWithHttpInfo(id: string, filterArchived?: Array<string>, filterReferenceName?: Array<string>, filterId?: Array<string>, fieldsGameCenterAchievementReleases?: Array<'gameCenterAchievement' | 'gameCenterDetail' | 'live'>, fieldsGameCenterGroups?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'referenceName'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterAchievementLocalizations?: Array<'afterEarnedDescription' | 'beforeEarnedDescription' | 'gameCenterAchievement' | 'gameCenterAchievementImage' | 'locale' | 'name'>, fieldsGameCenterAchievements?: Array<'archived' | 'gameCenterDetail' | 'gameCenterGroup' | 'groupAchievement' | 'localizations' | 'points' | 'referenceName' | 'releases' | 'repeatable' | 'showBeforeEarned' | 'vendorIdentifier'>, limit?: number, limitLocalizations?: number, limitReleases?: number, include?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'groupAchievement' | 'localizations' | 'releases'>, _options?: Configuration): Observable<HttpInfo<GameCenterAchievementsResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterGroupsGameCenterAchievementsGetToManyRelated(id, filterArchived, filterReferenceName, filterId, fieldsGameCenterAchievementReleases, fieldsGameCenterGroups, fieldsGameCenterDetails, fieldsGameCenterAchievementLocalizations, fieldsGameCenterAchievements, limit, limitLocalizations, limitReleases, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterGroupsGameCenterAchievementsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param filterArchived filter by attribute \&#39;archived\&#39;
     * @param filterReferenceName filter by attribute \&#39;referenceName\&#39;
     * @param filterId filter by id(s)
     * @param fieldsGameCenterAchievementReleases the fields to include for returned resources of type gameCenterAchievementReleases
     * @param fieldsGameCenterGroups the fields to include for returned resources of type gameCenterGroups
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterAchievementLocalizations the fields to include for returned resources of type gameCenterAchievementLocalizations
     * @param fieldsGameCenterAchievements the fields to include for returned resources of type gameCenterAchievements
     * @param limit maximum resources per page
     * @param limitLocalizations maximum number of related localizations returned (when they are included)
     * @param limitReleases maximum number of related releases returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public gameCenterGroupsGameCenterAchievementsGetToManyRelated(id: string, filterArchived?: Array<string>, filterReferenceName?: Array<string>, filterId?: Array<string>, fieldsGameCenterAchievementReleases?: Array<'gameCenterAchievement' | 'gameCenterDetail' | 'live'>, fieldsGameCenterGroups?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'referenceName'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterAchievementLocalizations?: Array<'afterEarnedDescription' | 'beforeEarnedDescription' | 'gameCenterAchievement' | 'gameCenterAchievementImage' | 'locale' | 'name'>, fieldsGameCenterAchievements?: Array<'archived' | 'gameCenterDetail' | 'gameCenterGroup' | 'groupAchievement' | 'localizations' | 'points' | 'referenceName' | 'releases' | 'repeatable' | 'showBeforeEarned' | 'vendorIdentifier'>, limit?: number, limitLocalizations?: number, limitReleases?: number, include?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'groupAchievement' | 'localizations' | 'releases'>, _options?: Configuration): Observable<GameCenterAchievementsResponse> {
        return this.gameCenterGroupsGameCenterAchievementsGetToManyRelatedWithHttpInfo(id, filterArchived, filterReferenceName, filterId, fieldsGameCenterAchievementReleases, fieldsGameCenterGroups, fieldsGameCenterDetails, fieldsGameCenterAchievementLocalizations, fieldsGameCenterAchievements, limit, limitLocalizations, limitReleases, include, _options).pipe(map((apiResponse: HttpInfo<GameCenterAchievementsResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public gameCenterGroupsGameCenterAchievementsGetToManyRelationshipWithHttpInfo(id: string, limit?: number, _options?: Configuration): Observable<HttpInfo<GameCenterGroupGameCenterAchievementsLinkagesResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterGroupsGameCenterAchievementsGetToManyRelationship(id, limit, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterGroupsGameCenterAchievementsGetToManyRelationshipWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public gameCenterGroupsGameCenterAchievementsGetToManyRelationship(id: string, limit?: number, _options?: Configuration): Observable<GameCenterGroupGameCenterAchievementsLinkagesResponse> {
        return this.gameCenterGroupsGameCenterAchievementsGetToManyRelationshipWithHttpInfo(id, limit, _options).pipe(map((apiResponse: HttpInfo<GameCenterGroupGameCenterAchievementsLinkagesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterGroupGameCenterAchievementsLinkagesRequest List of related linkages
     */
    public gameCenterGroupsGameCenterAchievementsReplaceToManyRelationshipWithHttpInfo(id: string, gameCenterGroupGameCenterAchievementsLinkagesRequest: GameCenterGroupGameCenterAchievementsLinkagesRequest, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.gameCenterGroupsGameCenterAchievementsReplaceToManyRelationship(id, gameCenterGroupGameCenterAchievementsLinkagesRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterGroupsGameCenterAchievementsReplaceToManyRelationshipWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterGroupGameCenterAchievementsLinkagesRequest List of related linkages
     */
    public gameCenterGroupsGameCenterAchievementsReplaceToManyRelationship(id: string, gameCenterGroupGameCenterAchievementsLinkagesRequest: GameCenterGroupGameCenterAchievementsLinkagesRequest, _options?: Configuration): Observable<void> {
        return this.gameCenterGroupsGameCenterAchievementsReplaceToManyRelationshipWithHttpInfo(id, gameCenterGroupGameCenterAchievementsLinkagesRequest, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param filterGameCenterAppVersionsEnabled filter by attribute \&#39;gameCenterAppVersions.enabled\&#39;
     * @param fieldsGameCenterAchievementReleases the fields to include for returned resources of type gameCenterAchievementReleases
     * @param fieldsGameCenterLeaderboardSetReleases the fields to include for returned resources of type gameCenterLeaderboardSetReleases
     * @param fieldsGameCenterLeaderboardSets the fields to include for returned resources of type gameCenterLeaderboardSets
     * @param fieldsGameCenterGroups the fields to include for returned resources of type gameCenterGroups
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     * @param fieldsGameCenterAppVersions the fields to include for returned resources of type gameCenterAppVersions
     * @param fieldsGameCenterAchievements the fields to include for returned resources of type gameCenterAchievements
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsGameCenterLeaderboardReleases the fields to include for returned resources of type gameCenterLeaderboardReleases
     * @param limit maximum resources per page
     * @param limitGameCenterAppVersions maximum number of related gameCenterAppVersions returned (when they are included)
     * @param limitGameCenterLeaderboards maximum number of related gameCenterLeaderboards returned (when they are included)
     * @param limitGameCenterLeaderboardSets maximum number of related gameCenterLeaderboardSets returned (when they are included)
     * @param limitGameCenterAchievements maximum number of related gameCenterAchievements returned (when they are included)
     * @param limitAchievementReleases maximum number of related achievementReleases returned (when they are included)
     * @param limitLeaderboardReleases maximum number of related leaderboardReleases returned (when they are included)
     * @param limitLeaderboardSetReleases maximum number of related leaderboardSetReleases returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public gameCenterGroupsGameCenterDetailsGetToManyRelatedWithHttpInfo(id: string, filterGameCenterAppVersionsEnabled?: Array<string>, fieldsGameCenterAchievementReleases?: Array<'gameCenterAchievement' | 'gameCenterDetail' | 'live'>, fieldsGameCenterLeaderboardSetReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboardSet' | 'live'>, fieldsGameCenterLeaderboardSets?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'referenceName' | 'releases' | 'vendorIdentifier'>, fieldsGameCenterGroups?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'referenceName'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, fieldsGameCenterAppVersions?: Array<'appStoreVersion' | 'compatibilityVersions' | 'enabled'>, fieldsGameCenterAchievements?: Array<'archived' | 'gameCenterDetail' | 'gameCenterGroup' | 'groupAchievement' | 'localizations' | 'points' | 'referenceName' | 'releases' | 'repeatable' | 'showBeforeEarned' | 'vendorIdentifier'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsGameCenterLeaderboardReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboard' | 'live'>, limit?: number, limitGameCenterAppVersions?: number, limitGameCenterLeaderboards?: number, limitGameCenterLeaderboardSets?: number, limitGameCenterAchievements?: number, limitAchievementReleases?: number, limitLeaderboardReleases?: number, limitLeaderboardSetReleases?: number, include?: Array<'achievementReleases' | 'app' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, _options?: Configuration): Observable<HttpInfo<GameCenterDetailsResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterGroupsGameCenterDetailsGetToManyRelated(id, filterGameCenterAppVersionsEnabled, fieldsGameCenterAchievementReleases, fieldsGameCenterLeaderboardSetReleases, fieldsGameCenterLeaderboardSets, fieldsGameCenterGroups, fieldsGameCenterDetails, fieldsGameCenterLeaderboards, fieldsGameCenterAppVersions, fieldsGameCenterAchievements, fieldsApps, fieldsGameCenterLeaderboardReleases, limit, limitGameCenterAppVersions, limitGameCenterLeaderboards, limitGameCenterLeaderboardSets, limitGameCenterAchievements, limitAchievementReleases, limitLeaderboardReleases, limitLeaderboardSetReleases, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterGroupsGameCenterDetailsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param filterGameCenterAppVersionsEnabled filter by attribute \&#39;gameCenterAppVersions.enabled\&#39;
     * @param fieldsGameCenterAchievementReleases the fields to include for returned resources of type gameCenterAchievementReleases
     * @param fieldsGameCenterLeaderboardSetReleases the fields to include for returned resources of type gameCenterLeaderboardSetReleases
     * @param fieldsGameCenterLeaderboardSets the fields to include for returned resources of type gameCenterLeaderboardSets
     * @param fieldsGameCenterGroups the fields to include for returned resources of type gameCenterGroups
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     * @param fieldsGameCenterAppVersions the fields to include for returned resources of type gameCenterAppVersions
     * @param fieldsGameCenterAchievements the fields to include for returned resources of type gameCenterAchievements
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsGameCenterLeaderboardReleases the fields to include for returned resources of type gameCenterLeaderboardReleases
     * @param limit maximum resources per page
     * @param limitGameCenterAppVersions maximum number of related gameCenterAppVersions returned (when they are included)
     * @param limitGameCenterLeaderboards maximum number of related gameCenterLeaderboards returned (when they are included)
     * @param limitGameCenterLeaderboardSets maximum number of related gameCenterLeaderboardSets returned (when they are included)
     * @param limitGameCenterAchievements maximum number of related gameCenterAchievements returned (when they are included)
     * @param limitAchievementReleases maximum number of related achievementReleases returned (when they are included)
     * @param limitLeaderboardReleases maximum number of related leaderboardReleases returned (when they are included)
     * @param limitLeaderboardSetReleases maximum number of related leaderboardSetReleases returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public gameCenterGroupsGameCenterDetailsGetToManyRelated(id: string, filterGameCenterAppVersionsEnabled?: Array<string>, fieldsGameCenterAchievementReleases?: Array<'gameCenterAchievement' | 'gameCenterDetail' | 'live'>, fieldsGameCenterLeaderboardSetReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboardSet' | 'live'>, fieldsGameCenterLeaderboardSets?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'referenceName' | 'releases' | 'vendorIdentifier'>, fieldsGameCenterGroups?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'referenceName'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, fieldsGameCenterAppVersions?: Array<'appStoreVersion' | 'compatibilityVersions' | 'enabled'>, fieldsGameCenterAchievements?: Array<'archived' | 'gameCenterDetail' | 'gameCenterGroup' | 'groupAchievement' | 'localizations' | 'points' | 'referenceName' | 'releases' | 'repeatable' | 'showBeforeEarned' | 'vendorIdentifier'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsGameCenterLeaderboardReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboard' | 'live'>, limit?: number, limitGameCenterAppVersions?: number, limitGameCenterLeaderboards?: number, limitGameCenterLeaderboardSets?: number, limitGameCenterAchievements?: number, limitAchievementReleases?: number, limitLeaderboardReleases?: number, limitLeaderboardSetReleases?: number, include?: Array<'achievementReleases' | 'app' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, _options?: Configuration): Observable<GameCenterDetailsResponse> {
        return this.gameCenterGroupsGameCenterDetailsGetToManyRelatedWithHttpInfo(id, filterGameCenterAppVersionsEnabled, fieldsGameCenterAchievementReleases, fieldsGameCenterLeaderboardSetReleases, fieldsGameCenterLeaderboardSets, fieldsGameCenterGroups, fieldsGameCenterDetails, fieldsGameCenterLeaderboards, fieldsGameCenterAppVersions, fieldsGameCenterAchievements, fieldsApps, fieldsGameCenterLeaderboardReleases, limit, limitGameCenterAppVersions, limitGameCenterLeaderboards, limitGameCenterLeaderboardSets, limitGameCenterAchievements, limitAchievementReleases, limitLeaderboardReleases, limitLeaderboardSetReleases, include, _options).pipe(map((apiResponse: HttpInfo<GameCenterDetailsResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param filterReferenceName filter by attribute \&#39;referenceName\&#39;
     * @param filterId filter by id(s)
     * @param fieldsGameCenterLeaderboardSetLocalizations the fields to include for returned resources of type gameCenterLeaderboardSetLocalizations
     * @param fieldsGameCenterLeaderboardSetReleases the fields to include for returned resources of type gameCenterLeaderboardSetReleases
     * @param fieldsGameCenterLeaderboardSets the fields to include for returned resources of type gameCenterLeaderboardSets
     * @param fieldsGameCenterGroups the fields to include for returned resources of type gameCenterGroups
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     * @param limit maximum resources per page
     * @param limitLocalizations maximum number of related localizations returned (when they are included)
     * @param limitGameCenterLeaderboards maximum number of related gameCenterLeaderboards returned (when they are included)
     * @param limitReleases maximum number of related releases returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public gameCenterGroupsGameCenterLeaderboardSetsGetToManyRelatedWithHttpInfo(id: string, filterReferenceName?: Array<string>, filterId?: Array<string>, fieldsGameCenterLeaderboardSetLocalizations?: Array<'gameCenterLeaderboardSet' | 'gameCenterLeaderboardSetImage' | 'locale' | 'name'>, fieldsGameCenterLeaderboardSetReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboardSet' | 'live'>, fieldsGameCenterLeaderboardSets?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'referenceName' | 'releases' | 'vendorIdentifier'>, fieldsGameCenterGroups?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'referenceName'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, limit?: number, limitLocalizations?: number, limitGameCenterLeaderboards?: number, limitReleases?: number, include?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'releases'>, _options?: Configuration): Observable<HttpInfo<GameCenterLeaderboardSetsResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterGroupsGameCenterLeaderboardSetsGetToManyRelated(id, filterReferenceName, filterId, fieldsGameCenterLeaderboardSetLocalizations, fieldsGameCenterLeaderboardSetReleases, fieldsGameCenterLeaderboardSets, fieldsGameCenterGroups, fieldsGameCenterDetails, fieldsGameCenterLeaderboards, limit, limitLocalizations, limitGameCenterLeaderboards, limitReleases, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterGroupsGameCenterLeaderboardSetsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param filterReferenceName filter by attribute \&#39;referenceName\&#39;
     * @param filterId filter by id(s)
     * @param fieldsGameCenterLeaderboardSetLocalizations the fields to include for returned resources of type gameCenterLeaderboardSetLocalizations
     * @param fieldsGameCenterLeaderboardSetReleases the fields to include for returned resources of type gameCenterLeaderboardSetReleases
     * @param fieldsGameCenterLeaderboardSets the fields to include for returned resources of type gameCenterLeaderboardSets
     * @param fieldsGameCenterGroups the fields to include for returned resources of type gameCenterGroups
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     * @param limit maximum resources per page
     * @param limitLocalizations maximum number of related localizations returned (when they are included)
     * @param limitGameCenterLeaderboards maximum number of related gameCenterLeaderboards returned (when they are included)
     * @param limitReleases maximum number of related releases returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public gameCenterGroupsGameCenterLeaderboardSetsGetToManyRelated(id: string, filterReferenceName?: Array<string>, filterId?: Array<string>, fieldsGameCenterLeaderboardSetLocalizations?: Array<'gameCenterLeaderboardSet' | 'gameCenterLeaderboardSetImage' | 'locale' | 'name'>, fieldsGameCenterLeaderboardSetReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboardSet' | 'live'>, fieldsGameCenterLeaderboardSets?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'referenceName' | 'releases' | 'vendorIdentifier'>, fieldsGameCenterGroups?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'referenceName'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, limit?: number, limitLocalizations?: number, limitGameCenterLeaderboards?: number, limitReleases?: number, include?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'releases'>, _options?: Configuration): Observable<GameCenterLeaderboardSetsResponse> {
        return this.gameCenterGroupsGameCenterLeaderboardSetsGetToManyRelatedWithHttpInfo(id, filterReferenceName, filterId, fieldsGameCenterLeaderboardSetLocalizations, fieldsGameCenterLeaderboardSetReleases, fieldsGameCenterLeaderboardSets, fieldsGameCenterGroups, fieldsGameCenterDetails, fieldsGameCenterLeaderboards, limit, limitLocalizations, limitGameCenterLeaderboards, limitReleases, include, _options).pipe(map((apiResponse: HttpInfo<GameCenterLeaderboardSetsResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public gameCenterGroupsGameCenterLeaderboardSetsGetToManyRelationshipWithHttpInfo(id: string, limit?: number, _options?: Configuration): Observable<HttpInfo<GameCenterGroupGameCenterLeaderboardSetsLinkagesResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterGroupsGameCenterLeaderboardSetsGetToManyRelationship(id, limit, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterGroupsGameCenterLeaderboardSetsGetToManyRelationshipWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public gameCenterGroupsGameCenterLeaderboardSetsGetToManyRelationship(id: string, limit?: number, _options?: Configuration): Observable<GameCenterGroupGameCenterLeaderboardSetsLinkagesResponse> {
        return this.gameCenterGroupsGameCenterLeaderboardSetsGetToManyRelationshipWithHttpInfo(id, limit, _options).pipe(map((apiResponse: HttpInfo<GameCenterGroupGameCenterLeaderboardSetsLinkagesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterGroupGameCenterLeaderboardSetsLinkagesRequest List of related linkages
     */
    public gameCenterGroupsGameCenterLeaderboardSetsReplaceToManyRelationshipWithHttpInfo(id: string, gameCenterGroupGameCenterLeaderboardSetsLinkagesRequest: GameCenterGroupGameCenterLeaderboardSetsLinkagesRequest, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.gameCenterGroupsGameCenterLeaderboardSetsReplaceToManyRelationship(id, gameCenterGroupGameCenterLeaderboardSetsLinkagesRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterGroupsGameCenterLeaderboardSetsReplaceToManyRelationshipWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterGroupGameCenterLeaderboardSetsLinkagesRequest List of related linkages
     */
    public gameCenterGroupsGameCenterLeaderboardSetsReplaceToManyRelationship(id: string, gameCenterGroupGameCenterLeaderboardSetsLinkagesRequest: GameCenterGroupGameCenterLeaderboardSetsLinkagesRequest, _options?: Configuration): Observable<void> {
        return this.gameCenterGroupsGameCenterLeaderboardSetsReplaceToManyRelationshipWithHttpInfo(id, gameCenterGroupGameCenterLeaderboardSetsLinkagesRequest, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param filterArchived filter by attribute \&#39;archived\&#39;
     * @param filterReferenceName filter by attribute \&#39;referenceName\&#39;
     * @param filterId filter by id(s)
     * @param fieldsGameCenterLeaderboardLocalizations the fields to include for returned resources of type gameCenterLeaderboardLocalizations
     * @param fieldsGameCenterLeaderboardSets the fields to include for returned resources of type gameCenterLeaderboardSets
     * @param fieldsGameCenterGroups the fields to include for returned resources of type gameCenterGroups
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     * @param fieldsGameCenterLeaderboardReleases the fields to include for returned resources of type gameCenterLeaderboardReleases
     * @param limit maximum resources per page
     * @param limitGameCenterLeaderboardSets maximum number of related gameCenterLeaderboardSets returned (when they are included)
     * @param limitLocalizations maximum number of related localizations returned (when they are included)
     * @param limitReleases maximum number of related releases returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public gameCenterGroupsGameCenterLeaderboardsGetToManyRelatedWithHttpInfo(id: string, filterArchived?: Array<string>, filterReferenceName?: Array<string>, filterId?: Array<string>, fieldsGameCenterLeaderboardLocalizations?: Array<'formatterOverride' | 'formatterSuffix' | 'formatterSuffixSingular' | 'gameCenterLeaderboard' | 'gameCenterLeaderboardImage' | 'locale' | 'name'>, fieldsGameCenterLeaderboardSets?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'referenceName' | 'releases' | 'vendorIdentifier'>, fieldsGameCenterGroups?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'referenceName'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, fieldsGameCenterLeaderboardReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboard' | 'live'>, limit?: number, limitGameCenterLeaderboardSets?: number, limitLocalizations?: number, limitReleases?: number, include?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'releases'>, _options?: Configuration): Observable<HttpInfo<GameCenterLeaderboardsResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterGroupsGameCenterLeaderboardsGetToManyRelated(id, filterArchived, filterReferenceName, filterId, fieldsGameCenterLeaderboardLocalizations, fieldsGameCenterLeaderboardSets, fieldsGameCenterGroups, fieldsGameCenterDetails, fieldsGameCenterLeaderboards, fieldsGameCenterLeaderboardReleases, limit, limitGameCenterLeaderboardSets, limitLocalizations, limitReleases, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterGroupsGameCenterLeaderboardsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param filterArchived filter by attribute \&#39;archived\&#39;
     * @param filterReferenceName filter by attribute \&#39;referenceName\&#39;
     * @param filterId filter by id(s)
     * @param fieldsGameCenterLeaderboardLocalizations the fields to include for returned resources of type gameCenterLeaderboardLocalizations
     * @param fieldsGameCenterLeaderboardSets the fields to include for returned resources of type gameCenterLeaderboardSets
     * @param fieldsGameCenterGroups the fields to include for returned resources of type gameCenterGroups
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     * @param fieldsGameCenterLeaderboardReleases the fields to include for returned resources of type gameCenterLeaderboardReleases
     * @param limit maximum resources per page
     * @param limitGameCenterLeaderboardSets maximum number of related gameCenterLeaderboardSets returned (when they are included)
     * @param limitLocalizations maximum number of related localizations returned (when they are included)
     * @param limitReleases maximum number of related releases returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public gameCenterGroupsGameCenterLeaderboardsGetToManyRelated(id: string, filterArchived?: Array<string>, filterReferenceName?: Array<string>, filterId?: Array<string>, fieldsGameCenterLeaderboardLocalizations?: Array<'formatterOverride' | 'formatterSuffix' | 'formatterSuffixSingular' | 'gameCenterLeaderboard' | 'gameCenterLeaderboardImage' | 'locale' | 'name'>, fieldsGameCenterLeaderboardSets?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'referenceName' | 'releases' | 'vendorIdentifier'>, fieldsGameCenterGroups?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'referenceName'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, fieldsGameCenterLeaderboardReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboard' | 'live'>, limit?: number, limitGameCenterLeaderboardSets?: number, limitLocalizations?: number, limitReleases?: number, include?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'releases'>, _options?: Configuration): Observable<GameCenterLeaderboardsResponse> {
        return this.gameCenterGroupsGameCenterLeaderboardsGetToManyRelatedWithHttpInfo(id, filterArchived, filterReferenceName, filterId, fieldsGameCenterLeaderboardLocalizations, fieldsGameCenterLeaderboardSets, fieldsGameCenterGroups, fieldsGameCenterDetails, fieldsGameCenterLeaderboards, fieldsGameCenterLeaderboardReleases, limit, limitGameCenterLeaderboardSets, limitLocalizations, limitReleases, include, _options).pipe(map((apiResponse: HttpInfo<GameCenterLeaderboardsResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public gameCenterGroupsGameCenterLeaderboardsGetToManyRelationshipWithHttpInfo(id: string, limit?: number, _options?: Configuration): Observable<HttpInfo<GameCenterGroupGameCenterLeaderboardsLinkagesResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterGroupsGameCenterLeaderboardsGetToManyRelationship(id, limit, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterGroupsGameCenterLeaderboardsGetToManyRelationshipWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public gameCenterGroupsGameCenterLeaderboardsGetToManyRelationship(id: string, limit?: number, _options?: Configuration): Observable<GameCenterGroupGameCenterLeaderboardsLinkagesResponse> {
        return this.gameCenterGroupsGameCenterLeaderboardsGetToManyRelationshipWithHttpInfo(id, limit, _options).pipe(map((apiResponse: HttpInfo<GameCenterGroupGameCenterLeaderboardsLinkagesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterGroupGameCenterLeaderboardsLinkagesRequest List of related linkages
     */
    public gameCenterGroupsGameCenterLeaderboardsReplaceToManyRelationshipWithHttpInfo(id: string, gameCenterGroupGameCenterLeaderboardsLinkagesRequest: GameCenterGroupGameCenterLeaderboardsLinkagesRequest, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.gameCenterGroupsGameCenterLeaderboardsReplaceToManyRelationship(id, gameCenterGroupGameCenterLeaderboardsLinkagesRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterGroupsGameCenterLeaderboardsReplaceToManyRelationshipWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterGroupGameCenterLeaderboardsLinkagesRequest List of related linkages
     */
    public gameCenterGroupsGameCenterLeaderboardsReplaceToManyRelationship(id: string, gameCenterGroupGameCenterLeaderboardsLinkagesRequest: GameCenterGroupGameCenterLeaderboardsLinkagesRequest, _options?: Configuration): Observable<void> {
        return this.gameCenterGroupsGameCenterLeaderboardsReplaceToManyRelationshipWithHttpInfo(id, gameCenterGroupGameCenterLeaderboardsLinkagesRequest, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param filterGameCenterDetails filter by id(s) of related \&#39;gameCenterDetails\&#39;
     * @param fieldsGameCenterGroups the fields to include for returned resources of type gameCenterGroups
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsGameCenterLeaderboardSets the fields to include for returned resources of type gameCenterLeaderboardSets
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     * @param fieldsGameCenterAchievements the fields to include for returned resources of type gameCenterAchievements
     * @param limitGameCenterAchievements maximum number of related gameCenterAchievements returned (when they are included)
     * @param limitGameCenterDetails maximum number of related gameCenterDetails returned (when they are included)
     * @param limitGameCenterLeaderboardSets maximum number of related gameCenterLeaderboardSets returned (when they are included)
     * @param limitGameCenterLeaderboards maximum number of related gameCenterLeaderboards returned (when they are included)
     */
    public gameCenterGroupsGetCollectionWithHttpInfo(filterGameCenterDetails?: Array<string>, fieldsGameCenterGroups?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'referenceName'>, limit?: number, include?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards'>, fieldsGameCenterLeaderboardSets?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'referenceName' | 'releases' | 'vendorIdentifier'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, fieldsGameCenterAchievements?: Array<'archived' | 'gameCenterDetail' | 'gameCenterGroup' | 'groupAchievement' | 'localizations' | 'points' | 'referenceName' | 'releases' | 'repeatable' | 'showBeforeEarned' | 'vendorIdentifier'>, limitGameCenterAchievements?: number, limitGameCenterDetails?: number, limitGameCenterLeaderboardSets?: number, limitGameCenterLeaderboards?: number, _options?: Configuration): Observable<HttpInfo<GameCenterGroupsResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterGroupsGetCollection(filterGameCenterDetails, fieldsGameCenterGroups, limit, include, fieldsGameCenterLeaderboardSets, fieldsGameCenterDetails, fieldsGameCenterLeaderboards, fieldsGameCenterAchievements, limitGameCenterAchievements, limitGameCenterDetails, limitGameCenterLeaderboardSets, limitGameCenterLeaderboards, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterGroupsGetCollectionWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param filterGameCenterDetails filter by id(s) of related \&#39;gameCenterDetails\&#39;
     * @param fieldsGameCenterGroups the fields to include for returned resources of type gameCenterGroups
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsGameCenterLeaderboardSets the fields to include for returned resources of type gameCenterLeaderboardSets
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     * @param fieldsGameCenterAchievements the fields to include for returned resources of type gameCenterAchievements
     * @param limitGameCenterAchievements maximum number of related gameCenterAchievements returned (when they are included)
     * @param limitGameCenterDetails maximum number of related gameCenterDetails returned (when they are included)
     * @param limitGameCenterLeaderboardSets maximum number of related gameCenterLeaderboardSets returned (when they are included)
     * @param limitGameCenterLeaderboards maximum number of related gameCenterLeaderboards returned (when they are included)
     */
    public gameCenterGroupsGetCollection(filterGameCenterDetails?: Array<string>, fieldsGameCenterGroups?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'referenceName'>, limit?: number, include?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards'>, fieldsGameCenterLeaderboardSets?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'referenceName' | 'releases' | 'vendorIdentifier'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, fieldsGameCenterAchievements?: Array<'archived' | 'gameCenterDetail' | 'gameCenterGroup' | 'groupAchievement' | 'localizations' | 'points' | 'referenceName' | 'releases' | 'repeatable' | 'showBeforeEarned' | 'vendorIdentifier'>, limitGameCenterAchievements?: number, limitGameCenterDetails?: number, limitGameCenterLeaderboardSets?: number, limitGameCenterLeaderboards?: number, _options?: Configuration): Observable<GameCenterGroupsResponse> {
        return this.gameCenterGroupsGetCollectionWithHttpInfo(filterGameCenterDetails, fieldsGameCenterGroups, limit, include, fieldsGameCenterLeaderboardSets, fieldsGameCenterDetails, fieldsGameCenterLeaderboards, fieldsGameCenterAchievements, limitGameCenterAchievements, limitGameCenterDetails, limitGameCenterLeaderboardSets, limitGameCenterLeaderboards, _options).pipe(map((apiResponse: HttpInfo<GameCenterGroupsResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterGroups the fields to include for returned resources of type gameCenterGroups
     * @param include comma-separated list of relationships to include
     * @param fieldsGameCenterLeaderboardSets the fields to include for returned resources of type gameCenterLeaderboardSets
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     * @param fieldsGameCenterAchievements the fields to include for returned resources of type gameCenterAchievements
     * @param limitGameCenterAchievements maximum number of related gameCenterAchievements returned (when they are included)
     * @param limitGameCenterDetails maximum number of related gameCenterDetails returned (when they are included)
     * @param limitGameCenterLeaderboardSets maximum number of related gameCenterLeaderboardSets returned (when they are included)
     * @param limitGameCenterLeaderboards maximum number of related gameCenterLeaderboards returned (when they are included)
     */
    public gameCenterGroupsGetInstanceWithHttpInfo(id: string, fieldsGameCenterGroups?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'referenceName'>, include?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards'>, fieldsGameCenterLeaderboardSets?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'referenceName' | 'releases' | 'vendorIdentifier'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, fieldsGameCenterAchievements?: Array<'archived' | 'gameCenterDetail' | 'gameCenterGroup' | 'groupAchievement' | 'localizations' | 'points' | 'referenceName' | 'releases' | 'repeatable' | 'showBeforeEarned' | 'vendorIdentifier'>, limitGameCenterAchievements?: number, limitGameCenterDetails?: number, limitGameCenterLeaderboardSets?: number, limitGameCenterLeaderboards?: number, _options?: Configuration): Observable<HttpInfo<GameCenterGroupResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterGroupsGetInstance(id, fieldsGameCenterGroups, include, fieldsGameCenterLeaderboardSets, fieldsGameCenterDetails, fieldsGameCenterLeaderboards, fieldsGameCenterAchievements, limitGameCenterAchievements, limitGameCenterDetails, limitGameCenterLeaderboardSets, limitGameCenterLeaderboards, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterGroupsGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterGroups the fields to include for returned resources of type gameCenterGroups
     * @param include comma-separated list of relationships to include
     * @param fieldsGameCenterLeaderboardSets the fields to include for returned resources of type gameCenterLeaderboardSets
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     * @param fieldsGameCenterAchievements the fields to include for returned resources of type gameCenterAchievements
     * @param limitGameCenterAchievements maximum number of related gameCenterAchievements returned (when they are included)
     * @param limitGameCenterDetails maximum number of related gameCenterDetails returned (when they are included)
     * @param limitGameCenterLeaderboardSets maximum number of related gameCenterLeaderboardSets returned (when they are included)
     * @param limitGameCenterLeaderboards maximum number of related gameCenterLeaderboards returned (when they are included)
     */
    public gameCenterGroupsGetInstance(id: string, fieldsGameCenterGroups?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'referenceName'>, include?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards'>, fieldsGameCenterLeaderboardSets?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'referenceName' | 'releases' | 'vendorIdentifier'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, fieldsGameCenterAchievements?: Array<'archived' | 'gameCenterDetail' | 'gameCenterGroup' | 'groupAchievement' | 'localizations' | 'points' | 'referenceName' | 'releases' | 'repeatable' | 'showBeforeEarned' | 'vendorIdentifier'>, limitGameCenterAchievements?: number, limitGameCenterDetails?: number, limitGameCenterLeaderboardSets?: number, limitGameCenterLeaderboards?: number, _options?: Configuration): Observable<GameCenterGroupResponse> {
        return this.gameCenterGroupsGetInstanceWithHttpInfo(id, fieldsGameCenterGroups, include, fieldsGameCenterLeaderboardSets, fieldsGameCenterDetails, fieldsGameCenterLeaderboards, fieldsGameCenterAchievements, limitGameCenterAchievements, limitGameCenterDetails, limitGameCenterLeaderboardSets, limitGameCenterLeaderboards, _options).pipe(map((apiResponse: HttpInfo<GameCenterGroupResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterGroupUpdateRequest GameCenterGroup representation
     */
    public gameCenterGroupsUpdateInstanceWithHttpInfo(id: string, gameCenterGroupUpdateRequest: GameCenterGroupUpdateRequest, _options?: Configuration): Observable<HttpInfo<GameCenterGroupResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterGroupsUpdateInstance(id, gameCenterGroupUpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterGroupsUpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterGroupUpdateRequest GameCenterGroup representation
     */
    public gameCenterGroupsUpdateInstance(id: string, gameCenterGroupUpdateRequest: GameCenterGroupUpdateRequest, _options?: Configuration): Observable<GameCenterGroupResponse> {
        return this.gameCenterGroupsUpdateInstanceWithHttpInfo(id, gameCenterGroupUpdateRequest, _options).pipe(map((apiResponse: HttpInfo<GameCenterGroupResponse>) => apiResponse.data));
    }

}

import { GameCenterLeaderboardEntrySubmissionsApiRequestFactory, GameCenterLeaderboardEntrySubmissionsApiResponseProcessor} from "../apis/GameCenterLeaderboardEntrySubmissionsApi.ts";
export class ObservableGameCenterLeaderboardEntrySubmissionsApi {
    private requestFactory: GameCenterLeaderboardEntrySubmissionsApiRequestFactory;
    private responseProcessor: GameCenterLeaderboardEntrySubmissionsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: GameCenterLeaderboardEntrySubmissionsApiRequestFactory,
        responseProcessor?: GameCenterLeaderboardEntrySubmissionsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new GameCenterLeaderboardEntrySubmissionsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new GameCenterLeaderboardEntrySubmissionsApiResponseProcessor();
    }

    /**
     * @param gameCenterLeaderboardEntrySubmissionCreateRequest GameCenterLeaderboardEntrySubmission representation
     */
    public gameCenterLeaderboardEntrySubmissionsCreateInstanceWithHttpInfo(gameCenterLeaderboardEntrySubmissionCreateRequest: GameCenterLeaderboardEntrySubmissionCreateRequest, _options?: Configuration): Observable<HttpInfo<GameCenterLeaderboardEntrySubmissionResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterLeaderboardEntrySubmissionsCreateInstance(gameCenterLeaderboardEntrySubmissionCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterLeaderboardEntrySubmissionsCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param gameCenterLeaderboardEntrySubmissionCreateRequest GameCenterLeaderboardEntrySubmission representation
     */
    public gameCenterLeaderboardEntrySubmissionsCreateInstance(gameCenterLeaderboardEntrySubmissionCreateRequest: GameCenterLeaderboardEntrySubmissionCreateRequest, _options?: Configuration): Observable<GameCenterLeaderboardEntrySubmissionResponse> {
        return this.gameCenterLeaderboardEntrySubmissionsCreateInstanceWithHttpInfo(gameCenterLeaderboardEntrySubmissionCreateRequest, _options).pipe(map((apiResponse: HttpInfo<GameCenterLeaderboardEntrySubmissionResponse>) => apiResponse.data));
    }

}

import { GameCenterLeaderboardImagesApiRequestFactory, GameCenterLeaderboardImagesApiResponseProcessor} from "../apis/GameCenterLeaderboardImagesApi.ts";
export class ObservableGameCenterLeaderboardImagesApi {
    private requestFactory: GameCenterLeaderboardImagesApiRequestFactory;
    private responseProcessor: GameCenterLeaderboardImagesApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: GameCenterLeaderboardImagesApiRequestFactory,
        responseProcessor?: GameCenterLeaderboardImagesApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new GameCenterLeaderboardImagesApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new GameCenterLeaderboardImagesApiResponseProcessor();
    }

    /**
     * @param gameCenterLeaderboardImageCreateRequest GameCenterLeaderboardImage representation
     */
    public gameCenterLeaderboardImagesCreateInstanceWithHttpInfo(gameCenterLeaderboardImageCreateRequest: GameCenterLeaderboardImageCreateRequest, _options?: Configuration): Observable<HttpInfo<GameCenterLeaderboardImageResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterLeaderboardImagesCreateInstance(gameCenterLeaderboardImageCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterLeaderboardImagesCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param gameCenterLeaderboardImageCreateRequest GameCenterLeaderboardImage representation
     */
    public gameCenterLeaderboardImagesCreateInstance(gameCenterLeaderboardImageCreateRequest: GameCenterLeaderboardImageCreateRequest, _options?: Configuration): Observable<GameCenterLeaderboardImageResponse> {
        return this.gameCenterLeaderboardImagesCreateInstanceWithHttpInfo(gameCenterLeaderboardImageCreateRequest, _options).pipe(map((apiResponse: HttpInfo<GameCenterLeaderboardImageResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterLeaderboardImagesDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.gameCenterLeaderboardImagesDeleteInstance(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterLeaderboardImagesDeleteInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterLeaderboardImagesDeleteInstance(id: string, _options?: Configuration): Observable<void> {
        return this.gameCenterLeaderboardImagesDeleteInstanceWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterLeaderboardImages the fields to include for returned resources of type gameCenterLeaderboardImages
     * @param include comma-separated list of relationships to include
     */
    public gameCenterLeaderboardImagesGetInstanceWithHttpInfo(id: string, fieldsGameCenterLeaderboardImages?: Array<'assetDeliveryState' | 'fileName' | 'fileSize' | 'gameCenterLeaderboardLocalization' | 'imageAsset' | 'uploadOperations' | 'uploaded'>, include?: Array<'gameCenterLeaderboardLocalization'>, _options?: Configuration): Observable<HttpInfo<GameCenterLeaderboardImageResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterLeaderboardImagesGetInstance(id, fieldsGameCenterLeaderboardImages, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterLeaderboardImagesGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterLeaderboardImages the fields to include for returned resources of type gameCenterLeaderboardImages
     * @param include comma-separated list of relationships to include
     */
    public gameCenterLeaderboardImagesGetInstance(id: string, fieldsGameCenterLeaderboardImages?: Array<'assetDeliveryState' | 'fileName' | 'fileSize' | 'gameCenterLeaderboardLocalization' | 'imageAsset' | 'uploadOperations' | 'uploaded'>, include?: Array<'gameCenterLeaderboardLocalization'>, _options?: Configuration): Observable<GameCenterLeaderboardImageResponse> {
        return this.gameCenterLeaderboardImagesGetInstanceWithHttpInfo(id, fieldsGameCenterLeaderboardImages, include, _options).pipe(map((apiResponse: HttpInfo<GameCenterLeaderboardImageResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterLeaderboardImageUpdateRequest GameCenterLeaderboardImage representation
     */
    public gameCenterLeaderboardImagesUpdateInstanceWithHttpInfo(id: string, gameCenterLeaderboardImageUpdateRequest: GameCenterLeaderboardImageUpdateRequest, _options?: Configuration): Observable<HttpInfo<GameCenterLeaderboardImageResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterLeaderboardImagesUpdateInstance(id, gameCenterLeaderboardImageUpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterLeaderboardImagesUpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterLeaderboardImageUpdateRequest GameCenterLeaderboardImage representation
     */
    public gameCenterLeaderboardImagesUpdateInstance(id: string, gameCenterLeaderboardImageUpdateRequest: GameCenterLeaderboardImageUpdateRequest, _options?: Configuration): Observable<GameCenterLeaderboardImageResponse> {
        return this.gameCenterLeaderboardImagesUpdateInstanceWithHttpInfo(id, gameCenterLeaderboardImageUpdateRequest, _options).pipe(map((apiResponse: HttpInfo<GameCenterLeaderboardImageResponse>) => apiResponse.data));
    }

}

import { GameCenterLeaderboardLocalizationsApiRequestFactory, GameCenterLeaderboardLocalizationsApiResponseProcessor} from "../apis/GameCenterLeaderboardLocalizationsApi.ts";
export class ObservableGameCenterLeaderboardLocalizationsApi {
    private requestFactory: GameCenterLeaderboardLocalizationsApiRequestFactory;
    private responseProcessor: GameCenterLeaderboardLocalizationsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: GameCenterLeaderboardLocalizationsApiRequestFactory,
        responseProcessor?: GameCenterLeaderboardLocalizationsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new GameCenterLeaderboardLocalizationsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new GameCenterLeaderboardLocalizationsApiResponseProcessor();
    }

    /**
     * @param gameCenterLeaderboardLocalizationCreateRequest GameCenterLeaderboardLocalization representation
     */
    public gameCenterLeaderboardLocalizationsCreateInstanceWithHttpInfo(gameCenterLeaderboardLocalizationCreateRequest: GameCenterLeaderboardLocalizationCreateRequest, _options?: Configuration): Observable<HttpInfo<GameCenterLeaderboardLocalizationResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterLeaderboardLocalizationsCreateInstance(gameCenterLeaderboardLocalizationCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterLeaderboardLocalizationsCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param gameCenterLeaderboardLocalizationCreateRequest GameCenterLeaderboardLocalization representation
     */
    public gameCenterLeaderboardLocalizationsCreateInstance(gameCenterLeaderboardLocalizationCreateRequest: GameCenterLeaderboardLocalizationCreateRequest, _options?: Configuration): Observable<GameCenterLeaderboardLocalizationResponse> {
        return this.gameCenterLeaderboardLocalizationsCreateInstanceWithHttpInfo(gameCenterLeaderboardLocalizationCreateRequest, _options).pipe(map((apiResponse: HttpInfo<GameCenterLeaderboardLocalizationResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterLeaderboardLocalizationsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.gameCenterLeaderboardLocalizationsDeleteInstance(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterLeaderboardLocalizationsDeleteInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterLeaderboardLocalizationsDeleteInstance(id: string, _options?: Configuration): Observable<void> {
        return this.gameCenterLeaderboardLocalizationsDeleteInstanceWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterLeaderboardImages the fields to include for returned resources of type gameCenterLeaderboardImages
     * @param fieldsGameCenterLeaderboardLocalizations the fields to include for returned resources of type gameCenterLeaderboardLocalizations
     * @param include comma-separated list of relationships to include
     */
    public gameCenterLeaderboardLocalizationsGameCenterLeaderboardImageGetToOneRelatedWithHttpInfo(id: string, fieldsGameCenterLeaderboardImages?: Array<'assetDeliveryState' | 'fileName' | 'fileSize' | 'gameCenterLeaderboardLocalization' | 'imageAsset' | 'uploadOperations' | 'uploaded'>, fieldsGameCenterLeaderboardLocalizations?: Array<'formatterOverride' | 'formatterSuffix' | 'formatterSuffixSingular' | 'gameCenterLeaderboard' | 'gameCenterLeaderboardImage' | 'locale' | 'name'>, include?: Array<'gameCenterLeaderboardLocalization'>, _options?: Configuration): Observable<HttpInfo<GameCenterLeaderboardImageResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterLeaderboardLocalizationsGameCenterLeaderboardImageGetToOneRelated(id, fieldsGameCenterLeaderboardImages, fieldsGameCenterLeaderboardLocalizations, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterLeaderboardLocalizationsGameCenterLeaderboardImageGetToOneRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterLeaderboardImages the fields to include for returned resources of type gameCenterLeaderboardImages
     * @param fieldsGameCenterLeaderboardLocalizations the fields to include for returned resources of type gameCenterLeaderboardLocalizations
     * @param include comma-separated list of relationships to include
     */
    public gameCenterLeaderboardLocalizationsGameCenterLeaderboardImageGetToOneRelated(id: string, fieldsGameCenterLeaderboardImages?: Array<'assetDeliveryState' | 'fileName' | 'fileSize' | 'gameCenterLeaderboardLocalization' | 'imageAsset' | 'uploadOperations' | 'uploaded'>, fieldsGameCenterLeaderboardLocalizations?: Array<'formatterOverride' | 'formatterSuffix' | 'formatterSuffixSingular' | 'gameCenterLeaderboard' | 'gameCenterLeaderboardImage' | 'locale' | 'name'>, include?: Array<'gameCenterLeaderboardLocalization'>, _options?: Configuration): Observable<GameCenterLeaderboardImageResponse> {
        return this.gameCenterLeaderboardLocalizationsGameCenterLeaderboardImageGetToOneRelatedWithHttpInfo(id, fieldsGameCenterLeaderboardImages, fieldsGameCenterLeaderboardLocalizations, include, _options).pipe(map((apiResponse: HttpInfo<GameCenterLeaderboardImageResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterLeaderboardLocalizations the fields to include for returned resources of type gameCenterLeaderboardLocalizations
     * @param include comma-separated list of relationships to include
     * @param fieldsGameCenterLeaderboardImages the fields to include for returned resources of type gameCenterLeaderboardImages
     */
    public gameCenterLeaderboardLocalizationsGetInstanceWithHttpInfo(id: string, fieldsGameCenterLeaderboardLocalizations?: Array<'formatterOverride' | 'formatterSuffix' | 'formatterSuffixSingular' | 'gameCenterLeaderboard' | 'gameCenterLeaderboardImage' | 'locale' | 'name'>, include?: Array<'gameCenterLeaderboard' | 'gameCenterLeaderboardImage'>, fieldsGameCenterLeaderboardImages?: Array<'assetDeliveryState' | 'fileName' | 'fileSize' | 'gameCenterLeaderboardLocalization' | 'imageAsset' | 'uploadOperations' | 'uploaded'>, _options?: Configuration): Observable<HttpInfo<GameCenterLeaderboardLocalizationResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterLeaderboardLocalizationsGetInstance(id, fieldsGameCenterLeaderboardLocalizations, include, fieldsGameCenterLeaderboardImages, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterLeaderboardLocalizationsGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterLeaderboardLocalizations the fields to include for returned resources of type gameCenterLeaderboardLocalizations
     * @param include comma-separated list of relationships to include
     * @param fieldsGameCenterLeaderboardImages the fields to include for returned resources of type gameCenterLeaderboardImages
     */
    public gameCenterLeaderboardLocalizationsGetInstance(id: string, fieldsGameCenterLeaderboardLocalizations?: Array<'formatterOverride' | 'formatterSuffix' | 'formatterSuffixSingular' | 'gameCenterLeaderboard' | 'gameCenterLeaderboardImage' | 'locale' | 'name'>, include?: Array<'gameCenterLeaderboard' | 'gameCenterLeaderboardImage'>, fieldsGameCenterLeaderboardImages?: Array<'assetDeliveryState' | 'fileName' | 'fileSize' | 'gameCenterLeaderboardLocalization' | 'imageAsset' | 'uploadOperations' | 'uploaded'>, _options?: Configuration): Observable<GameCenterLeaderboardLocalizationResponse> {
        return this.gameCenterLeaderboardLocalizationsGetInstanceWithHttpInfo(id, fieldsGameCenterLeaderboardLocalizations, include, fieldsGameCenterLeaderboardImages, _options).pipe(map((apiResponse: HttpInfo<GameCenterLeaderboardLocalizationResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterLeaderboardLocalizationUpdateRequest GameCenterLeaderboardLocalization representation
     */
    public gameCenterLeaderboardLocalizationsUpdateInstanceWithHttpInfo(id: string, gameCenterLeaderboardLocalizationUpdateRequest: GameCenterLeaderboardLocalizationUpdateRequest, _options?: Configuration): Observable<HttpInfo<GameCenterLeaderboardLocalizationResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterLeaderboardLocalizationsUpdateInstance(id, gameCenterLeaderboardLocalizationUpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterLeaderboardLocalizationsUpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterLeaderboardLocalizationUpdateRequest GameCenterLeaderboardLocalization representation
     */
    public gameCenterLeaderboardLocalizationsUpdateInstance(id: string, gameCenterLeaderboardLocalizationUpdateRequest: GameCenterLeaderboardLocalizationUpdateRequest, _options?: Configuration): Observable<GameCenterLeaderboardLocalizationResponse> {
        return this.gameCenterLeaderboardLocalizationsUpdateInstanceWithHttpInfo(id, gameCenterLeaderboardLocalizationUpdateRequest, _options).pipe(map((apiResponse: HttpInfo<GameCenterLeaderboardLocalizationResponse>) => apiResponse.data));
    }

}

import { GameCenterLeaderboardReleasesApiRequestFactory, GameCenterLeaderboardReleasesApiResponseProcessor} from "../apis/GameCenterLeaderboardReleasesApi.ts";
export class ObservableGameCenterLeaderboardReleasesApi {
    private requestFactory: GameCenterLeaderboardReleasesApiRequestFactory;
    private responseProcessor: GameCenterLeaderboardReleasesApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: GameCenterLeaderboardReleasesApiRequestFactory,
        responseProcessor?: GameCenterLeaderboardReleasesApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new GameCenterLeaderboardReleasesApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new GameCenterLeaderboardReleasesApiResponseProcessor();
    }

    /**
     * @param gameCenterLeaderboardReleaseCreateRequest GameCenterLeaderboardRelease representation
     */
    public gameCenterLeaderboardReleasesCreateInstanceWithHttpInfo(gameCenterLeaderboardReleaseCreateRequest: GameCenterLeaderboardReleaseCreateRequest, _options?: Configuration): Observable<HttpInfo<GameCenterLeaderboardReleaseResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterLeaderboardReleasesCreateInstance(gameCenterLeaderboardReleaseCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterLeaderboardReleasesCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param gameCenterLeaderboardReleaseCreateRequest GameCenterLeaderboardRelease representation
     */
    public gameCenterLeaderboardReleasesCreateInstance(gameCenterLeaderboardReleaseCreateRequest: GameCenterLeaderboardReleaseCreateRequest, _options?: Configuration): Observable<GameCenterLeaderboardReleaseResponse> {
        return this.gameCenterLeaderboardReleasesCreateInstanceWithHttpInfo(gameCenterLeaderboardReleaseCreateRequest, _options).pipe(map((apiResponse: HttpInfo<GameCenterLeaderboardReleaseResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterLeaderboardReleasesDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.gameCenterLeaderboardReleasesDeleteInstance(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterLeaderboardReleasesDeleteInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterLeaderboardReleasesDeleteInstance(id: string, _options?: Configuration): Observable<void> {
        return this.gameCenterLeaderboardReleasesDeleteInstanceWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterLeaderboardReleases the fields to include for returned resources of type gameCenterLeaderboardReleases
     * @param include comma-separated list of relationships to include
     */
    public gameCenterLeaderboardReleasesGetInstanceWithHttpInfo(id: string, fieldsGameCenterLeaderboardReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboard' | 'live'>, include?: Array<'gameCenterDetail' | 'gameCenterLeaderboard'>, _options?: Configuration): Observable<HttpInfo<GameCenterLeaderboardReleaseResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterLeaderboardReleasesGetInstance(id, fieldsGameCenterLeaderboardReleases, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterLeaderboardReleasesGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterLeaderboardReleases the fields to include for returned resources of type gameCenterLeaderboardReleases
     * @param include comma-separated list of relationships to include
     */
    public gameCenterLeaderboardReleasesGetInstance(id: string, fieldsGameCenterLeaderboardReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboard' | 'live'>, include?: Array<'gameCenterDetail' | 'gameCenterLeaderboard'>, _options?: Configuration): Observable<GameCenterLeaderboardReleaseResponse> {
        return this.gameCenterLeaderboardReleasesGetInstanceWithHttpInfo(id, fieldsGameCenterLeaderboardReleases, include, _options).pipe(map((apiResponse: HttpInfo<GameCenterLeaderboardReleaseResponse>) => apiResponse.data));
    }

}

import { GameCenterLeaderboardSetImagesApiRequestFactory, GameCenterLeaderboardSetImagesApiResponseProcessor} from "../apis/GameCenterLeaderboardSetImagesApi.ts";
export class ObservableGameCenterLeaderboardSetImagesApi {
    private requestFactory: GameCenterLeaderboardSetImagesApiRequestFactory;
    private responseProcessor: GameCenterLeaderboardSetImagesApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: GameCenterLeaderboardSetImagesApiRequestFactory,
        responseProcessor?: GameCenterLeaderboardSetImagesApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new GameCenterLeaderboardSetImagesApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new GameCenterLeaderboardSetImagesApiResponseProcessor();
    }

    /**
     * @param gameCenterLeaderboardSetImageCreateRequest GameCenterLeaderboardSetImage representation
     */
    public gameCenterLeaderboardSetImagesCreateInstanceWithHttpInfo(gameCenterLeaderboardSetImageCreateRequest: GameCenterLeaderboardSetImageCreateRequest, _options?: Configuration): Observable<HttpInfo<GameCenterLeaderboardSetImageResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterLeaderboardSetImagesCreateInstance(gameCenterLeaderboardSetImageCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterLeaderboardSetImagesCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param gameCenterLeaderboardSetImageCreateRequest GameCenterLeaderboardSetImage representation
     */
    public gameCenterLeaderboardSetImagesCreateInstance(gameCenterLeaderboardSetImageCreateRequest: GameCenterLeaderboardSetImageCreateRequest, _options?: Configuration): Observable<GameCenterLeaderboardSetImageResponse> {
        return this.gameCenterLeaderboardSetImagesCreateInstanceWithHttpInfo(gameCenterLeaderboardSetImageCreateRequest, _options).pipe(map((apiResponse: HttpInfo<GameCenterLeaderboardSetImageResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterLeaderboardSetImagesDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.gameCenterLeaderboardSetImagesDeleteInstance(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterLeaderboardSetImagesDeleteInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterLeaderboardSetImagesDeleteInstance(id: string, _options?: Configuration): Observable<void> {
        return this.gameCenterLeaderboardSetImagesDeleteInstanceWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterLeaderboardSetImages the fields to include for returned resources of type gameCenterLeaderboardSetImages
     * @param include comma-separated list of relationships to include
     */
    public gameCenterLeaderboardSetImagesGetInstanceWithHttpInfo(id: string, fieldsGameCenterLeaderboardSetImages?: Array<'assetDeliveryState' | 'fileName' | 'fileSize' | 'gameCenterLeaderboardSetLocalization' | 'imageAsset' | 'uploadOperations' | 'uploaded'>, include?: Array<'gameCenterLeaderboardSetLocalization'>, _options?: Configuration): Observable<HttpInfo<GameCenterLeaderboardSetImageResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterLeaderboardSetImagesGetInstance(id, fieldsGameCenterLeaderboardSetImages, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterLeaderboardSetImagesGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterLeaderboardSetImages the fields to include for returned resources of type gameCenterLeaderboardSetImages
     * @param include comma-separated list of relationships to include
     */
    public gameCenterLeaderboardSetImagesGetInstance(id: string, fieldsGameCenterLeaderboardSetImages?: Array<'assetDeliveryState' | 'fileName' | 'fileSize' | 'gameCenterLeaderboardSetLocalization' | 'imageAsset' | 'uploadOperations' | 'uploaded'>, include?: Array<'gameCenterLeaderboardSetLocalization'>, _options?: Configuration): Observable<GameCenterLeaderboardSetImageResponse> {
        return this.gameCenterLeaderboardSetImagesGetInstanceWithHttpInfo(id, fieldsGameCenterLeaderboardSetImages, include, _options).pipe(map((apiResponse: HttpInfo<GameCenterLeaderboardSetImageResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterLeaderboardSetImageUpdateRequest GameCenterLeaderboardSetImage representation
     */
    public gameCenterLeaderboardSetImagesUpdateInstanceWithHttpInfo(id: string, gameCenterLeaderboardSetImageUpdateRequest: GameCenterLeaderboardSetImageUpdateRequest, _options?: Configuration): Observable<HttpInfo<GameCenterLeaderboardSetImageResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterLeaderboardSetImagesUpdateInstance(id, gameCenterLeaderboardSetImageUpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterLeaderboardSetImagesUpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterLeaderboardSetImageUpdateRequest GameCenterLeaderboardSetImage representation
     */
    public gameCenterLeaderboardSetImagesUpdateInstance(id: string, gameCenterLeaderboardSetImageUpdateRequest: GameCenterLeaderboardSetImageUpdateRequest, _options?: Configuration): Observable<GameCenterLeaderboardSetImageResponse> {
        return this.gameCenterLeaderboardSetImagesUpdateInstanceWithHttpInfo(id, gameCenterLeaderboardSetImageUpdateRequest, _options).pipe(map((apiResponse: HttpInfo<GameCenterLeaderboardSetImageResponse>) => apiResponse.data));
    }

}

import { GameCenterLeaderboardSetLocalizationsApiRequestFactory, GameCenterLeaderboardSetLocalizationsApiResponseProcessor} from "../apis/GameCenterLeaderboardSetLocalizationsApi.ts";
export class ObservableGameCenterLeaderboardSetLocalizationsApi {
    private requestFactory: GameCenterLeaderboardSetLocalizationsApiRequestFactory;
    private responseProcessor: GameCenterLeaderboardSetLocalizationsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: GameCenterLeaderboardSetLocalizationsApiRequestFactory,
        responseProcessor?: GameCenterLeaderboardSetLocalizationsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new GameCenterLeaderboardSetLocalizationsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new GameCenterLeaderboardSetLocalizationsApiResponseProcessor();
    }

    /**
     * @param gameCenterLeaderboardSetLocalizationCreateRequest GameCenterLeaderboardSetLocalization representation
     */
    public gameCenterLeaderboardSetLocalizationsCreateInstanceWithHttpInfo(gameCenterLeaderboardSetLocalizationCreateRequest: GameCenterLeaderboardSetLocalizationCreateRequest, _options?: Configuration): Observable<HttpInfo<GameCenterLeaderboardSetLocalizationResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterLeaderboardSetLocalizationsCreateInstance(gameCenterLeaderboardSetLocalizationCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterLeaderboardSetLocalizationsCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param gameCenterLeaderboardSetLocalizationCreateRequest GameCenterLeaderboardSetLocalization representation
     */
    public gameCenterLeaderboardSetLocalizationsCreateInstance(gameCenterLeaderboardSetLocalizationCreateRequest: GameCenterLeaderboardSetLocalizationCreateRequest, _options?: Configuration): Observable<GameCenterLeaderboardSetLocalizationResponse> {
        return this.gameCenterLeaderboardSetLocalizationsCreateInstanceWithHttpInfo(gameCenterLeaderboardSetLocalizationCreateRequest, _options).pipe(map((apiResponse: HttpInfo<GameCenterLeaderboardSetLocalizationResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterLeaderboardSetLocalizationsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.gameCenterLeaderboardSetLocalizationsDeleteInstance(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterLeaderboardSetLocalizationsDeleteInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterLeaderboardSetLocalizationsDeleteInstance(id: string, _options?: Configuration): Observable<void> {
        return this.gameCenterLeaderboardSetLocalizationsDeleteInstanceWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterLeaderboardSetLocalizations the fields to include for returned resources of type gameCenterLeaderboardSetLocalizations
     * @param fieldsGameCenterLeaderboardSetImages the fields to include for returned resources of type gameCenterLeaderboardSetImages
     * @param include comma-separated list of relationships to include
     */
    public gameCenterLeaderboardSetLocalizationsGameCenterLeaderboardSetImageGetToOneRelatedWithHttpInfo(id: string, fieldsGameCenterLeaderboardSetLocalizations?: Array<'gameCenterLeaderboardSet' | 'gameCenterLeaderboardSetImage' | 'locale' | 'name'>, fieldsGameCenterLeaderboardSetImages?: Array<'assetDeliveryState' | 'fileName' | 'fileSize' | 'gameCenterLeaderboardSetLocalization' | 'imageAsset' | 'uploadOperations' | 'uploaded'>, include?: Array<'gameCenterLeaderboardSetLocalization'>, _options?: Configuration): Observable<HttpInfo<GameCenterLeaderboardSetImageResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterLeaderboardSetLocalizationsGameCenterLeaderboardSetImageGetToOneRelated(id, fieldsGameCenterLeaderboardSetLocalizations, fieldsGameCenterLeaderboardSetImages, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterLeaderboardSetLocalizationsGameCenterLeaderboardSetImageGetToOneRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterLeaderboardSetLocalizations the fields to include for returned resources of type gameCenterLeaderboardSetLocalizations
     * @param fieldsGameCenterLeaderboardSetImages the fields to include for returned resources of type gameCenterLeaderboardSetImages
     * @param include comma-separated list of relationships to include
     */
    public gameCenterLeaderboardSetLocalizationsGameCenterLeaderboardSetImageGetToOneRelated(id: string, fieldsGameCenterLeaderboardSetLocalizations?: Array<'gameCenterLeaderboardSet' | 'gameCenterLeaderboardSetImage' | 'locale' | 'name'>, fieldsGameCenterLeaderboardSetImages?: Array<'assetDeliveryState' | 'fileName' | 'fileSize' | 'gameCenterLeaderboardSetLocalization' | 'imageAsset' | 'uploadOperations' | 'uploaded'>, include?: Array<'gameCenterLeaderboardSetLocalization'>, _options?: Configuration): Observable<GameCenterLeaderboardSetImageResponse> {
        return this.gameCenterLeaderboardSetLocalizationsGameCenterLeaderboardSetImageGetToOneRelatedWithHttpInfo(id, fieldsGameCenterLeaderboardSetLocalizations, fieldsGameCenterLeaderboardSetImages, include, _options).pipe(map((apiResponse: HttpInfo<GameCenterLeaderboardSetImageResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterLeaderboardSetLocalizations the fields to include for returned resources of type gameCenterLeaderboardSetLocalizations
     * @param include comma-separated list of relationships to include
     * @param fieldsGameCenterLeaderboardSetImages the fields to include for returned resources of type gameCenterLeaderboardSetImages
     */
    public gameCenterLeaderboardSetLocalizationsGetInstanceWithHttpInfo(id: string, fieldsGameCenterLeaderboardSetLocalizations?: Array<'gameCenterLeaderboardSet' | 'gameCenterLeaderboardSetImage' | 'locale' | 'name'>, include?: Array<'gameCenterLeaderboardSet' | 'gameCenterLeaderboardSetImage'>, fieldsGameCenterLeaderboardSetImages?: Array<'assetDeliveryState' | 'fileName' | 'fileSize' | 'gameCenterLeaderboardSetLocalization' | 'imageAsset' | 'uploadOperations' | 'uploaded'>, _options?: Configuration): Observable<HttpInfo<GameCenterLeaderboardSetLocalizationResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterLeaderboardSetLocalizationsGetInstance(id, fieldsGameCenterLeaderboardSetLocalizations, include, fieldsGameCenterLeaderboardSetImages, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterLeaderboardSetLocalizationsGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterLeaderboardSetLocalizations the fields to include for returned resources of type gameCenterLeaderboardSetLocalizations
     * @param include comma-separated list of relationships to include
     * @param fieldsGameCenterLeaderboardSetImages the fields to include for returned resources of type gameCenterLeaderboardSetImages
     */
    public gameCenterLeaderboardSetLocalizationsGetInstance(id: string, fieldsGameCenterLeaderboardSetLocalizations?: Array<'gameCenterLeaderboardSet' | 'gameCenterLeaderboardSetImage' | 'locale' | 'name'>, include?: Array<'gameCenterLeaderboardSet' | 'gameCenterLeaderboardSetImage'>, fieldsGameCenterLeaderboardSetImages?: Array<'assetDeliveryState' | 'fileName' | 'fileSize' | 'gameCenterLeaderboardSetLocalization' | 'imageAsset' | 'uploadOperations' | 'uploaded'>, _options?: Configuration): Observable<GameCenterLeaderboardSetLocalizationResponse> {
        return this.gameCenterLeaderboardSetLocalizationsGetInstanceWithHttpInfo(id, fieldsGameCenterLeaderboardSetLocalizations, include, fieldsGameCenterLeaderboardSetImages, _options).pipe(map((apiResponse: HttpInfo<GameCenterLeaderboardSetLocalizationResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterLeaderboardSetLocalizationUpdateRequest GameCenterLeaderboardSetLocalization representation
     */
    public gameCenterLeaderboardSetLocalizationsUpdateInstanceWithHttpInfo(id: string, gameCenterLeaderboardSetLocalizationUpdateRequest: GameCenterLeaderboardSetLocalizationUpdateRequest, _options?: Configuration): Observable<HttpInfo<GameCenterLeaderboardSetLocalizationResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterLeaderboardSetLocalizationsUpdateInstance(id, gameCenterLeaderboardSetLocalizationUpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterLeaderboardSetLocalizationsUpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterLeaderboardSetLocalizationUpdateRequest GameCenterLeaderboardSetLocalization representation
     */
    public gameCenterLeaderboardSetLocalizationsUpdateInstance(id: string, gameCenterLeaderboardSetLocalizationUpdateRequest: GameCenterLeaderboardSetLocalizationUpdateRequest, _options?: Configuration): Observable<GameCenterLeaderboardSetLocalizationResponse> {
        return this.gameCenterLeaderboardSetLocalizationsUpdateInstanceWithHttpInfo(id, gameCenterLeaderboardSetLocalizationUpdateRequest, _options).pipe(map((apiResponse: HttpInfo<GameCenterLeaderboardSetLocalizationResponse>) => apiResponse.data));
    }

}

import { GameCenterLeaderboardSetMemberLocalizationsApiRequestFactory, GameCenterLeaderboardSetMemberLocalizationsApiResponseProcessor} from "../apis/GameCenterLeaderboardSetMemberLocalizationsApi.ts";
export class ObservableGameCenterLeaderboardSetMemberLocalizationsApi {
    private requestFactory: GameCenterLeaderboardSetMemberLocalizationsApiRequestFactory;
    private responseProcessor: GameCenterLeaderboardSetMemberLocalizationsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: GameCenterLeaderboardSetMemberLocalizationsApiRequestFactory,
        responseProcessor?: GameCenterLeaderboardSetMemberLocalizationsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new GameCenterLeaderboardSetMemberLocalizationsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new GameCenterLeaderboardSetMemberLocalizationsApiResponseProcessor();
    }

    /**
     * @param gameCenterLeaderboardSetMemberLocalizationCreateRequest GameCenterLeaderboardSetMemberLocalization representation
     */
    public gameCenterLeaderboardSetMemberLocalizationsCreateInstanceWithHttpInfo(gameCenterLeaderboardSetMemberLocalizationCreateRequest: GameCenterLeaderboardSetMemberLocalizationCreateRequest, _options?: Configuration): Observable<HttpInfo<GameCenterLeaderboardSetMemberLocalizationResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterLeaderboardSetMemberLocalizationsCreateInstance(gameCenterLeaderboardSetMemberLocalizationCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterLeaderboardSetMemberLocalizationsCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param gameCenterLeaderboardSetMemberLocalizationCreateRequest GameCenterLeaderboardSetMemberLocalization representation
     */
    public gameCenterLeaderboardSetMemberLocalizationsCreateInstance(gameCenterLeaderboardSetMemberLocalizationCreateRequest: GameCenterLeaderboardSetMemberLocalizationCreateRequest, _options?: Configuration): Observable<GameCenterLeaderboardSetMemberLocalizationResponse> {
        return this.gameCenterLeaderboardSetMemberLocalizationsCreateInstanceWithHttpInfo(gameCenterLeaderboardSetMemberLocalizationCreateRequest, _options).pipe(map((apiResponse: HttpInfo<GameCenterLeaderboardSetMemberLocalizationResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterLeaderboardSetMemberLocalizationsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.gameCenterLeaderboardSetMemberLocalizationsDeleteInstance(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterLeaderboardSetMemberLocalizationsDeleteInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterLeaderboardSetMemberLocalizationsDeleteInstance(id: string, _options?: Configuration): Observable<void> {
        return this.gameCenterLeaderboardSetMemberLocalizationsDeleteInstanceWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterLeaderboardLocalizations the fields to include for returned resources of type gameCenterLeaderboardLocalizations
     * @param fieldsGameCenterLeaderboardSets the fields to include for returned resources of type gameCenterLeaderboardSets
     * @param fieldsGameCenterGroups the fields to include for returned resources of type gameCenterGroups
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     * @param fieldsGameCenterLeaderboardReleases the fields to include for returned resources of type gameCenterLeaderboardReleases
     * @param limitGameCenterLeaderboardSets maximum number of related gameCenterLeaderboardSets returned (when they are included)
     * @param limitLocalizations maximum number of related localizations returned (when they are included)
     * @param limitReleases maximum number of related releases returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public gameCenterLeaderboardSetMemberLocalizationsGameCenterLeaderboardGetToOneRelatedWithHttpInfo(id: string, fieldsGameCenterLeaderboardLocalizations?: Array<'formatterOverride' | 'formatterSuffix' | 'formatterSuffixSingular' | 'gameCenterLeaderboard' | 'gameCenterLeaderboardImage' | 'locale' | 'name'>, fieldsGameCenterLeaderboardSets?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'referenceName' | 'releases' | 'vendorIdentifier'>, fieldsGameCenterGroups?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'referenceName'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, fieldsGameCenterLeaderboardReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboard' | 'live'>, limitGameCenterLeaderboardSets?: number, limitLocalizations?: number, limitReleases?: number, include?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'releases'>, _options?: Configuration): Observable<HttpInfo<GameCenterLeaderboardResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterLeaderboardSetMemberLocalizationsGameCenterLeaderboardGetToOneRelated(id, fieldsGameCenterLeaderboardLocalizations, fieldsGameCenterLeaderboardSets, fieldsGameCenterGroups, fieldsGameCenterDetails, fieldsGameCenterLeaderboards, fieldsGameCenterLeaderboardReleases, limitGameCenterLeaderboardSets, limitLocalizations, limitReleases, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterLeaderboardSetMemberLocalizationsGameCenterLeaderboardGetToOneRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterLeaderboardLocalizations the fields to include for returned resources of type gameCenterLeaderboardLocalizations
     * @param fieldsGameCenterLeaderboardSets the fields to include for returned resources of type gameCenterLeaderboardSets
     * @param fieldsGameCenterGroups the fields to include for returned resources of type gameCenterGroups
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     * @param fieldsGameCenterLeaderboardReleases the fields to include for returned resources of type gameCenterLeaderboardReleases
     * @param limitGameCenterLeaderboardSets maximum number of related gameCenterLeaderboardSets returned (when they are included)
     * @param limitLocalizations maximum number of related localizations returned (when they are included)
     * @param limitReleases maximum number of related releases returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public gameCenterLeaderboardSetMemberLocalizationsGameCenterLeaderboardGetToOneRelated(id: string, fieldsGameCenterLeaderboardLocalizations?: Array<'formatterOverride' | 'formatterSuffix' | 'formatterSuffixSingular' | 'gameCenterLeaderboard' | 'gameCenterLeaderboardImage' | 'locale' | 'name'>, fieldsGameCenterLeaderboardSets?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'referenceName' | 'releases' | 'vendorIdentifier'>, fieldsGameCenterGroups?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'referenceName'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, fieldsGameCenterLeaderboardReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboard' | 'live'>, limitGameCenterLeaderboardSets?: number, limitLocalizations?: number, limitReleases?: number, include?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'releases'>, _options?: Configuration): Observable<GameCenterLeaderboardResponse> {
        return this.gameCenterLeaderboardSetMemberLocalizationsGameCenterLeaderboardGetToOneRelatedWithHttpInfo(id, fieldsGameCenterLeaderboardLocalizations, fieldsGameCenterLeaderboardSets, fieldsGameCenterGroups, fieldsGameCenterDetails, fieldsGameCenterLeaderboards, fieldsGameCenterLeaderboardReleases, limitGameCenterLeaderboardSets, limitLocalizations, limitReleases, include, _options).pipe(map((apiResponse: HttpInfo<GameCenterLeaderboardResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterLeaderboardSetLocalizations the fields to include for returned resources of type gameCenterLeaderboardSetLocalizations
     * @param fieldsGameCenterLeaderboardSetReleases the fields to include for returned resources of type gameCenterLeaderboardSetReleases
     * @param fieldsGameCenterLeaderboardSets the fields to include for returned resources of type gameCenterLeaderboardSets
     * @param fieldsGameCenterGroups the fields to include for returned resources of type gameCenterGroups
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     * @param limitLocalizations maximum number of related localizations returned (when they are included)
     * @param limitGameCenterLeaderboards maximum number of related gameCenterLeaderboards returned (when they are included)
     * @param limitReleases maximum number of related releases returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public gameCenterLeaderboardSetMemberLocalizationsGameCenterLeaderboardSetGetToOneRelatedWithHttpInfo(id: string, fieldsGameCenterLeaderboardSetLocalizations?: Array<'gameCenterLeaderboardSet' | 'gameCenterLeaderboardSetImage' | 'locale' | 'name'>, fieldsGameCenterLeaderboardSetReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboardSet' | 'live'>, fieldsGameCenterLeaderboardSets?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'referenceName' | 'releases' | 'vendorIdentifier'>, fieldsGameCenterGroups?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'referenceName'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, limitLocalizations?: number, limitGameCenterLeaderboards?: number, limitReleases?: number, include?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'releases'>, _options?: Configuration): Observable<HttpInfo<GameCenterLeaderboardSetResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterLeaderboardSetMemberLocalizationsGameCenterLeaderboardSetGetToOneRelated(id, fieldsGameCenterLeaderboardSetLocalizations, fieldsGameCenterLeaderboardSetReleases, fieldsGameCenterLeaderboardSets, fieldsGameCenterGroups, fieldsGameCenterDetails, fieldsGameCenterLeaderboards, limitLocalizations, limitGameCenterLeaderboards, limitReleases, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterLeaderboardSetMemberLocalizationsGameCenterLeaderboardSetGetToOneRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterLeaderboardSetLocalizations the fields to include for returned resources of type gameCenterLeaderboardSetLocalizations
     * @param fieldsGameCenterLeaderboardSetReleases the fields to include for returned resources of type gameCenterLeaderboardSetReleases
     * @param fieldsGameCenterLeaderboardSets the fields to include for returned resources of type gameCenterLeaderboardSets
     * @param fieldsGameCenterGroups the fields to include for returned resources of type gameCenterGroups
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     * @param limitLocalizations maximum number of related localizations returned (when they are included)
     * @param limitGameCenterLeaderboards maximum number of related gameCenterLeaderboards returned (when they are included)
     * @param limitReleases maximum number of related releases returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public gameCenterLeaderboardSetMemberLocalizationsGameCenterLeaderboardSetGetToOneRelated(id: string, fieldsGameCenterLeaderboardSetLocalizations?: Array<'gameCenterLeaderboardSet' | 'gameCenterLeaderboardSetImage' | 'locale' | 'name'>, fieldsGameCenterLeaderboardSetReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboardSet' | 'live'>, fieldsGameCenterLeaderboardSets?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'referenceName' | 'releases' | 'vendorIdentifier'>, fieldsGameCenterGroups?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'referenceName'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, limitLocalizations?: number, limitGameCenterLeaderboards?: number, limitReleases?: number, include?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'releases'>, _options?: Configuration): Observable<GameCenterLeaderboardSetResponse> {
        return this.gameCenterLeaderboardSetMemberLocalizationsGameCenterLeaderboardSetGetToOneRelatedWithHttpInfo(id, fieldsGameCenterLeaderboardSetLocalizations, fieldsGameCenterLeaderboardSetReleases, fieldsGameCenterLeaderboardSets, fieldsGameCenterGroups, fieldsGameCenterDetails, fieldsGameCenterLeaderboards, limitLocalizations, limitGameCenterLeaderboards, limitReleases, include, _options).pipe(map((apiResponse: HttpInfo<GameCenterLeaderboardSetResponse>) => apiResponse.data));
    }

    /**
     * @param filterGameCenterLeaderboard filter by id(s) of related \&#39;gameCenterLeaderboard\&#39;
     * @param filterGameCenterLeaderboardSet filter by id(s) of related \&#39;gameCenterLeaderboardSet\&#39;
     * @param fieldsGameCenterLeaderboardSetMemberLocalizations the fields to include for returned resources of type gameCenterLeaderboardSetMemberLocalizations
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsGameCenterLeaderboardSets the fields to include for returned resources of type gameCenterLeaderboardSets
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     */
    public gameCenterLeaderboardSetMemberLocalizationsGetCollectionWithHttpInfo(filterGameCenterLeaderboard: Array<string>, filterGameCenterLeaderboardSet: Array<string>, fieldsGameCenterLeaderboardSetMemberLocalizations?: Array<'gameCenterLeaderboard' | 'gameCenterLeaderboardSet' | 'locale' | 'name'>, limit?: number, include?: Array<'gameCenterLeaderboard' | 'gameCenterLeaderboardSet'>, fieldsGameCenterLeaderboardSets?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'referenceName' | 'releases' | 'vendorIdentifier'>, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, _options?: Configuration): Observable<HttpInfo<GameCenterLeaderboardSetMemberLocalizationsResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterLeaderboardSetMemberLocalizationsGetCollection(filterGameCenterLeaderboard, filterGameCenterLeaderboardSet, fieldsGameCenterLeaderboardSetMemberLocalizations, limit, include, fieldsGameCenterLeaderboardSets, fieldsGameCenterLeaderboards, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterLeaderboardSetMemberLocalizationsGetCollectionWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param filterGameCenterLeaderboard filter by id(s) of related \&#39;gameCenterLeaderboard\&#39;
     * @param filterGameCenterLeaderboardSet filter by id(s) of related \&#39;gameCenterLeaderboardSet\&#39;
     * @param fieldsGameCenterLeaderboardSetMemberLocalizations the fields to include for returned resources of type gameCenterLeaderboardSetMemberLocalizations
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsGameCenterLeaderboardSets the fields to include for returned resources of type gameCenterLeaderboardSets
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     */
    public gameCenterLeaderboardSetMemberLocalizationsGetCollection(filterGameCenterLeaderboard: Array<string>, filterGameCenterLeaderboardSet: Array<string>, fieldsGameCenterLeaderboardSetMemberLocalizations?: Array<'gameCenterLeaderboard' | 'gameCenterLeaderboardSet' | 'locale' | 'name'>, limit?: number, include?: Array<'gameCenterLeaderboard' | 'gameCenterLeaderboardSet'>, fieldsGameCenterLeaderboardSets?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'referenceName' | 'releases' | 'vendorIdentifier'>, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, _options?: Configuration): Observable<GameCenterLeaderboardSetMemberLocalizationsResponse> {
        return this.gameCenterLeaderboardSetMemberLocalizationsGetCollectionWithHttpInfo(filterGameCenterLeaderboard, filterGameCenterLeaderboardSet, fieldsGameCenterLeaderboardSetMemberLocalizations, limit, include, fieldsGameCenterLeaderboardSets, fieldsGameCenterLeaderboards, _options).pipe(map((apiResponse: HttpInfo<GameCenterLeaderboardSetMemberLocalizationsResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterLeaderboardSetMemberLocalizationUpdateRequest GameCenterLeaderboardSetMemberLocalization representation
     */
    public gameCenterLeaderboardSetMemberLocalizationsUpdateInstanceWithHttpInfo(id: string, gameCenterLeaderboardSetMemberLocalizationUpdateRequest: GameCenterLeaderboardSetMemberLocalizationUpdateRequest, _options?: Configuration): Observable<HttpInfo<GameCenterLeaderboardSetMemberLocalizationResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterLeaderboardSetMemberLocalizationsUpdateInstance(id, gameCenterLeaderboardSetMemberLocalizationUpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterLeaderboardSetMemberLocalizationsUpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterLeaderboardSetMemberLocalizationUpdateRequest GameCenterLeaderboardSetMemberLocalization representation
     */
    public gameCenterLeaderboardSetMemberLocalizationsUpdateInstance(id: string, gameCenterLeaderboardSetMemberLocalizationUpdateRequest: GameCenterLeaderboardSetMemberLocalizationUpdateRequest, _options?: Configuration): Observable<GameCenterLeaderboardSetMemberLocalizationResponse> {
        return this.gameCenterLeaderboardSetMemberLocalizationsUpdateInstanceWithHttpInfo(id, gameCenterLeaderboardSetMemberLocalizationUpdateRequest, _options).pipe(map((apiResponse: HttpInfo<GameCenterLeaderboardSetMemberLocalizationResponse>) => apiResponse.data));
    }

}

import { GameCenterLeaderboardSetReleasesApiRequestFactory, GameCenterLeaderboardSetReleasesApiResponseProcessor} from "../apis/GameCenterLeaderboardSetReleasesApi.ts";
export class ObservableGameCenterLeaderboardSetReleasesApi {
    private requestFactory: GameCenterLeaderboardSetReleasesApiRequestFactory;
    private responseProcessor: GameCenterLeaderboardSetReleasesApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: GameCenterLeaderboardSetReleasesApiRequestFactory,
        responseProcessor?: GameCenterLeaderboardSetReleasesApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new GameCenterLeaderboardSetReleasesApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new GameCenterLeaderboardSetReleasesApiResponseProcessor();
    }

    /**
     * @param gameCenterLeaderboardSetReleaseCreateRequest GameCenterLeaderboardSetRelease representation
     */
    public gameCenterLeaderboardSetReleasesCreateInstanceWithHttpInfo(gameCenterLeaderboardSetReleaseCreateRequest: GameCenterLeaderboardSetReleaseCreateRequest, _options?: Configuration): Observable<HttpInfo<GameCenterLeaderboardSetReleaseResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterLeaderboardSetReleasesCreateInstance(gameCenterLeaderboardSetReleaseCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterLeaderboardSetReleasesCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param gameCenterLeaderboardSetReleaseCreateRequest GameCenterLeaderboardSetRelease representation
     */
    public gameCenterLeaderboardSetReleasesCreateInstance(gameCenterLeaderboardSetReleaseCreateRequest: GameCenterLeaderboardSetReleaseCreateRequest, _options?: Configuration): Observable<GameCenterLeaderboardSetReleaseResponse> {
        return this.gameCenterLeaderboardSetReleasesCreateInstanceWithHttpInfo(gameCenterLeaderboardSetReleaseCreateRequest, _options).pipe(map((apiResponse: HttpInfo<GameCenterLeaderboardSetReleaseResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterLeaderboardSetReleasesDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.gameCenterLeaderboardSetReleasesDeleteInstance(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterLeaderboardSetReleasesDeleteInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterLeaderboardSetReleasesDeleteInstance(id: string, _options?: Configuration): Observable<void> {
        return this.gameCenterLeaderboardSetReleasesDeleteInstanceWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterLeaderboardSetReleases the fields to include for returned resources of type gameCenterLeaderboardSetReleases
     * @param include comma-separated list of relationships to include
     */
    public gameCenterLeaderboardSetReleasesGetInstanceWithHttpInfo(id: string, fieldsGameCenterLeaderboardSetReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboardSet' | 'live'>, include?: Array<'gameCenterDetail' | 'gameCenterLeaderboardSet'>, _options?: Configuration): Observable<HttpInfo<GameCenterLeaderboardSetReleaseResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterLeaderboardSetReleasesGetInstance(id, fieldsGameCenterLeaderboardSetReleases, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterLeaderboardSetReleasesGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterLeaderboardSetReleases the fields to include for returned resources of type gameCenterLeaderboardSetReleases
     * @param include comma-separated list of relationships to include
     */
    public gameCenterLeaderboardSetReleasesGetInstance(id: string, fieldsGameCenterLeaderboardSetReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboardSet' | 'live'>, include?: Array<'gameCenterDetail' | 'gameCenterLeaderboardSet'>, _options?: Configuration): Observable<GameCenterLeaderboardSetReleaseResponse> {
        return this.gameCenterLeaderboardSetReleasesGetInstanceWithHttpInfo(id, fieldsGameCenterLeaderboardSetReleases, include, _options).pipe(map((apiResponse: HttpInfo<GameCenterLeaderboardSetReleaseResponse>) => apiResponse.data));
    }

}

import { GameCenterLeaderboardSetsApiRequestFactory, GameCenterLeaderboardSetsApiResponseProcessor} from "../apis/GameCenterLeaderboardSetsApi.ts";
export class ObservableGameCenterLeaderboardSetsApi {
    private requestFactory: GameCenterLeaderboardSetsApiRequestFactory;
    private responseProcessor: GameCenterLeaderboardSetsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: GameCenterLeaderboardSetsApiRequestFactory,
        responseProcessor?: GameCenterLeaderboardSetsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new GameCenterLeaderboardSetsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new GameCenterLeaderboardSetsApiResponseProcessor();
    }

    /**
     * @param gameCenterLeaderboardSetCreateRequest GameCenterLeaderboardSet representation
     */
    public gameCenterLeaderboardSetsCreateInstanceWithHttpInfo(gameCenterLeaderboardSetCreateRequest: GameCenterLeaderboardSetCreateRequest, _options?: Configuration): Observable<HttpInfo<GameCenterLeaderboardSetResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterLeaderboardSetsCreateInstance(gameCenterLeaderboardSetCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterLeaderboardSetsCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param gameCenterLeaderboardSetCreateRequest GameCenterLeaderboardSet representation
     */
    public gameCenterLeaderboardSetsCreateInstance(gameCenterLeaderboardSetCreateRequest: GameCenterLeaderboardSetCreateRequest, _options?: Configuration): Observable<GameCenterLeaderboardSetResponse> {
        return this.gameCenterLeaderboardSetsCreateInstanceWithHttpInfo(gameCenterLeaderboardSetCreateRequest, _options).pipe(map((apiResponse: HttpInfo<GameCenterLeaderboardSetResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterLeaderboardSetsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.gameCenterLeaderboardSetsDeleteInstance(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterLeaderboardSetsDeleteInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterLeaderboardSetsDeleteInstance(id: string, _options?: Configuration): Observable<void> {
        return this.gameCenterLeaderboardSetsDeleteInstanceWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterLeaderboardSetGameCenterLeaderboardsLinkagesRequest List of related linkages
     */
    public gameCenterLeaderboardSetsGameCenterLeaderboardsCreateToManyRelationshipWithHttpInfo(id: string, gameCenterLeaderboardSetGameCenterLeaderboardsLinkagesRequest: GameCenterLeaderboardSetGameCenterLeaderboardsLinkagesRequest, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.gameCenterLeaderboardSetsGameCenterLeaderboardsCreateToManyRelationship(id, gameCenterLeaderboardSetGameCenterLeaderboardsLinkagesRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterLeaderboardSetsGameCenterLeaderboardsCreateToManyRelationshipWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterLeaderboardSetGameCenterLeaderboardsLinkagesRequest List of related linkages
     */
    public gameCenterLeaderboardSetsGameCenterLeaderboardsCreateToManyRelationship(id: string, gameCenterLeaderboardSetGameCenterLeaderboardsLinkagesRequest: GameCenterLeaderboardSetGameCenterLeaderboardsLinkagesRequest, _options?: Configuration): Observable<void> {
        return this.gameCenterLeaderboardSetsGameCenterLeaderboardsCreateToManyRelationshipWithHttpInfo(id, gameCenterLeaderboardSetGameCenterLeaderboardsLinkagesRequest, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterLeaderboardSetGameCenterLeaderboardsLinkagesRequest List of related linkages
     */
    public gameCenterLeaderboardSetsGameCenterLeaderboardsDeleteToManyRelationshipWithHttpInfo(id: string, gameCenterLeaderboardSetGameCenterLeaderboardsLinkagesRequest: GameCenterLeaderboardSetGameCenterLeaderboardsLinkagesRequest, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.gameCenterLeaderboardSetsGameCenterLeaderboardsDeleteToManyRelationship(id, gameCenterLeaderboardSetGameCenterLeaderboardsLinkagesRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterLeaderboardSetsGameCenterLeaderboardsDeleteToManyRelationshipWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterLeaderboardSetGameCenterLeaderboardsLinkagesRequest List of related linkages
     */
    public gameCenterLeaderboardSetsGameCenterLeaderboardsDeleteToManyRelationship(id: string, gameCenterLeaderboardSetGameCenterLeaderboardsLinkagesRequest: GameCenterLeaderboardSetGameCenterLeaderboardsLinkagesRequest, _options?: Configuration): Observable<void> {
        return this.gameCenterLeaderboardSetsGameCenterLeaderboardsDeleteToManyRelationshipWithHttpInfo(id, gameCenterLeaderboardSetGameCenterLeaderboardsLinkagesRequest, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param filterArchived filter by attribute \&#39;archived\&#39;
     * @param filterReferenceName filter by attribute \&#39;referenceName\&#39;
     * @param filterId filter by id(s)
     * @param fieldsGameCenterLeaderboardLocalizations the fields to include for returned resources of type gameCenterLeaderboardLocalizations
     * @param fieldsGameCenterLeaderboardSets the fields to include for returned resources of type gameCenterLeaderboardSets
     * @param fieldsGameCenterGroups the fields to include for returned resources of type gameCenterGroups
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     * @param fieldsGameCenterLeaderboardReleases the fields to include for returned resources of type gameCenterLeaderboardReleases
     * @param limit maximum resources per page
     * @param limitGameCenterLeaderboardSets maximum number of related gameCenterLeaderboardSets returned (when they are included)
     * @param limitLocalizations maximum number of related localizations returned (when they are included)
     * @param limitReleases maximum number of related releases returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public gameCenterLeaderboardSetsGameCenterLeaderboardsGetToManyRelatedWithHttpInfo(id: string, filterArchived?: Array<string>, filterReferenceName?: Array<string>, filterId?: Array<string>, fieldsGameCenterLeaderboardLocalizations?: Array<'formatterOverride' | 'formatterSuffix' | 'formatterSuffixSingular' | 'gameCenterLeaderboard' | 'gameCenterLeaderboardImage' | 'locale' | 'name'>, fieldsGameCenterLeaderboardSets?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'referenceName' | 'releases' | 'vendorIdentifier'>, fieldsGameCenterGroups?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'referenceName'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, fieldsGameCenterLeaderboardReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboard' | 'live'>, limit?: number, limitGameCenterLeaderboardSets?: number, limitLocalizations?: number, limitReleases?: number, include?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'releases'>, _options?: Configuration): Observable<HttpInfo<GameCenterLeaderboardsResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterLeaderboardSetsGameCenterLeaderboardsGetToManyRelated(id, filterArchived, filterReferenceName, filterId, fieldsGameCenterLeaderboardLocalizations, fieldsGameCenterLeaderboardSets, fieldsGameCenterGroups, fieldsGameCenterDetails, fieldsGameCenterLeaderboards, fieldsGameCenterLeaderboardReleases, limit, limitGameCenterLeaderboardSets, limitLocalizations, limitReleases, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterLeaderboardSetsGameCenterLeaderboardsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param filterArchived filter by attribute \&#39;archived\&#39;
     * @param filterReferenceName filter by attribute \&#39;referenceName\&#39;
     * @param filterId filter by id(s)
     * @param fieldsGameCenterLeaderboardLocalizations the fields to include for returned resources of type gameCenterLeaderboardLocalizations
     * @param fieldsGameCenterLeaderboardSets the fields to include for returned resources of type gameCenterLeaderboardSets
     * @param fieldsGameCenterGroups the fields to include for returned resources of type gameCenterGroups
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     * @param fieldsGameCenterLeaderboardReleases the fields to include for returned resources of type gameCenterLeaderboardReleases
     * @param limit maximum resources per page
     * @param limitGameCenterLeaderboardSets maximum number of related gameCenterLeaderboardSets returned (when they are included)
     * @param limitLocalizations maximum number of related localizations returned (when they are included)
     * @param limitReleases maximum number of related releases returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public gameCenterLeaderboardSetsGameCenterLeaderboardsGetToManyRelated(id: string, filterArchived?: Array<string>, filterReferenceName?: Array<string>, filterId?: Array<string>, fieldsGameCenterLeaderboardLocalizations?: Array<'formatterOverride' | 'formatterSuffix' | 'formatterSuffixSingular' | 'gameCenterLeaderboard' | 'gameCenterLeaderboardImage' | 'locale' | 'name'>, fieldsGameCenterLeaderboardSets?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'referenceName' | 'releases' | 'vendorIdentifier'>, fieldsGameCenterGroups?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'referenceName'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, fieldsGameCenterLeaderboardReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboard' | 'live'>, limit?: number, limitGameCenterLeaderboardSets?: number, limitLocalizations?: number, limitReleases?: number, include?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'releases'>, _options?: Configuration): Observable<GameCenterLeaderboardsResponse> {
        return this.gameCenterLeaderboardSetsGameCenterLeaderboardsGetToManyRelatedWithHttpInfo(id, filterArchived, filterReferenceName, filterId, fieldsGameCenterLeaderboardLocalizations, fieldsGameCenterLeaderboardSets, fieldsGameCenterGroups, fieldsGameCenterDetails, fieldsGameCenterLeaderboards, fieldsGameCenterLeaderboardReleases, limit, limitGameCenterLeaderboardSets, limitLocalizations, limitReleases, include, _options).pipe(map((apiResponse: HttpInfo<GameCenterLeaderboardsResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public gameCenterLeaderboardSetsGameCenterLeaderboardsGetToManyRelationshipWithHttpInfo(id: string, limit?: number, _options?: Configuration): Observable<HttpInfo<GameCenterLeaderboardSetGameCenterLeaderboardsLinkagesResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterLeaderboardSetsGameCenterLeaderboardsGetToManyRelationship(id, limit, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterLeaderboardSetsGameCenterLeaderboardsGetToManyRelationshipWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public gameCenterLeaderboardSetsGameCenterLeaderboardsGetToManyRelationship(id: string, limit?: number, _options?: Configuration): Observable<GameCenterLeaderboardSetGameCenterLeaderboardsLinkagesResponse> {
        return this.gameCenterLeaderboardSetsGameCenterLeaderboardsGetToManyRelationshipWithHttpInfo(id, limit, _options).pipe(map((apiResponse: HttpInfo<GameCenterLeaderboardSetGameCenterLeaderboardsLinkagesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterLeaderboardSetGameCenterLeaderboardsLinkagesRequest List of related linkages
     */
    public gameCenterLeaderboardSetsGameCenterLeaderboardsReplaceToManyRelationshipWithHttpInfo(id: string, gameCenterLeaderboardSetGameCenterLeaderboardsLinkagesRequest: GameCenterLeaderboardSetGameCenterLeaderboardsLinkagesRequest, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.gameCenterLeaderboardSetsGameCenterLeaderboardsReplaceToManyRelationship(id, gameCenterLeaderboardSetGameCenterLeaderboardsLinkagesRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterLeaderboardSetsGameCenterLeaderboardsReplaceToManyRelationshipWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterLeaderboardSetGameCenterLeaderboardsLinkagesRequest List of related linkages
     */
    public gameCenterLeaderboardSetsGameCenterLeaderboardsReplaceToManyRelationship(id: string, gameCenterLeaderboardSetGameCenterLeaderboardsLinkagesRequest: GameCenterLeaderboardSetGameCenterLeaderboardsLinkagesRequest, _options?: Configuration): Observable<void> {
        return this.gameCenterLeaderboardSetsGameCenterLeaderboardsReplaceToManyRelationshipWithHttpInfo(id, gameCenterLeaderboardSetGameCenterLeaderboardsLinkagesRequest, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterLeaderboardSets the fields to include for returned resources of type gameCenterLeaderboardSets
     * @param include comma-separated list of relationships to include
     * @param fieldsGameCenterLeaderboardSetLocalizations the fields to include for returned resources of type gameCenterLeaderboardSetLocalizations
     * @param fieldsGameCenterLeaderboardSetReleases the fields to include for returned resources of type gameCenterLeaderboardSetReleases
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     * @param limitGameCenterLeaderboards maximum number of related gameCenterLeaderboards returned (when they are included)
     * @param limitLocalizations maximum number of related localizations returned (when they are included)
     * @param limitReleases maximum number of related releases returned (when they are included)
     */
    public gameCenterLeaderboardSetsGetInstanceWithHttpInfo(id: string, fieldsGameCenterLeaderboardSets?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'referenceName' | 'releases' | 'vendorIdentifier'>, include?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'releases'>, fieldsGameCenterLeaderboardSetLocalizations?: Array<'gameCenterLeaderboardSet' | 'gameCenterLeaderboardSetImage' | 'locale' | 'name'>, fieldsGameCenterLeaderboardSetReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboardSet' | 'live'>, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, limitGameCenterLeaderboards?: number, limitLocalizations?: number, limitReleases?: number, _options?: Configuration): Observable<HttpInfo<GameCenterLeaderboardSetResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterLeaderboardSetsGetInstance(id, fieldsGameCenterLeaderboardSets, include, fieldsGameCenterLeaderboardSetLocalizations, fieldsGameCenterLeaderboardSetReleases, fieldsGameCenterLeaderboards, limitGameCenterLeaderboards, limitLocalizations, limitReleases, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterLeaderboardSetsGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterLeaderboardSets the fields to include for returned resources of type gameCenterLeaderboardSets
     * @param include comma-separated list of relationships to include
     * @param fieldsGameCenterLeaderboardSetLocalizations the fields to include for returned resources of type gameCenterLeaderboardSetLocalizations
     * @param fieldsGameCenterLeaderboardSetReleases the fields to include for returned resources of type gameCenterLeaderboardSetReleases
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     * @param limitGameCenterLeaderboards maximum number of related gameCenterLeaderboards returned (when they are included)
     * @param limitLocalizations maximum number of related localizations returned (when they are included)
     * @param limitReleases maximum number of related releases returned (when they are included)
     */
    public gameCenterLeaderboardSetsGetInstance(id: string, fieldsGameCenterLeaderboardSets?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'referenceName' | 'releases' | 'vendorIdentifier'>, include?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'releases'>, fieldsGameCenterLeaderboardSetLocalizations?: Array<'gameCenterLeaderboardSet' | 'gameCenterLeaderboardSetImage' | 'locale' | 'name'>, fieldsGameCenterLeaderboardSetReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboardSet' | 'live'>, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, limitGameCenterLeaderboards?: number, limitLocalizations?: number, limitReleases?: number, _options?: Configuration): Observable<GameCenterLeaderboardSetResponse> {
        return this.gameCenterLeaderboardSetsGetInstanceWithHttpInfo(id, fieldsGameCenterLeaderboardSets, include, fieldsGameCenterLeaderboardSetLocalizations, fieldsGameCenterLeaderboardSetReleases, fieldsGameCenterLeaderboards, limitGameCenterLeaderboards, limitLocalizations, limitReleases, _options).pipe(map((apiResponse: HttpInfo<GameCenterLeaderboardSetResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterLeaderboardSetLocalizations the fields to include for returned resources of type gameCenterLeaderboardSetLocalizations
     * @param fieldsGameCenterLeaderboardSetReleases the fields to include for returned resources of type gameCenterLeaderboardSetReleases
     * @param fieldsGameCenterLeaderboardSets the fields to include for returned resources of type gameCenterLeaderboardSets
     * @param fieldsGameCenterGroups the fields to include for returned resources of type gameCenterGroups
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     * @param limitLocalizations maximum number of related localizations returned (when they are included)
     * @param limitGameCenterLeaderboards maximum number of related gameCenterLeaderboards returned (when they are included)
     * @param limitReleases maximum number of related releases returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public gameCenterLeaderboardSetsGroupLeaderboardSetGetToOneRelatedWithHttpInfo(id: string, fieldsGameCenterLeaderboardSetLocalizations?: Array<'gameCenterLeaderboardSet' | 'gameCenterLeaderboardSetImage' | 'locale' | 'name'>, fieldsGameCenterLeaderboardSetReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboardSet' | 'live'>, fieldsGameCenterLeaderboardSets?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'referenceName' | 'releases' | 'vendorIdentifier'>, fieldsGameCenterGroups?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'referenceName'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, limitLocalizations?: number, limitGameCenterLeaderboards?: number, limitReleases?: number, include?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'releases'>, _options?: Configuration): Observable<HttpInfo<GameCenterLeaderboardSetResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterLeaderboardSetsGroupLeaderboardSetGetToOneRelated(id, fieldsGameCenterLeaderboardSetLocalizations, fieldsGameCenterLeaderboardSetReleases, fieldsGameCenterLeaderboardSets, fieldsGameCenterGroups, fieldsGameCenterDetails, fieldsGameCenterLeaderboards, limitLocalizations, limitGameCenterLeaderboards, limitReleases, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterLeaderboardSetsGroupLeaderboardSetGetToOneRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterLeaderboardSetLocalizations the fields to include for returned resources of type gameCenterLeaderboardSetLocalizations
     * @param fieldsGameCenterLeaderboardSetReleases the fields to include for returned resources of type gameCenterLeaderboardSetReleases
     * @param fieldsGameCenterLeaderboardSets the fields to include for returned resources of type gameCenterLeaderboardSets
     * @param fieldsGameCenterGroups the fields to include for returned resources of type gameCenterGroups
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     * @param limitLocalizations maximum number of related localizations returned (when they are included)
     * @param limitGameCenterLeaderboards maximum number of related gameCenterLeaderboards returned (when they are included)
     * @param limitReleases maximum number of related releases returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public gameCenterLeaderboardSetsGroupLeaderboardSetGetToOneRelated(id: string, fieldsGameCenterLeaderboardSetLocalizations?: Array<'gameCenterLeaderboardSet' | 'gameCenterLeaderboardSetImage' | 'locale' | 'name'>, fieldsGameCenterLeaderboardSetReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboardSet' | 'live'>, fieldsGameCenterLeaderboardSets?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'referenceName' | 'releases' | 'vendorIdentifier'>, fieldsGameCenterGroups?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'referenceName'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, limitLocalizations?: number, limitGameCenterLeaderboards?: number, limitReleases?: number, include?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'releases'>, _options?: Configuration): Observable<GameCenterLeaderboardSetResponse> {
        return this.gameCenterLeaderboardSetsGroupLeaderboardSetGetToOneRelatedWithHttpInfo(id, fieldsGameCenterLeaderboardSetLocalizations, fieldsGameCenterLeaderboardSetReleases, fieldsGameCenterLeaderboardSets, fieldsGameCenterGroups, fieldsGameCenterDetails, fieldsGameCenterLeaderboards, limitLocalizations, limitGameCenterLeaderboards, limitReleases, include, _options).pipe(map((apiResponse: HttpInfo<GameCenterLeaderboardSetResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterLeaderboardSetsGroupLeaderboardSetGetToOneRelationshipWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<GameCenterLeaderboardSetGroupLeaderboardSetLinkageResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterLeaderboardSetsGroupLeaderboardSetGetToOneRelationship(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterLeaderboardSetsGroupLeaderboardSetGetToOneRelationshipWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterLeaderboardSetsGroupLeaderboardSetGetToOneRelationship(id: string, _options?: Configuration): Observable<GameCenterLeaderboardSetGroupLeaderboardSetLinkageResponse> {
        return this.gameCenterLeaderboardSetsGroupLeaderboardSetGetToOneRelationshipWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<GameCenterLeaderboardSetGroupLeaderboardSetLinkageResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterLeaderboardSetGroupLeaderboardSetLinkageRequest Related linkage
     */
    public gameCenterLeaderboardSetsGroupLeaderboardSetUpdateToOneRelationshipWithHttpInfo(id: string, gameCenterLeaderboardSetGroupLeaderboardSetLinkageRequest: GameCenterLeaderboardSetGroupLeaderboardSetLinkageRequest, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.gameCenterLeaderboardSetsGroupLeaderboardSetUpdateToOneRelationship(id, gameCenterLeaderboardSetGroupLeaderboardSetLinkageRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterLeaderboardSetsGroupLeaderboardSetUpdateToOneRelationshipWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterLeaderboardSetGroupLeaderboardSetLinkageRequest Related linkage
     */
    public gameCenterLeaderboardSetsGroupLeaderboardSetUpdateToOneRelationship(id: string, gameCenterLeaderboardSetGroupLeaderboardSetLinkageRequest: GameCenterLeaderboardSetGroupLeaderboardSetLinkageRequest, _options?: Configuration): Observable<void> {
        return this.gameCenterLeaderboardSetsGroupLeaderboardSetUpdateToOneRelationshipWithHttpInfo(id, gameCenterLeaderboardSetGroupLeaderboardSetLinkageRequest, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterLeaderboardSetLocalizations the fields to include for returned resources of type gameCenterLeaderboardSetLocalizations
     * @param fieldsGameCenterLeaderboardSets the fields to include for returned resources of type gameCenterLeaderboardSets
     * @param fieldsGameCenterLeaderboardSetImages the fields to include for returned resources of type gameCenterLeaderboardSetImages
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public gameCenterLeaderboardSetsLocalizationsGetToManyRelatedWithHttpInfo(id: string, fieldsGameCenterLeaderboardSetLocalizations?: Array<'gameCenterLeaderboardSet' | 'gameCenterLeaderboardSetImage' | 'locale' | 'name'>, fieldsGameCenterLeaderboardSets?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'referenceName' | 'releases' | 'vendorIdentifier'>, fieldsGameCenterLeaderboardSetImages?: Array<'assetDeliveryState' | 'fileName' | 'fileSize' | 'gameCenterLeaderboardSetLocalization' | 'imageAsset' | 'uploadOperations' | 'uploaded'>, limit?: number, include?: Array<'gameCenterLeaderboardSet' | 'gameCenterLeaderboardSetImage'>, _options?: Configuration): Observable<HttpInfo<GameCenterLeaderboardSetLocalizationsResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterLeaderboardSetsLocalizationsGetToManyRelated(id, fieldsGameCenterLeaderboardSetLocalizations, fieldsGameCenterLeaderboardSets, fieldsGameCenterLeaderboardSetImages, limit, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterLeaderboardSetsLocalizationsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterLeaderboardSetLocalizations the fields to include for returned resources of type gameCenterLeaderboardSetLocalizations
     * @param fieldsGameCenterLeaderboardSets the fields to include for returned resources of type gameCenterLeaderboardSets
     * @param fieldsGameCenterLeaderboardSetImages the fields to include for returned resources of type gameCenterLeaderboardSetImages
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public gameCenterLeaderboardSetsLocalizationsGetToManyRelated(id: string, fieldsGameCenterLeaderboardSetLocalizations?: Array<'gameCenterLeaderboardSet' | 'gameCenterLeaderboardSetImage' | 'locale' | 'name'>, fieldsGameCenterLeaderboardSets?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'referenceName' | 'releases' | 'vendorIdentifier'>, fieldsGameCenterLeaderboardSetImages?: Array<'assetDeliveryState' | 'fileName' | 'fileSize' | 'gameCenterLeaderboardSetLocalization' | 'imageAsset' | 'uploadOperations' | 'uploaded'>, limit?: number, include?: Array<'gameCenterLeaderboardSet' | 'gameCenterLeaderboardSetImage'>, _options?: Configuration): Observable<GameCenterLeaderboardSetLocalizationsResponse> {
        return this.gameCenterLeaderboardSetsLocalizationsGetToManyRelatedWithHttpInfo(id, fieldsGameCenterLeaderboardSetLocalizations, fieldsGameCenterLeaderboardSets, fieldsGameCenterLeaderboardSetImages, limit, include, _options).pipe(map((apiResponse: HttpInfo<GameCenterLeaderboardSetLocalizationsResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param filterLive filter by attribute \&#39;live\&#39;
     * @param filterGameCenterDetail filter by id(s) of related \&#39;gameCenterDetail\&#39;
     * @param fieldsGameCenterLeaderboardSetReleases the fields to include for returned resources of type gameCenterLeaderboardSetReleases
     * @param fieldsGameCenterLeaderboardSets the fields to include for returned resources of type gameCenterLeaderboardSets
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public gameCenterLeaderboardSetsReleasesGetToManyRelatedWithHttpInfo(id: string, filterLive?: Array<string>, filterGameCenterDetail?: Array<string>, fieldsGameCenterLeaderboardSetReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboardSet' | 'live'>, fieldsGameCenterLeaderboardSets?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'referenceName' | 'releases' | 'vendorIdentifier'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, limit?: number, include?: Array<'gameCenterDetail' | 'gameCenterLeaderboardSet'>, _options?: Configuration): Observable<HttpInfo<GameCenterLeaderboardSetReleasesResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterLeaderboardSetsReleasesGetToManyRelated(id, filterLive, filterGameCenterDetail, fieldsGameCenterLeaderboardSetReleases, fieldsGameCenterLeaderboardSets, fieldsGameCenterDetails, limit, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterLeaderboardSetsReleasesGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param filterLive filter by attribute \&#39;live\&#39;
     * @param filterGameCenterDetail filter by id(s) of related \&#39;gameCenterDetail\&#39;
     * @param fieldsGameCenterLeaderboardSetReleases the fields to include for returned resources of type gameCenterLeaderboardSetReleases
     * @param fieldsGameCenterLeaderboardSets the fields to include for returned resources of type gameCenterLeaderboardSets
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public gameCenterLeaderboardSetsReleasesGetToManyRelated(id: string, filterLive?: Array<string>, filterGameCenterDetail?: Array<string>, fieldsGameCenterLeaderboardSetReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboardSet' | 'live'>, fieldsGameCenterLeaderboardSets?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'referenceName' | 'releases' | 'vendorIdentifier'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, limit?: number, include?: Array<'gameCenterDetail' | 'gameCenterLeaderboardSet'>, _options?: Configuration): Observable<GameCenterLeaderboardSetReleasesResponse> {
        return this.gameCenterLeaderboardSetsReleasesGetToManyRelatedWithHttpInfo(id, filterLive, filterGameCenterDetail, fieldsGameCenterLeaderboardSetReleases, fieldsGameCenterLeaderboardSets, fieldsGameCenterDetails, limit, include, _options).pipe(map((apiResponse: HttpInfo<GameCenterLeaderboardSetReleasesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterLeaderboardSetUpdateRequest GameCenterLeaderboardSet representation
     */
    public gameCenterLeaderboardSetsUpdateInstanceWithHttpInfo(id: string, gameCenterLeaderboardSetUpdateRequest: GameCenterLeaderboardSetUpdateRequest, _options?: Configuration): Observable<HttpInfo<GameCenterLeaderboardSetResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterLeaderboardSetsUpdateInstance(id, gameCenterLeaderboardSetUpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterLeaderboardSetsUpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterLeaderboardSetUpdateRequest GameCenterLeaderboardSet representation
     */
    public gameCenterLeaderboardSetsUpdateInstance(id: string, gameCenterLeaderboardSetUpdateRequest: GameCenterLeaderboardSetUpdateRequest, _options?: Configuration): Observable<GameCenterLeaderboardSetResponse> {
        return this.gameCenterLeaderboardSetsUpdateInstanceWithHttpInfo(id, gameCenterLeaderboardSetUpdateRequest, _options).pipe(map((apiResponse: HttpInfo<GameCenterLeaderboardSetResponse>) => apiResponse.data));
    }

}

import { GameCenterLeaderboardsApiRequestFactory, GameCenterLeaderboardsApiResponseProcessor} from "../apis/GameCenterLeaderboardsApi.ts";
export class ObservableGameCenterLeaderboardsApi {
    private requestFactory: GameCenterLeaderboardsApiRequestFactory;
    private responseProcessor: GameCenterLeaderboardsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: GameCenterLeaderboardsApiRequestFactory,
        responseProcessor?: GameCenterLeaderboardsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new GameCenterLeaderboardsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new GameCenterLeaderboardsApiResponseProcessor();
    }

    /**
     * @param gameCenterLeaderboardCreateRequest GameCenterLeaderboard representation
     */
    public gameCenterLeaderboardsCreateInstanceWithHttpInfo(gameCenterLeaderboardCreateRequest: GameCenterLeaderboardCreateRequest, _options?: Configuration): Observable<HttpInfo<GameCenterLeaderboardResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterLeaderboardsCreateInstance(gameCenterLeaderboardCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterLeaderboardsCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param gameCenterLeaderboardCreateRequest GameCenterLeaderboard representation
     */
    public gameCenterLeaderboardsCreateInstance(gameCenterLeaderboardCreateRequest: GameCenterLeaderboardCreateRequest, _options?: Configuration): Observable<GameCenterLeaderboardResponse> {
        return this.gameCenterLeaderboardsCreateInstanceWithHttpInfo(gameCenterLeaderboardCreateRequest, _options).pipe(map((apiResponse: HttpInfo<GameCenterLeaderboardResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterLeaderboardsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.gameCenterLeaderboardsDeleteInstance(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterLeaderboardsDeleteInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterLeaderboardsDeleteInstance(id: string, _options?: Configuration): Observable<void> {
        return this.gameCenterLeaderboardsDeleteInstanceWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     * @param include comma-separated list of relationships to include
     * @param fieldsGameCenterLeaderboardLocalizations the fields to include for returned resources of type gameCenterLeaderboardLocalizations
     * @param fieldsGameCenterLeaderboardReleases the fields to include for returned resources of type gameCenterLeaderboardReleases
     * @param limitGameCenterLeaderboardSets maximum number of related gameCenterLeaderboardSets returned (when they are included)
     * @param limitLocalizations maximum number of related localizations returned (when they are included)
     * @param limitReleases maximum number of related releases returned (when they are included)
     */
    public gameCenterLeaderboardsGetInstanceWithHttpInfo(id: string, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, include?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'releases'>, fieldsGameCenterLeaderboardLocalizations?: Array<'formatterOverride' | 'formatterSuffix' | 'formatterSuffixSingular' | 'gameCenterLeaderboard' | 'gameCenterLeaderboardImage' | 'locale' | 'name'>, fieldsGameCenterLeaderboardReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboard' | 'live'>, limitGameCenterLeaderboardSets?: number, limitLocalizations?: number, limitReleases?: number, _options?: Configuration): Observable<HttpInfo<GameCenterLeaderboardResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterLeaderboardsGetInstance(id, fieldsGameCenterLeaderboards, include, fieldsGameCenterLeaderboardLocalizations, fieldsGameCenterLeaderboardReleases, limitGameCenterLeaderboardSets, limitLocalizations, limitReleases, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterLeaderboardsGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     * @param include comma-separated list of relationships to include
     * @param fieldsGameCenterLeaderboardLocalizations the fields to include for returned resources of type gameCenterLeaderboardLocalizations
     * @param fieldsGameCenterLeaderboardReleases the fields to include for returned resources of type gameCenterLeaderboardReleases
     * @param limitGameCenterLeaderboardSets maximum number of related gameCenterLeaderboardSets returned (when they are included)
     * @param limitLocalizations maximum number of related localizations returned (when they are included)
     * @param limitReleases maximum number of related releases returned (when they are included)
     */
    public gameCenterLeaderboardsGetInstance(id: string, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, include?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'releases'>, fieldsGameCenterLeaderboardLocalizations?: Array<'formatterOverride' | 'formatterSuffix' | 'formatterSuffixSingular' | 'gameCenterLeaderboard' | 'gameCenterLeaderboardImage' | 'locale' | 'name'>, fieldsGameCenterLeaderboardReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboard' | 'live'>, limitGameCenterLeaderboardSets?: number, limitLocalizations?: number, limitReleases?: number, _options?: Configuration): Observable<GameCenterLeaderboardResponse> {
        return this.gameCenterLeaderboardsGetInstanceWithHttpInfo(id, fieldsGameCenterLeaderboards, include, fieldsGameCenterLeaderboardLocalizations, fieldsGameCenterLeaderboardReleases, limitGameCenterLeaderboardSets, limitLocalizations, limitReleases, _options).pipe(map((apiResponse: HttpInfo<GameCenterLeaderboardResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterLeaderboardLocalizations the fields to include for returned resources of type gameCenterLeaderboardLocalizations
     * @param fieldsGameCenterLeaderboardSets the fields to include for returned resources of type gameCenterLeaderboardSets
     * @param fieldsGameCenterGroups the fields to include for returned resources of type gameCenterGroups
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     * @param fieldsGameCenterLeaderboardReleases the fields to include for returned resources of type gameCenterLeaderboardReleases
     * @param limitGameCenterLeaderboardSets maximum number of related gameCenterLeaderboardSets returned (when they are included)
     * @param limitLocalizations maximum number of related localizations returned (when they are included)
     * @param limitReleases maximum number of related releases returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public gameCenterLeaderboardsGroupLeaderboardGetToOneRelatedWithHttpInfo(id: string, fieldsGameCenterLeaderboardLocalizations?: Array<'formatterOverride' | 'formatterSuffix' | 'formatterSuffixSingular' | 'gameCenterLeaderboard' | 'gameCenterLeaderboardImage' | 'locale' | 'name'>, fieldsGameCenterLeaderboardSets?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'referenceName' | 'releases' | 'vendorIdentifier'>, fieldsGameCenterGroups?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'referenceName'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, fieldsGameCenterLeaderboardReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboard' | 'live'>, limitGameCenterLeaderboardSets?: number, limitLocalizations?: number, limitReleases?: number, include?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'releases'>, _options?: Configuration): Observable<HttpInfo<GameCenterLeaderboardResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterLeaderboardsGroupLeaderboardGetToOneRelated(id, fieldsGameCenterLeaderboardLocalizations, fieldsGameCenterLeaderboardSets, fieldsGameCenterGroups, fieldsGameCenterDetails, fieldsGameCenterLeaderboards, fieldsGameCenterLeaderboardReleases, limitGameCenterLeaderboardSets, limitLocalizations, limitReleases, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterLeaderboardsGroupLeaderboardGetToOneRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterLeaderboardLocalizations the fields to include for returned resources of type gameCenterLeaderboardLocalizations
     * @param fieldsGameCenterLeaderboardSets the fields to include for returned resources of type gameCenterLeaderboardSets
     * @param fieldsGameCenterGroups the fields to include for returned resources of type gameCenterGroups
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     * @param fieldsGameCenterLeaderboardReleases the fields to include for returned resources of type gameCenterLeaderboardReleases
     * @param limitGameCenterLeaderboardSets maximum number of related gameCenterLeaderboardSets returned (when they are included)
     * @param limitLocalizations maximum number of related localizations returned (when they are included)
     * @param limitReleases maximum number of related releases returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public gameCenterLeaderboardsGroupLeaderboardGetToOneRelated(id: string, fieldsGameCenterLeaderboardLocalizations?: Array<'formatterOverride' | 'formatterSuffix' | 'formatterSuffixSingular' | 'gameCenterLeaderboard' | 'gameCenterLeaderboardImage' | 'locale' | 'name'>, fieldsGameCenterLeaderboardSets?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'referenceName' | 'releases' | 'vendorIdentifier'>, fieldsGameCenterGroups?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'referenceName'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, fieldsGameCenterLeaderboardReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboard' | 'live'>, limitGameCenterLeaderboardSets?: number, limitLocalizations?: number, limitReleases?: number, include?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'releases'>, _options?: Configuration): Observable<GameCenterLeaderboardResponse> {
        return this.gameCenterLeaderboardsGroupLeaderboardGetToOneRelatedWithHttpInfo(id, fieldsGameCenterLeaderboardLocalizations, fieldsGameCenterLeaderboardSets, fieldsGameCenterGroups, fieldsGameCenterDetails, fieldsGameCenterLeaderboards, fieldsGameCenterLeaderboardReleases, limitGameCenterLeaderboardSets, limitLocalizations, limitReleases, include, _options).pipe(map((apiResponse: HttpInfo<GameCenterLeaderboardResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterLeaderboardsGroupLeaderboardGetToOneRelationshipWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<GameCenterLeaderboardGroupLeaderboardLinkageResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterLeaderboardsGroupLeaderboardGetToOneRelationship(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterLeaderboardsGroupLeaderboardGetToOneRelationshipWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterLeaderboardsGroupLeaderboardGetToOneRelationship(id: string, _options?: Configuration): Observable<GameCenterLeaderboardGroupLeaderboardLinkageResponse> {
        return this.gameCenterLeaderboardsGroupLeaderboardGetToOneRelationshipWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<GameCenterLeaderboardGroupLeaderboardLinkageResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterLeaderboardGroupLeaderboardLinkageRequest Related linkage
     */
    public gameCenterLeaderboardsGroupLeaderboardUpdateToOneRelationshipWithHttpInfo(id: string, gameCenterLeaderboardGroupLeaderboardLinkageRequest: GameCenterLeaderboardGroupLeaderboardLinkageRequest, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.gameCenterLeaderboardsGroupLeaderboardUpdateToOneRelationship(id, gameCenterLeaderboardGroupLeaderboardLinkageRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterLeaderboardsGroupLeaderboardUpdateToOneRelationshipWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterLeaderboardGroupLeaderboardLinkageRequest Related linkage
     */
    public gameCenterLeaderboardsGroupLeaderboardUpdateToOneRelationship(id: string, gameCenterLeaderboardGroupLeaderboardLinkageRequest: GameCenterLeaderboardGroupLeaderboardLinkageRequest, _options?: Configuration): Observable<void> {
        return this.gameCenterLeaderboardsGroupLeaderboardUpdateToOneRelationshipWithHttpInfo(id, gameCenterLeaderboardGroupLeaderboardLinkageRequest, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterLeaderboardLocalizations the fields to include for returned resources of type gameCenterLeaderboardLocalizations
     * @param fieldsGameCenterLeaderboardImages the fields to include for returned resources of type gameCenterLeaderboardImages
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public gameCenterLeaderboardsLocalizationsGetToManyRelatedWithHttpInfo(id: string, fieldsGameCenterLeaderboardLocalizations?: Array<'formatterOverride' | 'formatterSuffix' | 'formatterSuffixSingular' | 'gameCenterLeaderboard' | 'gameCenterLeaderboardImage' | 'locale' | 'name'>, fieldsGameCenterLeaderboardImages?: Array<'assetDeliveryState' | 'fileName' | 'fileSize' | 'gameCenterLeaderboardLocalization' | 'imageAsset' | 'uploadOperations' | 'uploaded'>, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, limit?: number, include?: Array<'gameCenterLeaderboard' | 'gameCenterLeaderboardImage'>, _options?: Configuration): Observable<HttpInfo<GameCenterLeaderboardLocalizationsResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterLeaderboardsLocalizationsGetToManyRelated(id, fieldsGameCenterLeaderboardLocalizations, fieldsGameCenterLeaderboardImages, fieldsGameCenterLeaderboards, limit, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterLeaderboardsLocalizationsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterLeaderboardLocalizations the fields to include for returned resources of type gameCenterLeaderboardLocalizations
     * @param fieldsGameCenterLeaderboardImages the fields to include for returned resources of type gameCenterLeaderboardImages
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public gameCenterLeaderboardsLocalizationsGetToManyRelated(id: string, fieldsGameCenterLeaderboardLocalizations?: Array<'formatterOverride' | 'formatterSuffix' | 'formatterSuffixSingular' | 'gameCenterLeaderboard' | 'gameCenterLeaderboardImage' | 'locale' | 'name'>, fieldsGameCenterLeaderboardImages?: Array<'assetDeliveryState' | 'fileName' | 'fileSize' | 'gameCenterLeaderboardLocalization' | 'imageAsset' | 'uploadOperations' | 'uploaded'>, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, limit?: number, include?: Array<'gameCenterLeaderboard' | 'gameCenterLeaderboardImage'>, _options?: Configuration): Observable<GameCenterLeaderboardLocalizationsResponse> {
        return this.gameCenterLeaderboardsLocalizationsGetToManyRelatedWithHttpInfo(id, fieldsGameCenterLeaderboardLocalizations, fieldsGameCenterLeaderboardImages, fieldsGameCenterLeaderboards, limit, include, _options).pipe(map((apiResponse: HttpInfo<GameCenterLeaderboardLocalizationsResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param filterLive filter by attribute \&#39;live\&#39;
     * @param filterGameCenterDetail filter by id(s) of related \&#39;gameCenterDetail\&#39;
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     * @param fieldsGameCenterLeaderboardReleases the fields to include for returned resources of type gameCenterLeaderboardReleases
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public gameCenterLeaderboardsReleasesGetToManyRelatedWithHttpInfo(id: string, filterLive?: Array<string>, filterGameCenterDetail?: Array<string>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, fieldsGameCenterLeaderboardReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboard' | 'live'>, limit?: number, include?: Array<'gameCenterDetail' | 'gameCenterLeaderboard'>, _options?: Configuration): Observable<HttpInfo<GameCenterLeaderboardReleasesResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterLeaderboardsReleasesGetToManyRelated(id, filterLive, filterGameCenterDetail, fieldsGameCenterDetails, fieldsGameCenterLeaderboards, fieldsGameCenterLeaderboardReleases, limit, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterLeaderboardsReleasesGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param filterLive filter by attribute \&#39;live\&#39;
     * @param filterGameCenterDetail filter by id(s) of related \&#39;gameCenterDetail\&#39;
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     * @param fieldsGameCenterLeaderboardReleases the fields to include for returned resources of type gameCenterLeaderboardReleases
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public gameCenterLeaderboardsReleasesGetToManyRelated(id: string, filterLive?: Array<string>, filterGameCenterDetail?: Array<string>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, fieldsGameCenterLeaderboardReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboard' | 'live'>, limit?: number, include?: Array<'gameCenterDetail' | 'gameCenterLeaderboard'>, _options?: Configuration): Observable<GameCenterLeaderboardReleasesResponse> {
        return this.gameCenterLeaderboardsReleasesGetToManyRelatedWithHttpInfo(id, filterLive, filterGameCenterDetail, fieldsGameCenterDetails, fieldsGameCenterLeaderboards, fieldsGameCenterLeaderboardReleases, limit, include, _options).pipe(map((apiResponse: HttpInfo<GameCenterLeaderboardReleasesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterLeaderboardUpdateRequest GameCenterLeaderboard representation
     */
    public gameCenterLeaderboardsUpdateInstanceWithHttpInfo(id: string, gameCenterLeaderboardUpdateRequest: GameCenterLeaderboardUpdateRequest, _options?: Configuration): Observable<HttpInfo<GameCenterLeaderboardResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterLeaderboardsUpdateInstance(id, gameCenterLeaderboardUpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterLeaderboardsUpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterLeaderboardUpdateRequest GameCenterLeaderboard representation
     */
    public gameCenterLeaderboardsUpdateInstance(id: string, gameCenterLeaderboardUpdateRequest: GameCenterLeaderboardUpdateRequest, _options?: Configuration): Observable<GameCenterLeaderboardResponse> {
        return this.gameCenterLeaderboardsUpdateInstanceWithHttpInfo(id, gameCenterLeaderboardUpdateRequest, _options).pipe(map((apiResponse: HttpInfo<GameCenterLeaderboardResponse>) => apiResponse.data));
    }

}

import { GameCenterMatchmakingQueuesApiRequestFactory, GameCenterMatchmakingQueuesApiResponseProcessor} from "../apis/GameCenterMatchmakingQueuesApi.ts";
export class ObservableGameCenterMatchmakingQueuesApi {
    private requestFactory: GameCenterMatchmakingQueuesApiRequestFactory;
    private responseProcessor: GameCenterMatchmakingQueuesApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: GameCenterMatchmakingQueuesApiRequestFactory,
        responseProcessor?: GameCenterMatchmakingQueuesApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new GameCenterMatchmakingQueuesApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new GameCenterMatchmakingQueuesApiResponseProcessor();
    }

    /**
     * @param gameCenterMatchmakingQueueCreateRequest GameCenterMatchmakingQueue representation
     */
    public gameCenterMatchmakingQueuesCreateInstanceWithHttpInfo(gameCenterMatchmakingQueueCreateRequest: GameCenterMatchmakingQueueCreateRequest, _options?: Configuration): Observable<HttpInfo<GameCenterMatchmakingQueueResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterMatchmakingQueuesCreateInstance(gameCenterMatchmakingQueueCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterMatchmakingQueuesCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param gameCenterMatchmakingQueueCreateRequest GameCenterMatchmakingQueue representation
     */
    public gameCenterMatchmakingQueuesCreateInstance(gameCenterMatchmakingQueueCreateRequest: GameCenterMatchmakingQueueCreateRequest, _options?: Configuration): Observable<GameCenterMatchmakingQueueResponse> {
        return this.gameCenterMatchmakingQueuesCreateInstanceWithHttpInfo(gameCenterMatchmakingQueueCreateRequest, _options).pipe(map((apiResponse: HttpInfo<GameCenterMatchmakingQueueResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterMatchmakingQueuesDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.gameCenterMatchmakingQueuesDeleteInstance(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterMatchmakingQueuesDeleteInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterMatchmakingQueuesDeleteInstance(id: string, _options?: Configuration): Observable<void> {
        return this.gameCenterMatchmakingQueuesDeleteInstanceWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param granularity the granularity of the per-group dataset
     * @param limit maximum number of groups to return per page
     * @param sort comma-separated list of sort expressions; metrics will be sorted as specified
     */
    public gameCenterMatchmakingQueuesExperimentMatchmakingQueueSizesGetMetricsWithHttpInfo(id: string, granularity: 'P1D' | 'PT1H' | 'PT15M', limit?: number, sort?: Array<'averageNumberOfRequests' | '-averageNumberOfRequests' | 'count' | '-count' | 'p50NumberOfRequests' | '-p50NumberOfRequests' | 'p95NumberOfRequests' | '-p95NumberOfRequests'>, _options?: Configuration): Observable<HttpInfo<GameCenterMatchmakingQueueSizesV1MetricResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterMatchmakingQueuesExperimentMatchmakingQueueSizesGetMetrics(id, granularity, limit, sort, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterMatchmakingQueuesExperimentMatchmakingQueueSizesGetMetricsWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param granularity the granularity of the per-group dataset
     * @param limit maximum number of groups to return per page
     * @param sort comma-separated list of sort expressions; metrics will be sorted as specified
     */
    public gameCenterMatchmakingQueuesExperimentMatchmakingQueueSizesGetMetrics(id: string, granularity: 'P1D' | 'PT1H' | 'PT15M', limit?: number, sort?: Array<'averageNumberOfRequests' | '-averageNumberOfRequests' | 'count' | '-count' | 'p50NumberOfRequests' | '-p50NumberOfRequests' | 'p95NumberOfRequests' | '-p95NumberOfRequests'>, _options?: Configuration): Observable<GameCenterMatchmakingQueueSizesV1MetricResponse> {
        return this.gameCenterMatchmakingQueuesExperimentMatchmakingQueueSizesGetMetricsWithHttpInfo(id, granularity, limit, sort, _options).pipe(map((apiResponse: HttpInfo<GameCenterMatchmakingQueueSizesV1MetricResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param granularity the granularity of the per-group dataset
     * @param limit maximum number of groups to return per page
     * @param groupBy the dimension by which to group the results
     * @param filterResult filter by \&#39;result\&#39; attribute dimension
     * @param filterGameCenterDetail filter by \&#39;gameCenterDetail\&#39; relationship dimension
     * @param sort comma-separated list of sort expressions; metrics will be sorted as specified
     */
    public gameCenterMatchmakingQueuesExperimentMatchmakingRequestsGetMetricsWithHttpInfo(id: string, granularity: 'P1D' | 'PT1H' | 'PT15M', limit?: number, groupBy?: Array<'gameCenterDetail' | 'result'>, filterResult?: 'MATCHED' | 'CANCELED' | 'EXPIRED', filterGameCenterDetail?: string, sort?: Array<'averageSecondsInQueue' | '-averageSecondsInQueue' | 'count' | '-count' | 'p50SecondsInQueue' | '-p50SecondsInQueue' | 'p95SecondsInQueue' | '-p95SecondsInQueue'>, _options?: Configuration): Observable<HttpInfo<GameCenterMatchmakingQueueRequestsV1MetricResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterMatchmakingQueuesExperimentMatchmakingRequestsGetMetrics(id, granularity, limit, groupBy, filterResult, filterGameCenterDetail, sort, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterMatchmakingQueuesExperimentMatchmakingRequestsGetMetricsWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param granularity the granularity of the per-group dataset
     * @param limit maximum number of groups to return per page
     * @param groupBy the dimension by which to group the results
     * @param filterResult filter by \&#39;result\&#39; attribute dimension
     * @param filterGameCenterDetail filter by \&#39;gameCenterDetail\&#39; relationship dimension
     * @param sort comma-separated list of sort expressions; metrics will be sorted as specified
     */
    public gameCenterMatchmakingQueuesExperimentMatchmakingRequestsGetMetrics(id: string, granularity: 'P1D' | 'PT1H' | 'PT15M', limit?: number, groupBy?: Array<'gameCenterDetail' | 'result'>, filterResult?: 'MATCHED' | 'CANCELED' | 'EXPIRED', filterGameCenterDetail?: string, sort?: Array<'averageSecondsInQueue' | '-averageSecondsInQueue' | 'count' | '-count' | 'p50SecondsInQueue' | '-p50SecondsInQueue' | 'p95SecondsInQueue' | '-p95SecondsInQueue'>, _options?: Configuration): Observable<GameCenterMatchmakingQueueRequestsV1MetricResponse> {
        return this.gameCenterMatchmakingQueuesExperimentMatchmakingRequestsGetMetricsWithHttpInfo(id, granularity, limit, groupBy, filterResult, filterGameCenterDetail, sort, _options).pipe(map((apiResponse: HttpInfo<GameCenterMatchmakingQueueRequestsV1MetricResponse>) => apiResponse.data));
    }

    /**
     * @param fieldsGameCenterMatchmakingQueues the fields to include for returned resources of type gameCenterMatchmakingQueues
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public gameCenterMatchmakingQueuesGetCollectionWithHttpInfo(fieldsGameCenterMatchmakingQueues?: Array<'classicMatchmakingBundleIds' | 'experimentRuleSet' | 'referenceName' | 'ruleSet'>, limit?: number, include?: Array<'experimentRuleSet' | 'ruleSet'>, _options?: Configuration): Observable<HttpInfo<GameCenterMatchmakingQueuesResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterMatchmakingQueuesGetCollection(fieldsGameCenterMatchmakingQueues, limit, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterMatchmakingQueuesGetCollectionWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param fieldsGameCenterMatchmakingQueues the fields to include for returned resources of type gameCenterMatchmakingQueues
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public gameCenterMatchmakingQueuesGetCollection(fieldsGameCenterMatchmakingQueues?: Array<'classicMatchmakingBundleIds' | 'experimentRuleSet' | 'referenceName' | 'ruleSet'>, limit?: number, include?: Array<'experimentRuleSet' | 'ruleSet'>, _options?: Configuration): Observable<GameCenterMatchmakingQueuesResponse> {
        return this.gameCenterMatchmakingQueuesGetCollectionWithHttpInfo(fieldsGameCenterMatchmakingQueues, limit, include, _options).pipe(map((apiResponse: HttpInfo<GameCenterMatchmakingQueuesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterMatchmakingQueues the fields to include for returned resources of type gameCenterMatchmakingQueues
     * @param include comma-separated list of relationships to include
     */
    public gameCenterMatchmakingQueuesGetInstanceWithHttpInfo(id: string, fieldsGameCenterMatchmakingQueues?: Array<'classicMatchmakingBundleIds' | 'experimentRuleSet' | 'referenceName' | 'ruleSet'>, include?: Array<'experimentRuleSet' | 'ruleSet'>, _options?: Configuration): Observable<HttpInfo<GameCenterMatchmakingQueueResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterMatchmakingQueuesGetInstance(id, fieldsGameCenterMatchmakingQueues, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterMatchmakingQueuesGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterMatchmakingQueues the fields to include for returned resources of type gameCenterMatchmakingQueues
     * @param include comma-separated list of relationships to include
     */
    public gameCenterMatchmakingQueuesGetInstance(id: string, fieldsGameCenterMatchmakingQueues?: Array<'classicMatchmakingBundleIds' | 'experimentRuleSet' | 'referenceName' | 'ruleSet'>, include?: Array<'experimentRuleSet' | 'ruleSet'>, _options?: Configuration): Observable<GameCenterMatchmakingQueueResponse> {
        return this.gameCenterMatchmakingQueuesGetInstanceWithHttpInfo(id, fieldsGameCenterMatchmakingQueues, include, _options).pipe(map((apiResponse: HttpInfo<GameCenterMatchmakingQueueResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param granularity the granularity of the per-group dataset
     * @param limit maximum number of groups to return per page
     * @param sort comma-separated list of sort expressions; metrics will be sorted as specified
     */
    public gameCenterMatchmakingQueuesMatchmakingQueueSizesGetMetricsWithHttpInfo(id: string, granularity: 'P1D' | 'PT1H' | 'PT15M', limit?: number, sort?: Array<'averageNumberOfRequests' | '-averageNumberOfRequests' | 'count' | '-count' | 'p50NumberOfRequests' | '-p50NumberOfRequests' | 'p95NumberOfRequests' | '-p95NumberOfRequests'>, _options?: Configuration): Observable<HttpInfo<GameCenterMatchmakingQueueSizesV1MetricResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterMatchmakingQueuesMatchmakingQueueSizesGetMetrics(id, granularity, limit, sort, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterMatchmakingQueuesMatchmakingQueueSizesGetMetricsWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param granularity the granularity of the per-group dataset
     * @param limit maximum number of groups to return per page
     * @param sort comma-separated list of sort expressions; metrics will be sorted as specified
     */
    public gameCenterMatchmakingQueuesMatchmakingQueueSizesGetMetrics(id: string, granularity: 'P1D' | 'PT1H' | 'PT15M', limit?: number, sort?: Array<'averageNumberOfRequests' | '-averageNumberOfRequests' | 'count' | '-count' | 'p50NumberOfRequests' | '-p50NumberOfRequests' | 'p95NumberOfRequests' | '-p95NumberOfRequests'>, _options?: Configuration): Observable<GameCenterMatchmakingQueueSizesV1MetricResponse> {
        return this.gameCenterMatchmakingQueuesMatchmakingQueueSizesGetMetricsWithHttpInfo(id, granularity, limit, sort, _options).pipe(map((apiResponse: HttpInfo<GameCenterMatchmakingQueueSizesV1MetricResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param granularity the granularity of the per-group dataset
     * @param limit maximum number of groups to return per page
     * @param groupBy the dimension by which to group the results
     * @param filterResult filter by \&#39;result\&#39; attribute dimension
     * @param filterGameCenterDetail filter by \&#39;gameCenterDetail\&#39; relationship dimension
     * @param sort comma-separated list of sort expressions; metrics will be sorted as specified
     */
    public gameCenterMatchmakingQueuesMatchmakingRequestsGetMetricsWithHttpInfo(id: string, granularity: 'P1D' | 'PT1H' | 'PT15M', limit?: number, groupBy?: Array<'gameCenterDetail' | 'result'>, filterResult?: 'MATCHED' | 'CANCELED' | 'EXPIRED', filterGameCenterDetail?: string, sort?: Array<'averageSecondsInQueue' | '-averageSecondsInQueue' | 'count' | '-count' | 'p50SecondsInQueue' | '-p50SecondsInQueue' | 'p95SecondsInQueue' | '-p95SecondsInQueue'>, _options?: Configuration): Observable<HttpInfo<GameCenterMatchmakingQueueRequestsV1MetricResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterMatchmakingQueuesMatchmakingRequestsGetMetrics(id, granularity, limit, groupBy, filterResult, filterGameCenterDetail, sort, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterMatchmakingQueuesMatchmakingRequestsGetMetricsWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param granularity the granularity of the per-group dataset
     * @param limit maximum number of groups to return per page
     * @param groupBy the dimension by which to group the results
     * @param filterResult filter by \&#39;result\&#39; attribute dimension
     * @param filterGameCenterDetail filter by \&#39;gameCenterDetail\&#39; relationship dimension
     * @param sort comma-separated list of sort expressions; metrics will be sorted as specified
     */
    public gameCenterMatchmakingQueuesMatchmakingRequestsGetMetrics(id: string, granularity: 'P1D' | 'PT1H' | 'PT15M', limit?: number, groupBy?: Array<'gameCenterDetail' | 'result'>, filterResult?: 'MATCHED' | 'CANCELED' | 'EXPIRED', filterGameCenterDetail?: string, sort?: Array<'averageSecondsInQueue' | '-averageSecondsInQueue' | 'count' | '-count' | 'p50SecondsInQueue' | '-p50SecondsInQueue' | 'p95SecondsInQueue' | '-p95SecondsInQueue'>, _options?: Configuration): Observable<GameCenterMatchmakingQueueRequestsV1MetricResponse> {
        return this.gameCenterMatchmakingQueuesMatchmakingRequestsGetMetricsWithHttpInfo(id, granularity, limit, groupBy, filterResult, filterGameCenterDetail, sort, _options).pipe(map((apiResponse: HttpInfo<GameCenterMatchmakingQueueRequestsV1MetricResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param granularity the granularity of the per-group dataset
     * @param limit maximum number of groups to return per page
     * @param sort comma-separated list of sort expressions; metrics will be sorted as specified
     */
    public gameCenterMatchmakingQueuesMatchmakingSessionsGetMetricsWithHttpInfo(id: string, granularity: 'P1D' | 'PT1H' | 'PT15M', limit?: number, sort?: Array<'averagePlayerCount' | '-averagePlayerCount' | 'count' | '-count' | 'p50PlayerCount' | '-p50PlayerCount' | 'p95PlayerCount' | '-p95PlayerCount'>, _options?: Configuration): Observable<HttpInfo<GameCenterMatchmakingSessionsV1MetricResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterMatchmakingQueuesMatchmakingSessionsGetMetrics(id, granularity, limit, sort, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterMatchmakingQueuesMatchmakingSessionsGetMetricsWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param granularity the granularity of the per-group dataset
     * @param limit maximum number of groups to return per page
     * @param sort comma-separated list of sort expressions; metrics will be sorted as specified
     */
    public gameCenterMatchmakingQueuesMatchmakingSessionsGetMetrics(id: string, granularity: 'P1D' | 'PT1H' | 'PT15M', limit?: number, sort?: Array<'averagePlayerCount' | '-averagePlayerCount' | 'count' | '-count' | 'p50PlayerCount' | '-p50PlayerCount' | 'p95PlayerCount' | '-p95PlayerCount'>, _options?: Configuration): Observable<GameCenterMatchmakingSessionsV1MetricResponse> {
        return this.gameCenterMatchmakingQueuesMatchmakingSessionsGetMetricsWithHttpInfo(id, granularity, limit, sort, _options).pipe(map((apiResponse: HttpInfo<GameCenterMatchmakingSessionsV1MetricResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterMatchmakingQueueUpdateRequest GameCenterMatchmakingQueue representation
     */
    public gameCenterMatchmakingQueuesUpdateInstanceWithHttpInfo(id: string, gameCenterMatchmakingQueueUpdateRequest: GameCenterMatchmakingQueueUpdateRequest, _options?: Configuration): Observable<HttpInfo<GameCenterMatchmakingQueueResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterMatchmakingQueuesUpdateInstance(id, gameCenterMatchmakingQueueUpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterMatchmakingQueuesUpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterMatchmakingQueueUpdateRequest GameCenterMatchmakingQueue representation
     */
    public gameCenterMatchmakingQueuesUpdateInstance(id: string, gameCenterMatchmakingQueueUpdateRequest: GameCenterMatchmakingQueueUpdateRequest, _options?: Configuration): Observable<GameCenterMatchmakingQueueResponse> {
        return this.gameCenterMatchmakingQueuesUpdateInstanceWithHttpInfo(id, gameCenterMatchmakingQueueUpdateRequest, _options).pipe(map((apiResponse: HttpInfo<GameCenterMatchmakingQueueResponse>) => apiResponse.data));
    }

}

import { GameCenterMatchmakingRuleSetTestsApiRequestFactory, GameCenterMatchmakingRuleSetTestsApiResponseProcessor} from "../apis/GameCenterMatchmakingRuleSetTestsApi.ts";
export class ObservableGameCenterMatchmakingRuleSetTestsApi {
    private requestFactory: GameCenterMatchmakingRuleSetTestsApiRequestFactory;
    private responseProcessor: GameCenterMatchmakingRuleSetTestsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: GameCenterMatchmakingRuleSetTestsApiRequestFactory,
        responseProcessor?: GameCenterMatchmakingRuleSetTestsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new GameCenterMatchmakingRuleSetTestsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new GameCenterMatchmakingRuleSetTestsApiResponseProcessor();
    }

    /**
     * @param gameCenterMatchmakingRuleSetTestCreateRequest GameCenterMatchmakingRuleSetTest representation
     */
    public gameCenterMatchmakingRuleSetTestsCreateInstanceWithHttpInfo(gameCenterMatchmakingRuleSetTestCreateRequest: GameCenterMatchmakingRuleSetTestCreateRequest, _options?: Configuration): Observable<HttpInfo<GameCenterMatchmakingRuleSetTestResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterMatchmakingRuleSetTestsCreateInstance(gameCenterMatchmakingRuleSetTestCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterMatchmakingRuleSetTestsCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param gameCenterMatchmakingRuleSetTestCreateRequest GameCenterMatchmakingRuleSetTest representation
     */
    public gameCenterMatchmakingRuleSetTestsCreateInstance(gameCenterMatchmakingRuleSetTestCreateRequest: GameCenterMatchmakingRuleSetTestCreateRequest, _options?: Configuration): Observable<GameCenterMatchmakingRuleSetTestResponse> {
        return this.gameCenterMatchmakingRuleSetTestsCreateInstanceWithHttpInfo(gameCenterMatchmakingRuleSetTestCreateRequest, _options).pipe(map((apiResponse: HttpInfo<GameCenterMatchmakingRuleSetTestResponse>) => apiResponse.data));
    }

}

import { GameCenterMatchmakingRuleSetsApiRequestFactory, GameCenterMatchmakingRuleSetsApiResponseProcessor} from "../apis/GameCenterMatchmakingRuleSetsApi.ts";
export class ObservableGameCenterMatchmakingRuleSetsApi {
    private requestFactory: GameCenterMatchmakingRuleSetsApiRequestFactory;
    private responseProcessor: GameCenterMatchmakingRuleSetsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: GameCenterMatchmakingRuleSetsApiRequestFactory,
        responseProcessor?: GameCenterMatchmakingRuleSetsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new GameCenterMatchmakingRuleSetsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new GameCenterMatchmakingRuleSetsApiResponseProcessor();
    }

    /**
     * @param gameCenterMatchmakingRuleSetCreateRequest GameCenterMatchmakingRuleSet representation
     */
    public gameCenterMatchmakingRuleSetsCreateInstanceWithHttpInfo(gameCenterMatchmakingRuleSetCreateRequest: GameCenterMatchmakingRuleSetCreateRequest, _options?: Configuration): Observable<HttpInfo<GameCenterMatchmakingRuleSetResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterMatchmakingRuleSetsCreateInstance(gameCenterMatchmakingRuleSetCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterMatchmakingRuleSetsCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param gameCenterMatchmakingRuleSetCreateRequest GameCenterMatchmakingRuleSet representation
     */
    public gameCenterMatchmakingRuleSetsCreateInstance(gameCenterMatchmakingRuleSetCreateRequest: GameCenterMatchmakingRuleSetCreateRequest, _options?: Configuration): Observable<GameCenterMatchmakingRuleSetResponse> {
        return this.gameCenterMatchmakingRuleSetsCreateInstanceWithHttpInfo(gameCenterMatchmakingRuleSetCreateRequest, _options).pipe(map((apiResponse: HttpInfo<GameCenterMatchmakingRuleSetResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterMatchmakingRuleSetsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.gameCenterMatchmakingRuleSetsDeleteInstance(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterMatchmakingRuleSetsDeleteInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterMatchmakingRuleSetsDeleteInstance(id: string, _options?: Configuration): Observable<void> {
        return this.gameCenterMatchmakingRuleSetsDeleteInstanceWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param fieldsGameCenterMatchmakingRuleSets the fields to include for returned resources of type gameCenterMatchmakingRuleSets
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsGameCenterMatchmakingQueues the fields to include for returned resources of type gameCenterMatchmakingQueues
     * @param fieldsGameCenterMatchmakingTeams the fields to include for returned resources of type gameCenterMatchmakingTeams
     * @param fieldsGameCenterMatchmakingRules the fields to include for returned resources of type gameCenterMatchmakingRules
     * @param limitMatchmakingQueues maximum number of related matchmakingQueues returned (when they are included)
     * @param limitRules maximum number of related rules returned (when they are included)
     * @param limitTeams maximum number of related teams returned (when they are included)
     */
    public gameCenterMatchmakingRuleSetsGetCollectionWithHttpInfo(fieldsGameCenterMatchmakingRuleSets?: Array<'matchmakingQueues' | 'maxPlayers' | 'minPlayers' | 'referenceName' | 'ruleLanguageVersion' | 'rules' | 'teams'>, limit?: number, include?: Array<'matchmakingQueues' | 'rules' | 'teams'>, fieldsGameCenterMatchmakingQueues?: Array<'classicMatchmakingBundleIds' | 'experimentRuleSet' | 'referenceName' | 'ruleSet'>, fieldsGameCenterMatchmakingTeams?: Array<'maxPlayers' | 'minPlayers' | 'referenceName' | 'ruleSet'>, fieldsGameCenterMatchmakingRules?: Array<'description' | 'expression' | 'referenceName' | 'ruleSet' | 'type' | 'weight'>, limitMatchmakingQueues?: number, limitRules?: number, limitTeams?: number, _options?: Configuration): Observable<HttpInfo<GameCenterMatchmakingRuleSetsResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterMatchmakingRuleSetsGetCollection(fieldsGameCenterMatchmakingRuleSets, limit, include, fieldsGameCenterMatchmakingQueues, fieldsGameCenterMatchmakingTeams, fieldsGameCenterMatchmakingRules, limitMatchmakingQueues, limitRules, limitTeams, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterMatchmakingRuleSetsGetCollectionWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param fieldsGameCenterMatchmakingRuleSets the fields to include for returned resources of type gameCenterMatchmakingRuleSets
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsGameCenterMatchmakingQueues the fields to include for returned resources of type gameCenterMatchmakingQueues
     * @param fieldsGameCenterMatchmakingTeams the fields to include for returned resources of type gameCenterMatchmakingTeams
     * @param fieldsGameCenterMatchmakingRules the fields to include for returned resources of type gameCenterMatchmakingRules
     * @param limitMatchmakingQueues maximum number of related matchmakingQueues returned (when they are included)
     * @param limitRules maximum number of related rules returned (when they are included)
     * @param limitTeams maximum number of related teams returned (when they are included)
     */
    public gameCenterMatchmakingRuleSetsGetCollection(fieldsGameCenterMatchmakingRuleSets?: Array<'matchmakingQueues' | 'maxPlayers' | 'minPlayers' | 'referenceName' | 'ruleLanguageVersion' | 'rules' | 'teams'>, limit?: number, include?: Array<'matchmakingQueues' | 'rules' | 'teams'>, fieldsGameCenterMatchmakingQueues?: Array<'classicMatchmakingBundleIds' | 'experimentRuleSet' | 'referenceName' | 'ruleSet'>, fieldsGameCenterMatchmakingTeams?: Array<'maxPlayers' | 'minPlayers' | 'referenceName' | 'ruleSet'>, fieldsGameCenterMatchmakingRules?: Array<'description' | 'expression' | 'referenceName' | 'ruleSet' | 'type' | 'weight'>, limitMatchmakingQueues?: number, limitRules?: number, limitTeams?: number, _options?: Configuration): Observable<GameCenterMatchmakingRuleSetsResponse> {
        return this.gameCenterMatchmakingRuleSetsGetCollectionWithHttpInfo(fieldsGameCenterMatchmakingRuleSets, limit, include, fieldsGameCenterMatchmakingQueues, fieldsGameCenterMatchmakingTeams, fieldsGameCenterMatchmakingRules, limitMatchmakingQueues, limitRules, limitTeams, _options).pipe(map((apiResponse: HttpInfo<GameCenterMatchmakingRuleSetsResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterMatchmakingRuleSets the fields to include for returned resources of type gameCenterMatchmakingRuleSets
     * @param include comma-separated list of relationships to include
     * @param fieldsGameCenterMatchmakingQueues the fields to include for returned resources of type gameCenterMatchmakingQueues
     * @param fieldsGameCenterMatchmakingTeams the fields to include for returned resources of type gameCenterMatchmakingTeams
     * @param fieldsGameCenterMatchmakingRules the fields to include for returned resources of type gameCenterMatchmakingRules
     * @param limitMatchmakingQueues maximum number of related matchmakingQueues returned (when they are included)
     * @param limitRules maximum number of related rules returned (when they are included)
     * @param limitTeams maximum number of related teams returned (when they are included)
     */
    public gameCenterMatchmakingRuleSetsGetInstanceWithHttpInfo(id: string, fieldsGameCenterMatchmakingRuleSets?: Array<'matchmakingQueues' | 'maxPlayers' | 'minPlayers' | 'referenceName' | 'ruleLanguageVersion' | 'rules' | 'teams'>, include?: Array<'matchmakingQueues' | 'rules' | 'teams'>, fieldsGameCenterMatchmakingQueues?: Array<'classicMatchmakingBundleIds' | 'experimentRuleSet' | 'referenceName' | 'ruleSet'>, fieldsGameCenterMatchmakingTeams?: Array<'maxPlayers' | 'minPlayers' | 'referenceName' | 'ruleSet'>, fieldsGameCenterMatchmakingRules?: Array<'description' | 'expression' | 'referenceName' | 'ruleSet' | 'type' | 'weight'>, limitMatchmakingQueues?: number, limitRules?: number, limitTeams?: number, _options?: Configuration): Observable<HttpInfo<GameCenterMatchmakingRuleSetResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterMatchmakingRuleSetsGetInstance(id, fieldsGameCenterMatchmakingRuleSets, include, fieldsGameCenterMatchmakingQueues, fieldsGameCenterMatchmakingTeams, fieldsGameCenterMatchmakingRules, limitMatchmakingQueues, limitRules, limitTeams, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterMatchmakingRuleSetsGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterMatchmakingRuleSets the fields to include for returned resources of type gameCenterMatchmakingRuleSets
     * @param include comma-separated list of relationships to include
     * @param fieldsGameCenterMatchmakingQueues the fields to include for returned resources of type gameCenterMatchmakingQueues
     * @param fieldsGameCenterMatchmakingTeams the fields to include for returned resources of type gameCenterMatchmakingTeams
     * @param fieldsGameCenterMatchmakingRules the fields to include for returned resources of type gameCenterMatchmakingRules
     * @param limitMatchmakingQueues maximum number of related matchmakingQueues returned (when they are included)
     * @param limitRules maximum number of related rules returned (when they are included)
     * @param limitTeams maximum number of related teams returned (when they are included)
     */
    public gameCenterMatchmakingRuleSetsGetInstance(id: string, fieldsGameCenterMatchmakingRuleSets?: Array<'matchmakingQueues' | 'maxPlayers' | 'minPlayers' | 'referenceName' | 'ruleLanguageVersion' | 'rules' | 'teams'>, include?: Array<'matchmakingQueues' | 'rules' | 'teams'>, fieldsGameCenterMatchmakingQueues?: Array<'classicMatchmakingBundleIds' | 'experimentRuleSet' | 'referenceName' | 'ruleSet'>, fieldsGameCenterMatchmakingTeams?: Array<'maxPlayers' | 'minPlayers' | 'referenceName' | 'ruleSet'>, fieldsGameCenterMatchmakingRules?: Array<'description' | 'expression' | 'referenceName' | 'ruleSet' | 'type' | 'weight'>, limitMatchmakingQueues?: number, limitRules?: number, limitTeams?: number, _options?: Configuration): Observable<GameCenterMatchmakingRuleSetResponse> {
        return this.gameCenterMatchmakingRuleSetsGetInstanceWithHttpInfo(id, fieldsGameCenterMatchmakingRuleSets, include, fieldsGameCenterMatchmakingQueues, fieldsGameCenterMatchmakingTeams, fieldsGameCenterMatchmakingRules, limitMatchmakingQueues, limitRules, limitTeams, _options).pipe(map((apiResponse: HttpInfo<GameCenterMatchmakingRuleSetResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterMatchmakingQueues the fields to include for returned resources of type gameCenterMatchmakingQueues
     * @param fieldsGameCenterMatchmakingRuleSets the fields to include for returned resources of type gameCenterMatchmakingRuleSets
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public gameCenterMatchmakingRuleSetsMatchmakingQueuesGetToManyRelatedWithHttpInfo(id: string, fieldsGameCenterMatchmakingQueues?: Array<'classicMatchmakingBundleIds' | 'experimentRuleSet' | 'referenceName' | 'ruleSet'>, fieldsGameCenterMatchmakingRuleSets?: Array<'matchmakingQueues' | 'maxPlayers' | 'minPlayers' | 'referenceName' | 'ruleLanguageVersion' | 'rules' | 'teams'>, limit?: number, include?: Array<'experimentRuleSet' | 'ruleSet'>, _options?: Configuration): Observable<HttpInfo<GameCenterMatchmakingQueuesResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterMatchmakingRuleSetsMatchmakingQueuesGetToManyRelated(id, fieldsGameCenterMatchmakingQueues, fieldsGameCenterMatchmakingRuleSets, limit, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterMatchmakingRuleSetsMatchmakingQueuesGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterMatchmakingQueues the fields to include for returned resources of type gameCenterMatchmakingQueues
     * @param fieldsGameCenterMatchmakingRuleSets the fields to include for returned resources of type gameCenterMatchmakingRuleSets
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public gameCenterMatchmakingRuleSetsMatchmakingQueuesGetToManyRelated(id: string, fieldsGameCenterMatchmakingQueues?: Array<'classicMatchmakingBundleIds' | 'experimentRuleSet' | 'referenceName' | 'ruleSet'>, fieldsGameCenterMatchmakingRuleSets?: Array<'matchmakingQueues' | 'maxPlayers' | 'minPlayers' | 'referenceName' | 'ruleLanguageVersion' | 'rules' | 'teams'>, limit?: number, include?: Array<'experimentRuleSet' | 'ruleSet'>, _options?: Configuration): Observable<GameCenterMatchmakingQueuesResponse> {
        return this.gameCenterMatchmakingRuleSetsMatchmakingQueuesGetToManyRelatedWithHttpInfo(id, fieldsGameCenterMatchmakingQueues, fieldsGameCenterMatchmakingRuleSets, limit, include, _options).pipe(map((apiResponse: HttpInfo<GameCenterMatchmakingQueuesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterMatchmakingRules the fields to include for returned resources of type gameCenterMatchmakingRules
     * @param limit maximum resources per page
     */
    public gameCenterMatchmakingRuleSetsRulesGetToManyRelatedWithHttpInfo(id: string, fieldsGameCenterMatchmakingRules?: Array<'description' | 'expression' | 'referenceName' | 'ruleSet' | 'type' | 'weight'>, limit?: number, _options?: Configuration): Observable<HttpInfo<GameCenterMatchmakingRulesResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterMatchmakingRuleSetsRulesGetToManyRelated(id, fieldsGameCenterMatchmakingRules, limit, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterMatchmakingRuleSetsRulesGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterMatchmakingRules the fields to include for returned resources of type gameCenterMatchmakingRules
     * @param limit maximum resources per page
     */
    public gameCenterMatchmakingRuleSetsRulesGetToManyRelated(id: string, fieldsGameCenterMatchmakingRules?: Array<'description' | 'expression' | 'referenceName' | 'ruleSet' | 'type' | 'weight'>, limit?: number, _options?: Configuration): Observable<GameCenterMatchmakingRulesResponse> {
        return this.gameCenterMatchmakingRuleSetsRulesGetToManyRelatedWithHttpInfo(id, fieldsGameCenterMatchmakingRules, limit, _options).pipe(map((apiResponse: HttpInfo<GameCenterMatchmakingRulesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterMatchmakingTeams the fields to include for returned resources of type gameCenterMatchmakingTeams
     * @param limit maximum resources per page
     */
    public gameCenterMatchmakingRuleSetsTeamsGetToManyRelatedWithHttpInfo(id: string, fieldsGameCenterMatchmakingTeams?: Array<'maxPlayers' | 'minPlayers' | 'referenceName' | 'ruleSet'>, limit?: number, _options?: Configuration): Observable<HttpInfo<GameCenterMatchmakingTeamsResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterMatchmakingRuleSetsTeamsGetToManyRelated(id, fieldsGameCenterMatchmakingTeams, limit, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterMatchmakingRuleSetsTeamsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterMatchmakingTeams the fields to include for returned resources of type gameCenterMatchmakingTeams
     * @param limit maximum resources per page
     */
    public gameCenterMatchmakingRuleSetsTeamsGetToManyRelated(id: string, fieldsGameCenterMatchmakingTeams?: Array<'maxPlayers' | 'minPlayers' | 'referenceName' | 'ruleSet'>, limit?: number, _options?: Configuration): Observable<GameCenterMatchmakingTeamsResponse> {
        return this.gameCenterMatchmakingRuleSetsTeamsGetToManyRelatedWithHttpInfo(id, fieldsGameCenterMatchmakingTeams, limit, _options).pipe(map((apiResponse: HttpInfo<GameCenterMatchmakingTeamsResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterMatchmakingRuleSetUpdateRequest GameCenterMatchmakingRuleSet representation
     */
    public gameCenterMatchmakingRuleSetsUpdateInstanceWithHttpInfo(id: string, gameCenterMatchmakingRuleSetUpdateRequest: GameCenterMatchmakingRuleSetUpdateRequest, _options?: Configuration): Observable<HttpInfo<GameCenterMatchmakingRuleSetResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterMatchmakingRuleSetsUpdateInstance(id, gameCenterMatchmakingRuleSetUpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterMatchmakingRuleSetsUpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterMatchmakingRuleSetUpdateRequest GameCenterMatchmakingRuleSet representation
     */
    public gameCenterMatchmakingRuleSetsUpdateInstance(id: string, gameCenterMatchmakingRuleSetUpdateRequest: GameCenterMatchmakingRuleSetUpdateRequest, _options?: Configuration): Observable<GameCenterMatchmakingRuleSetResponse> {
        return this.gameCenterMatchmakingRuleSetsUpdateInstanceWithHttpInfo(id, gameCenterMatchmakingRuleSetUpdateRequest, _options).pipe(map((apiResponse: HttpInfo<GameCenterMatchmakingRuleSetResponse>) => apiResponse.data));
    }

}

import { GameCenterMatchmakingRulesApiRequestFactory, GameCenterMatchmakingRulesApiResponseProcessor} from "../apis/GameCenterMatchmakingRulesApi.ts";
export class ObservableGameCenterMatchmakingRulesApi {
    private requestFactory: GameCenterMatchmakingRulesApiRequestFactory;
    private responseProcessor: GameCenterMatchmakingRulesApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: GameCenterMatchmakingRulesApiRequestFactory,
        responseProcessor?: GameCenterMatchmakingRulesApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new GameCenterMatchmakingRulesApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new GameCenterMatchmakingRulesApiResponseProcessor();
    }

    /**
     * @param gameCenterMatchmakingRuleCreateRequest GameCenterMatchmakingRule representation
     */
    public gameCenterMatchmakingRulesCreateInstanceWithHttpInfo(gameCenterMatchmakingRuleCreateRequest: GameCenterMatchmakingRuleCreateRequest, _options?: Configuration): Observable<HttpInfo<GameCenterMatchmakingRuleResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterMatchmakingRulesCreateInstance(gameCenterMatchmakingRuleCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterMatchmakingRulesCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param gameCenterMatchmakingRuleCreateRequest GameCenterMatchmakingRule representation
     */
    public gameCenterMatchmakingRulesCreateInstance(gameCenterMatchmakingRuleCreateRequest: GameCenterMatchmakingRuleCreateRequest, _options?: Configuration): Observable<GameCenterMatchmakingRuleResponse> {
        return this.gameCenterMatchmakingRulesCreateInstanceWithHttpInfo(gameCenterMatchmakingRuleCreateRequest, _options).pipe(map((apiResponse: HttpInfo<GameCenterMatchmakingRuleResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterMatchmakingRulesDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.gameCenterMatchmakingRulesDeleteInstance(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterMatchmakingRulesDeleteInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterMatchmakingRulesDeleteInstance(id: string, _options?: Configuration): Observable<void> {
        return this.gameCenterMatchmakingRulesDeleteInstanceWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param granularity the granularity of the per-group dataset
     * @param limit maximum number of groups to return per page
     * @param groupBy the dimension by which to group the results
     * @param filterResult filter by \&#39;result\&#39; attribute dimension
     * @param filterGameCenterMatchmakingQueue filter by \&#39;gameCenterMatchmakingQueue\&#39; relationship dimension
     * @param sort comma-separated list of sort expressions; metrics will be sorted as specified
     */
    public gameCenterMatchmakingRulesMatchmakingBooleanRuleResultsGetMetricsWithHttpInfo(id: string, granularity: 'P1D' | 'PT1H' | 'PT15M', limit?: number, groupBy?: Array<'gameCenterMatchmakingQueue' | 'result'>, filterResult?: string, filterGameCenterMatchmakingQueue?: string, sort?: Array<'count' | '-count'>, _options?: Configuration): Observable<HttpInfo<GameCenterMatchmakingBooleanRuleResultsV1MetricResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterMatchmakingRulesMatchmakingBooleanRuleResultsGetMetrics(id, granularity, limit, groupBy, filterResult, filterGameCenterMatchmakingQueue, sort, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterMatchmakingRulesMatchmakingBooleanRuleResultsGetMetricsWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param granularity the granularity of the per-group dataset
     * @param limit maximum number of groups to return per page
     * @param groupBy the dimension by which to group the results
     * @param filterResult filter by \&#39;result\&#39; attribute dimension
     * @param filterGameCenterMatchmakingQueue filter by \&#39;gameCenterMatchmakingQueue\&#39; relationship dimension
     * @param sort comma-separated list of sort expressions; metrics will be sorted as specified
     */
    public gameCenterMatchmakingRulesMatchmakingBooleanRuleResultsGetMetrics(id: string, granularity: 'P1D' | 'PT1H' | 'PT15M', limit?: number, groupBy?: Array<'gameCenterMatchmakingQueue' | 'result'>, filterResult?: string, filterGameCenterMatchmakingQueue?: string, sort?: Array<'count' | '-count'>, _options?: Configuration): Observable<GameCenterMatchmakingBooleanRuleResultsV1MetricResponse> {
        return this.gameCenterMatchmakingRulesMatchmakingBooleanRuleResultsGetMetricsWithHttpInfo(id, granularity, limit, groupBy, filterResult, filterGameCenterMatchmakingQueue, sort, _options).pipe(map((apiResponse: HttpInfo<GameCenterMatchmakingBooleanRuleResultsV1MetricResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param granularity the granularity of the per-group dataset
     * @param limit maximum number of groups to return per page
     * @param groupBy the dimension by which to group the results
     * @param filterGameCenterMatchmakingQueue filter by \&#39;gameCenterMatchmakingQueue\&#39; relationship dimension
     * @param sort comma-separated list of sort expressions; metrics will be sorted as specified
     */
    public gameCenterMatchmakingRulesMatchmakingNumberRuleResultsGetMetricsWithHttpInfo(id: string, granularity: 'P1D' | 'PT1H' | 'PT15M', limit?: number, groupBy?: Array<'gameCenterMatchmakingQueue'>, filterGameCenterMatchmakingQueue?: string, sort?: Array<'averageResult' | '-averageResult' | 'count' | '-count' | 'p50Result' | '-p50Result' | 'p95Result' | '-p95Result'>, _options?: Configuration): Observable<HttpInfo<GameCenterMatchmakingNumberRuleResultsV1MetricResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterMatchmakingRulesMatchmakingNumberRuleResultsGetMetrics(id, granularity, limit, groupBy, filterGameCenterMatchmakingQueue, sort, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterMatchmakingRulesMatchmakingNumberRuleResultsGetMetricsWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param granularity the granularity of the per-group dataset
     * @param limit maximum number of groups to return per page
     * @param groupBy the dimension by which to group the results
     * @param filterGameCenterMatchmakingQueue filter by \&#39;gameCenterMatchmakingQueue\&#39; relationship dimension
     * @param sort comma-separated list of sort expressions; metrics will be sorted as specified
     */
    public gameCenterMatchmakingRulesMatchmakingNumberRuleResultsGetMetrics(id: string, granularity: 'P1D' | 'PT1H' | 'PT15M', limit?: number, groupBy?: Array<'gameCenterMatchmakingQueue'>, filterGameCenterMatchmakingQueue?: string, sort?: Array<'averageResult' | '-averageResult' | 'count' | '-count' | 'p50Result' | '-p50Result' | 'p95Result' | '-p95Result'>, _options?: Configuration): Observable<GameCenterMatchmakingNumberRuleResultsV1MetricResponse> {
        return this.gameCenterMatchmakingRulesMatchmakingNumberRuleResultsGetMetricsWithHttpInfo(id, granularity, limit, groupBy, filterGameCenterMatchmakingQueue, sort, _options).pipe(map((apiResponse: HttpInfo<GameCenterMatchmakingNumberRuleResultsV1MetricResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param granularity the granularity of the per-group dataset
     * @param limit maximum number of groups to return per page
     * @param groupBy the dimension by which to group the results
     * @param filterGameCenterMatchmakingQueue filter by \&#39;gameCenterMatchmakingQueue\&#39; relationship dimension
     * @param sort comma-separated list of sort expressions; metrics will be sorted as specified
     */
    public gameCenterMatchmakingRulesMatchmakingRuleErrorsGetMetricsWithHttpInfo(id: string, granularity: 'P1D' | 'PT1H' | 'PT15M', limit?: number, groupBy?: Array<'gameCenterMatchmakingQueue'>, filterGameCenterMatchmakingQueue?: string, sort?: Array<'count' | '-count'>, _options?: Configuration): Observable<HttpInfo<GameCenterMatchmakingRuleErrorsV1MetricResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterMatchmakingRulesMatchmakingRuleErrorsGetMetrics(id, granularity, limit, groupBy, filterGameCenterMatchmakingQueue, sort, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterMatchmakingRulesMatchmakingRuleErrorsGetMetricsWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param granularity the granularity of the per-group dataset
     * @param limit maximum number of groups to return per page
     * @param groupBy the dimension by which to group the results
     * @param filterGameCenterMatchmakingQueue filter by \&#39;gameCenterMatchmakingQueue\&#39; relationship dimension
     * @param sort comma-separated list of sort expressions; metrics will be sorted as specified
     */
    public gameCenterMatchmakingRulesMatchmakingRuleErrorsGetMetrics(id: string, granularity: 'P1D' | 'PT1H' | 'PT15M', limit?: number, groupBy?: Array<'gameCenterMatchmakingQueue'>, filterGameCenterMatchmakingQueue?: string, sort?: Array<'count' | '-count'>, _options?: Configuration): Observable<GameCenterMatchmakingRuleErrorsV1MetricResponse> {
        return this.gameCenterMatchmakingRulesMatchmakingRuleErrorsGetMetricsWithHttpInfo(id, granularity, limit, groupBy, filterGameCenterMatchmakingQueue, sort, _options).pipe(map((apiResponse: HttpInfo<GameCenterMatchmakingRuleErrorsV1MetricResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterMatchmakingRuleUpdateRequest GameCenterMatchmakingRule representation
     */
    public gameCenterMatchmakingRulesUpdateInstanceWithHttpInfo(id: string, gameCenterMatchmakingRuleUpdateRequest: GameCenterMatchmakingRuleUpdateRequest, _options?: Configuration): Observable<HttpInfo<GameCenterMatchmakingRuleResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterMatchmakingRulesUpdateInstance(id, gameCenterMatchmakingRuleUpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterMatchmakingRulesUpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterMatchmakingRuleUpdateRequest GameCenterMatchmakingRule representation
     */
    public gameCenterMatchmakingRulesUpdateInstance(id: string, gameCenterMatchmakingRuleUpdateRequest: GameCenterMatchmakingRuleUpdateRequest, _options?: Configuration): Observable<GameCenterMatchmakingRuleResponse> {
        return this.gameCenterMatchmakingRulesUpdateInstanceWithHttpInfo(id, gameCenterMatchmakingRuleUpdateRequest, _options).pipe(map((apiResponse: HttpInfo<GameCenterMatchmakingRuleResponse>) => apiResponse.data));
    }

}

import { GameCenterMatchmakingTeamsApiRequestFactory, GameCenterMatchmakingTeamsApiResponseProcessor} from "../apis/GameCenterMatchmakingTeamsApi.ts";
export class ObservableGameCenterMatchmakingTeamsApi {
    private requestFactory: GameCenterMatchmakingTeamsApiRequestFactory;
    private responseProcessor: GameCenterMatchmakingTeamsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: GameCenterMatchmakingTeamsApiRequestFactory,
        responseProcessor?: GameCenterMatchmakingTeamsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new GameCenterMatchmakingTeamsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new GameCenterMatchmakingTeamsApiResponseProcessor();
    }

    /**
     * @param gameCenterMatchmakingTeamCreateRequest GameCenterMatchmakingTeam representation
     */
    public gameCenterMatchmakingTeamsCreateInstanceWithHttpInfo(gameCenterMatchmakingTeamCreateRequest: GameCenterMatchmakingTeamCreateRequest, _options?: Configuration): Observable<HttpInfo<GameCenterMatchmakingTeamResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterMatchmakingTeamsCreateInstance(gameCenterMatchmakingTeamCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterMatchmakingTeamsCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param gameCenterMatchmakingTeamCreateRequest GameCenterMatchmakingTeam representation
     */
    public gameCenterMatchmakingTeamsCreateInstance(gameCenterMatchmakingTeamCreateRequest: GameCenterMatchmakingTeamCreateRequest, _options?: Configuration): Observable<GameCenterMatchmakingTeamResponse> {
        return this.gameCenterMatchmakingTeamsCreateInstanceWithHttpInfo(gameCenterMatchmakingTeamCreateRequest, _options).pipe(map((apiResponse: HttpInfo<GameCenterMatchmakingTeamResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterMatchmakingTeamsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.gameCenterMatchmakingTeamsDeleteInstance(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterMatchmakingTeamsDeleteInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterMatchmakingTeamsDeleteInstance(id: string, _options?: Configuration): Observable<void> {
        return this.gameCenterMatchmakingTeamsDeleteInstanceWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterMatchmakingTeamUpdateRequest GameCenterMatchmakingTeam representation
     */
    public gameCenterMatchmakingTeamsUpdateInstanceWithHttpInfo(id: string, gameCenterMatchmakingTeamUpdateRequest: GameCenterMatchmakingTeamUpdateRequest, _options?: Configuration): Observable<HttpInfo<GameCenterMatchmakingTeamResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterMatchmakingTeamsUpdateInstance(id, gameCenterMatchmakingTeamUpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterMatchmakingTeamsUpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterMatchmakingTeamUpdateRequest GameCenterMatchmakingTeam representation
     */
    public gameCenterMatchmakingTeamsUpdateInstance(id: string, gameCenterMatchmakingTeamUpdateRequest: GameCenterMatchmakingTeamUpdateRequest, _options?: Configuration): Observable<GameCenterMatchmakingTeamResponse> {
        return this.gameCenterMatchmakingTeamsUpdateInstanceWithHttpInfo(id, gameCenterMatchmakingTeamUpdateRequest, _options).pipe(map((apiResponse: HttpInfo<GameCenterMatchmakingTeamResponse>) => apiResponse.data));
    }

}

import { GameCenterPlayerAchievementSubmissionsApiRequestFactory, GameCenterPlayerAchievementSubmissionsApiResponseProcessor} from "../apis/GameCenterPlayerAchievementSubmissionsApi.ts";
export class ObservableGameCenterPlayerAchievementSubmissionsApi {
    private requestFactory: GameCenterPlayerAchievementSubmissionsApiRequestFactory;
    private responseProcessor: GameCenterPlayerAchievementSubmissionsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: GameCenterPlayerAchievementSubmissionsApiRequestFactory,
        responseProcessor?: GameCenterPlayerAchievementSubmissionsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new GameCenterPlayerAchievementSubmissionsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new GameCenterPlayerAchievementSubmissionsApiResponseProcessor();
    }

    /**
     * @param gameCenterPlayerAchievementSubmissionCreateRequest GameCenterPlayerAchievementSubmission representation
     */
    public gameCenterPlayerAchievementSubmissionsCreateInstanceWithHttpInfo(gameCenterPlayerAchievementSubmissionCreateRequest: GameCenterPlayerAchievementSubmissionCreateRequest, _options?: Configuration): Observable<HttpInfo<GameCenterPlayerAchievementSubmissionResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterPlayerAchievementSubmissionsCreateInstance(gameCenterPlayerAchievementSubmissionCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterPlayerAchievementSubmissionsCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param gameCenterPlayerAchievementSubmissionCreateRequest GameCenterPlayerAchievementSubmission representation
     */
    public gameCenterPlayerAchievementSubmissionsCreateInstance(gameCenterPlayerAchievementSubmissionCreateRequest: GameCenterPlayerAchievementSubmissionCreateRequest, _options?: Configuration): Observable<GameCenterPlayerAchievementSubmissionResponse> {
        return this.gameCenterPlayerAchievementSubmissionsCreateInstanceWithHttpInfo(gameCenterPlayerAchievementSubmissionCreateRequest, _options).pipe(map((apiResponse: HttpInfo<GameCenterPlayerAchievementSubmissionResponse>) => apiResponse.data));
    }

}

import { InAppPurchaseAppStoreReviewScreenshotsApiRequestFactory, InAppPurchaseAppStoreReviewScreenshotsApiResponseProcessor} from "../apis/InAppPurchaseAppStoreReviewScreenshotsApi.ts";
export class ObservableInAppPurchaseAppStoreReviewScreenshotsApi {
    private requestFactory: InAppPurchaseAppStoreReviewScreenshotsApiRequestFactory;
    private responseProcessor: InAppPurchaseAppStoreReviewScreenshotsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: InAppPurchaseAppStoreReviewScreenshotsApiRequestFactory,
        responseProcessor?: InAppPurchaseAppStoreReviewScreenshotsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new InAppPurchaseAppStoreReviewScreenshotsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new InAppPurchaseAppStoreReviewScreenshotsApiResponseProcessor();
    }

    /**
     * @param inAppPurchaseAppStoreReviewScreenshotCreateRequest InAppPurchaseAppStoreReviewScreenshot representation
     */
    public inAppPurchaseAppStoreReviewScreenshotsCreateInstanceWithHttpInfo(inAppPurchaseAppStoreReviewScreenshotCreateRequest: InAppPurchaseAppStoreReviewScreenshotCreateRequest, _options?: Configuration): Observable<HttpInfo<InAppPurchaseAppStoreReviewScreenshotResponse>> {
        const requestContextPromise = this.requestFactory.inAppPurchaseAppStoreReviewScreenshotsCreateInstance(inAppPurchaseAppStoreReviewScreenshotCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.inAppPurchaseAppStoreReviewScreenshotsCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param inAppPurchaseAppStoreReviewScreenshotCreateRequest InAppPurchaseAppStoreReviewScreenshot representation
     */
    public inAppPurchaseAppStoreReviewScreenshotsCreateInstance(inAppPurchaseAppStoreReviewScreenshotCreateRequest: InAppPurchaseAppStoreReviewScreenshotCreateRequest, _options?: Configuration): Observable<InAppPurchaseAppStoreReviewScreenshotResponse> {
        return this.inAppPurchaseAppStoreReviewScreenshotsCreateInstanceWithHttpInfo(inAppPurchaseAppStoreReviewScreenshotCreateRequest, _options).pipe(map((apiResponse: HttpInfo<InAppPurchaseAppStoreReviewScreenshotResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public inAppPurchaseAppStoreReviewScreenshotsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.inAppPurchaseAppStoreReviewScreenshotsDeleteInstance(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.inAppPurchaseAppStoreReviewScreenshotsDeleteInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public inAppPurchaseAppStoreReviewScreenshotsDeleteInstance(id: string, _options?: Configuration): Observable<void> {
        return this.inAppPurchaseAppStoreReviewScreenshotsDeleteInstanceWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsInAppPurchaseAppStoreReviewScreenshots the fields to include for returned resources of type inAppPurchaseAppStoreReviewScreenshots
     * @param include comma-separated list of relationships to include
     */
    public inAppPurchaseAppStoreReviewScreenshotsGetInstanceWithHttpInfo(id: string, fieldsInAppPurchaseAppStoreReviewScreenshots?: Array<'assetDeliveryState' | 'assetToken' | 'assetType' | 'fileName' | 'fileSize' | 'imageAsset' | 'inAppPurchaseV2' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, include?: Array<'inAppPurchaseV2'>, _options?: Configuration): Observable<HttpInfo<InAppPurchaseAppStoreReviewScreenshotResponse>> {
        const requestContextPromise = this.requestFactory.inAppPurchaseAppStoreReviewScreenshotsGetInstance(id, fieldsInAppPurchaseAppStoreReviewScreenshots, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.inAppPurchaseAppStoreReviewScreenshotsGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsInAppPurchaseAppStoreReviewScreenshots the fields to include for returned resources of type inAppPurchaseAppStoreReviewScreenshots
     * @param include comma-separated list of relationships to include
     */
    public inAppPurchaseAppStoreReviewScreenshotsGetInstance(id: string, fieldsInAppPurchaseAppStoreReviewScreenshots?: Array<'assetDeliveryState' | 'assetToken' | 'assetType' | 'fileName' | 'fileSize' | 'imageAsset' | 'inAppPurchaseV2' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, include?: Array<'inAppPurchaseV2'>, _options?: Configuration): Observable<InAppPurchaseAppStoreReviewScreenshotResponse> {
        return this.inAppPurchaseAppStoreReviewScreenshotsGetInstanceWithHttpInfo(id, fieldsInAppPurchaseAppStoreReviewScreenshots, include, _options).pipe(map((apiResponse: HttpInfo<InAppPurchaseAppStoreReviewScreenshotResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param inAppPurchaseAppStoreReviewScreenshotUpdateRequest InAppPurchaseAppStoreReviewScreenshot representation
     */
    public inAppPurchaseAppStoreReviewScreenshotsUpdateInstanceWithHttpInfo(id: string, inAppPurchaseAppStoreReviewScreenshotUpdateRequest: InAppPurchaseAppStoreReviewScreenshotUpdateRequest, _options?: Configuration): Observable<HttpInfo<InAppPurchaseAppStoreReviewScreenshotResponse>> {
        const requestContextPromise = this.requestFactory.inAppPurchaseAppStoreReviewScreenshotsUpdateInstance(id, inAppPurchaseAppStoreReviewScreenshotUpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.inAppPurchaseAppStoreReviewScreenshotsUpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param inAppPurchaseAppStoreReviewScreenshotUpdateRequest InAppPurchaseAppStoreReviewScreenshot representation
     */
    public inAppPurchaseAppStoreReviewScreenshotsUpdateInstance(id: string, inAppPurchaseAppStoreReviewScreenshotUpdateRequest: InAppPurchaseAppStoreReviewScreenshotUpdateRequest, _options?: Configuration): Observable<InAppPurchaseAppStoreReviewScreenshotResponse> {
        return this.inAppPurchaseAppStoreReviewScreenshotsUpdateInstanceWithHttpInfo(id, inAppPurchaseAppStoreReviewScreenshotUpdateRequest, _options).pipe(map((apiResponse: HttpInfo<InAppPurchaseAppStoreReviewScreenshotResponse>) => apiResponse.data));
    }

}

import { InAppPurchaseAvailabilitiesApiRequestFactory, InAppPurchaseAvailabilitiesApiResponseProcessor} from "../apis/InAppPurchaseAvailabilitiesApi.ts";
export class ObservableInAppPurchaseAvailabilitiesApi {
    private requestFactory: InAppPurchaseAvailabilitiesApiRequestFactory;
    private responseProcessor: InAppPurchaseAvailabilitiesApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: InAppPurchaseAvailabilitiesApiRequestFactory,
        responseProcessor?: InAppPurchaseAvailabilitiesApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new InAppPurchaseAvailabilitiesApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new InAppPurchaseAvailabilitiesApiResponseProcessor();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limit maximum resources per page
     */
    public inAppPurchaseAvailabilitiesAvailableTerritoriesGetToManyRelatedWithHttpInfo(id: string, fieldsTerritories?: Array<'currency'>, limit?: number, _options?: Configuration): Observable<HttpInfo<TerritoriesResponse>> {
        const requestContextPromise = this.requestFactory.inAppPurchaseAvailabilitiesAvailableTerritoriesGetToManyRelated(id, fieldsTerritories, limit, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.inAppPurchaseAvailabilitiesAvailableTerritoriesGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limit maximum resources per page
     */
    public inAppPurchaseAvailabilitiesAvailableTerritoriesGetToManyRelated(id: string, fieldsTerritories?: Array<'currency'>, limit?: number, _options?: Configuration): Observable<TerritoriesResponse> {
        return this.inAppPurchaseAvailabilitiesAvailableTerritoriesGetToManyRelatedWithHttpInfo(id, fieldsTerritories, limit, _options).pipe(map((apiResponse: HttpInfo<TerritoriesResponse>) => apiResponse.data));
    }

    /**
     * @param inAppPurchaseAvailabilityCreateRequest InAppPurchaseAvailability representation
     */
    public inAppPurchaseAvailabilitiesCreateInstanceWithHttpInfo(inAppPurchaseAvailabilityCreateRequest: InAppPurchaseAvailabilityCreateRequest, _options?: Configuration): Observable<HttpInfo<InAppPurchaseAvailabilityResponse>> {
        const requestContextPromise = this.requestFactory.inAppPurchaseAvailabilitiesCreateInstance(inAppPurchaseAvailabilityCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.inAppPurchaseAvailabilitiesCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param inAppPurchaseAvailabilityCreateRequest InAppPurchaseAvailability representation
     */
    public inAppPurchaseAvailabilitiesCreateInstance(inAppPurchaseAvailabilityCreateRequest: InAppPurchaseAvailabilityCreateRequest, _options?: Configuration): Observable<InAppPurchaseAvailabilityResponse> {
        return this.inAppPurchaseAvailabilitiesCreateInstanceWithHttpInfo(inAppPurchaseAvailabilityCreateRequest, _options).pipe(map((apiResponse: HttpInfo<InAppPurchaseAvailabilityResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsInAppPurchaseAvailabilities the fields to include for returned resources of type inAppPurchaseAvailabilities
     * @param include comma-separated list of relationships to include
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limitAvailableTerritories maximum number of related availableTerritories returned (when they are included)
     */
    public inAppPurchaseAvailabilitiesGetInstanceWithHttpInfo(id: string, fieldsInAppPurchaseAvailabilities?: Array<'availableInNewTerritories' | 'availableTerritories' | 'inAppPurchase'>, include?: Array<'availableTerritories'>, fieldsTerritories?: Array<'currency'>, limitAvailableTerritories?: number, _options?: Configuration): Observable<HttpInfo<InAppPurchaseAvailabilityResponse>> {
        const requestContextPromise = this.requestFactory.inAppPurchaseAvailabilitiesGetInstance(id, fieldsInAppPurchaseAvailabilities, include, fieldsTerritories, limitAvailableTerritories, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.inAppPurchaseAvailabilitiesGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsInAppPurchaseAvailabilities the fields to include for returned resources of type inAppPurchaseAvailabilities
     * @param include comma-separated list of relationships to include
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limitAvailableTerritories maximum number of related availableTerritories returned (when they are included)
     */
    public inAppPurchaseAvailabilitiesGetInstance(id: string, fieldsInAppPurchaseAvailabilities?: Array<'availableInNewTerritories' | 'availableTerritories' | 'inAppPurchase'>, include?: Array<'availableTerritories'>, fieldsTerritories?: Array<'currency'>, limitAvailableTerritories?: number, _options?: Configuration): Observable<InAppPurchaseAvailabilityResponse> {
        return this.inAppPurchaseAvailabilitiesGetInstanceWithHttpInfo(id, fieldsInAppPurchaseAvailabilities, include, fieldsTerritories, limitAvailableTerritories, _options).pipe(map((apiResponse: HttpInfo<InAppPurchaseAvailabilityResponse>) => apiResponse.data));
    }

}

import { InAppPurchaseContentsApiRequestFactory, InAppPurchaseContentsApiResponseProcessor} from "../apis/InAppPurchaseContentsApi.ts";
export class ObservableInAppPurchaseContentsApi {
    private requestFactory: InAppPurchaseContentsApiRequestFactory;
    private responseProcessor: InAppPurchaseContentsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: InAppPurchaseContentsApiRequestFactory,
        responseProcessor?: InAppPurchaseContentsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new InAppPurchaseContentsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new InAppPurchaseContentsApiResponseProcessor();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsInAppPurchaseContents the fields to include for returned resources of type inAppPurchaseContents
     * @param include comma-separated list of relationships to include
     */
    public inAppPurchaseContentsGetInstanceWithHttpInfo(id: string, fieldsInAppPurchaseContents?: Array<'fileName' | 'fileSize' | 'inAppPurchaseV2' | 'lastModifiedDate' | 'url'>, include?: Array<'inAppPurchaseV2'>, _options?: Configuration): Observable<HttpInfo<InAppPurchaseContentResponse>> {
        const requestContextPromise = this.requestFactory.inAppPurchaseContentsGetInstance(id, fieldsInAppPurchaseContents, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.inAppPurchaseContentsGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsInAppPurchaseContents the fields to include for returned resources of type inAppPurchaseContents
     * @param include comma-separated list of relationships to include
     */
    public inAppPurchaseContentsGetInstance(id: string, fieldsInAppPurchaseContents?: Array<'fileName' | 'fileSize' | 'inAppPurchaseV2' | 'lastModifiedDate' | 'url'>, include?: Array<'inAppPurchaseV2'>, _options?: Configuration): Observable<InAppPurchaseContentResponse> {
        return this.inAppPurchaseContentsGetInstanceWithHttpInfo(id, fieldsInAppPurchaseContents, include, _options).pipe(map((apiResponse: HttpInfo<InAppPurchaseContentResponse>) => apiResponse.data));
    }

}

import { InAppPurchaseLocalizationsApiRequestFactory, InAppPurchaseLocalizationsApiResponseProcessor} from "../apis/InAppPurchaseLocalizationsApi.ts";
export class ObservableInAppPurchaseLocalizationsApi {
    private requestFactory: InAppPurchaseLocalizationsApiRequestFactory;
    private responseProcessor: InAppPurchaseLocalizationsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: InAppPurchaseLocalizationsApiRequestFactory,
        responseProcessor?: InAppPurchaseLocalizationsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new InAppPurchaseLocalizationsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new InAppPurchaseLocalizationsApiResponseProcessor();
    }

    /**
     * @param inAppPurchaseLocalizationCreateRequest InAppPurchaseLocalization representation
     */
    public inAppPurchaseLocalizationsCreateInstanceWithHttpInfo(inAppPurchaseLocalizationCreateRequest: InAppPurchaseLocalizationCreateRequest, _options?: Configuration): Observable<HttpInfo<InAppPurchaseLocalizationResponse>> {
        const requestContextPromise = this.requestFactory.inAppPurchaseLocalizationsCreateInstance(inAppPurchaseLocalizationCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.inAppPurchaseLocalizationsCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param inAppPurchaseLocalizationCreateRequest InAppPurchaseLocalization representation
     */
    public inAppPurchaseLocalizationsCreateInstance(inAppPurchaseLocalizationCreateRequest: InAppPurchaseLocalizationCreateRequest, _options?: Configuration): Observable<InAppPurchaseLocalizationResponse> {
        return this.inAppPurchaseLocalizationsCreateInstanceWithHttpInfo(inAppPurchaseLocalizationCreateRequest, _options).pipe(map((apiResponse: HttpInfo<InAppPurchaseLocalizationResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public inAppPurchaseLocalizationsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.inAppPurchaseLocalizationsDeleteInstance(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.inAppPurchaseLocalizationsDeleteInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public inAppPurchaseLocalizationsDeleteInstance(id: string, _options?: Configuration): Observable<void> {
        return this.inAppPurchaseLocalizationsDeleteInstanceWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsInAppPurchaseLocalizations the fields to include for returned resources of type inAppPurchaseLocalizations
     * @param include comma-separated list of relationships to include
     */
    public inAppPurchaseLocalizationsGetInstanceWithHttpInfo(id: string, fieldsInAppPurchaseLocalizations?: Array<'description' | 'inAppPurchaseV2' | 'locale' | 'name' | 'state'>, include?: Array<'inAppPurchaseV2'>, _options?: Configuration): Observable<HttpInfo<InAppPurchaseLocalizationResponse>> {
        const requestContextPromise = this.requestFactory.inAppPurchaseLocalizationsGetInstance(id, fieldsInAppPurchaseLocalizations, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.inAppPurchaseLocalizationsGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsInAppPurchaseLocalizations the fields to include for returned resources of type inAppPurchaseLocalizations
     * @param include comma-separated list of relationships to include
     */
    public inAppPurchaseLocalizationsGetInstance(id: string, fieldsInAppPurchaseLocalizations?: Array<'description' | 'inAppPurchaseV2' | 'locale' | 'name' | 'state'>, include?: Array<'inAppPurchaseV2'>, _options?: Configuration): Observable<InAppPurchaseLocalizationResponse> {
        return this.inAppPurchaseLocalizationsGetInstanceWithHttpInfo(id, fieldsInAppPurchaseLocalizations, include, _options).pipe(map((apiResponse: HttpInfo<InAppPurchaseLocalizationResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param inAppPurchaseLocalizationUpdateRequest InAppPurchaseLocalization representation
     */
    public inAppPurchaseLocalizationsUpdateInstanceWithHttpInfo(id: string, inAppPurchaseLocalizationUpdateRequest: InAppPurchaseLocalizationUpdateRequest, _options?: Configuration): Observable<HttpInfo<InAppPurchaseLocalizationResponse>> {
        const requestContextPromise = this.requestFactory.inAppPurchaseLocalizationsUpdateInstance(id, inAppPurchaseLocalizationUpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.inAppPurchaseLocalizationsUpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param inAppPurchaseLocalizationUpdateRequest InAppPurchaseLocalization representation
     */
    public inAppPurchaseLocalizationsUpdateInstance(id: string, inAppPurchaseLocalizationUpdateRequest: InAppPurchaseLocalizationUpdateRequest, _options?: Configuration): Observable<InAppPurchaseLocalizationResponse> {
        return this.inAppPurchaseLocalizationsUpdateInstanceWithHttpInfo(id, inAppPurchaseLocalizationUpdateRequest, _options).pipe(map((apiResponse: HttpInfo<InAppPurchaseLocalizationResponse>) => apiResponse.data));
    }

}

import { InAppPurchasePriceSchedulesApiRequestFactory, InAppPurchasePriceSchedulesApiResponseProcessor} from "../apis/InAppPurchasePriceSchedulesApi.ts";
export class ObservableInAppPurchasePriceSchedulesApi {
    private requestFactory: InAppPurchasePriceSchedulesApiRequestFactory;
    private responseProcessor: InAppPurchasePriceSchedulesApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: InAppPurchasePriceSchedulesApiRequestFactory,
        responseProcessor?: InAppPurchasePriceSchedulesApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new InAppPurchasePriceSchedulesApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new InAppPurchasePriceSchedulesApiResponseProcessor();
    }

    /**
     * @param id the id of the requested resource
     * @param filterTerritory filter by id(s) of related \&#39;territory\&#39;
     * @param fieldsInAppPurchasePricePoints the fields to include for returned resources of type inAppPurchasePricePoints
     * @param fieldsInAppPurchasePrices the fields to include for returned resources of type inAppPurchasePrices
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public inAppPurchasePriceSchedulesAutomaticPricesGetToManyRelatedWithHttpInfo(id: string, filterTerritory?: Array<string>, fieldsInAppPurchasePricePoints?: Array<'customerPrice' | 'inAppPurchaseV2' | 'priceTier' | 'proceeds' | 'territory'>, fieldsInAppPurchasePrices?: Array<'endDate' | 'inAppPurchasePricePoint' | 'inAppPurchaseV2' | 'manual' | 'startDate' | 'territory'>, fieldsTerritories?: Array<'currency'>, limit?: number, include?: Array<'inAppPurchasePricePoint' | 'territory'>, _options?: Configuration): Observable<HttpInfo<InAppPurchasePricesResponse>> {
        const requestContextPromise = this.requestFactory.inAppPurchasePriceSchedulesAutomaticPricesGetToManyRelated(id, filterTerritory, fieldsInAppPurchasePricePoints, fieldsInAppPurchasePrices, fieldsTerritories, limit, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.inAppPurchasePriceSchedulesAutomaticPricesGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param filterTerritory filter by id(s) of related \&#39;territory\&#39;
     * @param fieldsInAppPurchasePricePoints the fields to include for returned resources of type inAppPurchasePricePoints
     * @param fieldsInAppPurchasePrices the fields to include for returned resources of type inAppPurchasePrices
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public inAppPurchasePriceSchedulesAutomaticPricesGetToManyRelated(id: string, filterTerritory?: Array<string>, fieldsInAppPurchasePricePoints?: Array<'customerPrice' | 'inAppPurchaseV2' | 'priceTier' | 'proceeds' | 'territory'>, fieldsInAppPurchasePrices?: Array<'endDate' | 'inAppPurchasePricePoint' | 'inAppPurchaseV2' | 'manual' | 'startDate' | 'territory'>, fieldsTerritories?: Array<'currency'>, limit?: number, include?: Array<'inAppPurchasePricePoint' | 'territory'>, _options?: Configuration): Observable<InAppPurchasePricesResponse> {
        return this.inAppPurchasePriceSchedulesAutomaticPricesGetToManyRelatedWithHttpInfo(id, filterTerritory, fieldsInAppPurchasePricePoints, fieldsInAppPurchasePrices, fieldsTerritories, limit, include, _options).pipe(map((apiResponse: HttpInfo<InAppPurchasePricesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsTerritories the fields to include for returned resources of type territories
     */
    public inAppPurchasePriceSchedulesBaseTerritoryGetToOneRelatedWithHttpInfo(id: string, fieldsTerritories?: Array<'currency'>, _options?: Configuration): Observable<HttpInfo<TerritoryResponse>> {
        const requestContextPromise = this.requestFactory.inAppPurchasePriceSchedulesBaseTerritoryGetToOneRelated(id, fieldsTerritories, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.inAppPurchasePriceSchedulesBaseTerritoryGetToOneRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsTerritories the fields to include for returned resources of type territories
     */
    public inAppPurchasePriceSchedulesBaseTerritoryGetToOneRelated(id: string, fieldsTerritories?: Array<'currency'>, _options?: Configuration): Observable<TerritoryResponse> {
        return this.inAppPurchasePriceSchedulesBaseTerritoryGetToOneRelatedWithHttpInfo(id, fieldsTerritories, _options).pipe(map((apiResponse: HttpInfo<TerritoryResponse>) => apiResponse.data));
    }

    /**
     * @param inAppPurchasePriceScheduleCreateRequest InAppPurchasePriceSchedule representation
     */
    public inAppPurchasePriceSchedulesCreateInstanceWithHttpInfo(inAppPurchasePriceScheduleCreateRequest: InAppPurchasePriceScheduleCreateRequest, _options?: Configuration): Observable<HttpInfo<InAppPurchasePriceScheduleResponse>> {
        const requestContextPromise = this.requestFactory.inAppPurchasePriceSchedulesCreateInstance(inAppPurchasePriceScheduleCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.inAppPurchasePriceSchedulesCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param inAppPurchasePriceScheduleCreateRequest InAppPurchasePriceSchedule representation
     */
    public inAppPurchasePriceSchedulesCreateInstance(inAppPurchasePriceScheduleCreateRequest: InAppPurchasePriceScheduleCreateRequest, _options?: Configuration): Observable<InAppPurchasePriceScheduleResponse> {
        return this.inAppPurchasePriceSchedulesCreateInstanceWithHttpInfo(inAppPurchasePriceScheduleCreateRequest, _options).pipe(map((apiResponse: HttpInfo<InAppPurchasePriceScheduleResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsInAppPurchasePriceSchedules the fields to include for returned resources of type inAppPurchasePriceSchedules
     * @param include comma-separated list of relationships to include
     * @param fieldsInAppPurchasePrices the fields to include for returned resources of type inAppPurchasePrices
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limitAutomaticPrices maximum number of related automaticPrices returned (when they are included)
     * @param limitManualPrices maximum number of related manualPrices returned (when they are included)
     */
    public inAppPurchasePriceSchedulesGetInstanceWithHttpInfo(id: string, fieldsInAppPurchasePriceSchedules?: Array<'automaticPrices' | 'baseTerritory' | 'inAppPurchase' | 'manualPrices'>, include?: Array<'automaticPrices' | 'baseTerritory' | 'inAppPurchase' | 'manualPrices'>, fieldsInAppPurchasePrices?: Array<'endDate' | 'inAppPurchasePricePoint' | 'inAppPurchaseV2' | 'manual' | 'startDate' | 'territory'>, fieldsTerritories?: Array<'currency'>, limitAutomaticPrices?: number, limitManualPrices?: number, _options?: Configuration): Observable<HttpInfo<InAppPurchasePriceScheduleResponse>> {
        const requestContextPromise = this.requestFactory.inAppPurchasePriceSchedulesGetInstance(id, fieldsInAppPurchasePriceSchedules, include, fieldsInAppPurchasePrices, fieldsTerritories, limitAutomaticPrices, limitManualPrices, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.inAppPurchasePriceSchedulesGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsInAppPurchasePriceSchedules the fields to include for returned resources of type inAppPurchasePriceSchedules
     * @param include comma-separated list of relationships to include
     * @param fieldsInAppPurchasePrices the fields to include for returned resources of type inAppPurchasePrices
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limitAutomaticPrices maximum number of related automaticPrices returned (when they are included)
     * @param limitManualPrices maximum number of related manualPrices returned (when they are included)
     */
    public inAppPurchasePriceSchedulesGetInstance(id: string, fieldsInAppPurchasePriceSchedules?: Array<'automaticPrices' | 'baseTerritory' | 'inAppPurchase' | 'manualPrices'>, include?: Array<'automaticPrices' | 'baseTerritory' | 'inAppPurchase' | 'manualPrices'>, fieldsInAppPurchasePrices?: Array<'endDate' | 'inAppPurchasePricePoint' | 'inAppPurchaseV2' | 'manual' | 'startDate' | 'territory'>, fieldsTerritories?: Array<'currency'>, limitAutomaticPrices?: number, limitManualPrices?: number, _options?: Configuration): Observable<InAppPurchasePriceScheduleResponse> {
        return this.inAppPurchasePriceSchedulesGetInstanceWithHttpInfo(id, fieldsInAppPurchasePriceSchedules, include, fieldsInAppPurchasePrices, fieldsTerritories, limitAutomaticPrices, limitManualPrices, _options).pipe(map((apiResponse: HttpInfo<InAppPurchasePriceScheduleResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param filterTerritory filter by id(s) of related \&#39;territory\&#39;
     * @param fieldsInAppPurchasePricePoints the fields to include for returned resources of type inAppPurchasePricePoints
     * @param fieldsInAppPurchasePrices the fields to include for returned resources of type inAppPurchasePrices
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public inAppPurchasePriceSchedulesManualPricesGetToManyRelatedWithHttpInfo(id: string, filterTerritory?: Array<string>, fieldsInAppPurchasePricePoints?: Array<'customerPrice' | 'inAppPurchaseV2' | 'priceTier' | 'proceeds' | 'territory'>, fieldsInAppPurchasePrices?: Array<'endDate' | 'inAppPurchasePricePoint' | 'inAppPurchaseV2' | 'manual' | 'startDate' | 'territory'>, fieldsTerritories?: Array<'currency'>, limit?: number, include?: Array<'inAppPurchasePricePoint' | 'territory'>, _options?: Configuration): Observable<HttpInfo<InAppPurchasePricesResponse>> {
        const requestContextPromise = this.requestFactory.inAppPurchasePriceSchedulesManualPricesGetToManyRelated(id, filterTerritory, fieldsInAppPurchasePricePoints, fieldsInAppPurchasePrices, fieldsTerritories, limit, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.inAppPurchasePriceSchedulesManualPricesGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param filterTerritory filter by id(s) of related \&#39;territory\&#39;
     * @param fieldsInAppPurchasePricePoints the fields to include for returned resources of type inAppPurchasePricePoints
     * @param fieldsInAppPurchasePrices the fields to include for returned resources of type inAppPurchasePrices
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public inAppPurchasePriceSchedulesManualPricesGetToManyRelated(id: string, filterTerritory?: Array<string>, fieldsInAppPurchasePricePoints?: Array<'customerPrice' | 'inAppPurchaseV2' | 'priceTier' | 'proceeds' | 'territory'>, fieldsInAppPurchasePrices?: Array<'endDate' | 'inAppPurchasePricePoint' | 'inAppPurchaseV2' | 'manual' | 'startDate' | 'territory'>, fieldsTerritories?: Array<'currency'>, limit?: number, include?: Array<'inAppPurchasePricePoint' | 'territory'>, _options?: Configuration): Observable<InAppPurchasePricesResponse> {
        return this.inAppPurchasePriceSchedulesManualPricesGetToManyRelatedWithHttpInfo(id, filterTerritory, fieldsInAppPurchasePricePoints, fieldsInAppPurchasePrices, fieldsTerritories, limit, include, _options).pipe(map((apiResponse: HttpInfo<InAppPurchasePricesResponse>) => apiResponse.data));
    }

}

import { InAppPurchaseSubmissionsApiRequestFactory, InAppPurchaseSubmissionsApiResponseProcessor} from "../apis/InAppPurchaseSubmissionsApi.ts";
export class ObservableInAppPurchaseSubmissionsApi {
    private requestFactory: InAppPurchaseSubmissionsApiRequestFactory;
    private responseProcessor: InAppPurchaseSubmissionsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: InAppPurchaseSubmissionsApiRequestFactory,
        responseProcessor?: InAppPurchaseSubmissionsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new InAppPurchaseSubmissionsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new InAppPurchaseSubmissionsApiResponseProcessor();
    }

    /**
     * @param inAppPurchaseSubmissionCreateRequest InAppPurchaseSubmission representation
     */
    public inAppPurchaseSubmissionsCreateInstanceWithHttpInfo(inAppPurchaseSubmissionCreateRequest: InAppPurchaseSubmissionCreateRequest, _options?: Configuration): Observable<HttpInfo<InAppPurchaseSubmissionResponse>> {
        const requestContextPromise = this.requestFactory.inAppPurchaseSubmissionsCreateInstance(inAppPurchaseSubmissionCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.inAppPurchaseSubmissionsCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param inAppPurchaseSubmissionCreateRequest InAppPurchaseSubmission representation
     */
    public inAppPurchaseSubmissionsCreateInstance(inAppPurchaseSubmissionCreateRequest: InAppPurchaseSubmissionCreateRequest, _options?: Configuration): Observable<InAppPurchaseSubmissionResponse> {
        return this.inAppPurchaseSubmissionsCreateInstanceWithHttpInfo(inAppPurchaseSubmissionCreateRequest, _options).pipe(map((apiResponse: HttpInfo<InAppPurchaseSubmissionResponse>) => apiResponse.data));
    }

}

import { InAppPurchasesApiRequestFactory, InAppPurchasesApiResponseProcessor} from "../apis/InAppPurchasesApi.ts";
export class ObservableInAppPurchasesApi {
    private requestFactory: InAppPurchasesApiRequestFactory;
    private responseProcessor: InAppPurchasesApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: InAppPurchasesApiRequestFactory,
        responseProcessor?: InAppPurchasesApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new InAppPurchasesApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new InAppPurchasesApiResponseProcessor();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsInAppPurchases the fields to include for returned resources of type inAppPurchases
     * @param include comma-separated list of relationships to include
     * @param limitApps maximum number of related apps returned (when they are included)
     */
    public inAppPurchasesGetInstanceWithHttpInfo(id: string, fieldsInAppPurchases?: Array<'apps' | 'inAppPurchaseType' | 'productId' | 'referenceName' | 'state'>, include?: Array<'apps'>, limitApps?: number, _options?: Configuration): Observable<HttpInfo<InAppPurchaseResponse>> {
        const requestContextPromise = this.requestFactory.inAppPurchasesGetInstance(id, fieldsInAppPurchases, include, limitApps, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.inAppPurchasesGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsInAppPurchases the fields to include for returned resources of type inAppPurchases
     * @param include comma-separated list of relationships to include
     * @param limitApps maximum number of related apps returned (when they are included)
     */
    public inAppPurchasesGetInstance(id: string, fieldsInAppPurchases?: Array<'apps' | 'inAppPurchaseType' | 'productId' | 'referenceName' | 'state'>, include?: Array<'apps'>, limitApps?: number, _options?: Configuration): Observable<InAppPurchaseResponse> {
        return this.inAppPurchasesGetInstanceWithHttpInfo(id, fieldsInAppPurchases, include, limitApps, _options).pipe(map((apiResponse: HttpInfo<InAppPurchaseResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsInAppPurchaseAppStoreReviewScreenshots the fields to include for returned resources of type inAppPurchaseAppStoreReviewScreenshots
     * @param fieldsInAppPurchases the fields to include for returned resources of type inAppPurchases
     * @param include comma-separated list of relationships to include
     */
    public inAppPurchasesV2AppStoreReviewScreenshotGetToOneRelatedWithHttpInfo(id: string, fieldsInAppPurchaseAppStoreReviewScreenshots?: Array<'assetDeliveryState' | 'assetToken' | 'assetType' | 'fileName' | 'fileSize' | 'imageAsset' | 'inAppPurchaseV2' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, fieldsInAppPurchases?: Array<'app' | 'appStoreReviewScreenshot' | 'content' | 'contentHosting' | 'familySharable' | 'iapPriceSchedule' | 'inAppPurchaseAvailability' | 'inAppPurchaseLocalizations' | 'inAppPurchaseType' | 'name' | 'pricePoints' | 'productId' | 'promotedPurchase' | 'reviewNote' | 'state'>, include?: Array<'inAppPurchaseV2'>, _options?: Configuration): Observable<HttpInfo<InAppPurchaseAppStoreReviewScreenshotResponse>> {
        const requestContextPromise = this.requestFactory.inAppPurchasesV2AppStoreReviewScreenshotGetToOneRelated(id, fieldsInAppPurchaseAppStoreReviewScreenshots, fieldsInAppPurchases, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.inAppPurchasesV2AppStoreReviewScreenshotGetToOneRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsInAppPurchaseAppStoreReviewScreenshots the fields to include for returned resources of type inAppPurchaseAppStoreReviewScreenshots
     * @param fieldsInAppPurchases the fields to include for returned resources of type inAppPurchases
     * @param include comma-separated list of relationships to include
     */
    public inAppPurchasesV2AppStoreReviewScreenshotGetToOneRelated(id: string, fieldsInAppPurchaseAppStoreReviewScreenshots?: Array<'assetDeliveryState' | 'assetToken' | 'assetType' | 'fileName' | 'fileSize' | 'imageAsset' | 'inAppPurchaseV2' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, fieldsInAppPurchases?: Array<'app' | 'appStoreReviewScreenshot' | 'content' | 'contentHosting' | 'familySharable' | 'iapPriceSchedule' | 'inAppPurchaseAvailability' | 'inAppPurchaseLocalizations' | 'inAppPurchaseType' | 'name' | 'pricePoints' | 'productId' | 'promotedPurchase' | 'reviewNote' | 'state'>, include?: Array<'inAppPurchaseV2'>, _options?: Configuration): Observable<InAppPurchaseAppStoreReviewScreenshotResponse> {
        return this.inAppPurchasesV2AppStoreReviewScreenshotGetToOneRelatedWithHttpInfo(id, fieldsInAppPurchaseAppStoreReviewScreenshots, fieldsInAppPurchases, include, _options).pipe(map((apiResponse: HttpInfo<InAppPurchaseAppStoreReviewScreenshotResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsInAppPurchases the fields to include for returned resources of type inAppPurchases
     * @param fieldsInAppPurchaseContents the fields to include for returned resources of type inAppPurchaseContents
     * @param include comma-separated list of relationships to include
     */
    public inAppPurchasesV2ContentGetToOneRelatedWithHttpInfo(id: string, fieldsInAppPurchases?: Array<'app' | 'appStoreReviewScreenshot' | 'content' | 'contentHosting' | 'familySharable' | 'iapPriceSchedule' | 'inAppPurchaseAvailability' | 'inAppPurchaseLocalizations' | 'inAppPurchaseType' | 'name' | 'pricePoints' | 'productId' | 'promotedPurchase' | 'reviewNote' | 'state'>, fieldsInAppPurchaseContents?: Array<'fileName' | 'fileSize' | 'inAppPurchaseV2' | 'lastModifiedDate' | 'url'>, include?: Array<'inAppPurchaseV2'>, _options?: Configuration): Observable<HttpInfo<InAppPurchaseContentResponse>> {
        const requestContextPromise = this.requestFactory.inAppPurchasesV2ContentGetToOneRelated(id, fieldsInAppPurchases, fieldsInAppPurchaseContents, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.inAppPurchasesV2ContentGetToOneRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsInAppPurchases the fields to include for returned resources of type inAppPurchases
     * @param fieldsInAppPurchaseContents the fields to include for returned resources of type inAppPurchaseContents
     * @param include comma-separated list of relationships to include
     */
    public inAppPurchasesV2ContentGetToOneRelated(id: string, fieldsInAppPurchases?: Array<'app' | 'appStoreReviewScreenshot' | 'content' | 'contentHosting' | 'familySharable' | 'iapPriceSchedule' | 'inAppPurchaseAvailability' | 'inAppPurchaseLocalizations' | 'inAppPurchaseType' | 'name' | 'pricePoints' | 'productId' | 'promotedPurchase' | 'reviewNote' | 'state'>, fieldsInAppPurchaseContents?: Array<'fileName' | 'fileSize' | 'inAppPurchaseV2' | 'lastModifiedDate' | 'url'>, include?: Array<'inAppPurchaseV2'>, _options?: Configuration): Observable<InAppPurchaseContentResponse> {
        return this.inAppPurchasesV2ContentGetToOneRelatedWithHttpInfo(id, fieldsInAppPurchases, fieldsInAppPurchaseContents, include, _options).pipe(map((apiResponse: HttpInfo<InAppPurchaseContentResponse>) => apiResponse.data));
    }

    /**
     * @param inAppPurchaseV2CreateRequest InAppPurchase representation
     */
    public inAppPurchasesV2CreateInstanceWithHttpInfo(inAppPurchaseV2CreateRequest: InAppPurchaseV2CreateRequest, _options?: Configuration): Observable<HttpInfo<InAppPurchaseV2Response>> {
        const requestContextPromise = this.requestFactory.inAppPurchasesV2CreateInstance(inAppPurchaseV2CreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.inAppPurchasesV2CreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param inAppPurchaseV2CreateRequest InAppPurchase representation
     */
    public inAppPurchasesV2CreateInstance(inAppPurchaseV2CreateRequest: InAppPurchaseV2CreateRequest, _options?: Configuration): Observable<InAppPurchaseV2Response> {
        return this.inAppPurchasesV2CreateInstanceWithHttpInfo(inAppPurchaseV2CreateRequest, _options).pipe(map((apiResponse: HttpInfo<InAppPurchaseV2Response>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public inAppPurchasesV2DeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.inAppPurchasesV2DeleteInstance(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.inAppPurchasesV2DeleteInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public inAppPurchasesV2DeleteInstance(id: string, _options?: Configuration): Observable<void> {
        return this.inAppPurchasesV2DeleteInstanceWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsInAppPurchases the fields to include for returned resources of type inAppPurchases
     * @param include comma-separated list of relationships to include
     * @param fieldsInAppPurchaseAvailabilities the fields to include for returned resources of type inAppPurchaseAvailabilities
     * @param fieldsInAppPurchaseAppStoreReviewScreenshots the fields to include for returned resources of type inAppPurchaseAppStoreReviewScreenshots
     * @param fieldsPromotedPurchases the fields to include for returned resources of type promotedPurchases
     * @param fieldsInAppPurchasePricePoints the fields to include for returned resources of type inAppPurchasePricePoints
     * @param fieldsInAppPurchaseLocalizations the fields to include for returned resources of type inAppPurchaseLocalizations
     * @param fieldsInAppPurchasePriceSchedules the fields to include for returned resources of type inAppPurchasePriceSchedules
     * @param fieldsInAppPurchaseContents the fields to include for returned resources of type inAppPurchaseContents
     * @param limitInAppPurchaseLocalizations maximum number of related inAppPurchaseLocalizations returned (when they are included)
     * @param limitPricePoints maximum number of related pricePoints returned (when they are included)
     */
    public inAppPurchasesV2GetInstanceWithHttpInfo(id: string, fieldsInAppPurchases?: Array<'app' | 'appStoreReviewScreenshot' | 'content' | 'contentHosting' | 'familySharable' | 'iapPriceSchedule' | 'inAppPurchaseAvailability' | 'inAppPurchaseLocalizations' | 'inAppPurchaseType' | 'name' | 'pricePoints' | 'productId' | 'promotedPurchase' | 'reviewNote' | 'state'>, include?: Array<'appStoreReviewScreenshot' | 'content' | 'iapPriceSchedule' | 'inAppPurchaseAvailability' | 'inAppPurchaseLocalizations' | 'pricePoints' | 'promotedPurchase'>, fieldsInAppPurchaseAvailabilities?: Array<'availableInNewTerritories' | 'availableTerritories' | 'inAppPurchase'>, fieldsInAppPurchaseAppStoreReviewScreenshots?: Array<'assetDeliveryState' | 'assetToken' | 'assetType' | 'fileName' | 'fileSize' | 'imageAsset' | 'inAppPurchaseV2' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, fieldsPromotedPurchases?: Array<'app' | 'enabled' | 'inAppPurchaseV2' | 'promotionImages' | 'state' | 'subscription' | 'visibleForAllUsers'>, fieldsInAppPurchasePricePoints?: Array<'customerPrice' | 'inAppPurchaseV2' | 'priceTier' | 'proceeds' | 'territory'>, fieldsInAppPurchaseLocalizations?: Array<'description' | 'inAppPurchaseV2' | 'locale' | 'name' | 'state'>, fieldsInAppPurchasePriceSchedules?: Array<'automaticPrices' | 'baseTerritory' | 'inAppPurchase' | 'manualPrices'>, fieldsInAppPurchaseContents?: Array<'fileName' | 'fileSize' | 'inAppPurchaseV2' | 'lastModifiedDate' | 'url'>, limitInAppPurchaseLocalizations?: number, limitPricePoints?: number, _options?: Configuration): Observable<HttpInfo<InAppPurchaseV2Response>> {
        const requestContextPromise = this.requestFactory.inAppPurchasesV2GetInstance(id, fieldsInAppPurchases, include, fieldsInAppPurchaseAvailabilities, fieldsInAppPurchaseAppStoreReviewScreenshots, fieldsPromotedPurchases, fieldsInAppPurchasePricePoints, fieldsInAppPurchaseLocalizations, fieldsInAppPurchasePriceSchedules, fieldsInAppPurchaseContents, limitInAppPurchaseLocalizations, limitPricePoints, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.inAppPurchasesV2GetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsInAppPurchases the fields to include for returned resources of type inAppPurchases
     * @param include comma-separated list of relationships to include
     * @param fieldsInAppPurchaseAvailabilities the fields to include for returned resources of type inAppPurchaseAvailabilities
     * @param fieldsInAppPurchaseAppStoreReviewScreenshots the fields to include for returned resources of type inAppPurchaseAppStoreReviewScreenshots
     * @param fieldsPromotedPurchases the fields to include for returned resources of type promotedPurchases
     * @param fieldsInAppPurchasePricePoints the fields to include for returned resources of type inAppPurchasePricePoints
     * @param fieldsInAppPurchaseLocalizations the fields to include for returned resources of type inAppPurchaseLocalizations
     * @param fieldsInAppPurchasePriceSchedules the fields to include for returned resources of type inAppPurchasePriceSchedules
     * @param fieldsInAppPurchaseContents the fields to include for returned resources of type inAppPurchaseContents
     * @param limitInAppPurchaseLocalizations maximum number of related inAppPurchaseLocalizations returned (when they are included)
     * @param limitPricePoints maximum number of related pricePoints returned (when they are included)
     */
    public inAppPurchasesV2GetInstance(id: string, fieldsInAppPurchases?: Array<'app' | 'appStoreReviewScreenshot' | 'content' | 'contentHosting' | 'familySharable' | 'iapPriceSchedule' | 'inAppPurchaseAvailability' | 'inAppPurchaseLocalizations' | 'inAppPurchaseType' | 'name' | 'pricePoints' | 'productId' | 'promotedPurchase' | 'reviewNote' | 'state'>, include?: Array<'appStoreReviewScreenshot' | 'content' | 'iapPriceSchedule' | 'inAppPurchaseAvailability' | 'inAppPurchaseLocalizations' | 'pricePoints' | 'promotedPurchase'>, fieldsInAppPurchaseAvailabilities?: Array<'availableInNewTerritories' | 'availableTerritories' | 'inAppPurchase'>, fieldsInAppPurchaseAppStoreReviewScreenshots?: Array<'assetDeliveryState' | 'assetToken' | 'assetType' | 'fileName' | 'fileSize' | 'imageAsset' | 'inAppPurchaseV2' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, fieldsPromotedPurchases?: Array<'app' | 'enabled' | 'inAppPurchaseV2' | 'promotionImages' | 'state' | 'subscription' | 'visibleForAllUsers'>, fieldsInAppPurchasePricePoints?: Array<'customerPrice' | 'inAppPurchaseV2' | 'priceTier' | 'proceeds' | 'territory'>, fieldsInAppPurchaseLocalizations?: Array<'description' | 'inAppPurchaseV2' | 'locale' | 'name' | 'state'>, fieldsInAppPurchasePriceSchedules?: Array<'automaticPrices' | 'baseTerritory' | 'inAppPurchase' | 'manualPrices'>, fieldsInAppPurchaseContents?: Array<'fileName' | 'fileSize' | 'inAppPurchaseV2' | 'lastModifiedDate' | 'url'>, limitInAppPurchaseLocalizations?: number, limitPricePoints?: number, _options?: Configuration): Observable<InAppPurchaseV2Response> {
        return this.inAppPurchasesV2GetInstanceWithHttpInfo(id, fieldsInAppPurchases, include, fieldsInAppPurchaseAvailabilities, fieldsInAppPurchaseAppStoreReviewScreenshots, fieldsPromotedPurchases, fieldsInAppPurchasePricePoints, fieldsInAppPurchaseLocalizations, fieldsInAppPurchasePriceSchedules, fieldsInAppPurchaseContents, limitInAppPurchaseLocalizations, limitPricePoints, _options).pipe(map((apiResponse: HttpInfo<InAppPurchaseV2Response>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsInAppPurchasePrices the fields to include for returned resources of type inAppPurchasePrices
     * @param fieldsInAppPurchases the fields to include for returned resources of type inAppPurchases
     * @param fieldsInAppPurchasePriceSchedules the fields to include for returned resources of type inAppPurchasePriceSchedules
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limitManualPrices maximum number of related manualPrices returned (when they are included)
     * @param limitAutomaticPrices maximum number of related automaticPrices returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public inAppPurchasesV2IapPriceScheduleGetToOneRelatedWithHttpInfo(id: string, fieldsInAppPurchasePrices?: Array<'endDate' | 'inAppPurchasePricePoint' | 'inAppPurchaseV2' | 'manual' | 'startDate' | 'territory'>, fieldsInAppPurchases?: Array<'app' | 'appStoreReviewScreenshot' | 'content' | 'contentHosting' | 'familySharable' | 'iapPriceSchedule' | 'inAppPurchaseAvailability' | 'inAppPurchaseLocalizations' | 'inAppPurchaseType' | 'name' | 'pricePoints' | 'productId' | 'promotedPurchase' | 'reviewNote' | 'state'>, fieldsInAppPurchasePriceSchedules?: Array<'automaticPrices' | 'baseTerritory' | 'inAppPurchase' | 'manualPrices'>, fieldsTerritories?: Array<'currency'>, limitManualPrices?: number, limitAutomaticPrices?: number, include?: Array<'automaticPrices' | 'baseTerritory' | 'inAppPurchase' | 'manualPrices'>, _options?: Configuration): Observable<HttpInfo<InAppPurchasePriceScheduleResponse>> {
        const requestContextPromise = this.requestFactory.inAppPurchasesV2IapPriceScheduleGetToOneRelated(id, fieldsInAppPurchasePrices, fieldsInAppPurchases, fieldsInAppPurchasePriceSchedules, fieldsTerritories, limitManualPrices, limitAutomaticPrices, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.inAppPurchasesV2IapPriceScheduleGetToOneRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsInAppPurchasePrices the fields to include for returned resources of type inAppPurchasePrices
     * @param fieldsInAppPurchases the fields to include for returned resources of type inAppPurchases
     * @param fieldsInAppPurchasePriceSchedules the fields to include for returned resources of type inAppPurchasePriceSchedules
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limitManualPrices maximum number of related manualPrices returned (when they are included)
     * @param limitAutomaticPrices maximum number of related automaticPrices returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public inAppPurchasesV2IapPriceScheduleGetToOneRelated(id: string, fieldsInAppPurchasePrices?: Array<'endDate' | 'inAppPurchasePricePoint' | 'inAppPurchaseV2' | 'manual' | 'startDate' | 'territory'>, fieldsInAppPurchases?: Array<'app' | 'appStoreReviewScreenshot' | 'content' | 'contentHosting' | 'familySharable' | 'iapPriceSchedule' | 'inAppPurchaseAvailability' | 'inAppPurchaseLocalizations' | 'inAppPurchaseType' | 'name' | 'pricePoints' | 'productId' | 'promotedPurchase' | 'reviewNote' | 'state'>, fieldsInAppPurchasePriceSchedules?: Array<'automaticPrices' | 'baseTerritory' | 'inAppPurchase' | 'manualPrices'>, fieldsTerritories?: Array<'currency'>, limitManualPrices?: number, limitAutomaticPrices?: number, include?: Array<'automaticPrices' | 'baseTerritory' | 'inAppPurchase' | 'manualPrices'>, _options?: Configuration): Observable<InAppPurchasePriceScheduleResponse> {
        return this.inAppPurchasesV2IapPriceScheduleGetToOneRelatedWithHttpInfo(id, fieldsInAppPurchasePrices, fieldsInAppPurchases, fieldsInAppPurchasePriceSchedules, fieldsTerritories, limitManualPrices, limitAutomaticPrices, include, _options).pipe(map((apiResponse: HttpInfo<InAppPurchasePriceScheduleResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsInAppPurchaseAvailabilities the fields to include for returned resources of type inAppPurchaseAvailabilities
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limitAvailableTerritories maximum number of related availableTerritories returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public inAppPurchasesV2InAppPurchaseAvailabilityGetToOneRelatedWithHttpInfo(id: string, fieldsInAppPurchaseAvailabilities?: Array<'availableInNewTerritories' | 'availableTerritories' | 'inAppPurchase'>, fieldsTerritories?: Array<'currency'>, limitAvailableTerritories?: number, include?: Array<'availableTerritories'>, _options?: Configuration): Observable<HttpInfo<InAppPurchaseAvailabilityResponse>> {
        const requestContextPromise = this.requestFactory.inAppPurchasesV2InAppPurchaseAvailabilityGetToOneRelated(id, fieldsInAppPurchaseAvailabilities, fieldsTerritories, limitAvailableTerritories, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.inAppPurchasesV2InAppPurchaseAvailabilityGetToOneRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsInAppPurchaseAvailabilities the fields to include for returned resources of type inAppPurchaseAvailabilities
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limitAvailableTerritories maximum number of related availableTerritories returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public inAppPurchasesV2InAppPurchaseAvailabilityGetToOneRelated(id: string, fieldsInAppPurchaseAvailabilities?: Array<'availableInNewTerritories' | 'availableTerritories' | 'inAppPurchase'>, fieldsTerritories?: Array<'currency'>, limitAvailableTerritories?: number, include?: Array<'availableTerritories'>, _options?: Configuration): Observable<InAppPurchaseAvailabilityResponse> {
        return this.inAppPurchasesV2InAppPurchaseAvailabilityGetToOneRelatedWithHttpInfo(id, fieldsInAppPurchaseAvailabilities, fieldsTerritories, limitAvailableTerritories, include, _options).pipe(map((apiResponse: HttpInfo<InAppPurchaseAvailabilityResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsInAppPurchaseLocalizations the fields to include for returned resources of type inAppPurchaseLocalizations
     * @param fieldsInAppPurchases the fields to include for returned resources of type inAppPurchases
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public inAppPurchasesV2InAppPurchaseLocalizationsGetToManyRelatedWithHttpInfo(id: string, fieldsInAppPurchaseLocalizations?: Array<'description' | 'inAppPurchaseV2' | 'locale' | 'name' | 'state'>, fieldsInAppPurchases?: Array<'app' | 'appStoreReviewScreenshot' | 'content' | 'contentHosting' | 'familySharable' | 'iapPriceSchedule' | 'inAppPurchaseAvailability' | 'inAppPurchaseLocalizations' | 'inAppPurchaseType' | 'name' | 'pricePoints' | 'productId' | 'promotedPurchase' | 'reviewNote' | 'state'>, limit?: number, include?: Array<'inAppPurchaseV2'>, _options?: Configuration): Observable<HttpInfo<InAppPurchaseLocalizationsResponse>> {
        const requestContextPromise = this.requestFactory.inAppPurchasesV2InAppPurchaseLocalizationsGetToManyRelated(id, fieldsInAppPurchaseLocalizations, fieldsInAppPurchases, limit, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.inAppPurchasesV2InAppPurchaseLocalizationsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsInAppPurchaseLocalizations the fields to include for returned resources of type inAppPurchaseLocalizations
     * @param fieldsInAppPurchases the fields to include for returned resources of type inAppPurchases
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public inAppPurchasesV2InAppPurchaseLocalizationsGetToManyRelated(id: string, fieldsInAppPurchaseLocalizations?: Array<'description' | 'inAppPurchaseV2' | 'locale' | 'name' | 'state'>, fieldsInAppPurchases?: Array<'app' | 'appStoreReviewScreenshot' | 'content' | 'contentHosting' | 'familySharable' | 'iapPriceSchedule' | 'inAppPurchaseAvailability' | 'inAppPurchaseLocalizations' | 'inAppPurchaseType' | 'name' | 'pricePoints' | 'productId' | 'promotedPurchase' | 'reviewNote' | 'state'>, limit?: number, include?: Array<'inAppPurchaseV2'>, _options?: Configuration): Observable<InAppPurchaseLocalizationsResponse> {
        return this.inAppPurchasesV2InAppPurchaseLocalizationsGetToManyRelatedWithHttpInfo(id, fieldsInAppPurchaseLocalizations, fieldsInAppPurchases, limit, include, _options).pipe(map((apiResponse: HttpInfo<InAppPurchaseLocalizationsResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param filterPriceTier filter by attribute \&#39;priceTier\&#39;
     * @param filterTerritory filter by id(s) of related \&#39;territory\&#39;
     * @param fieldsInAppPurchasePricePoints the fields to include for returned resources of type inAppPurchasePricePoints
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public inAppPurchasesV2PricePointsGetToManyRelatedWithHttpInfo(id: string, filterPriceTier?: Array<string>, filterTerritory?: Array<string>, fieldsInAppPurchasePricePoints?: Array<'customerPrice' | 'inAppPurchaseV2' | 'priceTier' | 'proceeds' | 'territory'>, fieldsTerritories?: Array<'currency'>, limit?: number, include?: Array<'territory'>, _options?: Configuration): Observable<HttpInfo<InAppPurchasePricePointsResponse>> {
        const requestContextPromise = this.requestFactory.inAppPurchasesV2PricePointsGetToManyRelated(id, filterPriceTier, filterTerritory, fieldsInAppPurchasePricePoints, fieldsTerritories, limit, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.inAppPurchasesV2PricePointsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param filterPriceTier filter by attribute \&#39;priceTier\&#39;
     * @param filterTerritory filter by id(s) of related \&#39;territory\&#39;
     * @param fieldsInAppPurchasePricePoints the fields to include for returned resources of type inAppPurchasePricePoints
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public inAppPurchasesV2PricePointsGetToManyRelated(id: string, filterPriceTier?: Array<string>, filterTerritory?: Array<string>, fieldsInAppPurchasePricePoints?: Array<'customerPrice' | 'inAppPurchaseV2' | 'priceTier' | 'proceeds' | 'territory'>, fieldsTerritories?: Array<'currency'>, limit?: number, include?: Array<'territory'>, _options?: Configuration): Observable<InAppPurchasePricePointsResponse> {
        return this.inAppPurchasesV2PricePointsGetToManyRelatedWithHttpInfo(id, filterPriceTier, filterTerritory, fieldsInAppPurchasePricePoints, fieldsTerritories, limit, include, _options).pipe(map((apiResponse: HttpInfo<InAppPurchasePricePointsResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsPromotedPurchases the fields to include for returned resources of type promotedPurchases
     * @param fieldsSubscriptions the fields to include for returned resources of type subscriptions
     * @param fieldsInAppPurchases the fields to include for returned resources of type inAppPurchases
     * @param fieldsPromotedPurchaseImages the fields to include for returned resources of type promotedPurchaseImages
     * @param limitPromotionImages maximum number of related promotionImages returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public inAppPurchasesV2PromotedPurchaseGetToOneRelatedWithHttpInfo(id: string, fieldsPromotedPurchases?: Array<'app' | 'enabled' | 'inAppPurchaseV2' | 'promotionImages' | 'state' | 'subscription' | 'visibleForAllUsers'>, fieldsSubscriptions?: Array<'appStoreReviewScreenshot' | 'familySharable' | 'group' | 'groupLevel' | 'introductoryOffers' | 'name' | 'offerCodes' | 'pricePoints' | 'prices' | 'productId' | 'promotedPurchase' | 'promotionalOffers' | 'reviewNote' | 'state' | 'subscriptionAvailability' | 'subscriptionLocalizations' | 'subscriptionPeriod'>, fieldsInAppPurchases?: Array<'app' | 'appStoreReviewScreenshot' | 'content' | 'contentHosting' | 'familySharable' | 'iapPriceSchedule' | 'inAppPurchaseAvailability' | 'inAppPurchaseLocalizations' | 'inAppPurchaseType' | 'name' | 'pricePoints' | 'productId' | 'promotedPurchase' | 'reviewNote' | 'state'>, fieldsPromotedPurchaseImages?: Array<'assetToken' | 'assetType' | 'fileName' | 'fileSize' | 'imageAsset' | 'promotedPurchase' | 'sourceFileChecksum' | 'state' | 'uploadOperations' | 'uploaded'>, limitPromotionImages?: number, include?: Array<'inAppPurchaseV2' | 'promotionImages' | 'subscription'>, _options?: Configuration): Observable<HttpInfo<PromotedPurchaseResponse>> {
        const requestContextPromise = this.requestFactory.inAppPurchasesV2PromotedPurchaseGetToOneRelated(id, fieldsPromotedPurchases, fieldsSubscriptions, fieldsInAppPurchases, fieldsPromotedPurchaseImages, limitPromotionImages, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.inAppPurchasesV2PromotedPurchaseGetToOneRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsPromotedPurchases the fields to include for returned resources of type promotedPurchases
     * @param fieldsSubscriptions the fields to include for returned resources of type subscriptions
     * @param fieldsInAppPurchases the fields to include for returned resources of type inAppPurchases
     * @param fieldsPromotedPurchaseImages the fields to include for returned resources of type promotedPurchaseImages
     * @param limitPromotionImages maximum number of related promotionImages returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public inAppPurchasesV2PromotedPurchaseGetToOneRelated(id: string, fieldsPromotedPurchases?: Array<'app' | 'enabled' | 'inAppPurchaseV2' | 'promotionImages' | 'state' | 'subscription' | 'visibleForAllUsers'>, fieldsSubscriptions?: Array<'appStoreReviewScreenshot' | 'familySharable' | 'group' | 'groupLevel' | 'introductoryOffers' | 'name' | 'offerCodes' | 'pricePoints' | 'prices' | 'productId' | 'promotedPurchase' | 'promotionalOffers' | 'reviewNote' | 'state' | 'subscriptionAvailability' | 'subscriptionLocalizations' | 'subscriptionPeriod'>, fieldsInAppPurchases?: Array<'app' | 'appStoreReviewScreenshot' | 'content' | 'contentHosting' | 'familySharable' | 'iapPriceSchedule' | 'inAppPurchaseAvailability' | 'inAppPurchaseLocalizations' | 'inAppPurchaseType' | 'name' | 'pricePoints' | 'productId' | 'promotedPurchase' | 'reviewNote' | 'state'>, fieldsPromotedPurchaseImages?: Array<'assetToken' | 'assetType' | 'fileName' | 'fileSize' | 'imageAsset' | 'promotedPurchase' | 'sourceFileChecksum' | 'state' | 'uploadOperations' | 'uploaded'>, limitPromotionImages?: number, include?: Array<'inAppPurchaseV2' | 'promotionImages' | 'subscription'>, _options?: Configuration): Observable<PromotedPurchaseResponse> {
        return this.inAppPurchasesV2PromotedPurchaseGetToOneRelatedWithHttpInfo(id, fieldsPromotedPurchases, fieldsSubscriptions, fieldsInAppPurchases, fieldsPromotedPurchaseImages, limitPromotionImages, include, _options).pipe(map((apiResponse: HttpInfo<PromotedPurchaseResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param inAppPurchaseV2UpdateRequest InAppPurchase representation
     */
    public inAppPurchasesV2UpdateInstanceWithHttpInfo(id: string, inAppPurchaseV2UpdateRequest: InAppPurchaseV2UpdateRequest, _options?: Configuration): Observable<HttpInfo<InAppPurchaseV2Response>> {
        const requestContextPromise = this.requestFactory.inAppPurchasesV2UpdateInstance(id, inAppPurchaseV2UpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.inAppPurchasesV2UpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param inAppPurchaseV2UpdateRequest InAppPurchase representation
     */
    public inAppPurchasesV2UpdateInstance(id: string, inAppPurchaseV2UpdateRequest: InAppPurchaseV2UpdateRequest, _options?: Configuration): Observable<InAppPurchaseV2Response> {
        return this.inAppPurchasesV2UpdateInstanceWithHttpInfo(id, inAppPurchaseV2UpdateRequest, _options).pipe(map((apiResponse: HttpInfo<InAppPurchaseV2Response>) => apiResponse.data));
    }

}

import { MarketplaceDomainsApiRequestFactory, MarketplaceDomainsApiResponseProcessor} from "../apis/MarketplaceDomainsApi.ts";
export class ObservableMarketplaceDomainsApi {
    private requestFactory: MarketplaceDomainsApiRequestFactory;
    private responseProcessor: MarketplaceDomainsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: MarketplaceDomainsApiRequestFactory,
        responseProcessor?: MarketplaceDomainsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new MarketplaceDomainsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new MarketplaceDomainsApiResponseProcessor();
    }

    /**
     * @param marketplaceDomainCreateRequest MarketplaceDomain representation
     */
    public marketplaceDomainsCreateInstanceWithHttpInfo(marketplaceDomainCreateRequest: MarketplaceDomainCreateRequest, _options?: Configuration): Observable<HttpInfo<MarketplaceDomainResponse>> {
        const requestContextPromise = this.requestFactory.marketplaceDomainsCreateInstance(marketplaceDomainCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.marketplaceDomainsCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param marketplaceDomainCreateRequest MarketplaceDomain representation
     */
    public marketplaceDomainsCreateInstance(marketplaceDomainCreateRequest: MarketplaceDomainCreateRequest, _options?: Configuration): Observable<MarketplaceDomainResponse> {
        return this.marketplaceDomainsCreateInstanceWithHttpInfo(marketplaceDomainCreateRequest, _options).pipe(map((apiResponse: HttpInfo<MarketplaceDomainResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public marketplaceDomainsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.marketplaceDomainsDeleteInstance(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.marketplaceDomainsDeleteInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public marketplaceDomainsDeleteInstance(id: string, _options?: Configuration): Observable<void> {
        return this.marketplaceDomainsDeleteInstanceWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param fieldsMarketplaceDomains the fields to include for returned resources of type marketplaceDomains
     * @param limit maximum resources per page
     */
    public marketplaceDomainsGetCollectionWithHttpInfo(fieldsMarketplaceDomains?: Array<'createdDate' | 'domain' | 'referenceName'>, limit?: number, _options?: Configuration): Observable<HttpInfo<MarketplaceDomainsResponse>> {
        const requestContextPromise = this.requestFactory.marketplaceDomainsGetCollection(fieldsMarketplaceDomains, limit, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.marketplaceDomainsGetCollectionWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param fieldsMarketplaceDomains the fields to include for returned resources of type marketplaceDomains
     * @param limit maximum resources per page
     */
    public marketplaceDomainsGetCollection(fieldsMarketplaceDomains?: Array<'createdDate' | 'domain' | 'referenceName'>, limit?: number, _options?: Configuration): Observable<MarketplaceDomainsResponse> {
        return this.marketplaceDomainsGetCollectionWithHttpInfo(fieldsMarketplaceDomains, limit, _options).pipe(map((apiResponse: HttpInfo<MarketplaceDomainsResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsMarketplaceDomains the fields to include for returned resources of type marketplaceDomains
     */
    public marketplaceDomainsGetInstanceWithHttpInfo(id: string, fieldsMarketplaceDomains?: Array<'createdDate' | 'domain' | 'referenceName'>, _options?: Configuration): Observable<HttpInfo<MarketplaceDomainResponse>> {
        const requestContextPromise = this.requestFactory.marketplaceDomainsGetInstance(id, fieldsMarketplaceDomains, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.marketplaceDomainsGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsMarketplaceDomains the fields to include for returned resources of type marketplaceDomains
     */
    public marketplaceDomainsGetInstance(id: string, fieldsMarketplaceDomains?: Array<'createdDate' | 'domain' | 'referenceName'>, _options?: Configuration): Observable<MarketplaceDomainResponse> {
        return this.marketplaceDomainsGetInstanceWithHttpInfo(id, fieldsMarketplaceDomains, _options).pipe(map((apiResponse: HttpInfo<MarketplaceDomainResponse>) => apiResponse.data));
    }

}

import { MarketplaceSearchDetailsApiRequestFactory, MarketplaceSearchDetailsApiResponseProcessor} from "../apis/MarketplaceSearchDetailsApi.ts";
export class ObservableMarketplaceSearchDetailsApi {
    private requestFactory: MarketplaceSearchDetailsApiRequestFactory;
    private responseProcessor: MarketplaceSearchDetailsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: MarketplaceSearchDetailsApiRequestFactory,
        responseProcessor?: MarketplaceSearchDetailsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new MarketplaceSearchDetailsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new MarketplaceSearchDetailsApiResponseProcessor();
    }

    /**
     * @param marketplaceSearchDetailCreateRequest MarketplaceSearchDetail representation
     */
    public marketplaceSearchDetailsCreateInstanceWithHttpInfo(marketplaceSearchDetailCreateRequest: MarketplaceSearchDetailCreateRequest, _options?: Configuration): Observable<HttpInfo<MarketplaceSearchDetailResponse>> {
        const requestContextPromise = this.requestFactory.marketplaceSearchDetailsCreateInstance(marketplaceSearchDetailCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.marketplaceSearchDetailsCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param marketplaceSearchDetailCreateRequest MarketplaceSearchDetail representation
     */
    public marketplaceSearchDetailsCreateInstance(marketplaceSearchDetailCreateRequest: MarketplaceSearchDetailCreateRequest, _options?: Configuration): Observable<MarketplaceSearchDetailResponse> {
        return this.marketplaceSearchDetailsCreateInstanceWithHttpInfo(marketplaceSearchDetailCreateRequest, _options).pipe(map((apiResponse: HttpInfo<MarketplaceSearchDetailResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public marketplaceSearchDetailsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.marketplaceSearchDetailsDeleteInstance(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.marketplaceSearchDetailsDeleteInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public marketplaceSearchDetailsDeleteInstance(id: string, _options?: Configuration): Observable<void> {
        return this.marketplaceSearchDetailsDeleteInstanceWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param marketplaceSearchDetailUpdateRequest MarketplaceSearchDetail representation
     */
    public marketplaceSearchDetailsUpdateInstanceWithHttpInfo(id: string, marketplaceSearchDetailUpdateRequest: MarketplaceSearchDetailUpdateRequest, _options?: Configuration): Observable<HttpInfo<MarketplaceSearchDetailResponse>> {
        const requestContextPromise = this.requestFactory.marketplaceSearchDetailsUpdateInstance(id, marketplaceSearchDetailUpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.marketplaceSearchDetailsUpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param marketplaceSearchDetailUpdateRequest MarketplaceSearchDetail representation
     */
    public marketplaceSearchDetailsUpdateInstance(id: string, marketplaceSearchDetailUpdateRequest: MarketplaceSearchDetailUpdateRequest, _options?: Configuration): Observable<MarketplaceSearchDetailResponse> {
        return this.marketplaceSearchDetailsUpdateInstanceWithHttpInfo(id, marketplaceSearchDetailUpdateRequest, _options).pipe(map((apiResponse: HttpInfo<MarketplaceSearchDetailResponse>) => apiResponse.data));
    }

}

import { MarketplaceWebhooksApiRequestFactory, MarketplaceWebhooksApiResponseProcessor} from "../apis/MarketplaceWebhooksApi.ts";
export class ObservableMarketplaceWebhooksApi {
    private requestFactory: MarketplaceWebhooksApiRequestFactory;
    private responseProcessor: MarketplaceWebhooksApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: MarketplaceWebhooksApiRequestFactory,
        responseProcessor?: MarketplaceWebhooksApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new MarketplaceWebhooksApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new MarketplaceWebhooksApiResponseProcessor();
    }

    /**
     * @param marketplaceWebhookCreateRequest MarketplaceWebhook representation
     */
    public marketplaceWebhooksCreateInstanceWithHttpInfo(marketplaceWebhookCreateRequest: MarketplaceWebhookCreateRequest, _options?: Configuration): Observable<HttpInfo<MarketplaceWebhookResponse>> {
        const requestContextPromise = this.requestFactory.marketplaceWebhooksCreateInstance(marketplaceWebhookCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.marketplaceWebhooksCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param marketplaceWebhookCreateRequest MarketplaceWebhook representation
     */
    public marketplaceWebhooksCreateInstance(marketplaceWebhookCreateRequest: MarketplaceWebhookCreateRequest, _options?: Configuration): Observable<MarketplaceWebhookResponse> {
        return this.marketplaceWebhooksCreateInstanceWithHttpInfo(marketplaceWebhookCreateRequest, _options).pipe(map((apiResponse: HttpInfo<MarketplaceWebhookResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public marketplaceWebhooksDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.marketplaceWebhooksDeleteInstance(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.marketplaceWebhooksDeleteInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public marketplaceWebhooksDeleteInstance(id: string, _options?: Configuration): Observable<void> {
        return this.marketplaceWebhooksDeleteInstanceWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param fieldsMarketplaceWebhooks the fields to include for returned resources of type marketplaceWebhooks
     * @param limit maximum resources per page
     */
    public marketplaceWebhooksGetCollectionWithHttpInfo(fieldsMarketplaceWebhooks?: Array<'endpointUrl' | 'secret'>, limit?: number, _options?: Configuration): Observable<HttpInfo<MarketplaceWebhooksResponse>> {
        const requestContextPromise = this.requestFactory.marketplaceWebhooksGetCollection(fieldsMarketplaceWebhooks, limit, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.marketplaceWebhooksGetCollectionWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param fieldsMarketplaceWebhooks the fields to include for returned resources of type marketplaceWebhooks
     * @param limit maximum resources per page
     */
    public marketplaceWebhooksGetCollection(fieldsMarketplaceWebhooks?: Array<'endpointUrl' | 'secret'>, limit?: number, _options?: Configuration): Observable<MarketplaceWebhooksResponse> {
        return this.marketplaceWebhooksGetCollectionWithHttpInfo(fieldsMarketplaceWebhooks, limit, _options).pipe(map((apiResponse: HttpInfo<MarketplaceWebhooksResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param marketplaceWebhookUpdateRequest MarketplaceWebhook representation
     */
    public marketplaceWebhooksUpdateInstanceWithHttpInfo(id: string, marketplaceWebhookUpdateRequest: MarketplaceWebhookUpdateRequest, _options?: Configuration): Observable<HttpInfo<MarketplaceWebhookResponse>> {
        const requestContextPromise = this.requestFactory.marketplaceWebhooksUpdateInstance(id, marketplaceWebhookUpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.marketplaceWebhooksUpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param marketplaceWebhookUpdateRequest MarketplaceWebhook representation
     */
    public marketplaceWebhooksUpdateInstance(id: string, marketplaceWebhookUpdateRequest: MarketplaceWebhookUpdateRequest, _options?: Configuration): Observable<MarketplaceWebhookResponse> {
        return this.marketplaceWebhooksUpdateInstanceWithHttpInfo(id, marketplaceWebhookUpdateRequest, _options).pipe(map((apiResponse: HttpInfo<MarketplaceWebhookResponse>) => apiResponse.data));
    }

}

import { MetricsApiRequestFactory, MetricsApiResponseProcessor} from "../apis/MetricsApi.ts";
export class ObservableMetricsApi {
    private requestFactory: MetricsApiRequestFactory;
    private responseProcessor: MetricsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: MetricsApiRequestFactory,
        responseProcessor?: MetricsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new MetricsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new MetricsApiResponseProcessor();
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum number of groups to return per page
     * @param groupBy the dimension by which to group the results
     * @param filterBetaTesters filter by \&#39;betaTesters\&#39; relationship dimension
     * @param period the duration of the reporting period
     */
    public appsBetaTesterUsagesGetMetricsWithHttpInfo(id: string, limit?: number, groupBy?: Array<'betaTesters'>, filterBetaTesters?: string, period?: 'P7D' | 'P30D' | 'P90D' | 'P365D', _options?: Configuration): Observable<HttpInfo<AppsBetaTesterUsagesV1MetricResponse>> {
        const requestContextPromise = this.requestFactory.appsBetaTesterUsagesGetMetrics(id, limit, groupBy, filterBetaTesters, period, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.appsBetaTesterUsagesGetMetricsWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum number of groups to return per page
     * @param groupBy the dimension by which to group the results
     * @param filterBetaTesters filter by \&#39;betaTesters\&#39; relationship dimension
     * @param period the duration of the reporting period
     */
    public appsBetaTesterUsagesGetMetrics(id: string, limit?: number, groupBy?: Array<'betaTesters'>, filterBetaTesters?: string, period?: 'P7D' | 'P30D' | 'P90D' | 'P365D', _options?: Configuration): Observable<AppsBetaTesterUsagesV1MetricResponse> {
        return this.appsBetaTesterUsagesGetMetricsWithHttpInfo(id, limit, groupBy, filterBetaTesters, period, _options).pipe(map((apiResponse: HttpInfo<AppsBetaTesterUsagesV1MetricResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum number of groups to return per page
     * @param groupBy the dimension by which to group the results
     * @param filterBetaTesters filter by \&#39;betaTesters\&#39; relationship dimension
     * @param period the duration of the reporting period
     */
    public betaGroupsBetaTesterUsagesGetMetricsWithHttpInfo(id: string, limit?: number, groupBy?: Array<'betaTesters'>, filterBetaTesters?: string, period?: 'P7D' | 'P30D' | 'P90D' | 'P365D', _options?: Configuration): Observable<HttpInfo<AppsBetaTesterUsagesV1MetricResponse>> {
        const requestContextPromise = this.requestFactory.betaGroupsBetaTesterUsagesGetMetrics(id, limit, groupBy, filterBetaTesters, period, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.betaGroupsBetaTesterUsagesGetMetricsWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum number of groups to return per page
     * @param groupBy the dimension by which to group the results
     * @param filterBetaTesters filter by \&#39;betaTesters\&#39; relationship dimension
     * @param period the duration of the reporting period
     */
    public betaGroupsBetaTesterUsagesGetMetrics(id: string, limit?: number, groupBy?: Array<'betaTesters'>, filterBetaTesters?: string, period?: 'P7D' | 'P30D' | 'P90D' | 'P365D', _options?: Configuration): Observable<AppsBetaTesterUsagesV1MetricResponse> {
        return this.betaGroupsBetaTesterUsagesGetMetricsWithHttpInfo(id, limit, groupBy, filterBetaTesters, period, _options).pipe(map((apiResponse: HttpInfo<AppsBetaTesterUsagesV1MetricResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param filterApps filter by \&#39;apps\&#39; relationship dimension
     * @param limit maximum number of groups to return per page
     * @param period the duration of the reporting period
     */
    public betaTestersBetaTesterUsagesGetMetricsWithHttpInfo(id: string, filterApps: string, limit?: number, period?: 'P7D' | 'P30D' | 'P90D' | 'P365D', _options?: Configuration): Observable<HttpInfo<BetaTesterUsagesV1MetricResponse>> {
        const requestContextPromise = this.requestFactory.betaTestersBetaTesterUsagesGetMetrics(id, filterApps, limit, period, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.betaTestersBetaTesterUsagesGetMetricsWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param filterApps filter by \&#39;apps\&#39; relationship dimension
     * @param limit maximum number of groups to return per page
     * @param period the duration of the reporting period
     */
    public betaTestersBetaTesterUsagesGetMetrics(id: string, filterApps: string, limit?: number, period?: 'P7D' | 'P30D' | 'P90D' | 'P365D', _options?: Configuration): Observable<BetaTesterUsagesV1MetricResponse> {
        return this.betaTestersBetaTesterUsagesGetMetricsWithHttpInfo(id, filterApps, limit, period, _options).pipe(map((apiResponse: HttpInfo<BetaTesterUsagesV1MetricResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum number of groups to return per page
     */
    public buildsBetaBuildUsagesGetMetricsWithHttpInfo(id: string, limit?: number, _options?: Configuration): Observable<HttpInfo<BetaBuildUsagesV1MetricResponse>> {
        const requestContextPromise = this.requestFactory.buildsBetaBuildUsagesGetMetrics(id, limit, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.buildsBetaBuildUsagesGetMetricsWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum number of groups to return per page
     */
    public buildsBetaBuildUsagesGetMetrics(id: string, limit?: number, _options?: Configuration): Observable<BetaBuildUsagesV1MetricResponse> {
        return this.buildsBetaBuildUsagesGetMetricsWithHttpInfo(id, limit, _options).pipe(map((apiResponse: HttpInfo<BetaBuildUsagesV1MetricResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param granularity the granularity of the per-group dataset
     * @param limit maximum number of groups to return per page
     * @param groupBy the dimension by which to group the results
     * @param filterResult filter by \&#39;result\&#39; attribute dimension
     * @param sort comma-separated list of sort expressions; metrics will be sorted as specified
     */
    public gameCenterDetailsClassicMatchmakingRequestsGetMetricsWithHttpInfo(id: string, granularity: 'P1D' | 'PT1H' | 'PT15M', limit?: number, groupBy?: Array<'result'>, filterResult?: 'MATCHED' | 'CANCELED' | 'EXPIRED', sort?: Array<'averageSecondsInQueue' | '-averageSecondsInQueue' | 'count' | '-count' | 'p50SecondsInQueue' | '-p50SecondsInQueue' | 'p95SecondsInQueue' | '-p95SecondsInQueue'>, _options?: Configuration): Observable<HttpInfo<GameCenterMatchmakingAppRequestsV1MetricResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterDetailsClassicMatchmakingRequestsGetMetrics(id, granularity, limit, groupBy, filterResult, sort, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterDetailsClassicMatchmakingRequestsGetMetricsWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param granularity the granularity of the per-group dataset
     * @param limit maximum number of groups to return per page
     * @param groupBy the dimension by which to group the results
     * @param filterResult filter by \&#39;result\&#39; attribute dimension
     * @param sort comma-separated list of sort expressions; metrics will be sorted as specified
     */
    public gameCenterDetailsClassicMatchmakingRequestsGetMetrics(id: string, granularity: 'P1D' | 'PT1H' | 'PT15M', limit?: number, groupBy?: Array<'result'>, filterResult?: 'MATCHED' | 'CANCELED' | 'EXPIRED', sort?: Array<'averageSecondsInQueue' | '-averageSecondsInQueue' | 'count' | '-count' | 'p50SecondsInQueue' | '-p50SecondsInQueue' | 'p95SecondsInQueue' | '-p95SecondsInQueue'>, _options?: Configuration): Observable<GameCenterMatchmakingAppRequestsV1MetricResponse> {
        return this.gameCenterDetailsClassicMatchmakingRequestsGetMetricsWithHttpInfo(id, granularity, limit, groupBy, filterResult, sort, _options).pipe(map((apiResponse: HttpInfo<GameCenterMatchmakingAppRequestsV1MetricResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param granularity the granularity of the per-group dataset
     * @param limit maximum number of groups to return per page
     * @param groupBy the dimension by which to group the results
     * @param filterResult filter by \&#39;result\&#39; attribute dimension
     * @param sort comma-separated list of sort expressions; metrics will be sorted as specified
     */
    public gameCenterDetailsRuleBasedMatchmakingRequestsGetMetricsWithHttpInfo(id: string, granularity: 'P1D' | 'PT1H' | 'PT15M', limit?: number, groupBy?: Array<'result'>, filterResult?: 'MATCHED' | 'CANCELED' | 'EXPIRED', sort?: Array<'averageSecondsInQueue' | '-averageSecondsInQueue' | 'count' | '-count' | 'p50SecondsInQueue' | '-p50SecondsInQueue' | 'p95SecondsInQueue' | '-p95SecondsInQueue'>, _options?: Configuration): Observable<HttpInfo<GameCenterMatchmakingAppRequestsV1MetricResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterDetailsRuleBasedMatchmakingRequestsGetMetrics(id, granularity, limit, groupBy, filterResult, sort, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterDetailsRuleBasedMatchmakingRequestsGetMetricsWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param granularity the granularity of the per-group dataset
     * @param limit maximum number of groups to return per page
     * @param groupBy the dimension by which to group the results
     * @param filterResult filter by \&#39;result\&#39; attribute dimension
     * @param sort comma-separated list of sort expressions; metrics will be sorted as specified
     */
    public gameCenterDetailsRuleBasedMatchmakingRequestsGetMetrics(id: string, granularity: 'P1D' | 'PT1H' | 'PT15M', limit?: number, groupBy?: Array<'result'>, filterResult?: 'MATCHED' | 'CANCELED' | 'EXPIRED', sort?: Array<'averageSecondsInQueue' | '-averageSecondsInQueue' | 'count' | '-count' | 'p50SecondsInQueue' | '-p50SecondsInQueue' | 'p95SecondsInQueue' | '-p95SecondsInQueue'>, _options?: Configuration): Observable<GameCenterMatchmakingAppRequestsV1MetricResponse> {
        return this.gameCenterDetailsRuleBasedMatchmakingRequestsGetMetricsWithHttpInfo(id, granularity, limit, groupBy, filterResult, sort, _options).pipe(map((apiResponse: HttpInfo<GameCenterMatchmakingAppRequestsV1MetricResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param granularity the granularity of the per-group dataset
     * @param limit maximum number of groups to return per page
     * @param sort comma-separated list of sort expressions; metrics will be sorted as specified
     */
    public gameCenterMatchmakingQueuesExperimentMatchmakingQueueSizesGetMetricsWithHttpInfo(id: string, granularity: 'P1D' | 'PT1H' | 'PT15M', limit?: number, sort?: Array<'averageNumberOfRequests' | '-averageNumberOfRequests' | 'count' | '-count' | 'p50NumberOfRequests' | '-p50NumberOfRequests' | 'p95NumberOfRequests' | '-p95NumberOfRequests'>, _options?: Configuration): Observable<HttpInfo<GameCenterMatchmakingQueueSizesV1MetricResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterMatchmakingQueuesExperimentMatchmakingQueueSizesGetMetrics(id, granularity, limit, sort, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterMatchmakingQueuesExperimentMatchmakingQueueSizesGetMetricsWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param granularity the granularity of the per-group dataset
     * @param limit maximum number of groups to return per page
     * @param sort comma-separated list of sort expressions; metrics will be sorted as specified
     */
    public gameCenterMatchmakingQueuesExperimentMatchmakingQueueSizesGetMetrics(id: string, granularity: 'P1D' | 'PT1H' | 'PT15M', limit?: number, sort?: Array<'averageNumberOfRequests' | '-averageNumberOfRequests' | 'count' | '-count' | 'p50NumberOfRequests' | '-p50NumberOfRequests' | 'p95NumberOfRequests' | '-p95NumberOfRequests'>, _options?: Configuration): Observable<GameCenterMatchmakingQueueSizesV1MetricResponse> {
        return this.gameCenterMatchmakingQueuesExperimentMatchmakingQueueSizesGetMetricsWithHttpInfo(id, granularity, limit, sort, _options).pipe(map((apiResponse: HttpInfo<GameCenterMatchmakingQueueSizesV1MetricResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param granularity the granularity of the per-group dataset
     * @param limit maximum number of groups to return per page
     * @param groupBy the dimension by which to group the results
     * @param filterResult filter by \&#39;result\&#39; attribute dimension
     * @param filterGameCenterDetail filter by \&#39;gameCenterDetail\&#39; relationship dimension
     * @param sort comma-separated list of sort expressions; metrics will be sorted as specified
     */
    public gameCenterMatchmakingQueuesExperimentMatchmakingRequestsGetMetricsWithHttpInfo(id: string, granularity: 'P1D' | 'PT1H' | 'PT15M', limit?: number, groupBy?: Array<'gameCenterDetail' | 'result'>, filterResult?: 'MATCHED' | 'CANCELED' | 'EXPIRED', filterGameCenterDetail?: string, sort?: Array<'averageSecondsInQueue' | '-averageSecondsInQueue' | 'count' | '-count' | 'p50SecondsInQueue' | '-p50SecondsInQueue' | 'p95SecondsInQueue' | '-p95SecondsInQueue'>, _options?: Configuration): Observable<HttpInfo<GameCenterMatchmakingQueueRequestsV1MetricResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterMatchmakingQueuesExperimentMatchmakingRequestsGetMetrics(id, granularity, limit, groupBy, filterResult, filterGameCenterDetail, sort, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterMatchmakingQueuesExperimentMatchmakingRequestsGetMetricsWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param granularity the granularity of the per-group dataset
     * @param limit maximum number of groups to return per page
     * @param groupBy the dimension by which to group the results
     * @param filterResult filter by \&#39;result\&#39; attribute dimension
     * @param filterGameCenterDetail filter by \&#39;gameCenterDetail\&#39; relationship dimension
     * @param sort comma-separated list of sort expressions; metrics will be sorted as specified
     */
    public gameCenterMatchmakingQueuesExperimentMatchmakingRequestsGetMetrics(id: string, granularity: 'P1D' | 'PT1H' | 'PT15M', limit?: number, groupBy?: Array<'gameCenterDetail' | 'result'>, filterResult?: 'MATCHED' | 'CANCELED' | 'EXPIRED', filterGameCenterDetail?: string, sort?: Array<'averageSecondsInQueue' | '-averageSecondsInQueue' | 'count' | '-count' | 'p50SecondsInQueue' | '-p50SecondsInQueue' | 'p95SecondsInQueue' | '-p95SecondsInQueue'>, _options?: Configuration): Observable<GameCenterMatchmakingQueueRequestsV1MetricResponse> {
        return this.gameCenterMatchmakingQueuesExperimentMatchmakingRequestsGetMetricsWithHttpInfo(id, granularity, limit, groupBy, filterResult, filterGameCenterDetail, sort, _options).pipe(map((apiResponse: HttpInfo<GameCenterMatchmakingQueueRequestsV1MetricResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param granularity the granularity of the per-group dataset
     * @param limit maximum number of groups to return per page
     * @param sort comma-separated list of sort expressions; metrics will be sorted as specified
     */
    public gameCenterMatchmakingQueuesMatchmakingQueueSizesGetMetricsWithHttpInfo(id: string, granularity: 'P1D' | 'PT1H' | 'PT15M', limit?: number, sort?: Array<'averageNumberOfRequests' | '-averageNumberOfRequests' | 'count' | '-count' | 'p50NumberOfRequests' | '-p50NumberOfRequests' | 'p95NumberOfRequests' | '-p95NumberOfRequests'>, _options?: Configuration): Observable<HttpInfo<GameCenterMatchmakingQueueSizesV1MetricResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterMatchmakingQueuesMatchmakingQueueSizesGetMetrics(id, granularity, limit, sort, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterMatchmakingQueuesMatchmakingQueueSizesGetMetricsWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param granularity the granularity of the per-group dataset
     * @param limit maximum number of groups to return per page
     * @param sort comma-separated list of sort expressions; metrics will be sorted as specified
     */
    public gameCenterMatchmakingQueuesMatchmakingQueueSizesGetMetrics(id: string, granularity: 'P1D' | 'PT1H' | 'PT15M', limit?: number, sort?: Array<'averageNumberOfRequests' | '-averageNumberOfRequests' | 'count' | '-count' | 'p50NumberOfRequests' | '-p50NumberOfRequests' | 'p95NumberOfRequests' | '-p95NumberOfRequests'>, _options?: Configuration): Observable<GameCenterMatchmakingQueueSizesV1MetricResponse> {
        return this.gameCenterMatchmakingQueuesMatchmakingQueueSizesGetMetricsWithHttpInfo(id, granularity, limit, sort, _options).pipe(map((apiResponse: HttpInfo<GameCenterMatchmakingQueueSizesV1MetricResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param granularity the granularity of the per-group dataset
     * @param limit maximum number of groups to return per page
     * @param groupBy the dimension by which to group the results
     * @param filterResult filter by \&#39;result\&#39; attribute dimension
     * @param filterGameCenterDetail filter by \&#39;gameCenterDetail\&#39; relationship dimension
     * @param sort comma-separated list of sort expressions; metrics will be sorted as specified
     */
    public gameCenterMatchmakingQueuesMatchmakingRequestsGetMetricsWithHttpInfo(id: string, granularity: 'P1D' | 'PT1H' | 'PT15M', limit?: number, groupBy?: Array<'gameCenterDetail' | 'result'>, filterResult?: 'MATCHED' | 'CANCELED' | 'EXPIRED', filterGameCenterDetail?: string, sort?: Array<'averageSecondsInQueue' | '-averageSecondsInQueue' | 'count' | '-count' | 'p50SecondsInQueue' | '-p50SecondsInQueue' | 'p95SecondsInQueue' | '-p95SecondsInQueue'>, _options?: Configuration): Observable<HttpInfo<GameCenterMatchmakingQueueRequestsV1MetricResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterMatchmakingQueuesMatchmakingRequestsGetMetrics(id, granularity, limit, groupBy, filterResult, filterGameCenterDetail, sort, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterMatchmakingQueuesMatchmakingRequestsGetMetricsWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param granularity the granularity of the per-group dataset
     * @param limit maximum number of groups to return per page
     * @param groupBy the dimension by which to group the results
     * @param filterResult filter by \&#39;result\&#39; attribute dimension
     * @param filterGameCenterDetail filter by \&#39;gameCenterDetail\&#39; relationship dimension
     * @param sort comma-separated list of sort expressions; metrics will be sorted as specified
     */
    public gameCenterMatchmakingQueuesMatchmakingRequestsGetMetrics(id: string, granularity: 'P1D' | 'PT1H' | 'PT15M', limit?: number, groupBy?: Array<'gameCenterDetail' | 'result'>, filterResult?: 'MATCHED' | 'CANCELED' | 'EXPIRED', filterGameCenterDetail?: string, sort?: Array<'averageSecondsInQueue' | '-averageSecondsInQueue' | 'count' | '-count' | 'p50SecondsInQueue' | '-p50SecondsInQueue' | 'p95SecondsInQueue' | '-p95SecondsInQueue'>, _options?: Configuration): Observable<GameCenterMatchmakingQueueRequestsV1MetricResponse> {
        return this.gameCenterMatchmakingQueuesMatchmakingRequestsGetMetricsWithHttpInfo(id, granularity, limit, groupBy, filterResult, filterGameCenterDetail, sort, _options).pipe(map((apiResponse: HttpInfo<GameCenterMatchmakingQueueRequestsV1MetricResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param granularity the granularity of the per-group dataset
     * @param limit maximum number of groups to return per page
     * @param sort comma-separated list of sort expressions; metrics will be sorted as specified
     */
    public gameCenterMatchmakingQueuesMatchmakingSessionsGetMetricsWithHttpInfo(id: string, granularity: 'P1D' | 'PT1H' | 'PT15M', limit?: number, sort?: Array<'averagePlayerCount' | '-averagePlayerCount' | 'count' | '-count' | 'p50PlayerCount' | '-p50PlayerCount' | 'p95PlayerCount' | '-p95PlayerCount'>, _options?: Configuration): Observable<HttpInfo<GameCenterMatchmakingSessionsV1MetricResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterMatchmakingQueuesMatchmakingSessionsGetMetrics(id, granularity, limit, sort, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterMatchmakingQueuesMatchmakingSessionsGetMetricsWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param granularity the granularity of the per-group dataset
     * @param limit maximum number of groups to return per page
     * @param sort comma-separated list of sort expressions; metrics will be sorted as specified
     */
    public gameCenterMatchmakingQueuesMatchmakingSessionsGetMetrics(id: string, granularity: 'P1D' | 'PT1H' | 'PT15M', limit?: number, sort?: Array<'averagePlayerCount' | '-averagePlayerCount' | 'count' | '-count' | 'p50PlayerCount' | '-p50PlayerCount' | 'p95PlayerCount' | '-p95PlayerCount'>, _options?: Configuration): Observable<GameCenterMatchmakingSessionsV1MetricResponse> {
        return this.gameCenterMatchmakingQueuesMatchmakingSessionsGetMetricsWithHttpInfo(id, granularity, limit, sort, _options).pipe(map((apiResponse: HttpInfo<GameCenterMatchmakingSessionsV1MetricResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param granularity the granularity of the per-group dataset
     * @param limit maximum number of groups to return per page
     * @param groupBy the dimension by which to group the results
     * @param filterResult filter by \&#39;result\&#39; attribute dimension
     * @param filterGameCenterMatchmakingQueue filter by \&#39;gameCenterMatchmakingQueue\&#39; relationship dimension
     * @param sort comma-separated list of sort expressions; metrics will be sorted as specified
     */
    public gameCenterMatchmakingRulesMatchmakingBooleanRuleResultsGetMetricsWithHttpInfo(id: string, granularity: 'P1D' | 'PT1H' | 'PT15M', limit?: number, groupBy?: Array<'gameCenterMatchmakingQueue' | 'result'>, filterResult?: string, filterGameCenterMatchmakingQueue?: string, sort?: Array<'count' | '-count'>, _options?: Configuration): Observable<HttpInfo<GameCenterMatchmakingBooleanRuleResultsV1MetricResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterMatchmakingRulesMatchmakingBooleanRuleResultsGetMetrics(id, granularity, limit, groupBy, filterResult, filterGameCenterMatchmakingQueue, sort, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterMatchmakingRulesMatchmakingBooleanRuleResultsGetMetricsWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param granularity the granularity of the per-group dataset
     * @param limit maximum number of groups to return per page
     * @param groupBy the dimension by which to group the results
     * @param filterResult filter by \&#39;result\&#39; attribute dimension
     * @param filterGameCenterMatchmakingQueue filter by \&#39;gameCenterMatchmakingQueue\&#39; relationship dimension
     * @param sort comma-separated list of sort expressions; metrics will be sorted as specified
     */
    public gameCenterMatchmakingRulesMatchmakingBooleanRuleResultsGetMetrics(id: string, granularity: 'P1D' | 'PT1H' | 'PT15M', limit?: number, groupBy?: Array<'gameCenterMatchmakingQueue' | 'result'>, filterResult?: string, filterGameCenterMatchmakingQueue?: string, sort?: Array<'count' | '-count'>, _options?: Configuration): Observable<GameCenterMatchmakingBooleanRuleResultsV1MetricResponse> {
        return this.gameCenterMatchmakingRulesMatchmakingBooleanRuleResultsGetMetricsWithHttpInfo(id, granularity, limit, groupBy, filterResult, filterGameCenterMatchmakingQueue, sort, _options).pipe(map((apiResponse: HttpInfo<GameCenterMatchmakingBooleanRuleResultsV1MetricResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param granularity the granularity of the per-group dataset
     * @param limit maximum number of groups to return per page
     * @param groupBy the dimension by which to group the results
     * @param filterGameCenterMatchmakingQueue filter by \&#39;gameCenterMatchmakingQueue\&#39; relationship dimension
     * @param sort comma-separated list of sort expressions; metrics will be sorted as specified
     */
    public gameCenterMatchmakingRulesMatchmakingNumberRuleResultsGetMetricsWithHttpInfo(id: string, granularity: 'P1D' | 'PT1H' | 'PT15M', limit?: number, groupBy?: Array<'gameCenterMatchmakingQueue'>, filterGameCenterMatchmakingQueue?: string, sort?: Array<'averageResult' | '-averageResult' | 'count' | '-count' | 'p50Result' | '-p50Result' | 'p95Result' | '-p95Result'>, _options?: Configuration): Observable<HttpInfo<GameCenterMatchmakingNumberRuleResultsV1MetricResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterMatchmakingRulesMatchmakingNumberRuleResultsGetMetrics(id, granularity, limit, groupBy, filterGameCenterMatchmakingQueue, sort, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterMatchmakingRulesMatchmakingNumberRuleResultsGetMetricsWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param granularity the granularity of the per-group dataset
     * @param limit maximum number of groups to return per page
     * @param groupBy the dimension by which to group the results
     * @param filterGameCenterMatchmakingQueue filter by \&#39;gameCenterMatchmakingQueue\&#39; relationship dimension
     * @param sort comma-separated list of sort expressions; metrics will be sorted as specified
     */
    public gameCenterMatchmakingRulesMatchmakingNumberRuleResultsGetMetrics(id: string, granularity: 'P1D' | 'PT1H' | 'PT15M', limit?: number, groupBy?: Array<'gameCenterMatchmakingQueue'>, filterGameCenterMatchmakingQueue?: string, sort?: Array<'averageResult' | '-averageResult' | 'count' | '-count' | 'p50Result' | '-p50Result' | 'p95Result' | '-p95Result'>, _options?: Configuration): Observable<GameCenterMatchmakingNumberRuleResultsV1MetricResponse> {
        return this.gameCenterMatchmakingRulesMatchmakingNumberRuleResultsGetMetricsWithHttpInfo(id, granularity, limit, groupBy, filterGameCenterMatchmakingQueue, sort, _options).pipe(map((apiResponse: HttpInfo<GameCenterMatchmakingNumberRuleResultsV1MetricResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param granularity the granularity of the per-group dataset
     * @param limit maximum number of groups to return per page
     * @param groupBy the dimension by which to group the results
     * @param filterGameCenterMatchmakingQueue filter by \&#39;gameCenterMatchmakingQueue\&#39; relationship dimension
     * @param sort comma-separated list of sort expressions; metrics will be sorted as specified
     */
    public gameCenterMatchmakingRulesMatchmakingRuleErrorsGetMetricsWithHttpInfo(id: string, granularity: 'P1D' | 'PT1H' | 'PT15M', limit?: number, groupBy?: Array<'gameCenterMatchmakingQueue'>, filterGameCenterMatchmakingQueue?: string, sort?: Array<'count' | '-count'>, _options?: Configuration): Observable<HttpInfo<GameCenterMatchmakingRuleErrorsV1MetricResponse>> {
        const requestContextPromise = this.requestFactory.gameCenterMatchmakingRulesMatchmakingRuleErrorsGetMetrics(id, granularity, limit, groupBy, filterGameCenterMatchmakingQueue, sort, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.gameCenterMatchmakingRulesMatchmakingRuleErrorsGetMetricsWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param granularity the granularity of the per-group dataset
     * @param limit maximum number of groups to return per page
     * @param groupBy the dimension by which to group the results
     * @param filterGameCenterMatchmakingQueue filter by \&#39;gameCenterMatchmakingQueue\&#39; relationship dimension
     * @param sort comma-separated list of sort expressions; metrics will be sorted as specified
     */
    public gameCenterMatchmakingRulesMatchmakingRuleErrorsGetMetrics(id: string, granularity: 'P1D' | 'PT1H' | 'PT15M', limit?: number, groupBy?: Array<'gameCenterMatchmakingQueue'>, filterGameCenterMatchmakingQueue?: string, sort?: Array<'count' | '-count'>, _options?: Configuration): Observable<GameCenterMatchmakingRuleErrorsV1MetricResponse> {
        return this.gameCenterMatchmakingRulesMatchmakingRuleErrorsGetMetricsWithHttpInfo(id, granularity, limit, groupBy, filterGameCenterMatchmakingQueue, sort, _options).pipe(map((apiResponse: HttpInfo<GameCenterMatchmakingRuleErrorsV1MetricResponse>) => apiResponse.data));
    }

}

import { PreReleaseVersionsApiRequestFactory, PreReleaseVersionsApiResponseProcessor} from "../apis/PreReleaseVersionsApi.ts";
export class ObservablePreReleaseVersionsApi {
    private requestFactory: PreReleaseVersionsApiRequestFactory;
    private responseProcessor: PreReleaseVersionsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: PreReleaseVersionsApiRequestFactory,
        responseProcessor?: PreReleaseVersionsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new PreReleaseVersionsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new PreReleaseVersionsApiResponseProcessor();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsApps the fields to include for returned resources of type apps
     */
    public preReleaseVersionsAppGetToOneRelatedWithHttpInfo(id: string, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, _options?: Configuration): Observable<HttpInfo<AppWithoutIncludesResponse>> {
        const requestContextPromise = this.requestFactory.preReleaseVersionsAppGetToOneRelated(id, fieldsApps, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.preReleaseVersionsAppGetToOneRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsApps the fields to include for returned resources of type apps
     */
    public preReleaseVersionsAppGetToOneRelated(id: string, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, _options?: Configuration): Observable<AppWithoutIncludesResponse> {
        return this.preReleaseVersionsAppGetToOneRelatedWithHttpInfo(id, fieldsApps, _options).pipe(map((apiResponse: HttpInfo<AppWithoutIncludesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param limit maximum resources per page
     */
    public preReleaseVersionsBuildsGetToManyRelatedWithHttpInfo(id: string, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, limit?: number, _options?: Configuration): Observable<HttpInfo<BuildsWithoutIncludesResponse>> {
        const requestContextPromise = this.requestFactory.preReleaseVersionsBuildsGetToManyRelated(id, fieldsBuilds, limit, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.preReleaseVersionsBuildsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param limit maximum resources per page
     */
    public preReleaseVersionsBuildsGetToManyRelated(id: string, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, limit?: number, _options?: Configuration): Observable<BuildsWithoutIncludesResponse> {
        return this.preReleaseVersionsBuildsGetToManyRelatedWithHttpInfo(id, fieldsBuilds, limit, _options).pipe(map((apiResponse: HttpInfo<BuildsWithoutIncludesResponse>) => apiResponse.data));
    }

    /**
     * @param filterBuildsExpired filter by attribute \&#39;builds.expired\&#39;
     * @param filterBuildsProcessingState filter by attribute \&#39;builds.processingState\&#39;
     * @param filterBuildsVersion filter by attribute \&#39;builds.version\&#39;
     * @param filterPlatform filter by attribute \&#39;platform\&#39;
     * @param filterVersion filter by attribute \&#39;version\&#39;
     * @param filterApp filter by id(s) of related \&#39;app\&#39;
     * @param filterBuilds filter by id(s) of related \&#39;builds\&#39;
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsPreReleaseVersions the fields to include for returned resources of type preReleaseVersions
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param limitBuilds maximum number of related builds returned (when they are included)
     */
    public preReleaseVersionsGetCollectionWithHttpInfo(filterBuildsExpired?: Array<string>, filterBuildsProcessingState?: Array<'PROCESSING' | 'FAILED' | 'INVALID' | 'VALID'>, filterBuildsVersion?: Array<string>, filterPlatform?: Array<'IOS' | 'MAC_OS' | 'TV_OS' | 'VISION_OS'>, filterVersion?: Array<string>, filterApp?: Array<string>, filterBuilds?: Array<string>, sort?: Array<'version' | '-version'>, fieldsPreReleaseVersions?: Array<'app' | 'builds' | 'platform' | 'version'>, limit?: number, include?: Array<'app' | 'builds'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, limitBuilds?: number, _options?: Configuration): Observable<HttpInfo<PreReleaseVersionsResponse>> {
        const requestContextPromise = this.requestFactory.preReleaseVersionsGetCollection(filterBuildsExpired, filterBuildsProcessingState, filterBuildsVersion, filterPlatform, filterVersion, filterApp, filterBuilds, sort, fieldsPreReleaseVersions, limit, include, fieldsApps, fieldsBuilds, limitBuilds, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.preReleaseVersionsGetCollectionWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param filterBuildsExpired filter by attribute \&#39;builds.expired\&#39;
     * @param filterBuildsProcessingState filter by attribute \&#39;builds.processingState\&#39;
     * @param filterBuildsVersion filter by attribute \&#39;builds.version\&#39;
     * @param filterPlatform filter by attribute \&#39;platform\&#39;
     * @param filterVersion filter by attribute \&#39;version\&#39;
     * @param filterApp filter by id(s) of related \&#39;app\&#39;
     * @param filterBuilds filter by id(s) of related \&#39;builds\&#39;
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsPreReleaseVersions the fields to include for returned resources of type preReleaseVersions
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param limitBuilds maximum number of related builds returned (when they are included)
     */
    public preReleaseVersionsGetCollection(filterBuildsExpired?: Array<string>, filterBuildsProcessingState?: Array<'PROCESSING' | 'FAILED' | 'INVALID' | 'VALID'>, filterBuildsVersion?: Array<string>, filterPlatform?: Array<'IOS' | 'MAC_OS' | 'TV_OS' | 'VISION_OS'>, filterVersion?: Array<string>, filterApp?: Array<string>, filterBuilds?: Array<string>, sort?: Array<'version' | '-version'>, fieldsPreReleaseVersions?: Array<'app' | 'builds' | 'platform' | 'version'>, limit?: number, include?: Array<'app' | 'builds'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, limitBuilds?: number, _options?: Configuration): Observable<PreReleaseVersionsResponse> {
        return this.preReleaseVersionsGetCollectionWithHttpInfo(filterBuildsExpired, filterBuildsProcessingState, filterBuildsVersion, filterPlatform, filterVersion, filterApp, filterBuilds, sort, fieldsPreReleaseVersions, limit, include, fieldsApps, fieldsBuilds, limitBuilds, _options).pipe(map((apiResponse: HttpInfo<PreReleaseVersionsResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsPreReleaseVersions the fields to include for returned resources of type preReleaseVersions
     * @param include comma-separated list of relationships to include
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param limitBuilds maximum number of related builds returned (when they are included)
     */
    public preReleaseVersionsGetInstanceWithHttpInfo(id: string, fieldsPreReleaseVersions?: Array<'app' | 'builds' | 'platform' | 'version'>, include?: Array<'app' | 'builds'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, limitBuilds?: number, _options?: Configuration): Observable<HttpInfo<PrereleaseVersionResponse>> {
        const requestContextPromise = this.requestFactory.preReleaseVersionsGetInstance(id, fieldsPreReleaseVersions, include, fieldsApps, fieldsBuilds, limitBuilds, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.preReleaseVersionsGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsPreReleaseVersions the fields to include for returned resources of type preReleaseVersions
     * @param include comma-separated list of relationships to include
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param limitBuilds maximum number of related builds returned (when they are included)
     */
    public preReleaseVersionsGetInstance(id: string, fieldsPreReleaseVersions?: Array<'app' | 'builds' | 'platform' | 'version'>, include?: Array<'app' | 'builds'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, limitBuilds?: number, _options?: Configuration): Observable<PrereleaseVersionResponse> {
        return this.preReleaseVersionsGetInstanceWithHttpInfo(id, fieldsPreReleaseVersions, include, fieldsApps, fieldsBuilds, limitBuilds, _options).pipe(map((apiResponse: HttpInfo<PrereleaseVersionResponse>) => apiResponse.data));
    }

}

import { ProfilesApiRequestFactory, ProfilesApiResponseProcessor} from "../apis/ProfilesApi.ts";
export class ObservableProfilesApi {
    private requestFactory: ProfilesApiRequestFactory;
    private responseProcessor: ProfilesApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: ProfilesApiRequestFactory,
        responseProcessor?: ProfilesApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new ProfilesApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new ProfilesApiResponseProcessor();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBundleIds the fields to include for returned resources of type bundleIds
     */
    public profilesBundleIdGetToOneRelatedWithHttpInfo(id: string, fieldsBundleIds?: Array<'app' | 'bundleIdCapabilities' | 'identifier' | 'name' | 'platform' | 'profiles' | 'seedId'>, _options?: Configuration): Observable<HttpInfo<BundleIdWithoutIncludesResponse>> {
        const requestContextPromise = this.requestFactory.profilesBundleIdGetToOneRelated(id, fieldsBundleIds, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.profilesBundleIdGetToOneRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBundleIds the fields to include for returned resources of type bundleIds
     */
    public profilesBundleIdGetToOneRelated(id: string, fieldsBundleIds?: Array<'app' | 'bundleIdCapabilities' | 'identifier' | 'name' | 'platform' | 'profiles' | 'seedId'>, _options?: Configuration): Observable<BundleIdWithoutIncludesResponse> {
        return this.profilesBundleIdGetToOneRelatedWithHttpInfo(id, fieldsBundleIds, _options).pipe(map((apiResponse: HttpInfo<BundleIdWithoutIncludesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCertificates the fields to include for returned resources of type certificates
     * @param limit maximum resources per page
     */
    public profilesCertificatesGetToManyRelatedWithHttpInfo(id: string, fieldsCertificates?: Array<'certificateContent' | 'certificateType' | 'csrContent' | 'displayName' | 'expirationDate' | 'name' | 'platform' | 'serialNumber'>, limit?: number, _options?: Configuration): Observable<HttpInfo<CertificatesWithoutIncludesResponse>> {
        const requestContextPromise = this.requestFactory.profilesCertificatesGetToManyRelated(id, fieldsCertificates, limit, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.profilesCertificatesGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCertificates the fields to include for returned resources of type certificates
     * @param limit maximum resources per page
     */
    public profilesCertificatesGetToManyRelated(id: string, fieldsCertificates?: Array<'certificateContent' | 'certificateType' | 'csrContent' | 'displayName' | 'expirationDate' | 'name' | 'platform' | 'serialNumber'>, limit?: number, _options?: Configuration): Observable<CertificatesWithoutIncludesResponse> {
        return this.profilesCertificatesGetToManyRelatedWithHttpInfo(id, fieldsCertificates, limit, _options).pipe(map((apiResponse: HttpInfo<CertificatesWithoutIncludesResponse>) => apiResponse.data));
    }

    /**
     * @param profileCreateRequest Profile representation
     */
    public profilesCreateInstanceWithHttpInfo(profileCreateRequest: ProfileCreateRequest, _options?: Configuration): Observable<HttpInfo<ProfileResponse>> {
        const requestContextPromise = this.requestFactory.profilesCreateInstance(profileCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.profilesCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param profileCreateRequest Profile representation
     */
    public profilesCreateInstance(profileCreateRequest: ProfileCreateRequest, _options?: Configuration): Observable<ProfileResponse> {
        return this.profilesCreateInstanceWithHttpInfo(profileCreateRequest, _options).pipe(map((apiResponse: HttpInfo<ProfileResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public profilesDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.profilesDeleteInstance(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.profilesDeleteInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public profilesDeleteInstance(id: string, _options?: Configuration): Observable<void> {
        return this.profilesDeleteInstanceWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsDevices the fields to include for returned resources of type devices
     * @param limit maximum resources per page
     */
    public profilesDevicesGetToManyRelatedWithHttpInfo(id: string, fieldsDevices?: Array<'addedDate' | 'deviceClass' | 'model' | 'name' | 'platform' | 'status' | 'udid'>, limit?: number, _options?: Configuration): Observable<HttpInfo<DevicesWithoutIncludesResponse>> {
        const requestContextPromise = this.requestFactory.profilesDevicesGetToManyRelated(id, fieldsDevices, limit, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.profilesDevicesGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsDevices the fields to include for returned resources of type devices
     * @param limit maximum resources per page
     */
    public profilesDevicesGetToManyRelated(id: string, fieldsDevices?: Array<'addedDate' | 'deviceClass' | 'model' | 'name' | 'platform' | 'status' | 'udid'>, limit?: number, _options?: Configuration): Observable<DevicesWithoutIncludesResponse> {
        return this.profilesDevicesGetToManyRelatedWithHttpInfo(id, fieldsDevices, limit, _options).pipe(map((apiResponse: HttpInfo<DevicesWithoutIncludesResponse>) => apiResponse.data));
    }

    /**
     * @param filterName filter by attribute \&#39;name\&#39;
     * @param filterProfileState filter by attribute \&#39;profileState\&#39;
     * @param filterProfileType filter by attribute \&#39;profileType\&#39;
     * @param filterId filter by id(s)
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsProfiles the fields to include for returned resources of type profiles
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsCertificates the fields to include for returned resources of type certificates
     * @param fieldsDevices the fields to include for returned resources of type devices
     * @param fieldsBundleIds the fields to include for returned resources of type bundleIds
     * @param limitCertificates maximum number of related certificates returned (when they are included)
     * @param limitDevices maximum number of related devices returned (when they are included)
     */
    public profilesGetCollectionWithHttpInfo(filterName?: Array<string>, filterProfileState?: Array<'ACTIVE' | 'INVALID'>, filterProfileType?: Array<'IOS_APP_DEVELOPMENT' | 'IOS_APP_STORE' | 'IOS_APP_ADHOC' | 'IOS_APP_INHOUSE' | 'MAC_APP_DEVELOPMENT' | 'MAC_APP_STORE' | 'MAC_APP_DIRECT' | 'TVOS_APP_DEVELOPMENT' | 'TVOS_APP_STORE' | 'TVOS_APP_ADHOC' | 'TVOS_APP_INHOUSE' | 'MAC_CATALYST_APP_DEVELOPMENT' | 'MAC_CATALYST_APP_STORE' | 'MAC_CATALYST_APP_DIRECT'>, filterId?: Array<string>, sort?: Array<'id' | '-id' | 'name' | '-name' | 'profileState' | '-profileState' | 'profileType' | '-profileType'>, fieldsProfiles?: Array<'bundleId' | 'certificates' | 'createdDate' | 'devices' | 'expirationDate' | 'name' | 'platform' | 'profileContent' | 'profileState' | 'profileType' | 'uuid'>, limit?: number, include?: Array<'bundleId' | 'certificates' | 'devices'>, fieldsCertificates?: Array<'certificateContent' | 'certificateType' | 'csrContent' | 'displayName' | 'expirationDate' | 'name' | 'platform' | 'serialNumber'>, fieldsDevices?: Array<'addedDate' | 'deviceClass' | 'model' | 'name' | 'platform' | 'status' | 'udid'>, fieldsBundleIds?: Array<'app' | 'bundleIdCapabilities' | 'identifier' | 'name' | 'platform' | 'profiles' | 'seedId'>, limitCertificates?: number, limitDevices?: number, _options?: Configuration): Observable<HttpInfo<ProfilesResponse>> {
        const requestContextPromise = this.requestFactory.profilesGetCollection(filterName, filterProfileState, filterProfileType, filterId, sort, fieldsProfiles, limit, include, fieldsCertificates, fieldsDevices, fieldsBundleIds, limitCertificates, limitDevices, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.profilesGetCollectionWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param filterName filter by attribute \&#39;name\&#39;
     * @param filterProfileState filter by attribute \&#39;profileState\&#39;
     * @param filterProfileType filter by attribute \&#39;profileType\&#39;
     * @param filterId filter by id(s)
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsProfiles the fields to include for returned resources of type profiles
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsCertificates the fields to include for returned resources of type certificates
     * @param fieldsDevices the fields to include for returned resources of type devices
     * @param fieldsBundleIds the fields to include for returned resources of type bundleIds
     * @param limitCertificates maximum number of related certificates returned (when they are included)
     * @param limitDevices maximum number of related devices returned (when they are included)
     */
    public profilesGetCollection(filterName?: Array<string>, filterProfileState?: Array<'ACTIVE' | 'INVALID'>, filterProfileType?: Array<'IOS_APP_DEVELOPMENT' | 'IOS_APP_STORE' | 'IOS_APP_ADHOC' | 'IOS_APP_INHOUSE' | 'MAC_APP_DEVELOPMENT' | 'MAC_APP_STORE' | 'MAC_APP_DIRECT' | 'TVOS_APP_DEVELOPMENT' | 'TVOS_APP_STORE' | 'TVOS_APP_ADHOC' | 'TVOS_APP_INHOUSE' | 'MAC_CATALYST_APP_DEVELOPMENT' | 'MAC_CATALYST_APP_STORE' | 'MAC_CATALYST_APP_DIRECT'>, filterId?: Array<string>, sort?: Array<'id' | '-id' | 'name' | '-name' | 'profileState' | '-profileState' | 'profileType' | '-profileType'>, fieldsProfiles?: Array<'bundleId' | 'certificates' | 'createdDate' | 'devices' | 'expirationDate' | 'name' | 'platform' | 'profileContent' | 'profileState' | 'profileType' | 'uuid'>, limit?: number, include?: Array<'bundleId' | 'certificates' | 'devices'>, fieldsCertificates?: Array<'certificateContent' | 'certificateType' | 'csrContent' | 'displayName' | 'expirationDate' | 'name' | 'platform' | 'serialNumber'>, fieldsDevices?: Array<'addedDate' | 'deviceClass' | 'model' | 'name' | 'platform' | 'status' | 'udid'>, fieldsBundleIds?: Array<'app' | 'bundleIdCapabilities' | 'identifier' | 'name' | 'platform' | 'profiles' | 'seedId'>, limitCertificates?: number, limitDevices?: number, _options?: Configuration): Observable<ProfilesResponse> {
        return this.profilesGetCollectionWithHttpInfo(filterName, filterProfileState, filterProfileType, filterId, sort, fieldsProfiles, limit, include, fieldsCertificates, fieldsDevices, fieldsBundleIds, limitCertificates, limitDevices, _options).pipe(map((apiResponse: HttpInfo<ProfilesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsProfiles the fields to include for returned resources of type profiles
     * @param include comma-separated list of relationships to include
     * @param fieldsCertificates the fields to include for returned resources of type certificates
     * @param fieldsDevices the fields to include for returned resources of type devices
     * @param fieldsBundleIds the fields to include for returned resources of type bundleIds
     * @param limitCertificates maximum number of related certificates returned (when they are included)
     * @param limitDevices maximum number of related devices returned (when they are included)
     */
    public profilesGetInstanceWithHttpInfo(id: string, fieldsProfiles?: Array<'bundleId' | 'certificates' | 'createdDate' | 'devices' | 'expirationDate' | 'name' | 'platform' | 'profileContent' | 'profileState' | 'profileType' | 'uuid'>, include?: Array<'bundleId' | 'certificates' | 'devices'>, fieldsCertificates?: Array<'certificateContent' | 'certificateType' | 'csrContent' | 'displayName' | 'expirationDate' | 'name' | 'platform' | 'serialNumber'>, fieldsDevices?: Array<'addedDate' | 'deviceClass' | 'model' | 'name' | 'platform' | 'status' | 'udid'>, fieldsBundleIds?: Array<'app' | 'bundleIdCapabilities' | 'identifier' | 'name' | 'platform' | 'profiles' | 'seedId'>, limitCertificates?: number, limitDevices?: number, _options?: Configuration): Observable<HttpInfo<ProfileResponse>> {
        const requestContextPromise = this.requestFactory.profilesGetInstance(id, fieldsProfiles, include, fieldsCertificates, fieldsDevices, fieldsBundleIds, limitCertificates, limitDevices, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.profilesGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsProfiles the fields to include for returned resources of type profiles
     * @param include comma-separated list of relationships to include
     * @param fieldsCertificates the fields to include for returned resources of type certificates
     * @param fieldsDevices the fields to include for returned resources of type devices
     * @param fieldsBundleIds the fields to include for returned resources of type bundleIds
     * @param limitCertificates maximum number of related certificates returned (when they are included)
     * @param limitDevices maximum number of related devices returned (when they are included)
     */
    public profilesGetInstance(id: string, fieldsProfiles?: Array<'bundleId' | 'certificates' | 'createdDate' | 'devices' | 'expirationDate' | 'name' | 'platform' | 'profileContent' | 'profileState' | 'profileType' | 'uuid'>, include?: Array<'bundleId' | 'certificates' | 'devices'>, fieldsCertificates?: Array<'certificateContent' | 'certificateType' | 'csrContent' | 'displayName' | 'expirationDate' | 'name' | 'platform' | 'serialNumber'>, fieldsDevices?: Array<'addedDate' | 'deviceClass' | 'model' | 'name' | 'platform' | 'status' | 'udid'>, fieldsBundleIds?: Array<'app' | 'bundleIdCapabilities' | 'identifier' | 'name' | 'platform' | 'profiles' | 'seedId'>, limitCertificates?: number, limitDevices?: number, _options?: Configuration): Observable<ProfileResponse> {
        return this.profilesGetInstanceWithHttpInfo(id, fieldsProfiles, include, fieldsCertificates, fieldsDevices, fieldsBundleIds, limitCertificates, limitDevices, _options).pipe(map((apiResponse: HttpInfo<ProfileResponse>) => apiResponse.data));
    }

}

import { PromotedPurchaseImagesApiRequestFactory, PromotedPurchaseImagesApiResponseProcessor} from "../apis/PromotedPurchaseImagesApi.ts";
export class ObservablePromotedPurchaseImagesApi {
    private requestFactory: PromotedPurchaseImagesApiRequestFactory;
    private responseProcessor: PromotedPurchaseImagesApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: PromotedPurchaseImagesApiRequestFactory,
        responseProcessor?: PromotedPurchaseImagesApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new PromotedPurchaseImagesApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new PromotedPurchaseImagesApiResponseProcessor();
    }

    /**
     * @param promotedPurchaseImageCreateRequest PromotedPurchaseImage representation
     */
    public promotedPurchaseImagesCreateInstanceWithHttpInfo(promotedPurchaseImageCreateRequest: PromotedPurchaseImageCreateRequest, _options?: Configuration): Observable<HttpInfo<PromotedPurchaseImageResponse>> {
        const requestContextPromise = this.requestFactory.promotedPurchaseImagesCreateInstance(promotedPurchaseImageCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.promotedPurchaseImagesCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param promotedPurchaseImageCreateRequest PromotedPurchaseImage representation
     */
    public promotedPurchaseImagesCreateInstance(promotedPurchaseImageCreateRequest: PromotedPurchaseImageCreateRequest, _options?: Configuration): Observable<PromotedPurchaseImageResponse> {
        return this.promotedPurchaseImagesCreateInstanceWithHttpInfo(promotedPurchaseImageCreateRequest, _options).pipe(map((apiResponse: HttpInfo<PromotedPurchaseImageResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public promotedPurchaseImagesDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.promotedPurchaseImagesDeleteInstance(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.promotedPurchaseImagesDeleteInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public promotedPurchaseImagesDeleteInstance(id: string, _options?: Configuration): Observable<void> {
        return this.promotedPurchaseImagesDeleteInstanceWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsPromotedPurchaseImages the fields to include for returned resources of type promotedPurchaseImages
     * @param include comma-separated list of relationships to include
     */
    public promotedPurchaseImagesGetInstanceWithHttpInfo(id: string, fieldsPromotedPurchaseImages?: Array<'assetToken' | 'assetType' | 'fileName' | 'fileSize' | 'imageAsset' | 'promotedPurchase' | 'sourceFileChecksum' | 'state' | 'uploadOperations' | 'uploaded'>, include?: Array<'promotedPurchase'>, _options?: Configuration): Observable<HttpInfo<PromotedPurchaseImageResponse>> {
        const requestContextPromise = this.requestFactory.promotedPurchaseImagesGetInstance(id, fieldsPromotedPurchaseImages, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.promotedPurchaseImagesGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsPromotedPurchaseImages the fields to include for returned resources of type promotedPurchaseImages
     * @param include comma-separated list of relationships to include
     */
    public promotedPurchaseImagesGetInstance(id: string, fieldsPromotedPurchaseImages?: Array<'assetToken' | 'assetType' | 'fileName' | 'fileSize' | 'imageAsset' | 'promotedPurchase' | 'sourceFileChecksum' | 'state' | 'uploadOperations' | 'uploaded'>, include?: Array<'promotedPurchase'>, _options?: Configuration): Observable<PromotedPurchaseImageResponse> {
        return this.promotedPurchaseImagesGetInstanceWithHttpInfo(id, fieldsPromotedPurchaseImages, include, _options).pipe(map((apiResponse: HttpInfo<PromotedPurchaseImageResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param promotedPurchaseImageUpdateRequest PromotedPurchaseImage representation
     */
    public promotedPurchaseImagesUpdateInstanceWithHttpInfo(id: string, promotedPurchaseImageUpdateRequest: PromotedPurchaseImageUpdateRequest, _options?: Configuration): Observable<HttpInfo<PromotedPurchaseImageResponse>> {
        const requestContextPromise = this.requestFactory.promotedPurchaseImagesUpdateInstance(id, promotedPurchaseImageUpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.promotedPurchaseImagesUpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param promotedPurchaseImageUpdateRequest PromotedPurchaseImage representation
     */
    public promotedPurchaseImagesUpdateInstance(id: string, promotedPurchaseImageUpdateRequest: PromotedPurchaseImageUpdateRequest, _options?: Configuration): Observable<PromotedPurchaseImageResponse> {
        return this.promotedPurchaseImagesUpdateInstanceWithHttpInfo(id, promotedPurchaseImageUpdateRequest, _options).pipe(map((apiResponse: HttpInfo<PromotedPurchaseImageResponse>) => apiResponse.data));
    }

}

import { PromotedPurchasesApiRequestFactory, PromotedPurchasesApiResponseProcessor} from "../apis/PromotedPurchasesApi.ts";
export class ObservablePromotedPurchasesApi {
    private requestFactory: PromotedPurchasesApiRequestFactory;
    private responseProcessor: PromotedPurchasesApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: PromotedPurchasesApiRequestFactory,
        responseProcessor?: PromotedPurchasesApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new PromotedPurchasesApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new PromotedPurchasesApiResponseProcessor();
    }

    /**
     * @param promotedPurchaseCreateRequest PromotedPurchase representation
     */
    public promotedPurchasesCreateInstanceWithHttpInfo(promotedPurchaseCreateRequest: PromotedPurchaseCreateRequest, _options?: Configuration): Observable<HttpInfo<PromotedPurchaseResponse>> {
        const requestContextPromise = this.requestFactory.promotedPurchasesCreateInstance(promotedPurchaseCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.promotedPurchasesCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param promotedPurchaseCreateRequest PromotedPurchase representation
     */
    public promotedPurchasesCreateInstance(promotedPurchaseCreateRequest: PromotedPurchaseCreateRequest, _options?: Configuration): Observable<PromotedPurchaseResponse> {
        return this.promotedPurchasesCreateInstanceWithHttpInfo(promotedPurchaseCreateRequest, _options).pipe(map((apiResponse: HttpInfo<PromotedPurchaseResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public promotedPurchasesDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.promotedPurchasesDeleteInstance(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.promotedPurchasesDeleteInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public promotedPurchasesDeleteInstance(id: string, _options?: Configuration): Observable<void> {
        return this.promotedPurchasesDeleteInstanceWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsPromotedPurchases the fields to include for returned resources of type promotedPurchases
     * @param include comma-separated list of relationships to include
     * @param fieldsPromotedPurchaseImages the fields to include for returned resources of type promotedPurchaseImages
     * @param limitPromotionImages maximum number of related promotionImages returned (when they are included)
     */
    public promotedPurchasesGetInstanceWithHttpInfo(id: string, fieldsPromotedPurchases?: Array<'app' | 'enabled' | 'inAppPurchaseV2' | 'promotionImages' | 'state' | 'subscription' | 'visibleForAllUsers'>, include?: Array<'inAppPurchaseV2' | 'promotionImages' | 'subscription'>, fieldsPromotedPurchaseImages?: Array<'assetToken' | 'assetType' | 'fileName' | 'fileSize' | 'imageAsset' | 'promotedPurchase' | 'sourceFileChecksum' | 'state' | 'uploadOperations' | 'uploaded'>, limitPromotionImages?: number, _options?: Configuration): Observable<HttpInfo<PromotedPurchaseResponse>> {
        const requestContextPromise = this.requestFactory.promotedPurchasesGetInstance(id, fieldsPromotedPurchases, include, fieldsPromotedPurchaseImages, limitPromotionImages, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.promotedPurchasesGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsPromotedPurchases the fields to include for returned resources of type promotedPurchases
     * @param include comma-separated list of relationships to include
     * @param fieldsPromotedPurchaseImages the fields to include for returned resources of type promotedPurchaseImages
     * @param limitPromotionImages maximum number of related promotionImages returned (when they are included)
     */
    public promotedPurchasesGetInstance(id: string, fieldsPromotedPurchases?: Array<'app' | 'enabled' | 'inAppPurchaseV2' | 'promotionImages' | 'state' | 'subscription' | 'visibleForAllUsers'>, include?: Array<'inAppPurchaseV2' | 'promotionImages' | 'subscription'>, fieldsPromotedPurchaseImages?: Array<'assetToken' | 'assetType' | 'fileName' | 'fileSize' | 'imageAsset' | 'promotedPurchase' | 'sourceFileChecksum' | 'state' | 'uploadOperations' | 'uploaded'>, limitPromotionImages?: number, _options?: Configuration): Observable<PromotedPurchaseResponse> {
        return this.promotedPurchasesGetInstanceWithHttpInfo(id, fieldsPromotedPurchases, include, fieldsPromotedPurchaseImages, limitPromotionImages, _options).pipe(map((apiResponse: HttpInfo<PromotedPurchaseResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsPromotedPurchases the fields to include for returned resources of type promotedPurchases
     * @param fieldsPromotedPurchaseImages the fields to include for returned resources of type promotedPurchaseImages
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public promotedPurchasesPromotionImagesGetToManyRelatedWithHttpInfo(id: string, fieldsPromotedPurchases?: Array<'app' | 'enabled' | 'inAppPurchaseV2' | 'promotionImages' | 'state' | 'subscription' | 'visibleForAllUsers'>, fieldsPromotedPurchaseImages?: Array<'assetToken' | 'assetType' | 'fileName' | 'fileSize' | 'imageAsset' | 'promotedPurchase' | 'sourceFileChecksum' | 'state' | 'uploadOperations' | 'uploaded'>, limit?: number, include?: Array<'promotedPurchase'>, _options?: Configuration): Observable<HttpInfo<PromotedPurchaseImagesResponse>> {
        const requestContextPromise = this.requestFactory.promotedPurchasesPromotionImagesGetToManyRelated(id, fieldsPromotedPurchases, fieldsPromotedPurchaseImages, limit, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.promotedPurchasesPromotionImagesGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsPromotedPurchases the fields to include for returned resources of type promotedPurchases
     * @param fieldsPromotedPurchaseImages the fields to include for returned resources of type promotedPurchaseImages
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public promotedPurchasesPromotionImagesGetToManyRelated(id: string, fieldsPromotedPurchases?: Array<'app' | 'enabled' | 'inAppPurchaseV2' | 'promotionImages' | 'state' | 'subscription' | 'visibleForAllUsers'>, fieldsPromotedPurchaseImages?: Array<'assetToken' | 'assetType' | 'fileName' | 'fileSize' | 'imageAsset' | 'promotedPurchase' | 'sourceFileChecksum' | 'state' | 'uploadOperations' | 'uploaded'>, limit?: number, include?: Array<'promotedPurchase'>, _options?: Configuration): Observable<PromotedPurchaseImagesResponse> {
        return this.promotedPurchasesPromotionImagesGetToManyRelatedWithHttpInfo(id, fieldsPromotedPurchases, fieldsPromotedPurchaseImages, limit, include, _options).pipe(map((apiResponse: HttpInfo<PromotedPurchaseImagesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param promotedPurchaseUpdateRequest PromotedPurchase representation
     */
    public promotedPurchasesUpdateInstanceWithHttpInfo(id: string, promotedPurchaseUpdateRequest: PromotedPurchaseUpdateRequest, _options?: Configuration): Observable<HttpInfo<PromotedPurchaseResponse>> {
        const requestContextPromise = this.requestFactory.promotedPurchasesUpdateInstance(id, promotedPurchaseUpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.promotedPurchasesUpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param promotedPurchaseUpdateRequest PromotedPurchase representation
     */
    public promotedPurchasesUpdateInstance(id: string, promotedPurchaseUpdateRequest: PromotedPurchaseUpdateRequest, _options?: Configuration): Observable<PromotedPurchaseResponse> {
        return this.promotedPurchasesUpdateInstanceWithHttpInfo(id, promotedPurchaseUpdateRequest, _options).pipe(map((apiResponse: HttpInfo<PromotedPurchaseResponse>) => apiResponse.data));
    }

}

import { ReviewSubmissionItemsApiRequestFactory, ReviewSubmissionItemsApiResponseProcessor} from "../apis/ReviewSubmissionItemsApi.ts";
export class ObservableReviewSubmissionItemsApi {
    private requestFactory: ReviewSubmissionItemsApiRequestFactory;
    private responseProcessor: ReviewSubmissionItemsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: ReviewSubmissionItemsApiRequestFactory,
        responseProcessor?: ReviewSubmissionItemsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new ReviewSubmissionItemsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new ReviewSubmissionItemsApiResponseProcessor();
    }

    /**
     * @param reviewSubmissionItemCreateRequest ReviewSubmissionItem representation
     */
    public reviewSubmissionItemsCreateInstanceWithHttpInfo(reviewSubmissionItemCreateRequest: ReviewSubmissionItemCreateRequest, _options?: Configuration): Observable<HttpInfo<ReviewSubmissionItemResponse>> {
        const requestContextPromise = this.requestFactory.reviewSubmissionItemsCreateInstance(reviewSubmissionItemCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.reviewSubmissionItemsCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param reviewSubmissionItemCreateRequest ReviewSubmissionItem representation
     */
    public reviewSubmissionItemsCreateInstance(reviewSubmissionItemCreateRequest: ReviewSubmissionItemCreateRequest, _options?: Configuration): Observable<ReviewSubmissionItemResponse> {
        return this.reviewSubmissionItemsCreateInstanceWithHttpInfo(reviewSubmissionItemCreateRequest, _options).pipe(map((apiResponse: HttpInfo<ReviewSubmissionItemResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public reviewSubmissionItemsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.reviewSubmissionItemsDeleteInstance(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.reviewSubmissionItemsDeleteInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public reviewSubmissionItemsDeleteInstance(id: string, _options?: Configuration): Observable<void> {
        return this.reviewSubmissionItemsDeleteInstanceWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param reviewSubmissionItemUpdateRequest ReviewSubmissionItem representation
     */
    public reviewSubmissionItemsUpdateInstanceWithHttpInfo(id: string, reviewSubmissionItemUpdateRequest: ReviewSubmissionItemUpdateRequest, _options?: Configuration): Observable<HttpInfo<ReviewSubmissionItemResponse>> {
        const requestContextPromise = this.requestFactory.reviewSubmissionItemsUpdateInstance(id, reviewSubmissionItemUpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.reviewSubmissionItemsUpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param reviewSubmissionItemUpdateRequest ReviewSubmissionItem representation
     */
    public reviewSubmissionItemsUpdateInstance(id: string, reviewSubmissionItemUpdateRequest: ReviewSubmissionItemUpdateRequest, _options?: Configuration): Observable<ReviewSubmissionItemResponse> {
        return this.reviewSubmissionItemsUpdateInstanceWithHttpInfo(id, reviewSubmissionItemUpdateRequest, _options).pipe(map((apiResponse: HttpInfo<ReviewSubmissionItemResponse>) => apiResponse.data));
    }

}

import { ReviewSubmissionsApiRequestFactory, ReviewSubmissionsApiResponseProcessor} from "../apis/ReviewSubmissionsApi.ts";
export class ObservableReviewSubmissionsApi {
    private requestFactory: ReviewSubmissionsApiRequestFactory;
    private responseProcessor: ReviewSubmissionsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: ReviewSubmissionsApiRequestFactory,
        responseProcessor?: ReviewSubmissionsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new ReviewSubmissionsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new ReviewSubmissionsApiResponseProcessor();
    }

    /**
     * @param reviewSubmissionCreateRequest ReviewSubmission representation
     */
    public reviewSubmissionsCreateInstanceWithHttpInfo(reviewSubmissionCreateRequest: ReviewSubmissionCreateRequest, _options?: Configuration): Observable<HttpInfo<ReviewSubmissionResponse>> {
        const requestContextPromise = this.requestFactory.reviewSubmissionsCreateInstance(reviewSubmissionCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.reviewSubmissionsCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param reviewSubmissionCreateRequest ReviewSubmission representation
     */
    public reviewSubmissionsCreateInstance(reviewSubmissionCreateRequest: ReviewSubmissionCreateRequest, _options?: Configuration): Observable<ReviewSubmissionResponse> {
        return this.reviewSubmissionsCreateInstanceWithHttpInfo(reviewSubmissionCreateRequest, _options).pipe(map((apiResponse: HttpInfo<ReviewSubmissionResponse>) => apiResponse.data));
    }

    /**
     * @param filterApp filter by id(s) of related \&#39;app\&#39;
     * @param filterPlatform filter by attribute \&#39;platform\&#39;
     * @param filterState filter by attribute \&#39;state\&#39;
     * @param fieldsReviewSubmissions the fields to include for returned resources of type reviewSubmissions
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsReviewSubmissionItems the fields to include for returned resources of type reviewSubmissionItems
     * @param limitItems maximum number of related items returned (when they are included)
     */
    public reviewSubmissionsGetCollectionWithHttpInfo(filterApp: Array<string>, filterPlatform?: Array<'IOS' | 'MAC_OS' | 'TV_OS' | 'VISION_OS'>, filterState?: Array<'READY_FOR_REVIEW' | 'WAITING_FOR_REVIEW' | 'IN_REVIEW' | 'UNRESOLVED_ISSUES' | 'CANCELING' | 'COMPLETING' | 'COMPLETE'>, fieldsReviewSubmissions?: Array<'app' | 'appStoreVersionForReview' | 'canceled' | 'items' | 'lastUpdatedByActor' | 'platform' | 'state' | 'submitted' | 'submittedByActor' | 'submittedDate'>, limit?: number, include?: Array<'app' | 'appStoreVersionForReview' | 'items' | 'lastUpdatedByActor' | 'submittedByActor'>, fieldsReviewSubmissionItems?: Array<'appCustomProductPageVersion' | 'appEvent' | 'appStoreVersion' | 'appStoreVersionExperiment' | 'appStoreVersionExperimentV2' | 'removed' | 'resolved' | 'reviewSubmission' | 'state'>, limitItems?: number, _options?: Configuration): Observable<HttpInfo<ReviewSubmissionsResponse>> {
        const requestContextPromise = this.requestFactory.reviewSubmissionsGetCollection(filterApp, filterPlatform, filterState, fieldsReviewSubmissions, limit, include, fieldsReviewSubmissionItems, limitItems, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.reviewSubmissionsGetCollectionWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param filterApp filter by id(s) of related \&#39;app\&#39;
     * @param filterPlatform filter by attribute \&#39;platform\&#39;
     * @param filterState filter by attribute \&#39;state\&#39;
     * @param fieldsReviewSubmissions the fields to include for returned resources of type reviewSubmissions
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsReviewSubmissionItems the fields to include for returned resources of type reviewSubmissionItems
     * @param limitItems maximum number of related items returned (when they are included)
     */
    public reviewSubmissionsGetCollection(filterApp: Array<string>, filterPlatform?: Array<'IOS' | 'MAC_OS' | 'TV_OS' | 'VISION_OS'>, filterState?: Array<'READY_FOR_REVIEW' | 'WAITING_FOR_REVIEW' | 'IN_REVIEW' | 'UNRESOLVED_ISSUES' | 'CANCELING' | 'COMPLETING' | 'COMPLETE'>, fieldsReviewSubmissions?: Array<'app' | 'appStoreVersionForReview' | 'canceled' | 'items' | 'lastUpdatedByActor' | 'platform' | 'state' | 'submitted' | 'submittedByActor' | 'submittedDate'>, limit?: number, include?: Array<'app' | 'appStoreVersionForReview' | 'items' | 'lastUpdatedByActor' | 'submittedByActor'>, fieldsReviewSubmissionItems?: Array<'appCustomProductPageVersion' | 'appEvent' | 'appStoreVersion' | 'appStoreVersionExperiment' | 'appStoreVersionExperimentV2' | 'removed' | 'resolved' | 'reviewSubmission' | 'state'>, limitItems?: number, _options?: Configuration): Observable<ReviewSubmissionsResponse> {
        return this.reviewSubmissionsGetCollectionWithHttpInfo(filterApp, filterPlatform, filterState, fieldsReviewSubmissions, limit, include, fieldsReviewSubmissionItems, limitItems, _options).pipe(map((apiResponse: HttpInfo<ReviewSubmissionsResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsReviewSubmissions the fields to include for returned resources of type reviewSubmissions
     * @param include comma-separated list of relationships to include
     * @param fieldsReviewSubmissionItems the fields to include for returned resources of type reviewSubmissionItems
     * @param limitItems maximum number of related items returned (when they are included)
     */
    public reviewSubmissionsGetInstanceWithHttpInfo(id: string, fieldsReviewSubmissions?: Array<'app' | 'appStoreVersionForReview' | 'canceled' | 'items' | 'lastUpdatedByActor' | 'platform' | 'state' | 'submitted' | 'submittedByActor' | 'submittedDate'>, include?: Array<'app' | 'appStoreVersionForReview' | 'items' | 'lastUpdatedByActor' | 'submittedByActor'>, fieldsReviewSubmissionItems?: Array<'appCustomProductPageVersion' | 'appEvent' | 'appStoreVersion' | 'appStoreVersionExperiment' | 'appStoreVersionExperimentV2' | 'removed' | 'resolved' | 'reviewSubmission' | 'state'>, limitItems?: number, _options?: Configuration): Observable<HttpInfo<ReviewSubmissionResponse>> {
        const requestContextPromise = this.requestFactory.reviewSubmissionsGetInstance(id, fieldsReviewSubmissions, include, fieldsReviewSubmissionItems, limitItems, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.reviewSubmissionsGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsReviewSubmissions the fields to include for returned resources of type reviewSubmissions
     * @param include comma-separated list of relationships to include
     * @param fieldsReviewSubmissionItems the fields to include for returned resources of type reviewSubmissionItems
     * @param limitItems maximum number of related items returned (when they are included)
     */
    public reviewSubmissionsGetInstance(id: string, fieldsReviewSubmissions?: Array<'app' | 'appStoreVersionForReview' | 'canceled' | 'items' | 'lastUpdatedByActor' | 'platform' | 'state' | 'submitted' | 'submittedByActor' | 'submittedDate'>, include?: Array<'app' | 'appStoreVersionForReview' | 'items' | 'lastUpdatedByActor' | 'submittedByActor'>, fieldsReviewSubmissionItems?: Array<'appCustomProductPageVersion' | 'appEvent' | 'appStoreVersion' | 'appStoreVersionExperiment' | 'appStoreVersionExperimentV2' | 'removed' | 'resolved' | 'reviewSubmission' | 'state'>, limitItems?: number, _options?: Configuration): Observable<ReviewSubmissionResponse> {
        return this.reviewSubmissionsGetInstanceWithHttpInfo(id, fieldsReviewSubmissions, include, fieldsReviewSubmissionItems, limitItems, _options).pipe(map((apiResponse: HttpInfo<ReviewSubmissionResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppStoreVersionExperiments the fields to include for returned resources of type appStoreVersionExperiments
     * @param fieldsReviewSubmissionItems the fields to include for returned resources of type reviewSubmissionItems
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsAppCustomProductPageVersions the fields to include for returned resources of type appCustomProductPageVersions
     * @param fieldsAppEvents the fields to include for returned resources of type appEvents
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public reviewSubmissionsItemsGetToManyRelatedWithHttpInfo(id: string, fieldsAppStoreVersionExperiments?: Array<'app' | 'appStoreVersion' | 'appStoreVersionExperimentTreatments' | 'controlVersions' | 'endDate' | 'latestControlVersion' | 'name' | 'platform' | 'reviewRequired' | 'startDate' | 'started' | 'state' | 'trafficProportion'>, fieldsReviewSubmissionItems?: Array<'appCustomProductPageVersion' | 'appEvent' | 'appStoreVersion' | 'appStoreVersionExperiment' | 'appStoreVersionExperimentV2' | 'removed' | 'resolved' | 'reviewSubmission' | 'state'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsAppCustomProductPageVersions?: Array<'appCustomProductPage' | 'appCustomProductPageLocalizations' | 'state' | 'version'>, fieldsAppEvents?: Array<'app' | 'archivedTerritorySchedules' | 'badge' | 'deepLink' | 'eventState' | 'localizations' | 'primaryLocale' | 'priority' | 'purchaseRequirement' | 'purpose' | 'referenceName' | 'territorySchedules'>, limit?: number, include?: Array<'appCustomProductPageVersion' | 'appEvent' | 'appStoreVersion' | 'appStoreVersionExperiment' | 'appStoreVersionExperimentV2'>, _options?: Configuration): Observable<HttpInfo<ReviewSubmissionItemsResponse>> {
        const requestContextPromise = this.requestFactory.reviewSubmissionsItemsGetToManyRelated(id, fieldsAppStoreVersionExperiments, fieldsReviewSubmissionItems, fieldsAppStoreVersions, fieldsAppCustomProductPageVersions, fieldsAppEvents, limit, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.reviewSubmissionsItemsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppStoreVersionExperiments the fields to include for returned resources of type appStoreVersionExperiments
     * @param fieldsReviewSubmissionItems the fields to include for returned resources of type reviewSubmissionItems
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsAppCustomProductPageVersions the fields to include for returned resources of type appCustomProductPageVersions
     * @param fieldsAppEvents the fields to include for returned resources of type appEvents
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public reviewSubmissionsItemsGetToManyRelated(id: string, fieldsAppStoreVersionExperiments?: Array<'app' | 'appStoreVersion' | 'appStoreVersionExperimentTreatments' | 'controlVersions' | 'endDate' | 'latestControlVersion' | 'name' | 'platform' | 'reviewRequired' | 'startDate' | 'started' | 'state' | 'trafficProportion'>, fieldsReviewSubmissionItems?: Array<'appCustomProductPageVersion' | 'appEvent' | 'appStoreVersion' | 'appStoreVersionExperiment' | 'appStoreVersionExperimentV2' | 'removed' | 'resolved' | 'reviewSubmission' | 'state'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsAppCustomProductPageVersions?: Array<'appCustomProductPage' | 'appCustomProductPageLocalizations' | 'state' | 'version'>, fieldsAppEvents?: Array<'app' | 'archivedTerritorySchedules' | 'badge' | 'deepLink' | 'eventState' | 'localizations' | 'primaryLocale' | 'priority' | 'purchaseRequirement' | 'purpose' | 'referenceName' | 'territorySchedules'>, limit?: number, include?: Array<'appCustomProductPageVersion' | 'appEvent' | 'appStoreVersion' | 'appStoreVersionExperiment' | 'appStoreVersionExperimentV2'>, _options?: Configuration): Observable<ReviewSubmissionItemsResponse> {
        return this.reviewSubmissionsItemsGetToManyRelatedWithHttpInfo(id, fieldsAppStoreVersionExperiments, fieldsReviewSubmissionItems, fieldsAppStoreVersions, fieldsAppCustomProductPageVersions, fieldsAppEvents, limit, include, _options).pipe(map((apiResponse: HttpInfo<ReviewSubmissionItemsResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param reviewSubmissionUpdateRequest ReviewSubmission representation
     */
    public reviewSubmissionsUpdateInstanceWithHttpInfo(id: string, reviewSubmissionUpdateRequest: ReviewSubmissionUpdateRequest, _options?: Configuration): Observable<HttpInfo<ReviewSubmissionResponse>> {
        const requestContextPromise = this.requestFactory.reviewSubmissionsUpdateInstance(id, reviewSubmissionUpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.reviewSubmissionsUpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param reviewSubmissionUpdateRequest ReviewSubmission representation
     */
    public reviewSubmissionsUpdateInstance(id: string, reviewSubmissionUpdateRequest: ReviewSubmissionUpdateRequest, _options?: Configuration): Observable<ReviewSubmissionResponse> {
        return this.reviewSubmissionsUpdateInstanceWithHttpInfo(id, reviewSubmissionUpdateRequest, _options).pipe(map((apiResponse: HttpInfo<ReviewSubmissionResponse>) => apiResponse.data));
    }

}

import { RoutingAppCoveragesApiRequestFactory, RoutingAppCoveragesApiResponseProcessor} from "../apis/RoutingAppCoveragesApi.ts";
export class ObservableRoutingAppCoveragesApi {
    private requestFactory: RoutingAppCoveragesApiRequestFactory;
    private responseProcessor: RoutingAppCoveragesApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: RoutingAppCoveragesApiRequestFactory,
        responseProcessor?: RoutingAppCoveragesApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new RoutingAppCoveragesApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new RoutingAppCoveragesApiResponseProcessor();
    }

    /**
     * @param routingAppCoverageCreateRequest RoutingAppCoverage representation
     */
    public routingAppCoveragesCreateInstanceWithHttpInfo(routingAppCoverageCreateRequest: RoutingAppCoverageCreateRequest, _options?: Configuration): Observable<HttpInfo<RoutingAppCoverageResponse>> {
        const requestContextPromise = this.requestFactory.routingAppCoveragesCreateInstance(routingAppCoverageCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.routingAppCoveragesCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param routingAppCoverageCreateRequest RoutingAppCoverage representation
     */
    public routingAppCoveragesCreateInstance(routingAppCoverageCreateRequest: RoutingAppCoverageCreateRequest, _options?: Configuration): Observable<RoutingAppCoverageResponse> {
        return this.routingAppCoveragesCreateInstanceWithHttpInfo(routingAppCoverageCreateRequest, _options).pipe(map((apiResponse: HttpInfo<RoutingAppCoverageResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public routingAppCoveragesDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.routingAppCoveragesDeleteInstance(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.routingAppCoveragesDeleteInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public routingAppCoveragesDeleteInstance(id: string, _options?: Configuration): Observable<void> {
        return this.routingAppCoveragesDeleteInstanceWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsRoutingAppCoverages the fields to include for returned resources of type routingAppCoverages
     * @param include comma-separated list of relationships to include
     */
    public routingAppCoveragesGetInstanceWithHttpInfo(id: string, fieldsRoutingAppCoverages?: Array<'appStoreVersion' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, include?: Array<'appStoreVersion'>, _options?: Configuration): Observable<HttpInfo<RoutingAppCoverageResponse>> {
        const requestContextPromise = this.requestFactory.routingAppCoveragesGetInstance(id, fieldsRoutingAppCoverages, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.routingAppCoveragesGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsRoutingAppCoverages the fields to include for returned resources of type routingAppCoverages
     * @param include comma-separated list of relationships to include
     */
    public routingAppCoveragesGetInstance(id: string, fieldsRoutingAppCoverages?: Array<'appStoreVersion' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, include?: Array<'appStoreVersion'>, _options?: Configuration): Observable<RoutingAppCoverageResponse> {
        return this.routingAppCoveragesGetInstanceWithHttpInfo(id, fieldsRoutingAppCoverages, include, _options).pipe(map((apiResponse: HttpInfo<RoutingAppCoverageResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param routingAppCoverageUpdateRequest RoutingAppCoverage representation
     */
    public routingAppCoveragesUpdateInstanceWithHttpInfo(id: string, routingAppCoverageUpdateRequest: RoutingAppCoverageUpdateRequest, _options?: Configuration): Observable<HttpInfo<RoutingAppCoverageResponse>> {
        const requestContextPromise = this.requestFactory.routingAppCoveragesUpdateInstance(id, routingAppCoverageUpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.routingAppCoveragesUpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param routingAppCoverageUpdateRequest RoutingAppCoverage representation
     */
    public routingAppCoveragesUpdateInstance(id: string, routingAppCoverageUpdateRequest: RoutingAppCoverageUpdateRequest, _options?: Configuration): Observable<RoutingAppCoverageResponse> {
        return this.routingAppCoveragesUpdateInstanceWithHttpInfo(id, routingAppCoverageUpdateRequest, _options).pipe(map((apiResponse: HttpInfo<RoutingAppCoverageResponse>) => apiResponse.data));
    }

}

import { SalesReportsApiRequestFactory, SalesReportsApiResponseProcessor} from "../apis/SalesReportsApi.ts";
export class ObservableSalesReportsApi {
    private requestFactory: SalesReportsApiRequestFactory;
    private responseProcessor: SalesReportsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: SalesReportsApiRequestFactory,
        responseProcessor?: SalesReportsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new SalesReportsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new SalesReportsApiResponseProcessor();
    }

    /**
     * @param filterFrequency filter by attribute \&#39;frequency\&#39;
     * @param filterReportSubType filter by attribute \&#39;reportSubType\&#39;
     * @param filterReportType filter by attribute \&#39;reportType\&#39;
     * @param filterVendorNumber filter by attribute \&#39;vendorNumber\&#39;
     * @param filterReportDate filter by attribute \&#39;reportDate\&#39;
     * @param filterVersion filter by attribute \&#39;version\&#39;
     */
    public salesReportsGetCollectionWithHttpInfo(filterFrequency: Array<'DAILY' | 'WEEKLY' | 'MONTHLY' | 'YEARLY'>, filterReportSubType: Array<'SUMMARY' | 'DETAILED' | 'SUMMARY_INSTALL_TYPE' | 'SUMMARY_TERRITORY' | 'SUMMARY_CHANNEL'>, filterReportType: Array<'SALES' | 'PRE_ORDER' | 'NEWSSTAND' | 'SUBSCRIPTION' | 'SUBSCRIPTION_EVENT' | 'SUBSCRIBER' | 'SUBSCRIPTION_OFFER_CODE_REDEMPTION' | 'INSTALLS' | 'FIRST_ANNUAL'>, filterVendorNumber: Array<string>, filterReportDate?: Array<string>, filterVersion?: Array<string>, _options?: Configuration): Observable<HttpInfo<HttpFile>> {
        const requestContextPromise = this.requestFactory.salesReportsGetCollection(filterFrequency, filterReportSubType, filterReportType, filterVendorNumber, filterReportDate, filterVersion, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.salesReportsGetCollectionWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param filterFrequency filter by attribute \&#39;frequency\&#39;
     * @param filterReportSubType filter by attribute \&#39;reportSubType\&#39;
     * @param filterReportType filter by attribute \&#39;reportType\&#39;
     * @param filterVendorNumber filter by attribute \&#39;vendorNumber\&#39;
     * @param filterReportDate filter by attribute \&#39;reportDate\&#39;
     * @param filterVersion filter by attribute \&#39;version\&#39;
     */
    public salesReportsGetCollection(filterFrequency: Array<'DAILY' | 'WEEKLY' | 'MONTHLY' | 'YEARLY'>, filterReportSubType: Array<'SUMMARY' | 'DETAILED' | 'SUMMARY_INSTALL_TYPE' | 'SUMMARY_TERRITORY' | 'SUMMARY_CHANNEL'>, filterReportType: Array<'SALES' | 'PRE_ORDER' | 'NEWSSTAND' | 'SUBSCRIPTION' | 'SUBSCRIPTION_EVENT' | 'SUBSCRIBER' | 'SUBSCRIPTION_OFFER_CODE_REDEMPTION' | 'INSTALLS' | 'FIRST_ANNUAL'>, filterVendorNumber: Array<string>, filterReportDate?: Array<string>, filterVersion?: Array<string>, _options?: Configuration): Observable<HttpFile> {
        return this.salesReportsGetCollectionWithHttpInfo(filterFrequency, filterReportSubType, filterReportType, filterVendorNumber, filterReportDate, filterVersion, _options).pipe(map((apiResponse: HttpInfo<HttpFile>) => apiResponse.data));
    }

}

import { SandboxTestersApiRequestFactory, SandboxTestersApiResponseProcessor} from "../apis/SandboxTestersApi.ts";
export class ObservableSandboxTestersApi {
    private requestFactory: SandboxTestersApiRequestFactory;
    private responseProcessor: SandboxTestersApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: SandboxTestersApiRequestFactory,
        responseProcessor?: SandboxTestersApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new SandboxTestersApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new SandboxTestersApiResponseProcessor();
    }

    /**
     * @param fieldsSandboxTesters the fields to include for returned resources of type sandboxTesters
     * @param limit maximum resources per page
     */
    public sandboxTestersV2GetCollectionWithHttpInfo(fieldsSandboxTesters?: Array<'acAccountName' | 'applePayCompatible' | 'firstName' | 'interruptPurchases' | 'lastName' | 'subscriptionRenewalRate' | 'territory'>, limit?: number, _options?: Configuration): Observable<HttpInfo<SandboxTestersV2Response>> {
        const requestContextPromise = this.requestFactory.sandboxTestersV2GetCollection(fieldsSandboxTesters, limit, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.sandboxTestersV2GetCollectionWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param fieldsSandboxTesters the fields to include for returned resources of type sandboxTesters
     * @param limit maximum resources per page
     */
    public sandboxTestersV2GetCollection(fieldsSandboxTesters?: Array<'acAccountName' | 'applePayCompatible' | 'firstName' | 'interruptPurchases' | 'lastName' | 'subscriptionRenewalRate' | 'territory'>, limit?: number, _options?: Configuration): Observable<SandboxTestersV2Response> {
        return this.sandboxTestersV2GetCollectionWithHttpInfo(fieldsSandboxTesters, limit, _options).pipe(map((apiResponse: HttpInfo<SandboxTestersV2Response>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param sandboxTesterV2UpdateRequest SandboxTester representation
     */
    public sandboxTestersV2UpdateInstanceWithHttpInfo(id: string, sandboxTesterV2UpdateRequest: SandboxTesterV2UpdateRequest, _options?: Configuration): Observable<HttpInfo<SandboxTesterV2Response>> {
        const requestContextPromise = this.requestFactory.sandboxTestersV2UpdateInstance(id, sandboxTesterV2UpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.sandboxTestersV2UpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param sandboxTesterV2UpdateRequest SandboxTester representation
     */
    public sandboxTestersV2UpdateInstance(id: string, sandboxTesterV2UpdateRequest: SandboxTesterV2UpdateRequest, _options?: Configuration): Observable<SandboxTesterV2Response> {
        return this.sandboxTestersV2UpdateInstanceWithHttpInfo(id, sandboxTesterV2UpdateRequest, _options).pipe(map((apiResponse: HttpInfo<SandboxTesterV2Response>) => apiResponse.data));
    }

}

import { SandboxTestersClearPurchaseHistoryRequestApiRequestFactory, SandboxTestersClearPurchaseHistoryRequestApiResponseProcessor} from "../apis/SandboxTestersClearPurchaseHistoryRequestApi.ts";
export class ObservableSandboxTestersClearPurchaseHistoryRequestApi {
    private requestFactory: SandboxTestersClearPurchaseHistoryRequestApiRequestFactory;
    private responseProcessor: SandboxTestersClearPurchaseHistoryRequestApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: SandboxTestersClearPurchaseHistoryRequestApiRequestFactory,
        responseProcessor?: SandboxTestersClearPurchaseHistoryRequestApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new SandboxTestersClearPurchaseHistoryRequestApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new SandboxTestersClearPurchaseHistoryRequestApiResponseProcessor();
    }

    /**
     * @param sandboxTestersClearPurchaseHistoryRequestV2CreateRequest SandboxTestersClearPurchaseHistoryRequest representation
     */
    public sandboxTestersClearPurchaseHistoryRequestV2CreateInstanceWithHttpInfo(sandboxTestersClearPurchaseHistoryRequestV2CreateRequest: SandboxTestersClearPurchaseHistoryRequestV2CreateRequest, _options?: Configuration): Observable<HttpInfo<SandboxTestersClearPurchaseHistoryRequestV2Response>> {
        const requestContextPromise = this.requestFactory.sandboxTestersClearPurchaseHistoryRequestV2CreateInstance(sandboxTestersClearPurchaseHistoryRequestV2CreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.sandboxTestersClearPurchaseHistoryRequestV2CreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param sandboxTestersClearPurchaseHistoryRequestV2CreateRequest SandboxTestersClearPurchaseHistoryRequest representation
     */
    public sandboxTestersClearPurchaseHistoryRequestV2CreateInstance(sandboxTestersClearPurchaseHistoryRequestV2CreateRequest: SandboxTestersClearPurchaseHistoryRequestV2CreateRequest, _options?: Configuration): Observable<SandboxTestersClearPurchaseHistoryRequestV2Response> {
        return this.sandboxTestersClearPurchaseHistoryRequestV2CreateInstanceWithHttpInfo(sandboxTestersClearPurchaseHistoryRequestV2CreateRequest, _options).pipe(map((apiResponse: HttpInfo<SandboxTestersClearPurchaseHistoryRequestV2Response>) => apiResponse.data));
    }

}

import { ScmGitReferencesApiRequestFactory, ScmGitReferencesApiResponseProcessor} from "../apis/ScmGitReferencesApi.ts";
export class ObservableScmGitReferencesApi {
    private requestFactory: ScmGitReferencesApiRequestFactory;
    private responseProcessor: ScmGitReferencesApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: ScmGitReferencesApiRequestFactory,
        responseProcessor?: ScmGitReferencesApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new ScmGitReferencesApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new ScmGitReferencesApiResponseProcessor();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsScmGitReferences the fields to include for returned resources of type scmGitReferences
     * @param include comma-separated list of relationships to include
     */
    public scmGitReferencesGetInstanceWithHttpInfo(id: string, fieldsScmGitReferences?: Array<'canonicalName' | 'isDeleted' | 'kind' | 'name' | 'repository'>, include?: Array<'repository'>, _options?: Configuration): Observable<HttpInfo<ScmGitReferenceResponse>> {
        const requestContextPromise = this.requestFactory.scmGitReferencesGetInstance(id, fieldsScmGitReferences, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.scmGitReferencesGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsScmGitReferences the fields to include for returned resources of type scmGitReferences
     * @param include comma-separated list of relationships to include
     */
    public scmGitReferencesGetInstance(id: string, fieldsScmGitReferences?: Array<'canonicalName' | 'isDeleted' | 'kind' | 'name' | 'repository'>, include?: Array<'repository'>, _options?: Configuration): Observable<ScmGitReferenceResponse> {
        return this.scmGitReferencesGetInstanceWithHttpInfo(id, fieldsScmGitReferences, include, _options).pipe(map((apiResponse: HttpInfo<ScmGitReferenceResponse>) => apiResponse.data));
    }

}

import { ScmProvidersApiRequestFactory, ScmProvidersApiResponseProcessor} from "../apis/ScmProvidersApi.ts";
export class ObservableScmProvidersApi {
    private requestFactory: ScmProvidersApiRequestFactory;
    private responseProcessor: ScmProvidersApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: ScmProvidersApiRequestFactory,
        responseProcessor?: ScmProvidersApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new ScmProvidersApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new ScmProvidersApiResponseProcessor();
    }

    /**
     * @param fieldsScmProviders the fields to include for returned resources of type scmProviders
     * @param limit maximum resources per page
     * @param fieldsScmRepositories the fields to include for returned resources of type scmRepositories
     */
    public scmProvidersGetCollectionWithHttpInfo(fieldsScmProviders?: Array<'repositories' | 'scmProviderType' | 'url'>, limit?: number, fieldsScmRepositories?: Array<'defaultBranch' | 'gitReferences' | 'httpCloneUrl' | 'lastAccessedDate' | 'ownerName' | 'pullRequests' | 'repositoryName' | 'scmProvider' | 'sshCloneUrl'>, _options?: Configuration): Observable<HttpInfo<ScmProvidersResponse>> {
        const requestContextPromise = this.requestFactory.scmProvidersGetCollection(fieldsScmProviders, limit, fieldsScmRepositories, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.scmProvidersGetCollectionWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param fieldsScmProviders the fields to include for returned resources of type scmProviders
     * @param limit maximum resources per page
     * @param fieldsScmRepositories the fields to include for returned resources of type scmRepositories
     */
    public scmProvidersGetCollection(fieldsScmProviders?: Array<'repositories' | 'scmProviderType' | 'url'>, limit?: number, fieldsScmRepositories?: Array<'defaultBranch' | 'gitReferences' | 'httpCloneUrl' | 'lastAccessedDate' | 'ownerName' | 'pullRequests' | 'repositoryName' | 'scmProvider' | 'sshCloneUrl'>, _options?: Configuration): Observable<ScmProvidersResponse> {
        return this.scmProvidersGetCollectionWithHttpInfo(fieldsScmProviders, limit, fieldsScmRepositories, _options).pipe(map((apiResponse: HttpInfo<ScmProvidersResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsScmProviders the fields to include for returned resources of type scmProviders
     * @param fieldsScmRepositories the fields to include for returned resources of type scmRepositories
     */
    public scmProvidersGetInstanceWithHttpInfo(id: string, fieldsScmProviders?: Array<'repositories' | 'scmProviderType' | 'url'>, fieldsScmRepositories?: Array<'defaultBranch' | 'gitReferences' | 'httpCloneUrl' | 'lastAccessedDate' | 'ownerName' | 'pullRequests' | 'repositoryName' | 'scmProvider' | 'sshCloneUrl'>, _options?: Configuration): Observable<HttpInfo<ScmProviderResponse>> {
        const requestContextPromise = this.requestFactory.scmProvidersGetInstance(id, fieldsScmProviders, fieldsScmRepositories, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.scmProvidersGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsScmProviders the fields to include for returned resources of type scmProviders
     * @param fieldsScmRepositories the fields to include for returned resources of type scmRepositories
     */
    public scmProvidersGetInstance(id: string, fieldsScmProviders?: Array<'repositories' | 'scmProviderType' | 'url'>, fieldsScmRepositories?: Array<'defaultBranch' | 'gitReferences' | 'httpCloneUrl' | 'lastAccessedDate' | 'ownerName' | 'pullRequests' | 'repositoryName' | 'scmProvider' | 'sshCloneUrl'>, _options?: Configuration): Observable<ScmProviderResponse> {
        return this.scmProvidersGetInstanceWithHttpInfo(id, fieldsScmProviders, fieldsScmRepositories, _options).pipe(map((apiResponse: HttpInfo<ScmProviderResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param filterId filter by id(s)
     * @param fieldsScmGitReferences the fields to include for returned resources of type scmGitReferences
     * @param fieldsScmProviders the fields to include for returned resources of type scmProviders
     * @param fieldsScmRepositories the fields to include for returned resources of type scmRepositories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public scmProvidersRepositoriesGetToManyRelatedWithHttpInfo(id: string, filterId?: Array<string>, fieldsScmGitReferences?: Array<'canonicalName' | 'isDeleted' | 'kind' | 'name' | 'repository'>, fieldsScmProviders?: Array<'repositories' | 'scmProviderType' | 'url'>, fieldsScmRepositories?: Array<'defaultBranch' | 'gitReferences' | 'httpCloneUrl' | 'lastAccessedDate' | 'ownerName' | 'pullRequests' | 'repositoryName' | 'scmProvider' | 'sshCloneUrl'>, limit?: number, include?: Array<'defaultBranch' | 'scmProvider'>, _options?: Configuration): Observable<HttpInfo<ScmRepositoriesResponse>> {
        const requestContextPromise = this.requestFactory.scmProvidersRepositoriesGetToManyRelated(id, filterId, fieldsScmGitReferences, fieldsScmProviders, fieldsScmRepositories, limit, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.scmProvidersRepositoriesGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param filterId filter by id(s)
     * @param fieldsScmGitReferences the fields to include for returned resources of type scmGitReferences
     * @param fieldsScmProviders the fields to include for returned resources of type scmProviders
     * @param fieldsScmRepositories the fields to include for returned resources of type scmRepositories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public scmProvidersRepositoriesGetToManyRelated(id: string, filterId?: Array<string>, fieldsScmGitReferences?: Array<'canonicalName' | 'isDeleted' | 'kind' | 'name' | 'repository'>, fieldsScmProviders?: Array<'repositories' | 'scmProviderType' | 'url'>, fieldsScmRepositories?: Array<'defaultBranch' | 'gitReferences' | 'httpCloneUrl' | 'lastAccessedDate' | 'ownerName' | 'pullRequests' | 'repositoryName' | 'scmProvider' | 'sshCloneUrl'>, limit?: number, include?: Array<'defaultBranch' | 'scmProvider'>, _options?: Configuration): Observable<ScmRepositoriesResponse> {
        return this.scmProvidersRepositoriesGetToManyRelatedWithHttpInfo(id, filterId, fieldsScmGitReferences, fieldsScmProviders, fieldsScmRepositories, limit, include, _options).pipe(map((apiResponse: HttpInfo<ScmRepositoriesResponse>) => apiResponse.data));
    }

}

import { ScmPullRequestsApiRequestFactory, ScmPullRequestsApiResponseProcessor} from "../apis/ScmPullRequestsApi.ts";
export class ObservableScmPullRequestsApi {
    private requestFactory: ScmPullRequestsApiRequestFactory;
    private responseProcessor: ScmPullRequestsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: ScmPullRequestsApiRequestFactory,
        responseProcessor?: ScmPullRequestsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new ScmPullRequestsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new ScmPullRequestsApiResponseProcessor();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsScmPullRequests the fields to include for returned resources of type scmPullRequests
     * @param include comma-separated list of relationships to include
     */
    public scmPullRequestsGetInstanceWithHttpInfo(id: string, fieldsScmPullRequests?: Array<'destinationBranchName' | 'destinationRepositoryName' | 'destinationRepositoryOwner' | 'isClosed' | 'isCrossRepository' | 'number' | 'repository' | 'sourceBranchName' | 'sourceRepositoryName' | 'sourceRepositoryOwner' | 'title' | 'webUrl'>, include?: Array<'repository'>, _options?: Configuration): Observable<HttpInfo<ScmPullRequestResponse>> {
        const requestContextPromise = this.requestFactory.scmPullRequestsGetInstance(id, fieldsScmPullRequests, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.scmPullRequestsGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsScmPullRequests the fields to include for returned resources of type scmPullRequests
     * @param include comma-separated list of relationships to include
     */
    public scmPullRequestsGetInstance(id: string, fieldsScmPullRequests?: Array<'destinationBranchName' | 'destinationRepositoryName' | 'destinationRepositoryOwner' | 'isClosed' | 'isCrossRepository' | 'number' | 'repository' | 'sourceBranchName' | 'sourceRepositoryName' | 'sourceRepositoryOwner' | 'title' | 'webUrl'>, include?: Array<'repository'>, _options?: Configuration): Observable<ScmPullRequestResponse> {
        return this.scmPullRequestsGetInstanceWithHttpInfo(id, fieldsScmPullRequests, include, _options).pipe(map((apiResponse: HttpInfo<ScmPullRequestResponse>) => apiResponse.data));
    }

}

import { ScmRepositoriesApiRequestFactory, ScmRepositoriesApiResponseProcessor} from "../apis/ScmRepositoriesApi.ts";
export class ObservableScmRepositoriesApi {
    private requestFactory: ScmRepositoriesApiRequestFactory;
    private responseProcessor: ScmRepositoriesApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: ScmRepositoriesApiRequestFactory,
        responseProcessor?: ScmRepositoriesApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new ScmRepositoriesApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new ScmRepositoriesApiResponseProcessor();
    }

    /**
     * @param filterId filter by id(s)
     * @param fieldsScmRepositories the fields to include for returned resources of type scmRepositories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsScmGitReferences the fields to include for returned resources of type scmGitReferences
     * @param fieldsScmPullRequests the fields to include for returned resources of type scmPullRequests
     */
    public scmRepositoriesGetCollectionWithHttpInfo(filterId?: Array<string>, fieldsScmRepositories?: Array<'defaultBranch' | 'gitReferences' | 'httpCloneUrl' | 'lastAccessedDate' | 'ownerName' | 'pullRequests' | 'repositoryName' | 'scmProvider' | 'sshCloneUrl'>, limit?: number, include?: Array<'defaultBranch' | 'scmProvider'>, fieldsScmGitReferences?: Array<'canonicalName' | 'isDeleted' | 'kind' | 'name' | 'repository'>, fieldsScmPullRequests?: Array<'destinationBranchName' | 'destinationRepositoryName' | 'destinationRepositoryOwner' | 'isClosed' | 'isCrossRepository' | 'number' | 'repository' | 'sourceBranchName' | 'sourceRepositoryName' | 'sourceRepositoryOwner' | 'title' | 'webUrl'>, _options?: Configuration): Observable<HttpInfo<ScmRepositoriesResponse>> {
        const requestContextPromise = this.requestFactory.scmRepositoriesGetCollection(filterId, fieldsScmRepositories, limit, include, fieldsScmGitReferences, fieldsScmPullRequests, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.scmRepositoriesGetCollectionWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param filterId filter by id(s)
     * @param fieldsScmRepositories the fields to include for returned resources of type scmRepositories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsScmGitReferences the fields to include for returned resources of type scmGitReferences
     * @param fieldsScmPullRequests the fields to include for returned resources of type scmPullRequests
     */
    public scmRepositoriesGetCollection(filterId?: Array<string>, fieldsScmRepositories?: Array<'defaultBranch' | 'gitReferences' | 'httpCloneUrl' | 'lastAccessedDate' | 'ownerName' | 'pullRequests' | 'repositoryName' | 'scmProvider' | 'sshCloneUrl'>, limit?: number, include?: Array<'defaultBranch' | 'scmProvider'>, fieldsScmGitReferences?: Array<'canonicalName' | 'isDeleted' | 'kind' | 'name' | 'repository'>, fieldsScmPullRequests?: Array<'destinationBranchName' | 'destinationRepositoryName' | 'destinationRepositoryOwner' | 'isClosed' | 'isCrossRepository' | 'number' | 'repository' | 'sourceBranchName' | 'sourceRepositoryName' | 'sourceRepositoryOwner' | 'title' | 'webUrl'>, _options?: Configuration): Observable<ScmRepositoriesResponse> {
        return this.scmRepositoriesGetCollectionWithHttpInfo(filterId, fieldsScmRepositories, limit, include, fieldsScmGitReferences, fieldsScmPullRequests, _options).pipe(map((apiResponse: HttpInfo<ScmRepositoriesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsScmRepositories the fields to include for returned resources of type scmRepositories
     * @param include comma-separated list of relationships to include
     * @param fieldsScmGitReferences the fields to include for returned resources of type scmGitReferences
     * @param fieldsScmPullRequests the fields to include for returned resources of type scmPullRequests
     */
    public scmRepositoriesGetInstanceWithHttpInfo(id: string, fieldsScmRepositories?: Array<'defaultBranch' | 'gitReferences' | 'httpCloneUrl' | 'lastAccessedDate' | 'ownerName' | 'pullRequests' | 'repositoryName' | 'scmProvider' | 'sshCloneUrl'>, include?: Array<'defaultBranch' | 'scmProvider'>, fieldsScmGitReferences?: Array<'canonicalName' | 'isDeleted' | 'kind' | 'name' | 'repository'>, fieldsScmPullRequests?: Array<'destinationBranchName' | 'destinationRepositoryName' | 'destinationRepositoryOwner' | 'isClosed' | 'isCrossRepository' | 'number' | 'repository' | 'sourceBranchName' | 'sourceRepositoryName' | 'sourceRepositoryOwner' | 'title' | 'webUrl'>, _options?: Configuration): Observable<HttpInfo<ScmRepositoryResponse>> {
        const requestContextPromise = this.requestFactory.scmRepositoriesGetInstance(id, fieldsScmRepositories, include, fieldsScmGitReferences, fieldsScmPullRequests, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.scmRepositoriesGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsScmRepositories the fields to include for returned resources of type scmRepositories
     * @param include comma-separated list of relationships to include
     * @param fieldsScmGitReferences the fields to include for returned resources of type scmGitReferences
     * @param fieldsScmPullRequests the fields to include for returned resources of type scmPullRequests
     */
    public scmRepositoriesGetInstance(id: string, fieldsScmRepositories?: Array<'defaultBranch' | 'gitReferences' | 'httpCloneUrl' | 'lastAccessedDate' | 'ownerName' | 'pullRequests' | 'repositoryName' | 'scmProvider' | 'sshCloneUrl'>, include?: Array<'defaultBranch' | 'scmProvider'>, fieldsScmGitReferences?: Array<'canonicalName' | 'isDeleted' | 'kind' | 'name' | 'repository'>, fieldsScmPullRequests?: Array<'destinationBranchName' | 'destinationRepositoryName' | 'destinationRepositoryOwner' | 'isClosed' | 'isCrossRepository' | 'number' | 'repository' | 'sourceBranchName' | 'sourceRepositoryName' | 'sourceRepositoryOwner' | 'title' | 'webUrl'>, _options?: Configuration): Observable<ScmRepositoryResponse> {
        return this.scmRepositoriesGetInstanceWithHttpInfo(id, fieldsScmRepositories, include, fieldsScmGitReferences, fieldsScmPullRequests, _options).pipe(map((apiResponse: HttpInfo<ScmRepositoryResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsScmGitReferences the fields to include for returned resources of type scmGitReferences
     * @param fieldsScmRepositories the fields to include for returned resources of type scmRepositories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public scmRepositoriesGitReferencesGetToManyRelatedWithHttpInfo(id: string, fieldsScmGitReferences?: Array<'canonicalName' | 'isDeleted' | 'kind' | 'name' | 'repository'>, fieldsScmRepositories?: Array<'defaultBranch' | 'gitReferences' | 'httpCloneUrl' | 'lastAccessedDate' | 'ownerName' | 'pullRequests' | 'repositoryName' | 'scmProvider' | 'sshCloneUrl'>, limit?: number, include?: Array<'repository'>, _options?: Configuration): Observable<HttpInfo<ScmGitReferencesResponse>> {
        const requestContextPromise = this.requestFactory.scmRepositoriesGitReferencesGetToManyRelated(id, fieldsScmGitReferences, fieldsScmRepositories, limit, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.scmRepositoriesGitReferencesGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsScmGitReferences the fields to include for returned resources of type scmGitReferences
     * @param fieldsScmRepositories the fields to include for returned resources of type scmRepositories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public scmRepositoriesGitReferencesGetToManyRelated(id: string, fieldsScmGitReferences?: Array<'canonicalName' | 'isDeleted' | 'kind' | 'name' | 'repository'>, fieldsScmRepositories?: Array<'defaultBranch' | 'gitReferences' | 'httpCloneUrl' | 'lastAccessedDate' | 'ownerName' | 'pullRequests' | 'repositoryName' | 'scmProvider' | 'sshCloneUrl'>, limit?: number, include?: Array<'repository'>, _options?: Configuration): Observable<ScmGitReferencesResponse> {
        return this.scmRepositoriesGitReferencesGetToManyRelatedWithHttpInfo(id, fieldsScmGitReferences, fieldsScmRepositories, limit, include, _options).pipe(map((apiResponse: HttpInfo<ScmGitReferencesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsScmPullRequests the fields to include for returned resources of type scmPullRequests
     * @param fieldsScmRepositories the fields to include for returned resources of type scmRepositories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public scmRepositoriesPullRequestsGetToManyRelatedWithHttpInfo(id: string, fieldsScmPullRequests?: Array<'destinationBranchName' | 'destinationRepositoryName' | 'destinationRepositoryOwner' | 'isClosed' | 'isCrossRepository' | 'number' | 'repository' | 'sourceBranchName' | 'sourceRepositoryName' | 'sourceRepositoryOwner' | 'title' | 'webUrl'>, fieldsScmRepositories?: Array<'defaultBranch' | 'gitReferences' | 'httpCloneUrl' | 'lastAccessedDate' | 'ownerName' | 'pullRequests' | 'repositoryName' | 'scmProvider' | 'sshCloneUrl'>, limit?: number, include?: Array<'repository'>, _options?: Configuration): Observable<HttpInfo<ScmPullRequestsResponse>> {
        const requestContextPromise = this.requestFactory.scmRepositoriesPullRequestsGetToManyRelated(id, fieldsScmPullRequests, fieldsScmRepositories, limit, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.scmRepositoriesPullRequestsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsScmPullRequests the fields to include for returned resources of type scmPullRequests
     * @param fieldsScmRepositories the fields to include for returned resources of type scmRepositories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public scmRepositoriesPullRequestsGetToManyRelated(id: string, fieldsScmPullRequests?: Array<'destinationBranchName' | 'destinationRepositoryName' | 'destinationRepositoryOwner' | 'isClosed' | 'isCrossRepository' | 'number' | 'repository' | 'sourceBranchName' | 'sourceRepositoryName' | 'sourceRepositoryOwner' | 'title' | 'webUrl'>, fieldsScmRepositories?: Array<'defaultBranch' | 'gitReferences' | 'httpCloneUrl' | 'lastAccessedDate' | 'ownerName' | 'pullRequests' | 'repositoryName' | 'scmProvider' | 'sshCloneUrl'>, limit?: number, include?: Array<'repository'>, _options?: Configuration): Observable<ScmPullRequestsResponse> {
        return this.scmRepositoriesPullRequestsGetToManyRelatedWithHttpInfo(id, fieldsScmPullRequests, fieldsScmRepositories, limit, include, _options).pipe(map((apiResponse: HttpInfo<ScmPullRequestsResponse>) => apiResponse.data));
    }

}

import { SubscriptionAppStoreReviewScreenshotsApiRequestFactory, SubscriptionAppStoreReviewScreenshotsApiResponseProcessor} from "../apis/SubscriptionAppStoreReviewScreenshotsApi.ts";
export class ObservableSubscriptionAppStoreReviewScreenshotsApi {
    private requestFactory: SubscriptionAppStoreReviewScreenshotsApiRequestFactory;
    private responseProcessor: SubscriptionAppStoreReviewScreenshotsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: SubscriptionAppStoreReviewScreenshotsApiRequestFactory,
        responseProcessor?: SubscriptionAppStoreReviewScreenshotsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new SubscriptionAppStoreReviewScreenshotsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new SubscriptionAppStoreReviewScreenshotsApiResponseProcessor();
    }

    /**
     * @param subscriptionAppStoreReviewScreenshotCreateRequest SubscriptionAppStoreReviewScreenshot representation
     */
    public subscriptionAppStoreReviewScreenshotsCreateInstanceWithHttpInfo(subscriptionAppStoreReviewScreenshotCreateRequest: SubscriptionAppStoreReviewScreenshotCreateRequest, _options?: Configuration): Observable<HttpInfo<SubscriptionAppStoreReviewScreenshotResponse>> {
        const requestContextPromise = this.requestFactory.subscriptionAppStoreReviewScreenshotsCreateInstance(subscriptionAppStoreReviewScreenshotCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.subscriptionAppStoreReviewScreenshotsCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param subscriptionAppStoreReviewScreenshotCreateRequest SubscriptionAppStoreReviewScreenshot representation
     */
    public subscriptionAppStoreReviewScreenshotsCreateInstance(subscriptionAppStoreReviewScreenshotCreateRequest: SubscriptionAppStoreReviewScreenshotCreateRequest, _options?: Configuration): Observable<SubscriptionAppStoreReviewScreenshotResponse> {
        return this.subscriptionAppStoreReviewScreenshotsCreateInstanceWithHttpInfo(subscriptionAppStoreReviewScreenshotCreateRequest, _options).pipe(map((apiResponse: HttpInfo<SubscriptionAppStoreReviewScreenshotResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public subscriptionAppStoreReviewScreenshotsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.subscriptionAppStoreReviewScreenshotsDeleteInstance(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.subscriptionAppStoreReviewScreenshotsDeleteInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public subscriptionAppStoreReviewScreenshotsDeleteInstance(id: string, _options?: Configuration): Observable<void> {
        return this.subscriptionAppStoreReviewScreenshotsDeleteInstanceWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsSubscriptionAppStoreReviewScreenshots the fields to include for returned resources of type subscriptionAppStoreReviewScreenshots
     * @param include comma-separated list of relationships to include
     */
    public subscriptionAppStoreReviewScreenshotsGetInstanceWithHttpInfo(id: string, fieldsSubscriptionAppStoreReviewScreenshots?: Array<'assetDeliveryState' | 'assetToken' | 'assetType' | 'fileName' | 'fileSize' | 'imageAsset' | 'sourceFileChecksum' | 'subscription' | 'uploadOperations' | 'uploaded'>, include?: Array<'subscription'>, _options?: Configuration): Observable<HttpInfo<SubscriptionAppStoreReviewScreenshotResponse>> {
        const requestContextPromise = this.requestFactory.subscriptionAppStoreReviewScreenshotsGetInstance(id, fieldsSubscriptionAppStoreReviewScreenshots, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.subscriptionAppStoreReviewScreenshotsGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsSubscriptionAppStoreReviewScreenshots the fields to include for returned resources of type subscriptionAppStoreReviewScreenshots
     * @param include comma-separated list of relationships to include
     */
    public subscriptionAppStoreReviewScreenshotsGetInstance(id: string, fieldsSubscriptionAppStoreReviewScreenshots?: Array<'assetDeliveryState' | 'assetToken' | 'assetType' | 'fileName' | 'fileSize' | 'imageAsset' | 'sourceFileChecksum' | 'subscription' | 'uploadOperations' | 'uploaded'>, include?: Array<'subscription'>, _options?: Configuration): Observable<SubscriptionAppStoreReviewScreenshotResponse> {
        return this.subscriptionAppStoreReviewScreenshotsGetInstanceWithHttpInfo(id, fieldsSubscriptionAppStoreReviewScreenshots, include, _options).pipe(map((apiResponse: HttpInfo<SubscriptionAppStoreReviewScreenshotResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param subscriptionAppStoreReviewScreenshotUpdateRequest SubscriptionAppStoreReviewScreenshot representation
     */
    public subscriptionAppStoreReviewScreenshotsUpdateInstanceWithHttpInfo(id: string, subscriptionAppStoreReviewScreenshotUpdateRequest: SubscriptionAppStoreReviewScreenshotUpdateRequest, _options?: Configuration): Observable<HttpInfo<SubscriptionAppStoreReviewScreenshotResponse>> {
        const requestContextPromise = this.requestFactory.subscriptionAppStoreReviewScreenshotsUpdateInstance(id, subscriptionAppStoreReviewScreenshotUpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.subscriptionAppStoreReviewScreenshotsUpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param subscriptionAppStoreReviewScreenshotUpdateRequest SubscriptionAppStoreReviewScreenshot representation
     */
    public subscriptionAppStoreReviewScreenshotsUpdateInstance(id: string, subscriptionAppStoreReviewScreenshotUpdateRequest: SubscriptionAppStoreReviewScreenshotUpdateRequest, _options?: Configuration): Observable<SubscriptionAppStoreReviewScreenshotResponse> {
        return this.subscriptionAppStoreReviewScreenshotsUpdateInstanceWithHttpInfo(id, subscriptionAppStoreReviewScreenshotUpdateRequest, _options).pipe(map((apiResponse: HttpInfo<SubscriptionAppStoreReviewScreenshotResponse>) => apiResponse.data));
    }

}

import { SubscriptionAvailabilitiesApiRequestFactory, SubscriptionAvailabilitiesApiResponseProcessor} from "../apis/SubscriptionAvailabilitiesApi.ts";
export class ObservableSubscriptionAvailabilitiesApi {
    private requestFactory: SubscriptionAvailabilitiesApiRequestFactory;
    private responseProcessor: SubscriptionAvailabilitiesApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: SubscriptionAvailabilitiesApiRequestFactory,
        responseProcessor?: SubscriptionAvailabilitiesApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new SubscriptionAvailabilitiesApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new SubscriptionAvailabilitiesApiResponseProcessor();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limit maximum resources per page
     */
    public subscriptionAvailabilitiesAvailableTerritoriesGetToManyRelatedWithHttpInfo(id: string, fieldsTerritories?: Array<'currency'>, limit?: number, _options?: Configuration): Observable<HttpInfo<TerritoriesResponse>> {
        const requestContextPromise = this.requestFactory.subscriptionAvailabilitiesAvailableTerritoriesGetToManyRelated(id, fieldsTerritories, limit, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.subscriptionAvailabilitiesAvailableTerritoriesGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limit maximum resources per page
     */
    public subscriptionAvailabilitiesAvailableTerritoriesGetToManyRelated(id: string, fieldsTerritories?: Array<'currency'>, limit?: number, _options?: Configuration): Observable<TerritoriesResponse> {
        return this.subscriptionAvailabilitiesAvailableTerritoriesGetToManyRelatedWithHttpInfo(id, fieldsTerritories, limit, _options).pipe(map((apiResponse: HttpInfo<TerritoriesResponse>) => apiResponse.data));
    }

    /**
     * @param subscriptionAvailabilityCreateRequest SubscriptionAvailability representation
     */
    public subscriptionAvailabilitiesCreateInstanceWithHttpInfo(subscriptionAvailabilityCreateRequest: SubscriptionAvailabilityCreateRequest, _options?: Configuration): Observable<HttpInfo<SubscriptionAvailabilityResponse>> {
        const requestContextPromise = this.requestFactory.subscriptionAvailabilitiesCreateInstance(subscriptionAvailabilityCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.subscriptionAvailabilitiesCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param subscriptionAvailabilityCreateRequest SubscriptionAvailability representation
     */
    public subscriptionAvailabilitiesCreateInstance(subscriptionAvailabilityCreateRequest: SubscriptionAvailabilityCreateRequest, _options?: Configuration): Observable<SubscriptionAvailabilityResponse> {
        return this.subscriptionAvailabilitiesCreateInstanceWithHttpInfo(subscriptionAvailabilityCreateRequest, _options).pipe(map((apiResponse: HttpInfo<SubscriptionAvailabilityResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsSubscriptionAvailabilities the fields to include for returned resources of type subscriptionAvailabilities
     * @param include comma-separated list of relationships to include
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limitAvailableTerritories maximum number of related availableTerritories returned (when they are included)
     */
    public subscriptionAvailabilitiesGetInstanceWithHttpInfo(id: string, fieldsSubscriptionAvailabilities?: Array<'availableInNewTerritories' | 'availableTerritories' | 'subscription'>, include?: Array<'availableTerritories' | 'subscription'>, fieldsTerritories?: Array<'currency'>, limitAvailableTerritories?: number, _options?: Configuration): Observable<HttpInfo<SubscriptionAvailabilityResponse>> {
        const requestContextPromise = this.requestFactory.subscriptionAvailabilitiesGetInstance(id, fieldsSubscriptionAvailabilities, include, fieldsTerritories, limitAvailableTerritories, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.subscriptionAvailabilitiesGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsSubscriptionAvailabilities the fields to include for returned resources of type subscriptionAvailabilities
     * @param include comma-separated list of relationships to include
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limitAvailableTerritories maximum number of related availableTerritories returned (when they are included)
     */
    public subscriptionAvailabilitiesGetInstance(id: string, fieldsSubscriptionAvailabilities?: Array<'availableInNewTerritories' | 'availableTerritories' | 'subscription'>, include?: Array<'availableTerritories' | 'subscription'>, fieldsTerritories?: Array<'currency'>, limitAvailableTerritories?: number, _options?: Configuration): Observable<SubscriptionAvailabilityResponse> {
        return this.subscriptionAvailabilitiesGetInstanceWithHttpInfo(id, fieldsSubscriptionAvailabilities, include, fieldsTerritories, limitAvailableTerritories, _options).pipe(map((apiResponse: HttpInfo<SubscriptionAvailabilityResponse>) => apiResponse.data));
    }

}

import { SubscriptionGracePeriodsApiRequestFactory, SubscriptionGracePeriodsApiResponseProcessor} from "../apis/SubscriptionGracePeriodsApi.ts";
export class ObservableSubscriptionGracePeriodsApi {
    private requestFactory: SubscriptionGracePeriodsApiRequestFactory;
    private responseProcessor: SubscriptionGracePeriodsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: SubscriptionGracePeriodsApiRequestFactory,
        responseProcessor?: SubscriptionGracePeriodsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new SubscriptionGracePeriodsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new SubscriptionGracePeriodsApiResponseProcessor();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsSubscriptionGracePeriods the fields to include for returned resources of type subscriptionGracePeriods
     */
    public subscriptionGracePeriodsGetInstanceWithHttpInfo(id: string, fieldsSubscriptionGracePeriods?: Array<'duration' | 'optIn' | 'renewalType' | 'sandboxOptIn'>, _options?: Configuration): Observable<HttpInfo<SubscriptionGracePeriodResponse>> {
        const requestContextPromise = this.requestFactory.subscriptionGracePeriodsGetInstance(id, fieldsSubscriptionGracePeriods, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.subscriptionGracePeriodsGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsSubscriptionGracePeriods the fields to include for returned resources of type subscriptionGracePeriods
     */
    public subscriptionGracePeriodsGetInstance(id: string, fieldsSubscriptionGracePeriods?: Array<'duration' | 'optIn' | 'renewalType' | 'sandboxOptIn'>, _options?: Configuration): Observable<SubscriptionGracePeriodResponse> {
        return this.subscriptionGracePeriodsGetInstanceWithHttpInfo(id, fieldsSubscriptionGracePeriods, _options).pipe(map((apiResponse: HttpInfo<SubscriptionGracePeriodResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param subscriptionGracePeriodUpdateRequest SubscriptionGracePeriod representation
     */
    public subscriptionGracePeriodsUpdateInstanceWithHttpInfo(id: string, subscriptionGracePeriodUpdateRequest: SubscriptionGracePeriodUpdateRequest, _options?: Configuration): Observable<HttpInfo<SubscriptionGracePeriodResponse>> {
        const requestContextPromise = this.requestFactory.subscriptionGracePeriodsUpdateInstance(id, subscriptionGracePeriodUpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.subscriptionGracePeriodsUpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param subscriptionGracePeriodUpdateRequest SubscriptionGracePeriod representation
     */
    public subscriptionGracePeriodsUpdateInstance(id: string, subscriptionGracePeriodUpdateRequest: SubscriptionGracePeriodUpdateRequest, _options?: Configuration): Observable<SubscriptionGracePeriodResponse> {
        return this.subscriptionGracePeriodsUpdateInstanceWithHttpInfo(id, subscriptionGracePeriodUpdateRequest, _options).pipe(map((apiResponse: HttpInfo<SubscriptionGracePeriodResponse>) => apiResponse.data));
    }

}

import { SubscriptionGroupLocalizationsApiRequestFactory, SubscriptionGroupLocalizationsApiResponseProcessor} from "../apis/SubscriptionGroupLocalizationsApi.ts";
export class ObservableSubscriptionGroupLocalizationsApi {
    private requestFactory: SubscriptionGroupLocalizationsApiRequestFactory;
    private responseProcessor: SubscriptionGroupLocalizationsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: SubscriptionGroupLocalizationsApiRequestFactory,
        responseProcessor?: SubscriptionGroupLocalizationsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new SubscriptionGroupLocalizationsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new SubscriptionGroupLocalizationsApiResponseProcessor();
    }

    /**
     * @param subscriptionGroupLocalizationCreateRequest SubscriptionGroupLocalization representation
     */
    public subscriptionGroupLocalizationsCreateInstanceWithHttpInfo(subscriptionGroupLocalizationCreateRequest: SubscriptionGroupLocalizationCreateRequest, _options?: Configuration): Observable<HttpInfo<SubscriptionGroupLocalizationResponse>> {
        const requestContextPromise = this.requestFactory.subscriptionGroupLocalizationsCreateInstance(subscriptionGroupLocalizationCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.subscriptionGroupLocalizationsCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param subscriptionGroupLocalizationCreateRequest SubscriptionGroupLocalization representation
     */
    public subscriptionGroupLocalizationsCreateInstance(subscriptionGroupLocalizationCreateRequest: SubscriptionGroupLocalizationCreateRequest, _options?: Configuration): Observable<SubscriptionGroupLocalizationResponse> {
        return this.subscriptionGroupLocalizationsCreateInstanceWithHttpInfo(subscriptionGroupLocalizationCreateRequest, _options).pipe(map((apiResponse: HttpInfo<SubscriptionGroupLocalizationResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public subscriptionGroupLocalizationsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.subscriptionGroupLocalizationsDeleteInstance(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.subscriptionGroupLocalizationsDeleteInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public subscriptionGroupLocalizationsDeleteInstance(id: string, _options?: Configuration): Observable<void> {
        return this.subscriptionGroupLocalizationsDeleteInstanceWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsSubscriptionGroupLocalizations the fields to include for returned resources of type subscriptionGroupLocalizations
     * @param include comma-separated list of relationships to include
     */
    public subscriptionGroupLocalizationsGetInstanceWithHttpInfo(id: string, fieldsSubscriptionGroupLocalizations?: Array<'customAppName' | 'locale' | 'name' | 'state' | 'subscriptionGroup'>, include?: Array<'subscriptionGroup'>, _options?: Configuration): Observable<HttpInfo<SubscriptionGroupLocalizationResponse>> {
        const requestContextPromise = this.requestFactory.subscriptionGroupLocalizationsGetInstance(id, fieldsSubscriptionGroupLocalizations, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.subscriptionGroupLocalizationsGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsSubscriptionGroupLocalizations the fields to include for returned resources of type subscriptionGroupLocalizations
     * @param include comma-separated list of relationships to include
     */
    public subscriptionGroupLocalizationsGetInstance(id: string, fieldsSubscriptionGroupLocalizations?: Array<'customAppName' | 'locale' | 'name' | 'state' | 'subscriptionGroup'>, include?: Array<'subscriptionGroup'>, _options?: Configuration): Observable<SubscriptionGroupLocalizationResponse> {
        return this.subscriptionGroupLocalizationsGetInstanceWithHttpInfo(id, fieldsSubscriptionGroupLocalizations, include, _options).pipe(map((apiResponse: HttpInfo<SubscriptionGroupLocalizationResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param subscriptionGroupLocalizationUpdateRequest SubscriptionGroupLocalization representation
     */
    public subscriptionGroupLocalizationsUpdateInstanceWithHttpInfo(id: string, subscriptionGroupLocalizationUpdateRequest: SubscriptionGroupLocalizationUpdateRequest, _options?: Configuration): Observable<HttpInfo<SubscriptionGroupLocalizationResponse>> {
        const requestContextPromise = this.requestFactory.subscriptionGroupLocalizationsUpdateInstance(id, subscriptionGroupLocalizationUpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.subscriptionGroupLocalizationsUpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param subscriptionGroupLocalizationUpdateRequest SubscriptionGroupLocalization representation
     */
    public subscriptionGroupLocalizationsUpdateInstance(id: string, subscriptionGroupLocalizationUpdateRequest: SubscriptionGroupLocalizationUpdateRequest, _options?: Configuration): Observable<SubscriptionGroupLocalizationResponse> {
        return this.subscriptionGroupLocalizationsUpdateInstanceWithHttpInfo(id, subscriptionGroupLocalizationUpdateRequest, _options).pipe(map((apiResponse: HttpInfo<SubscriptionGroupLocalizationResponse>) => apiResponse.data));
    }

}

import { SubscriptionGroupSubmissionsApiRequestFactory, SubscriptionGroupSubmissionsApiResponseProcessor} from "../apis/SubscriptionGroupSubmissionsApi.ts";
export class ObservableSubscriptionGroupSubmissionsApi {
    private requestFactory: SubscriptionGroupSubmissionsApiRequestFactory;
    private responseProcessor: SubscriptionGroupSubmissionsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: SubscriptionGroupSubmissionsApiRequestFactory,
        responseProcessor?: SubscriptionGroupSubmissionsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new SubscriptionGroupSubmissionsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new SubscriptionGroupSubmissionsApiResponseProcessor();
    }

    /**
     * @param subscriptionGroupSubmissionCreateRequest SubscriptionGroupSubmission representation
     */
    public subscriptionGroupSubmissionsCreateInstanceWithHttpInfo(subscriptionGroupSubmissionCreateRequest: SubscriptionGroupSubmissionCreateRequest, _options?: Configuration): Observable<HttpInfo<SubscriptionGroupSubmissionResponse>> {
        const requestContextPromise = this.requestFactory.subscriptionGroupSubmissionsCreateInstance(subscriptionGroupSubmissionCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.subscriptionGroupSubmissionsCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param subscriptionGroupSubmissionCreateRequest SubscriptionGroupSubmission representation
     */
    public subscriptionGroupSubmissionsCreateInstance(subscriptionGroupSubmissionCreateRequest: SubscriptionGroupSubmissionCreateRequest, _options?: Configuration): Observable<SubscriptionGroupSubmissionResponse> {
        return this.subscriptionGroupSubmissionsCreateInstanceWithHttpInfo(subscriptionGroupSubmissionCreateRequest, _options).pipe(map((apiResponse: HttpInfo<SubscriptionGroupSubmissionResponse>) => apiResponse.data));
    }

}

import { SubscriptionGroupsApiRequestFactory, SubscriptionGroupsApiResponseProcessor} from "../apis/SubscriptionGroupsApi.ts";
export class ObservableSubscriptionGroupsApi {
    private requestFactory: SubscriptionGroupsApiRequestFactory;
    private responseProcessor: SubscriptionGroupsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: SubscriptionGroupsApiRequestFactory,
        responseProcessor?: SubscriptionGroupsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new SubscriptionGroupsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new SubscriptionGroupsApiResponseProcessor();
    }

    /**
     * @param subscriptionGroupCreateRequest SubscriptionGroup representation
     */
    public subscriptionGroupsCreateInstanceWithHttpInfo(subscriptionGroupCreateRequest: SubscriptionGroupCreateRequest, _options?: Configuration): Observable<HttpInfo<SubscriptionGroupResponse>> {
        const requestContextPromise = this.requestFactory.subscriptionGroupsCreateInstance(subscriptionGroupCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.subscriptionGroupsCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param subscriptionGroupCreateRequest SubscriptionGroup representation
     */
    public subscriptionGroupsCreateInstance(subscriptionGroupCreateRequest: SubscriptionGroupCreateRequest, _options?: Configuration): Observable<SubscriptionGroupResponse> {
        return this.subscriptionGroupsCreateInstanceWithHttpInfo(subscriptionGroupCreateRequest, _options).pipe(map((apiResponse: HttpInfo<SubscriptionGroupResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public subscriptionGroupsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.subscriptionGroupsDeleteInstance(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.subscriptionGroupsDeleteInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public subscriptionGroupsDeleteInstance(id: string, _options?: Configuration): Observable<void> {
        return this.subscriptionGroupsDeleteInstanceWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsSubscriptionGroups the fields to include for returned resources of type subscriptionGroups
     * @param include comma-separated list of relationships to include
     * @param fieldsSubscriptions the fields to include for returned resources of type subscriptions
     * @param fieldsSubscriptionGroupLocalizations the fields to include for returned resources of type subscriptionGroupLocalizations
     * @param limitSubscriptionGroupLocalizations maximum number of related subscriptionGroupLocalizations returned (when they are included)
     * @param limitSubscriptions maximum number of related subscriptions returned (when they are included)
     */
    public subscriptionGroupsGetInstanceWithHttpInfo(id: string, fieldsSubscriptionGroups?: Array<'app' | 'referenceName' | 'subscriptionGroupLocalizations' | 'subscriptions'>, include?: Array<'subscriptionGroupLocalizations' | 'subscriptions'>, fieldsSubscriptions?: Array<'appStoreReviewScreenshot' | 'familySharable' | 'group' | 'groupLevel' | 'introductoryOffers' | 'name' | 'offerCodes' | 'pricePoints' | 'prices' | 'productId' | 'promotedPurchase' | 'promotionalOffers' | 'reviewNote' | 'state' | 'subscriptionAvailability' | 'subscriptionLocalizations' | 'subscriptionPeriod'>, fieldsSubscriptionGroupLocalizations?: Array<'customAppName' | 'locale' | 'name' | 'state' | 'subscriptionGroup'>, limitSubscriptionGroupLocalizations?: number, limitSubscriptions?: number, _options?: Configuration): Observable<HttpInfo<SubscriptionGroupResponse>> {
        const requestContextPromise = this.requestFactory.subscriptionGroupsGetInstance(id, fieldsSubscriptionGroups, include, fieldsSubscriptions, fieldsSubscriptionGroupLocalizations, limitSubscriptionGroupLocalizations, limitSubscriptions, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.subscriptionGroupsGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsSubscriptionGroups the fields to include for returned resources of type subscriptionGroups
     * @param include comma-separated list of relationships to include
     * @param fieldsSubscriptions the fields to include for returned resources of type subscriptions
     * @param fieldsSubscriptionGroupLocalizations the fields to include for returned resources of type subscriptionGroupLocalizations
     * @param limitSubscriptionGroupLocalizations maximum number of related subscriptionGroupLocalizations returned (when they are included)
     * @param limitSubscriptions maximum number of related subscriptions returned (when they are included)
     */
    public subscriptionGroupsGetInstance(id: string, fieldsSubscriptionGroups?: Array<'app' | 'referenceName' | 'subscriptionGroupLocalizations' | 'subscriptions'>, include?: Array<'subscriptionGroupLocalizations' | 'subscriptions'>, fieldsSubscriptions?: Array<'appStoreReviewScreenshot' | 'familySharable' | 'group' | 'groupLevel' | 'introductoryOffers' | 'name' | 'offerCodes' | 'pricePoints' | 'prices' | 'productId' | 'promotedPurchase' | 'promotionalOffers' | 'reviewNote' | 'state' | 'subscriptionAvailability' | 'subscriptionLocalizations' | 'subscriptionPeriod'>, fieldsSubscriptionGroupLocalizations?: Array<'customAppName' | 'locale' | 'name' | 'state' | 'subscriptionGroup'>, limitSubscriptionGroupLocalizations?: number, limitSubscriptions?: number, _options?: Configuration): Observable<SubscriptionGroupResponse> {
        return this.subscriptionGroupsGetInstanceWithHttpInfo(id, fieldsSubscriptionGroups, include, fieldsSubscriptions, fieldsSubscriptionGroupLocalizations, limitSubscriptionGroupLocalizations, limitSubscriptions, _options).pipe(map((apiResponse: HttpInfo<SubscriptionGroupResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsSubscriptionGroups the fields to include for returned resources of type subscriptionGroups
     * @param fieldsSubscriptionGroupLocalizations the fields to include for returned resources of type subscriptionGroupLocalizations
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public subscriptionGroupsSubscriptionGroupLocalizationsGetToManyRelatedWithHttpInfo(id: string, fieldsSubscriptionGroups?: Array<'app' | 'referenceName' | 'subscriptionGroupLocalizations' | 'subscriptions'>, fieldsSubscriptionGroupLocalizations?: Array<'customAppName' | 'locale' | 'name' | 'state' | 'subscriptionGroup'>, limit?: number, include?: Array<'subscriptionGroup'>, _options?: Configuration): Observable<HttpInfo<SubscriptionGroupLocalizationsResponse>> {
        const requestContextPromise = this.requestFactory.subscriptionGroupsSubscriptionGroupLocalizationsGetToManyRelated(id, fieldsSubscriptionGroups, fieldsSubscriptionGroupLocalizations, limit, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.subscriptionGroupsSubscriptionGroupLocalizationsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsSubscriptionGroups the fields to include for returned resources of type subscriptionGroups
     * @param fieldsSubscriptionGroupLocalizations the fields to include for returned resources of type subscriptionGroupLocalizations
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public subscriptionGroupsSubscriptionGroupLocalizationsGetToManyRelated(id: string, fieldsSubscriptionGroups?: Array<'app' | 'referenceName' | 'subscriptionGroupLocalizations' | 'subscriptions'>, fieldsSubscriptionGroupLocalizations?: Array<'customAppName' | 'locale' | 'name' | 'state' | 'subscriptionGroup'>, limit?: number, include?: Array<'subscriptionGroup'>, _options?: Configuration): Observable<SubscriptionGroupLocalizationsResponse> {
        return this.subscriptionGroupsSubscriptionGroupLocalizationsGetToManyRelatedWithHttpInfo(id, fieldsSubscriptionGroups, fieldsSubscriptionGroupLocalizations, limit, include, _options).pipe(map((apiResponse: HttpInfo<SubscriptionGroupLocalizationsResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param filterName filter by attribute \&#39;name\&#39;
     * @param filterProductId filter by attribute \&#39;productId\&#39;
     * @param filterState filter by attribute \&#39;state\&#39;
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsPromotedPurchases the fields to include for returned resources of type promotedPurchases
     * @param fieldsSubscriptionPromotionalOffers the fields to include for returned resources of type subscriptionPromotionalOffers
     * @param fieldsSubscriptionOfferCodes the fields to include for returned resources of type subscriptionOfferCodes
     * @param fieldsSubscriptionAppStoreReviewScreenshots the fields to include for returned resources of type subscriptionAppStoreReviewScreenshots
     * @param fieldsSubscriptions the fields to include for returned resources of type subscriptions
     * @param fieldsSubscriptionAvailabilities the fields to include for returned resources of type subscriptionAvailabilities
     * @param fieldsSubscriptionGroups the fields to include for returned resources of type subscriptionGroups
     * @param fieldsSubscriptionIntroductoryOffers the fields to include for returned resources of type subscriptionIntroductoryOffers
     * @param fieldsSubscriptionPrices the fields to include for returned resources of type subscriptionPrices
     * @param fieldsSubscriptionLocalizations the fields to include for returned resources of type subscriptionLocalizations
     * @param limit maximum resources per page
     * @param limitSubscriptionLocalizations maximum number of related subscriptionLocalizations returned (when they are included)
     * @param limitIntroductoryOffers maximum number of related introductoryOffers returned (when they are included)
     * @param limitPromotionalOffers maximum number of related promotionalOffers returned (when they are included)
     * @param limitOfferCodes maximum number of related offerCodes returned (when they are included)
     * @param limitPrices maximum number of related prices returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public subscriptionGroupsSubscriptionsGetToManyRelatedWithHttpInfo(id: string, filterName?: Array<string>, filterProductId?: Array<string>, filterState?: Array<'MISSING_METADATA' | 'READY_TO_SUBMIT' | 'WAITING_FOR_REVIEW' | 'IN_REVIEW' | 'DEVELOPER_ACTION_NEEDED' | 'PENDING_BINARY_APPROVAL' | 'APPROVED' | 'DEVELOPER_REMOVED_FROM_SALE' | 'REMOVED_FROM_SALE' | 'REJECTED'>, sort?: Array<'name' | '-name'>, fieldsPromotedPurchases?: Array<'app' | 'enabled' | 'inAppPurchaseV2' | 'promotionImages' | 'state' | 'subscription' | 'visibleForAllUsers'>, fieldsSubscriptionPromotionalOffers?: Array<'duration' | 'name' | 'numberOfPeriods' | 'offerCode' | 'offerMode' | 'prices' | 'subscription'>, fieldsSubscriptionOfferCodes?: Array<'active' | 'customCodes' | 'customerEligibilities' | 'duration' | 'name' | 'numberOfPeriods' | 'offerEligibility' | 'offerMode' | 'oneTimeUseCodes' | 'prices' | 'subscription' | 'totalNumberOfCodes'>, fieldsSubscriptionAppStoreReviewScreenshots?: Array<'assetDeliveryState' | 'assetToken' | 'assetType' | 'fileName' | 'fileSize' | 'imageAsset' | 'sourceFileChecksum' | 'subscription' | 'uploadOperations' | 'uploaded'>, fieldsSubscriptions?: Array<'appStoreReviewScreenshot' | 'familySharable' | 'group' | 'groupLevel' | 'introductoryOffers' | 'name' | 'offerCodes' | 'pricePoints' | 'prices' | 'productId' | 'promotedPurchase' | 'promotionalOffers' | 'reviewNote' | 'state' | 'subscriptionAvailability' | 'subscriptionLocalizations' | 'subscriptionPeriod'>, fieldsSubscriptionAvailabilities?: Array<'availableInNewTerritories' | 'availableTerritories' | 'subscription'>, fieldsSubscriptionGroups?: Array<'app' | 'referenceName' | 'subscriptionGroupLocalizations' | 'subscriptions'>, fieldsSubscriptionIntroductoryOffers?: Array<'duration' | 'endDate' | 'numberOfPeriods' | 'offerMode' | 'startDate' | 'subscription' | 'subscriptionPricePoint' | 'territory'>, fieldsSubscriptionPrices?: Array<'preserveCurrentPrice' | 'preserved' | 'startDate' | 'subscription' | 'subscriptionPricePoint' | 'territory'>, fieldsSubscriptionLocalizations?: Array<'description' | 'locale' | 'name' | 'state' | 'subscription'>, limit?: number, limitSubscriptionLocalizations?: number, limitIntroductoryOffers?: number, limitPromotionalOffers?: number, limitOfferCodes?: number, limitPrices?: number, include?: Array<'appStoreReviewScreenshot' | 'group' | 'introductoryOffers' | 'offerCodes' | 'prices' | 'promotedPurchase' | 'promotionalOffers' | 'subscriptionAvailability' | 'subscriptionLocalizations'>, _options?: Configuration): Observable<HttpInfo<SubscriptionsResponse>> {
        const requestContextPromise = this.requestFactory.subscriptionGroupsSubscriptionsGetToManyRelated(id, filterName, filterProductId, filterState, sort, fieldsPromotedPurchases, fieldsSubscriptionPromotionalOffers, fieldsSubscriptionOfferCodes, fieldsSubscriptionAppStoreReviewScreenshots, fieldsSubscriptions, fieldsSubscriptionAvailabilities, fieldsSubscriptionGroups, fieldsSubscriptionIntroductoryOffers, fieldsSubscriptionPrices, fieldsSubscriptionLocalizations, limit, limitSubscriptionLocalizations, limitIntroductoryOffers, limitPromotionalOffers, limitOfferCodes, limitPrices, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.subscriptionGroupsSubscriptionsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param filterName filter by attribute \&#39;name\&#39;
     * @param filterProductId filter by attribute \&#39;productId\&#39;
     * @param filterState filter by attribute \&#39;state\&#39;
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsPromotedPurchases the fields to include for returned resources of type promotedPurchases
     * @param fieldsSubscriptionPromotionalOffers the fields to include for returned resources of type subscriptionPromotionalOffers
     * @param fieldsSubscriptionOfferCodes the fields to include for returned resources of type subscriptionOfferCodes
     * @param fieldsSubscriptionAppStoreReviewScreenshots the fields to include for returned resources of type subscriptionAppStoreReviewScreenshots
     * @param fieldsSubscriptions the fields to include for returned resources of type subscriptions
     * @param fieldsSubscriptionAvailabilities the fields to include for returned resources of type subscriptionAvailabilities
     * @param fieldsSubscriptionGroups the fields to include for returned resources of type subscriptionGroups
     * @param fieldsSubscriptionIntroductoryOffers the fields to include for returned resources of type subscriptionIntroductoryOffers
     * @param fieldsSubscriptionPrices the fields to include for returned resources of type subscriptionPrices
     * @param fieldsSubscriptionLocalizations the fields to include for returned resources of type subscriptionLocalizations
     * @param limit maximum resources per page
     * @param limitSubscriptionLocalizations maximum number of related subscriptionLocalizations returned (when they are included)
     * @param limitIntroductoryOffers maximum number of related introductoryOffers returned (when they are included)
     * @param limitPromotionalOffers maximum number of related promotionalOffers returned (when they are included)
     * @param limitOfferCodes maximum number of related offerCodes returned (when they are included)
     * @param limitPrices maximum number of related prices returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public subscriptionGroupsSubscriptionsGetToManyRelated(id: string, filterName?: Array<string>, filterProductId?: Array<string>, filterState?: Array<'MISSING_METADATA' | 'READY_TO_SUBMIT' | 'WAITING_FOR_REVIEW' | 'IN_REVIEW' | 'DEVELOPER_ACTION_NEEDED' | 'PENDING_BINARY_APPROVAL' | 'APPROVED' | 'DEVELOPER_REMOVED_FROM_SALE' | 'REMOVED_FROM_SALE' | 'REJECTED'>, sort?: Array<'name' | '-name'>, fieldsPromotedPurchases?: Array<'app' | 'enabled' | 'inAppPurchaseV2' | 'promotionImages' | 'state' | 'subscription' | 'visibleForAllUsers'>, fieldsSubscriptionPromotionalOffers?: Array<'duration' | 'name' | 'numberOfPeriods' | 'offerCode' | 'offerMode' | 'prices' | 'subscription'>, fieldsSubscriptionOfferCodes?: Array<'active' | 'customCodes' | 'customerEligibilities' | 'duration' | 'name' | 'numberOfPeriods' | 'offerEligibility' | 'offerMode' | 'oneTimeUseCodes' | 'prices' | 'subscription' | 'totalNumberOfCodes'>, fieldsSubscriptionAppStoreReviewScreenshots?: Array<'assetDeliveryState' | 'assetToken' | 'assetType' | 'fileName' | 'fileSize' | 'imageAsset' | 'sourceFileChecksum' | 'subscription' | 'uploadOperations' | 'uploaded'>, fieldsSubscriptions?: Array<'appStoreReviewScreenshot' | 'familySharable' | 'group' | 'groupLevel' | 'introductoryOffers' | 'name' | 'offerCodes' | 'pricePoints' | 'prices' | 'productId' | 'promotedPurchase' | 'promotionalOffers' | 'reviewNote' | 'state' | 'subscriptionAvailability' | 'subscriptionLocalizations' | 'subscriptionPeriod'>, fieldsSubscriptionAvailabilities?: Array<'availableInNewTerritories' | 'availableTerritories' | 'subscription'>, fieldsSubscriptionGroups?: Array<'app' | 'referenceName' | 'subscriptionGroupLocalizations' | 'subscriptions'>, fieldsSubscriptionIntroductoryOffers?: Array<'duration' | 'endDate' | 'numberOfPeriods' | 'offerMode' | 'startDate' | 'subscription' | 'subscriptionPricePoint' | 'territory'>, fieldsSubscriptionPrices?: Array<'preserveCurrentPrice' | 'preserved' | 'startDate' | 'subscription' | 'subscriptionPricePoint' | 'territory'>, fieldsSubscriptionLocalizations?: Array<'description' | 'locale' | 'name' | 'state' | 'subscription'>, limit?: number, limitSubscriptionLocalizations?: number, limitIntroductoryOffers?: number, limitPromotionalOffers?: number, limitOfferCodes?: number, limitPrices?: number, include?: Array<'appStoreReviewScreenshot' | 'group' | 'introductoryOffers' | 'offerCodes' | 'prices' | 'promotedPurchase' | 'promotionalOffers' | 'subscriptionAvailability' | 'subscriptionLocalizations'>, _options?: Configuration): Observable<SubscriptionsResponse> {
        return this.subscriptionGroupsSubscriptionsGetToManyRelatedWithHttpInfo(id, filterName, filterProductId, filterState, sort, fieldsPromotedPurchases, fieldsSubscriptionPromotionalOffers, fieldsSubscriptionOfferCodes, fieldsSubscriptionAppStoreReviewScreenshots, fieldsSubscriptions, fieldsSubscriptionAvailabilities, fieldsSubscriptionGroups, fieldsSubscriptionIntroductoryOffers, fieldsSubscriptionPrices, fieldsSubscriptionLocalizations, limit, limitSubscriptionLocalizations, limitIntroductoryOffers, limitPromotionalOffers, limitOfferCodes, limitPrices, include, _options).pipe(map((apiResponse: HttpInfo<SubscriptionsResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param subscriptionGroupUpdateRequest SubscriptionGroup representation
     */
    public subscriptionGroupsUpdateInstanceWithHttpInfo(id: string, subscriptionGroupUpdateRequest: SubscriptionGroupUpdateRequest, _options?: Configuration): Observable<HttpInfo<SubscriptionGroupResponse>> {
        const requestContextPromise = this.requestFactory.subscriptionGroupsUpdateInstance(id, subscriptionGroupUpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.subscriptionGroupsUpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param subscriptionGroupUpdateRequest SubscriptionGroup representation
     */
    public subscriptionGroupsUpdateInstance(id: string, subscriptionGroupUpdateRequest: SubscriptionGroupUpdateRequest, _options?: Configuration): Observable<SubscriptionGroupResponse> {
        return this.subscriptionGroupsUpdateInstanceWithHttpInfo(id, subscriptionGroupUpdateRequest, _options).pipe(map((apiResponse: HttpInfo<SubscriptionGroupResponse>) => apiResponse.data));
    }

}

import { SubscriptionIntroductoryOffersApiRequestFactory, SubscriptionIntroductoryOffersApiResponseProcessor} from "../apis/SubscriptionIntroductoryOffersApi.ts";
export class ObservableSubscriptionIntroductoryOffersApi {
    private requestFactory: SubscriptionIntroductoryOffersApiRequestFactory;
    private responseProcessor: SubscriptionIntroductoryOffersApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: SubscriptionIntroductoryOffersApiRequestFactory,
        responseProcessor?: SubscriptionIntroductoryOffersApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new SubscriptionIntroductoryOffersApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new SubscriptionIntroductoryOffersApiResponseProcessor();
    }

    /**
     * @param subscriptionIntroductoryOfferCreateRequest SubscriptionIntroductoryOffer representation
     */
    public subscriptionIntroductoryOffersCreateInstanceWithHttpInfo(subscriptionIntroductoryOfferCreateRequest: SubscriptionIntroductoryOfferCreateRequest, _options?: Configuration): Observable<HttpInfo<SubscriptionIntroductoryOfferResponse>> {
        const requestContextPromise = this.requestFactory.subscriptionIntroductoryOffersCreateInstance(subscriptionIntroductoryOfferCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.subscriptionIntroductoryOffersCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param subscriptionIntroductoryOfferCreateRequest SubscriptionIntroductoryOffer representation
     */
    public subscriptionIntroductoryOffersCreateInstance(subscriptionIntroductoryOfferCreateRequest: SubscriptionIntroductoryOfferCreateRequest, _options?: Configuration): Observable<SubscriptionIntroductoryOfferResponse> {
        return this.subscriptionIntroductoryOffersCreateInstanceWithHttpInfo(subscriptionIntroductoryOfferCreateRequest, _options).pipe(map((apiResponse: HttpInfo<SubscriptionIntroductoryOfferResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public subscriptionIntroductoryOffersDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.subscriptionIntroductoryOffersDeleteInstance(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.subscriptionIntroductoryOffersDeleteInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public subscriptionIntroductoryOffersDeleteInstance(id: string, _options?: Configuration): Observable<void> {
        return this.subscriptionIntroductoryOffersDeleteInstanceWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param subscriptionIntroductoryOfferUpdateRequest SubscriptionIntroductoryOffer representation
     */
    public subscriptionIntroductoryOffersUpdateInstanceWithHttpInfo(id: string, subscriptionIntroductoryOfferUpdateRequest: SubscriptionIntroductoryOfferUpdateRequest, _options?: Configuration): Observable<HttpInfo<SubscriptionIntroductoryOfferResponse>> {
        const requestContextPromise = this.requestFactory.subscriptionIntroductoryOffersUpdateInstance(id, subscriptionIntroductoryOfferUpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.subscriptionIntroductoryOffersUpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param subscriptionIntroductoryOfferUpdateRequest SubscriptionIntroductoryOffer representation
     */
    public subscriptionIntroductoryOffersUpdateInstance(id: string, subscriptionIntroductoryOfferUpdateRequest: SubscriptionIntroductoryOfferUpdateRequest, _options?: Configuration): Observable<SubscriptionIntroductoryOfferResponse> {
        return this.subscriptionIntroductoryOffersUpdateInstanceWithHttpInfo(id, subscriptionIntroductoryOfferUpdateRequest, _options).pipe(map((apiResponse: HttpInfo<SubscriptionIntroductoryOfferResponse>) => apiResponse.data));
    }

}

import { SubscriptionLocalizationsApiRequestFactory, SubscriptionLocalizationsApiResponseProcessor} from "../apis/SubscriptionLocalizationsApi.ts";
export class ObservableSubscriptionLocalizationsApi {
    private requestFactory: SubscriptionLocalizationsApiRequestFactory;
    private responseProcessor: SubscriptionLocalizationsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: SubscriptionLocalizationsApiRequestFactory,
        responseProcessor?: SubscriptionLocalizationsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new SubscriptionLocalizationsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new SubscriptionLocalizationsApiResponseProcessor();
    }

    /**
     * @param subscriptionLocalizationCreateRequest SubscriptionLocalization representation
     */
    public subscriptionLocalizationsCreateInstanceWithHttpInfo(subscriptionLocalizationCreateRequest: SubscriptionLocalizationCreateRequest, _options?: Configuration): Observable<HttpInfo<SubscriptionLocalizationResponse>> {
        const requestContextPromise = this.requestFactory.subscriptionLocalizationsCreateInstance(subscriptionLocalizationCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.subscriptionLocalizationsCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param subscriptionLocalizationCreateRequest SubscriptionLocalization representation
     */
    public subscriptionLocalizationsCreateInstance(subscriptionLocalizationCreateRequest: SubscriptionLocalizationCreateRequest, _options?: Configuration): Observable<SubscriptionLocalizationResponse> {
        return this.subscriptionLocalizationsCreateInstanceWithHttpInfo(subscriptionLocalizationCreateRequest, _options).pipe(map((apiResponse: HttpInfo<SubscriptionLocalizationResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public subscriptionLocalizationsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.subscriptionLocalizationsDeleteInstance(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.subscriptionLocalizationsDeleteInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public subscriptionLocalizationsDeleteInstance(id: string, _options?: Configuration): Observable<void> {
        return this.subscriptionLocalizationsDeleteInstanceWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsSubscriptionLocalizations the fields to include for returned resources of type subscriptionLocalizations
     * @param include comma-separated list of relationships to include
     */
    public subscriptionLocalizationsGetInstanceWithHttpInfo(id: string, fieldsSubscriptionLocalizations?: Array<'description' | 'locale' | 'name' | 'state' | 'subscription'>, include?: Array<'subscription'>, _options?: Configuration): Observable<HttpInfo<SubscriptionLocalizationResponse>> {
        const requestContextPromise = this.requestFactory.subscriptionLocalizationsGetInstance(id, fieldsSubscriptionLocalizations, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.subscriptionLocalizationsGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsSubscriptionLocalizations the fields to include for returned resources of type subscriptionLocalizations
     * @param include comma-separated list of relationships to include
     */
    public subscriptionLocalizationsGetInstance(id: string, fieldsSubscriptionLocalizations?: Array<'description' | 'locale' | 'name' | 'state' | 'subscription'>, include?: Array<'subscription'>, _options?: Configuration): Observable<SubscriptionLocalizationResponse> {
        return this.subscriptionLocalizationsGetInstanceWithHttpInfo(id, fieldsSubscriptionLocalizations, include, _options).pipe(map((apiResponse: HttpInfo<SubscriptionLocalizationResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param subscriptionLocalizationUpdateRequest SubscriptionLocalization representation
     */
    public subscriptionLocalizationsUpdateInstanceWithHttpInfo(id: string, subscriptionLocalizationUpdateRequest: SubscriptionLocalizationUpdateRequest, _options?: Configuration): Observable<HttpInfo<SubscriptionLocalizationResponse>> {
        const requestContextPromise = this.requestFactory.subscriptionLocalizationsUpdateInstance(id, subscriptionLocalizationUpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.subscriptionLocalizationsUpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param subscriptionLocalizationUpdateRequest SubscriptionLocalization representation
     */
    public subscriptionLocalizationsUpdateInstance(id: string, subscriptionLocalizationUpdateRequest: SubscriptionLocalizationUpdateRequest, _options?: Configuration): Observable<SubscriptionLocalizationResponse> {
        return this.subscriptionLocalizationsUpdateInstanceWithHttpInfo(id, subscriptionLocalizationUpdateRequest, _options).pipe(map((apiResponse: HttpInfo<SubscriptionLocalizationResponse>) => apiResponse.data));
    }

}

import { SubscriptionOfferCodeCustomCodesApiRequestFactory, SubscriptionOfferCodeCustomCodesApiResponseProcessor} from "../apis/SubscriptionOfferCodeCustomCodesApi.ts";
export class ObservableSubscriptionOfferCodeCustomCodesApi {
    private requestFactory: SubscriptionOfferCodeCustomCodesApiRequestFactory;
    private responseProcessor: SubscriptionOfferCodeCustomCodesApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: SubscriptionOfferCodeCustomCodesApiRequestFactory,
        responseProcessor?: SubscriptionOfferCodeCustomCodesApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new SubscriptionOfferCodeCustomCodesApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new SubscriptionOfferCodeCustomCodesApiResponseProcessor();
    }

    /**
     * @param subscriptionOfferCodeCustomCodeCreateRequest SubscriptionOfferCodeCustomCode representation
     */
    public subscriptionOfferCodeCustomCodesCreateInstanceWithHttpInfo(subscriptionOfferCodeCustomCodeCreateRequest: SubscriptionOfferCodeCustomCodeCreateRequest, _options?: Configuration): Observable<HttpInfo<SubscriptionOfferCodeCustomCodeResponse>> {
        const requestContextPromise = this.requestFactory.subscriptionOfferCodeCustomCodesCreateInstance(subscriptionOfferCodeCustomCodeCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.subscriptionOfferCodeCustomCodesCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param subscriptionOfferCodeCustomCodeCreateRequest SubscriptionOfferCodeCustomCode representation
     */
    public subscriptionOfferCodeCustomCodesCreateInstance(subscriptionOfferCodeCustomCodeCreateRequest: SubscriptionOfferCodeCustomCodeCreateRequest, _options?: Configuration): Observable<SubscriptionOfferCodeCustomCodeResponse> {
        return this.subscriptionOfferCodeCustomCodesCreateInstanceWithHttpInfo(subscriptionOfferCodeCustomCodeCreateRequest, _options).pipe(map((apiResponse: HttpInfo<SubscriptionOfferCodeCustomCodeResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsSubscriptionOfferCodeCustomCodes the fields to include for returned resources of type subscriptionOfferCodeCustomCodes
     * @param include comma-separated list of relationships to include
     */
    public subscriptionOfferCodeCustomCodesGetInstanceWithHttpInfo(id: string, fieldsSubscriptionOfferCodeCustomCodes?: Array<'active' | 'createdDate' | 'customCode' | 'expirationDate' | 'numberOfCodes' | 'offerCode'>, include?: Array<'offerCode'>, _options?: Configuration): Observable<HttpInfo<SubscriptionOfferCodeCustomCodeResponse>> {
        const requestContextPromise = this.requestFactory.subscriptionOfferCodeCustomCodesGetInstance(id, fieldsSubscriptionOfferCodeCustomCodes, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.subscriptionOfferCodeCustomCodesGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsSubscriptionOfferCodeCustomCodes the fields to include for returned resources of type subscriptionOfferCodeCustomCodes
     * @param include comma-separated list of relationships to include
     */
    public subscriptionOfferCodeCustomCodesGetInstance(id: string, fieldsSubscriptionOfferCodeCustomCodes?: Array<'active' | 'createdDate' | 'customCode' | 'expirationDate' | 'numberOfCodes' | 'offerCode'>, include?: Array<'offerCode'>, _options?: Configuration): Observable<SubscriptionOfferCodeCustomCodeResponse> {
        return this.subscriptionOfferCodeCustomCodesGetInstanceWithHttpInfo(id, fieldsSubscriptionOfferCodeCustomCodes, include, _options).pipe(map((apiResponse: HttpInfo<SubscriptionOfferCodeCustomCodeResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param subscriptionOfferCodeCustomCodeUpdateRequest SubscriptionOfferCodeCustomCode representation
     */
    public subscriptionOfferCodeCustomCodesUpdateInstanceWithHttpInfo(id: string, subscriptionOfferCodeCustomCodeUpdateRequest: SubscriptionOfferCodeCustomCodeUpdateRequest, _options?: Configuration): Observable<HttpInfo<SubscriptionOfferCodeCustomCodeResponse>> {
        const requestContextPromise = this.requestFactory.subscriptionOfferCodeCustomCodesUpdateInstance(id, subscriptionOfferCodeCustomCodeUpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.subscriptionOfferCodeCustomCodesUpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param subscriptionOfferCodeCustomCodeUpdateRequest SubscriptionOfferCodeCustomCode representation
     */
    public subscriptionOfferCodeCustomCodesUpdateInstance(id: string, subscriptionOfferCodeCustomCodeUpdateRequest: SubscriptionOfferCodeCustomCodeUpdateRequest, _options?: Configuration): Observable<SubscriptionOfferCodeCustomCodeResponse> {
        return this.subscriptionOfferCodeCustomCodesUpdateInstanceWithHttpInfo(id, subscriptionOfferCodeCustomCodeUpdateRequest, _options).pipe(map((apiResponse: HttpInfo<SubscriptionOfferCodeCustomCodeResponse>) => apiResponse.data));
    }

}

import { SubscriptionOfferCodeOneTimeUseCodesApiRequestFactory, SubscriptionOfferCodeOneTimeUseCodesApiResponseProcessor} from "../apis/SubscriptionOfferCodeOneTimeUseCodesApi.ts";
export class ObservableSubscriptionOfferCodeOneTimeUseCodesApi {
    private requestFactory: SubscriptionOfferCodeOneTimeUseCodesApiRequestFactory;
    private responseProcessor: SubscriptionOfferCodeOneTimeUseCodesApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: SubscriptionOfferCodeOneTimeUseCodesApiRequestFactory,
        responseProcessor?: SubscriptionOfferCodeOneTimeUseCodesApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new SubscriptionOfferCodeOneTimeUseCodesApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new SubscriptionOfferCodeOneTimeUseCodesApiResponseProcessor();
    }

    /**
     * @param subscriptionOfferCodeOneTimeUseCodeCreateRequest SubscriptionOfferCodeOneTimeUseCode representation
     */
    public subscriptionOfferCodeOneTimeUseCodesCreateInstanceWithHttpInfo(subscriptionOfferCodeOneTimeUseCodeCreateRequest: SubscriptionOfferCodeOneTimeUseCodeCreateRequest, _options?: Configuration): Observable<HttpInfo<SubscriptionOfferCodeOneTimeUseCodeResponse>> {
        const requestContextPromise = this.requestFactory.subscriptionOfferCodeOneTimeUseCodesCreateInstance(subscriptionOfferCodeOneTimeUseCodeCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.subscriptionOfferCodeOneTimeUseCodesCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param subscriptionOfferCodeOneTimeUseCodeCreateRequest SubscriptionOfferCodeOneTimeUseCode representation
     */
    public subscriptionOfferCodeOneTimeUseCodesCreateInstance(subscriptionOfferCodeOneTimeUseCodeCreateRequest: SubscriptionOfferCodeOneTimeUseCodeCreateRequest, _options?: Configuration): Observable<SubscriptionOfferCodeOneTimeUseCodeResponse> {
        return this.subscriptionOfferCodeOneTimeUseCodesCreateInstanceWithHttpInfo(subscriptionOfferCodeOneTimeUseCodeCreateRequest, _options).pipe(map((apiResponse: HttpInfo<SubscriptionOfferCodeOneTimeUseCodeResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsSubscriptionOfferCodeOneTimeUseCodes the fields to include for returned resources of type subscriptionOfferCodeOneTimeUseCodes
     * @param include comma-separated list of relationships to include
     */
    public subscriptionOfferCodeOneTimeUseCodesGetInstanceWithHttpInfo(id: string, fieldsSubscriptionOfferCodeOneTimeUseCodes?: Array<'active' | 'createdDate' | 'expirationDate' | 'numberOfCodes' | 'offerCode' | 'values'>, include?: Array<'offerCode'>, _options?: Configuration): Observable<HttpInfo<SubscriptionOfferCodeOneTimeUseCodeResponse>> {
        const requestContextPromise = this.requestFactory.subscriptionOfferCodeOneTimeUseCodesGetInstance(id, fieldsSubscriptionOfferCodeOneTimeUseCodes, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.subscriptionOfferCodeOneTimeUseCodesGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsSubscriptionOfferCodeOneTimeUseCodes the fields to include for returned resources of type subscriptionOfferCodeOneTimeUseCodes
     * @param include comma-separated list of relationships to include
     */
    public subscriptionOfferCodeOneTimeUseCodesGetInstance(id: string, fieldsSubscriptionOfferCodeOneTimeUseCodes?: Array<'active' | 'createdDate' | 'expirationDate' | 'numberOfCodes' | 'offerCode' | 'values'>, include?: Array<'offerCode'>, _options?: Configuration): Observable<SubscriptionOfferCodeOneTimeUseCodeResponse> {
        return this.subscriptionOfferCodeOneTimeUseCodesGetInstanceWithHttpInfo(id, fieldsSubscriptionOfferCodeOneTimeUseCodes, include, _options).pipe(map((apiResponse: HttpInfo<SubscriptionOfferCodeOneTimeUseCodeResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param subscriptionOfferCodeOneTimeUseCodeUpdateRequest SubscriptionOfferCodeOneTimeUseCode representation
     */
    public subscriptionOfferCodeOneTimeUseCodesUpdateInstanceWithHttpInfo(id: string, subscriptionOfferCodeOneTimeUseCodeUpdateRequest: SubscriptionOfferCodeOneTimeUseCodeUpdateRequest, _options?: Configuration): Observable<HttpInfo<SubscriptionOfferCodeOneTimeUseCodeResponse>> {
        const requestContextPromise = this.requestFactory.subscriptionOfferCodeOneTimeUseCodesUpdateInstance(id, subscriptionOfferCodeOneTimeUseCodeUpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.subscriptionOfferCodeOneTimeUseCodesUpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param subscriptionOfferCodeOneTimeUseCodeUpdateRequest SubscriptionOfferCodeOneTimeUseCode representation
     */
    public subscriptionOfferCodeOneTimeUseCodesUpdateInstance(id: string, subscriptionOfferCodeOneTimeUseCodeUpdateRequest: SubscriptionOfferCodeOneTimeUseCodeUpdateRequest, _options?: Configuration): Observable<SubscriptionOfferCodeOneTimeUseCodeResponse> {
        return this.subscriptionOfferCodeOneTimeUseCodesUpdateInstanceWithHttpInfo(id, subscriptionOfferCodeOneTimeUseCodeUpdateRequest, _options).pipe(map((apiResponse: HttpInfo<SubscriptionOfferCodeOneTimeUseCodeResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public subscriptionOfferCodeOneTimeUseCodesValuesGetToOneRelatedWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<string>> {
        const requestContextPromise = this.requestFactory.subscriptionOfferCodeOneTimeUseCodesValuesGetToOneRelated(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.subscriptionOfferCodeOneTimeUseCodesValuesGetToOneRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public subscriptionOfferCodeOneTimeUseCodesValuesGetToOneRelated(id: string, _options?: Configuration): Observable<string> {
        return this.subscriptionOfferCodeOneTimeUseCodesValuesGetToOneRelatedWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<string>) => apiResponse.data));
    }

}

import { SubscriptionOfferCodesApiRequestFactory, SubscriptionOfferCodesApiResponseProcessor} from "../apis/SubscriptionOfferCodesApi.ts";
export class ObservableSubscriptionOfferCodesApi {
    private requestFactory: SubscriptionOfferCodesApiRequestFactory;
    private responseProcessor: SubscriptionOfferCodesApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: SubscriptionOfferCodesApiRequestFactory,
        responseProcessor?: SubscriptionOfferCodesApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new SubscriptionOfferCodesApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new SubscriptionOfferCodesApiResponseProcessor();
    }

    /**
     * @param subscriptionOfferCodeCreateRequest SubscriptionOfferCode representation
     */
    public subscriptionOfferCodesCreateInstanceWithHttpInfo(subscriptionOfferCodeCreateRequest: SubscriptionOfferCodeCreateRequest, _options?: Configuration): Observable<HttpInfo<SubscriptionOfferCodeResponse>> {
        const requestContextPromise = this.requestFactory.subscriptionOfferCodesCreateInstance(subscriptionOfferCodeCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.subscriptionOfferCodesCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param subscriptionOfferCodeCreateRequest SubscriptionOfferCode representation
     */
    public subscriptionOfferCodesCreateInstance(subscriptionOfferCodeCreateRequest: SubscriptionOfferCodeCreateRequest, _options?: Configuration): Observable<SubscriptionOfferCodeResponse> {
        return this.subscriptionOfferCodesCreateInstanceWithHttpInfo(subscriptionOfferCodeCreateRequest, _options).pipe(map((apiResponse: HttpInfo<SubscriptionOfferCodeResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsSubscriptionOfferCodeCustomCodes the fields to include for returned resources of type subscriptionOfferCodeCustomCodes
     * @param fieldsSubscriptionOfferCodes the fields to include for returned resources of type subscriptionOfferCodes
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public subscriptionOfferCodesCustomCodesGetToManyRelatedWithHttpInfo(id: string, fieldsSubscriptionOfferCodeCustomCodes?: Array<'active' | 'createdDate' | 'customCode' | 'expirationDate' | 'numberOfCodes' | 'offerCode'>, fieldsSubscriptionOfferCodes?: Array<'active' | 'customCodes' | 'customerEligibilities' | 'duration' | 'name' | 'numberOfPeriods' | 'offerEligibility' | 'offerMode' | 'oneTimeUseCodes' | 'prices' | 'subscription' | 'totalNumberOfCodes'>, limit?: number, include?: Array<'offerCode'>, _options?: Configuration): Observable<HttpInfo<SubscriptionOfferCodeCustomCodesResponse>> {
        const requestContextPromise = this.requestFactory.subscriptionOfferCodesCustomCodesGetToManyRelated(id, fieldsSubscriptionOfferCodeCustomCodes, fieldsSubscriptionOfferCodes, limit, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.subscriptionOfferCodesCustomCodesGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsSubscriptionOfferCodeCustomCodes the fields to include for returned resources of type subscriptionOfferCodeCustomCodes
     * @param fieldsSubscriptionOfferCodes the fields to include for returned resources of type subscriptionOfferCodes
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public subscriptionOfferCodesCustomCodesGetToManyRelated(id: string, fieldsSubscriptionOfferCodeCustomCodes?: Array<'active' | 'createdDate' | 'customCode' | 'expirationDate' | 'numberOfCodes' | 'offerCode'>, fieldsSubscriptionOfferCodes?: Array<'active' | 'customCodes' | 'customerEligibilities' | 'duration' | 'name' | 'numberOfPeriods' | 'offerEligibility' | 'offerMode' | 'oneTimeUseCodes' | 'prices' | 'subscription' | 'totalNumberOfCodes'>, limit?: number, include?: Array<'offerCode'>, _options?: Configuration): Observable<SubscriptionOfferCodeCustomCodesResponse> {
        return this.subscriptionOfferCodesCustomCodesGetToManyRelatedWithHttpInfo(id, fieldsSubscriptionOfferCodeCustomCodes, fieldsSubscriptionOfferCodes, limit, include, _options).pipe(map((apiResponse: HttpInfo<SubscriptionOfferCodeCustomCodesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsSubscriptionOfferCodes the fields to include for returned resources of type subscriptionOfferCodes
     * @param include comma-separated list of relationships to include
     * @param fieldsSubscriptionOfferCodeCustomCodes the fields to include for returned resources of type subscriptionOfferCodeCustomCodes
     * @param fieldsSubscriptionOfferCodeOneTimeUseCodes the fields to include for returned resources of type subscriptionOfferCodeOneTimeUseCodes
     * @param fieldsSubscriptionOfferCodePrices the fields to include for returned resources of type subscriptionOfferCodePrices
     * @param limitCustomCodes maximum number of related customCodes returned (when they are included)
     * @param limitOneTimeUseCodes maximum number of related oneTimeUseCodes returned (when they are included)
     * @param limitPrices maximum number of related prices returned (when they are included)
     */
    public subscriptionOfferCodesGetInstanceWithHttpInfo(id: string, fieldsSubscriptionOfferCodes?: Array<'active' | 'customCodes' | 'customerEligibilities' | 'duration' | 'name' | 'numberOfPeriods' | 'offerEligibility' | 'offerMode' | 'oneTimeUseCodes' | 'prices' | 'subscription' | 'totalNumberOfCodes'>, include?: Array<'customCodes' | 'oneTimeUseCodes' | 'prices' | 'subscription'>, fieldsSubscriptionOfferCodeCustomCodes?: Array<'active' | 'createdDate' | 'customCode' | 'expirationDate' | 'numberOfCodes' | 'offerCode'>, fieldsSubscriptionOfferCodeOneTimeUseCodes?: Array<'active' | 'createdDate' | 'expirationDate' | 'numberOfCodes' | 'offerCode' | 'values'>, fieldsSubscriptionOfferCodePrices?: Array<'subscriptionPricePoint' | 'territory'>, limitCustomCodes?: number, limitOneTimeUseCodes?: number, limitPrices?: number, _options?: Configuration): Observable<HttpInfo<SubscriptionOfferCodeResponse>> {
        const requestContextPromise = this.requestFactory.subscriptionOfferCodesGetInstance(id, fieldsSubscriptionOfferCodes, include, fieldsSubscriptionOfferCodeCustomCodes, fieldsSubscriptionOfferCodeOneTimeUseCodes, fieldsSubscriptionOfferCodePrices, limitCustomCodes, limitOneTimeUseCodes, limitPrices, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.subscriptionOfferCodesGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsSubscriptionOfferCodes the fields to include for returned resources of type subscriptionOfferCodes
     * @param include comma-separated list of relationships to include
     * @param fieldsSubscriptionOfferCodeCustomCodes the fields to include for returned resources of type subscriptionOfferCodeCustomCodes
     * @param fieldsSubscriptionOfferCodeOneTimeUseCodes the fields to include for returned resources of type subscriptionOfferCodeOneTimeUseCodes
     * @param fieldsSubscriptionOfferCodePrices the fields to include for returned resources of type subscriptionOfferCodePrices
     * @param limitCustomCodes maximum number of related customCodes returned (when they are included)
     * @param limitOneTimeUseCodes maximum number of related oneTimeUseCodes returned (when they are included)
     * @param limitPrices maximum number of related prices returned (when they are included)
     */
    public subscriptionOfferCodesGetInstance(id: string, fieldsSubscriptionOfferCodes?: Array<'active' | 'customCodes' | 'customerEligibilities' | 'duration' | 'name' | 'numberOfPeriods' | 'offerEligibility' | 'offerMode' | 'oneTimeUseCodes' | 'prices' | 'subscription' | 'totalNumberOfCodes'>, include?: Array<'customCodes' | 'oneTimeUseCodes' | 'prices' | 'subscription'>, fieldsSubscriptionOfferCodeCustomCodes?: Array<'active' | 'createdDate' | 'customCode' | 'expirationDate' | 'numberOfCodes' | 'offerCode'>, fieldsSubscriptionOfferCodeOneTimeUseCodes?: Array<'active' | 'createdDate' | 'expirationDate' | 'numberOfCodes' | 'offerCode' | 'values'>, fieldsSubscriptionOfferCodePrices?: Array<'subscriptionPricePoint' | 'territory'>, limitCustomCodes?: number, limitOneTimeUseCodes?: number, limitPrices?: number, _options?: Configuration): Observable<SubscriptionOfferCodeResponse> {
        return this.subscriptionOfferCodesGetInstanceWithHttpInfo(id, fieldsSubscriptionOfferCodes, include, fieldsSubscriptionOfferCodeCustomCodes, fieldsSubscriptionOfferCodeOneTimeUseCodes, fieldsSubscriptionOfferCodePrices, limitCustomCodes, limitOneTimeUseCodes, limitPrices, _options).pipe(map((apiResponse: HttpInfo<SubscriptionOfferCodeResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsSubscriptionOfferCodes the fields to include for returned resources of type subscriptionOfferCodes
     * @param fieldsSubscriptionOfferCodeOneTimeUseCodes the fields to include for returned resources of type subscriptionOfferCodeOneTimeUseCodes
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public subscriptionOfferCodesOneTimeUseCodesGetToManyRelatedWithHttpInfo(id: string, fieldsSubscriptionOfferCodes?: Array<'active' | 'customCodes' | 'customerEligibilities' | 'duration' | 'name' | 'numberOfPeriods' | 'offerEligibility' | 'offerMode' | 'oneTimeUseCodes' | 'prices' | 'subscription' | 'totalNumberOfCodes'>, fieldsSubscriptionOfferCodeOneTimeUseCodes?: Array<'active' | 'createdDate' | 'expirationDate' | 'numberOfCodes' | 'offerCode' | 'values'>, limit?: number, include?: Array<'offerCode'>, _options?: Configuration): Observable<HttpInfo<SubscriptionOfferCodeOneTimeUseCodesResponse>> {
        const requestContextPromise = this.requestFactory.subscriptionOfferCodesOneTimeUseCodesGetToManyRelated(id, fieldsSubscriptionOfferCodes, fieldsSubscriptionOfferCodeOneTimeUseCodes, limit, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.subscriptionOfferCodesOneTimeUseCodesGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsSubscriptionOfferCodes the fields to include for returned resources of type subscriptionOfferCodes
     * @param fieldsSubscriptionOfferCodeOneTimeUseCodes the fields to include for returned resources of type subscriptionOfferCodeOneTimeUseCodes
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public subscriptionOfferCodesOneTimeUseCodesGetToManyRelated(id: string, fieldsSubscriptionOfferCodes?: Array<'active' | 'customCodes' | 'customerEligibilities' | 'duration' | 'name' | 'numberOfPeriods' | 'offerEligibility' | 'offerMode' | 'oneTimeUseCodes' | 'prices' | 'subscription' | 'totalNumberOfCodes'>, fieldsSubscriptionOfferCodeOneTimeUseCodes?: Array<'active' | 'createdDate' | 'expirationDate' | 'numberOfCodes' | 'offerCode' | 'values'>, limit?: number, include?: Array<'offerCode'>, _options?: Configuration): Observable<SubscriptionOfferCodeOneTimeUseCodesResponse> {
        return this.subscriptionOfferCodesOneTimeUseCodesGetToManyRelatedWithHttpInfo(id, fieldsSubscriptionOfferCodes, fieldsSubscriptionOfferCodeOneTimeUseCodes, limit, include, _options).pipe(map((apiResponse: HttpInfo<SubscriptionOfferCodeOneTimeUseCodesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param filterTerritory filter by id(s) of related \&#39;territory\&#39;
     * @param fieldsSubscriptionPricePoints the fields to include for returned resources of type subscriptionPricePoints
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param fieldsSubscriptionOfferCodePrices the fields to include for returned resources of type subscriptionOfferCodePrices
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public subscriptionOfferCodesPricesGetToManyRelatedWithHttpInfo(id: string, filterTerritory?: Array<string>, fieldsSubscriptionPricePoints?: Array<'customerPrice' | 'equalizations' | 'proceeds' | 'proceedsYear2' | 'subscription' | 'territory'>, fieldsTerritories?: Array<'currency'>, fieldsSubscriptionOfferCodePrices?: Array<'subscriptionPricePoint' | 'territory'>, limit?: number, include?: Array<'subscriptionPricePoint' | 'territory'>, _options?: Configuration): Observable<HttpInfo<SubscriptionOfferCodePricesResponse>> {
        const requestContextPromise = this.requestFactory.subscriptionOfferCodesPricesGetToManyRelated(id, filterTerritory, fieldsSubscriptionPricePoints, fieldsTerritories, fieldsSubscriptionOfferCodePrices, limit, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.subscriptionOfferCodesPricesGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param filterTerritory filter by id(s) of related \&#39;territory\&#39;
     * @param fieldsSubscriptionPricePoints the fields to include for returned resources of type subscriptionPricePoints
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param fieldsSubscriptionOfferCodePrices the fields to include for returned resources of type subscriptionOfferCodePrices
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public subscriptionOfferCodesPricesGetToManyRelated(id: string, filterTerritory?: Array<string>, fieldsSubscriptionPricePoints?: Array<'customerPrice' | 'equalizations' | 'proceeds' | 'proceedsYear2' | 'subscription' | 'territory'>, fieldsTerritories?: Array<'currency'>, fieldsSubscriptionOfferCodePrices?: Array<'subscriptionPricePoint' | 'territory'>, limit?: number, include?: Array<'subscriptionPricePoint' | 'territory'>, _options?: Configuration): Observable<SubscriptionOfferCodePricesResponse> {
        return this.subscriptionOfferCodesPricesGetToManyRelatedWithHttpInfo(id, filterTerritory, fieldsSubscriptionPricePoints, fieldsTerritories, fieldsSubscriptionOfferCodePrices, limit, include, _options).pipe(map((apiResponse: HttpInfo<SubscriptionOfferCodePricesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param subscriptionOfferCodeUpdateRequest SubscriptionOfferCode representation
     */
    public subscriptionOfferCodesUpdateInstanceWithHttpInfo(id: string, subscriptionOfferCodeUpdateRequest: SubscriptionOfferCodeUpdateRequest, _options?: Configuration): Observable<HttpInfo<SubscriptionOfferCodeResponse>> {
        const requestContextPromise = this.requestFactory.subscriptionOfferCodesUpdateInstance(id, subscriptionOfferCodeUpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.subscriptionOfferCodesUpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param subscriptionOfferCodeUpdateRequest SubscriptionOfferCode representation
     */
    public subscriptionOfferCodesUpdateInstance(id: string, subscriptionOfferCodeUpdateRequest: SubscriptionOfferCodeUpdateRequest, _options?: Configuration): Observable<SubscriptionOfferCodeResponse> {
        return this.subscriptionOfferCodesUpdateInstanceWithHttpInfo(id, subscriptionOfferCodeUpdateRequest, _options).pipe(map((apiResponse: HttpInfo<SubscriptionOfferCodeResponse>) => apiResponse.data));
    }

}

import { SubscriptionPricePointsApiRequestFactory, SubscriptionPricePointsApiResponseProcessor} from "../apis/SubscriptionPricePointsApi.ts";
export class ObservableSubscriptionPricePointsApi {
    private requestFactory: SubscriptionPricePointsApiRequestFactory;
    private responseProcessor: SubscriptionPricePointsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: SubscriptionPricePointsApiRequestFactory,
        responseProcessor?: SubscriptionPricePointsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new SubscriptionPricePointsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new SubscriptionPricePointsApiResponseProcessor();
    }

    /**
     * @param id the id of the requested resource
     * @param filterSubscription filter by id(s) of related \&#39;subscription\&#39;
     * @param filterTerritory filter by id(s) of related \&#39;territory\&#39;
     * @param fieldsSubscriptionPricePoints the fields to include for returned resources of type subscriptionPricePoints
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public subscriptionPricePointsEqualizationsGetToManyRelatedWithHttpInfo(id: string, filterSubscription?: Array<string>, filterTerritory?: Array<string>, fieldsSubscriptionPricePoints?: Array<'customerPrice' | 'equalizations' | 'proceeds' | 'proceedsYear2' | 'subscription' | 'territory'>, fieldsTerritories?: Array<'currency'>, limit?: number, include?: Array<'territory'>, _options?: Configuration): Observable<HttpInfo<SubscriptionPricePointsResponse>> {
        const requestContextPromise = this.requestFactory.subscriptionPricePointsEqualizationsGetToManyRelated(id, filterSubscription, filterTerritory, fieldsSubscriptionPricePoints, fieldsTerritories, limit, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.subscriptionPricePointsEqualizationsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param filterSubscription filter by id(s) of related \&#39;subscription\&#39;
     * @param filterTerritory filter by id(s) of related \&#39;territory\&#39;
     * @param fieldsSubscriptionPricePoints the fields to include for returned resources of type subscriptionPricePoints
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public subscriptionPricePointsEqualizationsGetToManyRelated(id: string, filterSubscription?: Array<string>, filterTerritory?: Array<string>, fieldsSubscriptionPricePoints?: Array<'customerPrice' | 'equalizations' | 'proceeds' | 'proceedsYear2' | 'subscription' | 'territory'>, fieldsTerritories?: Array<'currency'>, limit?: number, include?: Array<'territory'>, _options?: Configuration): Observable<SubscriptionPricePointsResponse> {
        return this.subscriptionPricePointsEqualizationsGetToManyRelatedWithHttpInfo(id, filterSubscription, filterTerritory, fieldsSubscriptionPricePoints, fieldsTerritories, limit, include, _options).pipe(map((apiResponse: HttpInfo<SubscriptionPricePointsResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsSubscriptionPricePoints the fields to include for returned resources of type subscriptionPricePoints
     * @param include comma-separated list of relationships to include
     */
    public subscriptionPricePointsGetInstanceWithHttpInfo(id: string, fieldsSubscriptionPricePoints?: Array<'customerPrice' | 'equalizations' | 'proceeds' | 'proceedsYear2' | 'subscription' | 'territory'>, include?: Array<'territory'>, _options?: Configuration): Observable<HttpInfo<SubscriptionPricePointResponse>> {
        const requestContextPromise = this.requestFactory.subscriptionPricePointsGetInstance(id, fieldsSubscriptionPricePoints, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.subscriptionPricePointsGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsSubscriptionPricePoints the fields to include for returned resources of type subscriptionPricePoints
     * @param include comma-separated list of relationships to include
     */
    public subscriptionPricePointsGetInstance(id: string, fieldsSubscriptionPricePoints?: Array<'customerPrice' | 'equalizations' | 'proceeds' | 'proceedsYear2' | 'subscription' | 'territory'>, include?: Array<'territory'>, _options?: Configuration): Observable<SubscriptionPricePointResponse> {
        return this.subscriptionPricePointsGetInstanceWithHttpInfo(id, fieldsSubscriptionPricePoints, include, _options).pipe(map((apiResponse: HttpInfo<SubscriptionPricePointResponse>) => apiResponse.data));
    }

}

import { SubscriptionPricesApiRequestFactory, SubscriptionPricesApiResponseProcessor} from "../apis/SubscriptionPricesApi.ts";
export class ObservableSubscriptionPricesApi {
    private requestFactory: SubscriptionPricesApiRequestFactory;
    private responseProcessor: SubscriptionPricesApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: SubscriptionPricesApiRequestFactory,
        responseProcessor?: SubscriptionPricesApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new SubscriptionPricesApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new SubscriptionPricesApiResponseProcessor();
    }

    /**
     * @param subscriptionPriceCreateRequest SubscriptionPrice representation
     */
    public subscriptionPricesCreateInstanceWithHttpInfo(subscriptionPriceCreateRequest: SubscriptionPriceCreateRequest, _options?: Configuration): Observable<HttpInfo<SubscriptionPriceResponse>> {
        const requestContextPromise = this.requestFactory.subscriptionPricesCreateInstance(subscriptionPriceCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.subscriptionPricesCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param subscriptionPriceCreateRequest SubscriptionPrice representation
     */
    public subscriptionPricesCreateInstance(subscriptionPriceCreateRequest: SubscriptionPriceCreateRequest, _options?: Configuration): Observable<SubscriptionPriceResponse> {
        return this.subscriptionPricesCreateInstanceWithHttpInfo(subscriptionPriceCreateRequest, _options).pipe(map((apiResponse: HttpInfo<SubscriptionPriceResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public subscriptionPricesDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.subscriptionPricesDeleteInstance(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.subscriptionPricesDeleteInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public subscriptionPricesDeleteInstance(id: string, _options?: Configuration): Observable<void> {
        return this.subscriptionPricesDeleteInstanceWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

}

import { SubscriptionPromotionalOffersApiRequestFactory, SubscriptionPromotionalOffersApiResponseProcessor} from "../apis/SubscriptionPromotionalOffersApi.ts";
export class ObservableSubscriptionPromotionalOffersApi {
    private requestFactory: SubscriptionPromotionalOffersApiRequestFactory;
    private responseProcessor: SubscriptionPromotionalOffersApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: SubscriptionPromotionalOffersApiRequestFactory,
        responseProcessor?: SubscriptionPromotionalOffersApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new SubscriptionPromotionalOffersApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new SubscriptionPromotionalOffersApiResponseProcessor();
    }

    /**
     * @param subscriptionPromotionalOfferCreateRequest SubscriptionPromotionalOffer representation
     */
    public subscriptionPromotionalOffersCreateInstanceWithHttpInfo(subscriptionPromotionalOfferCreateRequest: SubscriptionPromotionalOfferCreateRequest, _options?: Configuration): Observable<HttpInfo<SubscriptionPromotionalOfferResponse>> {
        const requestContextPromise = this.requestFactory.subscriptionPromotionalOffersCreateInstance(subscriptionPromotionalOfferCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.subscriptionPromotionalOffersCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param subscriptionPromotionalOfferCreateRequest SubscriptionPromotionalOffer representation
     */
    public subscriptionPromotionalOffersCreateInstance(subscriptionPromotionalOfferCreateRequest: SubscriptionPromotionalOfferCreateRequest, _options?: Configuration): Observable<SubscriptionPromotionalOfferResponse> {
        return this.subscriptionPromotionalOffersCreateInstanceWithHttpInfo(subscriptionPromotionalOfferCreateRequest, _options).pipe(map((apiResponse: HttpInfo<SubscriptionPromotionalOfferResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public subscriptionPromotionalOffersDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.subscriptionPromotionalOffersDeleteInstance(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.subscriptionPromotionalOffersDeleteInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public subscriptionPromotionalOffersDeleteInstance(id: string, _options?: Configuration): Observable<void> {
        return this.subscriptionPromotionalOffersDeleteInstanceWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsSubscriptionPromotionalOffers the fields to include for returned resources of type subscriptionPromotionalOffers
     * @param include comma-separated list of relationships to include
     * @param fieldsSubscriptionPromotionalOfferPrices the fields to include for returned resources of type subscriptionPromotionalOfferPrices
     * @param limitPrices maximum number of related prices returned (when they are included)
     */
    public subscriptionPromotionalOffersGetInstanceWithHttpInfo(id: string, fieldsSubscriptionPromotionalOffers?: Array<'duration' | 'name' | 'numberOfPeriods' | 'offerCode' | 'offerMode' | 'prices' | 'subscription'>, include?: Array<'prices' | 'subscription'>, fieldsSubscriptionPromotionalOfferPrices?: Array<'subscriptionPricePoint' | 'territory'>, limitPrices?: number, _options?: Configuration): Observable<HttpInfo<SubscriptionPromotionalOfferResponse>> {
        const requestContextPromise = this.requestFactory.subscriptionPromotionalOffersGetInstance(id, fieldsSubscriptionPromotionalOffers, include, fieldsSubscriptionPromotionalOfferPrices, limitPrices, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.subscriptionPromotionalOffersGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsSubscriptionPromotionalOffers the fields to include for returned resources of type subscriptionPromotionalOffers
     * @param include comma-separated list of relationships to include
     * @param fieldsSubscriptionPromotionalOfferPrices the fields to include for returned resources of type subscriptionPromotionalOfferPrices
     * @param limitPrices maximum number of related prices returned (when they are included)
     */
    public subscriptionPromotionalOffersGetInstance(id: string, fieldsSubscriptionPromotionalOffers?: Array<'duration' | 'name' | 'numberOfPeriods' | 'offerCode' | 'offerMode' | 'prices' | 'subscription'>, include?: Array<'prices' | 'subscription'>, fieldsSubscriptionPromotionalOfferPrices?: Array<'subscriptionPricePoint' | 'territory'>, limitPrices?: number, _options?: Configuration): Observable<SubscriptionPromotionalOfferResponse> {
        return this.subscriptionPromotionalOffersGetInstanceWithHttpInfo(id, fieldsSubscriptionPromotionalOffers, include, fieldsSubscriptionPromotionalOfferPrices, limitPrices, _options).pipe(map((apiResponse: HttpInfo<SubscriptionPromotionalOfferResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param filterTerritory filter by id(s) of related \&#39;territory\&#39;
     * @param fieldsSubscriptionPricePoints the fields to include for returned resources of type subscriptionPricePoints
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param fieldsSubscriptionPromotionalOfferPrices the fields to include for returned resources of type subscriptionPromotionalOfferPrices
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public subscriptionPromotionalOffersPricesGetToManyRelatedWithHttpInfo(id: string, filterTerritory?: Array<string>, fieldsSubscriptionPricePoints?: Array<'customerPrice' | 'equalizations' | 'proceeds' | 'proceedsYear2' | 'subscription' | 'territory'>, fieldsTerritories?: Array<'currency'>, fieldsSubscriptionPromotionalOfferPrices?: Array<'subscriptionPricePoint' | 'territory'>, limit?: number, include?: Array<'subscriptionPricePoint' | 'territory'>, _options?: Configuration): Observable<HttpInfo<SubscriptionPromotionalOfferPricesResponse>> {
        const requestContextPromise = this.requestFactory.subscriptionPromotionalOffersPricesGetToManyRelated(id, filterTerritory, fieldsSubscriptionPricePoints, fieldsTerritories, fieldsSubscriptionPromotionalOfferPrices, limit, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.subscriptionPromotionalOffersPricesGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param filterTerritory filter by id(s) of related \&#39;territory\&#39;
     * @param fieldsSubscriptionPricePoints the fields to include for returned resources of type subscriptionPricePoints
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param fieldsSubscriptionPromotionalOfferPrices the fields to include for returned resources of type subscriptionPromotionalOfferPrices
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public subscriptionPromotionalOffersPricesGetToManyRelated(id: string, filterTerritory?: Array<string>, fieldsSubscriptionPricePoints?: Array<'customerPrice' | 'equalizations' | 'proceeds' | 'proceedsYear2' | 'subscription' | 'territory'>, fieldsTerritories?: Array<'currency'>, fieldsSubscriptionPromotionalOfferPrices?: Array<'subscriptionPricePoint' | 'territory'>, limit?: number, include?: Array<'subscriptionPricePoint' | 'territory'>, _options?: Configuration): Observable<SubscriptionPromotionalOfferPricesResponse> {
        return this.subscriptionPromotionalOffersPricesGetToManyRelatedWithHttpInfo(id, filterTerritory, fieldsSubscriptionPricePoints, fieldsTerritories, fieldsSubscriptionPromotionalOfferPrices, limit, include, _options).pipe(map((apiResponse: HttpInfo<SubscriptionPromotionalOfferPricesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param subscriptionPromotionalOfferUpdateRequest SubscriptionPromotionalOffer representation
     */
    public subscriptionPromotionalOffersUpdateInstanceWithHttpInfo(id: string, subscriptionPromotionalOfferUpdateRequest: SubscriptionPromotionalOfferUpdateRequest, _options?: Configuration): Observable<HttpInfo<SubscriptionPromotionalOfferResponse>> {
        const requestContextPromise = this.requestFactory.subscriptionPromotionalOffersUpdateInstance(id, subscriptionPromotionalOfferUpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.subscriptionPromotionalOffersUpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param subscriptionPromotionalOfferUpdateRequest SubscriptionPromotionalOffer representation
     */
    public subscriptionPromotionalOffersUpdateInstance(id: string, subscriptionPromotionalOfferUpdateRequest: SubscriptionPromotionalOfferUpdateRequest, _options?: Configuration): Observable<SubscriptionPromotionalOfferResponse> {
        return this.subscriptionPromotionalOffersUpdateInstanceWithHttpInfo(id, subscriptionPromotionalOfferUpdateRequest, _options).pipe(map((apiResponse: HttpInfo<SubscriptionPromotionalOfferResponse>) => apiResponse.data));
    }

}

import { SubscriptionSubmissionsApiRequestFactory, SubscriptionSubmissionsApiResponseProcessor} from "../apis/SubscriptionSubmissionsApi.ts";
export class ObservableSubscriptionSubmissionsApi {
    private requestFactory: SubscriptionSubmissionsApiRequestFactory;
    private responseProcessor: SubscriptionSubmissionsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: SubscriptionSubmissionsApiRequestFactory,
        responseProcessor?: SubscriptionSubmissionsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new SubscriptionSubmissionsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new SubscriptionSubmissionsApiResponseProcessor();
    }

    /**
     * @param subscriptionSubmissionCreateRequest SubscriptionSubmission representation
     */
    public subscriptionSubmissionsCreateInstanceWithHttpInfo(subscriptionSubmissionCreateRequest: SubscriptionSubmissionCreateRequest, _options?: Configuration): Observable<HttpInfo<SubscriptionSubmissionResponse>> {
        const requestContextPromise = this.requestFactory.subscriptionSubmissionsCreateInstance(subscriptionSubmissionCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.subscriptionSubmissionsCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param subscriptionSubmissionCreateRequest SubscriptionSubmission representation
     */
    public subscriptionSubmissionsCreateInstance(subscriptionSubmissionCreateRequest: SubscriptionSubmissionCreateRequest, _options?: Configuration): Observable<SubscriptionSubmissionResponse> {
        return this.subscriptionSubmissionsCreateInstanceWithHttpInfo(subscriptionSubmissionCreateRequest, _options).pipe(map((apiResponse: HttpInfo<SubscriptionSubmissionResponse>) => apiResponse.data));
    }

}

import { SubscriptionsApiRequestFactory, SubscriptionsApiResponseProcessor} from "../apis/SubscriptionsApi.ts";
export class ObservableSubscriptionsApi {
    private requestFactory: SubscriptionsApiRequestFactory;
    private responseProcessor: SubscriptionsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: SubscriptionsApiRequestFactory,
        responseProcessor?: SubscriptionsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new SubscriptionsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new SubscriptionsApiResponseProcessor();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsSubscriptionAppStoreReviewScreenshots the fields to include for returned resources of type subscriptionAppStoreReviewScreenshots
     * @param fieldsSubscriptions the fields to include for returned resources of type subscriptions
     * @param include comma-separated list of relationships to include
     */
    public subscriptionsAppStoreReviewScreenshotGetToOneRelatedWithHttpInfo(id: string, fieldsSubscriptionAppStoreReviewScreenshots?: Array<'assetDeliveryState' | 'assetToken' | 'assetType' | 'fileName' | 'fileSize' | 'imageAsset' | 'sourceFileChecksum' | 'subscription' | 'uploadOperations' | 'uploaded'>, fieldsSubscriptions?: Array<'appStoreReviewScreenshot' | 'familySharable' | 'group' | 'groupLevel' | 'introductoryOffers' | 'name' | 'offerCodes' | 'pricePoints' | 'prices' | 'productId' | 'promotedPurchase' | 'promotionalOffers' | 'reviewNote' | 'state' | 'subscriptionAvailability' | 'subscriptionLocalizations' | 'subscriptionPeriod'>, include?: Array<'subscription'>, _options?: Configuration): Observable<HttpInfo<SubscriptionAppStoreReviewScreenshotResponse>> {
        const requestContextPromise = this.requestFactory.subscriptionsAppStoreReviewScreenshotGetToOneRelated(id, fieldsSubscriptionAppStoreReviewScreenshots, fieldsSubscriptions, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.subscriptionsAppStoreReviewScreenshotGetToOneRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsSubscriptionAppStoreReviewScreenshots the fields to include for returned resources of type subscriptionAppStoreReviewScreenshots
     * @param fieldsSubscriptions the fields to include for returned resources of type subscriptions
     * @param include comma-separated list of relationships to include
     */
    public subscriptionsAppStoreReviewScreenshotGetToOneRelated(id: string, fieldsSubscriptionAppStoreReviewScreenshots?: Array<'assetDeliveryState' | 'assetToken' | 'assetType' | 'fileName' | 'fileSize' | 'imageAsset' | 'sourceFileChecksum' | 'subscription' | 'uploadOperations' | 'uploaded'>, fieldsSubscriptions?: Array<'appStoreReviewScreenshot' | 'familySharable' | 'group' | 'groupLevel' | 'introductoryOffers' | 'name' | 'offerCodes' | 'pricePoints' | 'prices' | 'productId' | 'promotedPurchase' | 'promotionalOffers' | 'reviewNote' | 'state' | 'subscriptionAvailability' | 'subscriptionLocalizations' | 'subscriptionPeriod'>, include?: Array<'subscription'>, _options?: Configuration): Observable<SubscriptionAppStoreReviewScreenshotResponse> {
        return this.subscriptionsAppStoreReviewScreenshotGetToOneRelatedWithHttpInfo(id, fieldsSubscriptionAppStoreReviewScreenshots, fieldsSubscriptions, include, _options).pipe(map((apiResponse: HttpInfo<SubscriptionAppStoreReviewScreenshotResponse>) => apiResponse.data));
    }

    /**
     * @param subscriptionCreateRequest Subscription representation
     */
    public subscriptionsCreateInstanceWithHttpInfo(subscriptionCreateRequest: SubscriptionCreateRequest, _options?: Configuration): Observable<HttpInfo<SubscriptionResponse>> {
        const requestContextPromise = this.requestFactory.subscriptionsCreateInstance(subscriptionCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.subscriptionsCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param subscriptionCreateRequest Subscription representation
     */
    public subscriptionsCreateInstance(subscriptionCreateRequest: SubscriptionCreateRequest, _options?: Configuration): Observable<SubscriptionResponse> {
        return this.subscriptionsCreateInstanceWithHttpInfo(subscriptionCreateRequest, _options).pipe(map((apiResponse: HttpInfo<SubscriptionResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public subscriptionsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.subscriptionsDeleteInstance(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.subscriptionsDeleteInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public subscriptionsDeleteInstance(id: string, _options?: Configuration): Observable<void> {
        return this.subscriptionsDeleteInstanceWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsSubscriptions the fields to include for returned resources of type subscriptions
     * @param include comma-separated list of relationships to include
     * @param fieldsPromotedPurchases the fields to include for returned resources of type promotedPurchases
     * @param fieldsSubscriptionPricePoints the fields to include for returned resources of type subscriptionPricePoints
     * @param fieldsSubscriptionPromotionalOffers the fields to include for returned resources of type subscriptionPromotionalOffers
     * @param fieldsSubscriptionOfferCodes the fields to include for returned resources of type subscriptionOfferCodes
     * @param fieldsSubscriptionAppStoreReviewScreenshots the fields to include for returned resources of type subscriptionAppStoreReviewScreenshots
     * @param fieldsSubscriptionAvailabilities the fields to include for returned resources of type subscriptionAvailabilities
     * @param fieldsSubscriptionPrices the fields to include for returned resources of type subscriptionPrices
     * @param fieldsSubscriptionIntroductoryOffers the fields to include for returned resources of type subscriptionIntroductoryOffers
     * @param fieldsSubscriptionLocalizations the fields to include for returned resources of type subscriptionLocalizations
     * @param limitIntroductoryOffers maximum number of related introductoryOffers returned (when they are included)
     * @param limitOfferCodes maximum number of related offerCodes returned (when they are included)
     * @param limitPrices maximum number of related prices returned (when they are included)
     * @param limitPromotionalOffers maximum number of related promotionalOffers returned (when they are included)
     * @param limitSubscriptionLocalizations maximum number of related subscriptionLocalizations returned (when they are included)
     */
    public subscriptionsGetInstanceWithHttpInfo(id: string, fieldsSubscriptions?: Array<'appStoreReviewScreenshot' | 'familySharable' | 'group' | 'groupLevel' | 'introductoryOffers' | 'name' | 'offerCodes' | 'pricePoints' | 'prices' | 'productId' | 'promotedPurchase' | 'promotionalOffers' | 'reviewNote' | 'state' | 'subscriptionAvailability' | 'subscriptionLocalizations' | 'subscriptionPeriod'>, include?: Array<'appStoreReviewScreenshot' | 'group' | 'introductoryOffers' | 'offerCodes' | 'prices' | 'promotedPurchase' | 'promotionalOffers' | 'subscriptionAvailability' | 'subscriptionLocalizations'>, fieldsPromotedPurchases?: Array<'app' | 'enabled' | 'inAppPurchaseV2' | 'promotionImages' | 'state' | 'subscription' | 'visibleForAllUsers'>, fieldsSubscriptionPricePoints?: Array<'customerPrice' | 'equalizations' | 'proceeds' | 'proceedsYear2' | 'subscription' | 'territory'>, fieldsSubscriptionPromotionalOffers?: Array<'duration' | 'name' | 'numberOfPeriods' | 'offerCode' | 'offerMode' | 'prices' | 'subscription'>, fieldsSubscriptionOfferCodes?: Array<'active' | 'customCodes' | 'customerEligibilities' | 'duration' | 'name' | 'numberOfPeriods' | 'offerEligibility' | 'offerMode' | 'oneTimeUseCodes' | 'prices' | 'subscription' | 'totalNumberOfCodes'>, fieldsSubscriptionAppStoreReviewScreenshots?: Array<'assetDeliveryState' | 'assetToken' | 'assetType' | 'fileName' | 'fileSize' | 'imageAsset' | 'sourceFileChecksum' | 'subscription' | 'uploadOperations' | 'uploaded'>, fieldsSubscriptionAvailabilities?: Array<'availableInNewTerritories' | 'availableTerritories' | 'subscription'>, fieldsSubscriptionPrices?: Array<'preserveCurrentPrice' | 'preserved' | 'startDate' | 'subscription' | 'subscriptionPricePoint' | 'territory'>, fieldsSubscriptionIntroductoryOffers?: Array<'duration' | 'endDate' | 'numberOfPeriods' | 'offerMode' | 'startDate' | 'subscription' | 'subscriptionPricePoint' | 'territory'>, fieldsSubscriptionLocalizations?: Array<'description' | 'locale' | 'name' | 'state' | 'subscription'>, limitIntroductoryOffers?: number, limitOfferCodes?: number, limitPrices?: number, limitPromotionalOffers?: number, limitSubscriptionLocalizations?: number, _options?: Configuration): Observable<HttpInfo<SubscriptionResponse>> {
        const requestContextPromise = this.requestFactory.subscriptionsGetInstance(id, fieldsSubscriptions, include, fieldsPromotedPurchases, fieldsSubscriptionPricePoints, fieldsSubscriptionPromotionalOffers, fieldsSubscriptionOfferCodes, fieldsSubscriptionAppStoreReviewScreenshots, fieldsSubscriptionAvailabilities, fieldsSubscriptionPrices, fieldsSubscriptionIntroductoryOffers, fieldsSubscriptionLocalizations, limitIntroductoryOffers, limitOfferCodes, limitPrices, limitPromotionalOffers, limitSubscriptionLocalizations, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.subscriptionsGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsSubscriptions the fields to include for returned resources of type subscriptions
     * @param include comma-separated list of relationships to include
     * @param fieldsPromotedPurchases the fields to include for returned resources of type promotedPurchases
     * @param fieldsSubscriptionPricePoints the fields to include for returned resources of type subscriptionPricePoints
     * @param fieldsSubscriptionPromotionalOffers the fields to include for returned resources of type subscriptionPromotionalOffers
     * @param fieldsSubscriptionOfferCodes the fields to include for returned resources of type subscriptionOfferCodes
     * @param fieldsSubscriptionAppStoreReviewScreenshots the fields to include for returned resources of type subscriptionAppStoreReviewScreenshots
     * @param fieldsSubscriptionAvailabilities the fields to include for returned resources of type subscriptionAvailabilities
     * @param fieldsSubscriptionPrices the fields to include for returned resources of type subscriptionPrices
     * @param fieldsSubscriptionIntroductoryOffers the fields to include for returned resources of type subscriptionIntroductoryOffers
     * @param fieldsSubscriptionLocalizations the fields to include for returned resources of type subscriptionLocalizations
     * @param limitIntroductoryOffers maximum number of related introductoryOffers returned (when they are included)
     * @param limitOfferCodes maximum number of related offerCodes returned (when they are included)
     * @param limitPrices maximum number of related prices returned (when they are included)
     * @param limitPromotionalOffers maximum number of related promotionalOffers returned (when they are included)
     * @param limitSubscriptionLocalizations maximum number of related subscriptionLocalizations returned (when they are included)
     */
    public subscriptionsGetInstance(id: string, fieldsSubscriptions?: Array<'appStoreReviewScreenshot' | 'familySharable' | 'group' | 'groupLevel' | 'introductoryOffers' | 'name' | 'offerCodes' | 'pricePoints' | 'prices' | 'productId' | 'promotedPurchase' | 'promotionalOffers' | 'reviewNote' | 'state' | 'subscriptionAvailability' | 'subscriptionLocalizations' | 'subscriptionPeriod'>, include?: Array<'appStoreReviewScreenshot' | 'group' | 'introductoryOffers' | 'offerCodes' | 'prices' | 'promotedPurchase' | 'promotionalOffers' | 'subscriptionAvailability' | 'subscriptionLocalizations'>, fieldsPromotedPurchases?: Array<'app' | 'enabled' | 'inAppPurchaseV2' | 'promotionImages' | 'state' | 'subscription' | 'visibleForAllUsers'>, fieldsSubscriptionPricePoints?: Array<'customerPrice' | 'equalizations' | 'proceeds' | 'proceedsYear2' | 'subscription' | 'territory'>, fieldsSubscriptionPromotionalOffers?: Array<'duration' | 'name' | 'numberOfPeriods' | 'offerCode' | 'offerMode' | 'prices' | 'subscription'>, fieldsSubscriptionOfferCodes?: Array<'active' | 'customCodes' | 'customerEligibilities' | 'duration' | 'name' | 'numberOfPeriods' | 'offerEligibility' | 'offerMode' | 'oneTimeUseCodes' | 'prices' | 'subscription' | 'totalNumberOfCodes'>, fieldsSubscriptionAppStoreReviewScreenshots?: Array<'assetDeliveryState' | 'assetToken' | 'assetType' | 'fileName' | 'fileSize' | 'imageAsset' | 'sourceFileChecksum' | 'subscription' | 'uploadOperations' | 'uploaded'>, fieldsSubscriptionAvailabilities?: Array<'availableInNewTerritories' | 'availableTerritories' | 'subscription'>, fieldsSubscriptionPrices?: Array<'preserveCurrentPrice' | 'preserved' | 'startDate' | 'subscription' | 'subscriptionPricePoint' | 'territory'>, fieldsSubscriptionIntroductoryOffers?: Array<'duration' | 'endDate' | 'numberOfPeriods' | 'offerMode' | 'startDate' | 'subscription' | 'subscriptionPricePoint' | 'territory'>, fieldsSubscriptionLocalizations?: Array<'description' | 'locale' | 'name' | 'state' | 'subscription'>, limitIntroductoryOffers?: number, limitOfferCodes?: number, limitPrices?: number, limitPromotionalOffers?: number, limitSubscriptionLocalizations?: number, _options?: Configuration): Observable<SubscriptionResponse> {
        return this.subscriptionsGetInstanceWithHttpInfo(id, fieldsSubscriptions, include, fieldsPromotedPurchases, fieldsSubscriptionPricePoints, fieldsSubscriptionPromotionalOffers, fieldsSubscriptionOfferCodes, fieldsSubscriptionAppStoreReviewScreenshots, fieldsSubscriptionAvailabilities, fieldsSubscriptionPrices, fieldsSubscriptionIntroductoryOffers, fieldsSubscriptionLocalizations, limitIntroductoryOffers, limitOfferCodes, limitPrices, limitPromotionalOffers, limitSubscriptionLocalizations, _options).pipe(map((apiResponse: HttpInfo<SubscriptionResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param subscriptionIntroductoryOffersLinkagesRequest List of related linkages
     */
    public subscriptionsIntroductoryOffersDeleteToManyRelationshipWithHttpInfo(id: string, subscriptionIntroductoryOffersLinkagesRequest: SubscriptionIntroductoryOffersLinkagesRequest, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.subscriptionsIntroductoryOffersDeleteToManyRelationship(id, subscriptionIntroductoryOffersLinkagesRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.subscriptionsIntroductoryOffersDeleteToManyRelationshipWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param subscriptionIntroductoryOffersLinkagesRequest List of related linkages
     */
    public subscriptionsIntroductoryOffersDeleteToManyRelationship(id: string, subscriptionIntroductoryOffersLinkagesRequest: SubscriptionIntroductoryOffersLinkagesRequest, _options?: Configuration): Observable<void> {
        return this.subscriptionsIntroductoryOffersDeleteToManyRelationshipWithHttpInfo(id, subscriptionIntroductoryOffersLinkagesRequest, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param filterTerritory filter by id(s) of related \&#39;territory\&#39;
     * @param fieldsSubscriptionPricePoints the fields to include for returned resources of type subscriptionPricePoints
     * @param fieldsSubscriptions the fields to include for returned resources of type subscriptions
     * @param fieldsSubscriptionIntroductoryOffers the fields to include for returned resources of type subscriptionIntroductoryOffers
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public subscriptionsIntroductoryOffersGetToManyRelatedWithHttpInfo(id: string, filterTerritory?: Array<string>, fieldsSubscriptionPricePoints?: Array<'customerPrice' | 'equalizations' | 'proceeds' | 'proceedsYear2' | 'subscription' | 'territory'>, fieldsSubscriptions?: Array<'appStoreReviewScreenshot' | 'familySharable' | 'group' | 'groupLevel' | 'introductoryOffers' | 'name' | 'offerCodes' | 'pricePoints' | 'prices' | 'productId' | 'promotedPurchase' | 'promotionalOffers' | 'reviewNote' | 'state' | 'subscriptionAvailability' | 'subscriptionLocalizations' | 'subscriptionPeriod'>, fieldsSubscriptionIntroductoryOffers?: Array<'duration' | 'endDate' | 'numberOfPeriods' | 'offerMode' | 'startDate' | 'subscription' | 'subscriptionPricePoint' | 'territory'>, fieldsTerritories?: Array<'currency'>, limit?: number, include?: Array<'subscription' | 'subscriptionPricePoint' | 'territory'>, _options?: Configuration): Observable<HttpInfo<SubscriptionIntroductoryOffersResponse>> {
        const requestContextPromise = this.requestFactory.subscriptionsIntroductoryOffersGetToManyRelated(id, filterTerritory, fieldsSubscriptionPricePoints, fieldsSubscriptions, fieldsSubscriptionIntroductoryOffers, fieldsTerritories, limit, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.subscriptionsIntroductoryOffersGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param filterTerritory filter by id(s) of related \&#39;territory\&#39;
     * @param fieldsSubscriptionPricePoints the fields to include for returned resources of type subscriptionPricePoints
     * @param fieldsSubscriptions the fields to include for returned resources of type subscriptions
     * @param fieldsSubscriptionIntroductoryOffers the fields to include for returned resources of type subscriptionIntroductoryOffers
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public subscriptionsIntroductoryOffersGetToManyRelated(id: string, filterTerritory?: Array<string>, fieldsSubscriptionPricePoints?: Array<'customerPrice' | 'equalizations' | 'proceeds' | 'proceedsYear2' | 'subscription' | 'territory'>, fieldsSubscriptions?: Array<'appStoreReviewScreenshot' | 'familySharable' | 'group' | 'groupLevel' | 'introductoryOffers' | 'name' | 'offerCodes' | 'pricePoints' | 'prices' | 'productId' | 'promotedPurchase' | 'promotionalOffers' | 'reviewNote' | 'state' | 'subscriptionAvailability' | 'subscriptionLocalizations' | 'subscriptionPeriod'>, fieldsSubscriptionIntroductoryOffers?: Array<'duration' | 'endDate' | 'numberOfPeriods' | 'offerMode' | 'startDate' | 'subscription' | 'subscriptionPricePoint' | 'territory'>, fieldsTerritories?: Array<'currency'>, limit?: number, include?: Array<'subscription' | 'subscriptionPricePoint' | 'territory'>, _options?: Configuration): Observable<SubscriptionIntroductoryOffersResponse> {
        return this.subscriptionsIntroductoryOffersGetToManyRelatedWithHttpInfo(id, filterTerritory, fieldsSubscriptionPricePoints, fieldsSubscriptions, fieldsSubscriptionIntroductoryOffers, fieldsTerritories, limit, include, _options).pipe(map((apiResponse: HttpInfo<SubscriptionIntroductoryOffersResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public subscriptionsIntroductoryOffersGetToManyRelationshipWithHttpInfo(id: string, limit?: number, _options?: Configuration): Observable<HttpInfo<SubscriptionIntroductoryOffersLinkagesResponse>> {
        const requestContextPromise = this.requestFactory.subscriptionsIntroductoryOffersGetToManyRelationship(id, limit, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.subscriptionsIntroductoryOffersGetToManyRelationshipWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public subscriptionsIntroductoryOffersGetToManyRelationship(id: string, limit?: number, _options?: Configuration): Observable<SubscriptionIntroductoryOffersLinkagesResponse> {
        return this.subscriptionsIntroductoryOffersGetToManyRelationshipWithHttpInfo(id, limit, _options).pipe(map((apiResponse: HttpInfo<SubscriptionIntroductoryOffersLinkagesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param filterTerritory filter by territory
     * @param fieldsSubscriptionOfferCodeCustomCodes the fields to include for returned resources of type subscriptionOfferCodeCustomCodes
     * @param fieldsSubscriptionOfferCodes the fields to include for returned resources of type subscriptionOfferCodes
     * @param fieldsSubscriptionOfferCodeOneTimeUseCodes the fields to include for returned resources of type subscriptionOfferCodeOneTimeUseCodes
     * @param fieldsSubscriptions the fields to include for returned resources of type subscriptions
     * @param fieldsSubscriptionOfferCodePrices the fields to include for returned resources of type subscriptionOfferCodePrices
     * @param limit maximum resources per page
     * @param limitOneTimeUseCodes maximum number of related oneTimeUseCodes returned (when they are included)
     * @param limitCustomCodes maximum number of related customCodes returned (when they are included)
     * @param limitPrices maximum number of related prices returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public subscriptionsOfferCodesGetToManyRelatedWithHttpInfo(id: string, filterTerritory?: Array<string>, fieldsSubscriptionOfferCodeCustomCodes?: Array<'active' | 'createdDate' | 'customCode' | 'expirationDate' | 'numberOfCodes' | 'offerCode'>, fieldsSubscriptionOfferCodes?: Array<'active' | 'customCodes' | 'customerEligibilities' | 'duration' | 'name' | 'numberOfPeriods' | 'offerEligibility' | 'offerMode' | 'oneTimeUseCodes' | 'prices' | 'subscription' | 'totalNumberOfCodes'>, fieldsSubscriptionOfferCodeOneTimeUseCodes?: Array<'active' | 'createdDate' | 'expirationDate' | 'numberOfCodes' | 'offerCode' | 'values'>, fieldsSubscriptions?: Array<'appStoreReviewScreenshot' | 'familySharable' | 'group' | 'groupLevel' | 'introductoryOffers' | 'name' | 'offerCodes' | 'pricePoints' | 'prices' | 'productId' | 'promotedPurchase' | 'promotionalOffers' | 'reviewNote' | 'state' | 'subscriptionAvailability' | 'subscriptionLocalizations' | 'subscriptionPeriod'>, fieldsSubscriptionOfferCodePrices?: Array<'subscriptionPricePoint' | 'territory'>, limit?: number, limitOneTimeUseCodes?: number, limitCustomCodes?: number, limitPrices?: number, include?: Array<'customCodes' | 'oneTimeUseCodes' | 'prices' | 'subscription'>, _options?: Configuration): Observable<HttpInfo<SubscriptionOfferCodesResponse>> {
        const requestContextPromise = this.requestFactory.subscriptionsOfferCodesGetToManyRelated(id, filterTerritory, fieldsSubscriptionOfferCodeCustomCodes, fieldsSubscriptionOfferCodes, fieldsSubscriptionOfferCodeOneTimeUseCodes, fieldsSubscriptions, fieldsSubscriptionOfferCodePrices, limit, limitOneTimeUseCodes, limitCustomCodes, limitPrices, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.subscriptionsOfferCodesGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param filterTerritory filter by territory
     * @param fieldsSubscriptionOfferCodeCustomCodes the fields to include for returned resources of type subscriptionOfferCodeCustomCodes
     * @param fieldsSubscriptionOfferCodes the fields to include for returned resources of type subscriptionOfferCodes
     * @param fieldsSubscriptionOfferCodeOneTimeUseCodes the fields to include for returned resources of type subscriptionOfferCodeOneTimeUseCodes
     * @param fieldsSubscriptions the fields to include for returned resources of type subscriptions
     * @param fieldsSubscriptionOfferCodePrices the fields to include for returned resources of type subscriptionOfferCodePrices
     * @param limit maximum resources per page
     * @param limitOneTimeUseCodes maximum number of related oneTimeUseCodes returned (when they are included)
     * @param limitCustomCodes maximum number of related customCodes returned (when they are included)
     * @param limitPrices maximum number of related prices returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public subscriptionsOfferCodesGetToManyRelated(id: string, filterTerritory?: Array<string>, fieldsSubscriptionOfferCodeCustomCodes?: Array<'active' | 'createdDate' | 'customCode' | 'expirationDate' | 'numberOfCodes' | 'offerCode'>, fieldsSubscriptionOfferCodes?: Array<'active' | 'customCodes' | 'customerEligibilities' | 'duration' | 'name' | 'numberOfPeriods' | 'offerEligibility' | 'offerMode' | 'oneTimeUseCodes' | 'prices' | 'subscription' | 'totalNumberOfCodes'>, fieldsSubscriptionOfferCodeOneTimeUseCodes?: Array<'active' | 'createdDate' | 'expirationDate' | 'numberOfCodes' | 'offerCode' | 'values'>, fieldsSubscriptions?: Array<'appStoreReviewScreenshot' | 'familySharable' | 'group' | 'groupLevel' | 'introductoryOffers' | 'name' | 'offerCodes' | 'pricePoints' | 'prices' | 'productId' | 'promotedPurchase' | 'promotionalOffers' | 'reviewNote' | 'state' | 'subscriptionAvailability' | 'subscriptionLocalizations' | 'subscriptionPeriod'>, fieldsSubscriptionOfferCodePrices?: Array<'subscriptionPricePoint' | 'territory'>, limit?: number, limitOneTimeUseCodes?: number, limitCustomCodes?: number, limitPrices?: number, include?: Array<'customCodes' | 'oneTimeUseCodes' | 'prices' | 'subscription'>, _options?: Configuration): Observable<SubscriptionOfferCodesResponse> {
        return this.subscriptionsOfferCodesGetToManyRelatedWithHttpInfo(id, filterTerritory, fieldsSubscriptionOfferCodeCustomCodes, fieldsSubscriptionOfferCodes, fieldsSubscriptionOfferCodeOneTimeUseCodes, fieldsSubscriptions, fieldsSubscriptionOfferCodePrices, limit, limitOneTimeUseCodes, limitCustomCodes, limitPrices, include, _options).pipe(map((apiResponse: HttpInfo<SubscriptionOfferCodesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param filterTerritory filter by id(s) of related \&#39;territory\&#39;
     * @param fieldsSubscriptionPricePoints the fields to include for returned resources of type subscriptionPricePoints
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public subscriptionsPricePointsGetToManyRelatedWithHttpInfo(id: string, filterTerritory?: Array<string>, fieldsSubscriptionPricePoints?: Array<'customerPrice' | 'equalizations' | 'proceeds' | 'proceedsYear2' | 'subscription' | 'territory'>, fieldsTerritories?: Array<'currency'>, limit?: number, include?: Array<'territory'>, _options?: Configuration): Observable<HttpInfo<SubscriptionPricePointsResponse>> {
        const requestContextPromise = this.requestFactory.subscriptionsPricePointsGetToManyRelated(id, filterTerritory, fieldsSubscriptionPricePoints, fieldsTerritories, limit, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.subscriptionsPricePointsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param filterTerritory filter by id(s) of related \&#39;territory\&#39;
     * @param fieldsSubscriptionPricePoints the fields to include for returned resources of type subscriptionPricePoints
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public subscriptionsPricePointsGetToManyRelated(id: string, filterTerritory?: Array<string>, fieldsSubscriptionPricePoints?: Array<'customerPrice' | 'equalizations' | 'proceeds' | 'proceedsYear2' | 'subscription' | 'territory'>, fieldsTerritories?: Array<'currency'>, limit?: number, include?: Array<'territory'>, _options?: Configuration): Observable<SubscriptionPricePointsResponse> {
        return this.subscriptionsPricePointsGetToManyRelatedWithHttpInfo(id, filterTerritory, fieldsSubscriptionPricePoints, fieldsTerritories, limit, include, _options).pipe(map((apiResponse: HttpInfo<SubscriptionPricePointsResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param subscriptionPricesLinkagesRequest List of related linkages
     */
    public subscriptionsPricesDeleteToManyRelationshipWithHttpInfo(id: string, subscriptionPricesLinkagesRequest: SubscriptionPricesLinkagesRequest, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.subscriptionsPricesDeleteToManyRelationship(id, subscriptionPricesLinkagesRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.subscriptionsPricesDeleteToManyRelationshipWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param subscriptionPricesLinkagesRequest List of related linkages
     */
    public subscriptionsPricesDeleteToManyRelationship(id: string, subscriptionPricesLinkagesRequest: SubscriptionPricesLinkagesRequest, _options?: Configuration): Observable<void> {
        return this.subscriptionsPricesDeleteToManyRelationshipWithHttpInfo(id, subscriptionPricesLinkagesRequest, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param filterSubscriptionPricePoint filter by id(s) of related \&#39;subscriptionPricePoint\&#39;
     * @param filterTerritory filter by id(s) of related \&#39;territory\&#39;
     * @param fieldsSubscriptionPricePoints the fields to include for returned resources of type subscriptionPricePoints
     * @param fieldsSubscriptionPrices the fields to include for returned resources of type subscriptionPrices
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public subscriptionsPricesGetToManyRelatedWithHttpInfo(id: string, filterSubscriptionPricePoint?: Array<string>, filterTerritory?: Array<string>, fieldsSubscriptionPricePoints?: Array<'customerPrice' | 'equalizations' | 'proceeds' | 'proceedsYear2' | 'subscription' | 'territory'>, fieldsSubscriptionPrices?: Array<'preserveCurrentPrice' | 'preserved' | 'startDate' | 'subscription' | 'subscriptionPricePoint' | 'territory'>, fieldsTerritories?: Array<'currency'>, limit?: number, include?: Array<'subscriptionPricePoint' | 'territory'>, _options?: Configuration): Observable<HttpInfo<SubscriptionPricesResponse>> {
        const requestContextPromise = this.requestFactory.subscriptionsPricesGetToManyRelated(id, filterSubscriptionPricePoint, filterTerritory, fieldsSubscriptionPricePoints, fieldsSubscriptionPrices, fieldsTerritories, limit, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.subscriptionsPricesGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param filterSubscriptionPricePoint filter by id(s) of related \&#39;subscriptionPricePoint\&#39;
     * @param filterTerritory filter by id(s) of related \&#39;territory\&#39;
     * @param fieldsSubscriptionPricePoints the fields to include for returned resources of type subscriptionPricePoints
     * @param fieldsSubscriptionPrices the fields to include for returned resources of type subscriptionPrices
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public subscriptionsPricesGetToManyRelated(id: string, filterSubscriptionPricePoint?: Array<string>, filterTerritory?: Array<string>, fieldsSubscriptionPricePoints?: Array<'customerPrice' | 'equalizations' | 'proceeds' | 'proceedsYear2' | 'subscription' | 'territory'>, fieldsSubscriptionPrices?: Array<'preserveCurrentPrice' | 'preserved' | 'startDate' | 'subscription' | 'subscriptionPricePoint' | 'territory'>, fieldsTerritories?: Array<'currency'>, limit?: number, include?: Array<'subscriptionPricePoint' | 'territory'>, _options?: Configuration): Observable<SubscriptionPricesResponse> {
        return this.subscriptionsPricesGetToManyRelatedWithHttpInfo(id, filterSubscriptionPricePoint, filterTerritory, fieldsSubscriptionPricePoints, fieldsSubscriptionPrices, fieldsTerritories, limit, include, _options).pipe(map((apiResponse: HttpInfo<SubscriptionPricesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public subscriptionsPricesGetToManyRelationshipWithHttpInfo(id: string, limit?: number, _options?: Configuration): Observable<HttpInfo<SubscriptionPricesLinkagesResponse>> {
        const requestContextPromise = this.requestFactory.subscriptionsPricesGetToManyRelationship(id, limit, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.subscriptionsPricesGetToManyRelationshipWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public subscriptionsPricesGetToManyRelationship(id: string, limit?: number, _options?: Configuration): Observable<SubscriptionPricesLinkagesResponse> {
        return this.subscriptionsPricesGetToManyRelationshipWithHttpInfo(id, limit, _options).pipe(map((apiResponse: HttpInfo<SubscriptionPricesLinkagesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsPromotedPurchases the fields to include for returned resources of type promotedPurchases
     * @param fieldsSubscriptions the fields to include for returned resources of type subscriptions
     * @param fieldsInAppPurchases the fields to include for returned resources of type inAppPurchases
     * @param fieldsPromotedPurchaseImages the fields to include for returned resources of type promotedPurchaseImages
     * @param limitPromotionImages maximum number of related promotionImages returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public subscriptionsPromotedPurchaseGetToOneRelatedWithHttpInfo(id: string, fieldsPromotedPurchases?: Array<'app' | 'enabled' | 'inAppPurchaseV2' | 'promotionImages' | 'state' | 'subscription' | 'visibleForAllUsers'>, fieldsSubscriptions?: Array<'appStoreReviewScreenshot' | 'familySharable' | 'group' | 'groupLevel' | 'introductoryOffers' | 'name' | 'offerCodes' | 'pricePoints' | 'prices' | 'productId' | 'promotedPurchase' | 'promotionalOffers' | 'reviewNote' | 'state' | 'subscriptionAvailability' | 'subscriptionLocalizations' | 'subscriptionPeriod'>, fieldsInAppPurchases?: Array<'app' | 'appStoreReviewScreenshot' | 'content' | 'contentHosting' | 'familySharable' | 'iapPriceSchedule' | 'inAppPurchaseAvailability' | 'inAppPurchaseLocalizations' | 'inAppPurchaseType' | 'name' | 'pricePoints' | 'productId' | 'promotedPurchase' | 'reviewNote' | 'state'>, fieldsPromotedPurchaseImages?: Array<'assetToken' | 'assetType' | 'fileName' | 'fileSize' | 'imageAsset' | 'promotedPurchase' | 'sourceFileChecksum' | 'state' | 'uploadOperations' | 'uploaded'>, limitPromotionImages?: number, include?: Array<'inAppPurchaseV2' | 'promotionImages' | 'subscription'>, _options?: Configuration): Observable<HttpInfo<PromotedPurchaseResponse>> {
        const requestContextPromise = this.requestFactory.subscriptionsPromotedPurchaseGetToOneRelated(id, fieldsPromotedPurchases, fieldsSubscriptions, fieldsInAppPurchases, fieldsPromotedPurchaseImages, limitPromotionImages, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.subscriptionsPromotedPurchaseGetToOneRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsPromotedPurchases the fields to include for returned resources of type promotedPurchases
     * @param fieldsSubscriptions the fields to include for returned resources of type subscriptions
     * @param fieldsInAppPurchases the fields to include for returned resources of type inAppPurchases
     * @param fieldsPromotedPurchaseImages the fields to include for returned resources of type promotedPurchaseImages
     * @param limitPromotionImages maximum number of related promotionImages returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public subscriptionsPromotedPurchaseGetToOneRelated(id: string, fieldsPromotedPurchases?: Array<'app' | 'enabled' | 'inAppPurchaseV2' | 'promotionImages' | 'state' | 'subscription' | 'visibleForAllUsers'>, fieldsSubscriptions?: Array<'appStoreReviewScreenshot' | 'familySharable' | 'group' | 'groupLevel' | 'introductoryOffers' | 'name' | 'offerCodes' | 'pricePoints' | 'prices' | 'productId' | 'promotedPurchase' | 'promotionalOffers' | 'reviewNote' | 'state' | 'subscriptionAvailability' | 'subscriptionLocalizations' | 'subscriptionPeriod'>, fieldsInAppPurchases?: Array<'app' | 'appStoreReviewScreenshot' | 'content' | 'contentHosting' | 'familySharable' | 'iapPriceSchedule' | 'inAppPurchaseAvailability' | 'inAppPurchaseLocalizations' | 'inAppPurchaseType' | 'name' | 'pricePoints' | 'productId' | 'promotedPurchase' | 'reviewNote' | 'state'>, fieldsPromotedPurchaseImages?: Array<'assetToken' | 'assetType' | 'fileName' | 'fileSize' | 'imageAsset' | 'promotedPurchase' | 'sourceFileChecksum' | 'state' | 'uploadOperations' | 'uploaded'>, limitPromotionImages?: number, include?: Array<'inAppPurchaseV2' | 'promotionImages' | 'subscription'>, _options?: Configuration): Observable<PromotedPurchaseResponse> {
        return this.subscriptionsPromotedPurchaseGetToOneRelatedWithHttpInfo(id, fieldsPromotedPurchases, fieldsSubscriptions, fieldsInAppPurchases, fieldsPromotedPurchaseImages, limitPromotionImages, include, _options).pipe(map((apiResponse: HttpInfo<PromotedPurchaseResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param filterTerritory filter by territory
     * @param fieldsSubscriptionPromotionalOffers the fields to include for returned resources of type subscriptionPromotionalOffers
     * @param fieldsSubscriptions the fields to include for returned resources of type subscriptions
     * @param fieldsSubscriptionPromotionalOfferPrices the fields to include for returned resources of type subscriptionPromotionalOfferPrices
     * @param limit maximum resources per page
     * @param limitPrices maximum number of related prices returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public subscriptionsPromotionalOffersGetToManyRelatedWithHttpInfo(id: string, filterTerritory?: Array<string>, fieldsSubscriptionPromotionalOffers?: Array<'duration' | 'name' | 'numberOfPeriods' | 'offerCode' | 'offerMode' | 'prices' | 'subscription'>, fieldsSubscriptions?: Array<'appStoreReviewScreenshot' | 'familySharable' | 'group' | 'groupLevel' | 'introductoryOffers' | 'name' | 'offerCodes' | 'pricePoints' | 'prices' | 'productId' | 'promotedPurchase' | 'promotionalOffers' | 'reviewNote' | 'state' | 'subscriptionAvailability' | 'subscriptionLocalizations' | 'subscriptionPeriod'>, fieldsSubscriptionPromotionalOfferPrices?: Array<'subscriptionPricePoint' | 'territory'>, limit?: number, limitPrices?: number, include?: Array<'prices' | 'subscription'>, _options?: Configuration): Observable<HttpInfo<SubscriptionPromotionalOffersResponse>> {
        const requestContextPromise = this.requestFactory.subscriptionsPromotionalOffersGetToManyRelated(id, filterTerritory, fieldsSubscriptionPromotionalOffers, fieldsSubscriptions, fieldsSubscriptionPromotionalOfferPrices, limit, limitPrices, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.subscriptionsPromotionalOffersGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param filterTerritory filter by territory
     * @param fieldsSubscriptionPromotionalOffers the fields to include for returned resources of type subscriptionPromotionalOffers
     * @param fieldsSubscriptions the fields to include for returned resources of type subscriptions
     * @param fieldsSubscriptionPromotionalOfferPrices the fields to include for returned resources of type subscriptionPromotionalOfferPrices
     * @param limit maximum resources per page
     * @param limitPrices maximum number of related prices returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public subscriptionsPromotionalOffersGetToManyRelated(id: string, filterTerritory?: Array<string>, fieldsSubscriptionPromotionalOffers?: Array<'duration' | 'name' | 'numberOfPeriods' | 'offerCode' | 'offerMode' | 'prices' | 'subscription'>, fieldsSubscriptions?: Array<'appStoreReviewScreenshot' | 'familySharable' | 'group' | 'groupLevel' | 'introductoryOffers' | 'name' | 'offerCodes' | 'pricePoints' | 'prices' | 'productId' | 'promotedPurchase' | 'promotionalOffers' | 'reviewNote' | 'state' | 'subscriptionAvailability' | 'subscriptionLocalizations' | 'subscriptionPeriod'>, fieldsSubscriptionPromotionalOfferPrices?: Array<'subscriptionPricePoint' | 'territory'>, limit?: number, limitPrices?: number, include?: Array<'prices' | 'subscription'>, _options?: Configuration): Observable<SubscriptionPromotionalOffersResponse> {
        return this.subscriptionsPromotionalOffersGetToManyRelatedWithHttpInfo(id, filterTerritory, fieldsSubscriptionPromotionalOffers, fieldsSubscriptions, fieldsSubscriptionPromotionalOfferPrices, limit, limitPrices, include, _options).pipe(map((apiResponse: HttpInfo<SubscriptionPromotionalOffersResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsSubscriptionAvailabilities the fields to include for returned resources of type subscriptionAvailabilities
     * @param fieldsSubscriptions the fields to include for returned resources of type subscriptions
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limitAvailableTerritories maximum number of related availableTerritories returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public subscriptionsSubscriptionAvailabilityGetToOneRelatedWithHttpInfo(id: string, fieldsSubscriptionAvailabilities?: Array<'availableInNewTerritories' | 'availableTerritories' | 'subscription'>, fieldsSubscriptions?: Array<'appStoreReviewScreenshot' | 'familySharable' | 'group' | 'groupLevel' | 'introductoryOffers' | 'name' | 'offerCodes' | 'pricePoints' | 'prices' | 'productId' | 'promotedPurchase' | 'promotionalOffers' | 'reviewNote' | 'state' | 'subscriptionAvailability' | 'subscriptionLocalizations' | 'subscriptionPeriod'>, fieldsTerritories?: Array<'currency'>, limitAvailableTerritories?: number, include?: Array<'availableTerritories' | 'subscription'>, _options?: Configuration): Observable<HttpInfo<SubscriptionAvailabilityResponse>> {
        const requestContextPromise = this.requestFactory.subscriptionsSubscriptionAvailabilityGetToOneRelated(id, fieldsSubscriptionAvailabilities, fieldsSubscriptions, fieldsTerritories, limitAvailableTerritories, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.subscriptionsSubscriptionAvailabilityGetToOneRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsSubscriptionAvailabilities the fields to include for returned resources of type subscriptionAvailabilities
     * @param fieldsSubscriptions the fields to include for returned resources of type subscriptions
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limitAvailableTerritories maximum number of related availableTerritories returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public subscriptionsSubscriptionAvailabilityGetToOneRelated(id: string, fieldsSubscriptionAvailabilities?: Array<'availableInNewTerritories' | 'availableTerritories' | 'subscription'>, fieldsSubscriptions?: Array<'appStoreReviewScreenshot' | 'familySharable' | 'group' | 'groupLevel' | 'introductoryOffers' | 'name' | 'offerCodes' | 'pricePoints' | 'prices' | 'productId' | 'promotedPurchase' | 'promotionalOffers' | 'reviewNote' | 'state' | 'subscriptionAvailability' | 'subscriptionLocalizations' | 'subscriptionPeriod'>, fieldsTerritories?: Array<'currency'>, limitAvailableTerritories?: number, include?: Array<'availableTerritories' | 'subscription'>, _options?: Configuration): Observable<SubscriptionAvailabilityResponse> {
        return this.subscriptionsSubscriptionAvailabilityGetToOneRelatedWithHttpInfo(id, fieldsSubscriptionAvailabilities, fieldsSubscriptions, fieldsTerritories, limitAvailableTerritories, include, _options).pipe(map((apiResponse: HttpInfo<SubscriptionAvailabilityResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsSubscriptions the fields to include for returned resources of type subscriptions
     * @param fieldsSubscriptionLocalizations the fields to include for returned resources of type subscriptionLocalizations
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public subscriptionsSubscriptionLocalizationsGetToManyRelatedWithHttpInfo(id: string, fieldsSubscriptions?: Array<'appStoreReviewScreenshot' | 'familySharable' | 'group' | 'groupLevel' | 'introductoryOffers' | 'name' | 'offerCodes' | 'pricePoints' | 'prices' | 'productId' | 'promotedPurchase' | 'promotionalOffers' | 'reviewNote' | 'state' | 'subscriptionAvailability' | 'subscriptionLocalizations' | 'subscriptionPeriod'>, fieldsSubscriptionLocalizations?: Array<'description' | 'locale' | 'name' | 'state' | 'subscription'>, limit?: number, include?: Array<'subscription'>, _options?: Configuration): Observable<HttpInfo<SubscriptionLocalizationsResponse>> {
        const requestContextPromise = this.requestFactory.subscriptionsSubscriptionLocalizationsGetToManyRelated(id, fieldsSubscriptions, fieldsSubscriptionLocalizations, limit, include, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.subscriptionsSubscriptionLocalizationsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsSubscriptions the fields to include for returned resources of type subscriptions
     * @param fieldsSubscriptionLocalizations the fields to include for returned resources of type subscriptionLocalizations
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public subscriptionsSubscriptionLocalizationsGetToManyRelated(id: string, fieldsSubscriptions?: Array<'appStoreReviewScreenshot' | 'familySharable' | 'group' | 'groupLevel' | 'introductoryOffers' | 'name' | 'offerCodes' | 'pricePoints' | 'prices' | 'productId' | 'promotedPurchase' | 'promotionalOffers' | 'reviewNote' | 'state' | 'subscriptionAvailability' | 'subscriptionLocalizations' | 'subscriptionPeriod'>, fieldsSubscriptionLocalizations?: Array<'description' | 'locale' | 'name' | 'state' | 'subscription'>, limit?: number, include?: Array<'subscription'>, _options?: Configuration): Observable<SubscriptionLocalizationsResponse> {
        return this.subscriptionsSubscriptionLocalizationsGetToManyRelatedWithHttpInfo(id, fieldsSubscriptions, fieldsSubscriptionLocalizations, limit, include, _options).pipe(map((apiResponse: HttpInfo<SubscriptionLocalizationsResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param subscriptionUpdateRequest Subscription representation
     */
    public subscriptionsUpdateInstanceWithHttpInfo(id: string, subscriptionUpdateRequest: SubscriptionUpdateRequest, _options?: Configuration): Observable<HttpInfo<SubscriptionResponse>> {
        const requestContextPromise = this.requestFactory.subscriptionsUpdateInstance(id, subscriptionUpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.subscriptionsUpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param subscriptionUpdateRequest Subscription representation
     */
    public subscriptionsUpdateInstance(id: string, subscriptionUpdateRequest: SubscriptionUpdateRequest, _options?: Configuration): Observable<SubscriptionResponse> {
        return this.subscriptionsUpdateInstanceWithHttpInfo(id, subscriptionUpdateRequest, _options).pipe(map((apiResponse: HttpInfo<SubscriptionResponse>) => apiResponse.data));
    }

}

import { TerritoriesApiRequestFactory, TerritoriesApiResponseProcessor} from "../apis/TerritoriesApi.ts";
export class ObservableTerritoriesApi {
    private requestFactory: TerritoriesApiRequestFactory;
    private responseProcessor: TerritoriesApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: TerritoriesApiRequestFactory,
        responseProcessor?: TerritoriesApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new TerritoriesApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new TerritoriesApiResponseProcessor();
    }

    /**
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limit maximum resources per page
     */
    public territoriesGetCollectionWithHttpInfo(fieldsTerritories?: Array<'currency'>, limit?: number, _options?: Configuration): Observable<HttpInfo<TerritoriesResponse>> {
        const requestContextPromise = this.requestFactory.territoriesGetCollection(fieldsTerritories, limit, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.territoriesGetCollectionWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limit maximum resources per page
     */
    public territoriesGetCollection(fieldsTerritories?: Array<'currency'>, limit?: number, _options?: Configuration): Observable<TerritoriesResponse> {
        return this.territoriesGetCollectionWithHttpInfo(fieldsTerritories, limit, _options).pipe(map((apiResponse: HttpInfo<TerritoriesResponse>) => apiResponse.data));
    }

}

import { TerritoryAvailabilitiesApiRequestFactory, TerritoryAvailabilitiesApiResponseProcessor} from "../apis/TerritoryAvailabilitiesApi.ts";
export class ObservableTerritoryAvailabilitiesApi {
    private requestFactory: TerritoryAvailabilitiesApiRequestFactory;
    private responseProcessor: TerritoryAvailabilitiesApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: TerritoryAvailabilitiesApiRequestFactory,
        responseProcessor?: TerritoryAvailabilitiesApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new TerritoryAvailabilitiesApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new TerritoryAvailabilitiesApiResponseProcessor();
    }

    /**
     * @param id the id of the requested resource
     * @param territoryAvailabilityUpdateRequest TerritoryAvailability representation
     */
    public territoryAvailabilitiesUpdateInstanceWithHttpInfo(id: string, territoryAvailabilityUpdateRequest: TerritoryAvailabilityUpdateRequest, _options?: Configuration): Observable<HttpInfo<TerritoryAvailabilityResponse>> {
        const requestContextPromise = this.requestFactory.territoryAvailabilitiesUpdateInstance(id, territoryAvailabilityUpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.territoryAvailabilitiesUpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param territoryAvailabilityUpdateRequest TerritoryAvailability representation
     */
    public territoryAvailabilitiesUpdateInstance(id: string, territoryAvailabilityUpdateRequest: TerritoryAvailabilityUpdateRequest, _options?: Configuration): Observable<TerritoryAvailabilityResponse> {
        return this.territoryAvailabilitiesUpdateInstanceWithHttpInfo(id, territoryAvailabilityUpdateRequest, _options).pipe(map((apiResponse: HttpInfo<TerritoryAvailabilityResponse>) => apiResponse.data));
    }

}

import { UserInvitationsApiRequestFactory, UserInvitationsApiResponseProcessor} from "../apis/UserInvitationsApi.ts";
export class ObservableUserInvitationsApi {
    private requestFactory: UserInvitationsApiRequestFactory;
    private responseProcessor: UserInvitationsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: UserInvitationsApiRequestFactory,
        responseProcessor?: UserInvitationsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new UserInvitationsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new UserInvitationsApiResponseProcessor();
    }

    /**
     * @param userInvitationCreateRequest UserInvitation representation
     */
    public userInvitationsCreateInstanceWithHttpInfo(userInvitationCreateRequest: UserInvitationCreateRequest, _options?: Configuration): Observable<HttpInfo<UserInvitationResponse>> {
        const requestContextPromise = this.requestFactory.userInvitationsCreateInstance(userInvitationCreateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.userInvitationsCreateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param userInvitationCreateRequest UserInvitation representation
     */
    public userInvitationsCreateInstance(userInvitationCreateRequest: UserInvitationCreateRequest, _options?: Configuration): Observable<UserInvitationResponse> {
        return this.userInvitationsCreateInstanceWithHttpInfo(userInvitationCreateRequest, _options).pipe(map((apiResponse: HttpInfo<UserInvitationResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     */
    public userInvitationsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.userInvitationsDeleteInstance(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.userInvitationsDeleteInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public userInvitationsDeleteInstance(id: string, _options?: Configuration): Observable<void> {
        return this.userInvitationsDeleteInstanceWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param filterEmail filter by attribute \&#39;email\&#39;
     * @param filterRoles filter by attribute \&#39;roles\&#39;
     * @param filterVisibleApps filter by id(s) of related \&#39;visibleApps\&#39;
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsUserInvitations the fields to include for returned resources of type userInvitations
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param limitVisibleApps maximum number of related visibleApps returned (when they are included)
     */
    public userInvitationsGetCollectionWithHttpInfo(filterEmail?: Array<string>, filterRoles?: Array<'ADMIN' | 'FINANCE' | 'ACCOUNT_HOLDER' | 'SALES' | 'MARKETING' | 'APP_MANAGER' | 'DEVELOPER' | 'ACCESS_TO_REPORTS' | 'CUSTOMER_SUPPORT' | 'IMAGE_MANAGER' | 'CREATE_APPS' | 'CLOUD_MANAGED_DEVELOPER_ID' | 'CLOUD_MANAGED_APP_DISTRIBUTION' | 'GENERATE_INDIVIDUAL_KEYS'>, filterVisibleApps?: Array<string>, sort?: Array<'email' | '-email' | 'lastName' | '-lastName'>, fieldsUserInvitations?: Array<'allAppsVisible' | 'email' | 'expirationDate' | 'firstName' | 'lastName' | 'provisioningAllowed' | 'roles' | 'visibleApps'>, limit?: number, include?: Array<'visibleApps'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, limitVisibleApps?: number, _options?: Configuration): Observable<HttpInfo<UserInvitationsResponse>> {
        const requestContextPromise = this.requestFactory.userInvitationsGetCollection(filterEmail, filterRoles, filterVisibleApps, sort, fieldsUserInvitations, limit, include, fieldsApps, limitVisibleApps, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.userInvitationsGetCollectionWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param filterEmail filter by attribute \&#39;email\&#39;
     * @param filterRoles filter by attribute \&#39;roles\&#39;
     * @param filterVisibleApps filter by id(s) of related \&#39;visibleApps\&#39;
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsUserInvitations the fields to include for returned resources of type userInvitations
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param limitVisibleApps maximum number of related visibleApps returned (when they are included)
     */
    public userInvitationsGetCollection(filterEmail?: Array<string>, filterRoles?: Array<'ADMIN' | 'FINANCE' | 'ACCOUNT_HOLDER' | 'SALES' | 'MARKETING' | 'APP_MANAGER' | 'DEVELOPER' | 'ACCESS_TO_REPORTS' | 'CUSTOMER_SUPPORT' | 'IMAGE_MANAGER' | 'CREATE_APPS' | 'CLOUD_MANAGED_DEVELOPER_ID' | 'CLOUD_MANAGED_APP_DISTRIBUTION' | 'GENERATE_INDIVIDUAL_KEYS'>, filterVisibleApps?: Array<string>, sort?: Array<'email' | '-email' | 'lastName' | '-lastName'>, fieldsUserInvitations?: Array<'allAppsVisible' | 'email' | 'expirationDate' | 'firstName' | 'lastName' | 'provisioningAllowed' | 'roles' | 'visibleApps'>, limit?: number, include?: Array<'visibleApps'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, limitVisibleApps?: number, _options?: Configuration): Observable<UserInvitationsResponse> {
        return this.userInvitationsGetCollectionWithHttpInfo(filterEmail, filterRoles, filterVisibleApps, sort, fieldsUserInvitations, limit, include, fieldsApps, limitVisibleApps, _options).pipe(map((apiResponse: HttpInfo<UserInvitationsResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsUserInvitations the fields to include for returned resources of type userInvitations
     * @param include comma-separated list of relationships to include
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param limitVisibleApps maximum number of related visibleApps returned (when they are included)
     */
    public userInvitationsGetInstanceWithHttpInfo(id: string, fieldsUserInvitations?: Array<'allAppsVisible' | 'email' | 'expirationDate' | 'firstName' | 'lastName' | 'provisioningAllowed' | 'roles' | 'visibleApps'>, include?: Array<'visibleApps'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, limitVisibleApps?: number, _options?: Configuration): Observable<HttpInfo<UserInvitationResponse>> {
        const requestContextPromise = this.requestFactory.userInvitationsGetInstance(id, fieldsUserInvitations, include, fieldsApps, limitVisibleApps, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.userInvitationsGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsUserInvitations the fields to include for returned resources of type userInvitations
     * @param include comma-separated list of relationships to include
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param limitVisibleApps maximum number of related visibleApps returned (when they are included)
     */
    public userInvitationsGetInstance(id: string, fieldsUserInvitations?: Array<'allAppsVisible' | 'email' | 'expirationDate' | 'firstName' | 'lastName' | 'provisioningAllowed' | 'roles' | 'visibleApps'>, include?: Array<'visibleApps'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, limitVisibleApps?: number, _options?: Configuration): Observable<UserInvitationResponse> {
        return this.userInvitationsGetInstanceWithHttpInfo(id, fieldsUserInvitations, include, fieldsApps, limitVisibleApps, _options).pipe(map((apiResponse: HttpInfo<UserInvitationResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param limit maximum resources per page
     */
    public userInvitationsVisibleAppsGetToManyRelatedWithHttpInfo(id: string, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, limit?: number, _options?: Configuration): Observable<HttpInfo<AppsWithoutIncludesResponse>> {
        const requestContextPromise = this.requestFactory.userInvitationsVisibleAppsGetToManyRelated(id, fieldsApps, limit, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.userInvitationsVisibleAppsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param limit maximum resources per page
     */
    public userInvitationsVisibleAppsGetToManyRelated(id: string, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, limit?: number, _options?: Configuration): Observable<AppsWithoutIncludesResponse> {
        return this.userInvitationsVisibleAppsGetToManyRelatedWithHttpInfo(id, fieldsApps, limit, _options).pipe(map((apiResponse: HttpInfo<AppsWithoutIncludesResponse>) => apiResponse.data));
    }

}

import { UsersApiRequestFactory, UsersApiResponseProcessor} from "../apis/UsersApi.ts";
export class ObservableUsersApi {
    private requestFactory: UsersApiRequestFactory;
    private responseProcessor: UsersApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: UsersApiRequestFactory,
        responseProcessor?: UsersApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new UsersApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new UsersApiResponseProcessor();
    }

    /**
     * @param id the id of the requested resource
     */
    public usersDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.usersDeleteInstance(id, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.usersDeleteInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     */
    public usersDeleteInstance(id: string, _options?: Configuration): Observable<void> {
        return this.usersDeleteInstanceWithHttpInfo(id, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param filterRoles filter by attribute \&#39;roles\&#39;
     * @param filterUsername filter by attribute \&#39;username\&#39;
     * @param filterVisibleApps filter by id(s) of related \&#39;visibleApps\&#39;
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsUsers the fields to include for returned resources of type users
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param limitVisibleApps maximum number of related visibleApps returned (when they are included)
     */
    public usersGetCollectionWithHttpInfo(filterRoles?: Array<'ADMIN' | 'FINANCE' | 'ACCOUNT_HOLDER' | 'SALES' | 'MARKETING' | 'APP_MANAGER' | 'DEVELOPER' | 'ACCESS_TO_REPORTS' | 'CUSTOMER_SUPPORT' | 'IMAGE_MANAGER' | 'CREATE_APPS' | 'CLOUD_MANAGED_DEVELOPER_ID' | 'CLOUD_MANAGED_APP_DISTRIBUTION' | 'GENERATE_INDIVIDUAL_KEYS'>, filterUsername?: Array<string>, filterVisibleApps?: Array<string>, sort?: Array<'lastName' | '-lastName' | 'username' | '-username'>, fieldsUsers?: Array<'allAppsVisible' | 'firstName' | 'lastName' | 'provisioningAllowed' | 'roles' | 'username' | 'visibleApps'>, limit?: number, include?: Array<'visibleApps'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, limitVisibleApps?: number, _options?: Configuration): Observable<HttpInfo<UsersResponse>> {
        const requestContextPromise = this.requestFactory.usersGetCollection(filterRoles, filterUsername, filterVisibleApps, sort, fieldsUsers, limit, include, fieldsApps, limitVisibleApps, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.usersGetCollectionWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param filterRoles filter by attribute \&#39;roles\&#39;
     * @param filterUsername filter by attribute \&#39;username\&#39;
     * @param filterVisibleApps filter by id(s) of related \&#39;visibleApps\&#39;
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsUsers the fields to include for returned resources of type users
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param limitVisibleApps maximum number of related visibleApps returned (when they are included)
     */
    public usersGetCollection(filterRoles?: Array<'ADMIN' | 'FINANCE' | 'ACCOUNT_HOLDER' | 'SALES' | 'MARKETING' | 'APP_MANAGER' | 'DEVELOPER' | 'ACCESS_TO_REPORTS' | 'CUSTOMER_SUPPORT' | 'IMAGE_MANAGER' | 'CREATE_APPS' | 'CLOUD_MANAGED_DEVELOPER_ID' | 'CLOUD_MANAGED_APP_DISTRIBUTION' | 'GENERATE_INDIVIDUAL_KEYS'>, filterUsername?: Array<string>, filterVisibleApps?: Array<string>, sort?: Array<'lastName' | '-lastName' | 'username' | '-username'>, fieldsUsers?: Array<'allAppsVisible' | 'firstName' | 'lastName' | 'provisioningAllowed' | 'roles' | 'username' | 'visibleApps'>, limit?: number, include?: Array<'visibleApps'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, limitVisibleApps?: number, _options?: Configuration): Observable<UsersResponse> {
        return this.usersGetCollectionWithHttpInfo(filterRoles, filterUsername, filterVisibleApps, sort, fieldsUsers, limit, include, fieldsApps, limitVisibleApps, _options).pipe(map((apiResponse: HttpInfo<UsersResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsUsers the fields to include for returned resources of type users
     * @param include comma-separated list of relationships to include
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param limitVisibleApps maximum number of related visibleApps returned (when they are included)
     */
    public usersGetInstanceWithHttpInfo(id: string, fieldsUsers?: Array<'allAppsVisible' | 'firstName' | 'lastName' | 'provisioningAllowed' | 'roles' | 'username' | 'visibleApps'>, include?: Array<'visibleApps'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, limitVisibleApps?: number, _options?: Configuration): Observable<HttpInfo<UserResponse>> {
        const requestContextPromise = this.requestFactory.usersGetInstance(id, fieldsUsers, include, fieldsApps, limitVisibleApps, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.usersGetInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsUsers the fields to include for returned resources of type users
     * @param include comma-separated list of relationships to include
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param limitVisibleApps maximum number of related visibleApps returned (when they are included)
     */
    public usersGetInstance(id: string, fieldsUsers?: Array<'allAppsVisible' | 'firstName' | 'lastName' | 'provisioningAllowed' | 'roles' | 'username' | 'visibleApps'>, include?: Array<'visibleApps'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, limitVisibleApps?: number, _options?: Configuration): Observable<UserResponse> {
        return this.usersGetInstanceWithHttpInfo(id, fieldsUsers, include, fieldsApps, limitVisibleApps, _options).pipe(map((apiResponse: HttpInfo<UserResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param userUpdateRequest User representation
     */
    public usersUpdateInstanceWithHttpInfo(id: string, userUpdateRequest: UserUpdateRequest, _options?: Configuration): Observable<HttpInfo<UserResponse>> {
        const requestContextPromise = this.requestFactory.usersUpdateInstance(id, userUpdateRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.usersUpdateInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param userUpdateRequest User representation
     */
    public usersUpdateInstance(id: string, userUpdateRequest: UserUpdateRequest, _options?: Configuration): Observable<UserResponse> {
        return this.usersUpdateInstanceWithHttpInfo(id, userUpdateRequest, _options).pipe(map((apiResponse: HttpInfo<UserResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param userVisibleAppsLinkagesRequest List of related linkages
     */
    public usersVisibleAppsCreateToManyRelationshipWithHttpInfo(id: string, userVisibleAppsLinkagesRequest: UserVisibleAppsLinkagesRequest, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.usersVisibleAppsCreateToManyRelationship(id, userVisibleAppsLinkagesRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.usersVisibleAppsCreateToManyRelationshipWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param userVisibleAppsLinkagesRequest List of related linkages
     */
    public usersVisibleAppsCreateToManyRelationship(id: string, userVisibleAppsLinkagesRequest: UserVisibleAppsLinkagesRequest, _options?: Configuration): Observable<void> {
        return this.usersVisibleAppsCreateToManyRelationshipWithHttpInfo(id, userVisibleAppsLinkagesRequest, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param userVisibleAppsLinkagesRequest List of related linkages
     */
    public usersVisibleAppsDeleteToManyRelationshipWithHttpInfo(id: string, userVisibleAppsLinkagesRequest: UserVisibleAppsLinkagesRequest, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.usersVisibleAppsDeleteToManyRelationship(id, userVisibleAppsLinkagesRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.usersVisibleAppsDeleteToManyRelationshipWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param userVisibleAppsLinkagesRequest List of related linkages
     */
    public usersVisibleAppsDeleteToManyRelationship(id: string, userVisibleAppsLinkagesRequest: UserVisibleAppsLinkagesRequest, _options?: Configuration): Observable<void> {
        return this.usersVisibleAppsDeleteToManyRelationshipWithHttpInfo(id, userVisibleAppsLinkagesRequest, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param limit maximum resources per page
     */
    public usersVisibleAppsGetToManyRelatedWithHttpInfo(id: string, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, limit?: number, _options?: Configuration): Observable<HttpInfo<AppsWithoutIncludesResponse>> {
        const requestContextPromise = this.requestFactory.usersVisibleAppsGetToManyRelated(id, fieldsApps, limit, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.usersVisibleAppsGetToManyRelatedWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param limit maximum resources per page
     */
    public usersVisibleAppsGetToManyRelated(id: string, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, limit?: number, _options?: Configuration): Observable<AppsWithoutIncludesResponse> {
        return this.usersVisibleAppsGetToManyRelatedWithHttpInfo(id, fieldsApps, limit, _options).pipe(map((apiResponse: HttpInfo<AppsWithoutIncludesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public usersVisibleAppsGetToManyRelationshipWithHttpInfo(id: string, limit?: number, _options?: Configuration): Observable<HttpInfo<UserVisibleAppsLinkagesResponse>> {
        const requestContextPromise = this.requestFactory.usersVisibleAppsGetToManyRelationship(id, limit, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.usersVisibleAppsGetToManyRelationshipWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public usersVisibleAppsGetToManyRelationship(id: string, limit?: number, _options?: Configuration): Observable<UserVisibleAppsLinkagesResponse> {
        return this.usersVisibleAppsGetToManyRelationshipWithHttpInfo(id, limit, _options).pipe(map((apiResponse: HttpInfo<UserVisibleAppsLinkagesResponse>) => apiResponse.data));
    }

    /**
     * @param id the id of the requested resource
     * @param userVisibleAppsLinkagesRequest List of related linkages
     */
    public usersVisibleAppsReplaceToManyRelationshipWithHttpInfo(id: string, userVisibleAppsLinkagesRequest: UserVisibleAppsLinkagesRequest, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.usersVisibleAppsReplaceToManyRelationship(id, userVisibleAppsLinkagesRequest, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.usersVisibleAppsReplaceToManyRelationshipWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param id the id of the requested resource
     * @param userVisibleAppsLinkagesRequest List of related linkages
     */
    public usersVisibleAppsReplaceToManyRelationship(id: string, userVisibleAppsLinkagesRequest: UserVisibleAppsLinkagesRequest, _options?: Configuration): Observable<void> {
        return this.usersVisibleAppsReplaceToManyRelationshipWithHttpInfo(id, userVisibleAppsLinkagesRequest, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

}
