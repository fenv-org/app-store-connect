import { ResponseContext, RequestContext, HttpFile, HttpInfo } from '../http/http.ts';
import { Configuration} from '../configuration.ts'

import { Actor } from '../models/Actor.ts';
import { ActorAttributes } from '../models/ActorAttributes.ts';
import { ActorResponse } from '../models/ActorResponse.ts';
import { ActorsResponse } from '../models/ActorsResponse.ts';
import { AgeRatingDeclaration } from '../models/AgeRatingDeclaration.ts';
import { AgeRatingDeclarationAttributes } from '../models/AgeRatingDeclarationAttributes.ts';
import { AgeRatingDeclarationResponse } from '../models/AgeRatingDeclarationResponse.ts';
import { AgeRatingDeclarationUpdateRequest } from '../models/AgeRatingDeclarationUpdateRequest.ts';
import { AgeRatingDeclarationUpdateRequestData } from '../models/AgeRatingDeclarationUpdateRequestData.ts';
import { AgeRatingDeclarationWithoutIncludesResponse } from '../models/AgeRatingDeclarationWithoutIncludesResponse.ts';
import { AlternativeDistributionDomain } from '../models/AlternativeDistributionDomain.ts';
import { AlternativeDistributionDomainAttributes } from '../models/AlternativeDistributionDomainAttributes.ts';
import { AlternativeDistributionDomainCreateRequest } from '../models/AlternativeDistributionDomainCreateRequest.ts';
import { AlternativeDistributionDomainCreateRequestData } from '../models/AlternativeDistributionDomainCreateRequestData.ts';
import { AlternativeDistributionDomainCreateRequestDataAttributes } from '../models/AlternativeDistributionDomainCreateRequestDataAttributes.ts';
import { AlternativeDistributionDomainResponse } from '../models/AlternativeDistributionDomainResponse.ts';
import { AlternativeDistributionDomainsResponse } from '../models/AlternativeDistributionDomainsResponse.ts';
import { AlternativeDistributionKey } from '../models/AlternativeDistributionKey.ts';
import { AlternativeDistributionKeyAttributes } from '../models/AlternativeDistributionKeyAttributes.ts';
import { AlternativeDistributionKeyCreateRequest } from '../models/AlternativeDistributionKeyCreateRequest.ts';
import { AlternativeDistributionKeyCreateRequestData } from '../models/AlternativeDistributionKeyCreateRequestData.ts';
import { AlternativeDistributionKeyCreateRequestDataAttributes } from '../models/AlternativeDistributionKeyCreateRequestDataAttributes.ts';
import { AlternativeDistributionKeyCreateRequestDataRelationships } from '../models/AlternativeDistributionKeyCreateRequestDataRelationships.ts';
import { AlternativeDistributionKeyCreateRequestDataRelationshipsApp } from '../models/AlternativeDistributionKeyCreateRequestDataRelationshipsApp.ts';
import { AlternativeDistributionKeyCreateRequestDataRelationshipsAppData } from '../models/AlternativeDistributionKeyCreateRequestDataRelationshipsAppData.ts';
import { AlternativeDistributionKeyResponse } from '../models/AlternativeDistributionKeyResponse.ts';
import { AlternativeDistributionPackage } from '../models/AlternativeDistributionPackage.ts';
import { AlternativeDistributionPackageCreateRequest } from '../models/AlternativeDistributionPackageCreateRequest.ts';
import { AlternativeDistributionPackageCreateRequestData } from '../models/AlternativeDistributionPackageCreateRequestData.ts';
import { AlternativeDistributionPackageCreateRequestDataRelationships } from '../models/AlternativeDistributionPackageCreateRequestDataRelationships.ts';
import { AlternativeDistributionPackageCreateRequestDataRelationshipsAppStoreVersion } from '../models/AlternativeDistributionPackageCreateRequestDataRelationshipsAppStoreVersion.ts';
import { AlternativeDistributionPackageCreateRequestDataRelationshipsAppStoreVersionData } from '../models/AlternativeDistributionPackageCreateRequestDataRelationshipsAppStoreVersionData.ts';
import { AlternativeDistributionPackageDelta } from '../models/AlternativeDistributionPackageDelta.ts';
import { AlternativeDistributionPackageDeltaAttributes } from '../models/AlternativeDistributionPackageDeltaAttributes.ts';
import { AlternativeDistributionPackageDeltaResponse } from '../models/AlternativeDistributionPackageDeltaResponse.ts';
import { AlternativeDistributionPackageDeltasResponse } from '../models/AlternativeDistributionPackageDeltasResponse.ts';
import { AlternativeDistributionPackageRelationships } from '../models/AlternativeDistributionPackageRelationships.ts';
import { AlternativeDistributionPackageRelationshipsVersions } from '../models/AlternativeDistributionPackageRelationshipsVersions.ts';
import { AlternativeDistributionPackageRelationshipsVersionsDataInner } from '../models/AlternativeDistributionPackageRelationshipsVersionsDataInner.ts';
import { AlternativeDistributionPackageResponse } from '../models/AlternativeDistributionPackageResponse.ts';
import { AlternativeDistributionPackageVariant } from '../models/AlternativeDistributionPackageVariant.ts';
import { AlternativeDistributionPackageVariantResponse } from '../models/AlternativeDistributionPackageVariantResponse.ts';
import { AlternativeDistributionPackageVariantsResponse } from '../models/AlternativeDistributionPackageVariantsResponse.ts';
import { AlternativeDistributionPackageVersion } from '../models/AlternativeDistributionPackageVersion.ts';
import { AlternativeDistributionPackageVersionAttributes } from '../models/AlternativeDistributionPackageVersionAttributes.ts';
import { AlternativeDistributionPackageVersionRelationships } from '../models/AlternativeDistributionPackageVersionRelationships.ts';
import { AlternativeDistributionPackageVersionRelationshipsAlternativeDistributionPackage } from '../models/AlternativeDistributionPackageVersionRelationshipsAlternativeDistributionPackage.ts';
import { AlternativeDistributionPackageVersionRelationshipsAlternativeDistributionPackageData } from '../models/AlternativeDistributionPackageVersionRelationshipsAlternativeDistributionPackageData.ts';
import { AlternativeDistributionPackageVersionRelationshipsDeltas } from '../models/AlternativeDistributionPackageVersionRelationshipsDeltas.ts';
import { AlternativeDistributionPackageVersionRelationshipsDeltasDataInner } from '../models/AlternativeDistributionPackageVersionRelationshipsDeltasDataInner.ts';
import { AlternativeDistributionPackageVersionRelationshipsVariants } from '../models/AlternativeDistributionPackageVersionRelationshipsVariants.ts';
import { AlternativeDistributionPackageVersionRelationshipsVariantsDataInner } from '../models/AlternativeDistributionPackageVersionRelationshipsVariantsDataInner.ts';
import { AlternativeDistributionPackageVersionRelationshipsVariantsLinks } from '../models/AlternativeDistributionPackageVersionRelationshipsVariantsLinks.ts';
import { AlternativeDistributionPackageVersionResponse } from '../models/AlternativeDistributionPackageVersionResponse.ts';
import { AlternativeDistributionPackageVersionsResponse } from '../models/AlternativeDistributionPackageVersionsResponse.ts';
import { AlternativeDistributionPackageVersionsResponseIncludedInner } from '../models/AlternativeDistributionPackageVersionsResponseIncludedInner.ts';
import { AnalyticsReport } from '../models/AnalyticsReport.ts';
import { AnalyticsReportAttributes } from '../models/AnalyticsReportAttributes.ts';
import { AnalyticsReportInstance } from '../models/AnalyticsReportInstance.ts';
import { AnalyticsReportInstanceAttributes } from '../models/AnalyticsReportInstanceAttributes.ts';
import { AnalyticsReportInstanceResponse } from '../models/AnalyticsReportInstanceResponse.ts';
import { AnalyticsReportInstancesResponse } from '../models/AnalyticsReportInstancesResponse.ts';
import { AnalyticsReportRequest } from '../models/AnalyticsReportRequest.ts';
import { AnalyticsReportRequestAttributes } from '../models/AnalyticsReportRequestAttributes.ts';
import { AnalyticsReportRequestCreateRequest } from '../models/AnalyticsReportRequestCreateRequest.ts';
import { AnalyticsReportRequestCreateRequestData } from '../models/AnalyticsReportRequestCreateRequestData.ts';
import { AnalyticsReportRequestCreateRequestDataAttributes } from '../models/AnalyticsReportRequestCreateRequestDataAttributes.ts';
import { AnalyticsReportRequestRelationships } from '../models/AnalyticsReportRequestRelationships.ts';
import { AnalyticsReportRequestRelationshipsReports } from '../models/AnalyticsReportRequestRelationshipsReports.ts';
import { AnalyticsReportRequestRelationshipsReportsDataInner } from '../models/AnalyticsReportRequestRelationshipsReportsDataInner.ts';
import { AnalyticsReportRequestResponse } from '../models/AnalyticsReportRequestResponse.ts';
import { AnalyticsReportRequestsResponse } from '../models/AnalyticsReportRequestsResponse.ts';
import { AnalyticsReportResponse } from '../models/AnalyticsReportResponse.ts';
import { AnalyticsReportSegment } from '../models/AnalyticsReportSegment.ts';
import { AnalyticsReportSegmentAttributes } from '../models/AnalyticsReportSegmentAttributes.ts';
import { AnalyticsReportSegmentResponse } from '../models/AnalyticsReportSegmentResponse.ts';
import { AnalyticsReportSegmentsResponse } from '../models/AnalyticsReportSegmentsResponse.ts';
import { AnalyticsReportsResponse } from '../models/AnalyticsReportsResponse.ts';
import { App } from '../models/App.ts';
import { AppAttributes } from '../models/AppAttributes.ts';
import { AppAvailability } from '../models/AppAvailability.ts';
import { AppAvailabilityCreateRequest } from '../models/AppAvailabilityCreateRequest.ts';
import { AppAvailabilityCreateRequestData } from '../models/AppAvailabilityCreateRequestData.ts';
import { AppAvailabilityCreateRequestDataRelationships } from '../models/AppAvailabilityCreateRequestDataRelationships.ts';
import { AppAvailabilityCreateRequestDataRelationshipsAvailableTerritories } from '../models/AppAvailabilityCreateRequestDataRelationshipsAvailableTerritories.ts';
import { AppAvailabilityRelationships } from '../models/AppAvailabilityRelationships.ts';
import { AppAvailabilityRelationshipsApp } from '../models/AppAvailabilityRelationshipsApp.ts';
import { AppAvailabilityRelationshipsAvailableTerritories } from '../models/AppAvailabilityRelationshipsAvailableTerritories.ts';
import { AppAvailabilityRelationshipsAvailableTerritoriesDataInner } from '../models/AppAvailabilityRelationshipsAvailableTerritoriesDataInner.ts';
import { AppAvailabilityResponse } from '../models/AppAvailabilityResponse.ts';
import { AppAvailabilityResponseIncludedInner } from '../models/AppAvailabilityResponseIncludedInner.ts';
import { AppAvailabilityV2 } from '../models/AppAvailabilityV2.ts';
import { AppAvailabilityV2Attributes } from '../models/AppAvailabilityV2Attributes.ts';
import { AppAvailabilityV2CreateRequest } from '../models/AppAvailabilityV2CreateRequest.ts';
import { AppAvailabilityV2CreateRequestData } from '../models/AppAvailabilityV2CreateRequestData.ts';
import { AppAvailabilityV2CreateRequestDataAttributes } from '../models/AppAvailabilityV2CreateRequestDataAttributes.ts';
import { AppAvailabilityV2CreateRequestDataRelationships } from '../models/AppAvailabilityV2CreateRequestDataRelationships.ts';
import { AppAvailabilityV2CreateRequestDataRelationshipsTerritoryAvailabilities } from '../models/AppAvailabilityV2CreateRequestDataRelationshipsTerritoryAvailabilities.ts';
import { AppAvailabilityV2Relationships } from '../models/AppAvailabilityV2Relationships.ts';
import { AppAvailabilityV2RelationshipsTerritoryAvailabilities } from '../models/AppAvailabilityV2RelationshipsTerritoryAvailabilities.ts';
import { AppAvailabilityV2RelationshipsTerritoryAvailabilitiesDataInner } from '../models/AppAvailabilityV2RelationshipsTerritoryAvailabilitiesDataInner.ts';
import { AppAvailabilityV2Response } from '../models/AppAvailabilityV2Response.ts';
import { AppBetaTestersLinkagesRequest } from '../models/AppBetaTestersLinkagesRequest.ts';
import { AppCategoriesResponse } from '../models/AppCategoriesResponse.ts';
import { AppCategoriesWithoutIncludesResponse } from '../models/AppCategoriesWithoutIncludesResponse.ts';
import { AppCategory } from '../models/AppCategory.ts';
import { AppCategoryAttributes } from '../models/AppCategoryAttributes.ts';
import { AppCategoryRelationships } from '../models/AppCategoryRelationships.ts';
import { AppCategoryRelationshipsParent } from '../models/AppCategoryRelationshipsParent.ts';
import { AppCategoryRelationshipsSubcategories } from '../models/AppCategoryRelationshipsSubcategories.ts';
import { AppCategoryRelationshipsSubcategoriesDataInner } from '../models/AppCategoryRelationshipsSubcategoriesDataInner.ts';
import { AppCategoryResponse } from '../models/AppCategoryResponse.ts';
import { AppCategoryWithoutIncludesResponse } from '../models/AppCategoryWithoutIncludesResponse.ts';
import { AppClip } from '../models/AppClip.ts';
import { AppClipAction } from '../models/AppClipAction.ts';
import { AppClipAdvancedExperience } from '../models/AppClipAdvancedExperience.ts';
import { AppClipAdvancedExperienceAttributes } from '../models/AppClipAdvancedExperienceAttributes.ts';
import { AppClipAdvancedExperienceAttributesPlace } from '../models/AppClipAdvancedExperienceAttributesPlace.ts';
import { AppClipAdvancedExperienceAttributesPlaceDisplayPoint } from '../models/AppClipAdvancedExperienceAttributesPlaceDisplayPoint.ts';
import { AppClipAdvancedExperienceAttributesPlaceDisplayPointCoordinates } from '../models/AppClipAdvancedExperienceAttributesPlaceDisplayPointCoordinates.ts';
import { AppClipAdvancedExperienceAttributesPlaceMainAddress } from '../models/AppClipAdvancedExperienceAttributesPlaceMainAddress.ts';
import { AppClipAdvancedExperienceAttributesPlaceMainAddressStructuredAddress } from '../models/AppClipAdvancedExperienceAttributesPlaceMainAddressStructuredAddress.ts';
import { AppClipAdvancedExperienceAttributesPlacePhoneNumber } from '../models/AppClipAdvancedExperienceAttributesPlacePhoneNumber.ts';
import { AppClipAdvancedExperienceCreateRequest } from '../models/AppClipAdvancedExperienceCreateRequest.ts';
import { AppClipAdvancedExperienceCreateRequestData } from '../models/AppClipAdvancedExperienceCreateRequestData.ts';
import { AppClipAdvancedExperienceCreateRequestDataAttributes } from '../models/AppClipAdvancedExperienceCreateRequestDataAttributes.ts';
import { AppClipAdvancedExperienceCreateRequestDataRelationships } from '../models/AppClipAdvancedExperienceCreateRequestDataRelationships.ts';
import { AppClipAdvancedExperienceCreateRequestDataRelationshipsAppClip } from '../models/AppClipAdvancedExperienceCreateRequestDataRelationshipsAppClip.ts';
import { AppClipAdvancedExperienceCreateRequestDataRelationshipsHeaderImage } from '../models/AppClipAdvancedExperienceCreateRequestDataRelationshipsHeaderImage.ts';
import { AppClipAdvancedExperienceCreateRequestDataRelationshipsLocalizations } from '../models/AppClipAdvancedExperienceCreateRequestDataRelationshipsLocalizations.ts';
import { AppClipAdvancedExperienceImage } from '../models/AppClipAdvancedExperienceImage.ts';
import { AppClipAdvancedExperienceImageAttributes } from '../models/AppClipAdvancedExperienceImageAttributes.ts';
import { AppClipAdvancedExperienceImageCreateRequest } from '../models/AppClipAdvancedExperienceImageCreateRequest.ts';
import { AppClipAdvancedExperienceImageCreateRequestData } from '../models/AppClipAdvancedExperienceImageCreateRequestData.ts';
import { AppClipAdvancedExperienceImageCreateRequestDataAttributes } from '../models/AppClipAdvancedExperienceImageCreateRequestDataAttributes.ts';
import { AppClipAdvancedExperienceImageResponse } from '../models/AppClipAdvancedExperienceImageResponse.ts';
import { AppClipAdvancedExperienceImageUpdateRequest } from '../models/AppClipAdvancedExperienceImageUpdateRequest.ts';
import { AppClipAdvancedExperienceImageUpdateRequestData } from '../models/AppClipAdvancedExperienceImageUpdateRequestData.ts';
import { AppClipAdvancedExperienceImageUpdateRequestDataAttributes } from '../models/AppClipAdvancedExperienceImageUpdateRequestDataAttributes.ts';
import { AppClipAdvancedExperienceLanguage } from '../models/AppClipAdvancedExperienceLanguage.ts';
import { AppClipAdvancedExperienceLocalization } from '../models/AppClipAdvancedExperienceLocalization.ts';
import { AppClipAdvancedExperienceLocalizationAttributes } from '../models/AppClipAdvancedExperienceLocalizationAttributes.ts';
import { AppClipAdvancedExperienceLocalizationInlineCreate } from '../models/AppClipAdvancedExperienceLocalizationInlineCreate.ts';
import { AppClipAdvancedExperienceRelationships } from '../models/AppClipAdvancedExperienceRelationships.ts';
import { AppClipAdvancedExperienceRelationshipsAppClip } from '../models/AppClipAdvancedExperienceRelationshipsAppClip.ts';
import { AppClipAdvancedExperienceRelationshipsAppClipData } from '../models/AppClipAdvancedExperienceRelationshipsAppClipData.ts';
import { AppClipAdvancedExperienceRelationshipsHeaderImage } from '../models/AppClipAdvancedExperienceRelationshipsHeaderImage.ts';
import { AppClipAdvancedExperienceRelationshipsHeaderImageData } from '../models/AppClipAdvancedExperienceRelationshipsHeaderImageData.ts';
import { AppClipAdvancedExperienceRelationshipsLocalizations } from '../models/AppClipAdvancedExperienceRelationshipsLocalizations.ts';
import { AppClipAdvancedExperienceRelationshipsLocalizationsDataInner } from '../models/AppClipAdvancedExperienceRelationshipsLocalizationsDataInner.ts';
import { AppClipAdvancedExperienceResponse } from '../models/AppClipAdvancedExperienceResponse.ts';
import { AppClipAdvancedExperienceUpdateRequest } from '../models/AppClipAdvancedExperienceUpdateRequest.ts';
import { AppClipAdvancedExperienceUpdateRequestData } from '../models/AppClipAdvancedExperienceUpdateRequestData.ts';
import { AppClipAdvancedExperienceUpdateRequestDataAttributes } from '../models/AppClipAdvancedExperienceUpdateRequestDataAttributes.ts';
import { AppClipAdvancedExperienceUpdateRequestDataRelationships } from '../models/AppClipAdvancedExperienceUpdateRequestDataRelationships.ts';
import { AppClipAdvancedExperienceUpdateRequestDataRelationshipsAppClip } from '../models/AppClipAdvancedExperienceUpdateRequestDataRelationshipsAppClip.ts';
import { AppClipAdvancedExperienceUpdateRequestDataRelationshipsHeaderImage } from '../models/AppClipAdvancedExperienceUpdateRequestDataRelationshipsHeaderImage.ts';
import { AppClipAdvancedExperienceUpdateRequestDataRelationshipsLocalizations } from '../models/AppClipAdvancedExperienceUpdateRequestDataRelationshipsLocalizations.ts';
import { AppClipAdvancedExperiencesResponse } from '../models/AppClipAdvancedExperiencesResponse.ts';
import { AppClipAdvancedExperiencesResponseIncludedInner } from '../models/AppClipAdvancedExperiencesResponseIncludedInner.ts';
import { AppClipAppStoreReviewDetail } from '../models/AppClipAppStoreReviewDetail.ts';
import { AppClipAppStoreReviewDetailAttributes } from '../models/AppClipAppStoreReviewDetailAttributes.ts';
import { AppClipAppStoreReviewDetailCreateRequest } from '../models/AppClipAppStoreReviewDetailCreateRequest.ts';
import { AppClipAppStoreReviewDetailCreateRequestData } from '../models/AppClipAppStoreReviewDetailCreateRequestData.ts';
import { AppClipAppStoreReviewDetailCreateRequestDataRelationships } from '../models/AppClipAppStoreReviewDetailCreateRequestDataRelationships.ts';
import { AppClipAppStoreReviewDetailCreateRequestDataRelationshipsAppClipDefaultExperience } from '../models/AppClipAppStoreReviewDetailCreateRequestDataRelationshipsAppClipDefaultExperience.ts';
import { AppClipAppStoreReviewDetailRelationships } from '../models/AppClipAppStoreReviewDetailRelationships.ts';
import { AppClipAppStoreReviewDetailRelationshipsAppClipDefaultExperience } from '../models/AppClipAppStoreReviewDetailRelationshipsAppClipDefaultExperience.ts';
import { AppClipAppStoreReviewDetailRelationshipsAppClipDefaultExperienceData } from '../models/AppClipAppStoreReviewDetailRelationshipsAppClipDefaultExperienceData.ts';
import { AppClipAppStoreReviewDetailResponse } from '../models/AppClipAppStoreReviewDetailResponse.ts';
import { AppClipAppStoreReviewDetailUpdateRequest } from '../models/AppClipAppStoreReviewDetailUpdateRequest.ts';
import { AppClipAppStoreReviewDetailUpdateRequestData } from '../models/AppClipAppStoreReviewDetailUpdateRequestData.ts';
import { AppClipAttributes } from '../models/AppClipAttributes.ts';
import { AppClipDefaultExperience } from '../models/AppClipDefaultExperience.ts';
import { AppClipDefaultExperienceAttributes } from '../models/AppClipDefaultExperienceAttributes.ts';
import { AppClipDefaultExperienceCreateRequest } from '../models/AppClipDefaultExperienceCreateRequest.ts';
import { AppClipDefaultExperienceCreateRequestData } from '../models/AppClipDefaultExperienceCreateRequestData.ts';
import { AppClipDefaultExperienceCreateRequestDataRelationships } from '../models/AppClipDefaultExperienceCreateRequestDataRelationships.ts';
import { AppClipDefaultExperienceCreateRequestDataRelationshipsAppClipDefaultExperienceTemplate } from '../models/AppClipDefaultExperienceCreateRequestDataRelationshipsAppClipDefaultExperienceTemplate.ts';
import { AppClipDefaultExperienceCreateRequestDataRelationshipsReleaseWithAppStoreVersion } from '../models/AppClipDefaultExperienceCreateRequestDataRelationshipsReleaseWithAppStoreVersion.ts';
import { AppClipDefaultExperienceLocalization } from '../models/AppClipDefaultExperienceLocalization.ts';
import { AppClipDefaultExperienceLocalizationAttributes } from '../models/AppClipDefaultExperienceLocalizationAttributes.ts';
import { AppClipDefaultExperienceLocalizationCreateRequest } from '../models/AppClipDefaultExperienceLocalizationCreateRequest.ts';
import { AppClipDefaultExperienceLocalizationCreateRequestData } from '../models/AppClipDefaultExperienceLocalizationCreateRequestData.ts';
import { AppClipDefaultExperienceLocalizationCreateRequestDataAttributes } from '../models/AppClipDefaultExperienceLocalizationCreateRequestDataAttributes.ts';
import { AppClipDefaultExperienceLocalizationRelationships } from '../models/AppClipDefaultExperienceLocalizationRelationships.ts';
import { AppClipDefaultExperienceLocalizationRelationshipsAppClipHeaderImage } from '../models/AppClipDefaultExperienceLocalizationRelationshipsAppClipHeaderImage.ts';
import { AppClipDefaultExperienceLocalizationRelationshipsAppClipHeaderImageData } from '../models/AppClipDefaultExperienceLocalizationRelationshipsAppClipHeaderImageData.ts';
import { AppClipDefaultExperienceLocalizationResponse } from '../models/AppClipDefaultExperienceLocalizationResponse.ts';
import { AppClipDefaultExperienceLocalizationUpdateRequest } from '../models/AppClipDefaultExperienceLocalizationUpdateRequest.ts';
import { AppClipDefaultExperienceLocalizationUpdateRequestData } from '../models/AppClipDefaultExperienceLocalizationUpdateRequestData.ts';
import { AppClipDefaultExperienceLocalizationUpdateRequestDataAttributes } from '../models/AppClipDefaultExperienceLocalizationUpdateRequestDataAttributes.ts';
import { AppClipDefaultExperienceLocalizationsResponse } from '../models/AppClipDefaultExperienceLocalizationsResponse.ts';
import { AppClipDefaultExperienceLocalizationsResponseIncludedInner } from '../models/AppClipDefaultExperienceLocalizationsResponseIncludedInner.ts';
import { AppClipDefaultExperienceRelationships } from '../models/AppClipDefaultExperienceRelationships.ts';
import { AppClipDefaultExperienceRelationshipsAppClipAppStoreReviewDetail } from '../models/AppClipDefaultExperienceRelationshipsAppClipAppStoreReviewDetail.ts';
import { AppClipDefaultExperienceRelationshipsAppClipAppStoreReviewDetailData } from '../models/AppClipDefaultExperienceRelationshipsAppClipAppStoreReviewDetailData.ts';
import { AppClipDefaultExperienceRelationshipsAppClipDefaultExperienceLocalizations } from '../models/AppClipDefaultExperienceRelationshipsAppClipDefaultExperienceLocalizations.ts';
import { AppClipDefaultExperienceRelationshipsAppClipDefaultExperienceLocalizationsDataInner } from '../models/AppClipDefaultExperienceRelationshipsAppClipDefaultExperienceLocalizationsDataInner.ts';
import { AppClipDefaultExperienceRelationshipsReleaseWithAppStoreVersion } from '../models/AppClipDefaultExperienceRelationshipsReleaseWithAppStoreVersion.ts';
import { AppClipDefaultExperienceReleaseWithAppStoreVersionLinkageRequest } from '../models/AppClipDefaultExperienceReleaseWithAppStoreVersionLinkageRequest.ts';
import { AppClipDefaultExperienceReleaseWithAppStoreVersionLinkageResponse } from '../models/AppClipDefaultExperienceReleaseWithAppStoreVersionLinkageResponse.ts';
import { AppClipDefaultExperienceResponse } from '../models/AppClipDefaultExperienceResponse.ts';
import { AppClipDefaultExperienceUpdateRequest } from '../models/AppClipDefaultExperienceUpdateRequest.ts';
import { AppClipDefaultExperienceUpdateRequestData } from '../models/AppClipDefaultExperienceUpdateRequestData.ts';
import { AppClipDefaultExperienceUpdateRequestDataRelationships } from '../models/AppClipDefaultExperienceUpdateRequestDataRelationships.ts';
import { AppClipDefaultExperiencesResponse } from '../models/AppClipDefaultExperiencesResponse.ts';
import { AppClipDefaultExperiencesResponseIncludedInner } from '../models/AppClipDefaultExperiencesResponseIncludedInner.ts';
import { AppClipDomainStatus } from '../models/AppClipDomainStatus.ts';
import { AppClipDomainStatusAttributes } from '../models/AppClipDomainStatusAttributes.ts';
import { AppClipDomainStatusAttributesDomainsInner } from '../models/AppClipDomainStatusAttributesDomainsInner.ts';
import { AppClipDomainStatusResponse } from '../models/AppClipDomainStatusResponse.ts';
import { AppClipHeaderImage } from '../models/AppClipHeaderImage.ts';
import { AppClipHeaderImageCreateRequest } from '../models/AppClipHeaderImageCreateRequest.ts';
import { AppClipHeaderImageCreateRequestData } from '../models/AppClipHeaderImageCreateRequestData.ts';
import { AppClipHeaderImageCreateRequestDataRelationships } from '../models/AppClipHeaderImageCreateRequestDataRelationships.ts';
import { AppClipHeaderImageCreateRequestDataRelationshipsAppClipDefaultExperienceLocalization } from '../models/AppClipHeaderImageCreateRequestDataRelationshipsAppClipDefaultExperienceLocalization.ts';
import { AppClipHeaderImageRelationships } from '../models/AppClipHeaderImageRelationships.ts';
import { AppClipHeaderImageRelationshipsAppClipDefaultExperienceLocalization } from '../models/AppClipHeaderImageRelationshipsAppClipDefaultExperienceLocalization.ts';
import { AppClipHeaderImageResponse } from '../models/AppClipHeaderImageResponse.ts';
import { AppClipHeaderImageUpdateRequest } from '../models/AppClipHeaderImageUpdateRequest.ts';
import { AppClipHeaderImageUpdateRequestData } from '../models/AppClipHeaderImageUpdateRequestData.ts';
import { AppClipRelationships } from '../models/AppClipRelationships.ts';
import { AppClipRelationshipsAppClipDefaultExperiences } from '../models/AppClipRelationshipsAppClipDefaultExperiences.ts';
import { AppClipResponse } from '../models/AppClipResponse.ts';
import { AppClipsResponse } from '../models/AppClipsResponse.ts';
import { AppClipsResponseIncludedInner } from '../models/AppClipsResponseIncludedInner.ts';
import { AppCustomProductPage } from '../models/AppCustomProductPage.ts';
import { AppCustomProductPageAttributes } from '../models/AppCustomProductPageAttributes.ts';
import { AppCustomProductPageCreateRequest } from '../models/AppCustomProductPageCreateRequest.ts';
import { AppCustomProductPageCreateRequestData } from '../models/AppCustomProductPageCreateRequestData.ts';
import { AppCustomProductPageCreateRequestDataAttributes } from '../models/AppCustomProductPageCreateRequestDataAttributes.ts';
import { AppCustomProductPageCreateRequestDataRelationships } from '../models/AppCustomProductPageCreateRequestDataRelationships.ts';
import { AppCustomProductPageCreateRequestDataRelationshipsAppCustomProductPageVersions } from '../models/AppCustomProductPageCreateRequestDataRelationshipsAppCustomProductPageVersions.ts';
import { AppCustomProductPageCreateRequestIncludedInner } from '../models/AppCustomProductPageCreateRequestIncludedInner.ts';
import { AppCustomProductPageLocalization } from '../models/AppCustomProductPageLocalization.ts';
import { AppCustomProductPageLocalizationAttributes } from '../models/AppCustomProductPageLocalizationAttributes.ts';
import { AppCustomProductPageLocalizationCreateRequest } from '../models/AppCustomProductPageLocalizationCreateRequest.ts';
import { AppCustomProductPageLocalizationCreateRequestData } from '../models/AppCustomProductPageLocalizationCreateRequestData.ts';
import { AppCustomProductPageLocalizationCreateRequestDataRelationships } from '../models/AppCustomProductPageLocalizationCreateRequestDataRelationships.ts';
import { AppCustomProductPageLocalizationCreateRequestDataRelationshipsAppCustomProductPageVersion } from '../models/AppCustomProductPageLocalizationCreateRequestDataRelationshipsAppCustomProductPageVersion.ts';
import { AppCustomProductPageLocalizationInlineCreate } from '../models/AppCustomProductPageLocalizationInlineCreate.ts';
import { AppCustomProductPageLocalizationInlineCreateAttributes } from '../models/AppCustomProductPageLocalizationInlineCreateAttributes.ts';
import { AppCustomProductPageLocalizationInlineCreateRelationships } from '../models/AppCustomProductPageLocalizationInlineCreateRelationships.ts';
import { AppCustomProductPageLocalizationInlineCreateRelationshipsAppCustomProductPageVersion } from '../models/AppCustomProductPageLocalizationInlineCreateRelationshipsAppCustomProductPageVersion.ts';
import { AppCustomProductPageLocalizationRelationships } from '../models/AppCustomProductPageLocalizationRelationships.ts';
import { AppCustomProductPageLocalizationRelationshipsAppCustomProductPageVersion } from '../models/AppCustomProductPageLocalizationRelationshipsAppCustomProductPageVersion.ts';
import { AppCustomProductPageLocalizationRelationshipsAppCustomProductPageVersionData } from '../models/AppCustomProductPageLocalizationRelationshipsAppCustomProductPageVersionData.ts';
import { AppCustomProductPageLocalizationRelationshipsAppPreviewSets } from '../models/AppCustomProductPageLocalizationRelationshipsAppPreviewSets.ts';
import { AppCustomProductPageLocalizationRelationshipsAppPreviewSetsDataInner } from '../models/AppCustomProductPageLocalizationRelationshipsAppPreviewSetsDataInner.ts';
import { AppCustomProductPageLocalizationRelationshipsAppScreenshotSets } from '../models/AppCustomProductPageLocalizationRelationshipsAppScreenshotSets.ts';
import { AppCustomProductPageLocalizationRelationshipsAppScreenshotSetsDataInner } from '../models/AppCustomProductPageLocalizationRelationshipsAppScreenshotSetsDataInner.ts';
import { AppCustomProductPageLocalizationResponse } from '../models/AppCustomProductPageLocalizationResponse.ts';
import { AppCustomProductPageLocalizationUpdateRequest } from '../models/AppCustomProductPageLocalizationUpdateRequest.ts';
import { AppCustomProductPageLocalizationUpdateRequestData } from '../models/AppCustomProductPageLocalizationUpdateRequestData.ts';
import { AppCustomProductPageLocalizationUpdateRequestDataAttributes } from '../models/AppCustomProductPageLocalizationUpdateRequestDataAttributes.ts';
import { AppCustomProductPageLocalizationsResponse } from '../models/AppCustomProductPageLocalizationsResponse.ts';
import { AppCustomProductPageLocalizationsResponseIncludedInner } from '../models/AppCustomProductPageLocalizationsResponseIncludedInner.ts';
import { AppCustomProductPageRelationships } from '../models/AppCustomProductPageRelationships.ts';
import { AppCustomProductPageRelationshipsAppCustomProductPageVersions } from '../models/AppCustomProductPageRelationshipsAppCustomProductPageVersions.ts';
import { AppCustomProductPageResponse } from '../models/AppCustomProductPageResponse.ts';
import { AppCustomProductPageUpdateRequest } from '../models/AppCustomProductPageUpdateRequest.ts';
import { AppCustomProductPageUpdateRequestData } from '../models/AppCustomProductPageUpdateRequestData.ts';
import { AppCustomProductPageUpdateRequestDataAttributes } from '../models/AppCustomProductPageUpdateRequestDataAttributes.ts';
import { AppCustomProductPageVersion } from '../models/AppCustomProductPageVersion.ts';
import { AppCustomProductPageVersionAttributes } from '../models/AppCustomProductPageVersionAttributes.ts';
import { AppCustomProductPageVersionCreateRequest } from '../models/AppCustomProductPageVersionCreateRequest.ts';
import { AppCustomProductPageVersionCreateRequestData } from '../models/AppCustomProductPageVersionCreateRequestData.ts';
import { AppCustomProductPageVersionCreateRequestDataRelationships } from '../models/AppCustomProductPageVersionCreateRequestDataRelationships.ts';
import { AppCustomProductPageVersionCreateRequestDataRelationshipsAppCustomProductPage } from '../models/AppCustomProductPageVersionCreateRequestDataRelationshipsAppCustomProductPage.ts';
import { AppCustomProductPageVersionInlineCreate } from '../models/AppCustomProductPageVersionInlineCreate.ts';
import { AppCustomProductPageVersionInlineCreateRelationships } from '../models/AppCustomProductPageVersionInlineCreateRelationships.ts';
import { AppCustomProductPageVersionInlineCreateRelationshipsAppCustomProductPage } from '../models/AppCustomProductPageVersionInlineCreateRelationshipsAppCustomProductPage.ts';
import { AppCustomProductPageVersionInlineCreateRelationshipsAppCustomProductPageLocalizations } from '../models/AppCustomProductPageVersionInlineCreateRelationshipsAppCustomProductPageLocalizations.ts';
import { AppCustomProductPageVersionRelationships } from '../models/AppCustomProductPageVersionRelationships.ts';
import { AppCustomProductPageVersionRelationshipsAppCustomProductPage } from '../models/AppCustomProductPageVersionRelationshipsAppCustomProductPage.ts';
import { AppCustomProductPageVersionRelationshipsAppCustomProductPageData } from '../models/AppCustomProductPageVersionRelationshipsAppCustomProductPageData.ts';
import { AppCustomProductPageVersionRelationshipsAppCustomProductPageLocalizations } from '../models/AppCustomProductPageVersionRelationshipsAppCustomProductPageLocalizations.ts';
import { AppCustomProductPageVersionRelationshipsAppCustomProductPageLocalizationsDataInner } from '../models/AppCustomProductPageVersionRelationshipsAppCustomProductPageLocalizationsDataInner.ts';
import { AppCustomProductPageVersionResponse } from '../models/AppCustomProductPageVersionResponse.ts';
import { AppCustomProductPageVersionsResponse } from '../models/AppCustomProductPageVersionsResponse.ts';
import { AppCustomProductPageVersionsResponseIncludedInner } from '../models/AppCustomProductPageVersionsResponseIncludedInner.ts';
import { AppCustomProductPagesResponse } from '../models/AppCustomProductPagesResponse.ts';
import { AppCustomProductPagesResponseIncludedInner } from '../models/AppCustomProductPagesResponseIncludedInner.ts';
import { AppEncryptionDeclaration } from '../models/AppEncryptionDeclaration.ts';
import { AppEncryptionDeclarationAttributes } from '../models/AppEncryptionDeclarationAttributes.ts';
import { AppEncryptionDeclarationBuildsLinkagesRequest } from '../models/AppEncryptionDeclarationBuildsLinkagesRequest.ts';
import { AppEncryptionDeclarationDocument } from '../models/AppEncryptionDeclarationDocument.ts';
import { AppEncryptionDeclarationDocumentAttributes } from '../models/AppEncryptionDeclarationDocumentAttributes.ts';
import { AppEncryptionDeclarationDocumentCreateRequest } from '../models/AppEncryptionDeclarationDocumentCreateRequest.ts';
import { AppEncryptionDeclarationDocumentCreateRequestData } from '../models/AppEncryptionDeclarationDocumentCreateRequestData.ts';
import { AppEncryptionDeclarationDocumentCreateRequestDataRelationships } from '../models/AppEncryptionDeclarationDocumentCreateRequestDataRelationships.ts';
import { AppEncryptionDeclarationDocumentCreateRequestDataRelationshipsAppEncryptionDeclaration } from '../models/AppEncryptionDeclarationDocumentCreateRequestDataRelationshipsAppEncryptionDeclaration.ts';
import { AppEncryptionDeclarationDocumentCreateRequestDataRelationshipsAppEncryptionDeclarationData } from '../models/AppEncryptionDeclarationDocumentCreateRequestDataRelationshipsAppEncryptionDeclarationData.ts';
import { AppEncryptionDeclarationDocumentResponse } from '../models/AppEncryptionDeclarationDocumentResponse.ts';
import { AppEncryptionDeclarationDocumentUpdateRequest } from '../models/AppEncryptionDeclarationDocumentUpdateRequest.ts';
import { AppEncryptionDeclarationDocumentUpdateRequestData } from '../models/AppEncryptionDeclarationDocumentUpdateRequestData.ts';
import { AppEncryptionDeclarationRelationships } from '../models/AppEncryptionDeclarationRelationships.ts';
import { AppEncryptionDeclarationRelationshipsAppEncryptionDeclarationDocument } from '../models/AppEncryptionDeclarationRelationshipsAppEncryptionDeclarationDocument.ts';
import { AppEncryptionDeclarationRelationshipsAppEncryptionDeclarationDocumentData } from '../models/AppEncryptionDeclarationRelationshipsAppEncryptionDeclarationDocumentData.ts';
import { AppEncryptionDeclarationRelationshipsBuilds } from '../models/AppEncryptionDeclarationRelationshipsBuilds.ts';
import { AppEncryptionDeclarationRelationshipsBuildsDataInner } from '../models/AppEncryptionDeclarationRelationshipsBuildsDataInner.ts';
import { AppEncryptionDeclarationResponse } from '../models/AppEncryptionDeclarationResponse.ts';
import { AppEncryptionDeclarationState } from '../models/AppEncryptionDeclarationState.ts';
import { AppEncryptionDeclarationWithoutIncludesResponse } from '../models/AppEncryptionDeclarationWithoutIncludesResponse.ts';
import { AppEncryptionDeclarationsResponse } from '../models/AppEncryptionDeclarationsResponse.ts';
import { AppEncryptionDeclarationsResponseIncludedInner } from '../models/AppEncryptionDeclarationsResponseIncludedInner.ts';
import { AppEvent } from '../models/AppEvent.ts';
import { AppEventAssetType } from '../models/AppEventAssetType.ts';
import { AppEventAttributes } from '../models/AppEventAttributes.ts';
import { AppEventAttributesTerritorySchedulesInner } from '../models/AppEventAttributesTerritorySchedulesInner.ts';
import { AppEventCreateRequest } from '../models/AppEventCreateRequest.ts';
import { AppEventCreateRequestData } from '../models/AppEventCreateRequestData.ts';
import { AppEventCreateRequestDataAttributes } from '../models/AppEventCreateRequestDataAttributes.ts';
import { AppEventLocalization } from '../models/AppEventLocalization.ts';
import { AppEventLocalizationAttributes } from '../models/AppEventLocalizationAttributes.ts';
import { AppEventLocalizationCreateRequest } from '../models/AppEventLocalizationCreateRequest.ts';
import { AppEventLocalizationCreateRequestData } from '../models/AppEventLocalizationCreateRequestData.ts';
import { AppEventLocalizationCreateRequestDataAttributes } from '../models/AppEventLocalizationCreateRequestDataAttributes.ts';
import { AppEventLocalizationCreateRequestDataRelationships } from '../models/AppEventLocalizationCreateRequestDataRelationships.ts';
import { AppEventLocalizationCreateRequestDataRelationshipsAppEvent } from '../models/AppEventLocalizationCreateRequestDataRelationshipsAppEvent.ts';
import { AppEventLocalizationRelationships } from '../models/AppEventLocalizationRelationships.ts';
import { AppEventLocalizationRelationshipsAppEvent } from '../models/AppEventLocalizationRelationshipsAppEvent.ts';
import { AppEventLocalizationRelationshipsAppEventData } from '../models/AppEventLocalizationRelationshipsAppEventData.ts';
import { AppEventLocalizationRelationshipsAppEventScreenshots } from '../models/AppEventLocalizationRelationshipsAppEventScreenshots.ts';
import { AppEventLocalizationRelationshipsAppEventScreenshotsDataInner } from '../models/AppEventLocalizationRelationshipsAppEventScreenshotsDataInner.ts';
import { AppEventLocalizationRelationshipsAppEventVideoClips } from '../models/AppEventLocalizationRelationshipsAppEventVideoClips.ts';
import { AppEventLocalizationRelationshipsAppEventVideoClipsDataInner } from '../models/AppEventLocalizationRelationshipsAppEventVideoClipsDataInner.ts';
import { AppEventLocalizationResponse } from '../models/AppEventLocalizationResponse.ts';
import { AppEventLocalizationUpdateRequest } from '../models/AppEventLocalizationUpdateRequest.ts';
import { AppEventLocalizationUpdateRequestData } from '../models/AppEventLocalizationUpdateRequestData.ts';
import { AppEventLocalizationUpdateRequestDataAttributes } from '../models/AppEventLocalizationUpdateRequestDataAttributes.ts';
import { AppEventLocalizationsResponse } from '../models/AppEventLocalizationsResponse.ts';
import { AppEventLocalizationsResponseIncludedInner } from '../models/AppEventLocalizationsResponseIncludedInner.ts';
import { AppEventRelationships } from '../models/AppEventRelationships.ts';
import { AppEventRelationshipsLocalizations } from '../models/AppEventRelationshipsLocalizations.ts';
import { AppEventResponse } from '../models/AppEventResponse.ts';
import { AppEventScreenshot } from '../models/AppEventScreenshot.ts';
import { AppEventScreenshotAttributes } from '../models/AppEventScreenshotAttributes.ts';
import { AppEventScreenshotCreateRequest } from '../models/AppEventScreenshotCreateRequest.ts';
import { AppEventScreenshotCreateRequestData } from '../models/AppEventScreenshotCreateRequestData.ts';
import { AppEventScreenshotCreateRequestDataAttributes } from '../models/AppEventScreenshotCreateRequestDataAttributes.ts';
import { AppEventScreenshotCreateRequestDataRelationships } from '../models/AppEventScreenshotCreateRequestDataRelationships.ts';
import { AppEventScreenshotCreateRequestDataRelationshipsAppEventLocalization } from '../models/AppEventScreenshotCreateRequestDataRelationshipsAppEventLocalization.ts';
import { AppEventScreenshotRelationships } from '../models/AppEventScreenshotRelationships.ts';
import { AppEventScreenshotRelationshipsAppEventLocalization } from '../models/AppEventScreenshotRelationshipsAppEventLocalization.ts';
import { AppEventScreenshotRelationshipsAppEventLocalizationData } from '../models/AppEventScreenshotRelationshipsAppEventLocalizationData.ts';
import { AppEventScreenshotResponse } from '../models/AppEventScreenshotResponse.ts';
import { AppEventScreenshotUpdateRequest } from '../models/AppEventScreenshotUpdateRequest.ts';
import { AppEventScreenshotUpdateRequestData } from '../models/AppEventScreenshotUpdateRequestData.ts';
import { AppEventScreenshotUpdateRequestDataAttributes } from '../models/AppEventScreenshotUpdateRequestDataAttributes.ts';
import { AppEventScreenshotsResponse } from '../models/AppEventScreenshotsResponse.ts';
import { AppEventUpdateRequest } from '../models/AppEventUpdateRequest.ts';
import { AppEventUpdateRequestData } from '../models/AppEventUpdateRequestData.ts';
import { AppEventUpdateRequestDataAttributes } from '../models/AppEventUpdateRequestDataAttributes.ts';
import { AppEventVideoClip } from '../models/AppEventVideoClip.ts';
import { AppEventVideoClipAttributes } from '../models/AppEventVideoClipAttributes.ts';
import { AppEventVideoClipCreateRequest } from '../models/AppEventVideoClipCreateRequest.ts';
import { AppEventVideoClipCreateRequestData } from '../models/AppEventVideoClipCreateRequestData.ts';
import { AppEventVideoClipCreateRequestDataAttributes } from '../models/AppEventVideoClipCreateRequestDataAttributes.ts';
import { AppEventVideoClipResponse } from '../models/AppEventVideoClipResponse.ts';
import { AppEventVideoClipUpdateRequest } from '../models/AppEventVideoClipUpdateRequest.ts';
import { AppEventVideoClipUpdateRequestData } from '../models/AppEventVideoClipUpdateRequestData.ts';
import { AppEventVideoClipUpdateRequestDataAttributes } from '../models/AppEventVideoClipUpdateRequestDataAttributes.ts';
import { AppEventVideoClipsResponse } from '../models/AppEventVideoClipsResponse.ts';
import { AppEventsResponse } from '../models/AppEventsResponse.ts';
import { AppInfo } from '../models/AppInfo.ts';
import { AppInfoAttributes } from '../models/AppInfoAttributes.ts';
import { AppInfoLocalization } from '../models/AppInfoLocalization.ts';
import { AppInfoLocalizationAttributes } from '../models/AppInfoLocalizationAttributes.ts';
import { AppInfoLocalizationCreateRequest } from '../models/AppInfoLocalizationCreateRequest.ts';
import { AppInfoLocalizationCreateRequestData } from '../models/AppInfoLocalizationCreateRequestData.ts';
import { AppInfoLocalizationCreateRequestDataAttributes } from '../models/AppInfoLocalizationCreateRequestDataAttributes.ts';
import { AppInfoLocalizationCreateRequestDataRelationships } from '../models/AppInfoLocalizationCreateRequestDataRelationships.ts';
import { AppInfoLocalizationCreateRequestDataRelationshipsAppInfo } from '../models/AppInfoLocalizationCreateRequestDataRelationshipsAppInfo.ts';
import { AppInfoLocalizationRelationships } from '../models/AppInfoLocalizationRelationships.ts';
import { AppInfoLocalizationRelationshipsAppInfo } from '../models/AppInfoLocalizationRelationshipsAppInfo.ts';
import { AppInfoLocalizationRelationshipsAppInfoData } from '../models/AppInfoLocalizationRelationshipsAppInfoData.ts';
import { AppInfoLocalizationResponse } from '../models/AppInfoLocalizationResponse.ts';
import { AppInfoLocalizationUpdateRequest } from '../models/AppInfoLocalizationUpdateRequest.ts';
import { AppInfoLocalizationUpdateRequestData } from '../models/AppInfoLocalizationUpdateRequestData.ts';
import { AppInfoLocalizationUpdateRequestDataAttributes } from '../models/AppInfoLocalizationUpdateRequestDataAttributes.ts';
import { AppInfoLocalizationsResponse } from '../models/AppInfoLocalizationsResponse.ts';
import { AppInfoRelationships } from '../models/AppInfoRelationships.ts';
import { AppInfoRelationshipsAgeRatingDeclaration } from '../models/AppInfoRelationshipsAgeRatingDeclaration.ts';
import { AppInfoRelationshipsAgeRatingDeclarationData } from '../models/AppInfoRelationshipsAgeRatingDeclarationData.ts';
import { AppInfoRelationshipsAppInfoLocalizations } from '../models/AppInfoRelationshipsAppInfoLocalizations.ts';
import { AppInfoRelationshipsAppInfoLocalizationsDataInner } from '../models/AppInfoRelationshipsAppInfoLocalizationsDataInner.ts';
import { AppInfoResponse } from '../models/AppInfoResponse.ts';
import { AppInfoUpdateRequest } from '../models/AppInfoUpdateRequest.ts';
import { AppInfoUpdateRequestData } from '../models/AppInfoUpdateRequestData.ts';
import { AppInfoUpdateRequestDataRelationships } from '../models/AppInfoUpdateRequestDataRelationships.ts';
import { AppInfoUpdateRequestDataRelationshipsPrimaryCategory } from '../models/AppInfoUpdateRequestDataRelationshipsPrimaryCategory.ts';
import { AppInfosResponse } from '../models/AppInfosResponse.ts';
import { AppInfosResponseIncludedInner } from '../models/AppInfosResponseIncludedInner.ts';
import { AppMediaAssetState } from '../models/AppMediaAssetState.ts';
import { AppMediaStateError } from '../models/AppMediaStateError.ts';
import { AppPreOrder } from '../models/AppPreOrder.ts';
import { AppPreOrderAttributes } from '../models/AppPreOrderAttributes.ts';
import { AppPreOrderCreateRequest } from '../models/AppPreOrderCreateRequest.ts';
import { AppPreOrderCreateRequestData } from '../models/AppPreOrderCreateRequestData.ts';
import { AppPreOrderCreateRequestDataAttributes } from '../models/AppPreOrderCreateRequestDataAttributes.ts';
import { AppPreOrderRelationships } from '../models/AppPreOrderRelationships.ts';
import { AppPreOrderResponse } from '../models/AppPreOrderResponse.ts';
import { AppPreOrderUpdateRequest } from '../models/AppPreOrderUpdateRequest.ts';
import { AppPreOrderUpdateRequestData } from '../models/AppPreOrderUpdateRequestData.ts';
import { AppPreOrderWithoutIncludesResponse } from '../models/AppPreOrderWithoutIncludesResponse.ts';
import { AppPreview } from '../models/AppPreview.ts';
import { AppPreviewAttributes } from '../models/AppPreviewAttributes.ts';
import { AppPreviewCreateRequest } from '../models/AppPreviewCreateRequest.ts';
import { AppPreviewCreateRequestData } from '../models/AppPreviewCreateRequestData.ts';
import { AppPreviewCreateRequestDataAttributes } from '../models/AppPreviewCreateRequestDataAttributes.ts';
import { AppPreviewCreateRequestDataRelationships } from '../models/AppPreviewCreateRequestDataRelationships.ts';
import { AppPreviewCreateRequestDataRelationshipsAppPreviewSet } from '../models/AppPreviewCreateRequestDataRelationshipsAppPreviewSet.ts';
import { AppPreviewRelationships } from '../models/AppPreviewRelationships.ts';
import { AppPreviewRelationshipsAppPreviewSet } from '../models/AppPreviewRelationshipsAppPreviewSet.ts';
import { AppPreviewResponse } from '../models/AppPreviewResponse.ts';
import { AppPreviewSet } from '../models/AppPreviewSet.ts';
import { AppPreviewSetAppPreviewsLinkagesRequest } from '../models/AppPreviewSetAppPreviewsLinkagesRequest.ts';
import { AppPreviewSetAppPreviewsLinkagesResponse } from '../models/AppPreviewSetAppPreviewsLinkagesResponse.ts';
import { AppPreviewSetAttributes } from '../models/AppPreviewSetAttributes.ts';
import { AppPreviewSetCreateRequest } from '../models/AppPreviewSetCreateRequest.ts';
import { AppPreviewSetCreateRequestData } from '../models/AppPreviewSetCreateRequestData.ts';
import { AppPreviewSetCreateRequestDataAttributes } from '../models/AppPreviewSetCreateRequestDataAttributes.ts';
import { AppPreviewSetCreateRequestDataRelationships } from '../models/AppPreviewSetCreateRequestDataRelationships.ts';
import { AppPreviewSetCreateRequestDataRelationshipsAppCustomProductPageLocalization } from '../models/AppPreviewSetCreateRequestDataRelationshipsAppCustomProductPageLocalization.ts';
import { AppPreviewSetCreateRequestDataRelationshipsAppStoreVersionExperimentTreatmentLocalization } from '../models/AppPreviewSetCreateRequestDataRelationshipsAppStoreVersionExperimentTreatmentLocalization.ts';
import { AppPreviewSetCreateRequestDataRelationshipsAppStoreVersionLocalization } from '../models/AppPreviewSetCreateRequestDataRelationshipsAppStoreVersionLocalization.ts';
import { AppPreviewSetRelationships } from '../models/AppPreviewSetRelationships.ts';
import { AppPreviewSetRelationshipsAppCustomProductPageLocalization } from '../models/AppPreviewSetRelationshipsAppCustomProductPageLocalization.ts';
import { AppPreviewSetRelationshipsAppPreviews } from '../models/AppPreviewSetRelationshipsAppPreviews.ts';
import { AppPreviewSetRelationshipsAppPreviewsDataInner } from '../models/AppPreviewSetRelationshipsAppPreviewsDataInner.ts';
import { AppPreviewSetRelationshipsAppStoreVersionExperimentTreatmentLocalization } from '../models/AppPreviewSetRelationshipsAppStoreVersionExperimentTreatmentLocalization.ts';
import { AppPreviewSetRelationshipsAppStoreVersionExperimentTreatmentLocalizationData } from '../models/AppPreviewSetRelationshipsAppStoreVersionExperimentTreatmentLocalizationData.ts';
import { AppPreviewSetRelationshipsAppStoreVersionLocalization } from '../models/AppPreviewSetRelationshipsAppStoreVersionLocalization.ts';
import { AppPreviewSetRelationshipsAppStoreVersionLocalizationData } from '../models/AppPreviewSetRelationshipsAppStoreVersionLocalizationData.ts';
import { AppPreviewSetResponse } from '../models/AppPreviewSetResponse.ts';
import { AppPreviewSetsResponse } from '../models/AppPreviewSetsResponse.ts';
import { AppPreviewSetsResponseIncludedInner } from '../models/AppPreviewSetsResponseIncludedInner.ts';
import { AppPreviewUpdateRequest } from '../models/AppPreviewUpdateRequest.ts';
import { AppPreviewUpdateRequestData } from '../models/AppPreviewUpdateRequestData.ts';
import { AppPreviewUpdateRequestDataAttributes } from '../models/AppPreviewUpdateRequestDataAttributes.ts';
import { AppPreviewsResponse } from '../models/AppPreviewsResponse.ts';
import { AppPrice } from '../models/AppPrice.ts';
import { AppPriceInlineCreate } from '../models/AppPriceInlineCreate.ts';
import { AppPricePoint } from '../models/AppPricePoint.ts';
import { AppPricePointRelationships } from '../models/AppPricePointRelationships.ts';
import { AppPricePointResponse } from '../models/AppPricePointResponse.ts';
import { AppPricePointV2 } from '../models/AppPricePointV2.ts';
import { AppPricePointV2Attributes } from '../models/AppPricePointV2Attributes.ts';
import { AppPricePointV2Relationships } from '../models/AppPricePointV2Relationships.ts';
import { AppPricePointV2RelationshipsPriceTier } from '../models/AppPricePointV2RelationshipsPriceTier.ts';
import { AppPricePointV2RelationshipsPriceTierData } from '../models/AppPricePointV2RelationshipsPriceTierData.ts';
import { AppPricePointV2RelationshipsTerritory } from '../models/AppPricePointV2RelationshipsTerritory.ts';
import { AppPricePointV3 } from '../models/AppPricePointV3.ts';
import { AppPricePointV3Relationships } from '../models/AppPricePointV3Relationships.ts';
import { AppPricePointV3Response } from '../models/AppPricePointV3Response.ts';
import { AppPricePointsResponse } from '../models/AppPricePointsResponse.ts';
import { AppPricePointsResponseIncludedInner } from '../models/AppPricePointsResponseIncludedInner.ts';
import { AppPricePointsV2Response } from '../models/AppPricePointsV2Response.ts';
import { AppPricePointsV2ResponseIncludedInner } from '../models/AppPricePointsV2ResponseIncludedInner.ts';
import { AppPricePointsV3Response } from '../models/AppPricePointsV3Response.ts';
import { AppPriceRelationships } from '../models/AppPriceRelationships.ts';
import { AppPriceResponse } from '../models/AppPriceResponse.ts';
import { AppPriceSchedule } from '../models/AppPriceSchedule.ts';
import { AppPriceScheduleCreateRequest } from '../models/AppPriceScheduleCreateRequest.ts';
import { AppPriceScheduleCreateRequestData } from '../models/AppPriceScheduleCreateRequestData.ts';
import { AppPriceScheduleCreateRequestDataRelationships } from '../models/AppPriceScheduleCreateRequestDataRelationships.ts';
import { AppPriceScheduleCreateRequestDataRelationshipsBaseTerritory } from '../models/AppPriceScheduleCreateRequestDataRelationshipsBaseTerritory.ts';
import { AppPriceScheduleCreateRequestDataRelationshipsManualPrices } from '../models/AppPriceScheduleCreateRequestDataRelationshipsManualPrices.ts';
import { AppPriceScheduleCreateRequestIncludedInner } from '../models/AppPriceScheduleCreateRequestIncludedInner.ts';
import { AppPriceScheduleRelationships } from '../models/AppPriceScheduleRelationships.ts';
import { AppPriceScheduleRelationshipsManualPrices } from '../models/AppPriceScheduleRelationshipsManualPrices.ts';
import { AppPriceScheduleRelationshipsManualPricesDataInner } from '../models/AppPriceScheduleRelationshipsManualPricesDataInner.ts';
import { AppPriceScheduleResponse } from '../models/AppPriceScheduleResponse.ts';
import { AppPriceScheduleResponseIncludedInner } from '../models/AppPriceScheduleResponseIncludedInner.ts';
import { AppPriceTier } from '../models/AppPriceTier.ts';
import { AppPriceTierRelationships } from '../models/AppPriceTierRelationships.ts';
import { AppPriceTierRelationshipsPricePoints } from '../models/AppPriceTierRelationshipsPricePoints.ts';
import { AppPriceTierRelationshipsPricePointsDataInner } from '../models/AppPriceTierRelationshipsPricePointsDataInner.ts';
import { AppPriceTierResponse } from '../models/AppPriceTierResponse.ts';
import { AppPriceTiersResponse } from '../models/AppPriceTiersResponse.ts';
import { AppPriceV2 } from '../models/AppPriceV2.ts';
import { AppPriceV2Attributes } from '../models/AppPriceV2Attributes.ts';
import { AppPriceV2InlineCreate } from '../models/AppPriceV2InlineCreate.ts';
import { AppPriceV2Relationships } from '../models/AppPriceV2Relationships.ts';
import { AppPriceV2RelationshipsAppPricePoint } from '../models/AppPriceV2RelationshipsAppPricePoint.ts';
import { AppPricesResponse } from '../models/AppPricesResponse.ts';
import { AppPricesResponseIncludedInner } from '../models/AppPricesResponseIncludedInner.ts';
import { AppPricesV2Response } from '../models/AppPricesV2Response.ts';
import { AppPricesV2ResponseIncludedInner } from '../models/AppPricesV2ResponseIncludedInner.ts';
import { AppPromotedPurchasesLinkagesRequest } from '../models/AppPromotedPurchasesLinkagesRequest.ts';
import { AppPromotedPurchasesLinkagesResponse } from '../models/AppPromotedPurchasesLinkagesResponse.ts';
import { AppRelationships } from '../models/AppRelationships.ts';
import { AppRelationshipsAppClips } from '../models/AppRelationshipsAppClips.ts';
import { AppRelationshipsAppCustomProductPages } from '../models/AppRelationshipsAppCustomProductPages.ts';
import { AppRelationshipsAppEncryptionDeclarations } from '../models/AppRelationshipsAppEncryptionDeclarations.ts';
import { AppRelationshipsAppEvents } from '../models/AppRelationshipsAppEvents.ts';
import { AppRelationshipsAppInfos } from '../models/AppRelationshipsAppInfos.ts';
import { AppRelationshipsAvailableTerritories } from '../models/AppRelationshipsAvailableTerritories.ts';
import { AppRelationshipsBetaAppLocalizations } from '../models/AppRelationshipsBetaAppLocalizations.ts';
import { AppRelationshipsBetaAppLocalizationsDataInner } from '../models/AppRelationshipsBetaAppLocalizationsDataInner.ts';
import { AppRelationshipsBetaAppReviewDetail } from '../models/AppRelationshipsBetaAppReviewDetail.ts';
import { AppRelationshipsBetaAppReviewDetailData } from '../models/AppRelationshipsBetaAppReviewDetailData.ts';
import { AppRelationshipsBetaGroups } from '../models/AppRelationshipsBetaGroups.ts';
import { AppRelationshipsBetaGroupsDataInner } from '../models/AppRelationshipsBetaGroupsDataInner.ts';
import { AppRelationshipsBetaLicenseAgreement } from '../models/AppRelationshipsBetaLicenseAgreement.ts';
import { AppRelationshipsBetaLicenseAgreementData } from '../models/AppRelationshipsBetaLicenseAgreementData.ts';
import { AppRelationshipsBuilds } from '../models/AppRelationshipsBuilds.ts';
import { AppRelationshipsCiProduct } from '../models/AppRelationshipsCiProduct.ts';
import { AppRelationshipsCiProductData } from '../models/AppRelationshipsCiProductData.ts';
import { AppRelationshipsEndUserLicenseAgreement } from '../models/AppRelationshipsEndUserLicenseAgreement.ts';
import { AppRelationshipsEndUserLicenseAgreementData } from '../models/AppRelationshipsEndUserLicenseAgreementData.ts';
import { AppRelationshipsGameCenterDetail } from '../models/AppRelationshipsGameCenterDetail.ts';
import { AppRelationshipsGameCenterDetailData } from '../models/AppRelationshipsGameCenterDetailData.ts';
import { AppRelationshipsGameCenterEnabledVersions } from '../models/AppRelationshipsGameCenterEnabledVersions.ts';
import { AppRelationshipsGameCenterEnabledVersionsDataInner } from '../models/AppRelationshipsGameCenterEnabledVersionsDataInner.ts';
import { AppRelationshipsInAppPurchases } from '../models/AppRelationshipsInAppPurchases.ts';
import { AppRelationshipsInAppPurchasesDataInner } from '../models/AppRelationshipsInAppPurchasesDataInner.ts';
import { AppRelationshipsInAppPurchasesV2 } from '../models/AppRelationshipsInAppPurchasesV2.ts';
import { AppRelationshipsPreOrder } from '../models/AppRelationshipsPreOrder.ts';
import { AppRelationshipsPreOrderData } from '../models/AppRelationshipsPreOrderData.ts';
import { AppRelationshipsPreReleaseVersions } from '../models/AppRelationshipsPreReleaseVersions.ts';
import { AppRelationshipsPreReleaseVersionsDataInner } from '../models/AppRelationshipsPreReleaseVersionsDataInner.ts';
import { AppRelationshipsPrices } from '../models/AppRelationshipsPrices.ts';
import { AppRelationshipsPromotedPurchases } from '../models/AppRelationshipsPromotedPurchases.ts';
import { AppRelationshipsPromotedPurchasesDataInner } from '../models/AppRelationshipsPromotedPurchasesDataInner.ts';
import { AppRelationshipsReviewSubmissions } from '../models/AppRelationshipsReviewSubmissions.ts';
import { AppRelationshipsReviewSubmissionsDataInner } from '../models/AppRelationshipsReviewSubmissionsDataInner.ts';
import { AppRelationshipsSubscriptionGracePeriod } from '../models/AppRelationshipsSubscriptionGracePeriod.ts';
import { AppRelationshipsSubscriptionGracePeriodData } from '../models/AppRelationshipsSubscriptionGracePeriodData.ts';
import { AppRelationshipsSubscriptionGroups } from '../models/AppRelationshipsSubscriptionGroups.ts';
import { AppRelationshipsSubscriptionGroupsDataInner } from '../models/AppRelationshipsSubscriptionGroupsDataInner.ts';
import { AppResponse } from '../models/AppResponse.ts';
import { AppScreenshot } from '../models/AppScreenshot.ts';
import { AppScreenshotAttributes } from '../models/AppScreenshotAttributes.ts';
import { AppScreenshotCreateRequest } from '../models/AppScreenshotCreateRequest.ts';
import { AppScreenshotCreateRequestData } from '../models/AppScreenshotCreateRequestData.ts';
import { AppScreenshotCreateRequestDataRelationships } from '../models/AppScreenshotCreateRequestDataRelationships.ts';
import { AppScreenshotCreateRequestDataRelationshipsAppScreenshotSet } from '../models/AppScreenshotCreateRequestDataRelationshipsAppScreenshotSet.ts';
import { AppScreenshotRelationships } from '../models/AppScreenshotRelationships.ts';
import { AppScreenshotRelationshipsAppScreenshotSet } from '../models/AppScreenshotRelationshipsAppScreenshotSet.ts';
import { AppScreenshotResponse } from '../models/AppScreenshotResponse.ts';
import { AppScreenshotSet } from '../models/AppScreenshotSet.ts';
import { AppScreenshotSetAppScreenshotsLinkagesRequest } from '../models/AppScreenshotSetAppScreenshotsLinkagesRequest.ts';
import { AppScreenshotSetAppScreenshotsLinkagesResponse } from '../models/AppScreenshotSetAppScreenshotsLinkagesResponse.ts';
import { AppScreenshotSetAttributes } from '../models/AppScreenshotSetAttributes.ts';
import { AppScreenshotSetCreateRequest } from '../models/AppScreenshotSetCreateRequest.ts';
import { AppScreenshotSetCreateRequestData } from '../models/AppScreenshotSetCreateRequestData.ts';
import { AppScreenshotSetCreateRequestDataAttributes } from '../models/AppScreenshotSetCreateRequestDataAttributes.ts';
import { AppScreenshotSetRelationships } from '../models/AppScreenshotSetRelationships.ts';
import { AppScreenshotSetRelationshipsAppScreenshots } from '../models/AppScreenshotSetRelationshipsAppScreenshots.ts';
import { AppScreenshotSetRelationshipsAppScreenshotsDataInner } from '../models/AppScreenshotSetRelationshipsAppScreenshotsDataInner.ts';
import { AppScreenshotSetResponse } from '../models/AppScreenshotSetResponse.ts';
import { AppScreenshotSetsResponse } from '../models/AppScreenshotSetsResponse.ts';
import { AppScreenshotSetsResponseIncludedInner } from '../models/AppScreenshotSetsResponseIncludedInner.ts';
import { AppScreenshotUpdateRequest } from '../models/AppScreenshotUpdateRequest.ts';
import { AppScreenshotUpdateRequestData } from '../models/AppScreenshotUpdateRequestData.ts';
import { AppScreenshotsResponse } from '../models/AppScreenshotsResponse.ts';
import { AppStoreAgeRating } from '../models/AppStoreAgeRating.ts';
import { AppStoreReviewAttachment } from '../models/AppStoreReviewAttachment.ts';
import { AppStoreReviewAttachmentAttributes } from '../models/AppStoreReviewAttachmentAttributes.ts';
import { AppStoreReviewAttachmentCreateRequest } from '../models/AppStoreReviewAttachmentCreateRequest.ts';
import { AppStoreReviewAttachmentCreateRequestData } from '../models/AppStoreReviewAttachmentCreateRequestData.ts';
import { AppStoreReviewAttachmentCreateRequestDataRelationships } from '../models/AppStoreReviewAttachmentCreateRequestDataRelationships.ts';
import { AppStoreReviewAttachmentCreateRequestDataRelationshipsAppStoreReviewDetail } from '../models/AppStoreReviewAttachmentCreateRequestDataRelationshipsAppStoreReviewDetail.ts';
import { AppStoreReviewAttachmentRelationships } from '../models/AppStoreReviewAttachmentRelationships.ts';
import { AppStoreReviewAttachmentRelationshipsAppStoreReviewDetail } from '../models/AppStoreReviewAttachmentRelationshipsAppStoreReviewDetail.ts';
import { AppStoreReviewAttachmentRelationshipsAppStoreReviewDetailData } from '../models/AppStoreReviewAttachmentRelationshipsAppStoreReviewDetailData.ts';
import { AppStoreReviewAttachmentResponse } from '../models/AppStoreReviewAttachmentResponse.ts';
import { AppStoreReviewAttachmentUpdateRequest } from '../models/AppStoreReviewAttachmentUpdateRequest.ts';
import { AppStoreReviewAttachmentUpdateRequestData } from '../models/AppStoreReviewAttachmentUpdateRequestData.ts';
import { AppStoreReviewAttachmentsResponse } from '../models/AppStoreReviewAttachmentsResponse.ts';
import { AppStoreReviewDetail } from '../models/AppStoreReviewDetail.ts';
import { AppStoreReviewDetailAttributes } from '../models/AppStoreReviewDetailAttributes.ts';
import { AppStoreReviewDetailCreateRequest } from '../models/AppStoreReviewDetailCreateRequest.ts';
import { AppStoreReviewDetailCreateRequestData } from '../models/AppStoreReviewDetailCreateRequestData.ts';
import { AppStoreReviewDetailRelationships } from '../models/AppStoreReviewDetailRelationships.ts';
import { AppStoreReviewDetailRelationshipsAppStoreReviewAttachments } from '../models/AppStoreReviewDetailRelationshipsAppStoreReviewAttachments.ts';
import { AppStoreReviewDetailRelationshipsAppStoreReviewAttachmentsDataInner } from '../models/AppStoreReviewDetailRelationshipsAppStoreReviewAttachmentsDataInner.ts';
import { AppStoreReviewDetailResponse } from '../models/AppStoreReviewDetailResponse.ts';
import { AppStoreReviewDetailResponseIncludedInner } from '../models/AppStoreReviewDetailResponseIncludedInner.ts';
import { AppStoreReviewDetailUpdateRequest } from '../models/AppStoreReviewDetailUpdateRequest.ts';
import { AppStoreReviewDetailUpdateRequestData } from '../models/AppStoreReviewDetailUpdateRequestData.ts';
import { AppStoreVersion } from '../models/AppStoreVersion.ts';
import { AppStoreVersionAppClipDefaultExperienceLinkageRequest } from '../models/AppStoreVersionAppClipDefaultExperienceLinkageRequest.ts';
import { AppStoreVersionAppClipDefaultExperienceLinkageResponse } from '../models/AppStoreVersionAppClipDefaultExperienceLinkageResponse.ts';
import { AppStoreVersionAttributes } from '../models/AppStoreVersionAttributes.ts';
import { AppStoreVersionBuildLinkageRequest } from '../models/AppStoreVersionBuildLinkageRequest.ts';
import { AppStoreVersionBuildLinkageResponse } from '../models/AppStoreVersionBuildLinkageResponse.ts';
import { AppStoreVersionCreateRequest } from '../models/AppStoreVersionCreateRequest.ts';
import { AppStoreVersionCreateRequestData } from '../models/AppStoreVersionCreateRequestData.ts';
import { AppStoreVersionCreateRequestDataAttributes } from '../models/AppStoreVersionCreateRequestDataAttributes.ts';
import { AppStoreVersionCreateRequestDataRelationships } from '../models/AppStoreVersionCreateRequestDataRelationships.ts';
import { AppStoreVersionCreateRequestDataRelationshipsAppStoreVersionLocalizations } from '../models/AppStoreVersionCreateRequestDataRelationshipsAppStoreVersionLocalizations.ts';
import { AppStoreVersionCreateRequestDataRelationshipsBuild } from '../models/AppStoreVersionCreateRequestDataRelationshipsBuild.ts';
import { AppStoreVersionExperiment } from '../models/AppStoreVersionExperiment.ts';
import { AppStoreVersionExperimentAttributes } from '../models/AppStoreVersionExperimentAttributes.ts';
import { AppStoreVersionExperimentCreateRequest } from '../models/AppStoreVersionExperimentCreateRequest.ts';
import { AppStoreVersionExperimentCreateRequestData } from '../models/AppStoreVersionExperimentCreateRequestData.ts';
import { AppStoreVersionExperimentCreateRequestDataAttributes } from '../models/AppStoreVersionExperimentCreateRequestDataAttributes.ts';
import { AppStoreVersionExperimentRelationships } from '../models/AppStoreVersionExperimentRelationships.ts';
import { AppStoreVersionExperimentResponse } from '../models/AppStoreVersionExperimentResponse.ts';
import { AppStoreVersionExperimentTreatment } from '../models/AppStoreVersionExperimentTreatment.ts';
import { AppStoreVersionExperimentTreatmentAttributes } from '../models/AppStoreVersionExperimentTreatmentAttributes.ts';
import { AppStoreVersionExperimentTreatmentCreateRequest } from '../models/AppStoreVersionExperimentTreatmentCreateRequest.ts';
import { AppStoreVersionExperimentTreatmentCreateRequestData } from '../models/AppStoreVersionExperimentTreatmentCreateRequestData.ts';
import { AppStoreVersionExperimentTreatmentCreateRequestDataAttributes } from '../models/AppStoreVersionExperimentTreatmentCreateRequestDataAttributes.ts';
import { AppStoreVersionExperimentTreatmentCreateRequestDataRelationships } from '../models/AppStoreVersionExperimentTreatmentCreateRequestDataRelationships.ts';
import { AppStoreVersionExperimentTreatmentCreateRequestDataRelationshipsAppStoreVersionExperiment } from '../models/AppStoreVersionExperimentTreatmentCreateRequestDataRelationshipsAppStoreVersionExperiment.ts';
import { AppStoreVersionExperimentTreatmentCreateRequestDataRelationshipsAppStoreVersionExperimentV2 } from '../models/AppStoreVersionExperimentTreatmentCreateRequestDataRelationshipsAppStoreVersionExperimentV2.ts';
import { AppStoreVersionExperimentTreatmentLocalization } from '../models/AppStoreVersionExperimentTreatmentLocalization.ts';
import { AppStoreVersionExperimentTreatmentLocalizationAttributes } from '../models/AppStoreVersionExperimentTreatmentLocalizationAttributes.ts';
import { AppStoreVersionExperimentTreatmentLocalizationCreateRequest } from '../models/AppStoreVersionExperimentTreatmentLocalizationCreateRequest.ts';
import { AppStoreVersionExperimentTreatmentLocalizationCreateRequestData } from '../models/AppStoreVersionExperimentTreatmentLocalizationCreateRequestData.ts';
import { AppStoreVersionExperimentTreatmentLocalizationCreateRequestDataAttributes } from '../models/AppStoreVersionExperimentTreatmentLocalizationCreateRequestDataAttributes.ts';
import { AppStoreVersionExperimentTreatmentLocalizationCreateRequestDataRelationships } from '../models/AppStoreVersionExperimentTreatmentLocalizationCreateRequestDataRelationships.ts';
import { AppStoreVersionExperimentTreatmentLocalizationCreateRequestDataRelationshipsAppStoreVersionExperimentTreatment } from '../models/AppStoreVersionExperimentTreatmentLocalizationCreateRequestDataRelationshipsAppStoreVersionExperimentTreatment.ts';
import { AppStoreVersionExperimentTreatmentLocalizationRelationships } from '../models/AppStoreVersionExperimentTreatmentLocalizationRelationships.ts';
import { AppStoreVersionExperimentTreatmentLocalizationRelationshipsAppStoreVersionExperimentTreatment } from '../models/AppStoreVersionExperimentTreatmentLocalizationRelationshipsAppStoreVersionExperimentTreatment.ts';
import { AppStoreVersionExperimentTreatmentLocalizationRelationshipsAppStoreVersionExperimentTreatmentData } from '../models/AppStoreVersionExperimentTreatmentLocalizationRelationshipsAppStoreVersionExperimentTreatmentData.ts';
import { AppStoreVersionExperimentTreatmentLocalizationResponse } from '../models/AppStoreVersionExperimentTreatmentLocalizationResponse.ts';
import { AppStoreVersionExperimentTreatmentLocalizationsResponse } from '../models/AppStoreVersionExperimentTreatmentLocalizationsResponse.ts';
import { AppStoreVersionExperimentTreatmentLocalizationsResponseIncludedInner } from '../models/AppStoreVersionExperimentTreatmentLocalizationsResponseIncludedInner.ts';
import { AppStoreVersionExperimentTreatmentRelationships } from '../models/AppStoreVersionExperimentTreatmentRelationships.ts';
import { AppStoreVersionExperimentTreatmentRelationshipsAppStoreVersionExperiment } from '../models/AppStoreVersionExperimentTreatmentRelationshipsAppStoreVersionExperiment.ts';
import { AppStoreVersionExperimentTreatmentRelationshipsAppStoreVersionExperimentData } from '../models/AppStoreVersionExperimentTreatmentRelationshipsAppStoreVersionExperimentData.ts';
import { AppStoreVersionExperimentTreatmentRelationshipsAppStoreVersionExperimentTreatmentLocalizations } from '../models/AppStoreVersionExperimentTreatmentRelationshipsAppStoreVersionExperimentTreatmentLocalizations.ts';
import { AppStoreVersionExperimentTreatmentResponse } from '../models/AppStoreVersionExperimentTreatmentResponse.ts';
import { AppStoreVersionExperimentTreatmentUpdateRequest } from '../models/AppStoreVersionExperimentTreatmentUpdateRequest.ts';
import { AppStoreVersionExperimentTreatmentUpdateRequestData } from '../models/AppStoreVersionExperimentTreatmentUpdateRequestData.ts';
import { AppStoreVersionExperimentTreatmentUpdateRequestDataAttributes } from '../models/AppStoreVersionExperimentTreatmentUpdateRequestDataAttributes.ts';
import { AppStoreVersionExperimentTreatmentsResponse } from '../models/AppStoreVersionExperimentTreatmentsResponse.ts';
import { AppStoreVersionExperimentTreatmentsResponseIncludedInner } from '../models/AppStoreVersionExperimentTreatmentsResponseIncludedInner.ts';
import { AppStoreVersionExperimentUpdateRequest } from '../models/AppStoreVersionExperimentUpdateRequest.ts';
import { AppStoreVersionExperimentV2 } from '../models/AppStoreVersionExperimentV2.ts';
import { AppStoreVersionExperimentV2Attributes } from '../models/AppStoreVersionExperimentV2Attributes.ts';
import { AppStoreVersionExperimentV2CreateRequest } from '../models/AppStoreVersionExperimentV2CreateRequest.ts';
import { AppStoreVersionExperimentV2CreateRequestData } from '../models/AppStoreVersionExperimentV2CreateRequestData.ts';
import { AppStoreVersionExperimentV2CreateRequestDataAttributes } from '../models/AppStoreVersionExperimentV2CreateRequestDataAttributes.ts';
import { AppStoreVersionExperimentV2Relationships } from '../models/AppStoreVersionExperimentV2Relationships.ts';
import { AppStoreVersionExperimentV2RelationshipsAppStoreVersionExperimentTreatments } from '../models/AppStoreVersionExperimentV2RelationshipsAppStoreVersionExperimentTreatments.ts';
import { AppStoreVersionExperimentV2RelationshipsControlVersions } from '../models/AppStoreVersionExperimentV2RelationshipsControlVersions.ts';
import { AppStoreVersionExperimentV2Response } from '../models/AppStoreVersionExperimentV2Response.ts';
import { AppStoreVersionExperimentV2UpdateRequest } from '../models/AppStoreVersionExperimentV2UpdateRequest.ts';
import { AppStoreVersionExperimentV2UpdateRequestData } from '../models/AppStoreVersionExperimentV2UpdateRequestData.ts';
import { AppStoreVersionExperimentV2UpdateRequestDataAttributes } from '../models/AppStoreVersionExperimentV2UpdateRequestDataAttributes.ts';
import { AppStoreVersionExperimentsResponse } from '../models/AppStoreVersionExperimentsResponse.ts';
import { AppStoreVersionExperimentsResponseIncludedInner } from '../models/AppStoreVersionExperimentsResponseIncludedInner.ts';
import { AppStoreVersionExperimentsV2Response } from '../models/AppStoreVersionExperimentsV2Response.ts';
import { AppStoreVersionExperimentsV2ResponseIncludedInner } from '../models/AppStoreVersionExperimentsV2ResponseIncludedInner.ts';
import { AppStoreVersionLocalization } from '../models/AppStoreVersionLocalization.ts';
import { AppStoreVersionLocalizationAttributes } from '../models/AppStoreVersionLocalizationAttributes.ts';
import { AppStoreVersionLocalizationCreateRequest } from '../models/AppStoreVersionLocalizationCreateRequest.ts';
import { AppStoreVersionLocalizationCreateRequestData } from '../models/AppStoreVersionLocalizationCreateRequestData.ts';
import { AppStoreVersionLocalizationCreateRequestDataAttributes } from '../models/AppStoreVersionLocalizationCreateRequestDataAttributes.ts';
import { AppStoreVersionLocalizationRelationships } from '../models/AppStoreVersionLocalizationRelationships.ts';
import { AppStoreVersionLocalizationResponse } from '../models/AppStoreVersionLocalizationResponse.ts';
import { AppStoreVersionLocalizationUpdateRequest } from '../models/AppStoreVersionLocalizationUpdateRequest.ts';
import { AppStoreVersionLocalizationUpdateRequestData } from '../models/AppStoreVersionLocalizationUpdateRequestData.ts';
import { AppStoreVersionLocalizationUpdateRequestDataAttributes } from '../models/AppStoreVersionLocalizationUpdateRequestDataAttributes.ts';
import { AppStoreVersionLocalizationsResponse } from '../models/AppStoreVersionLocalizationsResponse.ts';
import { AppStoreVersionLocalizationsResponseIncludedInner } from '../models/AppStoreVersionLocalizationsResponseIncludedInner.ts';
import { AppStoreVersionPhasedRelease } from '../models/AppStoreVersionPhasedRelease.ts';
import { AppStoreVersionPhasedReleaseAttributes } from '../models/AppStoreVersionPhasedReleaseAttributes.ts';
import { AppStoreVersionPhasedReleaseCreateRequest } from '../models/AppStoreVersionPhasedReleaseCreateRequest.ts';
import { AppStoreVersionPhasedReleaseCreateRequestData } from '../models/AppStoreVersionPhasedReleaseCreateRequestData.ts';
import { AppStoreVersionPhasedReleaseCreateRequestDataAttributes } from '../models/AppStoreVersionPhasedReleaseCreateRequestDataAttributes.ts';
import { AppStoreVersionPhasedReleaseResponse } from '../models/AppStoreVersionPhasedReleaseResponse.ts';
import { AppStoreVersionPhasedReleaseUpdateRequest } from '../models/AppStoreVersionPhasedReleaseUpdateRequest.ts';
import { AppStoreVersionPhasedReleaseUpdateRequestData } from '../models/AppStoreVersionPhasedReleaseUpdateRequestData.ts';
import { AppStoreVersionPhasedReleaseWithoutIncludesResponse } from '../models/AppStoreVersionPhasedReleaseWithoutIncludesResponse.ts';
import { AppStoreVersionPromotion } from '../models/AppStoreVersionPromotion.ts';
import { AppStoreVersionPromotionCreateRequest } from '../models/AppStoreVersionPromotionCreateRequest.ts';
import { AppStoreVersionPromotionCreateRequestData } from '../models/AppStoreVersionPromotionCreateRequestData.ts';
import { AppStoreVersionPromotionCreateRequestDataRelationships } from '../models/AppStoreVersionPromotionCreateRequestDataRelationships.ts';
import { AppStoreVersionPromotionResponse } from '../models/AppStoreVersionPromotionResponse.ts';
import { AppStoreVersionRelationships } from '../models/AppStoreVersionRelationships.ts';
import { AppStoreVersionRelationshipsAgeRatingDeclaration } from '../models/AppStoreVersionRelationshipsAgeRatingDeclaration.ts';
import { AppStoreVersionRelationshipsAppStoreVersionExperiments } from '../models/AppStoreVersionRelationshipsAppStoreVersionExperiments.ts';
import { AppStoreVersionRelationshipsAppStoreVersionLocalizations } from '../models/AppStoreVersionRelationshipsAppStoreVersionLocalizations.ts';
import { AppStoreVersionRelationshipsAppStoreVersionPhasedRelease } from '../models/AppStoreVersionRelationshipsAppStoreVersionPhasedRelease.ts';
import { AppStoreVersionRelationshipsAppStoreVersionPhasedReleaseData } from '../models/AppStoreVersionRelationshipsAppStoreVersionPhasedReleaseData.ts';
import { AppStoreVersionRelationshipsAppStoreVersionSubmission } from '../models/AppStoreVersionRelationshipsAppStoreVersionSubmission.ts';
import { AppStoreVersionRelationshipsAppStoreVersionSubmissionData } from '../models/AppStoreVersionRelationshipsAppStoreVersionSubmissionData.ts';
import { AppStoreVersionRelationshipsBuild } from '../models/AppStoreVersionRelationshipsBuild.ts';
import { AppStoreVersionRelationshipsRoutingAppCoverage } from '../models/AppStoreVersionRelationshipsRoutingAppCoverage.ts';
import { AppStoreVersionRelationshipsRoutingAppCoverageData } from '../models/AppStoreVersionRelationshipsRoutingAppCoverageData.ts';
import { AppStoreVersionReleaseRequest } from '../models/AppStoreVersionReleaseRequest.ts';
import { AppStoreVersionReleaseRequestCreateRequest } from '../models/AppStoreVersionReleaseRequestCreateRequest.ts';
import { AppStoreVersionReleaseRequestCreateRequestData } from '../models/AppStoreVersionReleaseRequestCreateRequestData.ts';
import { AppStoreVersionReleaseRequestResponse } from '../models/AppStoreVersionReleaseRequestResponse.ts';
import { AppStoreVersionResponse } from '../models/AppStoreVersionResponse.ts';
import { AppStoreVersionState } from '../models/AppStoreVersionState.ts';
import { AppStoreVersionSubmission } from '../models/AppStoreVersionSubmission.ts';
import { AppStoreVersionSubmissionCreateRequest } from '../models/AppStoreVersionSubmissionCreateRequest.ts';
import { AppStoreVersionSubmissionCreateRequestData } from '../models/AppStoreVersionSubmissionCreateRequestData.ts';
import { AppStoreVersionSubmissionRelationships } from '../models/AppStoreVersionSubmissionRelationships.ts';
import { AppStoreVersionSubmissionResponse } from '../models/AppStoreVersionSubmissionResponse.ts';
import { AppStoreVersionUpdateRequest } from '../models/AppStoreVersionUpdateRequest.ts';
import { AppStoreVersionUpdateRequestData } from '../models/AppStoreVersionUpdateRequestData.ts';
import { AppStoreVersionUpdateRequestDataAttributes } from '../models/AppStoreVersionUpdateRequestDataAttributes.ts';
import { AppStoreVersionUpdateRequestDataRelationships } from '../models/AppStoreVersionUpdateRequestDataRelationships.ts';
import { AppStoreVersionsResponse } from '../models/AppStoreVersionsResponse.ts';
import { AppStoreVersionsResponseIncludedInner } from '../models/AppStoreVersionsResponseIncludedInner.ts';
import { AppUpdateRequest } from '../models/AppUpdateRequest.ts';
import { AppUpdateRequestData } from '../models/AppUpdateRequestData.ts';
import { AppUpdateRequestDataAttributes } from '../models/AppUpdateRequestDataAttributes.ts';
import { AppUpdateRequestDataRelationships } from '../models/AppUpdateRequestDataRelationships.ts';
import { AppUpdateRequestDataRelationshipsAvailableTerritories } from '../models/AppUpdateRequestDataRelationshipsAvailableTerritories.ts';
import { AppUpdateRequestDataRelationshipsPrices } from '../models/AppUpdateRequestDataRelationshipsPrices.ts';
import { AppVersionState } from '../models/AppVersionState.ts';
import { AppWithoutIncludesResponse } from '../models/AppWithoutIncludesResponse.ts';
import { AppsBetaTesterUsagesV1MetricResponse } from '../models/AppsBetaTesterUsagesV1MetricResponse.ts';
import { AppsBetaTesterUsagesV1MetricResponseDataInner } from '../models/AppsBetaTesterUsagesV1MetricResponseDataInner.ts';
import { AppsBetaTesterUsagesV1MetricResponseDataInnerDataPoints } from '../models/AppsBetaTesterUsagesV1MetricResponseDataInnerDataPoints.ts';
import { AppsBetaTesterUsagesV1MetricResponseDataInnerDataPointsValues } from '../models/AppsBetaTesterUsagesV1MetricResponseDataInnerDataPointsValues.ts';
import { AppsBetaTesterUsagesV1MetricResponseDataInnerDimensions } from '../models/AppsBetaTesterUsagesV1MetricResponseDataInnerDimensions.ts';
import { AppsBetaTesterUsagesV1MetricResponseDataInnerDimensionsBetaTesters } from '../models/AppsBetaTesterUsagesV1MetricResponseDataInnerDimensionsBetaTesters.ts';
import { AppsBetaTesterUsagesV1MetricResponseDataInnerDimensionsBetaTestersLinks } from '../models/AppsBetaTesterUsagesV1MetricResponseDataInnerDimensionsBetaTestersLinks.ts';
import { AppsResponse } from '../models/AppsResponse.ts';
import { AppsResponseIncludedInner } from '../models/AppsResponseIncludedInner.ts';
import { AppsWithoutIncludesResponse } from '../models/AppsWithoutIncludesResponse.ts';
import { BetaAppClipInvocation } from '../models/BetaAppClipInvocation.ts';
import { BetaAppClipInvocationAttributes } from '../models/BetaAppClipInvocationAttributes.ts';
import { BetaAppClipInvocationCreateRequest } from '../models/BetaAppClipInvocationCreateRequest.ts';
import { BetaAppClipInvocationCreateRequestData } from '../models/BetaAppClipInvocationCreateRequestData.ts';
import { BetaAppClipInvocationCreateRequestDataAttributes } from '../models/BetaAppClipInvocationCreateRequestDataAttributes.ts';
import { BetaAppClipInvocationCreateRequestDataRelationships } from '../models/BetaAppClipInvocationCreateRequestDataRelationships.ts';
import { BetaAppClipInvocationCreateRequestDataRelationshipsBetaAppClipInvocationLocalizations } from '../models/BetaAppClipInvocationCreateRequestDataRelationshipsBetaAppClipInvocationLocalizations.ts';
import { BetaAppClipInvocationCreateRequestDataRelationshipsBuildBundle } from '../models/BetaAppClipInvocationCreateRequestDataRelationshipsBuildBundle.ts';
import { BetaAppClipInvocationCreateRequestDataRelationshipsBuildBundleData } from '../models/BetaAppClipInvocationCreateRequestDataRelationshipsBuildBundleData.ts';
import { BetaAppClipInvocationLocalization } from '../models/BetaAppClipInvocationLocalization.ts';
import { BetaAppClipInvocationLocalizationAttributes } from '../models/BetaAppClipInvocationLocalizationAttributes.ts';
import { BetaAppClipInvocationLocalizationCreateRequest } from '../models/BetaAppClipInvocationLocalizationCreateRequest.ts';
import { BetaAppClipInvocationLocalizationCreateRequestData } from '../models/BetaAppClipInvocationLocalizationCreateRequestData.ts';
import { BetaAppClipInvocationLocalizationCreateRequestDataRelationships } from '../models/BetaAppClipInvocationLocalizationCreateRequestDataRelationships.ts';
import { BetaAppClipInvocationLocalizationCreateRequestDataRelationshipsBetaAppClipInvocation } from '../models/BetaAppClipInvocationLocalizationCreateRequestDataRelationshipsBetaAppClipInvocation.ts';
import { BetaAppClipInvocationLocalizationInlineCreate } from '../models/BetaAppClipInvocationLocalizationInlineCreate.ts';
import { BetaAppClipInvocationLocalizationInlineCreateAttributes } from '../models/BetaAppClipInvocationLocalizationInlineCreateAttributes.ts';
import { BetaAppClipInvocationLocalizationInlineCreateRelationships } from '../models/BetaAppClipInvocationLocalizationInlineCreateRelationships.ts';
import { BetaAppClipInvocationLocalizationInlineCreateRelationshipsBetaAppClipInvocation } from '../models/BetaAppClipInvocationLocalizationInlineCreateRelationshipsBetaAppClipInvocation.ts';
import { BetaAppClipInvocationLocalizationInlineCreateRelationshipsBetaAppClipInvocationData } from '../models/BetaAppClipInvocationLocalizationInlineCreateRelationshipsBetaAppClipInvocationData.ts';
import { BetaAppClipInvocationLocalizationResponse } from '../models/BetaAppClipInvocationLocalizationResponse.ts';
import { BetaAppClipInvocationLocalizationUpdateRequest } from '../models/BetaAppClipInvocationLocalizationUpdateRequest.ts';
import { BetaAppClipInvocationLocalizationUpdateRequestData } from '../models/BetaAppClipInvocationLocalizationUpdateRequestData.ts';
import { BetaAppClipInvocationLocalizationUpdateRequestDataAttributes } from '../models/BetaAppClipInvocationLocalizationUpdateRequestDataAttributes.ts';
import { BetaAppClipInvocationRelationships } from '../models/BetaAppClipInvocationRelationships.ts';
import { BetaAppClipInvocationRelationshipsBetaAppClipInvocationLocalizations } from '../models/BetaAppClipInvocationRelationshipsBetaAppClipInvocationLocalizations.ts';
import { BetaAppClipInvocationRelationshipsBetaAppClipInvocationLocalizationsDataInner } from '../models/BetaAppClipInvocationRelationshipsBetaAppClipInvocationLocalizationsDataInner.ts';
import { BetaAppClipInvocationResponse } from '../models/BetaAppClipInvocationResponse.ts';
import { BetaAppClipInvocationUpdateRequest } from '../models/BetaAppClipInvocationUpdateRequest.ts';
import { BetaAppClipInvocationUpdateRequestData } from '../models/BetaAppClipInvocationUpdateRequestData.ts';
import { BetaAppClipInvocationsResponse } from '../models/BetaAppClipInvocationsResponse.ts';
import { BetaAppLocalization } from '../models/BetaAppLocalization.ts';
import { BetaAppLocalizationAttributes } from '../models/BetaAppLocalizationAttributes.ts';
import { BetaAppLocalizationCreateRequest } from '../models/BetaAppLocalizationCreateRequest.ts';
import { BetaAppLocalizationCreateRequestData } from '../models/BetaAppLocalizationCreateRequestData.ts';
import { BetaAppLocalizationCreateRequestDataAttributes } from '../models/BetaAppLocalizationCreateRequestDataAttributes.ts';
import { BetaAppLocalizationResponse } from '../models/BetaAppLocalizationResponse.ts';
import { BetaAppLocalizationUpdateRequest } from '../models/BetaAppLocalizationUpdateRequest.ts';
import { BetaAppLocalizationUpdateRequestData } from '../models/BetaAppLocalizationUpdateRequestData.ts';
import { BetaAppLocalizationUpdateRequestDataAttributes } from '../models/BetaAppLocalizationUpdateRequestDataAttributes.ts';
import { BetaAppLocalizationsResponse } from '../models/BetaAppLocalizationsResponse.ts';
import { BetaAppLocalizationsWithoutIncludesResponse } from '../models/BetaAppLocalizationsWithoutIncludesResponse.ts';
import { BetaAppReviewDetail } from '../models/BetaAppReviewDetail.ts';
import { BetaAppReviewDetailResponse } from '../models/BetaAppReviewDetailResponse.ts';
import { BetaAppReviewDetailUpdateRequest } from '../models/BetaAppReviewDetailUpdateRequest.ts';
import { BetaAppReviewDetailUpdateRequestData } from '../models/BetaAppReviewDetailUpdateRequestData.ts';
import { BetaAppReviewDetailWithoutIncludesResponse } from '../models/BetaAppReviewDetailWithoutIncludesResponse.ts';
import { BetaAppReviewDetailsResponse } from '../models/BetaAppReviewDetailsResponse.ts';
import { BetaAppReviewSubmission } from '../models/BetaAppReviewSubmission.ts';
import { BetaAppReviewSubmissionAttributes } from '../models/BetaAppReviewSubmissionAttributes.ts';
import { BetaAppReviewSubmissionCreateRequest } from '../models/BetaAppReviewSubmissionCreateRequest.ts';
import { BetaAppReviewSubmissionCreateRequestData } from '../models/BetaAppReviewSubmissionCreateRequestData.ts';
import { BetaAppReviewSubmissionCreateRequestDataRelationships } from '../models/BetaAppReviewSubmissionCreateRequestDataRelationships.ts';
import { BetaAppReviewSubmissionCreateRequestDataRelationshipsBuild } from '../models/BetaAppReviewSubmissionCreateRequestDataRelationshipsBuild.ts';
import { BetaAppReviewSubmissionRelationships } from '../models/BetaAppReviewSubmissionRelationships.ts';
import { BetaAppReviewSubmissionResponse } from '../models/BetaAppReviewSubmissionResponse.ts';
import { BetaAppReviewSubmissionWithoutIncludesResponse } from '../models/BetaAppReviewSubmissionWithoutIncludesResponse.ts';
import { BetaAppReviewSubmissionsResponse } from '../models/BetaAppReviewSubmissionsResponse.ts';
import { BetaBuildLocalization } from '../models/BetaBuildLocalization.ts';
import { BetaBuildLocalizationAttributes } from '../models/BetaBuildLocalizationAttributes.ts';
import { BetaBuildLocalizationCreateRequest } from '../models/BetaBuildLocalizationCreateRequest.ts';
import { BetaBuildLocalizationCreateRequestData } from '../models/BetaBuildLocalizationCreateRequestData.ts';
import { BetaBuildLocalizationCreateRequestDataAttributes } from '../models/BetaBuildLocalizationCreateRequestDataAttributes.ts';
import { BetaBuildLocalizationResponse } from '../models/BetaBuildLocalizationResponse.ts';
import { BetaBuildLocalizationUpdateRequest } from '../models/BetaBuildLocalizationUpdateRequest.ts';
import { BetaBuildLocalizationUpdateRequestData } from '../models/BetaBuildLocalizationUpdateRequestData.ts';
import { BetaBuildLocalizationUpdateRequestDataAttributes } from '../models/BetaBuildLocalizationUpdateRequestDataAttributes.ts';
import { BetaBuildLocalizationsResponse } from '../models/BetaBuildLocalizationsResponse.ts';
import { BetaBuildLocalizationsWithoutIncludesResponse } from '../models/BetaBuildLocalizationsWithoutIncludesResponse.ts';
import { BetaBuildUsagesV1MetricResponse } from '../models/BetaBuildUsagesV1MetricResponse.ts';
import { BetaBuildUsagesV1MetricResponseDataInner } from '../models/BetaBuildUsagesV1MetricResponseDataInner.ts';
import { BetaBuildUsagesV1MetricResponseDataInnerDataPoints } from '../models/BetaBuildUsagesV1MetricResponseDataInnerDataPoints.ts';
import { BetaBuildUsagesV1MetricResponseDataInnerDataPointsValues } from '../models/BetaBuildUsagesV1MetricResponseDataInnerDataPointsValues.ts';
import { BetaBuildUsagesV1MetricResponseDataInnerDimensions } from '../models/BetaBuildUsagesV1MetricResponseDataInnerDimensions.ts';
import { BetaBuildUsagesV1MetricResponseDataInnerDimensionsBundleIds } from '../models/BetaBuildUsagesV1MetricResponseDataInnerDimensionsBundleIds.ts';
import { BetaBuildUsagesV1MetricResponseDataInnerDimensionsBundleIdsLinks } from '../models/BetaBuildUsagesV1MetricResponseDataInnerDimensionsBundleIdsLinks.ts';
import { BetaGroup } from '../models/BetaGroup.ts';
import { BetaGroupAttributes } from '../models/BetaGroupAttributes.ts';
import { BetaGroupBetaTestersLinkagesRequest } from '../models/BetaGroupBetaTestersLinkagesRequest.ts';
import { BetaGroupBetaTestersLinkagesResponse } from '../models/BetaGroupBetaTestersLinkagesResponse.ts';
import { BetaGroupBuildsLinkagesRequest } from '../models/BetaGroupBuildsLinkagesRequest.ts';
import { BetaGroupBuildsLinkagesResponse } from '../models/BetaGroupBuildsLinkagesResponse.ts';
import { BetaGroupCreateRequest } from '../models/BetaGroupCreateRequest.ts';
import { BetaGroupCreateRequestData } from '../models/BetaGroupCreateRequestData.ts';
import { BetaGroupCreateRequestDataAttributes } from '../models/BetaGroupCreateRequestDataAttributes.ts';
import { BetaGroupCreateRequestDataRelationships } from '../models/BetaGroupCreateRequestDataRelationships.ts';
import { BetaGroupCreateRequestDataRelationshipsBetaTesters } from '../models/BetaGroupCreateRequestDataRelationshipsBetaTesters.ts';
import { BetaGroupCreateRequestDataRelationshipsBuilds } from '../models/BetaGroupCreateRequestDataRelationshipsBuilds.ts';
import { BetaGroupRelationships } from '../models/BetaGroupRelationships.ts';
import { BetaGroupRelationshipsBetaTesters } from '../models/BetaGroupRelationshipsBetaTesters.ts';
import { BetaGroupRelationshipsBetaTestersDataInner } from '../models/BetaGroupRelationshipsBetaTestersDataInner.ts';
import { BetaGroupResponse } from '../models/BetaGroupResponse.ts';
import { BetaGroupUpdateRequest } from '../models/BetaGroupUpdateRequest.ts';
import { BetaGroupUpdateRequestData } from '../models/BetaGroupUpdateRequestData.ts';
import { BetaGroupUpdateRequestDataAttributes } from '../models/BetaGroupUpdateRequestDataAttributes.ts';
import { BetaGroupsResponse } from '../models/BetaGroupsResponse.ts';
import { BetaGroupsResponseIncludedInner } from '../models/BetaGroupsResponseIncludedInner.ts';
import { BetaGroupsWithoutIncludesResponse } from '../models/BetaGroupsWithoutIncludesResponse.ts';
import { BetaInviteType } from '../models/BetaInviteType.ts';
import { BetaLicenseAgreement } from '../models/BetaLicenseAgreement.ts';
import { BetaLicenseAgreementAttributes } from '../models/BetaLicenseAgreementAttributes.ts';
import { BetaLicenseAgreementResponse } from '../models/BetaLicenseAgreementResponse.ts';
import { BetaLicenseAgreementUpdateRequest } from '../models/BetaLicenseAgreementUpdateRequest.ts';
import { BetaLicenseAgreementUpdateRequestData } from '../models/BetaLicenseAgreementUpdateRequestData.ts';
import { BetaLicenseAgreementWithoutIncludesResponse } from '../models/BetaLicenseAgreementWithoutIncludesResponse.ts';
import { BetaLicenseAgreementsResponse } from '../models/BetaLicenseAgreementsResponse.ts';
import { BetaReviewState } from '../models/BetaReviewState.ts';
import { BetaTester } from '../models/BetaTester.ts';
import { BetaTesterAppsLinkagesRequest } from '../models/BetaTesterAppsLinkagesRequest.ts';
import { BetaTesterAppsLinkagesResponse } from '../models/BetaTesterAppsLinkagesResponse.ts';
import { BetaTesterAttributes } from '../models/BetaTesterAttributes.ts';
import { BetaTesterBetaGroupsLinkagesRequest } from '../models/BetaTesterBetaGroupsLinkagesRequest.ts';
import { BetaTesterBetaGroupsLinkagesResponse } from '../models/BetaTesterBetaGroupsLinkagesResponse.ts';
import { BetaTesterBuildsLinkagesRequest } from '../models/BetaTesterBuildsLinkagesRequest.ts';
import { BetaTesterBuildsLinkagesResponse } from '../models/BetaTesterBuildsLinkagesResponse.ts';
import { BetaTesterCreateRequest } from '../models/BetaTesterCreateRequest.ts';
import { BetaTesterCreateRequestData } from '../models/BetaTesterCreateRequestData.ts';
import { BetaTesterCreateRequestDataAttributes } from '../models/BetaTesterCreateRequestDataAttributes.ts';
import { BetaTesterCreateRequestDataRelationships } from '../models/BetaTesterCreateRequestDataRelationships.ts';
import { BetaTesterCreateRequestDataRelationshipsBetaGroups } from '../models/BetaTesterCreateRequestDataRelationshipsBetaGroups.ts';
import { BetaTesterInvitation } from '../models/BetaTesterInvitation.ts';
import { BetaTesterInvitationCreateRequest } from '../models/BetaTesterInvitationCreateRequest.ts';
import { BetaTesterInvitationCreateRequestData } from '../models/BetaTesterInvitationCreateRequestData.ts';
import { BetaTesterInvitationCreateRequestDataRelationships } from '../models/BetaTesterInvitationCreateRequestDataRelationships.ts';
import { BetaTesterInvitationCreateRequestDataRelationshipsBetaTester } from '../models/BetaTesterInvitationCreateRequestDataRelationshipsBetaTester.ts';
import { BetaTesterInvitationResponse } from '../models/BetaTesterInvitationResponse.ts';
import { BetaTesterRelationships } from '../models/BetaTesterRelationships.ts';
import { BetaTesterRelationshipsApps } from '../models/BetaTesterRelationshipsApps.ts';
import { BetaTesterResponse } from '../models/BetaTesterResponse.ts';
import { BetaTesterUsagesV1MetricResponse } from '../models/BetaTesterUsagesV1MetricResponse.ts';
import { BetaTesterUsagesV1MetricResponseDataInner } from '../models/BetaTesterUsagesV1MetricResponseDataInner.ts';
import { BetaTesterUsagesV1MetricResponseDataInnerDimensions } from '../models/BetaTesterUsagesV1MetricResponseDataInnerDimensions.ts';
import { BetaTestersResponse } from '../models/BetaTestersResponse.ts';
import { BetaTestersResponseIncludedInner } from '../models/BetaTestersResponseIncludedInner.ts';
import { BetaTestersWithoutIncludesResponse } from '../models/BetaTestersWithoutIncludesResponse.ts';
import { BrazilAgeRating } from '../models/BrazilAgeRating.ts';
import { Build } from '../models/Build.ts';
import { BuildAppEncryptionDeclarationLinkageRequest } from '../models/BuildAppEncryptionDeclarationLinkageRequest.ts';
import { BuildAppEncryptionDeclarationLinkageResponse } from '../models/BuildAppEncryptionDeclarationLinkageResponse.ts';
import { BuildAttributes } from '../models/BuildAttributes.ts';
import { BuildAudienceType } from '../models/BuildAudienceType.ts';
import { BuildBetaDetail } from '../models/BuildBetaDetail.ts';
import { BuildBetaDetailAttributes } from '../models/BuildBetaDetailAttributes.ts';
import { BuildBetaDetailResponse } from '../models/BuildBetaDetailResponse.ts';
import { BuildBetaDetailUpdateRequest } from '../models/BuildBetaDetailUpdateRequest.ts';
import { BuildBetaDetailUpdateRequestData } from '../models/BuildBetaDetailUpdateRequestData.ts';
import { BuildBetaDetailUpdateRequestDataAttributes } from '../models/BuildBetaDetailUpdateRequestDataAttributes.ts';
import { BuildBetaDetailsResponse } from '../models/BuildBetaDetailsResponse.ts';
import { BuildBetaGroupsLinkagesRequest } from '../models/BuildBetaGroupsLinkagesRequest.ts';
import { BuildBetaNotification } from '../models/BuildBetaNotification.ts';
import { BuildBetaNotificationCreateRequest } from '../models/BuildBetaNotificationCreateRequest.ts';
import { BuildBetaNotificationCreateRequestData } from '../models/BuildBetaNotificationCreateRequestData.ts';
import { BuildBetaNotificationResponse } from '../models/BuildBetaNotificationResponse.ts';
import { BuildBundle } from '../models/BuildBundle.ts';
import { BuildBundleAttributes } from '../models/BuildBundleAttributes.ts';
import { BuildBundleFileSize } from '../models/BuildBundleFileSize.ts';
import { BuildBundleFileSizeAttributes } from '../models/BuildBundleFileSizeAttributes.ts';
import { BuildBundleFileSizesResponse } from '../models/BuildBundleFileSizesResponse.ts';
import { BuildBundleRelationships } from '../models/BuildBundleRelationships.ts';
import { BuildBundleRelationshipsAppClipDomainCacheStatus } from '../models/BuildBundleRelationshipsAppClipDomainCacheStatus.ts';
import { BuildBundleRelationshipsAppClipDomainCacheStatusData } from '../models/BuildBundleRelationshipsAppClipDomainCacheStatusData.ts';
import { BuildBundleRelationshipsBetaAppClipInvocations } from '../models/BuildBundleRelationshipsBetaAppClipInvocations.ts';
import { BuildBundleRelationshipsBuildBundleFileSizes } from '../models/BuildBundleRelationshipsBuildBundleFileSizes.ts';
import { BuildBundleRelationshipsBuildBundleFileSizesDataInner } from '../models/BuildBundleRelationshipsBuildBundleFileSizesDataInner.ts';
import { BuildIcon } from '../models/BuildIcon.ts';
import { BuildIconAttributes } from '../models/BuildIconAttributes.ts';
import { BuildIconsResponse } from '../models/BuildIconsResponse.ts';
import { BuildIconsWithoutIncludesResponse } from '../models/BuildIconsWithoutIncludesResponse.ts';
import { BuildIndividualTestersLinkagesRequest } from '../models/BuildIndividualTestersLinkagesRequest.ts';
import { BuildIndividualTestersLinkagesResponse } from '../models/BuildIndividualTestersLinkagesResponse.ts';
import { BuildRelationships } from '../models/BuildRelationships.ts';
import { BuildRelationshipsAppEncryptionDeclaration } from '../models/BuildRelationshipsAppEncryptionDeclaration.ts';
import { BuildRelationshipsBetaAppReviewSubmission } from '../models/BuildRelationshipsBetaAppReviewSubmission.ts';
import { BuildRelationshipsBetaAppReviewSubmissionData } from '../models/BuildRelationshipsBetaAppReviewSubmissionData.ts';
import { BuildRelationshipsBetaBuildLocalizations } from '../models/BuildRelationshipsBetaBuildLocalizations.ts';
import { BuildRelationshipsBetaBuildLocalizationsDataInner } from '../models/BuildRelationshipsBetaBuildLocalizationsDataInner.ts';
import { BuildRelationshipsBuildBetaDetail } from '../models/BuildRelationshipsBuildBetaDetail.ts';
import { BuildRelationshipsBuildBetaDetailData } from '../models/BuildRelationshipsBuildBetaDetailData.ts';
import { BuildRelationshipsBuildBundles } from '../models/BuildRelationshipsBuildBundles.ts';
import { BuildRelationshipsIcons } from '../models/BuildRelationshipsIcons.ts';
import { BuildRelationshipsIconsDataInner } from '../models/BuildRelationshipsIconsDataInner.ts';
import { BuildRelationshipsPreReleaseVersion } from '../models/BuildRelationshipsPreReleaseVersion.ts';
import { BuildResponse } from '../models/BuildResponse.ts';
import { BuildUpdateRequest } from '../models/BuildUpdateRequest.ts';
import { BuildUpdateRequestData } from '../models/BuildUpdateRequestData.ts';
import { BuildUpdateRequestDataAttributes } from '../models/BuildUpdateRequestDataAttributes.ts';
import { BuildUpdateRequestDataRelationships } from '../models/BuildUpdateRequestDataRelationships.ts';
import { BuildUpdateRequestDataRelationshipsAppEncryptionDeclaration } from '../models/BuildUpdateRequestDataRelationshipsAppEncryptionDeclaration.ts';
import { BuildWithoutIncludesResponse } from '../models/BuildWithoutIncludesResponse.ts';
import { BuildsResponse } from '../models/BuildsResponse.ts';
import { BuildsResponseIncludedInner } from '../models/BuildsResponseIncludedInner.ts';
import { BuildsWithoutIncludesResponse } from '../models/BuildsWithoutIncludesResponse.ts';
import { BundleId } from '../models/BundleId.ts';
import { BundleIdAttributes } from '../models/BundleIdAttributes.ts';
import { BundleIdCapabilitiesResponse } from '../models/BundleIdCapabilitiesResponse.ts';
import { BundleIdCapabilitiesWithoutIncludesResponse } from '../models/BundleIdCapabilitiesWithoutIncludesResponse.ts';
import { BundleIdCapability } from '../models/BundleIdCapability.ts';
import { BundleIdCapabilityAttributes } from '../models/BundleIdCapabilityAttributes.ts';
import { BundleIdCapabilityCreateRequest } from '../models/BundleIdCapabilityCreateRequest.ts';
import { BundleIdCapabilityCreateRequestData } from '../models/BundleIdCapabilityCreateRequestData.ts';
import { BundleIdCapabilityCreateRequestDataAttributes } from '../models/BundleIdCapabilityCreateRequestDataAttributes.ts';
import { BundleIdCapabilityCreateRequestDataRelationships } from '../models/BundleIdCapabilityCreateRequestDataRelationships.ts';
import { BundleIdCapabilityCreateRequestDataRelationshipsBundleId } from '../models/BundleIdCapabilityCreateRequestDataRelationshipsBundleId.ts';
import { BundleIdCapabilityCreateRequestDataRelationshipsBundleIdData } from '../models/BundleIdCapabilityCreateRequestDataRelationshipsBundleIdData.ts';
import { BundleIdCapabilityResponse } from '../models/BundleIdCapabilityResponse.ts';
import { BundleIdCapabilityUpdateRequest } from '../models/BundleIdCapabilityUpdateRequest.ts';
import { BundleIdCapabilityUpdateRequestData } from '../models/BundleIdCapabilityUpdateRequestData.ts';
import { BundleIdCreateRequest } from '../models/BundleIdCreateRequest.ts';
import { BundleIdCreateRequestData } from '../models/BundleIdCreateRequestData.ts';
import { BundleIdCreateRequestDataAttributes } from '../models/BundleIdCreateRequestDataAttributes.ts';
import { BundleIdPlatform } from '../models/BundleIdPlatform.ts';
import { BundleIdRelationships } from '../models/BundleIdRelationships.ts';
import { BundleIdRelationshipsBundleIdCapabilities } from '../models/BundleIdRelationshipsBundleIdCapabilities.ts';
import { BundleIdRelationshipsBundleIdCapabilitiesDataInner } from '../models/BundleIdRelationshipsBundleIdCapabilitiesDataInner.ts';
import { BundleIdRelationshipsProfiles } from '../models/BundleIdRelationshipsProfiles.ts';
import { BundleIdRelationshipsProfilesDataInner } from '../models/BundleIdRelationshipsProfilesDataInner.ts';
import { BundleIdResponse } from '../models/BundleIdResponse.ts';
import { BundleIdUpdateRequest } from '../models/BundleIdUpdateRequest.ts';
import { BundleIdUpdateRequestData } from '../models/BundleIdUpdateRequestData.ts';
import { BundleIdUpdateRequestDataAttributes } from '../models/BundleIdUpdateRequestDataAttributes.ts';
import { BundleIdWithoutIncludesResponse } from '../models/BundleIdWithoutIncludesResponse.ts';
import { BundleIdsResponse } from '../models/BundleIdsResponse.ts';
import { BundleIdsResponseIncludedInner } from '../models/BundleIdsResponseIncludedInner.ts';
import { CapabilityOption } from '../models/CapabilityOption.ts';
import { CapabilitySetting } from '../models/CapabilitySetting.ts';
import { CapabilityType } from '../models/CapabilityType.ts';
import { Certificate } from '../models/Certificate.ts';
import { CertificateAttributes } from '../models/CertificateAttributes.ts';
import { CertificateCreateRequest } from '../models/CertificateCreateRequest.ts';
import { CertificateCreateRequestData } from '../models/CertificateCreateRequestData.ts';
import { CertificateCreateRequestDataAttributes } from '../models/CertificateCreateRequestDataAttributes.ts';
import { CertificateResponse } from '../models/CertificateResponse.ts';
import { CertificateType } from '../models/CertificateType.ts';
import { CertificatesResponse } from '../models/CertificatesResponse.ts';
import { CertificatesWithoutIncludesResponse } from '../models/CertificatesWithoutIncludesResponse.ts';
import { CiAction } from '../models/CiAction.ts';
import { CiActionTestConfiguration } from '../models/CiActionTestConfiguration.ts';
import { CiActionType } from '../models/CiActionType.ts';
import { CiArtifact } from '../models/CiArtifact.ts';
import { CiArtifactAttributes } from '../models/CiArtifactAttributes.ts';
import { CiArtifactResponse } from '../models/CiArtifactResponse.ts';
import { CiArtifactsResponse } from '../models/CiArtifactsResponse.ts';
import { CiBranchPatterns } from '../models/CiBranchPatterns.ts';
import { CiBranchPatternsPatternsInner } from '../models/CiBranchPatternsPatternsInner.ts';
import { CiBranchStartCondition } from '../models/CiBranchStartCondition.ts';
import { CiBuildAction } from '../models/CiBuildAction.ts';
import { CiBuildActionAttributes } from '../models/CiBuildActionAttributes.ts';
import { CiBuildActionRelationships } from '../models/CiBuildActionRelationships.ts';
import { CiBuildActionRelationshipsBuildRun } from '../models/CiBuildActionRelationshipsBuildRun.ts';
import { CiBuildActionRelationshipsBuildRunData } from '../models/CiBuildActionRelationshipsBuildRunData.ts';
import { CiBuildActionResponse } from '../models/CiBuildActionResponse.ts';
import { CiBuildActionsResponse } from '../models/CiBuildActionsResponse.ts';
import { CiBuildRun } from '../models/CiBuildRun.ts';
import { CiBuildRunAttributes } from '../models/CiBuildRunAttributes.ts';
import { CiBuildRunAttributesSourceCommit } from '../models/CiBuildRunAttributesSourceCommit.ts';
import { CiBuildRunCreateRequest } from '../models/CiBuildRunCreateRequest.ts';
import { CiBuildRunCreateRequestData } from '../models/CiBuildRunCreateRequestData.ts';
import { CiBuildRunCreateRequestDataAttributes } from '../models/CiBuildRunCreateRequestDataAttributes.ts';
import { CiBuildRunCreateRequestDataRelationships } from '../models/CiBuildRunCreateRequestDataRelationships.ts';
import { CiBuildRunCreateRequestDataRelationshipsBuildRun } from '../models/CiBuildRunCreateRequestDataRelationshipsBuildRun.ts';
import { CiBuildRunCreateRequestDataRelationshipsPullRequest } from '../models/CiBuildRunCreateRequestDataRelationshipsPullRequest.ts';
import { CiBuildRunCreateRequestDataRelationshipsSourceBranchOrTag } from '../models/CiBuildRunCreateRequestDataRelationshipsSourceBranchOrTag.ts';
import { CiBuildRunCreateRequestDataRelationshipsWorkflow } from '../models/CiBuildRunCreateRequestDataRelationshipsWorkflow.ts';
import { CiBuildRunRelationships } from '../models/CiBuildRunRelationships.ts';
import { CiBuildRunRelationshipsPullRequest } from '../models/CiBuildRunRelationshipsPullRequest.ts';
import { CiBuildRunRelationshipsPullRequestData } from '../models/CiBuildRunRelationshipsPullRequestData.ts';
import { CiBuildRunRelationshipsSourceBranchOrTag } from '../models/CiBuildRunRelationshipsSourceBranchOrTag.ts';
import { CiBuildRunRelationshipsSourceBranchOrTagData } from '../models/CiBuildRunRelationshipsSourceBranchOrTagData.ts';
import { CiBuildRunRelationshipsWorkflow } from '../models/CiBuildRunRelationshipsWorkflow.ts';
import { CiBuildRunRelationshipsWorkflowData } from '../models/CiBuildRunRelationshipsWorkflowData.ts';
import { CiBuildRunResponse } from '../models/CiBuildRunResponse.ts';
import { CiBuildRunsResponse } from '../models/CiBuildRunsResponse.ts';
import { CiBuildRunsResponseIncludedInner } from '../models/CiBuildRunsResponseIncludedInner.ts';
import { CiCompletionStatus } from '../models/CiCompletionStatus.ts';
import { CiExecutionProgress } from '../models/CiExecutionProgress.ts';
import { CiFilesAndFoldersRule } from '../models/CiFilesAndFoldersRule.ts';
import { CiGitRefKind } from '../models/CiGitRefKind.ts';
import { CiGitUser } from '../models/CiGitUser.ts';
import { CiIssue } from '../models/CiIssue.ts';
import { CiIssueAttributes } from '../models/CiIssueAttributes.ts';
import { CiIssueCounts } from '../models/CiIssueCounts.ts';
import { CiIssueResponse } from '../models/CiIssueResponse.ts';
import { CiIssuesResponse } from '../models/CiIssuesResponse.ts';
import { CiMacOsVersion } from '../models/CiMacOsVersion.ts';
import { CiMacOsVersionAttributes } from '../models/CiMacOsVersionAttributes.ts';
import { CiMacOsVersionRelationships } from '../models/CiMacOsVersionRelationships.ts';
import { CiMacOsVersionRelationshipsXcodeVersions } from '../models/CiMacOsVersionRelationshipsXcodeVersions.ts';
import { CiMacOsVersionRelationshipsXcodeVersionsDataInner } from '../models/CiMacOsVersionRelationshipsXcodeVersionsDataInner.ts';
import { CiMacOsVersionResponse } from '../models/CiMacOsVersionResponse.ts';
import { CiMacOsVersionsResponse } from '../models/CiMacOsVersionsResponse.ts';
import { CiManualBranchStartCondition } from '../models/CiManualBranchStartCondition.ts';
import { CiManualPullRequestStartCondition } from '../models/CiManualPullRequestStartCondition.ts';
import { CiManualTagStartCondition } from '../models/CiManualTagStartCondition.ts';
import { CiProduct } from '../models/CiProduct.ts';
import { CiProductAttributes } from '../models/CiProductAttributes.ts';
import { CiProductRelationships } from '../models/CiProductRelationships.ts';
import { CiProductRelationshipsBundleId } from '../models/CiProductRelationshipsBundleId.ts';
import { CiProductRelationshipsPrimaryRepositories } from '../models/CiProductRelationshipsPrimaryRepositories.ts';
import { CiProductRelationshipsPrimaryRepositoriesDataInner } from '../models/CiProductRelationshipsPrimaryRepositoriesDataInner.ts';
import { CiProductResponse } from '../models/CiProductResponse.ts';
import { CiProductsResponse } from '../models/CiProductsResponse.ts';
import { CiProductsResponseIncludedInner } from '../models/CiProductsResponseIncludedInner.ts';
import { CiPullRequestStartCondition } from '../models/CiPullRequestStartCondition.ts';
import { CiScheduledStartCondition } from '../models/CiScheduledStartCondition.ts';
import { CiScheduledStartConditionSchedule } from '../models/CiScheduledStartConditionSchedule.ts';
import { CiStartConditionFileMatcher } from '../models/CiStartConditionFileMatcher.ts';
import { CiTagPatterns } from '../models/CiTagPatterns.ts';
import { CiTagStartCondition } from '../models/CiTagStartCondition.ts';
import { CiTestDestination } from '../models/CiTestDestination.ts';
import { CiTestDestinationKind } from '../models/CiTestDestinationKind.ts';
import { CiTestResult } from '../models/CiTestResult.ts';
import { CiTestResultAttributes } from '../models/CiTestResultAttributes.ts';
import { CiTestResultAttributesDestinationTestResultsInner } from '../models/CiTestResultAttributesDestinationTestResultsInner.ts';
import { CiTestResultResponse } from '../models/CiTestResultResponse.ts';
import { CiTestResultsResponse } from '../models/CiTestResultsResponse.ts';
import { CiTestStatus } from '../models/CiTestStatus.ts';
import { CiWorkflow } from '../models/CiWorkflow.ts';
import { CiWorkflowAttributes } from '../models/CiWorkflowAttributes.ts';
import { CiWorkflowCreateRequest } from '../models/CiWorkflowCreateRequest.ts';
import { CiWorkflowCreateRequestData } from '../models/CiWorkflowCreateRequestData.ts';
import { CiWorkflowCreateRequestDataAttributes } from '../models/CiWorkflowCreateRequestDataAttributes.ts';
import { CiWorkflowCreateRequestDataRelationships } from '../models/CiWorkflowCreateRequestDataRelationships.ts';
import { CiWorkflowCreateRequestDataRelationshipsMacOsVersion } from '../models/CiWorkflowCreateRequestDataRelationshipsMacOsVersion.ts';
import { CiWorkflowCreateRequestDataRelationshipsProduct } from '../models/CiWorkflowCreateRequestDataRelationshipsProduct.ts';
import { CiWorkflowCreateRequestDataRelationshipsRepository } from '../models/CiWorkflowCreateRequestDataRelationshipsRepository.ts';
import { CiWorkflowCreateRequestDataRelationshipsXcodeVersion } from '../models/CiWorkflowCreateRequestDataRelationshipsXcodeVersion.ts';
import { CiWorkflowRelationships } from '../models/CiWorkflowRelationships.ts';
import { CiWorkflowRelationshipsMacOsVersion } from '../models/CiWorkflowRelationshipsMacOsVersion.ts';
import { CiWorkflowRelationshipsMacOsVersionData } from '../models/CiWorkflowRelationshipsMacOsVersionData.ts';
import { CiWorkflowRelationshipsRepository } from '../models/CiWorkflowRelationshipsRepository.ts';
import { CiWorkflowRelationshipsXcodeVersion } from '../models/CiWorkflowRelationshipsXcodeVersion.ts';
import { CiWorkflowResponse } from '../models/CiWorkflowResponse.ts';
import { CiWorkflowUpdateRequest } from '../models/CiWorkflowUpdateRequest.ts';
import { CiWorkflowUpdateRequestData } from '../models/CiWorkflowUpdateRequestData.ts';
import { CiWorkflowUpdateRequestDataAttributes } from '../models/CiWorkflowUpdateRequestDataAttributes.ts';
import { CiWorkflowUpdateRequestDataRelationships } from '../models/CiWorkflowUpdateRequestDataRelationships.ts';
import { CiWorkflowUpdateRequestDataRelationshipsMacOsVersion } from '../models/CiWorkflowUpdateRequestDataRelationshipsMacOsVersion.ts';
import { CiWorkflowUpdateRequestDataRelationshipsXcodeVersion } from '../models/CiWorkflowUpdateRequestDataRelationshipsXcodeVersion.ts';
import { CiWorkflowsResponse } from '../models/CiWorkflowsResponse.ts';
import { CiWorkflowsResponseIncludedInner } from '../models/CiWorkflowsResponseIncludedInner.ts';
import { CiXcodeVersion } from '../models/CiXcodeVersion.ts';
import { CiXcodeVersionAttributes } from '../models/CiXcodeVersionAttributes.ts';
import { CiXcodeVersionAttributesTestDestinationsInner } from '../models/CiXcodeVersionAttributesTestDestinationsInner.ts';
import { CiXcodeVersionAttributesTestDestinationsInnerAvailableRuntimesInner } from '../models/CiXcodeVersionAttributesTestDestinationsInnerAvailableRuntimesInner.ts';
import { CiXcodeVersionRelationships } from '../models/CiXcodeVersionRelationships.ts';
import { CiXcodeVersionRelationshipsMacOsVersions } from '../models/CiXcodeVersionRelationshipsMacOsVersions.ts';
import { CiXcodeVersionResponse } from '../models/CiXcodeVersionResponse.ts';
import { CiXcodeVersionsResponse } from '../models/CiXcodeVersionsResponse.ts';
import { CustomerReview } from '../models/CustomerReview.ts';
import { CustomerReviewAttributes } from '../models/CustomerReviewAttributes.ts';
import { CustomerReviewRelationships } from '../models/CustomerReviewRelationships.ts';
import { CustomerReviewRelationshipsResponse } from '../models/CustomerReviewRelationshipsResponse.ts';
import { CustomerReviewRelationshipsResponseData } from '../models/CustomerReviewRelationshipsResponseData.ts';
import { CustomerReviewResponse } from '../models/CustomerReviewResponse.ts';
import { CustomerReviewResponseV1 } from '../models/CustomerReviewResponseV1.ts';
import { CustomerReviewResponseV1Attributes } from '../models/CustomerReviewResponseV1Attributes.ts';
import { CustomerReviewResponseV1CreateRequest } from '../models/CustomerReviewResponseV1CreateRequest.ts';
import { CustomerReviewResponseV1CreateRequestData } from '../models/CustomerReviewResponseV1CreateRequestData.ts';
import { CustomerReviewResponseV1CreateRequestDataAttributes } from '../models/CustomerReviewResponseV1CreateRequestDataAttributes.ts';
import { CustomerReviewResponseV1CreateRequestDataRelationships } from '../models/CustomerReviewResponseV1CreateRequestDataRelationships.ts';
import { CustomerReviewResponseV1CreateRequestDataRelationshipsReview } from '../models/CustomerReviewResponseV1CreateRequestDataRelationshipsReview.ts';
import { CustomerReviewResponseV1Relationships } from '../models/CustomerReviewResponseV1Relationships.ts';
import { CustomerReviewResponseV1RelationshipsReview } from '../models/CustomerReviewResponseV1RelationshipsReview.ts';
import { CustomerReviewResponseV1RelationshipsReviewData } from '../models/CustomerReviewResponseV1RelationshipsReviewData.ts';
import { CustomerReviewResponseV1Response } from '../models/CustomerReviewResponseV1Response.ts';
import { CustomerReviewsResponse } from '../models/CustomerReviewsResponse.ts';
import { Device } from '../models/Device.ts';
import { DeviceAttributes } from '../models/DeviceAttributes.ts';
import { DeviceCreateRequest } from '../models/DeviceCreateRequest.ts';
import { DeviceCreateRequestData } from '../models/DeviceCreateRequestData.ts';
import { DeviceCreateRequestDataAttributes } from '../models/DeviceCreateRequestDataAttributes.ts';
import { DeviceResponse } from '../models/DeviceResponse.ts';
import { DeviceUpdateRequest } from '../models/DeviceUpdateRequest.ts';
import { DeviceUpdateRequestData } from '../models/DeviceUpdateRequestData.ts';
import { DeviceUpdateRequestDataAttributes } from '../models/DeviceUpdateRequestDataAttributes.ts';
import { DevicesResponse } from '../models/DevicesResponse.ts';
import { DevicesWithoutIncludesResponse } from '../models/DevicesWithoutIncludesResponse.ts';
import { DiagnosticLog } from '../models/DiagnosticLog.ts';
import { DiagnosticLogCallStackNode } from '../models/DiagnosticLogCallStackNode.ts';
import { DiagnosticLogs } from '../models/DiagnosticLogs.ts';
import { DiagnosticLogsProductDataInner } from '../models/DiagnosticLogsProductDataInner.ts';
import { DiagnosticLogsProductDataInnerDiagnosticInsightsInner } from '../models/DiagnosticLogsProductDataInnerDiagnosticInsightsInner.ts';
import { DiagnosticLogsProductDataInnerDiagnosticLogsInner } from '../models/DiagnosticLogsProductDataInnerDiagnosticLogsInner.ts';
import { DiagnosticLogsProductDataInnerDiagnosticLogsInnerCallStackTreeInner } from '../models/DiagnosticLogsProductDataInnerDiagnosticLogsInnerCallStackTreeInner.ts';
import { DiagnosticLogsProductDataInnerDiagnosticLogsInnerCallStackTreeInnerCallStacksInner } from '../models/DiagnosticLogsProductDataInnerDiagnosticLogsInnerCallStackTreeInnerCallStacksInner.ts';
import { DiagnosticLogsProductDataInnerDiagnosticLogsInnerDiagnosticMetaData } from '../models/DiagnosticLogsProductDataInnerDiagnosticLogsInnerDiagnosticMetaData.ts';
import { DiagnosticSignature } from '../models/DiagnosticSignature.ts';
import { DiagnosticSignatureAttributes } from '../models/DiagnosticSignatureAttributes.ts';
import { DiagnosticSignaturesResponse } from '../models/DiagnosticSignaturesResponse.ts';
import { DocumentLinks } from '../models/DocumentLinks.ts';
import { EndAppAvailabilityPreOrder } from '../models/EndAppAvailabilityPreOrder.ts';
import { EndAppAvailabilityPreOrderCreateRequest } from '../models/EndAppAvailabilityPreOrderCreateRequest.ts';
import { EndAppAvailabilityPreOrderCreateRequestData } from '../models/EndAppAvailabilityPreOrderCreateRequestData.ts';
import { EndAppAvailabilityPreOrderCreateRequestDataRelationships } from '../models/EndAppAvailabilityPreOrderCreateRequestDataRelationships.ts';
import { EndAppAvailabilityPreOrderResponse } from '../models/EndAppAvailabilityPreOrderResponse.ts';
import { EndUserLicenseAgreement } from '../models/EndUserLicenseAgreement.ts';
import { EndUserLicenseAgreementCreateRequest } from '../models/EndUserLicenseAgreementCreateRequest.ts';
import { EndUserLicenseAgreementCreateRequestData } from '../models/EndUserLicenseAgreementCreateRequestData.ts';
import { EndUserLicenseAgreementCreateRequestDataAttributes } from '../models/EndUserLicenseAgreementCreateRequestDataAttributes.ts';
import { EndUserLicenseAgreementCreateRequestDataRelationships } from '../models/EndUserLicenseAgreementCreateRequestDataRelationships.ts';
import { EndUserLicenseAgreementRelationships } from '../models/EndUserLicenseAgreementRelationships.ts';
import { EndUserLicenseAgreementResponse } from '../models/EndUserLicenseAgreementResponse.ts';
import { EndUserLicenseAgreementUpdateRequest } from '../models/EndUserLicenseAgreementUpdateRequest.ts';
import { EndUserLicenseAgreementUpdateRequestData } from '../models/EndUserLicenseAgreementUpdateRequestData.ts';
import { EndUserLicenseAgreementUpdateRequestDataRelationships } from '../models/EndUserLicenseAgreementUpdateRequestDataRelationships.ts';
import { EndUserLicenseAgreementUpdateRequestDataRelationshipsTerritories } from '../models/EndUserLicenseAgreementUpdateRequestDataRelationshipsTerritories.ts';
import { EndUserLicenseAgreementWithoutIncludesResponse } from '../models/EndUserLicenseAgreementWithoutIncludesResponse.ts';
import { ErrorResponse } from '../models/ErrorResponse.ts';
import { ErrorResponseErrorsInner } from '../models/ErrorResponseErrorsInner.ts';
import { ErrorResponseErrorsInnerSource } from '../models/ErrorResponseErrorsInnerSource.ts';
import { ErrorSourceParameter } from '../models/ErrorSourceParameter.ts';
import { ErrorSourcePointer } from '../models/ErrorSourcePointer.ts';
import { ExternalBetaState } from '../models/ExternalBetaState.ts';
import { FileLocation } from '../models/FileLocation.ts';
import { GameCenterAchievement } from '../models/GameCenterAchievement.ts';
import { GameCenterAchievementAttributes } from '../models/GameCenterAchievementAttributes.ts';
import { GameCenterAchievementCreateRequest } from '../models/GameCenterAchievementCreateRequest.ts';
import { GameCenterAchievementCreateRequestData } from '../models/GameCenterAchievementCreateRequestData.ts';
import { GameCenterAchievementCreateRequestDataAttributes } from '../models/GameCenterAchievementCreateRequestDataAttributes.ts';
import { GameCenterAchievementCreateRequestDataRelationships } from '../models/GameCenterAchievementCreateRequestDataRelationships.ts';
import { GameCenterAchievementCreateRequestDataRelationshipsGameCenterDetail } from '../models/GameCenterAchievementCreateRequestDataRelationshipsGameCenterDetail.ts';
import { GameCenterAchievementCreateRequestDataRelationshipsGameCenterGroup } from '../models/GameCenterAchievementCreateRequestDataRelationshipsGameCenterGroup.ts';
import { GameCenterAchievementGroupAchievementLinkageRequest } from '../models/GameCenterAchievementGroupAchievementLinkageRequest.ts';
import { GameCenterAchievementGroupAchievementLinkageResponse } from '../models/GameCenterAchievementGroupAchievementLinkageResponse.ts';
import { GameCenterAchievementImage } from '../models/GameCenterAchievementImage.ts';
import { GameCenterAchievementImageAttributes } from '../models/GameCenterAchievementImageAttributes.ts';
import { GameCenterAchievementImageCreateRequest } from '../models/GameCenterAchievementImageCreateRequest.ts';
import { GameCenterAchievementImageCreateRequestData } from '../models/GameCenterAchievementImageCreateRequestData.ts';
import { GameCenterAchievementImageCreateRequestDataRelationships } from '../models/GameCenterAchievementImageCreateRequestDataRelationships.ts';
import { GameCenterAchievementImageCreateRequestDataRelationshipsGameCenterAchievementLocalization } from '../models/GameCenterAchievementImageCreateRequestDataRelationshipsGameCenterAchievementLocalization.ts';
import { GameCenterAchievementImageRelationships } from '../models/GameCenterAchievementImageRelationships.ts';
import { GameCenterAchievementImageRelationshipsGameCenterAchievementLocalization } from '../models/GameCenterAchievementImageRelationshipsGameCenterAchievementLocalization.ts';
import { GameCenterAchievementImageRelationshipsGameCenterAchievementLocalizationData } from '../models/GameCenterAchievementImageRelationshipsGameCenterAchievementLocalizationData.ts';
import { GameCenterAchievementImageResponse } from '../models/GameCenterAchievementImageResponse.ts';
import { GameCenterAchievementImageUpdateRequest } from '../models/GameCenterAchievementImageUpdateRequest.ts';
import { GameCenterAchievementImageUpdateRequestData } from '../models/GameCenterAchievementImageUpdateRequestData.ts';
import { GameCenterAchievementLocalization } from '../models/GameCenterAchievementLocalization.ts';
import { GameCenterAchievementLocalizationAttributes } from '../models/GameCenterAchievementLocalizationAttributes.ts';
import { GameCenterAchievementLocalizationCreateRequest } from '../models/GameCenterAchievementLocalizationCreateRequest.ts';
import { GameCenterAchievementLocalizationCreateRequestData } from '../models/GameCenterAchievementLocalizationCreateRequestData.ts';
import { GameCenterAchievementLocalizationCreateRequestDataAttributes } from '../models/GameCenterAchievementLocalizationCreateRequestDataAttributes.ts';
import { GameCenterAchievementLocalizationCreateRequestDataRelationships } from '../models/GameCenterAchievementLocalizationCreateRequestDataRelationships.ts';
import { GameCenterAchievementLocalizationCreateRequestDataRelationshipsGameCenterAchievement } from '../models/GameCenterAchievementLocalizationCreateRequestDataRelationshipsGameCenterAchievement.ts';
import { GameCenterAchievementLocalizationRelationships } from '../models/GameCenterAchievementLocalizationRelationships.ts';
import { GameCenterAchievementLocalizationRelationshipsGameCenterAchievement } from '../models/GameCenterAchievementLocalizationRelationshipsGameCenterAchievement.ts';
import { GameCenterAchievementLocalizationRelationshipsGameCenterAchievementData } from '../models/GameCenterAchievementLocalizationRelationshipsGameCenterAchievementData.ts';
import { GameCenterAchievementLocalizationRelationshipsGameCenterAchievementImage } from '../models/GameCenterAchievementLocalizationRelationshipsGameCenterAchievementImage.ts';
import { GameCenterAchievementLocalizationRelationshipsGameCenterAchievementImageData } from '../models/GameCenterAchievementLocalizationRelationshipsGameCenterAchievementImageData.ts';
import { GameCenterAchievementLocalizationResponse } from '../models/GameCenterAchievementLocalizationResponse.ts';
import { GameCenterAchievementLocalizationUpdateRequest } from '../models/GameCenterAchievementLocalizationUpdateRequest.ts';
import { GameCenterAchievementLocalizationUpdateRequestData } from '../models/GameCenterAchievementLocalizationUpdateRequestData.ts';
import { GameCenterAchievementLocalizationUpdateRequestDataAttributes } from '../models/GameCenterAchievementLocalizationUpdateRequestDataAttributes.ts';
import { GameCenterAchievementLocalizationsResponse } from '../models/GameCenterAchievementLocalizationsResponse.ts';
import { GameCenterAchievementLocalizationsResponseIncludedInner } from '../models/GameCenterAchievementLocalizationsResponseIncludedInner.ts';
import { GameCenterAchievementRelationships } from '../models/GameCenterAchievementRelationships.ts';
import { GameCenterAchievementRelationshipsGameCenterGroup } from '../models/GameCenterAchievementRelationshipsGameCenterGroup.ts';
import { GameCenterAchievementRelationshipsGameCenterGroupData } from '../models/GameCenterAchievementRelationshipsGameCenterGroupData.ts';
import { GameCenterAchievementRelationshipsLocalizations } from '../models/GameCenterAchievementRelationshipsLocalizations.ts';
import { GameCenterAchievementRelationshipsReleases } from '../models/GameCenterAchievementRelationshipsReleases.ts';
import { GameCenterAchievementRelationshipsReleasesDataInner } from '../models/GameCenterAchievementRelationshipsReleasesDataInner.ts';
import { GameCenterAchievementRelease } from '../models/GameCenterAchievementRelease.ts';
import { GameCenterAchievementReleaseAttributes } from '../models/GameCenterAchievementReleaseAttributes.ts';
import { GameCenterAchievementReleaseCreateRequest } from '../models/GameCenterAchievementReleaseCreateRequest.ts';
import { GameCenterAchievementReleaseCreateRequestData } from '../models/GameCenterAchievementReleaseCreateRequestData.ts';
import { GameCenterAchievementReleaseCreateRequestDataRelationships } from '../models/GameCenterAchievementReleaseCreateRequestDataRelationships.ts';
import { GameCenterAchievementReleaseCreateRequestDataRelationshipsGameCenterDetail } from '../models/GameCenterAchievementReleaseCreateRequestDataRelationshipsGameCenterDetail.ts';
import { GameCenterAchievementReleaseRelationships } from '../models/GameCenterAchievementReleaseRelationships.ts';
import { GameCenterAchievementReleaseResponse } from '../models/GameCenterAchievementReleaseResponse.ts';
import { GameCenterAchievementReleasesResponse } from '../models/GameCenterAchievementReleasesResponse.ts';
import { GameCenterAchievementReleasesResponseIncludedInner } from '../models/GameCenterAchievementReleasesResponseIncludedInner.ts';
import { GameCenterAchievementResponse } from '../models/GameCenterAchievementResponse.ts';
import { GameCenterAchievementUpdateRequest } from '../models/GameCenterAchievementUpdateRequest.ts';
import { GameCenterAchievementUpdateRequestData } from '../models/GameCenterAchievementUpdateRequestData.ts';
import { GameCenterAchievementUpdateRequestDataAttributes } from '../models/GameCenterAchievementUpdateRequestDataAttributes.ts';
import { GameCenterAchievementsResponse } from '../models/GameCenterAchievementsResponse.ts';
import { GameCenterAchievementsResponseIncludedInner } from '../models/GameCenterAchievementsResponseIncludedInner.ts';
import { GameCenterAppVersion } from '../models/GameCenterAppVersion.ts';
import { GameCenterAppVersionAttributes } from '../models/GameCenterAppVersionAttributes.ts';
import { GameCenterAppVersionCompatibilityVersionsLinkagesRequest } from '../models/GameCenterAppVersionCompatibilityVersionsLinkagesRequest.ts';
import { GameCenterAppVersionCompatibilityVersionsLinkagesResponse } from '../models/GameCenterAppVersionCompatibilityVersionsLinkagesResponse.ts';
import { GameCenterAppVersionCreateRequest } from '../models/GameCenterAppVersionCreateRequest.ts';
import { GameCenterAppVersionCreateRequestData } from '../models/GameCenterAppVersionCreateRequestData.ts';
import { GameCenterAppVersionRelationships } from '../models/GameCenterAppVersionRelationships.ts';
import { GameCenterAppVersionRelationshipsCompatibilityVersions } from '../models/GameCenterAppVersionRelationshipsCompatibilityVersions.ts';
import { GameCenterAppVersionRelationshipsCompatibilityVersionsDataInner } from '../models/GameCenterAppVersionRelationshipsCompatibilityVersionsDataInner.ts';
import { GameCenterAppVersionResponse } from '../models/GameCenterAppVersionResponse.ts';
import { GameCenterAppVersionUpdateRequest } from '../models/GameCenterAppVersionUpdateRequest.ts';
import { GameCenterAppVersionUpdateRequestData } from '../models/GameCenterAppVersionUpdateRequestData.ts';
import { GameCenterAppVersionsResponse } from '../models/GameCenterAppVersionsResponse.ts';
import { GameCenterAppVersionsResponseIncludedInner } from '../models/GameCenterAppVersionsResponseIncludedInner.ts';
import { GameCenterDetail } from '../models/GameCenterDetail.ts';
import { GameCenterDetailAttributes } from '../models/GameCenterDetailAttributes.ts';
import { GameCenterDetailCreateRequest } from '../models/GameCenterDetailCreateRequest.ts';
import { GameCenterDetailCreateRequestData } from '../models/GameCenterDetailCreateRequestData.ts';
import { GameCenterDetailCreateRequestDataAttributes } from '../models/GameCenterDetailCreateRequestDataAttributes.ts';
import { GameCenterDetailGameCenterAchievementsLinkagesRequest } from '../models/GameCenterDetailGameCenterAchievementsLinkagesRequest.ts';
import { GameCenterDetailGameCenterAchievementsLinkagesResponse } from '../models/GameCenterDetailGameCenterAchievementsLinkagesResponse.ts';
import { GameCenterDetailGameCenterLeaderboardSetsLinkagesRequest } from '../models/GameCenterDetailGameCenterLeaderboardSetsLinkagesRequest.ts';
import { GameCenterDetailGameCenterLeaderboardSetsLinkagesResponse } from '../models/GameCenterDetailGameCenterLeaderboardSetsLinkagesResponse.ts';
import { GameCenterDetailGameCenterLeaderboardsLinkagesRequest } from '../models/GameCenterDetailGameCenterLeaderboardsLinkagesRequest.ts';
import { GameCenterDetailGameCenterLeaderboardsLinkagesResponse } from '../models/GameCenterDetailGameCenterLeaderboardsLinkagesResponse.ts';
import { GameCenterDetailRelationships } from '../models/GameCenterDetailRelationships.ts';
import { GameCenterDetailRelationshipsDefaultLeaderboard } from '../models/GameCenterDetailRelationshipsDefaultLeaderboard.ts';
import { GameCenterDetailRelationshipsGameCenterAchievements } from '../models/GameCenterDetailRelationshipsGameCenterAchievements.ts';
import { GameCenterDetailRelationshipsGameCenterLeaderboardSets } from '../models/GameCenterDetailRelationshipsGameCenterLeaderboardSets.ts';
import { GameCenterDetailRelationshipsGameCenterLeaderboardSetsDataInner } from '../models/GameCenterDetailRelationshipsGameCenterLeaderboardSetsDataInner.ts';
import { GameCenterDetailRelationshipsGameCenterLeaderboards } from '../models/GameCenterDetailRelationshipsGameCenterLeaderboards.ts';
import { GameCenterDetailRelationshipsGameCenterLeaderboardsDataInner } from '../models/GameCenterDetailRelationshipsGameCenterLeaderboardsDataInner.ts';
import { GameCenterDetailRelationshipsLeaderboardReleases } from '../models/GameCenterDetailRelationshipsLeaderboardReleases.ts';
import { GameCenterDetailRelationshipsLeaderboardReleasesDataInner } from '../models/GameCenterDetailRelationshipsLeaderboardReleasesDataInner.ts';
import { GameCenterDetailRelationshipsLeaderboardSetReleases } from '../models/GameCenterDetailRelationshipsLeaderboardSetReleases.ts';
import { GameCenterDetailRelationshipsLeaderboardSetReleasesDataInner } from '../models/GameCenterDetailRelationshipsLeaderboardSetReleasesDataInner.ts';
import { GameCenterDetailResponse } from '../models/GameCenterDetailResponse.ts';
import { GameCenterDetailUpdateRequest } from '../models/GameCenterDetailUpdateRequest.ts';
import { GameCenterDetailUpdateRequestData } from '../models/GameCenterDetailUpdateRequestData.ts';
import { GameCenterDetailUpdateRequestDataRelationships } from '../models/GameCenterDetailUpdateRequestDataRelationships.ts';
import { GameCenterDetailUpdateRequestDataRelationshipsDefaultLeaderboard } from '../models/GameCenterDetailUpdateRequestDataRelationshipsDefaultLeaderboard.ts';
import { GameCenterDetailsResponse } from '../models/GameCenterDetailsResponse.ts';
import { GameCenterDetailsResponseIncludedInner } from '../models/GameCenterDetailsResponseIncludedInner.ts';
import { GameCenterEnabledVersion } from '../models/GameCenterEnabledVersion.ts';
import { GameCenterEnabledVersionAttributes } from '../models/GameCenterEnabledVersionAttributes.ts';
import { GameCenterEnabledVersionCompatibleVersionsLinkagesRequest } from '../models/GameCenterEnabledVersionCompatibleVersionsLinkagesRequest.ts';
import { GameCenterEnabledVersionCompatibleVersionsLinkagesResponse } from '../models/GameCenterEnabledVersionCompatibleVersionsLinkagesResponse.ts';
import { GameCenterEnabledVersionRelationships } from '../models/GameCenterEnabledVersionRelationships.ts';
import { GameCenterEnabledVersionsResponse } from '../models/GameCenterEnabledVersionsResponse.ts';
import { GameCenterEnabledVersionsResponseIncludedInner } from '../models/GameCenterEnabledVersionsResponseIncludedInner.ts';
import { GameCenterGroup } from '../models/GameCenterGroup.ts';
import { GameCenterGroupAttributes } from '../models/GameCenterGroupAttributes.ts';
import { GameCenterGroupCreateRequest } from '../models/GameCenterGroupCreateRequest.ts';
import { GameCenterGroupCreateRequestData } from '../models/GameCenterGroupCreateRequestData.ts';
import { GameCenterGroupGameCenterAchievementsLinkagesRequest } from '../models/GameCenterGroupGameCenterAchievementsLinkagesRequest.ts';
import { GameCenterGroupGameCenterAchievementsLinkagesResponse } from '../models/GameCenterGroupGameCenterAchievementsLinkagesResponse.ts';
import { GameCenterGroupGameCenterLeaderboardSetsLinkagesRequest } from '../models/GameCenterGroupGameCenterLeaderboardSetsLinkagesRequest.ts';
import { GameCenterGroupGameCenterLeaderboardSetsLinkagesResponse } from '../models/GameCenterGroupGameCenterLeaderboardSetsLinkagesResponse.ts';
import { GameCenterGroupGameCenterLeaderboardsLinkagesRequest } from '../models/GameCenterGroupGameCenterLeaderboardsLinkagesRequest.ts';
import { GameCenterGroupGameCenterLeaderboardsLinkagesResponse } from '../models/GameCenterGroupGameCenterLeaderboardsLinkagesResponse.ts';
import { GameCenterGroupRelationships } from '../models/GameCenterGroupRelationships.ts';
import { GameCenterGroupRelationshipsGameCenterDetails } from '../models/GameCenterGroupRelationshipsGameCenterDetails.ts';
import { GameCenterGroupResponse } from '../models/GameCenterGroupResponse.ts';
import { GameCenterGroupUpdateRequest } from '../models/GameCenterGroupUpdateRequest.ts';
import { GameCenterGroupUpdateRequestData } from '../models/GameCenterGroupUpdateRequestData.ts';
import { GameCenterGroupsResponse } from '../models/GameCenterGroupsResponse.ts';
import { GameCenterGroupsResponseIncludedInner } from '../models/GameCenterGroupsResponseIncludedInner.ts';
import { GameCenterLeaderboard } from '../models/GameCenterLeaderboard.ts';
import { GameCenterLeaderboardAttributes } from '../models/GameCenterLeaderboardAttributes.ts';
import { GameCenterLeaderboardCreateRequest } from '../models/GameCenterLeaderboardCreateRequest.ts';
import { GameCenterLeaderboardCreateRequestData } from '../models/GameCenterLeaderboardCreateRequestData.ts';
import { GameCenterLeaderboardCreateRequestDataAttributes } from '../models/GameCenterLeaderboardCreateRequestDataAttributes.ts';
import { GameCenterLeaderboardCreateRequestDataRelationships } from '../models/GameCenterLeaderboardCreateRequestDataRelationships.ts';
import { GameCenterLeaderboardCreateRequestDataRelationshipsGameCenterLeaderboardSets } from '../models/GameCenterLeaderboardCreateRequestDataRelationshipsGameCenterLeaderboardSets.ts';
import { GameCenterLeaderboardEntrySubmission } from '../models/GameCenterLeaderboardEntrySubmission.ts';
import { GameCenterLeaderboardEntrySubmissionAttributes } from '../models/GameCenterLeaderboardEntrySubmissionAttributes.ts';
import { GameCenterLeaderboardEntrySubmissionCreateRequest } from '../models/GameCenterLeaderboardEntrySubmissionCreateRequest.ts';
import { GameCenterLeaderboardEntrySubmissionCreateRequestData } from '../models/GameCenterLeaderboardEntrySubmissionCreateRequestData.ts';
import { GameCenterLeaderboardEntrySubmissionCreateRequestDataAttributes } from '../models/GameCenterLeaderboardEntrySubmissionCreateRequestDataAttributes.ts';
import { GameCenterLeaderboardEntrySubmissionResponse } from '../models/GameCenterLeaderboardEntrySubmissionResponse.ts';
import { GameCenterLeaderboardFormatter } from '../models/GameCenterLeaderboardFormatter.ts';
import { GameCenterLeaderboardGroupLeaderboardLinkageRequest } from '../models/GameCenterLeaderboardGroupLeaderboardLinkageRequest.ts';
import { GameCenterLeaderboardGroupLeaderboardLinkageResponse } from '../models/GameCenterLeaderboardGroupLeaderboardLinkageResponse.ts';
import { GameCenterLeaderboardImage } from '../models/GameCenterLeaderboardImage.ts';
import { GameCenterLeaderboardImageCreateRequest } from '../models/GameCenterLeaderboardImageCreateRequest.ts';
import { GameCenterLeaderboardImageCreateRequestData } from '../models/GameCenterLeaderboardImageCreateRequestData.ts';
import { GameCenterLeaderboardImageCreateRequestDataRelationships } from '../models/GameCenterLeaderboardImageCreateRequestDataRelationships.ts';
import { GameCenterLeaderboardImageCreateRequestDataRelationshipsGameCenterLeaderboardLocalization } from '../models/GameCenterLeaderboardImageCreateRequestDataRelationshipsGameCenterLeaderboardLocalization.ts';
import { GameCenterLeaderboardImageRelationships } from '../models/GameCenterLeaderboardImageRelationships.ts';
import { GameCenterLeaderboardImageRelationshipsGameCenterLeaderboardLocalization } from '../models/GameCenterLeaderboardImageRelationshipsGameCenterLeaderboardLocalization.ts';
import { GameCenterLeaderboardImageRelationshipsGameCenterLeaderboardLocalizationData } from '../models/GameCenterLeaderboardImageRelationshipsGameCenterLeaderboardLocalizationData.ts';
import { GameCenterLeaderboardImageResponse } from '../models/GameCenterLeaderboardImageResponse.ts';
import { GameCenterLeaderboardImageUpdateRequest } from '../models/GameCenterLeaderboardImageUpdateRequest.ts';
import { GameCenterLeaderboardImageUpdateRequestData } from '../models/GameCenterLeaderboardImageUpdateRequestData.ts';
import { GameCenterLeaderboardLocalization } from '../models/GameCenterLeaderboardLocalization.ts';
import { GameCenterLeaderboardLocalizationAttributes } from '../models/GameCenterLeaderboardLocalizationAttributes.ts';
import { GameCenterLeaderboardLocalizationCreateRequest } from '../models/GameCenterLeaderboardLocalizationCreateRequest.ts';
import { GameCenterLeaderboardLocalizationCreateRequestData } from '../models/GameCenterLeaderboardLocalizationCreateRequestData.ts';
import { GameCenterLeaderboardLocalizationCreateRequestDataAttributes } from '../models/GameCenterLeaderboardLocalizationCreateRequestDataAttributes.ts';
import { GameCenterLeaderboardLocalizationCreateRequestDataRelationships } from '../models/GameCenterLeaderboardLocalizationCreateRequestDataRelationships.ts';
import { GameCenterLeaderboardLocalizationCreateRequestDataRelationshipsGameCenterLeaderboard } from '../models/GameCenterLeaderboardLocalizationCreateRequestDataRelationshipsGameCenterLeaderboard.ts';
import { GameCenterLeaderboardLocalizationRelationships } from '../models/GameCenterLeaderboardLocalizationRelationships.ts';
import { GameCenterLeaderboardLocalizationRelationshipsGameCenterLeaderboardImage } from '../models/GameCenterLeaderboardLocalizationRelationshipsGameCenterLeaderboardImage.ts';
import { GameCenterLeaderboardLocalizationRelationshipsGameCenterLeaderboardImageData } from '../models/GameCenterLeaderboardLocalizationRelationshipsGameCenterLeaderboardImageData.ts';
import { GameCenterLeaderboardLocalizationResponse } from '../models/GameCenterLeaderboardLocalizationResponse.ts';
import { GameCenterLeaderboardLocalizationUpdateRequest } from '../models/GameCenterLeaderboardLocalizationUpdateRequest.ts';
import { GameCenterLeaderboardLocalizationUpdateRequestData } from '../models/GameCenterLeaderboardLocalizationUpdateRequestData.ts';
import { GameCenterLeaderboardLocalizationUpdateRequestDataAttributes } from '../models/GameCenterLeaderboardLocalizationUpdateRequestDataAttributes.ts';
import { GameCenterLeaderboardLocalizationsResponse } from '../models/GameCenterLeaderboardLocalizationsResponse.ts';
import { GameCenterLeaderboardLocalizationsResponseIncludedInner } from '../models/GameCenterLeaderboardLocalizationsResponseIncludedInner.ts';
import { GameCenterLeaderboardRelationships } from '../models/GameCenterLeaderboardRelationships.ts';
import { GameCenterLeaderboardRelationshipsLocalizations } from '../models/GameCenterLeaderboardRelationshipsLocalizations.ts';
import { GameCenterLeaderboardRelease } from '../models/GameCenterLeaderboardRelease.ts';
import { GameCenterLeaderboardReleaseCreateRequest } from '../models/GameCenterLeaderboardReleaseCreateRequest.ts';
import { GameCenterLeaderboardReleaseCreateRequestData } from '../models/GameCenterLeaderboardReleaseCreateRequestData.ts';
import { GameCenterLeaderboardReleaseCreateRequestDataRelationships } from '../models/GameCenterLeaderboardReleaseCreateRequestDataRelationships.ts';
import { GameCenterLeaderboardReleaseRelationships } from '../models/GameCenterLeaderboardReleaseRelationships.ts';
import { GameCenterLeaderboardReleaseResponse } from '../models/GameCenterLeaderboardReleaseResponse.ts';
import { GameCenterLeaderboardReleasesResponse } from '../models/GameCenterLeaderboardReleasesResponse.ts';
import { GameCenterLeaderboardReleasesResponseIncludedInner } from '../models/GameCenterLeaderboardReleasesResponseIncludedInner.ts';
import { GameCenterLeaderboardResponse } from '../models/GameCenterLeaderboardResponse.ts';
import { GameCenterLeaderboardSet } from '../models/GameCenterLeaderboardSet.ts';
import { GameCenterLeaderboardSetAttributes } from '../models/GameCenterLeaderboardSetAttributes.ts';
import { GameCenterLeaderboardSetCreateRequest } from '../models/GameCenterLeaderboardSetCreateRequest.ts';
import { GameCenterLeaderboardSetCreateRequestData } from '../models/GameCenterLeaderboardSetCreateRequestData.ts';
import { GameCenterLeaderboardSetCreateRequestDataAttributes } from '../models/GameCenterLeaderboardSetCreateRequestDataAttributes.ts';
import { GameCenterLeaderboardSetCreateRequestDataRelationships } from '../models/GameCenterLeaderboardSetCreateRequestDataRelationships.ts';
import { GameCenterLeaderboardSetCreateRequestDataRelationshipsGameCenterLeaderboards } from '../models/GameCenterLeaderboardSetCreateRequestDataRelationshipsGameCenterLeaderboards.ts';
import { GameCenterLeaderboardSetGameCenterLeaderboardsLinkagesRequest } from '../models/GameCenterLeaderboardSetGameCenterLeaderboardsLinkagesRequest.ts';
import { GameCenterLeaderboardSetGameCenterLeaderboardsLinkagesResponse } from '../models/GameCenterLeaderboardSetGameCenterLeaderboardsLinkagesResponse.ts';
import { GameCenterLeaderboardSetGroupLeaderboardSetLinkageRequest } from '../models/GameCenterLeaderboardSetGroupLeaderboardSetLinkageRequest.ts';
import { GameCenterLeaderboardSetGroupLeaderboardSetLinkageResponse } from '../models/GameCenterLeaderboardSetGroupLeaderboardSetLinkageResponse.ts';
import { GameCenterLeaderboardSetImage } from '../models/GameCenterLeaderboardSetImage.ts';
import { GameCenterLeaderboardSetImageCreateRequest } from '../models/GameCenterLeaderboardSetImageCreateRequest.ts';
import { GameCenterLeaderboardSetImageCreateRequestData } from '../models/GameCenterLeaderboardSetImageCreateRequestData.ts';
import { GameCenterLeaderboardSetImageCreateRequestDataRelationships } from '../models/GameCenterLeaderboardSetImageCreateRequestDataRelationships.ts';
import { GameCenterLeaderboardSetImageCreateRequestDataRelationshipsGameCenterLeaderboardSetLocalization } from '../models/GameCenterLeaderboardSetImageCreateRequestDataRelationshipsGameCenterLeaderboardSetLocalization.ts';
import { GameCenterLeaderboardSetImageRelationships } from '../models/GameCenterLeaderboardSetImageRelationships.ts';
import { GameCenterLeaderboardSetImageRelationshipsGameCenterLeaderboardSetLocalization } from '../models/GameCenterLeaderboardSetImageRelationshipsGameCenterLeaderboardSetLocalization.ts';
import { GameCenterLeaderboardSetImageRelationshipsGameCenterLeaderboardSetLocalizationData } from '../models/GameCenterLeaderboardSetImageRelationshipsGameCenterLeaderboardSetLocalizationData.ts';
import { GameCenterLeaderboardSetImageResponse } from '../models/GameCenterLeaderboardSetImageResponse.ts';
import { GameCenterLeaderboardSetImageUpdateRequest } from '../models/GameCenterLeaderboardSetImageUpdateRequest.ts';
import { GameCenterLeaderboardSetImageUpdateRequestData } from '../models/GameCenterLeaderboardSetImageUpdateRequestData.ts';
import { GameCenterLeaderboardSetLocalization } from '../models/GameCenterLeaderboardSetLocalization.ts';
import { GameCenterLeaderboardSetLocalizationAttributes } from '../models/GameCenterLeaderboardSetLocalizationAttributes.ts';
import { GameCenterLeaderboardSetLocalizationCreateRequest } from '../models/GameCenterLeaderboardSetLocalizationCreateRequest.ts';
import { GameCenterLeaderboardSetLocalizationCreateRequestData } from '../models/GameCenterLeaderboardSetLocalizationCreateRequestData.ts';
import { GameCenterLeaderboardSetLocalizationCreateRequestDataAttributes } from '../models/GameCenterLeaderboardSetLocalizationCreateRequestDataAttributes.ts';
import { GameCenterLeaderboardSetLocalizationCreateRequestDataRelationships } from '../models/GameCenterLeaderboardSetLocalizationCreateRequestDataRelationships.ts';
import { GameCenterLeaderboardSetLocalizationCreateRequestDataRelationshipsGameCenterLeaderboardSet } from '../models/GameCenterLeaderboardSetLocalizationCreateRequestDataRelationshipsGameCenterLeaderboardSet.ts';
import { GameCenterLeaderboardSetLocalizationRelationships } from '../models/GameCenterLeaderboardSetLocalizationRelationships.ts';
import { GameCenterLeaderboardSetLocalizationRelationshipsGameCenterLeaderboardSet } from '../models/GameCenterLeaderboardSetLocalizationRelationshipsGameCenterLeaderboardSet.ts';
import { GameCenterLeaderboardSetLocalizationRelationshipsGameCenterLeaderboardSetImage } from '../models/GameCenterLeaderboardSetLocalizationRelationshipsGameCenterLeaderboardSetImage.ts';
import { GameCenterLeaderboardSetLocalizationRelationshipsGameCenterLeaderboardSetImageData } from '../models/GameCenterLeaderboardSetLocalizationRelationshipsGameCenterLeaderboardSetImageData.ts';
import { GameCenterLeaderboardSetLocalizationResponse } from '../models/GameCenterLeaderboardSetLocalizationResponse.ts';
import { GameCenterLeaderboardSetLocalizationUpdateRequest } from '../models/GameCenterLeaderboardSetLocalizationUpdateRequest.ts';
import { GameCenterLeaderboardSetLocalizationUpdateRequestData } from '../models/GameCenterLeaderboardSetLocalizationUpdateRequestData.ts';
import { GameCenterLeaderboardSetLocalizationsResponse } from '../models/GameCenterLeaderboardSetLocalizationsResponse.ts';
import { GameCenterLeaderboardSetLocalizationsResponseIncludedInner } from '../models/GameCenterLeaderboardSetLocalizationsResponseIncludedInner.ts';
import { GameCenterLeaderboardSetMemberLocalization } from '../models/GameCenterLeaderboardSetMemberLocalization.ts';
import { GameCenterLeaderboardSetMemberLocalizationAttributes } from '../models/GameCenterLeaderboardSetMemberLocalizationAttributes.ts';
import { GameCenterLeaderboardSetMemberLocalizationCreateRequest } from '../models/GameCenterLeaderboardSetMemberLocalizationCreateRequest.ts';
import { GameCenterLeaderboardSetMemberLocalizationCreateRequestData } from '../models/GameCenterLeaderboardSetMemberLocalizationCreateRequestData.ts';
import { GameCenterLeaderboardSetMemberLocalizationCreateRequestDataRelationships } from '../models/GameCenterLeaderboardSetMemberLocalizationCreateRequestDataRelationships.ts';
import { GameCenterLeaderboardSetMemberLocalizationRelationships } from '../models/GameCenterLeaderboardSetMemberLocalizationRelationships.ts';
import { GameCenterLeaderboardSetMemberLocalizationResponse } from '../models/GameCenterLeaderboardSetMemberLocalizationResponse.ts';
import { GameCenterLeaderboardSetMemberLocalizationUpdateRequest } from '../models/GameCenterLeaderboardSetMemberLocalizationUpdateRequest.ts';
import { GameCenterLeaderboardSetMemberLocalizationUpdateRequestData } from '../models/GameCenterLeaderboardSetMemberLocalizationUpdateRequestData.ts';
import { GameCenterLeaderboardSetMemberLocalizationsResponse } from '../models/GameCenterLeaderboardSetMemberLocalizationsResponse.ts';
import { GameCenterLeaderboardSetMemberLocalizationsResponseIncludedInner } from '../models/GameCenterLeaderboardSetMemberLocalizationsResponseIncludedInner.ts';
import { GameCenterLeaderboardSetRelationships } from '../models/GameCenterLeaderboardSetRelationships.ts';
import { GameCenterLeaderboardSetRelationshipsLocalizations } from '../models/GameCenterLeaderboardSetRelationshipsLocalizations.ts';
import { GameCenterLeaderboardSetRelease } from '../models/GameCenterLeaderboardSetRelease.ts';
import { GameCenterLeaderboardSetReleaseCreateRequest } from '../models/GameCenterLeaderboardSetReleaseCreateRequest.ts';
import { GameCenterLeaderboardSetReleaseCreateRequestData } from '../models/GameCenterLeaderboardSetReleaseCreateRequestData.ts';
import { GameCenterLeaderboardSetReleaseCreateRequestDataRelationships } from '../models/GameCenterLeaderboardSetReleaseCreateRequestDataRelationships.ts';
import { GameCenterLeaderboardSetReleaseRelationships } from '../models/GameCenterLeaderboardSetReleaseRelationships.ts';
import { GameCenterLeaderboardSetReleaseResponse } from '../models/GameCenterLeaderboardSetReleaseResponse.ts';
import { GameCenterLeaderboardSetReleasesResponse } from '../models/GameCenterLeaderboardSetReleasesResponse.ts';
import { GameCenterLeaderboardSetReleasesResponseIncludedInner } from '../models/GameCenterLeaderboardSetReleasesResponseIncludedInner.ts';
import { GameCenterLeaderboardSetResponse } from '../models/GameCenterLeaderboardSetResponse.ts';
import { GameCenterLeaderboardSetUpdateRequest } from '../models/GameCenterLeaderboardSetUpdateRequest.ts';
import { GameCenterLeaderboardSetUpdateRequestData } from '../models/GameCenterLeaderboardSetUpdateRequestData.ts';
import { GameCenterLeaderboardSetsResponse } from '../models/GameCenterLeaderboardSetsResponse.ts';
import { GameCenterLeaderboardSetsResponseIncludedInner } from '../models/GameCenterLeaderboardSetsResponseIncludedInner.ts';
import { GameCenterLeaderboardUpdateRequest } from '../models/GameCenterLeaderboardUpdateRequest.ts';
import { GameCenterLeaderboardUpdateRequestData } from '../models/GameCenterLeaderboardUpdateRequestData.ts';
import { GameCenterLeaderboardUpdateRequestDataAttributes } from '../models/GameCenterLeaderboardUpdateRequestDataAttributes.ts';
import { GameCenterLeaderboardsResponse } from '../models/GameCenterLeaderboardsResponse.ts';
import { GameCenterLeaderboardsResponseIncludedInner } from '../models/GameCenterLeaderboardsResponseIncludedInner.ts';
import { GameCenterMatchmakingAppRequestsV1MetricResponse } from '../models/GameCenterMatchmakingAppRequestsV1MetricResponse.ts';
import { GameCenterMatchmakingAppRequestsV1MetricResponseDataInner } from '../models/GameCenterMatchmakingAppRequestsV1MetricResponseDataInner.ts';
import { GameCenterMatchmakingAppRequestsV1MetricResponseDataInnerDataPoints } from '../models/GameCenterMatchmakingAppRequestsV1MetricResponseDataInnerDataPoints.ts';
import { GameCenterMatchmakingAppRequestsV1MetricResponseDataInnerDataPointsValues } from '../models/GameCenterMatchmakingAppRequestsV1MetricResponseDataInnerDataPointsValues.ts';
import { GameCenterMatchmakingAppRequestsV1MetricResponseDataInnerDimensions } from '../models/GameCenterMatchmakingAppRequestsV1MetricResponseDataInnerDimensions.ts';
import { GameCenterMatchmakingBooleanRuleResultsV1MetricResponse } from '../models/GameCenterMatchmakingBooleanRuleResultsV1MetricResponse.ts';
import { GameCenterMatchmakingBooleanRuleResultsV1MetricResponseDataInner } from '../models/GameCenterMatchmakingBooleanRuleResultsV1MetricResponseDataInner.ts';
import { GameCenterMatchmakingBooleanRuleResultsV1MetricResponseDataInnerDataPoints } from '../models/GameCenterMatchmakingBooleanRuleResultsV1MetricResponseDataInnerDataPoints.ts';
import { GameCenterMatchmakingBooleanRuleResultsV1MetricResponseDataInnerDataPointsValues } from '../models/GameCenterMatchmakingBooleanRuleResultsV1MetricResponseDataInnerDataPointsValues.ts';
import { GameCenterMatchmakingBooleanRuleResultsV1MetricResponseDataInnerDimensions } from '../models/GameCenterMatchmakingBooleanRuleResultsV1MetricResponseDataInnerDimensions.ts';
import { GameCenterMatchmakingNumberRuleResultsV1MetricResponse } from '../models/GameCenterMatchmakingNumberRuleResultsV1MetricResponse.ts';
import { GameCenterMatchmakingNumberRuleResultsV1MetricResponseDataInner } from '../models/GameCenterMatchmakingNumberRuleResultsV1MetricResponseDataInner.ts';
import { GameCenterMatchmakingNumberRuleResultsV1MetricResponseDataInnerDataPoints } from '../models/GameCenterMatchmakingNumberRuleResultsV1MetricResponseDataInnerDataPoints.ts';
import { GameCenterMatchmakingNumberRuleResultsV1MetricResponseDataInnerDataPointsValues } from '../models/GameCenterMatchmakingNumberRuleResultsV1MetricResponseDataInnerDataPointsValues.ts';
import { GameCenterMatchmakingNumberRuleResultsV1MetricResponseDataInnerDimensions } from '../models/GameCenterMatchmakingNumberRuleResultsV1MetricResponseDataInnerDimensions.ts';
import { GameCenterMatchmakingQueue } from '../models/GameCenterMatchmakingQueue.ts';
import { GameCenterMatchmakingQueueAttributes } from '../models/GameCenterMatchmakingQueueAttributes.ts';
import { GameCenterMatchmakingQueueCreateRequest } from '../models/GameCenterMatchmakingQueueCreateRequest.ts';
import { GameCenterMatchmakingQueueCreateRequestData } from '../models/GameCenterMatchmakingQueueCreateRequestData.ts';
import { GameCenterMatchmakingQueueCreateRequestDataAttributes } from '../models/GameCenterMatchmakingQueueCreateRequestDataAttributes.ts';
import { GameCenterMatchmakingQueueCreateRequestDataRelationships } from '../models/GameCenterMatchmakingQueueCreateRequestDataRelationships.ts';
import { GameCenterMatchmakingQueueCreateRequestDataRelationshipsExperimentRuleSet } from '../models/GameCenterMatchmakingQueueCreateRequestDataRelationshipsExperimentRuleSet.ts';
import { GameCenterMatchmakingQueueCreateRequestDataRelationshipsRuleSet } from '../models/GameCenterMatchmakingQueueCreateRequestDataRelationshipsRuleSet.ts';
import { GameCenterMatchmakingQueueRelationships } from '../models/GameCenterMatchmakingQueueRelationships.ts';
import { GameCenterMatchmakingQueueRelationshipsRuleSet } from '../models/GameCenterMatchmakingQueueRelationshipsRuleSet.ts';
import { GameCenterMatchmakingQueueRelationshipsRuleSetData } from '../models/GameCenterMatchmakingQueueRelationshipsRuleSetData.ts';
import { GameCenterMatchmakingQueueRequestsV1MetricResponse } from '../models/GameCenterMatchmakingQueueRequestsV1MetricResponse.ts';
import { GameCenterMatchmakingQueueRequestsV1MetricResponseDataInner } from '../models/GameCenterMatchmakingQueueRequestsV1MetricResponseDataInner.ts';
import { GameCenterMatchmakingQueueRequestsV1MetricResponseDataInnerDimensions } from '../models/GameCenterMatchmakingQueueRequestsV1MetricResponseDataInnerDimensions.ts';
import { GameCenterMatchmakingQueueResponse } from '../models/GameCenterMatchmakingQueueResponse.ts';
import { GameCenterMatchmakingQueueSizesV1MetricResponse } from '../models/GameCenterMatchmakingQueueSizesV1MetricResponse.ts';
import { GameCenterMatchmakingQueueSizesV1MetricResponseDataInner } from '../models/GameCenterMatchmakingQueueSizesV1MetricResponseDataInner.ts';
import { GameCenterMatchmakingQueueSizesV1MetricResponseDataInnerDataPoints } from '../models/GameCenterMatchmakingQueueSizesV1MetricResponseDataInnerDataPoints.ts';
import { GameCenterMatchmakingQueueSizesV1MetricResponseDataInnerDataPointsValues } from '../models/GameCenterMatchmakingQueueSizesV1MetricResponseDataInnerDataPointsValues.ts';
import { GameCenterMatchmakingQueueUpdateRequest } from '../models/GameCenterMatchmakingQueueUpdateRequest.ts';
import { GameCenterMatchmakingQueueUpdateRequestData } from '../models/GameCenterMatchmakingQueueUpdateRequestData.ts';
import { GameCenterMatchmakingQueueUpdateRequestDataAttributes } from '../models/GameCenterMatchmakingQueueUpdateRequestDataAttributes.ts';
import { GameCenterMatchmakingQueueUpdateRequestDataRelationships } from '../models/GameCenterMatchmakingQueueUpdateRequestDataRelationships.ts';
import { GameCenterMatchmakingQueuesResponse } from '../models/GameCenterMatchmakingQueuesResponse.ts';
import { GameCenterMatchmakingRule } from '../models/GameCenterMatchmakingRule.ts';
import { GameCenterMatchmakingRuleAttributes } from '../models/GameCenterMatchmakingRuleAttributes.ts';
import { GameCenterMatchmakingRuleCreateRequest } from '../models/GameCenterMatchmakingRuleCreateRequest.ts';
import { GameCenterMatchmakingRuleCreateRequestData } from '../models/GameCenterMatchmakingRuleCreateRequestData.ts';
import { GameCenterMatchmakingRuleCreateRequestDataAttributes } from '../models/GameCenterMatchmakingRuleCreateRequestDataAttributes.ts';
import { GameCenterMatchmakingRuleCreateRequestDataRelationships } from '../models/GameCenterMatchmakingRuleCreateRequestDataRelationships.ts';
import { GameCenterMatchmakingRuleErrorsV1MetricResponse } from '../models/GameCenterMatchmakingRuleErrorsV1MetricResponse.ts';
import { GameCenterMatchmakingRuleErrorsV1MetricResponseDataInner } from '../models/GameCenterMatchmakingRuleErrorsV1MetricResponseDataInner.ts';
import { GameCenterMatchmakingRuleResponse } from '../models/GameCenterMatchmakingRuleResponse.ts';
import { GameCenterMatchmakingRuleSet } from '../models/GameCenterMatchmakingRuleSet.ts';
import { GameCenterMatchmakingRuleSetAttributes } from '../models/GameCenterMatchmakingRuleSetAttributes.ts';
import { GameCenterMatchmakingRuleSetCreateRequest } from '../models/GameCenterMatchmakingRuleSetCreateRequest.ts';
import { GameCenterMatchmakingRuleSetCreateRequestData } from '../models/GameCenterMatchmakingRuleSetCreateRequestData.ts';
import { GameCenterMatchmakingRuleSetCreateRequestDataAttributes } from '../models/GameCenterMatchmakingRuleSetCreateRequestDataAttributes.ts';
import { GameCenterMatchmakingRuleSetRelationships } from '../models/GameCenterMatchmakingRuleSetRelationships.ts';
import { GameCenterMatchmakingRuleSetRelationshipsMatchmakingQueues } from '../models/GameCenterMatchmakingRuleSetRelationshipsMatchmakingQueues.ts';
import { GameCenterMatchmakingRuleSetRelationshipsMatchmakingQueuesDataInner } from '../models/GameCenterMatchmakingRuleSetRelationshipsMatchmakingQueuesDataInner.ts';
import { GameCenterMatchmakingRuleSetRelationshipsRules } from '../models/GameCenterMatchmakingRuleSetRelationshipsRules.ts';
import { GameCenterMatchmakingRuleSetRelationshipsRulesDataInner } from '../models/GameCenterMatchmakingRuleSetRelationshipsRulesDataInner.ts';
import { GameCenterMatchmakingRuleSetRelationshipsTeams } from '../models/GameCenterMatchmakingRuleSetRelationshipsTeams.ts';
import { GameCenterMatchmakingRuleSetRelationshipsTeamsDataInner } from '../models/GameCenterMatchmakingRuleSetRelationshipsTeamsDataInner.ts';
import { GameCenterMatchmakingRuleSetResponse } from '../models/GameCenterMatchmakingRuleSetResponse.ts';
import { GameCenterMatchmakingRuleSetTest } from '../models/GameCenterMatchmakingRuleSetTest.ts';
import { GameCenterMatchmakingRuleSetTestAttributes } from '../models/GameCenterMatchmakingRuleSetTestAttributes.ts';
import { GameCenterMatchmakingRuleSetTestAttributesMatchmakingResultsInnerInner } from '../models/GameCenterMatchmakingRuleSetTestAttributesMatchmakingResultsInnerInner.ts';
import { GameCenterMatchmakingRuleSetTestCreateRequest } from '../models/GameCenterMatchmakingRuleSetTestCreateRequest.ts';
import { GameCenterMatchmakingRuleSetTestCreateRequestData } from '../models/GameCenterMatchmakingRuleSetTestCreateRequestData.ts';
import { GameCenterMatchmakingRuleSetTestCreateRequestDataRelationships } from '../models/GameCenterMatchmakingRuleSetTestCreateRequestDataRelationships.ts';
import { GameCenterMatchmakingRuleSetTestCreateRequestDataRelationshipsMatchmakingRequests } from '../models/GameCenterMatchmakingRuleSetTestCreateRequestDataRelationshipsMatchmakingRequests.ts';
import { GameCenterMatchmakingRuleSetTestCreateRequestDataRelationshipsMatchmakingRequestsDataInner } from '../models/GameCenterMatchmakingRuleSetTestCreateRequestDataRelationshipsMatchmakingRequestsDataInner.ts';
import { GameCenterMatchmakingRuleSetTestCreateRequestIncludedInner } from '../models/GameCenterMatchmakingRuleSetTestCreateRequestIncludedInner.ts';
import { GameCenterMatchmakingRuleSetTestResponse } from '../models/GameCenterMatchmakingRuleSetTestResponse.ts';
import { GameCenterMatchmakingRuleSetUpdateRequest } from '../models/GameCenterMatchmakingRuleSetUpdateRequest.ts';
import { GameCenterMatchmakingRuleSetUpdateRequestData } from '../models/GameCenterMatchmakingRuleSetUpdateRequestData.ts';
import { GameCenterMatchmakingRuleSetUpdateRequestDataAttributes } from '../models/GameCenterMatchmakingRuleSetUpdateRequestDataAttributes.ts';
import { GameCenterMatchmakingRuleSetsResponse } from '../models/GameCenterMatchmakingRuleSetsResponse.ts';
import { GameCenterMatchmakingRuleSetsResponseIncludedInner } from '../models/GameCenterMatchmakingRuleSetsResponseIncludedInner.ts';
import { GameCenterMatchmakingRuleUpdateRequest } from '../models/GameCenterMatchmakingRuleUpdateRequest.ts';
import { GameCenterMatchmakingRuleUpdateRequestData } from '../models/GameCenterMatchmakingRuleUpdateRequestData.ts';
import { GameCenterMatchmakingRuleUpdateRequestDataAttributes } from '../models/GameCenterMatchmakingRuleUpdateRequestDataAttributes.ts';
import { GameCenterMatchmakingRulesResponse } from '../models/GameCenterMatchmakingRulesResponse.ts';
import { GameCenterMatchmakingSessionsV1MetricResponse } from '../models/GameCenterMatchmakingSessionsV1MetricResponse.ts';
import { GameCenterMatchmakingSessionsV1MetricResponseDataInner } from '../models/GameCenterMatchmakingSessionsV1MetricResponseDataInner.ts';
import { GameCenterMatchmakingSessionsV1MetricResponseDataInnerDataPoints } from '../models/GameCenterMatchmakingSessionsV1MetricResponseDataInnerDataPoints.ts';
import { GameCenterMatchmakingSessionsV1MetricResponseDataInnerDataPointsValues } from '../models/GameCenterMatchmakingSessionsV1MetricResponseDataInnerDataPointsValues.ts';
import { GameCenterMatchmakingTeam } from '../models/GameCenterMatchmakingTeam.ts';
import { GameCenterMatchmakingTeamAssignment } from '../models/GameCenterMatchmakingTeamAssignment.ts';
import { GameCenterMatchmakingTeamAttributes } from '../models/GameCenterMatchmakingTeamAttributes.ts';
import { GameCenterMatchmakingTeamCreateRequest } from '../models/GameCenterMatchmakingTeamCreateRequest.ts';
import { GameCenterMatchmakingTeamCreateRequestData } from '../models/GameCenterMatchmakingTeamCreateRequestData.ts';
import { GameCenterMatchmakingTeamCreateRequestDataAttributes } from '../models/GameCenterMatchmakingTeamCreateRequestDataAttributes.ts';
import { GameCenterMatchmakingTeamResponse } from '../models/GameCenterMatchmakingTeamResponse.ts';
import { GameCenterMatchmakingTeamUpdateRequest } from '../models/GameCenterMatchmakingTeamUpdateRequest.ts';
import { GameCenterMatchmakingTeamUpdateRequestData } from '../models/GameCenterMatchmakingTeamUpdateRequestData.ts';
import { GameCenterMatchmakingTeamsResponse } from '../models/GameCenterMatchmakingTeamsResponse.ts';
import { GameCenterMatchmakingTestPlayerPropertyInlineCreate } from '../models/GameCenterMatchmakingTestPlayerPropertyInlineCreate.ts';
import { GameCenterMatchmakingTestPlayerPropertyInlineCreateAttributes } from '../models/GameCenterMatchmakingTestPlayerPropertyInlineCreateAttributes.ts';
import { GameCenterMatchmakingTestRequestInlineCreate } from '../models/GameCenterMatchmakingTestRequestInlineCreate.ts';
import { GameCenterMatchmakingTestRequestInlineCreateAttributes } from '../models/GameCenterMatchmakingTestRequestInlineCreateAttributes.ts';
import { GameCenterMatchmakingTestRequestInlineCreateRelationships } from '../models/GameCenterMatchmakingTestRequestInlineCreateRelationships.ts';
import { GameCenterMatchmakingTestRequestInlineCreateRelationshipsMatchmakingPlayerProperties } from '../models/GameCenterMatchmakingTestRequestInlineCreateRelationshipsMatchmakingPlayerProperties.ts';
import { GameCenterMatchmakingTestRequestInlineCreateRelationshipsMatchmakingPlayerPropertiesDataInner } from '../models/GameCenterMatchmakingTestRequestInlineCreateRelationshipsMatchmakingPlayerPropertiesDataInner.ts';
import { GameCenterPlayerAchievementSubmission } from '../models/GameCenterPlayerAchievementSubmission.ts';
import { GameCenterPlayerAchievementSubmissionAttributes } from '../models/GameCenterPlayerAchievementSubmissionAttributes.ts';
import { GameCenterPlayerAchievementSubmissionCreateRequest } from '../models/GameCenterPlayerAchievementSubmissionCreateRequest.ts';
import { GameCenterPlayerAchievementSubmissionCreateRequestData } from '../models/GameCenterPlayerAchievementSubmissionCreateRequestData.ts';
import { GameCenterPlayerAchievementSubmissionCreateRequestDataAttributes } from '../models/GameCenterPlayerAchievementSubmissionCreateRequestDataAttributes.ts';
import { GameCenterPlayerAchievementSubmissionResponse } from '../models/GameCenterPlayerAchievementSubmissionResponse.ts';
import { HttpHeader } from '../models/HttpHeader.ts';
import { IconAssetType } from '../models/IconAssetType.ts';
import { ImageAsset } from '../models/ImageAsset.ts';
import { InAppPurchase } from '../models/InAppPurchase.ts';
import { InAppPurchaseAppStoreReviewScreenshot } from '../models/InAppPurchaseAppStoreReviewScreenshot.ts';
import { InAppPurchaseAppStoreReviewScreenshotCreateRequest } from '../models/InAppPurchaseAppStoreReviewScreenshotCreateRequest.ts';
import { InAppPurchaseAppStoreReviewScreenshotCreateRequestData } from '../models/InAppPurchaseAppStoreReviewScreenshotCreateRequestData.ts';
import { InAppPurchaseAppStoreReviewScreenshotCreateRequestDataRelationships } from '../models/InAppPurchaseAppStoreReviewScreenshotCreateRequestDataRelationships.ts';
import { InAppPurchaseAppStoreReviewScreenshotCreateRequestDataRelationshipsInAppPurchaseV2 } from '../models/InAppPurchaseAppStoreReviewScreenshotCreateRequestDataRelationshipsInAppPurchaseV2.ts';
import { InAppPurchaseAppStoreReviewScreenshotRelationships } from '../models/InAppPurchaseAppStoreReviewScreenshotRelationships.ts';
import { InAppPurchaseAppStoreReviewScreenshotRelationshipsInAppPurchaseV2 } from '../models/InAppPurchaseAppStoreReviewScreenshotRelationshipsInAppPurchaseV2.ts';
import { InAppPurchaseAppStoreReviewScreenshotResponse } from '../models/InAppPurchaseAppStoreReviewScreenshotResponse.ts';
import { InAppPurchaseAppStoreReviewScreenshotUpdateRequest } from '../models/InAppPurchaseAppStoreReviewScreenshotUpdateRequest.ts';
import { InAppPurchaseAppStoreReviewScreenshotUpdateRequestData } from '../models/InAppPurchaseAppStoreReviewScreenshotUpdateRequestData.ts';
import { InAppPurchaseAttributes } from '../models/InAppPurchaseAttributes.ts';
import { InAppPurchaseAvailability } from '../models/InAppPurchaseAvailability.ts';
import { InAppPurchaseAvailabilityCreateRequest } from '../models/InAppPurchaseAvailabilityCreateRequest.ts';
import { InAppPurchaseAvailabilityCreateRequestData } from '../models/InAppPurchaseAvailabilityCreateRequestData.ts';
import { InAppPurchaseAvailabilityCreateRequestDataRelationships } from '../models/InAppPurchaseAvailabilityCreateRequestDataRelationships.ts';
import { InAppPurchaseAvailabilityRelationships } from '../models/InAppPurchaseAvailabilityRelationships.ts';
import { InAppPurchaseAvailabilityResponse } from '../models/InAppPurchaseAvailabilityResponse.ts';
import { InAppPurchaseContent } from '../models/InAppPurchaseContent.ts';
import { InAppPurchaseContentAttributes } from '../models/InAppPurchaseContentAttributes.ts';
import { InAppPurchaseContentResponse } from '../models/InAppPurchaseContentResponse.ts';
import { InAppPurchaseLocalization } from '../models/InAppPurchaseLocalization.ts';
import { InAppPurchaseLocalizationAttributes } from '../models/InAppPurchaseLocalizationAttributes.ts';
import { InAppPurchaseLocalizationCreateRequest } from '../models/InAppPurchaseLocalizationCreateRequest.ts';
import { InAppPurchaseLocalizationCreateRequestData } from '../models/InAppPurchaseLocalizationCreateRequestData.ts';
import { InAppPurchaseLocalizationCreateRequestDataAttributes } from '../models/InAppPurchaseLocalizationCreateRequestDataAttributes.ts';
import { InAppPurchaseLocalizationResponse } from '../models/InAppPurchaseLocalizationResponse.ts';
import { InAppPurchaseLocalizationUpdateRequest } from '../models/InAppPurchaseLocalizationUpdateRequest.ts';
import { InAppPurchaseLocalizationUpdateRequestData } from '../models/InAppPurchaseLocalizationUpdateRequestData.ts';
import { InAppPurchaseLocalizationUpdateRequestDataAttributes } from '../models/InAppPurchaseLocalizationUpdateRequestDataAttributes.ts';
import { InAppPurchaseLocalizationsResponse } from '../models/InAppPurchaseLocalizationsResponse.ts';
import { InAppPurchasePrice } from '../models/InAppPurchasePrice.ts';
import { InAppPurchasePriceAttributes } from '../models/InAppPurchasePriceAttributes.ts';
import { InAppPurchasePriceInlineCreate } from '../models/InAppPurchasePriceInlineCreate.ts';
import { InAppPurchasePriceInlineCreateAttributes } from '../models/InAppPurchasePriceInlineCreateAttributes.ts';
import { InAppPurchasePriceInlineCreateRelationships } from '../models/InAppPurchasePriceInlineCreateRelationships.ts';
import { InAppPurchasePriceInlineCreateRelationshipsInAppPurchasePricePoint } from '../models/InAppPurchasePriceInlineCreateRelationshipsInAppPurchasePricePoint.ts';
import { InAppPurchasePriceInlineCreateRelationshipsInAppPurchaseV2 } from '../models/InAppPurchasePriceInlineCreateRelationshipsInAppPurchaseV2.ts';
import { InAppPurchasePricePoint } from '../models/InAppPurchasePricePoint.ts';
import { InAppPurchasePricePointAttributes } from '../models/InAppPurchasePricePointAttributes.ts';
import { InAppPurchasePricePointRelationships } from '../models/InAppPurchasePricePointRelationships.ts';
import { InAppPurchasePricePointsResponse } from '../models/InAppPurchasePricePointsResponse.ts';
import { InAppPurchasePriceRelationships } from '../models/InAppPurchasePriceRelationships.ts';
import { InAppPurchasePriceRelationshipsInAppPurchasePricePoint } from '../models/InAppPurchasePriceRelationshipsInAppPurchasePricePoint.ts';
import { InAppPurchasePriceRelationshipsInAppPurchasePricePointData } from '../models/InAppPurchasePriceRelationshipsInAppPurchasePricePointData.ts';
import { InAppPurchasePriceSchedule } from '../models/InAppPurchasePriceSchedule.ts';
import { InAppPurchasePriceScheduleCreateRequest } from '../models/InAppPurchasePriceScheduleCreateRequest.ts';
import { InAppPurchasePriceScheduleCreateRequestData } from '../models/InAppPurchasePriceScheduleCreateRequestData.ts';
import { InAppPurchasePriceScheduleCreateRequestDataRelationships } from '../models/InAppPurchasePriceScheduleCreateRequestDataRelationships.ts';
import { InAppPurchasePriceScheduleCreateRequestDataRelationshipsManualPrices } from '../models/InAppPurchasePriceScheduleCreateRequestDataRelationshipsManualPrices.ts';
import { InAppPurchasePriceScheduleCreateRequestIncludedInner } from '../models/InAppPurchasePriceScheduleCreateRequestIncludedInner.ts';
import { InAppPurchasePriceScheduleRelationships } from '../models/InAppPurchasePriceScheduleRelationships.ts';
import { InAppPurchasePriceScheduleRelationshipsManualPrices } from '../models/InAppPurchasePriceScheduleRelationshipsManualPrices.ts';
import { InAppPurchasePriceScheduleRelationshipsManualPricesDataInner } from '../models/InAppPurchasePriceScheduleRelationshipsManualPricesDataInner.ts';
import { InAppPurchasePriceScheduleResponse } from '../models/InAppPurchasePriceScheduleResponse.ts';
import { InAppPurchasePriceScheduleResponseIncludedInner } from '../models/InAppPurchasePriceScheduleResponseIncludedInner.ts';
import { InAppPurchasePricesResponse } from '../models/InAppPurchasePricesResponse.ts';
import { InAppPurchasePricesResponseIncludedInner } from '../models/InAppPurchasePricesResponseIncludedInner.ts';
import { InAppPurchaseRelationships } from '../models/InAppPurchaseRelationships.ts';
import { InAppPurchaseResponse } from '../models/InAppPurchaseResponse.ts';
import { InAppPurchaseState } from '../models/InAppPurchaseState.ts';
import { InAppPurchaseSubmission } from '../models/InAppPurchaseSubmission.ts';
import { InAppPurchaseSubmissionCreateRequest } from '../models/InAppPurchaseSubmissionCreateRequest.ts';
import { InAppPurchaseSubmissionCreateRequestData } from '../models/InAppPurchaseSubmissionCreateRequestData.ts';
import { InAppPurchaseSubmissionResponse } from '../models/InAppPurchaseSubmissionResponse.ts';
import { InAppPurchaseType } from '../models/InAppPurchaseType.ts';
import { InAppPurchaseV2 } from '../models/InAppPurchaseV2.ts';
import { InAppPurchaseV2Attributes } from '../models/InAppPurchaseV2Attributes.ts';
import { InAppPurchaseV2CreateRequest } from '../models/InAppPurchaseV2CreateRequest.ts';
import { InAppPurchaseV2CreateRequestData } from '../models/InAppPurchaseV2CreateRequestData.ts';
import { InAppPurchaseV2CreateRequestDataAttributes } from '../models/InAppPurchaseV2CreateRequestDataAttributes.ts';
import { InAppPurchaseV2Relationships } from '../models/InAppPurchaseV2Relationships.ts';
import { InAppPurchaseV2RelationshipsAppStoreReviewScreenshot } from '../models/InAppPurchaseV2RelationshipsAppStoreReviewScreenshot.ts';
import { InAppPurchaseV2RelationshipsAppStoreReviewScreenshotData } from '../models/InAppPurchaseV2RelationshipsAppStoreReviewScreenshotData.ts';
import { InAppPurchaseV2RelationshipsContent } from '../models/InAppPurchaseV2RelationshipsContent.ts';
import { InAppPurchaseV2RelationshipsContentData } from '../models/InAppPurchaseV2RelationshipsContentData.ts';
import { InAppPurchaseV2RelationshipsIapPriceSchedule } from '../models/InAppPurchaseV2RelationshipsIapPriceSchedule.ts';
import { InAppPurchaseV2RelationshipsIapPriceScheduleData } from '../models/InAppPurchaseV2RelationshipsIapPriceScheduleData.ts';
import { InAppPurchaseV2RelationshipsInAppPurchaseAvailability } from '../models/InAppPurchaseV2RelationshipsInAppPurchaseAvailability.ts';
import { InAppPurchaseV2RelationshipsInAppPurchaseAvailabilityData } from '../models/InAppPurchaseV2RelationshipsInAppPurchaseAvailabilityData.ts';
import { InAppPurchaseV2RelationshipsInAppPurchaseLocalizations } from '../models/InAppPurchaseV2RelationshipsInAppPurchaseLocalizations.ts';
import { InAppPurchaseV2RelationshipsInAppPurchaseLocalizationsDataInner } from '../models/InAppPurchaseV2RelationshipsInAppPurchaseLocalizationsDataInner.ts';
import { InAppPurchaseV2RelationshipsPricePoints } from '../models/InAppPurchaseV2RelationshipsPricePoints.ts';
import { InAppPurchaseV2RelationshipsPromotedPurchase } from '../models/InAppPurchaseV2RelationshipsPromotedPurchase.ts';
import { InAppPurchaseV2Response } from '../models/InAppPurchaseV2Response.ts';
import { InAppPurchaseV2UpdateRequest } from '../models/InAppPurchaseV2UpdateRequest.ts';
import { InAppPurchaseV2UpdateRequestData } from '../models/InAppPurchaseV2UpdateRequestData.ts';
import { InAppPurchaseV2UpdateRequestDataAttributes } from '../models/InAppPurchaseV2UpdateRequestDataAttributes.ts';
import { InAppPurchasesResponse } from '../models/InAppPurchasesResponse.ts';
import { InAppPurchasesV2Response } from '../models/InAppPurchasesV2Response.ts';
import { InAppPurchasesV2ResponseIncludedInner } from '../models/InAppPurchasesV2ResponseIncludedInner.ts';
import { InternalBetaState } from '../models/InternalBetaState.ts';
import { KidsAgeBand } from '../models/KidsAgeBand.ts';
import { Location } from '../models/Location.ts';
import { MarketplaceDomain } from '../models/MarketplaceDomain.ts';
import { MarketplaceDomainCreateRequest } from '../models/MarketplaceDomainCreateRequest.ts';
import { MarketplaceDomainCreateRequestData } from '../models/MarketplaceDomainCreateRequestData.ts';
import { MarketplaceDomainResponse } from '../models/MarketplaceDomainResponse.ts';
import { MarketplaceDomainsResponse } from '../models/MarketplaceDomainsResponse.ts';
import { MarketplaceSearchDetail } from '../models/MarketplaceSearchDetail.ts';
import { MarketplaceSearchDetailAttributes } from '../models/MarketplaceSearchDetailAttributes.ts';
import { MarketplaceSearchDetailCreateRequest } from '../models/MarketplaceSearchDetailCreateRequest.ts';
import { MarketplaceSearchDetailCreateRequestData } from '../models/MarketplaceSearchDetailCreateRequestData.ts';
import { MarketplaceSearchDetailCreateRequestDataAttributes } from '../models/MarketplaceSearchDetailCreateRequestDataAttributes.ts';
import { MarketplaceSearchDetailResponse } from '../models/MarketplaceSearchDetailResponse.ts';
import { MarketplaceSearchDetailUpdateRequest } from '../models/MarketplaceSearchDetailUpdateRequest.ts';
import { MarketplaceSearchDetailUpdateRequestData } from '../models/MarketplaceSearchDetailUpdateRequestData.ts';
import { MarketplaceWebhook } from '../models/MarketplaceWebhook.ts';
import { MarketplaceWebhookAttributes } from '../models/MarketplaceWebhookAttributes.ts';
import { MarketplaceWebhookCreateRequest } from '../models/MarketplaceWebhookCreateRequest.ts';
import { MarketplaceWebhookCreateRequestData } from '../models/MarketplaceWebhookCreateRequestData.ts';
import { MarketplaceWebhookCreateRequestDataAttributes } from '../models/MarketplaceWebhookCreateRequestDataAttributes.ts';
import { MarketplaceWebhookResponse } from '../models/MarketplaceWebhookResponse.ts';
import { MarketplaceWebhookUpdateRequest } from '../models/MarketplaceWebhookUpdateRequest.ts';
import { MarketplaceWebhookUpdateRequestData } from '../models/MarketplaceWebhookUpdateRequestData.ts';
import { MarketplaceWebhookUpdateRequestDataAttributes } from '../models/MarketplaceWebhookUpdateRequestDataAttributes.ts';
import { MarketplaceWebhooksResponse } from '../models/MarketplaceWebhooksResponse.ts';
import { MetricCategory } from '../models/MetricCategory.ts';
import { MetricsInsight } from '../models/MetricsInsight.ts';
import { MetricsInsightPopulationsInner } from '../models/MetricsInsightPopulationsInner.ts';
import { PagedDocumentLinks } from '../models/PagedDocumentLinks.ts';
import { PagingInformation } from '../models/PagingInformation.ts';
import { PagingInformationPaging } from '../models/PagingInformationPaging.ts';
import { PerfPowerMetric } from '../models/PerfPowerMetric.ts';
import { PerfPowerMetricAttributes } from '../models/PerfPowerMetricAttributes.ts';
import { PhasedReleaseState } from '../models/PhasedReleaseState.ts';
import { Platform } from '../models/Platform.ts';
import { PreReleaseVersionsResponse } from '../models/PreReleaseVersionsResponse.ts';
import { PreReleaseVersionsResponseIncludedInner } from '../models/PreReleaseVersionsResponseIncludedInner.ts';
import { PreReleaseVersionsWithoutIncludesResponse } from '../models/PreReleaseVersionsWithoutIncludesResponse.ts';
import { PrereleaseVersion } from '../models/PrereleaseVersion.ts';
import { PrereleaseVersionAttributes } from '../models/PrereleaseVersionAttributes.ts';
import { PrereleaseVersionRelationships } from '../models/PrereleaseVersionRelationships.ts';
import { PrereleaseVersionResponse } from '../models/PrereleaseVersionResponse.ts';
import { PrereleaseVersionWithoutIncludesResponse } from '../models/PrereleaseVersionWithoutIncludesResponse.ts';
import { PreviewType } from '../models/PreviewType.ts';
import { Profile } from '../models/Profile.ts';
import { ProfileAttributes } from '../models/ProfileAttributes.ts';
import { ProfileCreateRequest } from '../models/ProfileCreateRequest.ts';
import { ProfileCreateRequestData } from '../models/ProfileCreateRequestData.ts';
import { ProfileCreateRequestDataAttributes } from '../models/ProfileCreateRequestDataAttributes.ts';
import { ProfileCreateRequestDataRelationships } from '../models/ProfileCreateRequestDataRelationships.ts';
import { ProfileCreateRequestDataRelationshipsCertificates } from '../models/ProfileCreateRequestDataRelationshipsCertificates.ts';
import { ProfileCreateRequestDataRelationshipsDevices } from '../models/ProfileCreateRequestDataRelationshipsDevices.ts';
import { ProfileRelationships } from '../models/ProfileRelationships.ts';
import { ProfileRelationshipsCertificates } from '../models/ProfileRelationshipsCertificates.ts';
import { ProfileRelationshipsCertificatesDataInner } from '../models/ProfileRelationshipsCertificatesDataInner.ts';
import { ProfileRelationshipsDevices } from '../models/ProfileRelationshipsDevices.ts';
import { ProfileRelationshipsDevicesDataInner } from '../models/ProfileRelationshipsDevicesDataInner.ts';
import { ProfileResponse } from '../models/ProfileResponse.ts';
import { ProfilesResponse } from '../models/ProfilesResponse.ts';
import { ProfilesResponseIncludedInner } from '../models/ProfilesResponseIncludedInner.ts';
import { ProfilesWithoutIncludesResponse } from '../models/ProfilesWithoutIncludesResponse.ts';
import { PromotedPurchase } from '../models/PromotedPurchase.ts';
import { PromotedPurchaseAttributes } from '../models/PromotedPurchaseAttributes.ts';
import { PromotedPurchaseCreateRequest } from '../models/PromotedPurchaseCreateRequest.ts';
import { PromotedPurchaseCreateRequestData } from '../models/PromotedPurchaseCreateRequestData.ts';
import { PromotedPurchaseCreateRequestDataAttributes } from '../models/PromotedPurchaseCreateRequestDataAttributes.ts';
import { PromotedPurchaseCreateRequestDataRelationships } from '../models/PromotedPurchaseCreateRequestDataRelationships.ts';
import { PromotedPurchaseCreateRequestDataRelationshipsSubscription } from '../models/PromotedPurchaseCreateRequestDataRelationshipsSubscription.ts';
import { PromotedPurchaseImage } from '../models/PromotedPurchaseImage.ts';
import { PromotedPurchaseImageAttributes } from '../models/PromotedPurchaseImageAttributes.ts';
import { PromotedPurchaseImageCreateRequest } from '../models/PromotedPurchaseImageCreateRequest.ts';
import { PromotedPurchaseImageCreateRequestData } from '../models/PromotedPurchaseImageCreateRequestData.ts';
import { PromotedPurchaseImageCreateRequestDataRelationships } from '../models/PromotedPurchaseImageCreateRequestDataRelationships.ts';
import { PromotedPurchaseImageCreateRequestDataRelationshipsPromotedPurchase } from '../models/PromotedPurchaseImageCreateRequestDataRelationshipsPromotedPurchase.ts';
import { PromotedPurchaseImageRelationships } from '../models/PromotedPurchaseImageRelationships.ts';
import { PromotedPurchaseImageResponse } from '../models/PromotedPurchaseImageResponse.ts';
import { PromotedPurchaseImageUpdateRequest } from '../models/PromotedPurchaseImageUpdateRequest.ts';
import { PromotedPurchaseImageUpdateRequestData } from '../models/PromotedPurchaseImageUpdateRequestData.ts';
import { PromotedPurchaseImagesResponse } from '../models/PromotedPurchaseImagesResponse.ts';
import { PromotedPurchaseRelationships } from '../models/PromotedPurchaseRelationships.ts';
import { PromotedPurchaseRelationshipsPromotionImages } from '../models/PromotedPurchaseRelationshipsPromotionImages.ts';
import { PromotedPurchaseRelationshipsPromotionImagesDataInner } from '../models/PromotedPurchaseRelationshipsPromotionImagesDataInner.ts';
import { PromotedPurchaseRelationshipsSubscription } from '../models/PromotedPurchaseRelationshipsSubscription.ts';
import { PromotedPurchaseRelationshipsSubscriptionData } from '../models/PromotedPurchaseRelationshipsSubscriptionData.ts';
import { PromotedPurchaseResponse } from '../models/PromotedPurchaseResponse.ts';
import { PromotedPurchaseUpdateRequest } from '../models/PromotedPurchaseUpdateRequest.ts';
import { PromotedPurchaseUpdateRequestData } from '../models/PromotedPurchaseUpdateRequestData.ts';
import { PromotedPurchaseUpdateRequestDataAttributes } from '../models/PromotedPurchaseUpdateRequestDataAttributes.ts';
import { PromotedPurchasesResponse } from '../models/PromotedPurchasesResponse.ts';
import { PromotedPurchasesResponseIncludedInner } from '../models/PromotedPurchasesResponseIncludedInner.ts';
import { Property } from '../models/Property.ts';
import { ResourceLinks } from '../models/ResourceLinks.ts';
import { ReviewSubmission } from '../models/ReviewSubmission.ts';
import { ReviewSubmissionAttributes } from '../models/ReviewSubmissionAttributes.ts';
import { ReviewSubmissionCreateRequest } from '../models/ReviewSubmissionCreateRequest.ts';
import { ReviewSubmissionCreateRequestData } from '../models/ReviewSubmissionCreateRequestData.ts';
import { ReviewSubmissionCreateRequestDataAttributes } from '../models/ReviewSubmissionCreateRequestDataAttributes.ts';
import { ReviewSubmissionItem } from '../models/ReviewSubmissionItem.ts';
import { ReviewSubmissionItemAttributes } from '../models/ReviewSubmissionItemAttributes.ts';
import { ReviewSubmissionItemCreateRequest } from '../models/ReviewSubmissionItemCreateRequest.ts';
import { ReviewSubmissionItemCreateRequestData } from '../models/ReviewSubmissionItemCreateRequestData.ts';
import { ReviewSubmissionItemCreateRequestDataRelationships } from '../models/ReviewSubmissionItemCreateRequestDataRelationships.ts';
import { ReviewSubmissionItemCreateRequestDataRelationshipsAppEvent } from '../models/ReviewSubmissionItemCreateRequestDataRelationshipsAppEvent.ts';
import { ReviewSubmissionItemCreateRequestDataRelationshipsReviewSubmission } from '../models/ReviewSubmissionItemCreateRequestDataRelationshipsReviewSubmission.ts';
import { ReviewSubmissionItemRelationships } from '../models/ReviewSubmissionItemRelationships.ts';
import { ReviewSubmissionItemResponse } from '../models/ReviewSubmissionItemResponse.ts';
import { ReviewSubmissionItemUpdateRequest } from '../models/ReviewSubmissionItemUpdateRequest.ts';
import { ReviewSubmissionItemUpdateRequestData } from '../models/ReviewSubmissionItemUpdateRequestData.ts';
import { ReviewSubmissionItemUpdateRequestDataAttributes } from '../models/ReviewSubmissionItemUpdateRequestDataAttributes.ts';
import { ReviewSubmissionItemsResponse } from '../models/ReviewSubmissionItemsResponse.ts';
import { ReviewSubmissionItemsResponseIncludedInner } from '../models/ReviewSubmissionItemsResponseIncludedInner.ts';
import { ReviewSubmissionRelationships } from '../models/ReviewSubmissionRelationships.ts';
import { ReviewSubmissionRelationshipsItems } from '../models/ReviewSubmissionRelationshipsItems.ts';
import { ReviewSubmissionRelationshipsItemsDataInner } from '../models/ReviewSubmissionRelationshipsItemsDataInner.ts';
import { ReviewSubmissionRelationshipsSubmittedByActor } from '../models/ReviewSubmissionRelationshipsSubmittedByActor.ts';
import { ReviewSubmissionRelationshipsSubmittedByActorData } from '../models/ReviewSubmissionRelationshipsSubmittedByActorData.ts';
import { ReviewSubmissionResponse } from '../models/ReviewSubmissionResponse.ts';
import { ReviewSubmissionUpdateRequest } from '../models/ReviewSubmissionUpdateRequest.ts';
import { ReviewSubmissionUpdateRequestData } from '../models/ReviewSubmissionUpdateRequestData.ts';
import { ReviewSubmissionUpdateRequestDataAttributes } from '../models/ReviewSubmissionUpdateRequestDataAttributes.ts';
import { ReviewSubmissionsResponse } from '../models/ReviewSubmissionsResponse.ts';
import { ReviewSubmissionsResponseIncludedInner } from '../models/ReviewSubmissionsResponseIncludedInner.ts';
import { RoutingAppCoverage } from '../models/RoutingAppCoverage.ts';
import { RoutingAppCoverageCreateRequest } from '../models/RoutingAppCoverageCreateRequest.ts';
import { RoutingAppCoverageCreateRequestData } from '../models/RoutingAppCoverageCreateRequestData.ts';
import { RoutingAppCoverageResponse } from '../models/RoutingAppCoverageResponse.ts';
import { RoutingAppCoverageUpdateRequest } from '../models/RoutingAppCoverageUpdateRequest.ts';
import { RoutingAppCoverageUpdateRequestData } from '../models/RoutingAppCoverageUpdateRequestData.ts';
import { RoutingAppCoverageWithoutIncludesResponse } from '../models/RoutingAppCoverageWithoutIncludesResponse.ts';
import { SandboxTesterV2 } from '../models/SandboxTesterV2.ts';
import { SandboxTesterV2Attributes } from '../models/SandboxTesterV2Attributes.ts';
import { SandboxTesterV2Response } from '../models/SandboxTesterV2Response.ts';
import { SandboxTesterV2UpdateRequest } from '../models/SandboxTesterV2UpdateRequest.ts';
import { SandboxTesterV2UpdateRequestData } from '../models/SandboxTesterV2UpdateRequestData.ts';
import { SandboxTesterV2UpdateRequestDataAttributes } from '../models/SandboxTesterV2UpdateRequestDataAttributes.ts';
import { SandboxTestersClearPurchaseHistoryRequestV2 } from '../models/SandboxTestersClearPurchaseHistoryRequestV2.ts';
import { SandboxTestersClearPurchaseHistoryRequestV2CreateRequest } from '../models/SandboxTestersClearPurchaseHistoryRequestV2CreateRequest.ts';
import { SandboxTestersClearPurchaseHistoryRequestV2CreateRequestData } from '../models/SandboxTestersClearPurchaseHistoryRequestV2CreateRequestData.ts';
import { SandboxTestersClearPurchaseHistoryRequestV2CreateRequestDataRelationships } from '../models/SandboxTestersClearPurchaseHistoryRequestV2CreateRequestDataRelationships.ts';
import { SandboxTestersClearPurchaseHistoryRequestV2CreateRequestDataRelationshipsSandboxTesters } from '../models/SandboxTestersClearPurchaseHistoryRequestV2CreateRequestDataRelationshipsSandboxTesters.ts';
import { SandboxTestersClearPurchaseHistoryRequestV2CreateRequestDataRelationshipsSandboxTestersDataInner } from '../models/SandboxTestersClearPurchaseHistoryRequestV2CreateRequestDataRelationshipsSandboxTestersDataInner.ts';
import { SandboxTestersClearPurchaseHistoryRequestV2Response } from '../models/SandboxTestersClearPurchaseHistoryRequestV2Response.ts';
import { SandboxTestersV2Response } from '../models/SandboxTestersV2Response.ts';
import { ScmGitReference } from '../models/ScmGitReference.ts';
import { ScmGitReferenceAttributes } from '../models/ScmGitReferenceAttributes.ts';
import { ScmGitReferenceRelationships } from '../models/ScmGitReferenceRelationships.ts';
import { ScmGitReferenceResponse } from '../models/ScmGitReferenceResponse.ts';
import { ScmGitReferencesResponse } from '../models/ScmGitReferencesResponse.ts';
import { ScmProvider } from '../models/ScmProvider.ts';
import { ScmProviderAttributes } from '../models/ScmProviderAttributes.ts';
import { ScmProviderResponse } from '../models/ScmProviderResponse.ts';
import { ScmProviderType } from '../models/ScmProviderType.ts';
import { ScmProvidersResponse } from '../models/ScmProvidersResponse.ts';
import { ScmPullRequest } from '../models/ScmPullRequest.ts';
import { ScmPullRequestAttributes } from '../models/ScmPullRequestAttributes.ts';
import { ScmPullRequestResponse } from '../models/ScmPullRequestResponse.ts';
import { ScmPullRequestsResponse } from '../models/ScmPullRequestsResponse.ts';
import { ScmRepositoriesResponse } from '../models/ScmRepositoriesResponse.ts';
import { ScmRepositoriesResponseIncludedInner } from '../models/ScmRepositoriesResponseIncludedInner.ts';
import { ScmRepository } from '../models/ScmRepository.ts';
import { ScmRepositoryAttributes } from '../models/ScmRepositoryAttributes.ts';
import { ScmRepositoryRelationships } from '../models/ScmRepositoryRelationships.ts';
import { ScmRepositoryRelationshipsScmProvider } from '../models/ScmRepositoryRelationshipsScmProvider.ts';
import { ScmRepositoryRelationshipsScmProviderData } from '../models/ScmRepositoryRelationshipsScmProviderData.ts';
import { ScmRepositoryResponse } from '../models/ScmRepositoryResponse.ts';
import { ScreenshotDisplayType } from '../models/ScreenshotDisplayType.ts';
import { Subscription } from '../models/Subscription.ts';
import { SubscriptionAppStoreReviewScreenshot } from '../models/SubscriptionAppStoreReviewScreenshot.ts';
import { SubscriptionAppStoreReviewScreenshotCreateRequest } from '../models/SubscriptionAppStoreReviewScreenshotCreateRequest.ts';
import { SubscriptionAppStoreReviewScreenshotCreateRequestData } from '../models/SubscriptionAppStoreReviewScreenshotCreateRequestData.ts';
import { SubscriptionAppStoreReviewScreenshotCreateRequestDataRelationships } from '../models/SubscriptionAppStoreReviewScreenshotCreateRequestDataRelationships.ts';
import { SubscriptionAppStoreReviewScreenshotCreateRequestDataRelationshipsSubscription } from '../models/SubscriptionAppStoreReviewScreenshotCreateRequestDataRelationshipsSubscription.ts';
import { SubscriptionAppStoreReviewScreenshotRelationships } from '../models/SubscriptionAppStoreReviewScreenshotRelationships.ts';
import { SubscriptionAppStoreReviewScreenshotResponse } from '../models/SubscriptionAppStoreReviewScreenshotResponse.ts';
import { SubscriptionAppStoreReviewScreenshotUpdateRequest } from '../models/SubscriptionAppStoreReviewScreenshotUpdateRequest.ts';
import { SubscriptionAppStoreReviewScreenshotUpdateRequestData } from '../models/SubscriptionAppStoreReviewScreenshotUpdateRequestData.ts';
import { SubscriptionAttributes } from '../models/SubscriptionAttributes.ts';
import { SubscriptionAvailability } from '../models/SubscriptionAvailability.ts';
import { SubscriptionAvailabilityCreateRequest } from '../models/SubscriptionAvailabilityCreateRequest.ts';
import { SubscriptionAvailabilityCreateRequestData } from '../models/SubscriptionAvailabilityCreateRequestData.ts';
import { SubscriptionAvailabilityCreateRequestDataRelationships } from '../models/SubscriptionAvailabilityCreateRequestDataRelationships.ts';
import { SubscriptionAvailabilityRelationships } from '../models/SubscriptionAvailabilityRelationships.ts';
import { SubscriptionAvailabilityResponse } from '../models/SubscriptionAvailabilityResponse.ts';
import { SubscriptionAvailabilityResponseIncludedInner } from '../models/SubscriptionAvailabilityResponseIncludedInner.ts';
import { SubscriptionCreateRequest } from '../models/SubscriptionCreateRequest.ts';
import { SubscriptionCreateRequestData } from '../models/SubscriptionCreateRequestData.ts';
import { SubscriptionCreateRequestDataAttributes } from '../models/SubscriptionCreateRequestDataAttributes.ts';
import { SubscriptionCreateRequestDataRelationships } from '../models/SubscriptionCreateRequestDataRelationships.ts';
import { SubscriptionCustomerEligibility } from '../models/SubscriptionCustomerEligibility.ts';
import { SubscriptionGracePeriod } from '../models/SubscriptionGracePeriod.ts';
import { SubscriptionGracePeriodAttributes } from '../models/SubscriptionGracePeriodAttributes.ts';
import { SubscriptionGracePeriodDuration } from '../models/SubscriptionGracePeriodDuration.ts';
import { SubscriptionGracePeriodResponse } from '../models/SubscriptionGracePeriodResponse.ts';
import { SubscriptionGracePeriodUpdateRequest } from '../models/SubscriptionGracePeriodUpdateRequest.ts';
import { SubscriptionGracePeriodUpdateRequestData } from '../models/SubscriptionGracePeriodUpdateRequestData.ts';
import { SubscriptionGroup } from '../models/SubscriptionGroup.ts';
import { SubscriptionGroupCreateRequest } from '../models/SubscriptionGroupCreateRequest.ts';
import { SubscriptionGroupCreateRequestData } from '../models/SubscriptionGroupCreateRequestData.ts';
import { SubscriptionGroupCreateRequestDataAttributes } from '../models/SubscriptionGroupCreateRequestDataAttributes.ts';
import { SubscriptionGroupLocalization } from '../models/SubscriptionGroupLocalization.ts';
import { SubscriptionGroupLocalizationAttributes } from '../models/SubscriptionGroupLocalizationAttributes.ts';
import { SubscriptionGroupLocalizationCreateRequest } from '../models/SubscriptionGroupLocalizationCreateRequest.ts';
import { SubscriptionGroupLocalizationCreateRequestData } from '../models/SubscriptionGroupLocalizationCreateRequestData.ts';
import { SubscriptionGroupLocalizationCreateRequestDataAttributes } from '../models/SubscriptionGroupLocalizationCreateRequestDataAttributes.ts';
import { SubscriptionGroupLocalizationCreateRequestDataRelationships } from '../models/SubscriptionGroupLocalizationCreateRequestDataRelationships.ts';
import { SubscriptionGroupLocalizationCreateRequestDataRelationshipsSubscriptionGroup } from '../models/SubscriptionGroupLocalizationCreateRequestDataRelationshipsSubscriptionGroup.ts';
import { SubscriptionGroupLocalizationRelationships } from '../models/SubscriptionGroupLocalizationRelationships.ts';
import { SubscriptionGroupLocalizationRelationshipsSubscriptionGroup } from '../models/SubscriptionGroupLocalizationRelationshipsSubscriptionGroup.ts';
import { SubscriptionGroupLocalizationResponse } from '../models/SubscriptionGroupLocalizationResponse.ts';
import { SubscriptionGroupLocalizationUpdateRequest } from '../models/SubscriptionGroupLocalizationUpdateRequest.ts';
import { SubscriptionGroupLocalizationUpdateRequestData } from '../models/SubscriptionGroupLocalizationUpdateRequestData.ts';
import { SubscriptionGroupLocalizationUpdateRequestDataAttributes } from '../models/SubscriptionGroupLocalizationUpdateRequestDataAttributes.ts';
import { SubscriptionGroupLocalizationsResponse } from '../models/SubscriptionGroupLocalizationsResponse.ts';
import { SubscriptionGroupRelationships } from '../models/SubscriptionGroupRelationships.ts';
import { SubscriptionGroupRelationshipsSubscriptionGroupLocalizations } from '../models/SubscriptionGroupRelationshipsSubscriptionGroupLocalizations.ts';
import { SubscriptionGroupRelationshipsSubscriptionGroupLocalizationsDataInner } from '../models/SubscriptionGroupRelationshipsSubscriptionGroupLocalizationsDataInner.ts';
import { SubscriptionGroupRelationshipsSubscriptions } from '../models/SubscriptionGroupRelationshipsSubscriptions.ts';
import { SubscriptionGroupResponse } from '../models/SubscriptionGroupResponse.ts';
import { SubscriptionGroupSubmission } from '../models/SubscriptionGroupSubmission.ts';
import { SubscriptionGroupSubmissionCreateRequest } from '../models/SubscriptionGroupSubmissionCreateRequest.ts';
import { SubscriptionGroupSubmissionCreateRequestData } from '../models/SubscriptionGroupSubmissionCreateRequestData.ts';
import { SubscriptionGroupSubmissionResponse } from '../models/SubscriptionGroupSubmissionResponse.ts';
import { SubscriptionGroupUpdateRequest } from '../models/SubscriptionGroupUpdateRequest.ts';
import { SubscriptionGroupUpdateRequestData } from '../models/SubscriptionGroupUpdateRequestData.ts';
import { SubscriptionGroupsResponse } from '../models/SubscriptionGroupsResponse.ts';
import { SubscriptionGroupsResponseIncludedInner } from '../models/SubscriptionGroupsResponseIncludedInner.ts';
import { SubscriptionIntroductoryOffer } from '../models/SubscriptionIntroductoryOffer.ts';
import { SubscriptionIntroductoryOfferAttributes } from '../models/SubscriptionIntroductoryOfferAttributes.ts';
import { SubscriptionIntroductoryOfferCreateRequest } from '../models/SubscriptionIntroductoryOfferCreateRequest.ts';
import { SubscriptionIntroductoryOfferCreateRequestData } from '../models/SubscriptionIntroductoryOfferCreateRequestData.ts';
import { SubscriptionIntroductoryOfferCreateRequestDataRelationships } from '../models/SubscriptionIntroductoryOfferCreateRequestDataRelationships.ts';
import { SubscriptionIntroductoryOfferInlineCreate } from '../models/SubscriptionIntroductoryOfferInlineCreate.ts';
import { SubscriptionIntroductoryOfferInlineCreateAttributes } from '../models/SubscriptionIntroductoryOfferInlineCreateAttributes.ts';
import { SubscriptionIntroductoryOfferInlineCreateRelationships } from '../models/SubscriptionIntroductoryOfferInlineCreateRelationships.ts';
import { SubscriptionIntroductoryOfferInlineCreateRelationshipsSubscriptionPricePoint } from '../models/SubscriptionIntroductoryOfferInlineCreateRelationshipsSubscriptionPricePoint.ts';
import { SubscriptionIntroductoryOfferInlineCreateRelationshipsTerritory } from '../models/SubscriptionIntroductoryOfferInlineCreateRelationshipsTerritory.ts';
import { SubscriptionIntroductoryOfferRelationships } from '../models/SubscriptionIntroductoryOfferRelationships.ts';
import { SubscriptionIntroductoryOfferRelationshipsSubscriptionPricePoint } from '../models/SubscriptionIntroductoryOfferRelationshipsSubscriptionPricePoint.ts';
import { SubscriptionIntroductoryOfferRelationshipsSubscriptionPricePointData } from '../models/SubscriptionIntroductoryOfferRelationshipsSubscriptionPricePointData.ts';
import { SubscriptionIntroductoryOfferResponse } from '../models/SubscriptionIntroductoryOfferResponse.ts';
import { SubscriptionIntroductoryOfferUpdateRequest } from '../models/SubscriptionIntroductoryOfferUpdateRequest.ts';
import { SubscriptionIntroductoryOfferUpdateRequestData } from '../models/SubscriptionIntroductoryOfferUpdateRequestData.ts';
import { SubscriptionIntroductoryOfferUpdateRequestDataAttributes } from '../models/SubscriptionIntroductoryOfferUpdateRequestDataAttributes.ts';
import { SubscriptionIntroductoryOffersLinkagesRequest } from '../models/SubscriptionIntroductoryOffersLinkagesRequest.ts';
import { SubscriptionIntroductoryOffersLinkagesResponse } from '../models/SubscriptionIntroductoryOffersLinkagesResponse.ts';
import { SubscriptionIntroductoryOffersResponse } from '../models/SubscriptionIntroductoryOffersResponse.ts';
import { SubscriptionIntroductoryOffersResponseIncludedInner } from '../models/SubscriptionIntroductoryOffersResponseIncludedInner.ts';
import { SubscriptionLocalization } from '../models/SubscriptionLocalization.ts';
import { SubscriptionLocalizationCreateRequest } from '../models/SubscriptionLocalizationCreateRequest.ts';
import { SubscriptionLocalizationCreateRequestData } from '../models/SubscriptionLocalizationCreateRequestData.ts';
import { SubscriptionLocalizationResponse } from '../models/SubscriptionLocalizationResponse.ts';
import { SubscriptionLocalizationUpdateRequest } from '../models/SubscriptionLocalizationUpdateRequest.ts';
import { SubscriptionLocalizationUpdateRequestData } from '../models/SubscriptionLocalizationUpdateRequestData.ts';
import { SubscriptionLocalizationsResponse } from '../models/SubscriptionLocalizationsResponse.ts';
import { SubscriptionOfferCode } from '../models/SubscriptionOfferCode.ts';
import { SubscriptionOfferCodeAttributes } from '../models/SubscriptionOfferCodeAttributes.ts';
import { SubscriptionOfferCodeCreateRequest } from '../models/SubscriptionOfferCodeCreateRequest.ts';
import { SubscriptionOfferCodeCreateRequestData } from '../models/SubscriptionOfferCodeCreateRequestData.ts';
import { SubscriptionOfferCodeCreateRequestDataAttributes } from '../models/SubscriptionOfferCodeCreateRequestDataAttributes.ts';
import { SubscriptionOfferCodeCreateRequestDataRelationships } from '../models/SubscriptionOfferCodeCreateRequestDataRelationships.ts';
import { SubscriptionOfferCodeCreateRequestDataRelationshipsPrices } from '../models/SubscriptionOfferCodeCreateRequestDataRelationshipsPrices.ts';
import { SubscriptionOfferCodeCustomCode } from '../models/SubscriptionOfferCodeCustomCode.ts';
import { SubscriptionOfferCodeCustomCodeAttributes } from '../models/SubscriptionOfferCodeCustomCodeAttributes.ts';
import { SubscriptionOfferCodeCustomCodeCreateRequest } from '../models/SubscriptionOfferCodeCustomCodeCreateRequest.ts';
import { SubscriptionOfferCodeCustomCodeCreateRequestData } from '../models/SubscriptionOfferCodeCustomCodeCreateRequestData.ts';
import { SubscriptionOfferCodeCustomCodeCreateRequestDataAttributes } from '../models/SubscriptionOfferCodeCustomCodeCreateRequestDataAttributes.ts';
import { SubscriptionOfferCodeCustomCodeCreateRequestDataRelationships } from '../models/SubscriptionOfferCodeCustomCodeCreateRequestDataRelationships.ts';
import { SubscriptionOfferCodeCustomCodeCreateRequestDataRelationshipsOfferCode } from '../models/SubscriptionOfferCodeCustomCodeCreateRequestDataRelationshipsOfferCode.ts';
import { SubscriptionOfferCodeCustomCodeRelationships } from '../models/SubscriptionOfferCodeCustomCodeRelationships.ts';
import { SubscriptionOfferCodeCustomCodeRelationshipsOfferCode } from '../models/SubscriptionOfferCodeCustomCodeRelationshipsOfferCode.ts';
import { SubscriptionOfferCodeCustomCodeRelationshipsOfferCodeData } from '../models/SubscriptionOfferCodeCustomCodeRelationshipsOfferCodeData.ts';
import { SubscriptionOfferCodeCustomCodeResponse } from '../models/SubscriptionOfferCodeCustomCodeResponse.ts';
import { SubscriptionOfferCodeCustomCodeUpdateRequest } from '../models/SubscriptionOfferCodeCustomCodeUpdateRequest.ts';
import { SubscriptionOfferCodeCustomCodeUpdateRequestData } from '../models/SubscriptionOfferCodeCustomCodeUpdateRequestData.ts';
import { SubscriptionOfferCodeCustomCodeUpdateRequestDataAttributes } from '../models/SubscriptionOfferCodeCustomCodeUpdateRequestDataAttributes.ts';
import { SubscriptionOfferCodeCustomCodesResponse } from '../models/SubscriptionOfferCodeCustomCodesResponse.ts';
import { SubscriptionOfferCodeOneTimeUseCode } from '../models/SubscriptionOfferCodeOneTimeUseCode.ts';
import { SubscriptionOfferCodeOneTimeUseCodeAttributes } from '../models/SubscriptionOfferCodeOneTimeUseCodeAttributes.ts';
import { SubscriptionOfferCodeOneTimeUseCodeCreateRequest } from '../models/SubscriptionOfferCodeOneTimeUseCodeCreateRequest.ts';
import { SubscriptionOfferCodeOneTimeUseCodeCreateRequestData } from '../models/SubscriptionOfferCodeOneTimeUseCodeCreateRequestData.ts';
import { SubscriptionOfferCodeOneTimeUseCodeCreateRequestDataAttributes } from '../models/SubscriptionOfferCodeOneTimeUseCodeCreateRequestDataAttributes.ts';
import { SubscriptionOfferCodeOneTimeUseCodeResponse } from '../models/SubscriptionOfferCodeOneTimeUseCodeResponse.ts';
import { SubscriptionOfferCodeOneTimeUseCodeUpdateRequest } from '../models/SubscriptionOfferCodeOneTimeUseCodeUpdateRequest.ts';
import { SubscriptionOfferCodeOneTimeUseCodeUpdateRequestData } from '../models/SubscriptionOfferCodeOneTimeUseCodeUpdateRequestData.ts';
import { SubscriptionOfferCodeOneTimeUseCodeValue } from '../models/SubscriptionOfferCodeOneTimeUseCodeValue.ts';
import { SubscriptionOfferCodeOneTimeUseCodesResponse } from '../models/SubscriptionOfferCodeOneTimeUseCodesResponse.ts';
import { SubscriptionOfferCodePrice } from '../models/SubscriptionOfferCodePrice.ts';
import { SubscriptionOfferCodePriceInlineCreate } from '../models/SubscriptionOfferCodePriceInlineCreate.ts';
import { SubscriptionOfferCodePriceInlineCreateRelationships } from '../models/SubscriptionOfferCodePriceInlineCreateRelationships.ts';
import { SubscriptionOfferCodePriceRelationships } from '../models/SubscriptionOfferCodePriceRelationships.ts';
import { SubscriptionOfferCodePricesResponse } from '../models/SubscriptionOfferCodePricesResponse.ts';
import { SubscriptionOfferCodePricesResponseIncludedInner } from '../models/SubscriptionOfferCodePricesResponseIncludedInner.ts';
import { SubscriptionOfferCodeRelationships } from '../models/SubscriptionOfferCodeRelationships.ts';
import { SubscriptionOfferCodeRelationshipsCustomCodes } from '../models/SubscriptionOfferCodeRelationshipsCustomCodes.ts';
import { SubscriptionOfferCodeRelationshipsCustomCodesDataInner } from '../models/SubscriptionOfferCodeRelationshipsCustomCodesDataInner.ts';
import { SubscriptionOfferCodeRelationshipsOneTimeUseCodes } from '../models/SubscriptionOfferCodeRelationshipsOneTimeUseCodes.ts';
import { SubscriptionOfferCodeRelationshipsOneTimeUseCodesDataInner } from '../models/SubscriptionOfferCodeRelationshipsOneTimeUseCodesDataInner.ts';
import { SubscriptionOfferCodeRelationshipsPrices } from '../models/SubscriptionOfferCodeRelationshipsPrices.ts';
import { SubscriptionOfferCodeRelationshipsPricesDataInner } from '../models/SubscriptionOfferCodeRelationshipsPricesDataInner.ts';
import { SubscriptionOfferCodeResponse } from '../models/SubscriptionOfferCodeResponse.ts';
import { SubscriptionOfferCodeUpdateRequest } from '../models/SubscriptionOfferCodeUpdateRequest.ts';
import { SubscriptionOfferCodeUpdateRequestData } from '../models/SubscriptionOfferCodeUpdateRequestData.ts';
import { SubscriptionOfferCodesResponse } from '../models/SubscriptionOfferCodesResponse.ts';
import { SubscriptionOfferCodesResponseIncludedInner } from '../models/SubscriptionOfferCodesResponseIncludedInner.ts';
import { SubscriptionOfferDuration } from '../models/SubscriptionOfferDuration.ts';
import { SubscriptionOfferEligibility } from '../models/SubscriptionOfferEligibility.ts';
import { SubscriptionOfferMode } from '../models/SubscriptionOfferMode.ts';
import { SubscriptionPrice } from '../models/SubscriptionPrice.ts';
import { SubscriptionPriceAttributes } from '../models/SubscriptionPriceAttributes.ts';
import { SubscriptionPriceCreateRequest } from '../models/SubscriptionPriceCreateRequest.ts';
import { SubscriptionPriceCreateRequestData } from '../models/SubscriptionPriceCreateRequestData.ts';
import { SubscriptionPriceCreateRequestDataRelationships } from '../models/SubscriptionPriceCreateRequestDataRelationships.ts';
import { SubscriptionPriceCreateRequestDataRelationshipsSubscriptionPricePoint } from '../models/SubscriptionPriceCreateRequestDataRelationshipsSubscriptionPricePoint.ts';
import { SubscriptionPriceInlineCreate } from '../models/SubscriptionPriceInlineCreate.ts';
import { SubscriptionPriceInlineCreateAttributes } from '../models/SubscriptionPriceInlineCreateAttributes.ts';
import { SubscriptionPricePoint } from '../models/SubscriptionPricePoint.ts';
import { SubscriptionPricePointAttributes } from '../models/SubscriptionPricePointAttributes.ts';
import { SubscriptionPricePointInlineCreate } from '../models/SubscriptionPricePointInlineCreate.ts';
import { SubscriptionPricePointResponse } from '../models/SubscriptionPricePointResponse.ts';
import { SubscriptionPricePointsResponse } from '../models/SubscriptionPricePointsResponse.ts';
import { SubscriptionPriceResponse } from '../models/SubscriptionPriceResponse.ts';
import { SubscriptionPricesLinkagesRequest } from '../models/SubscriptionPricesLinkagesRequest.ts';
import { SubscriptionPricesLinkagesResponse } from '../models/SubscriptionPricesLinkagesResponse.ts';
import { SubscriptionPricesResponse } from '../models/SubscriptionPricesResponse.ts';
import { SubscriptionPromotionalOffer } from '../models/SubscriptionPromotionalOffer.ts';
import { SubscriptionPromotionalOfferAttributes } from '../models/SubscriptionPromotionalOfferAttributes.ts';
import { SubscriptionPromotionalOfferCreateRequest } from '../models/SubscriptionPromotionalOfferCreateRequest.ts';
import { SubscriptionPromotionalOfferCreateRequestData } from '../models/SubscriptionPromotionalOfferCreateRequestData.ts';
import { SubscriptionPromotionalOfferCreateRequestDataRelationships } from '../models/SubscriptionPromotionalOfferCreateRequestDataRelationships.ts';
import { SubscriptionPromotionalOfferCreateRequestDataRelationshipsPrices } from '../models/SubscriptionPromotionalOfferCreateRequestDataRelationshipsPrices.ts';
import { SubscriptionPromotionalOfferInlineCreate } from '../models/SubscriptionPromotionalOfferInlineCreate.ts';
import { SubscriptionPromotionalOfferInlineCreateAttributes } from '../models/SubscriptionPromotionalOfferInlineCreateAttributes.ts';
import { SubscriptionPromotionalOfferInlineCreateRelationships } from '../models/SubscriptionPromotionalOfferInlineCreateRelationships.ts';
import { SubscriptionPromotionalOfferInlineCreateRelationshipsPrices } from '../models/SubscriptionPromotionalOfferInlineCreateRelationshipsPrices.ts';
import { SubscriptionPromotionalOfferPrice } from '../models/SubscriptionPromotionalOfferPrice.ts';
import { SubscriptionPromotionalOfferPriceInlineCreate } from '../models/SubscriptionPromotionalOfferPriceInlineCreate.ts';
import { SubscriptionPromotionalOfferPricesResponse } from '../models/SubscriptionPromotionalOfferPricesResponse.ts';
import { SubscriptionPromotionalOfferRelationships } from '../models/SubscriptionPromotionalOfferRelationships.ts';
import { SubscriptionPromotionalOfferRelationshipsPrices } from '../models/SubscriptionPromotionalOfferRelationshipsPrices.ts';
import { SubscriptionPromotionalOfferRelationshipsPricesDataInner } from '../models/SubscriptionPromotionalOfferRelationshipsPricesDataInner.ts';
import { SubscriptionPromotionalOfferResponse } from '../models/SubscriptionPromotionalOfferResponse.ts';
import { SubscriptionPromotionalOfferUpdateRequest } from '../models/SubscriptionPromotionalOfferUpdateRequest.ts';
import { SubscriptionPromotionalOfferUpdateRequestData } from '../models/SubscriptionPromotionalOfferUpdateRequestData.ts';
import { SubscriptionPromotionalOfferUpdateRequestDataRelationships } from '../models/SubscriptionPromotionalOfferUpdateRequestDataRelationships.ts';
import { SubscriptionPromotionalOffersResponse } from '../models/SubscriptionPromotionalOffersResponse.ts';
import { SubscriptionPromotionalOffersResponseIncludedInner } from '../models/SubscriptionPromotionalOffersResponseIncludedInner.ts';
import { SubscriptionRelationships } from '../models/SubscriptionRelationships.ts';
import { SubscriptionRelationshipsAppStoreReviewScreenshot } from '../models/SubscriptionRelationshipsAppStoreReviewScreenshot.ts';
import { SubscriptionRelationshipsAppStoreReviewScreenshotData } from '../models/SubscriptionRelationshipsAppStoreReviewScreenshotData.ts';
import { SubscriptionRelationshipsIntroductoryOffers } from '../models/SubscriptionRelationshipsIntroductoryOffers.ts';
import { SubscriptionRelationshipsIntroductoryOffersDataInner } from '../models/SubscriptionRelationshipsIntroductoryOffersDataInner.ts';
import { SubscriptionRelationshipsOfferCodes } from '../models/SubscriptionRelationshipsOfferCodes.ts';
import { SubscriptionRelationshipsPrices } from '../models/SubscriptionRelationshipsPrices.ts';
import { SubscriptionRelationshipsPricesDataInner } from '../models/SubscriptionRelationshipsPricesDataInner.ts';
import { SubscriptionRelationshipsPromotionalOffers } from '../models/SubscriptionRelationshipsPromotionalOffers.ts';
import { SubscriptionRelationshipsPromotionalOffersDataInner } from '../models/SubscriptionRelationshipsPromotionalOffersDataInner.ts';
import { SubscriptionRelationshipsSubscriptionAvailability } from '../models/SubscriptionRelationshipsSubscriptionAvailability.ts';
import { SubscriptionRelationshipsSubscriptionAvailabilityData } from '../models/SubscriptionRelationshipsSubscriptionAvailabilityData.ts';
import { SubscriptionRelationshipsSubscriptionLocalizations } from '../models/SubscriptionRelationshipsSubscriptionLocalizations.ts';
import { SubscriptionRelationshipsSubscriptionLocalizationsDataInner } from '../models/SubscriptionRelationshipsSubscriptionLocalizationsDataInner.ts';
import { SubscriptionResponse } from '../models/SubscriptionResponse.ts';
import { SubscriptionStatusUrlVersion } from '../models/SubscriptionStatusUrlVersion.ts';
import { SubscriptionSubmission } from '../models/SubscriptionSubmission.ts';
import { SubscriptionSubmissionCreateRequest } from '../models/SubscriptionSubmissionCreateRequest.ts';
import { SubscriptionSubmissionCreateRequestData } from '../models/SubscriptionSubmissionCreateRequestData.ts';
import { SubscriptionSubmissionResponse } from '../models/SubscriptionSubmissionResponse.ts';
import { SubscriptionUpdateRequest } from '../models/SubscriptionUpdateRequest.ts';
import { SubscriptionUpdateRequestData } from '../models/SubscriptionUpdateRequestData.ts';
import { SubscriptionUpdateRequestDataAttributes } from '../models/SubscriptionUpdateRequestDataAttributes.ts';
import { SubscriptionUpdateRequestDataRelationships } from '../models/SubscriptionUpdateRequestDataRelationships.ts';
import { SubscriptionUpdateRequestDataRelationshipsIntroductoryOffers } from '../models/SubscriptionUpdateRequestDataRelationshipsIntroductoryOffers.ts';
import { SubscriptionUpdateRequestDataRelationshipsPrices } from '../models/SubscriptionUpdateRequestDataRelationshipsPrices.ts';
import { SubscriptionUpdateRequestDataRelationshipsPromotionalOffers } from '../models/SubscriptionUpdateRequestDataRelationshipsPromotionalOffers.ts';
import { SubscriptionUpdateRequestIncludedInner } from '../models/SubscriptionUpdateRequestIncludedInner.ts';
import { SubscriptionsResponse } from '../models/SubscriptionsResponse.ts';
import { SubscriptionsResponseIncludedInner } from '../models/SubscriptionsResponseIncludedInner.ts';
import { TerritoriesResponse } from '../models/TerritoriesResponse.ts';
import { TerritoriesWithoutIncludesResponse } from '../models/TerritoriesWithoutIncludesResponse.ts';
import { Territory } from '../models/Territory.ts';
import { TerritoryAttributes } from '../models/TerritoryAttributes.ts';
import { TerritoryAvailabilitiesResponse } from '../models/TerritoryAvailabilitiesResponse.ts';
import { TerritoryAvailability } from '../models/TerritoryAvailability.ts';
import { TerritoryAvailabilityAttributes } from '../models/TerritoryAvailabilityAttributes.ts';
import { TerritoryAvailabilityInlineCreate } from '../models/TerritoryAvailabilityInlineCreate.ts';
import { TerritoryAvailabilityResponse } from '../models/TerritoryAvailabilityResponse.ts';
import { TerritoryAvailabilityUpdateRequest } from '../models/TerritoryAvailabilityUpdateRequest.ts';
import { TerritoryAvailabilityUpdateRequestData } from '../models/TerritoryAvailabilityUpdateRequestData.ts';
import { TerritoryAvailabilityUpdateRequestDataAttributes } from '../models/TerritoryAvailabilityUpdateRequestDataAttributes.ts';
import { TerritoryCode } from '../models/TerritoryCode.ts';
import { TerritoryInlineCreate } from '../models/TerritoryInlineCreate.ts';
import { TerritoryResponse } from '../models/TerritoryResponse.ts';
import { UploadOperation } from '../models/UploadOperation.ts';
import { User } from '../models/User.ts';
import { UserAttributes } from '../models/UserAttributes.ts';
import { UserInvitation } from '../models/UserInvitation.ts';
import { UserInvitationAttributes } from '../models/UserInvitationAttributes.ts';
import { UserInvitationCreateRequest } from '../models/UserInvitationCreateRequest.ts';
import { UserInvitationCreateRequestData } from '../models/UserInvitationCreateRequestData.ts';
import { UserInvitationCreateRequestDataAttributes } from '../models/UserInvitationCreateRequestDataAttributes.ts';
import { UserInvitationCreateRequestDataRelationships } from '../models/UserInvitationCreateRequestDataRelationships.ts';
import { UserInvitationCreateRequestDataRelationshipsVisibleApps } from '../models/UserInvitationCreateRequestDataRelationshipsVisibleApps.ts';
import { UserInvitationRelationships } from '../models/UserInvitationRelationships.ts';
import { UserInvitationResponse } from '../models/UserInvitationResponse.ts';
import { UserInvitationsResponse } from '../models/UserInvitationsResponse.ts';
import { UserResponse } from '../models/UserResponse.ts';
import { UserRole } from '../models/UserRole.ts';
import { UserUpdateRequest } from '../models/UserUpdateRequest.ts';
import { UserUpdateRequestData } from '../models/UserUpdateRequestData.ts';
import { UserUpdateRequestDataAttributes } from '../models/UserUpdateRequestDataAttributes.ts';
import { UserVisibleAppsLinkagesRequest } from '../models/UserVisibleAppsLinkagesRequest.ts';
import { UserVisibleAppsLinkagesResponse } from '../models/UserVisibleAppsLinkagesResponse.ts';
import { UsersResponse } from '../models/UsersResponse.ts';
import { XcodeMetrics } from '../models/XcodeMetrics.ts';
import { XcodeMetricsInsights } from '../models/XcodeMetricsInsights.ts';
import { XcodeMetricsProductDataInner } from '../models/XcodeMetricsProductDataInner.ts';
import { XcodeMetricsProductDataInnerMetricCategoriesInner } from '../models/XcodeMetricsProductDataInnerMetricCategoriesInner.ts';
import { XcodeMetricsProductDataInnerMetricCategoriesInnerMetricsInner } from '../models/XcodeMetricsProductDataInnerMetricCategoriesInnerMetricsInner.ts';
import { XcodeMetricsProductDataInnerMetricCategoriesInnerMetricsInnerDatasetsInner } from '../models/XcodeMetricsProductDataInnerMetricCategoriesInnerMetricsInnerDatasetsInner.ts';
import { XcodeMetricsProductDataInnerMetricCategoriesInnerMetricsInnerDatasetsInnerFilterCriteria } from '../models/XcodeMetricsProductDataInnerMetricCategoriesInnerMetricsInnerDatasetsInnerFilterCriteria.ts';
import { XcodeMetricsProductDataInnerMetricCategoriesInnerMetricsInnerDatasetsInnerPointsInner } from '../models/XcodeMetricsProductDataInnerMetricCategoriesInnerMetricsInnerDatasetsInnerPointsInner.ts';
import { XcodeMetricsProductDataInnerMetricCategoriesInnerMetricsInnerDatasetsInnerPointsInnerPercentageBreakdown } from '../models/XcodeMetricsProductDataInnerMetricCategoriesInnerMetricsInnerDatasetsInnerPointsInnerPercentageBreakdown.ts';
import { XcodeMetricsProductDataInnerMetricCategoriesInnerMetricsInnerGoalKeysInner } from '../models/XcodeMetricsProductDataInnerMetricCategoriesInnerMetricsInnerGoalKeysInner.ts';
import { XcodeMetricsProductDataInnerMetricCategoriesInnerMetricsInnerUnit } from '../models/XcodeMetricsProductDataInnerMetricCategoriesInnerMetricsInnerUnit.ts';
import { ObservableActorsApi } from './ObservableAPI.ts';

import { ActorsApiRequestFactory, ActorsApiResponseProcessor} from "../apis/ActorsApi.ts";
export class PromiseActorsApi {
    private api: ObservableActorsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: ActorsApiRequestFactory,
        responseProcessor?: ActorsApiResponseProcessor
    ) {
        this.api = new ObservableActorsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param filterId filter by id(s)
     * @param fieldsActors the fields to include for returned resources of type actors
     * @param limit maximum resources per page
     */
    public actorsGetCollectionWithHttpInfo(filterId: Array<string>, fieldsActors?: Array<'actorType' | 'apiKeyId' | 'userEmail' | 'userFirstName' | 'userLastName'>, limit?: number, _options?: Configuration): Promise<HttpInfo<ActorsResponse>> {
        const result = this.api.actorsGetCollectionWithHttpInfo(filterId, fieldsActors, limit, _options);
        return result.toPromise();
    }

    /**
     * @param filterId filter by id(s)
     * @param fieldsActors the fields to include for returned resources of type actors
     * @param limit maximum resources per page
     */
    public actorsGetCollection(filterId: Array<string>, fieldsActors?: Array<'actorType' | 'apiKeyId' | 'userEmail' | 'userFirstName' | 'userLastName'>, limit?: number, _options?: Configuration): Promise<ActorsResponse> {
        const result = this.api.actorsGetCollection(filterId, fieldsActors, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsActors the fields to include for returned resources of type actors
     */
    public actorsGetInstanceWithHttpInfo(id: string, fieldsActors?: Array<'actorType' | 'apiKeyId' | 'userEmail' | 'userFirstName' | 'userLastName'>, _options?: Configuration): Promise<HttpInfo<ActorResponse>> {
        const result = this.api.actorsGetInstanceWithHttpInfo(id, fieldsActors, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsActors the fields to include for returned resources of type actors
     */
    public actorsGetInstance(id: string, fieldsActors?: Array<'actorType' | 'apiKeyId' | 'userEmail' | 'userFirstName' | 'userLastName'>, _options?: Configuration): Promise<ActorResponse> {
        const result = this.api.actorsGetInstance(id, fieldsActors, _options);
        return result.toPromise();
    }


}



import { ObservableAgeRatingDeclarationsApi } from './ObservableAPI.ts';

import { AgeRatingDeclarationsApiRequestFactory, AgeRatingDeclarationsApiResponseProcessor} from "../apis/AgeRatingDeclarationsApi.ts";
export class PromiseAgeRatingDeclarationsApi {
    private api: ObservableAgeRatingDeclarationsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: AgeRatingDeclarationsApiRequestFactory,
        responseProcessor?: AgeRatingDeclarationsApiResponseProcessor
    ) {
        this.api = new ObservableAgeRatingDeclarationsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param id the id of the requested resource
     * @param ageRatingDeclarationUpdateRequest AgeRatingDeclaration representation
     */
    public ageRatingDeclarationsUpdateInstanceWithHttpInfo(id: string, ageRatingDeclarationUpdateRequest: AgeRatingDeclarationUpdateRequest, _options?: Configuration): Promise<HttpInfo<AgeRatingDeclarationResponse>> {
        const result = this.api.ageRatingDeclarationsUpdateInstanceWithHttpInfo(id, ageRatingDeclarationUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param ageRatingDeclarationUpdateRequest AgeRatingDeclaration representation
     */
    public ageRatingDeclarationsUpdateInstance(id: string, ageRatingDeclarationUpdateRequest: AgeRatingDeclarationUpdateRequest, _options?: Configuration): Promise<AgeRatingDeclarationResponse> {
        const result = this.api.ageRatingDeclarationsUpdateInstance(id, ageRatingDeclarationUpdateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableAlternativeDistributionDomainsApi } from './ObservableAPI.ts';

import { AlternativeDistributionDomainsApiRequestFactory, AlternativeDistributionDomainsApiResponseProcessor} from "../apis/AlternativeDistributionDomainsApi.ts";
export class PromiseAlternativeDistributionDomainsApi {
    private api: ObservableAlternativeDistributionDomainsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: AlternativeDistributionDomainsApiRequestFactory,
        responseProcessor?: AlternativeDistributionDomainsApiResponseProcessor
    ) {
        this.api = new ObservableAlternativeDistributionDomainsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param alternativeDistributionDomainCreateRequest AlternativeDistributionDomain representation
     */
    public alternativeDistributionDomainsCreateInstanceWithHttpInfo(alternativeDistributionDomainCreateRequest: AlternativeDistributionDomainCreateRequest, _options?: Configuration): Promise<HttpInfo<AlternativeDistributionDomainResponse>> {
        const result = this.api.alternativeDistributionDomainsCreateInstanceWithHttpInfo(alternativeDistributionDomainCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param alternativeDistributionDomainCreateRequest AlternativeDistributionDomain representation
     */
    public alternativeDistributionDomainsCreateInstance(alternativeDistributionDomainCreateRequest: AlternativeDistributionDomainCreateRequest, _options?: Configuration): Promise<AlternativeDistributionDomainResponse> {
        const result = this.api.alternativeDistributionDomainsCreateInstance(alternativeDistributionDomainCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public alternativeDistributionDomainsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.alternativeDistributionDomainsDeleteInstanceWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public alternativeDistributionDomainsDeleteInstance(id: string, _options?: Configuration): Promise<void> {
        const result = this.api.alternativeDistributionDomainsDeleteInstance(id, _options);
        return result.toPromise();
    }

    /**
     * @param fieldsAlternativeDistributionDomains the fields to include for returned resources of type alternativeDistributionDomains
     * @param limit maximum resources per page
     */
    public alternativeDistributionDomainsGetCollectionWithHttpInfo(fieldsAlternativeDistributionDomains?: Array<'createdDate' | 'domain' | 'referenceName'>, limit?: number, _options?: Configuration): Promise<HttpInfo<AlternativeDistributionDomainsResponse>> {
        const result = this.api.alternativeDistributionDomainsGetCollectionWithHttpInfo(fieldsAlternativeDistributionDomains, limit, _options);
        return result.toPromise();
    }

    /**
     * @param fieldsAlternativeDistributionDomains the fields to include for returned resources of type alternativeDistributionDomains
     * @param limit maximum resources per page
     */
    public alternativeDistributionDomainsGetCollection(fieldsAlternativeDistributionDomains?: Array<'createdDate' | 'domain' | 'referenceName'>, limit?: number, _options?: Configuration): Promise<AlternativeDistributionDomainsResponse> {
        const result = this.api.alternativeDistributionDomainsGetCollection(fieldsAlternativeDistributionDomains, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAlternativeDistributionDomains the fields to include for returned resources of type alternativeDistributionDomains
     */
    public alternativeDistributionDomainsGetInstanceWithHttpInfo(id: string, fieldsAlternativeDistributionDomains?: Array<'createdDate' | 'domain' | 'referenceName'>, _options?: Configuration): Promise<HttpInfo<AlternativeDistributionDomainResponse>> {
        const result = this.api.alternativeDistributionDomainsGetInstanceWithHttpInfo(id, fieldsAlternativeDistributionDomains, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAlternativeDistributionDomains the fields to include for returned resources of type alternativeDistributionDomains
     */
    public alternativeDistributionDomainsGetInstance(id: string, fieldsAlternativeDistributionDomains?: Array<'createdDate' | 'domain' | 'referenceName'>, _options?: Configuration): Promise<AlternativeDistributionDomainResponse> {
        const result = this.api.alternativeDistributionDomainsGetInstance(id, fieldsAlternativeDistributionDomains, _options);
        return result.toPromise();
    }


}



import { ObservableAlternativeDistributionKeysApi } from './ObservableAPI.ts';

import { AlternativeDistributionKeysApiRequestFactory, AlternativeDistributionKeysApiResponseProcessor} from "../apis/AlternativeDistributionKeysApi.ts";
export class PromiseAlternativeDistributionKeysApi {
    private api: ObservableAlternativeDistributionKeysApi

    public constructor(
        configuration: Configuration,
        requestFactory?: AlternativeDistributionKeysApiRequestFactory,
        responseProcessor?: AlternativeDistributionKeysApiResponseProcessor
    ) {
        this.api = new ObservableAlternativeDistributionKeysApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param alternativeDistributionKeyCreateRequest AlternativeDistributionKey representation
     */
    public alternativeDistributionKeysCreateInstanceWithHttpInfo(alternativeDistributionKeyCreateRequest: AlternativeDistributionKeyCreateRequest, _options?: Configuration): Promise<HttpInfo<AlternativeDistributionKeyResponse>> {
        const result = this.api.alternativeDistributionKeysCreateInstanceWithHttpInfo(alternativeDistributionKeyCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param alternativeDistributionKeyCreateRequest AlternativeDistributionKey representation
     */
    public alternativeDistributionKeysCreateInstance(alternativeDistributionKeyCreateRequest: AlternativeDistributionKeyCreateRequest, _options?: Configuration): Promise<AlternativeDistributionKeyResponse> {
        const result = this.api.alternativeDistributionKeysCreateInstance(alternativeDistributionKeyCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public alternativeDistributionKeysDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.alternativeDistributionKeysDeleteInstanceWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public alternativeDistributionKeysDeleteInstance(id: string, _options?: Configuration): Promise<void> {
        const result = this.api.alternativeDistributionKeysDeleteInstance(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAlternativeDistributionKeys the fields to include for returned resources of type alternativeDistributionKeys
     */
    public alternativeDistributionKeysGetInstanceWithHttpInfo(id: string, fieldsAlternativeDistributionKeys?: Array<'app' | 'publicKey'>, _options?: Configuration): Promise<HttpInfo<AlternativeDistributionKeyResponse>> {
        const result = this.api.alternativeDistributionKeysGetInstanceWithHttpInfo(id, fieldsAlternativeDistributionKeys, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAlternativeDistributionKeys the fields to include for returned resources of type alternativeDistributionKeys
     */
    public alternativeDistributionKeysGetInstance(id: string, fieldsAlternativeDistributionKeys?: Array<'app' | 'publicKey'>, _options?: Configuration): Promise<AlternativeDistributionKeyResponse> {
        const result = this.api.alternativeDistributionKeysGetInstance(id, fieldsAlternativeDistributionKeys, _options);
        return result.toPromise();
    }


}



import { ObservableAlternativeDistributionPackageDeltasApi } from './ObservableAPI.ts';

import { AlternativeDistributionPackageDeltasApiRequestFactory, AlternativeDistributionPackageDeltasApiResponseProcessor} from "../apis/AlternativeDistributionPackageDeltasApi.ts";
export class PromiseAlternativeDistributionPackageDeltasApi {
    private api: ObservableAlternativeDistributionPackageDeltasApi

    public constructor(
        configuration: Configuration,
        requestFactory?: AlternativeDistributionPackageDeltasApiRequestFactory,
        responseProcessor?: AlternativeDistributionPackageDeltasApiResponseProcessor
    ) {
        this.api = new ObservableAlternativeDistributionPackageDeltasApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAlternativeDistributionPackageDeltas the fields to include for returned resources of type alternativeDistributionPackageDeltas
     */
    public alternativeDistributionPackageDeltasGetInstanceWithHttpInfo(id: string, fieldsAlternativeDistributionPackageDeltas?: Array<'alternativeDistributionKeyBlob' | 'fileChecksum' | 'url' | 'urlExpirationDate'>, _options?: Configuration): Promise<HttpInfo<AlternativeDistributionPackageDeltaResponse>> {
        const result = this.api.alternativeDistributionPackageDeltasGetInstanceWithHttpInfo(id, fieldsAlternativeDistributionPackageDeltas, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAlternativeDistributionPackageDeltas the fields to include for returned resources of type alternativeDistributionPackageDeltas
     */
    public alternativeDistributionPackageDeltasGetInstance(id: string, fieldsAlternativeDistributionPackageDeltas?: Array<'alternativeDistributionKeyBlob' | 'fileChecksum' | 'url' | 'urlExpirationDate'>, _options?: Configuration): Promise<AlternativeDistributionPackageDeltaResponse> {
        const result = this.api.alternativeDistributionPackageDeltasGetInstance(id, fieldsAlternativeDistributionPackageDeltas, _options);
        return result.toPromise();
    }


}



import { ObservableAlternativeDistributionPackageVariantsApi } from './ObservableAPI.ts';

import { AlternativeDistributionPackageVariantsApiRequestFactory, AlternativeDistributionPackageVariantsApiResponseProcessor} from "../apis/AlternativeDistributionPackageVariantsApi.ts";
export class PromiseAlternativeDistributionPackageVariantsApi {
    private api: ObservableAlternativeDistributionPackageVariantsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: AlternativeDistributionPackageVariantsApiRequestFactory,
        responseProcessor?: AlternativeDistributionPackageVariantsApiResponseProcessor
    ) {
        this.api = new ObservableAlternativeDistributionPackageVariantsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAlternativeDistributionPackageVariants the fields to include for returned resources of type alternativeDistributionPackageVariants
     */
    public alternativeDistributionPackageVariantsGetInstanceWithHttpInfo(id: string, fieldsAlternativeDistributionPackageVariants?: Array<'alternativeDistributionKeyBlob' | 'fileChecksum' | 'url' | 'urlExpirationDate'>, _options?: Configuration): Promise<HttpInfo<AlternativeDistributionPackageVariantResponse>> {
        const result = this.api.alternativeDistributionPackageVariantsGetInstanceWithHttpInfo(id, fieldsAlternativeDistributionPackageVariants, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAlternativeDistributionPackageVariants the fields to include for returned resources of type alternativeDistributionPackageVariants
     */
    public alternativeDistributionPackageVariantsGetInstance(id: string, fieldsAlternativeDistributionPackageVariants?: Array<'alternativeDistributionKeyBlob' | 'fileChecksum' | 'url' | 'urlExpirationDate'>, _options?: Configuration): Promise<AlternativeDistributionPackageVariantResponse> {
        const result = this.api.alternativeDistributionPackageVariantsGetInstance(id, fieldsAlternativeDistributionPackageVariants, _options);
        return result.toPromise();
    }


}



import { ObservableAlternativeDistributionPackageVersionsApi } from './ObservableAPI.ts';

import { AlternativeDistributionPackageVersionsApiRequestFactory, AlternativeDistributionPackageVersionsApiResponseProcessor} from "../apis/AlternativeDistributionPackageVersionsApi.ts";
export class PromiseAlternativeDistributionPackageVersionsApi {
    private api: ObservableAlternativeDistributionPackageVersionsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: AlternativeDistributionPackageVersionsApiRequestFactory,
        responseProcessor?: AlternativeDistributionPackageVersionsApiResponseProcessor
    ) {
        this.api = new ObservableAlternativeDistributionPackageVersionsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAlternativeDistributionPackageDeltas the fields to include for returned resources of type alternativeDistributionPackageDeltas
     * @param limit maximum resources per page
     */
    public alternativeDistributionPackageVersionsDeltasGetToManyRelatedWithHttpInfo(id: string, fieldsAlternativeDistributionPackageDeltas?: Array<'alternativeDistributionKeyBlob' | 'fileChecksum' | 'url' | 'urlExpirationDate'>, limit?: number, _options?: Configuration): Promise<HttpInfo<AlternativeDistributionPackageDeltasResponse>> {
        const result = this.api.alternativeDistributionPackageVersionsDeltasGetToManyRelatedWithHttpInfo(id, fieldsAlternativeDistributionPackageDeltas, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAlternativeDistributionPackageDeltas the fields to include for returned resources of type alternativeDistributionPackageDeltas
     * @param limit maximum resources per page
     */
    public alternativeDistributionPackageVersionsDeltasGetToManyRelated(id: string, fieldsAlternativeDistributionPackageDeltas?: Array<'alternativeDistributionKeyBlob' | 'fileChecksum' | 'url' | 'urlExpirationDate'>, limit?: number, _options?: Configuration): Promise<AlternativeDistributionPackageDeltasResponse> {
        const result = this.api.alternativeDistributionPackageVersionsDeltasGetToManyRelated(id, fieldsAlternativeDistributionPackageDeltas, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAlternativeDistributionPackageVersions the fields to include for returned resources of type alternativeDistributionPackageVersions
     * @param include comma-separated list of relationships to include
     * @param fieldsAlternativeDistributionPackageVariants the fields to include for returned resources of type alternativeDistributionPackageVariants
     * @param fieldsAlternativeDistributionPackageDeltas the fields to include for returned resources of type alternativeDistributionPackageDeltas
     * @param limitDeltas maximum number of related deltas returned (when they are included)
     * @param limitVariants maximum number of related variants returned (when they are included)
     */
    public alternativeDistributionPackageVersionsGetInstanceWithHttpInfo(id: string, fieldsAlternativeDistributionPackageVersions?: Array<'alternativeDistributionPackage' | 'deltas' | 'fileChecksum' | 'state' | 'url' | 'urlExpirationDate' | 'variants' | 'version'>, include?: Array<'alternativeDistributionPackage' | 'deltas' | 'variants'>, fieldsAlternativeDistributionPackageVariants?: Array<'alternativeDistributionKeyBlob' | 'fileChecksum' | 'url' | 'urlExpirationDate'>, fieldsAlternativeDistributionPackageDeltas?: Array<'alternativeDistributionKeyBlob' | 'fileChecksum' | 'url' | 'urlExpirationDate'>, limitDeltas?: number, limitVariants?: number, _options?: Configuration): Promise<HttpInfo<AlternativeDistributionPackageVersionResponse>> {
        const result = this.api.alternativeDistributionPackageVersionsGetInstanceWithHttpInfo(id, fieldsAlternativeDistributionPackageVersions, include, fieldsAlternativeDistributionPackageVariants, fieldsAlternativeDistributionPackageDeltas, limitDeltas, limitVariants, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAlternativeDistributionPackageVersions the fields to include for returned resources of type alternativeDistributionPackageVersions
     * @param include comma-separated list of relationships to include
     * @param fieldsAlternativeDistributionPackageVariants the fields to include for returned resources of type alternativeDistributionPackageVariants
     * @param fieldsAlternativeDistributionPackageDeltas the fields to include for returned resources of type alternativeDistributionPackageDeltas
     * @param limitDeltas maximum number of related deltas returned (when they are included)
     * @param limitVariants maximum number of related variants returned (when they are included)
     */
    public alternativeDistributionPackageVersionsGetInstance(id: string, fieldsAlternativeDistributionPackageVersions?: Array<'alternativeDistributionPackage' | 'deltas' | 'fileChecksum' | 'state' | 'url' | 'urlExpirationDate' | 'variants' | 'version'>, include?: Array<'alternativeDistributionPackage' | 'deltas' | 'variants'>, fieldsAlternativeDistributionPackageVariants?: Array<'alternativeDistributionKeyBlob' | 'fileChecksum' | 'url' | 'urlExpirationDate'>, fieldsAlternativeDistributionPackageDeltas?: Array<'alternativeDistributionKeyBlob' | 'fileChecksum' | 'url' | 'urlExpirationDate'>, limitDeltas?: number, limitVariants?: number, _options?: Configuration): Promise<AlternativeDistributionPackageVersionResponse> {
        const result = this.api.alternativeDistributionPackageVersionsGetInstance(id, fieldsAlternativeDistributionPackageVersions, include, fieldsAlternativeDistributionPackageVariants, fieldsAlternativeDistributionPackageDeltas, limitDeltas, limitVariants, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAlternativeDistributionPackageVariants the fields to include for returned resources of type alternativeDistributionPackageVariants
     * @param limit maximum resources per page
     */
    public alternativeDistributionPackageVersionsVariantsGetToManyRelatedWithHttpInfo(id: string, fieldsAlternativeDistributionPackageVariants?: Array<'alternativeDistributionKeyBlob' | 'fileChecksum' | 'url' | 'urlExpirationDate'>, limit?: number, _options?: Configuration): Promise<HttpInfo<AlternativeDistributionPackageVariantsResponse>> {
        const result = this.api.alternativeDistributionPackageVersionsVariantsGetToManyRelatedWithHttpInfo(id, fieldsAlternativeDistributionPackageVariants, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAlternativeDistributionPackageVariants the fields to include for returned resources of type alternativeDistributionPackageVariants
     * @param limit maximum resources per page
     */
    public alternativeDistributionPackageVersionsVariantsGetToManyRelated(id: string, fieldsAlternativeDistributionPackageVariants?: Array<'alternativeDistributionKeyBlob' | 'fileChecksum' | 'url' | 'urlExpirationDate'>, limit?: number, _options?: Configuration): Promise<AlternativeDistributionPackageVariantsResponse> {
        const result = this.api.alternativeDistributionPackageVersionsVariantsGetToManyRelated(id, fieldsAlternativeDistributionPackageVariants, limit, _options);
        return result.toPromise();
    }


}



import { ObservableAlternativeDistributionPackagesApi } from './ObservableAPI.ts';

import { AlternativeDistributionPackagesApiRequestFactory, AlternativeDistributionPackagesApiResponseProcessor} from "../apis/AlternativeDistributionPackagesApi.ts";
export class PromiseAlternativeDistributionPackagesApi {
    private api: ObservableAlternativeDistributionPackagesApi

    public constructor(
        configuration: Configuration,
        requestFactory?: AlternativeDistributionPackagesApiRequestFactory,
        responseProcessor?: AlternativeDistributionPackagesApiResponseProcessor
    ) {
        this.api = new ObservableAlternativeDistributionPackagesApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param alternativeDistributionPackageCreateRequest AlternativeDistributionPackage representation
     */
    public alternativeDistributionPackagesCreateInstanceWithHttpInfo(alternativeDistributionPackageCreateRequest: AlternativeDistributionPackageCreateRequest, _options?: Configuration): Promise<HttpInfo<AlternativeDistributionPackageResponse>> {
        const result = this.api.alternativeDistributionPackagesCreateInstanceWithHttpInfo(alternativeDistributionPackageCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param alternativeDistributionPackageCreateRequest AlternativeDistributionPackage representation
     */
    public alternativeDistributionPackagesCreateInstance(alternativeDistributionPackageCreateRequest: AlternativeDistributionPackageCreateRequest, _options?: Configuration): Promise<AlternativeDistributionPackageResponse> {
        const result = this.api.alternativeDistributionPackagesCreateInstance(alternativeDistributionPackageCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAlternativeDistributionPackages the fields to include for returned resources of type alternativeDistributionPackages
     * @param include comma-separated list of relationships to include
     * @param fieldsAlternativeDistributionPackageVersions the fields to include for returned resources of type alternativeDistributionPackageVersions
     * @param limitVersions maximum number of related versions returned (when they are included)
     */
    public alternativeDistributionPackagesGetInstanceWithHttpInfo(id: string, fieldsAlternativeDistributionPackages?: Array<'appStoreVersion' | 'versions'>, include?: Array<'versions'>, fieldsAlternativeDistributionPackageVersions?: Array<'alternativeDistributionPackage' | 'deltas' | 'fileChecksum' | 'state' | 'url' | 'urlExpirationDate' | 'variants' | 'version'>, limitVersions?: number, _options?: Configuration): Promise<HttpInfo<AlternativeDistributionPackageResponse>> {
        const result = this.api.alternativeDistributionPackagesGetInstanceWithHttpInfo(id, fieldsAlternativeDistributionPackages, include, fieldsAlternativeDistributionPackageVersions, limitVersions, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAlternativeDistributionPackages the fields to include for returned resources of type alternativeDistributionPackages
     * @param include comma-separated list of relationships to include
     * @param fieldsAlternativeDistributionPackageVersions the fields to include for returned resources of type alternativeDistributionPackageVersions
     * @param limitVersions maximum number of related versions returned (when they are included)
     */
    public alternativeDistributionPackagesGetInstance(id: string, fieldsAlternativeDistributionPackages?: Array<'appStoreVersion' | 'versions'>, include?: Array<'versions'>, fieldsAlternativeDistributionPackageVersions?: Array<'alternativeDistributionPackage' | 'deltas' | 'fileChecksum' | 'state' | 'url' | 'urlExpirationDate' | 'variants' | 'version'>, limitVersions?: number, _options?: Configuration): Promise<AlternativeDistributionPackageResponse> {
        const result = this.api.alternativeDistributionPackagesGetInstance(id, fieldsAlternativeDistributionPackages, include, fieldsAlternativeDistributionPackageVersions, limitVersions, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterState filter by attribute \&#39;state\&#39;
     * @param fieldsAlternativeDistributionPackageVariants the fields to include for returned resources of type alternativeDistributionPackageVariants
     * @param fieldsAlternativeDistributionPackages the fields to include for returned resources of type alternativeDistributionPackages
     * @param fieldsAlternativeDistributionPackageVersions the fields to include for returned resources of type alternativeDistributionPackageVersions
     * @param fieldsAlternativeDistributionPackageDeltas the fields to include for returned resources of type alternativeDistributionPackageDeltas
     * @param limit maximum resources per page
     * @param limitVariants maximum number of related variants returned (when they are included)
     * @param limitDeltas maximum number of related deltas returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public alternativeDistributionPackagesVersionsGetToManyRelatedWithHttpInfo(id: string, filterState?: Array<'COMPLETED' | 'REPLACED'>, fieldsAlternativeDistributionPackageVariants?: Array<'alternativeDistributionKeyBlob' | 'fileChecksum' | 'url' | 'urlExpirationDate'>, fieldsAlternativeDistributionPackages?: Array<'appStoreVersion' | 'versions'>, fieldsAlternativeDistributionPackageVersions?: Array<'alternativeDistributionPackage' | 'deltas' | 'fileChecksum' | 'state' | 'url' | 'urlExpirationDate' | 'variants' | 'version'>, fieldsAlternativeDistributionPackageDeltas?: Array<'alternativeDistributionKeyBlob' | 'fileChecksum' | 'url' | 'urlExpirationDate'>, limit?: number, limitVariants?: number, limitDeltas?: number, include?: Array<'alternativeDistributionPackage' | 'deltas' | 'variants'>, _options?: Configuration): Promise<HttpInfo<AlternativeDistributionPackageVersionsResponse>> {
        const result = this.api.alternativeDistributionPackagesVersionsGetToManyRelatedWithHttpInfo(id, filterState, fieldsAlternativeDistributionPackageVariants, fieldsAlternativeDistributionPackages, fieldsAlternativeDistributionPackageVersions, fieldsAlternativeDistributionPackageDeltas, limit, limitVariants, limitDeltas, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterState filter by attribute \&#39;state\&#39;
     * @param fieldsAlternativeDistributionPackageVariants the fields to include for returned resources of type alternativeDistributionPackageVariants
     * @param fieldsAlternativeDistributionPackages the fields to include for returned resources of type alternativeDistributionPackages
     * @param fieldsAlternativeDistributionPackageVersions the fields to include for returned resources of type alternativeDistributionPackageVersions
     * @param fieldsAlternativeDistributionPackageDeltas the fields to include for returned resources of type alternativeDistributionPackageDeltas
     * @param limit maximum resources per page
     * @param limitVariants maximum number of related variants returned (when they are included)
     * @param limitDeltas maximum number of related deltas returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public alternativeDistributionPackagesVersionsGetToManyRelated(id: string, filterState?: Array<'COMPLETED' | 'REPLACED'>, fieldsAlternativeDistributionPackageVariants?: Array<'alternativeDistributionKeyBlob' | 'fileChecksum' | 'url' | 'urlExpirationDate'>, fieldsAlternativeDistributionPackages?: Array<'appStoreVersion' | 'versions'>, fieldsAlternativeDistributionPackageVersions?: Array<'alternativeDistributionPackage' | 'deltas' | 'fileChecksum' | 'state' | 'url' | 'urlExpirationDate' | 'variants' | 'version'>, fieldsAlternativeDistributionPackageDeltas?: Array<'alternativeDistributionKeyBlob' | 'fileChecksum' | 'url' | 'urlExpirationDate'>, limit?: number, limitVariants?: number, limitDeltas?: number, include?: Array<'alternativeDistributionPackage' | 'deltas' | 'variants'>, _options?: Configuration): Promise<AlternativeDistributionPackageVersionsResponse> {
        const result = this.api.alternativeDistributionPackagesVersionsGetToManyRelated(id, filterState, fieldsAlternativeDistributionPackageVariants, fieldsAlternativeDistributionPackages, fieldsAlternativeDistributionPackageVersions, fieldsAlternativeDistributionPackageDeltas, limit, limitVariants, limitDeltas, include, _options);
        return result.toPromise();
    }


}



import { ObservableAnalyticsReportInstancesApi } from './ObservableAPI.ts';

import { AnalyticsReportInstancesApiRequestFactory, AnalyticsReportInstancesApiResponseProcessor} from "../apis/AnalyticsReportInstancesApi.ts";
export class PromiseAnalyticsReportInstancesApi {
    private api: ObservableAnalyticsReportInstancesApi

    public constructor(
        configuration: Configuration,
        requestFactory?: AnalyticsReportInstancesApiRequestFactory,
        responseProcessor?: AnalyticsReportInstancesApiResponseProcessor
    ) {
        this.api = new ObservableAnalyticsReportInstancesApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAnalyticsReportInstances the fields to include for returned resources of type analyticsReportInstances
     * @param fieldsAnalyticsReportSegments the fields to include for returned resources of type analyticsReportSegments
     */
    public analyticsReportInstancesGetInstanceWithHttpInfo(id: string, fieldsAnalyticsReportInstances?: Array<'granularity' | 'processingDate' | 'segments'>, fieldsAnalyticsReportSegments?: Array<'checksum' | 'sizeInBytes' | 'url'>, _options?: Configuration): Promise<HttpInfo<AnalyticsReportInstanceResponse>> {
        const result = this.api.analyticsReportInstancesGetInstanceWithHttpInfo(id, fieldsAnalyticsReportInstances, fieldsAnalyticsReportSegments, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAnalyticsReportInstances the fields to include for returned resources of type analyticsReportInstances
     * @param fieldsAnalyticsReportSegments the fields to include for returned resources of type analyticsReportSegments
     */
    public analyticsReportInstancesGetInstance(id: string, fieldsAnalyticsReportInstances?: Array<'granularity' | 'processingDate' | 'segments'>, fieldsAnalyticsReportSegments?: Array<'checksum' | 'sizeInBytes' | 'url'>, _options?: Configuration): Promise<AnalyticsReportInstanceResponse> {
        const result = this.api.analyticsReportInstancesGetInstance(id, fieldsAnalyticsReportInstances, fieldsAnalyticsReportSegments, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAnalyticsReportSegments the fields to include for returned resources of type analyticsReportSegments
     * @param limit maximum resources per page
     */
    public analyticsReportInstancesSegmentsGetToManyRelatedWithHttpInfo(id: string, fieldsAnalyticsReportSegments?: Array<'checksum' | 'sizeInBytes' | 'url'>, limit?: number, _options?: Configuration): Promise<HttpInfo<AnalyticsReportSegmentsResponse>> {
        const result = this.api.analyticsReportInstancesSegmentsGetToManyRelatedWithHttpInfo(id, fieldsAnalyticsReportSegments, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAnalyticsReportSegments the fields to include for returned resources of type analyticsReportSegments
     * @param limit maximum resources per page
     */
    public analyticsReportInstancesSegmentsGetToManyRelated(id: string, fieldsAnalyticsReportSegments?: Array<'checksum' | 'sizeInBytes' | 'url'>, limit?: number, _options?: Configuration): Promise<AnalyticsReportSegmentsResponse> {
        const result = this.api.analyticsReportInstancesSegmentsGetToManyRelated(id, fieldsAnalyticsReportSegments, limit, _options);
        return result.toPromise();
    }


}



import { ObservableAnalyticsReportRequestsApi } from './ObservableAPI.ts';

import { AnalyticsReportRequestsApiRequestFactory, AnalyticsReportRequestsApiResponseProcessor} from "../apis/AnalyticsReportRequestsApi.ts";
export class PromiseAnalyticsReportRequestsApi {
    private api: ObservableAnalyticsReportRequestsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: AnalyticsReportRequestsApiRequestFactory,
        responseProcessor?: AnalyticsReportRequestsApiResponseProcessor
    ) {
        this.api = new ObservableAnalyticsReportRequestsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param analyticsReportRequestCreateRequest AnalyticsReportRequest representation
     */
    public analyticsReportRequestsCreateInstanceWithHttpInfo(analyticsReportRequestCreateRequest: AnalyticsReportRequestCreateRequest, _options?: Configuration): Promise<HttpInfo<AnalyticsReportRequestResponse>> {
        const result = this.api.analyticsReportRequestsCreateInstanceWithHttpInfo(analyticsReportRequestCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param analyticsReportRequestCreateRequest AnalyticsReportRequest representation
     */
    public analyticsReportRequestsCreateInstance(analyticsReportRequestCreateRequest: AnalyticsReportRequestCreateRequest, _options?: Configuration): Promise<AnalyticsReportRequestResponse> {
        const result = this.api.analyticsReportRequestsCreateInstance(analyticsReportRequestCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public analyticsReportRequestsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.analyticsReportRequestsDeleteInstanceWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public analyticsReportRequestsDeleteInstance(id: string, _options?: Configuration): Promise<void> {
        const result = this.api.analyticsReportRequestsDeleteInstance(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAnalyticsReportRequests the fields to include for returned resources of type analyticsReportRequests
     * @param include comma-separated list of relationships to include
     * @param fieldsAnalyticsReports the fields to include for returned resources of type analyticsReports
     * @param limitReports maximum number of related reports returned (when they are included)
     */
    public analyticsReportRequestsGetInstanceWithHttpInfo(id: string, fieldsAnalyticsReportRequests?: Array<'accessType' | 'app' | 'reports' | 'stoppedDueToInactivity'>, include?: Array<'reports'>, fieldsAnalyticsReports?: Array<'category' | 'instances' | 'name'>, limitReports?: number, _options?: Configuration): Promise<HttpInfo<AnalyticsReportRequestResponse>> {
        const result = this.api.analyticsReportRequestsGetInstanceWithHttpInfo(id, fieldsAnalyticsReportRequests, include, fieldsAnalyticsReports, limitReports, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAnalyticsReportRequests the fields to include for returned resources of type analyticsReportRequests
     * @param include comma-separated list of relationships to include
     * @param fieldsAnalyticsReports the fields to include for returned resources of type analyticsReports
     * @param limitReports maximum number of related reports returned (when they are included)
     */
    public analyticsReportRequestsGetInstance(id: string, fieldsAnalyticsReportRequests?: Array<'accessType' | 'app' | 'reports' | 'stoppedDueToInactivity'>, include?: Array<'reports'>, fieldsAnalyticsReports?: Array<'category' | 'instances' | 'name'>, limitReports?: number, _options?: Configuration): Promise<AnalyticsReportRequestResponse> {
        const result = this.api.analyticsReportRequestsGetInstance(id, fieldsAnalyticsReportRequests, include, fieldsAnalyticsReports, limitReports, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterCategory filter by attribute \&#39;category\&#39;
     * @param filterName filter by attribute \&#39;name\&#39;
     * @param fieldsAnalyticsReports the fields to include for returned resources of type analyticsReports
     * @param limit maximum resources per page
     */
    public analyticsReportRequestsReportsGetToManyRelatedWithHttpInfo(id: string, filterCategory?: Array<'APP_USAGE' | 'APP_STORE_ENGAGEMENT' | 'COMMERCE' | 'FRAMEWORK_USAGE' | 'PERFORMANCE'>, filterName?: Array<string>, fieldsAnalyticsReports?: Array<'category' | 'instances' | 'name'>, limit?: number, _options?: Configuration): Promise<HttpInfo<AnalyticsReportsResponse>> {
        const result = this.api.analyticsReportRequestsReportsGetToManyRelatedWithHttpInfo(id, filterCategory, filterName, fieldsAnalyticsReports, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterCategory filter by attribute \&#39;category\&#39;
     * @param filterName filter by attribute \&#39;name\&#39;
     * @param fieldsAnalyticsReports the fields to include for returned resources of type analyticsReports
     * @param limit maximum resources per page
     */
    public analyticsReportRequestsReportsGetToManyRelated(id: string, filterCategory?: Array<'APP_USAGE' | 'APP_STORE_ENGAGEMENT' | 'COMMERCE' | 'FRAMEWORK_USAGE' | 'PERFORMANCE'>, filterName?: Array<string>, fieldsAnalyticsReports?: Array<'category' | 'instances' | 'name'>, limit?: number, _options?: Configuration): Promise<AnalyticsReportsResponse> {
        const result = this.api.analyticsReportRequestsReportsGetToManyRelated(id, filterCategory, filterName, fieldsAnalyticsReports, limit, _options);
        return result.toPromise();
    }


}



import { ObservableAnalyticsReportSegmentsApi } from './ObservableAPI.ts';

import { AnalyticsReportSegmentsApiRequestFactory, AnalyticsReportSegmentsApiResponseProcessor} from "../apis/AnalyticsReportSegmentsApi.ts";
export class PromiseAnalyticsReportSegmentsApi {
    private api: ObservableAnalyticsReportSegmentsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: AnalyticsReportSegmentsApiRequestFactory,
        responseProcessor?: AnalyticsReportSegmentsApiResponseProcessor
    ) {
        this.api = new ObservableAnalyticsReportSegmentsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAnalyticsReportSegments the fields to include for returned resources of type analyticsReportSegments
     */
    public analyticsReportSegmentsGetInstanceWithHttpInfo(id: string, fieldsAnalyticsReportSegments?: Array<'checksum' | 'sizeInBytes' | 'url'>, _options?: Configuration): Promise<HttpInfo<AnalyticsReportSegmentResponse>> {
        const result = this.api.analyticsReportSegmentsGetInstanceWithHttpInfo(id, fieldsAnalyticsReportSegments, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAnalyticsReportSegments the fields to include for returned resources of type analyticsReportSegments
     */
    public analyticsReportSegmentsGetInstance(id: string, fieldsAnalyticsReportSegments?: Array<'checksum' | 'sizeInBytes' | 'url'>, _options?: Configuration): Promise<AnalyticsReportSegmentResponse> {
        const result = this.api.analyticsReportSegmentsGetInstance(id, fieldsAnalyticsReportSegments, _options);
        return result.toPromise();
    }


}



import { ObservableAnalyticsReportsApi } from './ObservableAPI.ts';

import { AnalyticsReportsApiRequestFactory, AnalyticsReportsApiResponseProcessor} from "../apis/AnalyticsReportsApi.ts";
export class PromiseAnalyticsReportsApi {
    private api: ObservableAnalyticsReportsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: AnalyticsReportsApiRequestFactory,
        responseProcessor?: AnalyticsReportsApiResponseProcessor
    ) {
        this.api = new ObservableAnalyticsReportsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAnalyticsReports the fields to include for returned resources of type analyticsReports
     * @param fieldsAnalyticsReportInstances the fields to include for returned resources of type analyticsReportInstances
     */
    public analyticsReportsGetInstanceWithHttpInfo(id: string, fieldsAnalyticsReports?: Array<'category' | 'instances' | 'name'>, fieldsAnalyticsReportInstances?: Array<'granularity' | 'processingDate' | 'segments'>, _options?: Configuration): Promise<HttpInfo<AnalyticsReportResponse>> {
        const result = this.api.analyticsReportsGetInstanceWithHttpInfo(id, fieldsAnalyticsReports, fieldsAnalyticsReportInstances, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAnalyticsReports the fields to include for returned resources of type analyticsReports
     * @param fieldsAnalyticsReportInstances the fields to include for returned resources of type analyticsReportInstances
     */
    public analyticsReportsGetInstance(id: string, fieldsAnalyticsReports?: Array<'category' | 'instances' | 'name'>, fieldsAnalyticsReportInstances?: Array<'granularity' | 'processingDate' | 'segments'>, _options?: Configuration): Promise<AnalyticsReportResponse> {
        const result = this.api.analyticsReportsGetInstance(id, fieldsAnalyticsReports, fieldsAnalyticsReportInstances, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterGranularity filter by attribute \&#39;granularity\&#39;
     * @param filterProcessingDate filter by attribute \&#39;processingDate\&#39;
     * @param fieldsAnalyticsReportInstances the fields to include for returned resources of type analyticsReportInstances
     * @param limit maximum resources per page
     */
    public analyticsReportsInstancesGetToManyRelatedWithHttpInfo(id: string, filterGranularity?: Array<'DAILY' | 'WEEKLY' | 'MONTHLY'>, filterProcessingDate?: Array<string>, fieldsAnalyticsReportInstances?: Array<'granularity' | 'processingDate' | 'segments'>, limit?: number, _options?: Configuration): Promise<HttpInfo<AnalyticsReportInstancesResponse>> {
        const result = this.api.analyticsReportsInstancesGetToManyRelatedWithHttpInfo(id, filterGranularity, filterProcessingDate, fieldsAnalyticsReportInstances, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterGranularity filter by attribute \&#39;granularity\&#39;
     * @param filterProcessingDate filter by attribute \&#39;processingDate\&#39;
     * @param fieldsAnalyticsReportInstances the fields to include for returned resources of type analyticsReportInstances
     * @param limit maximum resources per page
     */
    public analyticsReportsInstancesGetToManyRelated(id: string, filterGranularity?: Array<'DAILY' | 'WEEKLY' | 'MONTHLY'>, filterProcessingDate?: Array<string>, fieldsAnalyticsReportInstances?: Array<'granularity' | 'processingDate' | 'segments'>, limit?: number, _options?: Configuration): Promise<AnalyticsReportInstancesResponse> {
        const result = this.api.analyticsReportsInstancesGetToManyRelated(id, filterGranularity, filterProcessingDate, fieldsAnalyticsReportInstances, limit, _options);
        return result.toPromise();
    }


}



import { ObservableAppAvailabilitiesApi } from './ObservableAPI.ts';

import { AppAvailabilitiesApiRequestFactory, AppAvailabilitiesApiResponseProcessor} from "../apis/AppAvailabilitiesApi.ts";
export class PromiseAppAvailabilitiesApi {
    private api: ObservableAppAvailabilitiesApi

    public constructor(
        configuration: Configuration,
        requestFactory?: AppAvailabilitiesApiRequestFactory,
        responseProcessor?: AppAvailabilitiesApiResponseProcessor
    ) {
        this.api = new ObservableAppAvailabilitiesApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limit maximum resources per page
     */
    public appAvailabilitiesAvailableTerritoriesGetToManyRelatedWithHttpInfo(id: string, fieldsTerritories?: Array<'currency'>, limit?: number, _options?: Configuration): Promise<HttpInfo<TerritoriesResponse>> {
        const result = this.api.appAvailabilitiesAvailableTerritoriesGetToManyRelatedWithHttpInfo(id, fieldsTerritories, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limit maximum resources per page
     */
    public appAvailabilitiesAvailableTerritoriesGetToManyRelated(id: string, fieldsTerritories?: Array<'currency'>, limit?: number, _options?: Configuration): Promise<TerritoriesResponse> {
        const result = this.api.appAvailabilitiesAvailableTerritoriesGetToManyRelated(id, fieldsTerritories, limit, _options);
        return result.toPromise();
    }

    /**
     * @param appAvailabilityCreateRequest AppAvailability representation
     */
    public appAvailabilitiesCreateInstanceWithHttpInfo(appAvailabilityCreateRequest: AppAvailabilityCreateRequest, _options?: Configuration): Promise<HttpInfo<AppAvailabilityResponse>> {
        const result = this.api.appAvailabilitiesCreateInstanceWithHttpInfo(appAvailabilityCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param appAvailabilityCreateRequest AppAvailability representation
     */
    public appAvailabilitiesCreateInstance(appAvailabilityCreateRequest: AppAvailabilityCreateRequest, _options?: Configuration): Promise<AppAvailabilityResponse> {
        const result = this.api.appAvailabilitiesCreateInstance(appAvailabilityCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppAvailabilities the fields to include for returned resources of type appAvailabilities
     * @param include comma-separated list of relationships to include
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limitAvailableTerritories maximum number of related availableTerritories returned (when they are included)
     */
    public appAvailabilitiesGetInstanceWithHttpInfo(id: string, fieldsAppAvailabilities?: Array<'app' | 'availableInNewTerritories' | 'availableTerritories'>, include?: Array<'app' | 'availableTerritories'>, fieldsTerritories?: Array<'currency'>, limitAvailableTerritories?: number, _options?: Configuration): Promise<HttpInfo<AppAvailabilityResponse>> {
        const result = this.api.appAvailabilitiesGetInstanceWithHttpInfo(id, fieldsAppAvailabilities, include, fieldsTerritories, limitAvailableTerritories, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppAvailabilities the fields to include for returned resources of type appAvailabilities
     * @param include comma-separated list of relationships to include
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limitAvailableTerritories maximum number of related availableTerritories returned (when they are included)
     */
    public appAvailabilitiesGetInstance(id: string, fieldsAppAvailabilities?: Array<'app' | 'availableInNewTerritories' | 'availableTerritories'>, include?: Array<'app' | 'availableTerritories'>, fieldsTerritories?: Array<'currency'>, limitAvailableTerritories?: number, _options?: Configuration): Promise<AppAvailabilityResponse> {
        const result = this.api.appAvailabilitiesGetInstance(id, fieldsAppAvailabilities, include, fieldsTerritories, limitAvailableTerritories, _options);
        return result.toPromise();
    }

    /**
     * @param appAvailabilityV2CreateRequest AppAvailability representation
     */
    public appAvailabilitiesV2CreateInstanceWithHttpInfo(appAvailabilityV2CreateRequest: AppAvailabilityV2CreateRequest, _options?: Configuration): Promise<HttpInfo<AppAvailabilityV2Response>> {
        const result = this.api.appAvailabilitiesV2CreateInstanceWithHttpInfo(appAvailabilityV2CreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param appAvailabilityV2CreateRequest AppAvailability representation
     */
    public appAvailabilitiesV2CreateInstance(appAvailabilityV2CreateRequest: AppAvailabilityV2CreateRequest, _options?: Configuration): Promise<AppAvailabilityV2Response> {
        const result = this.api.appAvailabilitiesV2CreateInstance(appAvailabilityV2CreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppAvailabilities the fields to include for returned resources of type appAvailabilities
     * @param include comma-separated list of relationships to include
     * @param fieldsTerritoryAvailabilities the fields to include for returned resources of type territoryAvailabilities
     * @param limitTerritoryAvailabilities maximum number of related territoryAvailabilities returned (when they are included)
     */
    public appAvailabilitiesV2GetInstanceWithHttpInfo(id: string, fieldsAppAvailabilities?: Array<'app' | 'availableInNewTerritories' | 'territoryAvailabilities'>, include?: Array<'territoryAvailabilities'>, fieldsTerritoryAvailabilities?: Array<'available' | 'contentStatuses' | 'preOrderEnabled' | 'preOrderPublishDate' | 'releaseDate' | 'territory'>, limitTerritoryAvailabilities?: number, _options?: Configuration): Promise<HttpInfo<AppAvailabilityV2Response>> {
        const result = this.api.appAvailabilitiesV2GetInstanceWithHttpInfo(id, fieldsAppAvailabilities, include, fieldsTerritoryAvailabilities, limitTerritoryAvailabilities, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppAvailabilities the fields to include for returned resources of type appAvailabilities
     * @param include comma-separated list of relationships to include
     * @param fieldsTerritoryAvailabilities the fields to include for returned resources of type territoryAvailabilities
     * @param limitTerritoryAvailabilities maximum number of related territoryAvailabilities returned (when they are included)
     */
    public appAvailabilitiesV2GetInstance(id: string, fieldsAppAvailabilities?: Array<'app' | 'availableInNewTerritories' | 'territoryAvailabilities'>, include?: Array<'territoryAvailabilities'>, fieldsTerritoryAvailabilities?: Array<'available' | 'contentStatuses' | 'preOrderEnabled' | 'preOrderPublishDate' | 'releaseDate' | 'territory'>, limitTerritoryAvailabilities?: number, _options?: Configuration): Promise<AppAvailabilityV2Response> {
        const result = this.api.appAvailabilitiesV2GetInstance(id, fieldsAppAvailabilities, include, fieldsTerritoryAvailabilities, limitTerritoryAvailabilities, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsTerritoryAvailabilities the fields to include for returned resources of type territoryAvailabilities
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public appAvailabilitiesV2TerritoryAvailabilitiesGetToManyRelatedWithHttpInfo(id: string, fieldsTerritoryAvailabilities?: Array<'available' | 'contentStatuses' | 'preOrderEnabled' | 'preOrderPublishDate' | 'releaseDate' | 'territory'>, fieldsTerritories?: Array<'currency'>, limit?: number, include?: Array<'territory'>, _options?: Configuration): Promise<HttpInfo<TerritoryAvailabilitiesResponse>> {
        const result = this.api.appAvailabilitiesV2TerritoryAvailabilitiesGetToManyRelatedWithHttpInfo(id, fieldsTerritoryAvailabilities, fieldsTerritories, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsTerritoryAvailabilities the fields to include for returned resources of type territoryAvailabilities
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public appAvailabilitiesV2TerritoryAvailabilitiesGetToManyRelated(id: string, fieldsTerritoryAvailabilities?: Array<'available' | 'contentStatuses' | 'preOrderEnabled' | 'preOrderPublishDate' | 'releaseDate' | 'territory'>, fieldsTerritories?: Array<'currency'>, limit?: number, include?: Array<'territory'>, _options?: Configuration): Promise<TerritoryAvailabilitiesResponse> {
        const result = this.api.appAvailabilitiesV2TerritoryAvailabilitiesGetToManyRelated(id, fieldsTerritoryAvailabilities, fieldsTerritories, limit, include, _options);
        return result.toPromise();
    }


}



import { ObservableAppCategoriesApi } from './ObservableAPI.ts';

import { AppCategoriesApiRequestFactory, AppCategoriesApiResponseProcessor} from "../apis/AppCategoriesApi.ts";
export class PromiseAppCategoriesApi {
    private api: ObservableAppCategoriesApi

    public constructor(
        configuration: Configuration,
        requestFactory?: AppCategoriesApiRequestFactory,
        responseProcessor?: AppCategoriesApiResponseProcessor
    ) {
        this.api = new ObservableAppCategoriesApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param filterPlatforms filter by attribute \&#39;platforms\&#39;
     * @param existsParent filter by existence or non-existence of related \&#39;parent\&#39;
     * @param fieldsAppCategories the fields to include for returned resources of type appCategories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param limitSubcategories maximum number of related subcategories returned (when they are included)
     */
    public appCategoriesGetCollectionWithHttpInfo(filterPlatforms?: Array<'IOS' | 'MAC_OS' | 'TV_OS' | 'VISION_OS'>, existsParent?: boolean, fieldsAppCategories?: Array<'parent' | 'platforms' | 'subcategories'>, limit?: number, include?: Array<'parent' | 'subcategories'>, limitSubcategories?: number, _options?: Configuration): Promise<HttpInfo<AppCategoriesResponse>> {
        const result = this.api.appCategoriesGetCollectionWithHttpInfo(filterPlatforms, existsParent, fieldsAppCategories, limit, include, limitSubcategories, _options);
        return result.toPromise();
    }

    /**
     * @param filterPlatforms filter by attribute \&#39;platforms\&#39;
     * @param existsParent filter by existence or non-existence of related \&#39;parent\&#39;
     * @param fieldsAppCategories the fields to include for returned resources of type appCategories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param limitSubcategories maximum number of related subcategories returned (when they are included)
     */
    public appCategoriesGetCollection(filterPlatforms?: Array<'IOS' | 'MAC_OS' | 'TV_OS' | 'VISION_OS'>, existsParent?: boolean, fieldsAppCategories?: Array<'parent' | 'platforms' | 'subcategories'>, limit?: number, include?: Array<'parent' | 'subcategories'>, limitSubcategories?: number, _options?: Configuration): Promise<AppCategoriesResponse> {
        const result = this.api.appCategoriesGetCollection(filterPlatforms, existsParent, fieldsAppCategories, limit, include, limitSubcategories, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppCategories the fields to include for returned resources of type appCategories
     * @param include comma-separated list of relationships to include
     * @param limitSubcategories maximum number of related subcategories returned (when they are included)
     */
    public appCategoriesGetInstanceWithHttpInfo(id: string, fieldsAppCategories?: Array<'parent' | 'platforms' | 'subcategories'>, include?: Array<'parent' | 'subcategories'>, limitSubcategories?: number, _options?: Configuration): Promise<HttpInfo<AppCategoryResponse>> {
        const result = this.api.appCategoriesGetInstanceWithHttpInfo(id, fieldsAppCategories, include, limitSubcategories, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppCategories the fields to include for returned resources of type appCategories
     * @param include comma-separated list of relationships to include
     * @param limitSubcategories maximum number of related subcategories returned (when they are included)
     */
    public appCategoriesGetInstance(id: string, fieldsAppCategories?: Array<'parent' | 'platforms' | 'subcategories'>, include?: Array<'parent' | 'subcategories'>, limitSubcategories?: number, _options?: Configuration): Promise<AppCategoryResponse> {
        const result = this.api.appCategoriesGetInstance(id, fieldsAppCategories, include, limitSubcategories, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppCategories the fields to include for returned resources of type appCategories
     */
    public appCategoriesParentGetToOneRelatedWithHttpInfo(id: string, fieldsAppCategories?: Array<'parent' | 'platforms' | 'subcategories'>, _options?: Configuration): Promise<HttpInfo<AppCategoryWithoutIncludesResponse>> {
        const result = this.api.appCategoriesParentGetToOneRelatedWithHttpInfo(id, fieldsAppCategories, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppCategories the fields to include for returned resources of type appCategories
     */
    public appCategoriesParentGetToOneRelated(id: string, fieldsAppCategories?: Array<'parent' | 'platforms' | 'subcategories'>, _options?: Configuration): Promise<AppCategoryWithoutIncludesResponse> {
        const result = this.api.appCategoriesParentGetToOneRelated(id, fieldsAppCategories, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppCategories the fields to include for returned resources of type appCategories
     * @param limit maximum resources per page
     */
    public appCategoriesSubcategoriesGetToManyRelatedWithHttpInfo(id: string, fieldsAppCategories?: Array<'parent' | 'platforms' | 'subcategories'>, limit?: number, _options?: Configuration): Promise<HttpInfo<AppCategoriesWithoutIncludesResponse>> {
        const result = this.api.appCategoriesSubcategoriesGetToManyRelatedWithHttpInfo(id, fieldsAppCategories, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppCategories the fields to include for returned resources of type appCategories
     * @param limit maximum resources per page
     */
    public appCategoriesSubcategoriesGetToManyRelated(id: string, fieldsAppCategories?: Array<'parent' | 'platforms' | 'subcategories'>, limit?: number, _options?: Configuration): Promise<AppCategoriesWithoutIncludesResponse> {
        const result = this.api.appCategoriesSubcategoriesGetToManyRelated(id, fieldsAppCategories, limit, _options);
        return result.toPromise();
    }


}



import { ObservableAppClipAdvancedExperienceImagesApi } from './ObservableAPI.ts';

import { AppClipAdvancedExperienceImagesApiRequestFactory, AppClipAdvancedExperienceImagesApiResponseProcessor} from "../apis/AppClipAdvancedExperienceImagesApi.ts";
export class PromiseAppClipAdvancedExperienceImagesApi {
    private api: ObservableAppClipAdvancedExperienceImagesApi

    public constructor(
        configuration: Configuration,
        requestFactory?: AppClipAdvancedExperienceImagesApiRequestFactory,
        responseProcessor?: AppClipAdvancedExperienceImagesApiResponseProcessor
    ) {
        this.api = new ObservableAppClipAdvancedExperienceImagesApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param appClipAdvancedExperienceImageCreateRequest AppClipAdvancedExperienceImage representation
     */
    public appClipAdvancedExperienceImagesCreateInstanceWithHttpInfo(appClipAdvancedExperienceImageCreateRequest: AppClipAdvancedExperienceImageCreateRequest, _options?: Configuration): Promise<HttpInfo<AppClipAdvancedExperienceImageResponse>> {
        const result = this.api.appClipAdvancedExperienceImagesCreateInstanceWithHttpInfo(appClipAdvancedExperienceImageCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param appClipAdvancedExperienceImageCreateRequest AppClipAdvancedExperienceImage representation
     */
    public appClipAdvancedExperienceImagesCreateInstance(appClipAdvancedExperienceImageCreateRequest: AppClipAdvancedExperienceImageCreateRequest, _options?: Configuration): Promise<AppClipAdvancedExperienceImageResponse> {
        const result = this.api.appClipAdvancedExperienceImagesCreateInstance(appClipAdvancedExperienceImageCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppClipAdvancedExperienceImages the fields to include for returned resources of type appClipAdvancedExperienceImages
     */
    public appClipAdvancedExperienceImagesGetInstanceWithHttpInfo(id: string, fieldsAppClipAdvancedExperienceImages?: Array<'assetDeliveryState' | 'fileName' | 'fileSize' | 'imageAsset' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, _options?: Configuration): Promise<HttpInfo<AppClipAdvancedExperienceImageResponse>> {
        const result = this.api.appClipAdvancedExperienceImagesGetInstanceWithHttpInfo(id, fieldsAppClipAdvancedExperienceImages, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppClipAdvancedExperienceImages the fields to include for returned resources of type appClipAdvancedExperienceImages
     */
    public appClipAdvancedExperienceImagesGetInstance(id: string, fieldsAppClipAdvancedExperienceImages?: Array<'assetDeliveryState' | 'fileName' | 'fileSize' | 'imageAsset' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, _options?: Configuration): Promise<AppClipAdvancedExperienceImageResponse> {
        const result = this.api.appClipAdvancedExperienceImagesGetInstance(id, fieldsAppClipAdvancedExperienceImages, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param appClipAdvancedExperienceImageUpdateRequest AppClipAdvancedExperienceImage representation
     */
    public appClipAdvancedExperienceImagesUpdateInstanceWithHttpInfo(id: string, appClipAdvancedExperienceImageUpdateRequest: AppClipAdvancedExperienceImageUpdateRequest, _options?: Configuration): Promise<HttpInfo<AppClipAdvancedExperienceImageResponse>> {
        const result = this.api.appClipAdvancedExperienceImagesUpdateInstanceWithHttpInfo(id, appClipAdvancedExperienceImageUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param appClipAdvancedExperienceImageUpdateRequest AppClipAdvancedExperienceImage representation
     */
    public appClipAdvancedExperienceImagesUpdateInstance(id: string, appClipAdvancedExperienceImageUpdateRequest: AppClipAdvancedExperienceImageUpdateRequest, _options?: Configuration): Promise<AppClipAdvancedExperienceImageResponse> {
        const result = this.api.appClipAdvancedExperienceImagesUpdateInstance(id, appClipAdvancedExperienceImageUpdateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableAppClipAdvancedExperiencesApi } from './ObservableAPI.ts';

import { AppClipAdvancedExperiencesApiRequestFactory, AppClipAdvancedExperiencesApiResponseProcessor} from "../apis/AppClipAdvancedExperiencesApi.ts";
export class PromiseAppClipAdvancedExperiencesApi {
    private api: ObservableAppClipAdvancedExperiencesApi

    public constructor(
        configuration: Configuration,
        requestFactory?: AppClipAdvancedExperiencesApiRequestFactory,
        responseProcessor?: AppClipAdvancedExperiencesApiResponseProcessor
    ) {
        this.api = new ObservableAppClipAdvancedExperiencesApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param appClipAdvancedExperienceCreateRequest AppClipAdvancedExperience representation
     */
    public appClipAdvancedExperiencesCreateInstanceWithHttpInfo(appClipAdvancedExperienceCreateRequest: AppClipAdvancedExperienceCreateRequest, _options?: Configuration): Promise<HttpInfo<AppClipAdvancedExperienceResponse>> {
        const result = this.api.appClipAdvancedExperiencesCreateInstanceWithHttpInfo(appClipAdvancedExperienceCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param appClipAdvancedExperienceCreateRequest AppClipAdvancedExperience representation
     */
    public appClipAdvancedExperiencesCreateInstance(appClipAdvancedExperienceCreateRequest: AppClipAdvancedExperienceCreateRequest, _options?: Configuration): Promise<AppClipAdvancedExperienceResponse> {
        const result = this.api.appClipAdvancedExperiencesCreateInstance(appClipAdvancedExperienceCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppClipAdvancedExperiences the fields to include for returned resources of type appClipAdvancedExperiences
     * @param include comma-separated list of relationships to include
     * @param limitLocalizations maximum number of related localizations returned (when they are included)
     */
    public appClipAdvancedExperiencesGetInstanceWithHttpInfo(id: string, fieldsAppClipAdvancedExperiences?: Array<'action' | 'appClip' | 'businessCategory' | 'defaultLanguage' | 'headerImage' | 'isPoweredBy' | 'link' | 'localizations' | 'place' | 'placeStatus' | 'removed' | 'status' | 'version'>, include?: Array<'appClip' | 'headerImage' | 'localizations'>, limitLocalizations?: number, _options?: Configuration): Promise<HttpInfo<AppClipAdvancedExperienceResponse>> {
        const result = this.api.appClipAdvancedExperiencesGetInstanceWithHttpInfo(id, fieldsAppClipAdvancedExperiences, include, limitLocalizations, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppClipAdvancedExperiences the fields to include for returned resources of type appClipAdvancedExperiences
     * @param include comma-separated list of relationships to include
     * @param limitLocalizations maximum number of related localizations returned (when they are included)
     */
    public appClipAdvancedExperiencesGetInstance(id: string, fieldsAppClipAdvancedExperiences?: Array<'action' | 'appClip' | 'businessCategory' | 'defaultLanguage' | 'headerImage' | 'isPoweredBy' | 'link' | 'localizations' | 'place' | 'placeStatus' | 'removed' | 'status' | 'version'>, include?: Array<'appClip' | 'headerImage' | 'localizations'>, limitLocalizations?: number, _options?: Configuration): Promise<AppClipAdvancedExperienceResponse> {
        const result = this.api.appClipAdvancedExperiencesGetInstance(id, fieldsAppClipAdvancedExperiences, include, limitLocalizations, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param appClipAdvancedExperienceUpdateRequest AppClipAdvancedExperience representation
     */
    public appClipAdvancedExperiencesUpdateInstanceWithHttpInfo(id: string, appClipAdvancedExperienceUpdateRequest: AppClipAdvancedExperienceUpdateRequest, _options?: Configuration): Promise<HttpInfo<AppClipAdvancedExperienceResponse>> {
        const result = this.api.appClipAdvancedExperiencesUpdateInstanceWithHttpInfo(id, appClipAdvancedExperienceUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param appClipAdvancedExperienceUpdateRequest AppClipAdvancedExperience representation
     */
    public appClipAdvancedExperiencesUpdateInstance(id: string, appClipAdvancedExperienceUpdateRequest: AppClipAdvancedExperienceUpdateRequest, _options?: Configuration): Promise<AppClipAdvancedExperienceResponse> {
        const result = this.api.appClipAdvancedExperiencesUpdateInstance(id, appClipAdvancedExperienceUpdateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableAppClipAppStoreReviewDetailsApi } from './ObservableAPI.ts';

import { AppClipAppStoreReviewDetailsApiRequestFactory, AppClipAppStoreReviewDetailsApiResponseProcessor} from "../apis/AppClipAppStoreReviewDetailsApi.ts";
export class PromiseAppClipAppStoreReviewDetailsApi {
    private api: ObservableAppClipAppStoreReviewDetailsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: AppClipAppStoreReviewDetailsApiRequestFactory,
        responseProcessor?: AppClipAppStoreReviewDetailsApiResponseProcessor
    ) {
        this.api = new ObservableAppClipAppStoreReviewDetailsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param appClipAppStoreReviewDetailCreateRequest AppClipAppStoreReviewDetail representation
     */
    public appClipAppStoreReviewDetailsCreateInstanceWithHttpInfo(appClipAppStoreReviewDetailCreateRequest: AppClipAppStoreReviewDetailCreateRequest, _options?: Configuration): Promise<HttpInfo<AppClipAppStoreReviewDetailResponse>> {
        const result = this.api.appClipAppStoreReviewDetailsCreateInstanceWithHttpInfo(appClipAppStoreReviewDetailCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param appClipAppStoreReviewDetailCreateRequest AppClipAppStoreReviewDetail representation
     */
    public appClipAppStoreReviewDetailsCreateInstance(appClipAppStoreReviewDetailCreateRequest: AppClipAppStoreReviewDetailCreateRequest, _options?: Configuration): Promise<AppClipAppStoreReviewDetailResponse> {
        const result = this.api.appClipAppStoreReviewDetailsCreateInstance(appClipAppStoreReviewDetailCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppClipAppStoreReviewDetails the fields to include for returned resources of type appClipAppStoreReviewDetails
     * @param include comma-separated list of relationships to include
     */
    public appClipAppStoreReviewDetailsGetInstanceWithHttpInfo(id: string, fieldsAppClipAppStoreReviewDetails?: Array<'appClipDefaultExperience' | 'invocationUrls'>, include?: Array<'appClipDefaultExperience'>, _options?: Configuration): Promise<HttpInfo<AppClipAppStoreReviewDetailResponse>> {
        const result = this.api.appClipAppStoreReviewDetailsGetInstanceWithHttpInfo(id, fieldsAppClipAppStoreReviewDetails, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppClipAppStoreReviewDetails the fields to include for returned resources of type appClipAppStoreReviewDetails
     * @param include comma-separated list of relationships to include
     */
    public appClipAppStoreReviewDetailsGetInstance(id: string, fieldsAppClipAppStoreReviewDetails?: Array<'appClipDefaultExperience' | 'invocationUrls'>, include?: Array<'appClipDefaultExperience'>, _options?: Configuration): Promise<AppClipAppStoreReviewDetailResponse> {
        const result = this.api.appClipAppStoreReviewDetailsGetInstance(id, fieldsAppClipAppStoreReviewDetails, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param appClipAppStoreReviewDetailUpdateRequest AppClipAppStoreReviewDetail representation
     */
    public appClipAppStoreReviewDetailsUpdateInstanceWithHttpInfo(id: string, appClipAppStoreReviewDetailUpdateRequest: AppClipAppStoreReviewDetailUpdateRequest, _options?: Configuration): Promise<HttpInfo<AppClipAppStoreReviewDetailResponse>> {
        const result = this.api.appClipAppStoreReviewDetailsUpdateInstanceWithHttpInfo(id, appClipAppStoreReviewDetailUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param appClipAppStoreReviewDetailUpdateRequest AppClipAppStoreReviewDetail representation
     */
    public appClipAppStoreReviewDetailsUpdateInstance(id: string, appClipAppStoreReviewDetailUpdateRequest: AppClipAppStoreReviewDetailUpdateRequest, _options?: Configuration): Promise<AppClipAppStoreReviewDetailResponse> {
        const result = this.api.appClipAppStoreReviewDetailsUpdateInstance(id, appClipAppStoreReviewDetailUpdateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableAppClipDefaultExperienceLocalizationsApi } from './ObservableAPI.ts';

import { AppClipDefaultExperienceLocalizationsApiRequestFactory, AppClipDefaultExperienceLocalizationsApiResponseProcessor} from "../apis/AppClipDefaultExperienceLocalizationsApi.ts";
export class PromiseAppClipDefaultExperienceLocalizationsApi {
    private api: ObservableAppClipDefaultExperienceLocalizationsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: AppClipDefaultExperienceLocalizationsApiRequestFactory,
        responseProcessor?: AppClipDefaultExperienceLocalizationsApiResponseProcessor
    ) {
        this.api = new ObservableAppClipDefaultExperienceLocalizationsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppClipHeaderImages the fields to include for returned resources of type appClipHeaderImages
     * @param fieldsAppClipDefaultExperienceLocalizations the fields to include for returned resources of type appClipDefaultExperienceLocalizations
     * @param include comma-separated list of relationships to include
     */
    public appClipDefaultExperienceLocalizationsAppClipHeaderImageGetToOneRelatedWithHttpInfo(id: string, fieldsAppClipHeaderImages?: Array<'appClipDefaultExperienceLocalization' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'imageAsset' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, fieldsAppClipDefaultExperienceLocalizations?: Array<'appClipDefaultExperience' | 'appClipHeaderImage' | 'locale' | 'subtitle'>, include?: Array<'appClipDefaultExperienceLocalization'>, _options?: Configuration): Promise<HttpInfo<AppClipHeaderImageResponse>> {
        const result = this.api.appClipDefaultExperienceLocalizationsAppClipHeaderImageGetToOneRelatedWithHttpInfo(id, fieldsAppClipHeaderImages, fieldsAppClipDefaultExperienceLocalizations, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppClipHeaderImages the fields to include for returned resources of type appClipHeaderImages
     * @param fieldsAppClipDefaultExperienceLocalizations the fields to include for returned resources of type appClipDefaultExperienceLocalizations
     * @param include comma-separated list of relationships to include
     */
    public appClipDefaultExperienceLocalizationsAppClipHeaderImageGetToOneRelated(id: string, fieldsAppClipHeaderImages?: Array<'appClipDefaultExperienceLocalization' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'imageAsset' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, fieldsAppClipDefaultExperienceLocalizations?: Array<'appClipDefaultExperience' | 'appClipHeaderImage' | 'locale' | 'subtitle'>, include?: Array<'appClipDefaultExperienceLocalization'>, _options?: Configuration): Promise<AppClipHeaderImageResponse> {
        const result = this.api.appClipDefaultExperienceLocalizationsAppClipHeaderImageGetToOneRelated(id, fieldsAppClipHeaderImages, fieldsAppClipDefaultExperienceLocalizations, include, _options);
        return result.toPromise();
    }

    /**
     * @param appClipDefaultExperienceLocalizationCreateRequest AppClipDefaultExperienceLocalization representation
     */
    public appClipDefaultExperienceLocalizationsCreateInstanceWithHttpInfo(appClipDefaultExperienceLocalizationCreateRequest: AppClipDefaultExperienceLocalizationCreateRequest, _options?: Configuration): Promise<HttpInfo<AppClipDefaultExperienceLocalizationResponse>> {
        const result = this.api.appClipDefaultExperienceLocalizationsCreateInstanceWithHttpInfo(appClipDefaultExperienceLocalizationCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param appClipDefaultExperienceLocalizationCreateRequest AppClipDefaultExperienceLocalization representation
     */
    public appClipDefaultExperienceLocalizationsCreateInstance(appClipDefaultExperienceLocalizationCreateRequest: AppClipDefaultExperienceLocalizationCreateRequest, _options?: Configuration): Promise<AppClipDefaultExperienceLocalizationResponse> {
        const result = this.api.appClipDefaultExperienceLocalizationsCreateInstance(appClipDefaultExperienceLocalizationCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public appClipDefaultExperienceLocalizationsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.appClipDefaultExperienceLocalizationsDeleteInstanceWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public appClipDefaultExperienceLocalizationsDeleteInstance(id: string, _options?: Configuration): Promise<void> {
        const result = this.api.appClipDefaultExperienceLocalizationsDeleteInstance(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppClipDefaultExperienceLocalizations the fields to include for returned resources of type appClipDefaultExperienceLocalizations
     * @param include comma-separated list of relationships to include
     * @param fieldsAppClipHeaderImages the fields to include for returned resources of type appClipHeaderImages
     */
    public appClipDefaultExperienceLocalizationsGetInstanceWithHttpInfo(id: string, fieldsAppClipDefaultExperienceLocalizations?: Array<'appClipDefaultExperience' | 'appClipHeaderImage' | 'locale' | 'subtitle'>, include?: Array<'appClipDefaultExperience' | 'appClipHeaderImage'>, fieldsAppClipHeaderImages?: Array<'appClipDefaultExperienceLocalization' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'imageAsset' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, _options?: Configuration): Promise<HttpInfo<AppClipDefaultExperienceLocalizationResponse>> {
        const result = this.api.appClipDefaultExperienceLocalizationsGetInstanceWithHttpInfo(id, fieldsAppClipDefaultExperienceLocalizations, include, fieldsAppClipHeaderImages, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppClipDefaultExperienceLocalizations the fields to include for returned resources of type appClipDefaultExperienceLocalizations
     * @param include comma-separated list of relationships to include
     * @param fieldsAppClipHeaderImages the fields to include for returned resources of type appClipHeaderImages
     */
    public appClipDefaultExperienceLocalizationsGetInstance(id: string, fieldsAppClipDefaultExperienceLocalizations?: Array<'appClipDefaultExperience' | 'appClipHeaderImage' | 'locale' | 'subtitle'>, include?: Array<'appClipDefaultExperience' | 'appClipHeaderImage'>, fieldsAppClipHeaderImages?: Array<'appClipDefaultExperienceLocalization' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'imageAsset' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, _options?: Configuration): Promise<AppClipDefaultExperienceLocalizationResponse> {
        const result = this.api.appClipDefaultExperienceLocalizationsGetInstance(id, fieldsAppClipDefaultExperienceLocalizations, include, fieldsAppClipHeaderImages, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param appClipDefaultExperienceLocalizationUpdateRequest AppClipDefaultExperienceLocalization representation
     */
    public appClipDefaultExperienceLocalizationsUpdateInstanceWithHttpInfo(id: string, appClipDefaultExperienceLocalizationUpdateRequest: AppClipDefaultExperienceLocalizationUpdateRequest, _options?: Configuration): Promise<HttpInfo<AppClipDefaultExperienceLocalizationResponse>> {
        const result = this.api.appClipDefaultExperienceLocalizationsUpdateInstanceWithHttpInfo(id, appClipDefaultExperienceLocalizationUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param appClipDefaultExperienceLocalizationUpdateRequest AppClipDefaultExperienceLocalization representation
     */
    public appClipDefaultExperienceLocalizationsUpdateInstance(id: string, appClipDefaultExperienceLocalizationUpdateRequest: AppClipDefaultExperienceLocalizationUpdateRequest, _options?: Configuration): Promise<AppClipDefaultExperienceLocalizationResponse> {
        const result = this.api.appClipDefaultExperienceLocalizationsUpdateInstance(id, appClipDefaultExperienceLocalizationUpdateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableAppClipDefaultExperiencesApi } from './ObservableAPI.ts';

import { AppClipDefaultExperiencesApiRequestFactory, AppClipDefaultExperiencesApiResponseProcessor} from "../apis/AppClipDefaultExperiencesApi.ts";
export class PromiseAppClipDefaultExperiencesApi {
    private api: ObservableAppClipDefaultExperiencesApi

    public constructor(
        configuration: Configuration,
        requestFactory?: AppClipDefaultExperiencesApiRequestFactory,
        responseProcessor?: AppClipDefaultExperiencesApiResponseProcessor
    ) {
        this.api = new ObservableAppClipDefaultExperiencesApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppClipAppStoreReviewDetails the fields to include for returned resources of type appClipAppStoreReviewDetails
     * @param fieldsAppClipDefaultExperiences the fields to include for returned resources of type appClipDefaultExperiences
     * @param include comma-separated list of relationships to include
     */
    public appClipDefaultExperiencesAppClipAppStoreReviewDetailGetToOneRelatedWithHttpInfo(id: string, fieldsAppClipAppStoreReviewDetails?: Array<'appClipDefaultExperience' | 'invocationUrls'>, fieldsAppClipDefaultExperiences?: Array<'action' | 'appClip' | 'appClipAppStoreReviewDetail' | 'appClipDefaultExperienceLocalizations' | 'appClipDefaultExperienceTemplate' | 'releaseWithAppStoreVersion'>, include?: Array<'appClipDefaultExperience'>, _options?: Configuration): Promise<HttpInfo<AppClipAppStoreReviewDetailResponse>> {
        const result = this.api.appClipDefaultExperiencesAppClipAppStoreReviewDetailGetToOneRelatedWithHttpInfo(id, fieldsAppClipAppStoreReviewDetails, fieldsAppClipDefaultExperiences, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppClipAppStoreReviewDetails the fields to include for returned resources of type appClipAppStoreReviewDetails
     * @param fieldsAppClipDefaultExperiences the fields to include for returned resources of type appClipDefaultExperiences
     * @param include comma-separated list of relationships to include
     */
    public appClipDefaultExperiencesAppClipAppStoreReviewDetailGetToOneRelated(id: string, fieldsAppClipAppStoreReviewDetails?: Array<'appClipDefaultExperience' | 'invocationUrls'>, fieldsAppClipDefaultExperiences?: Array<'action' | 'appClip' | 'appClipAppStoreReviewDetail' | 'appClipDefaultExperienceLocalizations' | 'appClipDefaultExperienceTemplate' | 'releaseWithAppStoreVersion'>, include?: Array<'appClipDefaultExperience'>, _options?: Configuration): Promise<AppClipAppStoreReviewDetailResponse> {
        const result = this.api.appClipDefaultExperiencesAppClipAppStoreReviewDetailGetToOneRelated(id, fieldsAppClipAppStoreReviewDetails, fieldsAppClipDefaultExperiences, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterLocale filter by attribute \&#39;locale\&#39;
     * @param fieldsAppClipDefaultExperiences the fields to include for returned resources of type appClipDefaultExperiences
     * @param fieldsAppClipDefaultExperienceLocalizations the fields to include for returned resources of type appClipDefaultExperienceLocalizations
     * @param fieldsAppClipHeaderImages the fields to include for returned resources of type appClipHeaderImages
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public appClipDefaultExperiencesAppClipDefaultExperienceLocalizationsGetToManyRelatedWithHttpInfo(id: string, filterLocale?: Array<string>, fieldsAppClipDefaultExperiences?: Array<'action' | 'appClip' | 'appClipAppStoreReviewDetail' | 'appClipDefaultExperienceLocalizations' | 'appClipDefaultExperienceTemplate' | 'releaseWithAppStoreVersion'>, fieldsAppClipDefaultExperienceLocalizations?: Array<'appClipDefaultExperience' | 'appClipHeaderImage' | 'locale' | 'subtitle'>, fieldsAppClipHeaderImages?: Array<'appClipDefaultExperienceLocalization' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'imageAsset' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, limit?: number, include?: Array<'appClipDefaultExperience' | 'appClipHeaderImage'>, _options?: Configuration): Promise<HttpInfo<AppClipDefaultExperienceLocalizationsResponse>> {
        const result = this.api.appClipDefaultExperiencesAppClipDefaultExperienceLocalizationsGetToManyRelatedWithHttpInfo(id, filterLocale, fieldsAppClipDefaultExperiences, fieldsAppClipDefaultExperienceLocalizations, fieldsAppClipHeaderImages, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterLocale filter by attribute \&#39;locale\&#39;
     * @param fieldsAppClipDefaultExperiences the fields to include for returned resources of type appClipDefaultExperiences
     * @param fieldsAppClipDefaultExperienceLocalizations the fields to include for returned resources of type appClipDefaultExperienceLocalizations
     * @param fieldsAppClipHeaderImages the fields to include for returned resources of type appClipHeaderImages
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public appClipDefaultExperiencesAppClipDefaultExperienceLocalizationsGetToManyRelated(id: string, filterLocale?: Array<string>, fieldsAppClipDefaultExperiences?: Array<'action' | 'appClip' | 'appClipAppStoreReviewDetail' | 'appClipDefaultExperienceLocalizations' | 'appClipDefaultExperienceTemplate' | 'releaseWithAppStoreVersion'>, fieldsAppClipDefaultExperienceLocalizations?: Array<'appClipDefaultExperience' | 'appClipHeaderImage' | 'locale' | 'subtitle'>, fieldsAppClipHeaderImages?: Array<'appClipDefaultExperienceLocalization' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'imageAsset' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, limit?: number, include?: Array<'appClipDefaultExperience' | 'appClipHeaderImage'>, _options?: Configuration): Promise<AppClipDefaultExperienceLocalizationsResponse> {
        const result = this.api.appClipDefaultExperiencesAppClipDefaultExperienceLocalizationsGetToManyRelated(id, filterLocale, fieldsAppClipDefaultExperiences, fieldsAppClipDefaultExperienceLocalizations, fieldsAppClipHeaderImages, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param appClipDefaultExperienceCreateRequest AppClipDefaultExperience representation
     */
    public appClipDefaultExperiencesCreateInstanceWithHttpInfo(appClipDefaultExperienceCreateRequest: AppClipDefaultExperienceCreateRequest, _options?: Configuration): Promise<HttpInfo<AppClipDefaultExperienceResponse>> {
        const result = this.api.appClipDefaultExperiencesCreateInstanceWithHttpInfo(appClipDefaultExperienceCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param appClipDefaultExperienceCreateRequest AppClipDefaultExperience representation
     */
    public appClipDefaultExperiencesCreateInstance(appClipDefaultExperienceCreateRequest: AppClipDefaultExperienceCreateRequest, _options?: Configuration): Promise<AppClipDefaultExperienceResponse> {
        const result = this.api.appClipDefaultExperiencesCreateInstance(appClipDefaultExperienceCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public appClipDefaultExperiencesDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.appClipDefaultExperiencesDeleteInstanceWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public appClipDefaultExperiencesDeleteInstance(id: string, _options?: Configuration): Promise<void> {
        const result = this.api.appClipDefaultExperiencesDeleteInstance(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppClipDefaultExperiences the fields to include for returned resources of type appClipDefaultExperiences
     * @param include comma-separated list of relationships to include
     * @param fieldsAppClipAppStoreReviewDetails the fields to include for returned resources of type appClipAppStoreReviewDetails
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsAppClipDefaultExperienceLocalizations the fields to include for returned resources of type appClipDefaultExperienceLocalizations
     * @param limitAppClipDefaultExperienceLocalizations maximum number of related appClipDefaultExperienceLocalizations returned (when they are included)
     */
    public appClipDefaultExperiencesGetInstanceWithHttpInfo(id: string, fieldsAppClipDefaultExperiences?: Array<'action' | 'appClip' | 'appClipAppStoreReviewDetail' | 'appClipDefaultExperienceLocalizations' | 'appClipDefaultExperienceTemplate' | 'releaseWithAppStoreVersion'>, include?: Array<'appClip' | 'appClipAppStoreReviewDetail' | 'appClipDefaultExperienceLocalizations' | 'releaseWithAppStoreVersion'>, fieldsAppClipAppStoreReviewDetails?: Array<'appClipDefaultExperience' | 'invocationUrls'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsAppClipDefaultExperienceLocalizations?: Array<'appClipDefaultExperience' | 'appClipHeaderImage' | 'locale' | 'subtitle'>, limitAppClipDefaultExperienceLocalizations?: number, _options?: Configuration): Promise<HttpInfo<AppClipDefaultExperienceResponse>> {
        const result = this.api.appClipDefaultExperiencesGetInstanceWithHttpInfo(id, fieldsAppClipDefaultExperiences, include, fieldsAppClipAppStoreReviewDetails, fieldsAppStoreVersions, fieldsAppClipDefaultExperienceLocalizations, limitAppClipDefaultExperienceLocalizations, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppClipDefaultExperiences the fields to include for returned resources of type appClipDefaultExperiences
     * @param include comma-separated list of relationships to include
     * @param fieldsAppClipAppStoreReviewDetails the fields to include for returned resources of type appClipAppStoreReviewDetails
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsAppClipDefaultExperienceLocalizations the fields to include for returned resources of type appClipDefaultExperienceLocalizations
     * @param limitAppClipDefaultExperienceLocalizations maximum number of related appClipDefaultExperienceLocalizations returned (when they are included)
     */
    public appClipDefaultExperiencesGetInstance(id: string, fieldsAppClipDefaultExperiences?: Array<'action' | 'appClip' | 'appClipAppStoreReviewDetail' | 'appClipDefaultExperienceLocalizations' | 'appClipDefaultExperienceTemplate' | 'releaseWithAppStoreVersion'>, include?: Array<'appClip' | 'appClipAppStoreReviewDetail' | 'appClipDefaultExperienceLocalizations' | 'releaseWithAppStoreVersion'>, fieldsAppClipAppStoreReviewDetails?: Array<'appClipDefaultExperience' | 'invocationUrls'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsAppClipDefaultExperienceLocalizations?: Array<'appClipDefaultExperience' | 'appClipHeaderImage' | 'locale' | 'subtitle'>, limitAppClipDefaultExperienceLocalizations?: number, _options?: Configuration): Promise<AppClipDefaultExperienceResponse> {
        const result = this.api.appClipDefaultExperiencesGetInstance(id, fieldsAppClipDefaultExperiences, include, fieldsAppClipAppStoreReviewDetails, fieldsAppStoreVersions, fieldsAppClipDefaultExperienceLocalizations, limitAppClipDefaultExperienceLocalizations, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAgeRatingDeclarations the fields to include for returned resources of type ageRatingDeclarations
     * @param fieldsAppStoreReviewDetails the fields to include for returned resources of type appStoreReviewDetails
     * @param fieldsAppStoreVersionLocalizations the fields to include for returned resources of type appStoreVersionLocalizations
     * @param fieldsAppStoreVersionExperiments the fields to include for returned resources of type appStoreVersionExperiments
     * @param fieldsAppStoreVersionSubmissions the fields to include for returned resources of type appStoreVersionSubmissions
     * @param fieldsAlternativeDistributionPackages the fields to include for returned resources of type alternativeDistributionPackages
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsRoutingAppCoverages the fields to include for returned resources of type routingAppCoverages
     * @param fieldsAppClipDefaultExperiences the fields to include for returned resources of type appClipDefaultExperiences
     * @param fieldsAppStoreVersionPhasedReleases the fields to include for returned resources of type appStoreVersionPhasedReleases
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param limitAppStoreVersionLocalizations maximum number of related appStoreVersionLocalizations returned (when they are included)
     * @param limitAppStoreVersionExperiments maximum number of related appStoreVersionExperiments returned (when they are included)
     * @param limitAppStoreVersionExperimentsV2 maximum number of related appStoreVersionExperimentsV2 returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appClipDefaultExperiencesReleaseWithAppStoreVersionGetToOneRelatedWithHttpInfo(id: string, fieldsAgeRatingDeclarations?: Array<'ageRatingOverride' | 'alcoholTobaccoOrDrugUseOrReferences' | 'contests' | 'gambling' | 'gamblingAndContests' | 'gamblingSimulated' | 'horrorOrFearThemes' | 'kidsAgeBand' | 'matureOrSuggestiveThemes' | 'medicalOrTreatmentInformation' | 'profanityOrCrudeHumor' | 'seventeenPlus' | 'sexualContentGraphicAndNudity' | 'sexualContentOrNudity' | 'unrestrictedWebAccess' | 'violenceCartoonOrFantasy' | 'violenceRealistic' | 'violenceRealisticProlongedGraphicOrSadistic'>, fieldsAppStoreReviewDetails?: Array<'appStoreReviewAttachments' | 'appStoreVersion' | 'contactEmail' | 'contactFirstName' | 'contactLastName' | 'contactPhone' | 'demoAccountName' | 'demoAccountPassword' | 'demoAccountRequired' | 'notes'>, fieldsAppStoreVersionLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersion' | 'description' | 'keywords' | 'locale' | 'marketingUrl' | 'promotionalText' | 'supportUrl' | 'whatsNew'>, fieldsAppStoreVersionExperiments?: Array<'app' | 'appStoreVersion' | 'appStoreVersionExperimentTreatments' | 'controlVersions' | 'endDate' | 'latestControlVersion' | 'name' | 'platform' | 'reviewRequired' | 'startDate' | 'started' | 'state' | 'trafficProportion'>, fieldsAppStoreVersionSubmissions?: Array<'appStoreVersion'>, fieldsAlternativeDistributionPackages?: Array<'appStoreVersion' | 'versions'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsRoutingAppCoverages?: Array<'appStoreVersion' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, fieldsAppClipDefaultExperiences?: Array<'action' | 'appClip' | 'appClipAppStoreReviewDetail' | 'appClipDefaultExperienceLocalizations' | 'appClipDefaultExperienceTemplate' | 'releaseWithAppStoreVersion'>, fieldsAppStoreVersionPhasedReleases?: Array<'appStoreVersion' | 'currentDayNumber' | 'phasedReleaseState' | 'startDate' | 'totalPauseDuration'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, limitAppStoreVersionLocalizations?: number, limitAppStoreVersionExperiments?: number, limitAppStoreVersionExperimentsV2?: number, include?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'build' | 'routingAppCoverage'>, _options?: Configuration): Promise<HttpInfo<AppStoreVersionResponse>> {
        const result = this.api.appClipDefaultExperiencesReleaseWithAppStoreVersionGetToOneRelatedWithHttpInfo(id, fieldsAgeRatingDeclarations, fieldsAppStoreReviewDetails, fieldsAppStoreVersionLocalizations, fieldsAppStoreVersionExperiments, fieldsAppStoreVersionSubmissions, fieldsAlternativeDistributionPackages, fieldsAppStoreVersions, fieldsApps, fieldsRoutingAppCoverages, fieldsAppClipDefaultExperiences, fieldsAppStoreVersionPhasedReleases, fieldsBuilds, limitAppStoreVersionLocalizations, limitAppStoreVersionExperiments, limitAppStoreVersionExperimentsV2, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAgeRatingDeclarations the fields to include for returned resources of type ageRatingDeclarations
     * @param fieldsAppStoreReviewDetails the fields to include for returned resources of type appStoreReviewDetails
     * @param fieldsAppStoreVersionLocalizations the fields to include for returned resources of type appStoreVersionLocalizations
     * @param fieldsAppStoreVersionExperiments the fields to include for returned resources of type appStoreVersionExperiments
     * @param fieldsAppStoreVersionSubmissions the fields to include for returned resources of type appStoreVersionSubmissions
     * @param fieldsAlternativeDistributionPackages the fields to include for returned resources of type alternativeDistributionPackages
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsRoutingAppCoverages the fields to include for returned resources of type routingAppCoverages
     * @param fieldsAppClipDefaultExperiences the fields to include for returned resources of type appClipDefaultExperiences
     * @param fieldsAppStoreVersionPhasedReleases the fields to include for returned resources of type appStoreVersionPhasedReleases
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param limitAppStoreVersionLocalizations maximum number of related appStoreVersionLocalizations returned (when they are included)
     * @param limitAppStoreVersionExperiments maximum number of related appStoreVersionExperiments returned (when they are included)
     * @param limitAppStoreVersionExperimentsV2 maximum number of related appStoreVersionExperimentsV2 returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appClipDefaultExperiencesReleaseWithAppStoreVersionGetToOneRelated(id: string, fieldsAgeRatingDeclarations?: Array<'ageRatingOverride' | 'alcoholTobaccoOrDrugUseOrReferences' | 'contests' | 'gambling' | 'gamblingAndContests' | 'gamblingSimulated' | 'horrorOrFearThemes' | 'kidsAgeBand' | 'matureOrSuggestiveThemes' | 'medicalOrTreatmentInformation' | 'profanityOrCrudeHumor' | 'seventeenPlus' | 'sexualContentGraphicAndNudity' | 'sexualContentOrNudity' | 'unrestrictedWebAccess' | 'violenceCartoonOrFantasy' | 'violenceRealistic' | 'violenceRealisticProlongedGraphicOrSadistic'>, fieldsAppStoreReviewDetails?: Array<'appStoreReviewAttachments' | 'appStoreVersion' | 'contactEmail' | 'contactFirstName' | 'contactLastName' | 'contactPhone' | 'demoAccountName' | 'demoAccountPassword' | 'demoAccountRequired' | 'notes'>, fieldsAppStoreVersionLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersion' | 'description' | 'keywords' | 'locale' | 'marketingUrl' | 'promotionalText' | 'supportUrl' | 'whatsNew'>, fieldsAppStoreVersionExperiments?: Array<'app' | 'appStoreVersion' | 'appStoreVersionExperimentTreatments' | 'controlVersions' | 'endDate' | 'latestControlVersion' | 'name' | 'platform' | 'reviewRequired' | 'startDate' | 'started' | 'state' | 'trafficProportion'>, fieldsAppStoreVersionSubmissions?: Array<'appStoreVersion'>, fieldsAlternativeDistributionPackages?: Array<'appStoreVersion' | 'versions'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsRoutingAppCoverages?: Array<'appStoreVersion' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, fieldsAppClipDefaultExperiences?: Array<'action' | 'appClip' | 'appClipAppStoreReviewDetail' | 'appClipDefaultExperienceLocalizations' | 'appClipDefaultExperienceTemplate' | 'releaseWithAppStoreVersion'>, fieldsAppStoreVersionPhasedReleases?: Array<'appStoreVersion' | 'currentDayNumber' | 'phasedReleaseState' | 'startDate' | 'totalPauseDuration'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, limitAppStoreVersionLocalizations?: number, limitAppStoreVersionExperiments?: number, limitAppStoreVersionExperimentsV2?: number, include?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'build' | 'routingAppCoverage'>, _options?: Configuration): Promise<AppStoreVersionResponse> {
        const result = this.api.appClipDefaultExperiencesReleaseWithAppStoreVersionGetToOneRelated(id, fieldsAgeRatingDeclarations, fieldsAppStoreReviewDetails, fieldsAppStoreVersionLocalizations, fieldsAppStoreVersionExperiments, fieldsAppStoreVersionSubmissions, fieldsAlternativeDistributionPackages, fieldsAppStoreVersions, fieldsApps, fieldsRoutingAppCoverages, fieldsAppClipDefaultExperiences, fieldsAppStoreVersionPhasedReleases, fieldsBuilds, limitAppStoreVersionLocalizations, limitAppStoreVersionExperiments, limitAppStoreVersionExperimentsV2, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public appClipDefaultExperiencesReleaseWithAppStoreVersionGetToOneRelationshipWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<AppClipDefaultExperienceReleaseWithAppStoreVersionLinkageResponse>> {
        const result = this.api.appClipDefaultExperiencesReleaseWithAppStoreVersionGetToOneRelationshipWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public appClipDefaultExperiencesReleaseWithAppStoreVersionGetToOneRelationship(id: string, _options?: Configuration): Promise<AppClipDefaultExperienceReleaseWithAppStoreVersionLinkageResponse> {
        const result = this.api.appClipDefaultExperiencesReleaseWithAppStoreVersionGetToOneRelationship(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param appClipDefaultExperienceReleaseWithAppStoreVersionLinkageRequest Related linkage
     */
    public appClipDefaultExperiencesReleaseWithAppStoreVersionUpdateToOneRelationshipWithHttpInfo(id: string, appClipDefaultExperienceReleaseWithAppStoreVersionLinkageRequest: AppClipDefaultExperienceReleaseWithAppStoreVersionLinkageRequest, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.appClipDefaultExperiencesReleaseWithAppStoreVersionUpdateToOneRelationshipWithHttpInfo(id, appClipDefaultExperienceReleaseWithAppStoreVersionLinkageRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param appClipDefaultExperienceReleaseWithAppStoreVersionLinkageRequest Related linkage
     */
    public appClipDefaultExperiencesReleaseWithAppStoreVersionUpdateToOneRelationship(id: string, appClipDefaultExperienceReleaseWithAppStoreVersionLinkageRequest: AppClipDefaultExperienceReleaseWithAppStoreVersionLinkageRequest, _options?: Configuration): Promise<void> {
        const result = this.api.appClipDefaultExperiencesReleaseWithAppStoreVersionUpdateToOneRelationship(id, appClipDefaultExperienceReleaseWithAppStoreVersionLinkageRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param appClipDefaultExperienceUpdateRequest AppClipDefaultExperience representation
     */
    public appClipDefaultExperiencesUpdateInstanceWithHttpInfo(id: string, appClipDefaultExperienceUpdateRequest: AppClipDefaultExperienceUpdateRequest, _options?: Configuration): Promise<HttpInfo<AppClipDefaultExperienceResponse>> {
        const result = this.api.appClipDefaultExperiencesUpdateInstanceWithHttpInfo(id, appClipDefaultExperienceUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param appClipDefaultExperienceUpdateRequest AppClipDefaultExperience representation
     */
    public appClipDefaultExperiencesUpdateInstance(id: string, appClipDefaultExperienceUpdateRequest: AppClipDefaultExperienceUpdateRequest, _options?: Configuration): Promise<AppClipDefaultExperienceResponse> {
        const result = this.api.appClipDefaultExperiencesUpdateInstance(id, appClipDefaultExperienceUpdateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableAppClipHeaderImagesApi } from './ObservableAPI.ts';

import { AppClipHeaderImagesApiRequestFactory, AppClipHeaderImagesApiResponseProcessor} from "../apis/AppClipHeaderImagesApi.ts";
export class PromiseAppClipHeaderImagesApi {
    private api: ObservableAppClipHeaderImagesApi

    public constructor(
        configuration: Configuration,
        requestFactory?: AppClipHeaderImagesApiRequestFactory,
        responseProcessor?: AppClipHeaderImagesApiResponseProcessor
    ) {
        this.api = new ObservableAppClipHeaderImagesApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param appClipHeaderImageCreateRequest AppClipHeaderImage representation
     */
    public appClipHeaderImagesCreateInstanceWithHttpInfo(appClipHeaderImageCreateRequest: AppClipHeaderImageCreateRequest, _options?: Configuration): Promise<HttpInfo<AppClipHeaderImageResponse>> {
        const result = this.api.appClipHeaderImagesCreateInstanceWithHttpInfo(appClipHeaderImageCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param appClipHeaderImageCreateRequest AppClipHeaderImage representation
     */
    public appClipHeaderImagesCreateInstance(appClipHeaderImageCreateRequest: AppClipHeaderImageCreateRequest, _options?: Configuration): Promise<AppClipHeaderImageResponse> {
        const result = this.api.appClipHeaderImagesCreateInstance(appClipHeaderImageCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public appClipHeaderImagesDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.appClipHeaderImagesDeleteInstanceWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public appClipHeaderImagesDeleteInstance(id: string, _options?: Configuration): Promise<void> {
        const result = this.api.appClipHeaderImagesDeleteInstance(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppClipHeaderImages the fields to include for returned resources of type appClipHeaderImages
     * @param include comma-separated list of relationships to include
     */
    public appClipHeaderImagesGetInstanceWithHttpInfo(id: string, fieldsAppClipHeaderImages?: Array<'appClipDefaultExperienceLocalization' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'imageAsset' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, include?: Array<'appClipDefaultExperienceLocalization'>, _options?: Configuration): Promise<HttpInfo<AppClipHeaderImageResponse>> {
        const result = this.api.appClipHeaderImagesGetInstanceWithHttpInfo(id, fieldsAppClipHeaderImages, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppClipHeaderImages the fields to include for returned resources of type appClipHeaderImages
     * @param include comma-separated list of relationships to include
     */
    public appClipHeaderImagesGetInstance(id: string, fieldsAppClipHeaderImages?: Array<'appClipDefaultExperienceLocalization' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'imageAsset' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, include?: Array<'appClipDefaultExperienceLocalization'>, _options?: Configuration): Promise<AppClipHeaderImageResponse> {
        const result = this.api.appClipHeaderImagesGetInstance(id, fieldsAppClipHeaderImages, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param appClipHeaderImageUpdateRequest AppClipHeaderImage representation
     */
    public appClipHeaderImagesUpdateInstanceWithHttpInfo(id: string, appClipHeaderImageUpdateRequest: AppClipHeaderImageUpdateRequest, _options?: Configuration): Promise<HttpInfo<AppClipHeaderImageResponse>> {
        const result = this.api.appClipHeaderImagesUpdateInstanceWithHttpInfo(id, appClipHeaderImageUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param appClipHeaderImageUpdateRequest AppClipHeaderImage representation
     */
    public appClipHeaderImagesUpdateInstance(id: string, appClipHeaderImageUpdateRequest: AppClipHeaderImageUpdateRequest, _options?: Configuration): Promise<AppClipHeaderImageResponse> {
        const result = this.api.appClipHeaderImagesUpdateInstance(id, appClipHeaderImageUpdateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableAppClipsApi } from './ObservableAPI.ts';

import { AppClipsApiRequestFactory, AppClipsApiResponseProcessor} from "../apis/AppClipsApi.ts";
export class PromiseAppClipsApi {
    private api: ObservableAppClipsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: AppClipsApiRequestFactory,
        responseProcessor?: AppClipsApiResponseProcessor
    ) {
        this.api = new ObservableAppClipsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param id the id of the requested resource
     * @param filterAction filter by attribute \&#39;action\&#39;
     * @param filterPlaceStatus filter by attribute \&#39;placeStatus\&#39;
     * @param filterStatus filter by attribute \&#39;status\&#39;
     * @param fieldsAppClipAdvancedExperiences the fields to include for returned resources of type appClipAdvancedExperiences
     * @param fieldsAppClips the fields to include for returned resources of type appClips
     * @param fieldsAppClipAdvancedExperienceImages the fields to include for returned resources of type appClipAdvancedExperienceImages
     * @param fieldsAppClipAdvancedExperienceLocalizations the fields to include for returned resources of type appClipAdvancedExperienceLocalizations
     * @param limit maximum resources per page
     * @param limitLocalizations maximum number of related localizations returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appClipsAppClipAdvancedExperiencesGetToManyRelatedWithHttpInfo(id: string, filterAction?: Array<'OPEN' | 'VIEW' | 'PLAY'>, filterPlaceStatus?: Array<'PENDING' | 'MATCHED' | 'NO_MATCH'>, filterStatus?: Array<'RECEIVED' | 'DEACTIVATED' | 'APP_TRANSFER_IN_PROGRESS'>, fieldsAppClipAdvancedExperiences?: Array<'action' | 'appClip' | 'businessCategory' | 'defaultLanguage' | 'headerImage' | 'isPoweredBy' | 'link' | 'localizations' | 'place' | 'placeStatus' | 'removed' | 'status' | 'version'>, fieldsAppClips?: Array<'app' | 'appClipAdvancedExperiences' | 'appClipDefaultExperiences' | 'bundleId'>, fieldsAppClipAdvancedExperienceImages?: Array<'assetDeliveryState' | 'fileName' | 'fileSize' | 'imageAsset' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, fieldsAppClipAdvancedExperienceLocalizations?: Array<'language' | 'subtitle' | 'title'>, limit?: number, limitLocalizations?: number, include?: Array<'appClip' | 'headerImage' | 'localizations'>, _options?: Configuration): Promise<HttpInfo<AppClipAdvancedExperiencesResponse>> {
        const result = this.api.appClipsAppClipAdvancedExperiencesGetToManyRelatedWithHttpInfo(id, filterAction, filterPlaceStatus, filterStatus, fieldsAppClipAdvancedExperiences, fieldsAppClips, fieldsAppClipAdvancedExperienceImages, fieldsAppClipAdvancedExperienceLocalizations, limit, limitLocalizations, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterAction filter by attribute \&#39;action\&#39;
     * @param filterPlaceStatus filter by attribute \&#39;placeStatus\&#39;
     * @param filterStatus filter by attribute \&#39;status\&#39;
     * @param fieldsAppClipAdvancedExperiences the fields to include for returned resources of type appClipAdvancedExperiences
     * @param fieldsAppClips the fields to include for returned resources of type appClips
     * @param fieldsAppClipAdvancedExperienceImages the fields to include for returned resources of type appClipAdvancedExperienceImages
     * @param fieldsAppClipAdvancedExperienceLocalizations the fields to include for returned resources of type appClipAdvancedExperienceLocalizations
     * @param limit maximum resources per page
     * @param limitLocalizations maximum number of related localizations returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appClipsAppClipAdvancedExperiencesGetToManyRelated(id: string, filterAction?: Array<'OPEN' | 'VIEW' | 'PLAY'>, filterPlaceStatus?: Array<'PENDING' | 'MATCHED' | 'NO_MATCH'>, filterStatus?: Array<'RECEIVED' | 'DEACTIVATED' | 'APP_TRANSFER_IN_PROGRESS'>, fieldsAppClipAdvancedExperiences?: Array<'action' | 'appClip' | 'businessCategory' | 'defaultLanguage' | 'headerImage' | 'isPoweredBy' | 'link' | 'localizations' | 'place' | 'placeStatus' | 'removed' | 'status' | 'version'>, fieldsAppClips?: Array<'app' | 'appClipAdvancedExperiences' | 'appClipDefaultExperiences' | 'bundleId'>, fieldsAppClipAdvancedExperienceImages?: Array<'assetDeliveryState' | 'fileName' | 'fileSize' | 'imageAsset' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, fieldsAppClipAdvancedExperienceLocalizations?: Array<'language' | 'subtitle' | 'title'>, limit?: number, limitLocalizations?: number, include?: Array<'appClip' | 'headerImage' | 'localizations'>, _options?: Configuration): Promise<AppClipAdvancedExperiencesResponse> {
        const result = this.api.appClipsAppClipAdvancedExperiencesGetToManyRelated(id, filterAction, filterPlaceStatus, filterStatus, fieldsAppClipAdvancedExperiences, fieldsAppClips, fieldsAppClipAdvancedExperienceImages, fieldsAppClipAdvancedExperienceLocalizations, limit, limitLocalizations, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param existsReleaseWithAppStoreVersion filter by existence or non-existence of related \&#39;releaseWithAppStoreVersion\&#39;
     * @param fieldsAppClips the fields to include for returned resources of type appClips
     * @param fieldsAppClipAppStoreReviewDetails the fields to include for returned resources of type appClipAppStoreReviewDetails
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsAppClipDefaultExperiences the fields to include for returned resources of type appClipDefaultExperiences
     * @param fieldsAppClipDefaultExperienceLocalizations the fields to include for returned resources of type appClipDefaultExperienceLocalizations
     * @param limit maximum resources per page
     * @param limitAppClipDefaultExperienceLocalizations maximum number of related appClipDefaultExperienceLocalizations returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appClipsAppClipDefaultExperiencesGetToManyRelatedWithHttpInfo(id: string, existsReleaseWithAppStoreVersion?: boolean, fieldsAppClips?: Array<'app' | 'appClipAdvancedExperiences' | 'appClipDefaultExperiences' | 'bundleId'>, fieldsAppClipAppStoreReviewDetails?: Array<'appClipDefaultExperience' | 'invocationUrls'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsAppClipDefaultExperiences?: Array<'action' | 'appClip' | 'appClipAppStoreReviewDetail' | 'appClipDefaultExperienceLocalizations' | 'appClipDefaultExperienceTemplate' | 'releaseWithAppStoreVersion'>, fieldsAppClipDefaultExperienceLocalizations?: Array<'appClipDefaultExperience' | 'appClipHeaderImage' | 'locale' | 'subtitle'>, limit?: number, limitAppClipDefaultExperienceLocalizations?: number, include?: Array<'appClip' | 'appClipAppStoreReviewDetail' | 'appClipDefaultExperienceLocalizations' | 'releaseWithAppStoreVersion'>, _options?: Configuration): Promise<HttpInfo<AppClipDefaultExperiencesResponse>> {
        const result = this.api.appClipsAppClipDefaultExperiencesGetToManyRelatedWithHttpInfo(id, existsReleaseWithAppStoreVersion, fieldsAppClips, fieldsAppClipAppStoreReviewDetails, fieldsAppStoreVersions, fieldsAppClipDefaultExperiences, fieldsAppClipDefaultExperienceLocalizations, limit, limitAppClipDefaultExperienceLocalizations, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param existsReleaseWithAppStoreVersion filter by existence or non-existence of related \&#39;releaseWithAppStoreVersion\&#39;
     * @param fieldsAppClips the fields to include for returned resources of type appClips
     * @param fieldsAppClipAppStoreReviewDetails the fields to include for returned resources of type appClipAppStoreReviewDetails
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsAppClipDefaultExperiences the fields to include for returned resources of type appClipDefaultExperiences
     * @param fieldsAppClipDefaultExperienceLocalizations the fields to include for returned resources of type appClipDefaultExperienceLocalizations
     * @param limit maximum resources per page
     * @param limitAppClipDefaultExperienceLocalizations maximum number of related appClipDefaultExperienceLocalizations returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appClipsAppClipDefaultExperiencesGetToManyRelated(id: string, existsReleaseWithAppStoreVersion?: boolean, fieldsAppClips?: Array<'app' | 'appClipAdvancedExperiences' | 'appClipDefaultExperiences' | 'bundleId'>, fieldsAppClipAppStoreReviewDetails?: Array<'appClipDefaultExperience' | 'invocationUrls'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsAppClipDefaultExperiences?: Array<'action' | 'appClip' | 'appClipAppStoreReviewDetail' | 'appClipDefaultExperienceLocalizations' | 'appClipDefaultExperienceTemplate' | 'releaseWithAppStoreVersion'>, fieldsAppClipDefaultExperienceLocalizations?: Array<'appClipDefaultExperience' | 'appClipHeaderImage' | 'locale' | 'subtitle'>, limit?: number, limitAppClipDefaultExperienceLocalizations?: number, include?: Array<'appClip' | 'appClipAppStoreReviewDetail' | 'appClipDefaultExperienceLocalizations' | 'releaseWithAppStoreVersion'>, _options?: Configuration): Promise<AppClipDefaultExperiencesResponse> {
        const result = this.api.appClipsAppClipDefaultExperiencesGetToManyRelated(id, existsReleaseWithAppStoreVersion, fieldsAppClips, fieldsAppClipAppStoreReviewDetails, fieldsAppStoreVersions, fieldsAppClipDefaultExperiences, fieldsAppClipDefaultExperienceLocalizations, limit, limitAppClipDefaultExperienceLocalizations, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppClips the fields to include for returned resources of type appClips
     * @param include comma-separated list of relationships to include
     * @param fieldsAppClipAdvancedExperiences the fields to include for returned resources of type appClipAdvancedExperiences
     * @param fieldsAppClipDefaultExperiences the fields to include for returned resources of type appClipDefaultExperiences
     * @param limitAppClipDefaultExperiences maximum number of related appClipDefaultExperiences returned (when they are included)
     */
    public appClipsGetInstanceWithHttpInfo(id: string, fieldsAppClips?: Array<'app' | 'appClipAdvancedExperiences' | 'appClipDefaultExperiences' | 'bundleId'>, include?: Array<'app' | 'appClipDefaultExperiences'>, fieldsAppClipAdvancedExperiences?: Array<'action' | 'appClip' | 'businessCategory' | 'defaultLanguage' | 'headerImage' | 'isPoweredBy' | 'link' | 'localizations' | 'place' | 'placeStatus' | 'removed' | 'status' | 'version'>, fieldsAppClipDefaultExperiences?: Array<'action' | 'appClip' | 'appClipAppStoreReviewDetail' | 'appClipDefaultExperienceLocalizations' | 'appClipDefaultExperienceTemplate' | 'releaseWithAppStoreVersion'>, limitAppClipDefaultExperiences?: number, _options?: Configuration): Promise<HttpInfo<AppClipResponse>> {
        const result = this.api.appClipsGetInstanceWithHttpInfo(id, fieldsAppClips, include, fieldsAppClipAdvancedExperiences, fieldsAppClipDefaultExperiences, limitAppClipDefaultExperiences, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppClips the fields to include for returned resources of type appClips
     * @param include comma-separated list of relationships to include
     * @param fieldsAppClipAdvancedExperiences the fields to include for returned resources of type appClipAdvancedExperiences
     * @param fieldsAppClipDefaultExperiences the fields to include for returned resources of type appClipDefaultExperiences
     * @param limitAppClipDefaultExperiences maximum number of related appClipDefaultExperiences returned (when they are included)
     */
    public appClipsGetInstance(id: string, fieldsAppClips?: Array<'app' | 'appClipAdvancedExperiences' | 'appClipDefaultExperiences' | 'bundleId'>, include?: Array<'app' | 'appClipDefaultExperiences'>, fieldsAppClipAdvancedExperiences?: Array<'action' | 'appClip' | 'businessCategory' | 'defaultLanguage' | 'headerImage' | 'isPoweredBy' | 'link' | 'localizations' | 'place' | 'placeStatus' | 'removed' | 'status' | 'version'>, fieldsAppClipDefaultExperiences?: Array<'action' | 'appClip' | 'appClipAppStoreReviewDetail' | 'appClipDefaultExperienceLocalizations' | 'appClipDefaultExperienceTemplate' | 'releaseWithAppStoreVersion'>, limitAppClipDefaultExperiences?: number, _options?: Configuration): Promise<AppClipResponse> {
        const result = this.api.appClipsGetInstance(id, fieldsAppClips, include, fieldsAppClipAdvancedExperiences, fieldsAppClipDefaultExperiences, limitAppClipDefaultExperiences, _options);
        return result.toPromise();
    }


}



import { ObservableAppCustomProductPageLocalizationsApi } from './ObservableAPI.ts';

import { AppCustomProductPageLocalizationsApiRequestFactory, AppCustomProductPageLocalizationsApiResponseProcessor} from "../apis/AppCustomProductPageLocalizationsApi.ts";
export class PromiseAppCustomProductPageLocalizationsApi {
    private api: ObservableAppCustomProductPageLocalizationsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: AppCustomProductPageLocalizationsApiRequestFactory,
        responseProcessor?: AppCustomProductPageLocalizationsApiResponseProcessor
    ) {
        this.api = new ObservableAppCustomProductPageLocalizationsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param id the id of the requested resource
     * @param filterPreviewType filter by attribute \&#39;previewType\&#39;
     * @param filterAppStoreVersionExperimentTreatmentLocalization filter by id(s) of related \&#39;appStoreVersionExperimentTreatmentLocalization\&#39;
     * @param filterAppStoreVersionLocalization filter by id(s) of related \&#39;appStoreVersionLocalization\&#39;
     * @param fieldsAppCustomProductPageLocalizations the fields to include for returned resources of type appCustomProductPageLocalizations
     * @param fieldsAppStoreVersionExperimentTreatmentLocalizations the fields to include for returned resources of type appStoreVersionExperimentTreatmentLocalizations
     * @param fieldsAppPreviews the fields to include for returned resources of type appPreviews
     * @param fieldsAppPreviewSets the fields to include for returned resources of type appPreviewSets
     * @param fieldsAppStoreVersionLocalizations the fields to include for returned resources of type appStoreVersionLocalizations
     * @param limit maximum resources per page
     * @param limitAppPreviews maximum number of related appPreviews returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appCustomProductPageLocalizationsAppPreviewSetsGetToManyRelatedWithHttpInfo(id: string, filterPreviewType?: Array<'IPHONE_67' | 'IPHONE_61' | 'IPHONE_65' | 'IPHONE_58' | 'IPHONE_55' | 'IPHONE_47' | 'IPHONE_40' | 'IPHONE_35' | 'IPAD_PRO_3GEN_129' | 'IPAD_PRO_3GEN_11' | 'IPAD_PRO_129' | 'IPAD_105' | 'IPAD_97' | 'DESKTOP' | 'APPLE_TV' | 'APPLE_VISION_PRO'>, filterAppStoreVersionExperimentTreatmentLocalization?: Array<string>, filterAppStoreVersionLocalization?: Array<string>, fieldsAppCustomProductPageLocalizations?: Array<'appCustomProductPageVersion' | 'appPreviewSets' | 'appScreenshotSets' | 'locale' | 'promotionalText'>, fieldsAppStoreVersionExperimentTreatmentLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersionExperimentTreatment' | 'locale'>, fieldsAppPreviews?: Array<'appPreviewSet' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'mimeType' | 'previewFrameTimeCode' | 'previewImage' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded' | 'videoUrl'>, fieldsAppPreviewSets?: Array<'appCustomProductPageLocalization' | 'appPreviews' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'previewType'>, fieldsAppStoreVersionLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersion' | 'description' | 'keywords' | 'locale' | 'marketingUrl' | 'promotionalText' | 'supportUrl' | 'whatsNew'>, limit?: number, limitAppPreviews?: number, include?: Array<'appCustomProductPageLocalization' | 'appPreviews' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization'>, _options?: Configuration): Promise<HttpInfo<AppPreviewSetsResponse>> {
        const result = this.api.appCustomProductPageLocalizationsAppPreviewSetsGetToManyRelatedWithHttpInfo(id, filterPreviewType, filterAppStoreVersionExperimentTreatmentLocalization, filterAppStoreVersionLocalization, fieldsAppCustomProductPageLocalizations, fieldsAppStoreVersionExperimentTreatmentLocalizations, fieldsAppPreviews, fieldsAppPreviewSets, fieldsAppStoreVersionLocalizations, limit, limitAppPreviews, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterPreviewType filter by attribute \&#39;previewType\&#39;
     * @param filterAppStoreVersionExperimentTreatmentLocalization filter by id(s) of related \&#39;appStoreVersionExperimentTreatmentLocalization\&#39;
     * @param filterAppStoreVersionLocalization filter by id(s) of related \&#39;appStoreVersionLocalization\&#39;
     * @param fieldsAppCustomProductPageLocalizations the fields to include for returned resources of type appCustomProductPageLocalizations
     * @param fieldsAppStoreVersionExperimentTreatmentLocalizations the fields to include for returned resources of type appStoreVersionExperimentTreatmentLocalizations
     * @param fieldsAppPreviews the fields to include for returned resources of type appPreviews
     * @param fieldsAppPreviewSets the fields to include for returned resources of type appPreviewSets
     * @param fieldsAppStoreVersionLocalizations the fields to include for returned resources of type appStoreVersionLocalizations
     * @param limit maximum resources per page
     * @param limitAppPreviews maximum number of related appPreviews returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appCustomProductPageLocalizationsAppPreviewSetsGetToManyRelated(id: string, filterPreviewType?: Array<'IPHONE_67' | 'IPHONE_61' | 'IPHONE_65' | 'IPHONE_58' | 'IPHONE_55' | 'IPHONE_47' | 'IPHONE_40' | 'IPHONE_35' | 'IPAD_PRO_3GEN_129' | 'IPAD_PRO_3GEN_11' | 'IPAD_PRO_129' | 'IPAD_105' | 'IPAD_97' | 'DESKTOP' | 'APPLE_TV' | 'APPLE_VISION_PRO'>, filterAppStoreVersionExperimentTreatmentLocalization?: Array<string>, filterAppStoreVersionLocalization?: Array<string>, fieldsAppCustomProductPageLocalizations?: Array<'appCustomProductPageVersion' | 'appPreviewSets' | 'appScreenshotSets' | 'locale' | 'promotionalText'>, fieldsAppStoreVersionExperimentTreatmentLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersionExperimentTreatment' | 'locale'>, fieldsAppPreviews?: Array<'appPreviewSet' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'mimeType' | 'previewFrameTimeCode' | 'previewImage' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded' | 'videoUrl'>, fieldsAppPreviewSets?: Array<'appCustomProductPageLocalization' | 'appPreviews' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'previewType'>, fieldsAppStoreVersionLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersion' | 'description' | 'keywords' | 'locale' | 'marketingUrl' | 'promotionalText' | 'supportUrl' | 'whatsNew'>, limit?: number, limitAppPreviews?: number, include?: Array<'appCustomProductPageLocalization' | 'appPreviews' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization'>, _options?: Configuration): Promise<AppPreviewSetsResponse> {
        const result = this.api.appCustomProductPageLocalizationsAppPreviewSetsGetToManyRelated(id, filterPreviewType, filterAppStoreVersionExperimentTreatmentLocalization, filterAppStoreVersionLocalization, fieldsAppCustomProductPageLocalizations, fieldsAppStoreVersionExperimentTreatmentLocalizations, fieldsAppPreviews, fieldsAppPreviewSets, fieldsAppStoreVersionLocalizations, limit, limitAppPreviews, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterScreenshotDisplayType filter by attribute \&#39;screenshotDisplayType\&#39;
     * @param filterAppStoreVersionExperimentTreatmentLocalization filter by id(s) of related \&#39;appStoreVersionExperimentTreatmentLocalization\&#39;
     * @param filterAppStoreVersionLocalization filter by id(s) of related \&#39;appStoreVersionLocalization\&#39;
     * @param fieldsAppScreenshotSets the fields to include for returned resources of type appScreenshotSets
     * @param fieldsAppCustomProductPageLocalizations the fields to include for returned resources of type appCustomProductPageLocalizations
     * @param fieldsAppStoreVersionExperimentTreatmentLocalizations the fields to include for returned resources of type appStoreVersionExperimentTreatmentLocalizations
     * @param fieldsAppScreenshots the fields to include for returned resources of type appScreenshots
     * @param fieldsAppStoreVersionLocalizations the fields to include for returned resources of type appStoreVersionLocalizations
     * @param limit maximum resources per page
     * @param limitAppScreenshots maximum number of related appScreenshots returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appCustomProductPageLocalizationsAppScreenshotSetsGetToManyRelatedWithHttpInfo(id: string, filterScreenshotDisplayType?: Array<'APP_IPHONE_67' | 'APP_IPHONE_61' | 'APP_IPHONE_65' | 'APP_IPHONE_58' | 'APP_IPHONE_55' | 'APP_IPHONE_47' | 'APP_IPHONE_40' | 'APP_IPHONE_35' | 'APP_IPAD_PRO_3GEN_129' | 'APP_IPAD_PRO_3GEN_11' | 'APP_IPAD_PRO_129' | 'APP_IPAD_105' | 'APP_IPAD_97' | 'APP_DESKTOP' | 'APP_WATCH_ULTRA' | 'APP_WATCH_SERIES_7' | 'APP_WATCH_SERIES_4' | 'APP_WATCH_SERIES_3' | 'APP_APPLE_TV' | 'APP_APPLE_VISION_PRO' | 'IMESSAGE_APP_IPHONE_67' | 'IMESSAGE_APP_IPHONE_61' | 'IMESSAGE_APP_IPHONE_65' | 'IMESSAGE_APP_IPHONE_58' | 'IMESSAGE_APP_IPHONE_55' | 'IMESSAGE_APP_IPHONE_47' | 'IMESSAGE_APP_IPHONE_40' | 'IMESSAGE_APP_IPAD_PRO_3GEN_129' | 'IMESSAGE_APP_IPAD_PRO_3GEN_11' | 'IMESSAGE_APP_IPAD_PRO_129' | 'IMESSAGE_APP_IPAD_105' | 'IMESSAGE_APP_IPAD_97'>, filterAppStoreVersionExperimentTreatmentLocalization?: Array<string>, filterAppStoreVersionLocalization?: Array<string>, fieldsAppScreenshotSets?: Array<'appCustomProductPageLocalization' | 'appScreenshots' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'screenshotDisplayType'>, fieldsAppCustomProductPageLocalizations?: Array<'appCustomProductPageVersion' | 'appPreviewSets' | 'appScreenshotSets' | 'locale' | 'promotionalText'>, fieldsAppStoreVersionExperimentTreatmentLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersionExperimentTreatment' | 'locale'>, fieldsAppScreenshots?: Array<'appScreenshotSet' | 'assetDeliveryState' | 'assetToken' | 'assetType' | 'fileName' | 'fileSize' | 'imageAsset' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, fieldsAppStoreVersionLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersion' | 'description' | 'keywords' | 'locale' | 'marketingUrl' | 'promotionalText' | 'supportUrl' | 'whatsNew'>, limit?: number, limitAppScreenshots?: number, include?: Array<'appCustomProductPageLocalization' | 'appScreenshots' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization'>, _options?: Configuration): Promise<HttpInfo<AppScreenshotSetsResponse>> {
        const result = this.api.appCustomProductPageLocalizationsAppScreenshotSetsGetToManyRelatedWithHttpInfo(id, filterScreenshotDisplayType, filterAppStoreVersionExperimentTreatmentLocalization, filterAppStoreVersionLocalization, fieldsAppScreenshotSets, fieldsAppCustomProductPageLocalizations, fieldsAppStoreVersionExperimentTreatmentLocalizations, fieldsAppScreenshots, fieldsAppStoreVersionLocalizations, limit, limitAppScreenshots, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterScreenshotDisplayType filter by attribute \&#39;screenshotDisplayType\&#39;
     * @param filterAppStoreVersionExperimentTreatmentLocalization filter by id(s) of related \&#39;appStoreVersionExperimentTreatmentLocalization\&#39;
     * @param filterAppStoreVersionLocalization filter by id(s) of related \&#39;appStoreVersionLocalization\&#39;
     * @param fieldsAppScreenshotSets the fields to include for returned resources of type appScreenshotSets
     * @param fieldsAppCustomProductPageLocalizations the fields to include for returned resources of type appCustomProductPageLocalizations
     * @param fieldsAppStoreVersionExperimentTreatmentLocalizations the fields to include for returned resources of type appStoreVersionExperimentTreatmentLocalizations
     * @param fieldsAppScreenshots the fields to include for returned resources of type appScreenshots
     * @param fieldsAppStoreVersionLocalizations the fields to include for returned resources of type appStoreVersionLocalizations
     * @param limit maximum resources per page
     * @param limitAppScreenshots maximum number of related appScreenshots returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appCustomProductPageLocalizationsAppScreenshotSetsGetToManyRelated(id: string, filterScreenshotDisplayType?: Array<'APP_IPHONE_67' | 'APP_IPHONE_61' | 'APP_IPHONE_65' | 'APP_IPHONE_58' | 'APP_IPHONE_55' | 'APP_IPHONE_47' | 'APP_IPHONE_40' | 'APP_IPHONE_35' | 'APP_IPAD_PRO_3GEN_129' | 'APP_IPAD_PRO_3GEN_11' | 'APP_IPAD_PRO_129' | 'APP_IPAD_105' | 'APP_IPAD_97' | 'APP_DESKTOP' | 'APP_WATCH_ULTRA' | 'APP_WATCH_SERIES_7' | 'APP_WATCH_SERIES_4' | 'APP_WATCH_SERIES_3' | 'APP_APPLE_TV' | 'APP_APPLE_VISION_PRO' | 'IMESSAGE_APP_IPHONE_67' | 'IMESSAGE_APP_IPHONE_61' | 'IMESSAGE_APP_IPHONE_65' | 'IMESSAGE_APP_IPHONE_58' | 'IMESSAGE_APP_IPHONE_55' | 'IMESSAGE_APP_IPHONE_47' | 'IMESSAGE_APP_IPHONE_40' | 'IMESSAGE_APP_IPAD_PRO_3GEN_129' | 'IMESSAGE_APP_IPAD_PRO_3GEN_11' | 'IMESSAGE_APP_IPAD_PRO_129' | 'IMESSAGE_APP_IPAD_105' | 'IMESSAGE_APP_IPAD_97'>, filterAppStoreVersionExperimentTreatmentLocalization?: Array<string>, filterAppStoreVersionLocalization?: Array<string>, fieldsAppScreenshotSets?: Array<'appCustomProductPageLocalization' | 'appScreenshots' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'screenshotDisplayType'>, fieldsAppCustomProductPageLocalizations?: Array<'appCustomProductPageVersion' | 'appPreviewSets' | 'appScreenshotSets' | 'locale' | 'promotionalText'>, fieldsAppStoreVersionExperimentTreatmentLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersionExperimentTreatment' | 'locale'>, fieldsAppScreenshots?: Array<'appScreenshotSet' | 'assetDeliveryState' | 'assetToken' | 'assetType' | 'fileName' | 'fileSize' | 'imageAsset' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, fieldsAppStoreVersionLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersion' | 'description' | 'keywords' | 'locale' | 'marketingUrl' | 'promotionalText' | 'supportUrl' | 'whatsNew'>, limit?: number, limitAppScreenshots?: number, include?: Array<'appCustomProductPageLocalization' | 'appScreenshots' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization'>, _options?: Configuration): Promise<AppScreenshotSetsResponse> {
        const result = this.api.appCustomProductPageLocalizationsAppScreenshotSetsGetToManyRelated(id, filterScreenshotDisplayType, filterAppStoreVersionExperimentTreatmentLocalization, filterAppStoreVersionLocalization, fieldsAppScreenshotSets, fieldsAppCustomProductPageLocalizations, fieldsAppStoreVersionExperimentTreatmentLocalizations, fieldsAppScreenshots, fieldsAppStoreVersionLocalizations, limit, limitAppScreenshots, include, _options);
        return result.toPromise();
    }

    /**
     * @param appCustomProductPageLocalizationCreateRequest AppCustomProductPageLocalization representation
     */
    public appCustomProductPageLocalizationsCreateInstanceWithHttpInfo(appCustomProductPageLocalizationCreateRequest: AppCustomProductPageLocalizationCreateRequest, _options?: Configuration): Promise<HttpInfo<AppCustomProductPageLocalizationResponse>> {
        const result = this.api.appCustomProductPageLocalizationsCreateInstanceWithHttpInfo(appCustomProductPageLocalizationCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param appCustomProductPageLocalizationCreateRequest AppCustomProductPageLocalization representation
     */
    public appCustomProductPageLocalizationsCreateInstance(appCustomProductPageLocalizationCreateRequest: AppCustomProductPageLocalizationCreateRequest, _options?: Configuration): Promise<AppCustomProductPageLocalizationResponse> {
        const result = this.api.appCustomProductPageLocalizationsCreateInstance(appCustomProductPageLocalizationCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public appCustomProductPageLocalizationsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.appCustomProductPageLocalizationsDeleteInstanceWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public appCustomProductPageLocalizationsDeleteInstance(id: string, _options?: Configuration): Promise<void> {
        const result = this.api.appCustomProductPageLocalizationsDeleteInstance(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppCustomProductPageLocalizations the fields to include for returned resources of type appCustomProductPageLocalizations
     * @param include comma-separated list of relationships to include
     * @param fieldsAppScreenshotSets the fields to include for returned resources of type appScreenshotSets
     * @param fieldsAppPreviewSets the fields to include for returned resources of type appPreviewSets
     * @param limitAppPreviewSets maximum number of related appPreviewSets returned (when they are included)
     * @param limitAppScreenshotSets maximum number of related appScreenshotSets returned (when they are included)
     */
    public appCustomProductPageLocalizationsGetInstanceWithHttpInfo(id: string, fieldsAppCustomProductPageLocalizations?: Array<'appCustomProductPageVersion' | 'appPreviewSets' | 'appScreenshotSets' | 'locale' | 'promotionalText'>, include?: Array<'appCustomProductPageVersion' | 'appPreviewSets' | 'appScreenshotSets'>, fieldsAppScreenshotSets?: Array<'appCustomProductPageLocalization' | 'appScreenshots' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'screenshotDisplayType'>, fieldsAppPreviewSets?: Array<'appCustomProductPageLocalization' | 'appPreviews' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'previewType'>, limitAppPreviewSets?: number, limitAppScreenshotSets?: number, _options?: Configuration): Promise<HttpInfo<AppCustomProductPageLocalizationResponse>> {
        const result = this.api.appCustomProductPageLocalizationsGetInstanceWithHttpInfo(id, fieldsAppCustomProductPageLocalizations, include, fieldsAppScreenshotSets, fieldsAppPreviewSets, limitAppPreviewSets, limitAppScreenshotSets, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppCustomProductPageLocalizations the fields to include for returned resources of type appCustomProductPageLocalizations
     * @param include comma-separated list of relationships to include
     * @param fieldsAppScreenshotSets the fields to include for returned resources of type appScreenshotSets
     * @param fieldsAppPreviewSets the fields to include for returned resources of type appPreviewSets
     * @param limitAppPreviewSets maximum number of related appPreviewSets returned (when they are included)
     * @param limitAppScreenshotSets maximum number of related appScreenshotSets returned (when they are included)
     */
    public appCustomProductPageLocalizationsGetInstance(id: string, fieldsAppCustomProductPageLocalizations?: Array<'appCustomProductPageVersion' | 'appPreviewSets' | 'appScreenshotSets' | 'locale' | 'promotionalText'>, include?: Array<'appCustomProductPageVersion' | 'appPreviewSets' | 'appScreenshotSets'>, fieldsAppScreenshotSets?: Array<'appCustomProductPageLocalization' | 'appScreenshots' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'screenshotDisplayType'>, fieldsAppPreviewSets?: Array<'appCustomProductPageLocalization' | 'appPreviews' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'previewType'>, limitAppPreviewSets?: number, limitAppScreenshotSets?: number, _options?: Configuration): Promise<AppCustomProductPageLocalizationResponse> {
        const result = this.api.appCustomProductPageLocalizationsGetInstance(id, fieldsAppCustomProductPageLocalizations, include, fieldsAppScreenshotSets, fieldsAppPreviewSets, limitAppPreviewSets, limitAppScreenshotSets, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param appCustomProductPageLocalizationUpdateRequest AppCustomProductPageLocalization representation
     */
    public appCustomProductPageLocalizationsUpdateInstanceWithHttpInfo(id: string, appCustomProductPageLocalizationUpdateRequest: AppCustomProductPageLocalizationUpdateRequest, _options?: Configuration): Promise<HttpInfo<AppCustomProductPageLocalizationResponse>> {
        const result = this.api.appCustomProductPageLocalizationsUpdateInstanceWithHttpInfo(id, appCustomProductPageLocalizationUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param appCustomProductPageLocalizationUpdateRequest AppCustomProductPageLocalization representation
     */
    public appCustomProductPageLocalizationsUpdateInstance(id: string, appCustomProductPageLocalizationUpdateRequest: AppCustomProductPageLocalizationUpdateRequest, _options?: Configuration): Promise<AppCustomProductPageLocalizationResponse> {
        const result = this.api.appCustomProductPageLocalizationsUpdateInstance(id, appCustomProductPageLocalizationUpdateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableAppCustomProductPageVersionsApi } from './ObservableAPI.ts';

import { AppCustomProductPageVersionsApiRequestFactory, AppCustomProductPageVersionsApiResponseProcessor} from "../apis/AppCustomProductPageVersionsApi.ts";
export class PromiseAppCustomProductPageVersionsApi {
    private api: ObservableAppCustomProductPageVersionsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: AppCustomProductPageVersionsApiRequestFactory,
        responseProcessor?: AppCustomProductPageVersionsApiResponseProcessor
    ) {
        this.api = new ObservableAppCustomProductPageVersionsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param id the id of the requested resource
     * @param filterLocale filter by attribute \&#39;locale\&#39;
     * @param fieldsAppScreenshotSets the fields to include for returned resources of type appScreenshotSets
     * @param fieldsAppCustomProductPageLocalizations the fields to include for returned resources of type appCustomProductPageLocalizations
     * @param fieldsAppCustomProductPageVersions the fields to include for returned resources of type appCustomProductPageVersions
     * @param fieldsAppPreviewSets the fields to include for returned resources of type appPreviewSets
     * @param limit maximum resources per page
     * @param limitAppScreenshotSets maximum number of related appScreenshotSets returned (when they are included)
     * @param limitAppPreviewSets maximum number of related appPreviewSets returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appCustomProductPageVersionsAppCustomProductPageLocalizationsGetToManyRelatedWithHttpInfo(id: string, filterLocale?: Array<string>, fieldsAppScreenshotSets?: Array<'appCustomProductPageLocalization' | 'appScreenshots' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'screenshotDisplayType'>, fieldsAppCustomProductPageLocalizations?: Array<'appCustomProductPageVersion' | 'appPreviewSets' | 'appScreenshotSets' | 'locale' | 'promotionalText'>, fieldsAppCustomProductPageVersions?: Array<'appCustomProductPage' | 'appCustomProductPageLocalizations' | 'state' | 'version'>, fieldsAppPreviewSets?: Array<'appCustomProductPageLocalization' | 'appPreviews' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'previewType'>, limit?: number, limitAppScreenshotSets?: number, limitAppPreviewSets?: number, include?: Array<'appCustomProductPageVersion' | 'appPreviewSets' | 'appScreenshotSets'>, _options?: Configuration): Promise<HttpInfo<AppCustomProductPageLocalizationsResponse>> {
        const result = this.api.appCustomProductPageVersionsAppCustomProductPageLocalizationsGetToManyRelatedWithHttpInfo(id, filterLocale, fieldsAppScreenshotSets, fieldsAppCustomProductPageLocalizations, fieldsAppCustomProductPageVersions, fieldsAppPreviewSets, limit, limitAppScreenshotSets, limitAppPreviewSets, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterLocale filter by attribute \&#39;locale\&#39;
     * @param fieldsAppScreenshotSets the fields to include for returned resources of type appScreenshotSets
     * @param fieldsAppCustomProductPageLocalizations the fields to include for returned resources of type appCustomProductPageLocalizations
     * @param fieldsAppCustomProductPageVersions the fields to include for returned resources of type appCustomProductPageVersions
     * @param fieldsAppPreviewSets the fields to include for returned resources of type appPreviewSets
     * @param limit maximum resources per page
     * @param limitAppScreenshotSets maximum number of related appScreenshotSets returned (when they are included)
     * @param limitAppPreviewSets maximum number of related appPreviewSets returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appCustomProductPageVersionsAppCustomProductPageLocalizationsGetToManyRelated(id: string, filterLocale?: Array<string>, fieldsAppScreenshotSets?: Array<'appCustomProductPageLocalization' | 'appScreenshots' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'screenshotDisplayType'>, fieldsAppCustomProductPageLocalizations?: Array<'appCustomProductPageVersion' | 'appPreviewSets' | 'appScreenshotSets' | 'locale' | 'promotionalText'>, fieldsAppCustomProductPageVersions?: Array<'appCustomProductPage' | 'appCustomProductPageLocalizations' | 'state' | 'version'>, fieldsAppPreviewSets?: Array<'appCustomProductPageLocalization' | 'appPreviews' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'previewType'>, limit?: number, limitAppScreenshotSets?: number, limitAppPreviewSets?: number, include?: Array<'appCustomProductPageVersion' | 'appPreviewSets' | 'appScreenshotSets'>, _options?: Configuration): Promise<AppCustomProductPageLocalizationsResponse> {
        const result = this.api.appCustomProductPageVersionsAppCustomProductPageLocalizationsGetToManyRelated(id, filterLocale, fieldsAppScreenshotSets, fieldsAppCustomProductPageLocalizations, fieldsAppCustomProductPageVersions, fieldsAppPreviewSets, limit, limitAppScreenshotSets, limitAppPreviewSets, include, _options);
        return result.toPromise();
    }

    /**
     * @param appCustomProductPageVersionCreateRequest AppCustomProductPageVersion representation
     */
    public appCustomProductPageVersionsCreateInstanceWithHttpInfo(appCustomProductPageVersionCreateRequest: AppCustomProductPageVersionCreateRequest, _options?: Configuration): Promise<HttpInfo<AppCustomProductPageVersionResponse>> {
        const result = this.api.appCustomProductPageVersionsCreateInstanceWithHttpInfo(appCustomProductPageVersionCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param appCustomProductPageVersionCreateRequest AppCustomProductPageVersion representation
     */
    public appCustomProductPageVersionsCreateInstance(appCustomProductPageVersionCreateRequest: AppCustomProductPageVersionCreateRequest, _options?: Configuration): Promise<AppCustomProductPageVersionResponse> {
        const result = this.api.appCustomProductPageVersionsCreateInstance(appCustomProductPageVersionCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppCustomProductPageVersions the fields to include for returned resources of type appCustomProductPageVersions
     * @param include comma-separated list of relationships to include
     * @param fieldsAppCustomProductPageLocalizations the fields to include for returned resources of type appCustomProductPageLocalizations
     * @param limitAppCustomProductPageLocalizations maximum number of related appCustomProductPageLocalizations returned (when they are included)
     */
    public appCustomProductPageVersionsGetInstanceWithHttpInfo(id: string, fieldsAppCustomProductPageVersions?: Array<'appCustomProductPage' | 'appCustomProductPageLocalizations' | 'state' | 'version'>, include?: Array<'appCustomProductPage' | 'appCustomProductPageLocalizations'>, fieldsAppCustomProductPageLocalizations?: Array<'appCustomProductPageVersion' | 'appPreviewSets' | 'appScreenshotSets' | 'locale' | 'promotionalText'>, limitAppCustomProductPageLocalizations?: number, _options?: Configuration): Promise<HttpInfo<AppCustomProductPageVersionResponse>> {
        const result = this.api.appCustomProductPageVersionsGetInstanceWithHttpInfo(id, fieldsAppCustomProductPageVersions, include, fieldsAppCustomProductPageLocalizations, limitAppCustomProductPageLocalizations, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppCustomProductPageVersions the fields to include for returned resources of type appCustomProductPageVersions
     * @param include comma-separated list of relationships to include
     * @param fieldsAppCustomProductPageLocalizations the fields to include for returned resources of type appCustomProductPageLocalizations
     * @param limitAppCustomProductPageLocalizations maximum number of related appCustomProductPageLocalizations returned (when they are included)
     */
    public appCustomProductPageVersionsGetInstance(id: string, fieldsAppCustomProductPageVersions?: Array<'appCustomProductPage' | 'appCustomProductPageLocalizations' | 'state' | 'version'>, include?: Array<'appCustomProductPage' | 'appCustomProductPageLocalizations'>, fieldsAppCustomProductPageLocalizations?: Array<'appCustomProductPageVersion' | 'appPreviewSets' | 'appScreenshotSets' | 'locale' | 'promotionalText'>, limitAppCustomProductPageLocalizations?: number, _options?: Configuration): Promise<AppCustomProductPageVersionResponse> {
        const result = this.api.appCustomProductPageVersionsGetInstance(id, fieldsAppCustomProductPageVersions, include, fieldsAppCustomProductPageLocalizations, limitAppCustomProductPageLocalizations, _options);
        return result.toPromise();
    }


}



import { ObservableAppCustomProductPagesApi } from './ObservableAPI.ts';

import { AppCustomProductPagesApiRequestFactory, AppCustomProductPagesApiResponseProcessor} from "../apis/AppCustomProductPagesApi.ts";
export class PromiseAppCustomProductPagesApi {
    private api: ObservableAppCustomProductPagesApi

    public constructor(
        configuration: Configuration,
        requestFactory?: AppCustomProductPagesApiRequestFactory,
        responseProcessor?: AppCustomProductPagesApiResponseProcessor
    ) {
        this.api = new ObservableAppCustomProductPagesApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param id the id of the requested resource
     * @param filterState filter by attribute \&#39;state\&#39;
     * @param fieldsAppCustomProductPageLocalizations the fields to include for returned resources of type appCustomProductPageLocalizations
     * @param fieldsAppCustomProductPageVersions the fields to include for returned resources of type appCustomProductPageVersions
     * @param fieldsAppCustomProductPages the fields to include for returned resources of type appCustomProductPages
     * @param limit maximum resources per page
     * @param limitAppCustomProductPageLocalizations maximum number of related appCustomProductPageLocalizations returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appCustomProductPagesAppCustomProductPageVersionsGetToManyRelatedWithHttpInfo(id: string, filterState?: Array<'PREPARE_FOR_SUBMISSION' | 'READY_FOR_REVIEW' | 'WAITING_FOR_REVIEW' | 'IN_REVIEW' | 'ACCEPTED' | 'APPROVED' | 'REPLACED_WITH_NEW_VERSION' | 'REJECTED'>, fieldsAppCustomProductPageLocalizations?: Array<'appCustomProductPageVersion' | 'appPreviewSets' | 'appScreenshotSets' | 'locale' | 'promotionalText'>, fieldsAppCustomProductPageVersions?: Array<'appCustomProductPage' | 'appCustomProductPageLocalizations' | 'state' | 'version'>, fieldsAppCustomProductPages?: Array<'app' | 'appCustomProductPageVersions' | 'appStoreVersionTemplate' | 'customProductPageTemplate' | 'name' | 'url' | 'visible'>, limit?: number, limitAppCustomProductPageLocalizations?: number, include?: Array<'appCustomProductPage' | 'appCustomProductPageLocalizations'>, _options?: Configuration): Promise<HttpInfo<AppCustomProductPageVersionsResponse>> {
        const result = this.api.appCustomProductPagesAppCustomProductPageVersionsGetToManyRelatedWithHttpInfo(id, filterState, fieldsAppCustomProductPageLocalizations, fieldsAppCustomProductPageVersions, fieldsAppCustomProductPages, limit, limitAppCustomProductPageLocalizations, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterState filter by attribute \&#39;state\&#39;
     * @param fieldsAppCustomProductPageLocalizations the fields to include for returned resources of type appCustomProductPageLocalizations
     * @param fieldsAppCustomProductPageVersions the fields to include for returned resources of type appCustomProductPageVersions
     * @param fieldsAppCustomProductPages the fields to include for returned resources of type appCustomProductPages
     * @param limit maximum resources per page
     * @param limitAppCustomProductPageLocalizations maximum number of related appCustomProductPageLocalizations returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appCustomProductPagesAppCustomProductPageVersionsGetToManyRelated(id: string, filterState?: Array<'PREPARE_FOR_SUBMISSION' | 'READY_FOR_REVIEW' | 'WAITING_FOR_REVIEW' | 'IN_REVIEW' | 'ACCEPTED' | 'APPROVED' | 'REPLACED_WITH_NEW_VERSION' | 'REJECTED'>, fieldsAppCustomProductPageLocalizations?: Array<'appCustomProductPageVersion' | 'appPreviewSets' | 'appScreenshotSets' | 'locale' | 'promotionalText'>, fieldsAppCustomProductPageVersions?: Array<'appCustomProductPage' | 'appCustomProductPageLocalizations' | 'state' | 'version'>, fieldsAppCustomProductPages?: Array<'app' | 'appCustomProductPageVersions' | 'appStoreVersionTemplate' | 'customProductPageTemplate' | 'name' | 'url' | 'visible'>, limit?: number, limitAppCustomProductPageLocalizations?: number, include?: Array<'appCustomProductPage' | 'appCustomProductPageLocalizations'>, _options?: Configuration): Promise<AppCustomProductPageVersionsResponse> {
        const result = this.api.appCustomProductPagesAppCustomProductPageVersionsGetToManyRelated(id, filterState, fieldsAppCustomProductPageLocalizations, fieldsAppCustomProductPageVersions, fieldsAppCustomProductPages, limit, limitAppCustomProductPageLocalizations, include, _options);
        return result.toPromise();
    }

    /**
     * @param appCustomProductPageCreateRequest AppCustomProductPage representation
     */
    public appCustomProductPagesCreateInstanceWithHttpInfo(appCustomProductPageCreateRequest: AppCustomProductPageCreateRequest, _options?: Configuration): Promise<HttpInfo<AppCustomProductPageResponse>> {
        const result = this.api.appCustomProductPagesCreateInstanceWithHttpInfo(appCustomProductPageCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param appCustomProductPageCreateRequest AppCustomProductPage representation
     */
    public appCustomProductPagesCreateInstance(appCustomProductPageCreateRequest: AppCustomProductPageCreateRequest, _options?: Configuration): Promise<AppCustomProductPageResponse> {
        const result = this.api.appCustomProductPagesCreateInstance(appCustomProductPageCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public appCustomProductPagesDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.appCustomProductPagesDeleteInstanceWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public appCustomProductPagesDeleteInstance(id: string, _options?: Configuration): Promise<void> {
        const result = this.api.appCustomProductPagesDeleteInstance(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppCustomProductPages the fields to include for returned resources of type appCustomProductPages
     * @param include comma-separated list of relationships to include
     * @param fieldsAppCustomProductPageVersions the fields to include for returned resources of type appCustomProductPageVersions
     * @param limitAppCustomProductPageVersions maximum number of related appCustomProductPageVersions returned (when they are included)
     */
    public appCustomProductPagesGetInstanceWithHttpInfo(id: string, fieldsAppCustomProductPages?: Array<'app' | 'appCustomProductPageVersions' | 'appStoreVersionTemplate' | 'customProductPageTemplate' | 'name' | 'url' | 'visible'>, include?: Array<'app' | 'appCustomProductPageVersions'>, fieldsAppCustomProductPageVersions?: Array<'appCustomProductPage' | 'appCustomProductPageLocalizations' | 'state' | 'version'>, limitAppCustomProductPageVersions?: number, _options?: Configuration): Promise<HttpInfo<AppCustomProductPageResponse>> {
        const result = this.api.appCustomProductPagesGetInstanceWithHttpInfo(id, fieldsAppCustomProductPages, include, fieldsAppCustomProductPageVersions, limitAppCustomProductPageVersions, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppCustomProductPages the fields to include for returned resources of type appCustomProductPages
     * @param include comma-separated list of relationships to include
     * @param fieldsAppCustomProductPageVersions the fields to include for returned resources of type appCustomProductPageVersions
     * @param limitAppCustomProductPageVersions maximum number of related appCustomProductPageVersions returned (when they are included)
     */
    public appCustomProductPagesGetInstance(id: string, fieldsAppCustomProductPages?: Array<'app' | 'appCustomProductPageVersions' | 'appStoreVersionTemplate' | 'customProductPageTemplate' | 'name' | 'url' | 'visible'>, include?: Array<'app' | 'appCustomProductPageVersions'>, fieldsAppCustomProductPageVersions?: Array<'appCustomProductPage' | 'appCustomProductPageLocalizations' | 'state' | 'version'>, limitAppCustomProductPageVersions?: number, _options?: Configuration): Promise<AppCustomProductPageResponse> {
        const result = this.api.appCustomProductPagesGetInstance(id, fieldsAppCustomProductPages, include, fieldsAppCustomProductPageVersions, limitAppCustomProductPageVersions, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param appCustomProductPageUpdateRequest AppCustomProductPage representation
     */
    public appCustomProductPagesUpdateInstanceWithHttpInfo(id: string, appCustomProductPageUpdateRequest: AppCustomProductPageUpdateRequest, _options?: Configuration): Promise<HttpInfo<AppCustomProductPageResponse>> {
        const result = this.api.appCustomProductPagesUpdateInstanceWithHttpInfo(id, appCustomProductPageUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param appCustomProductPageUpdateRequest AppCustomProductPage representation
     */
    public appCustomProductPagesUpdateInstance(id: string, appCustomProductPageUpdateRequest: AppCustomProductPageUpdateRequest, _options?: Configuration): Promise<AppCustomProductPageResponse> {
        const result = this.api.appCustomProductPagesUpdateInstance(id, appCustomProductPageUpdateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableAppEncryptionDeclarationDocumentsApi } from './ObservableAPI.ts';

import { AppEncryptionDeclarationDocumentsApiRequestFactory, AppEncryptionDeclarationDocumentsApiResponseProcessor} from "../apis/AppEncryptionDeclarationDocumentsApi.ts";
export class PromiseAppEncryptionDeclarationDocumentsApi {
    private api: ObservableAppEncryptionDeclarationDocumentsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: AppEncryptionDeclarationDocumentsApiRequestFactory,
        responseProcessor?: AppEncryptionDeclarationDocumentsApiResponseProcessor
    ) {
        this.api = new ObservableAppEncryptionDeclarationDocumentsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param appEncryptionDeclarationDocumentCreateRequest AppEncryptionDeclarationDocument representation
     */
    public appEncryptionDeclarationDocumentsCreateInstanceWithHttpInfo(appEncryptionDeclarationDocumentCreateRequest: AppEncryptionDeclarationDocumentCreateRequest, _options?: Configuration): Promise<HttpInfo<AppEncryptionDeclarationDocumentResponse>> {
        const result = this.api.appEncryptionDeclarationDocumentsCreateInstanceWithHttpInfo(appEncryptionDeclarationDocumentCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param appEncryptionDeclarationDocumentCreateRequest AppEncryptionDeclarationDocument representation
     */
    public appEncryptionDeclarationDocumentsCreateInstance(appEncryptionDeclarationDocumentCreateRequest: AppEncryptionDeclarationDocumentCreateRequest, _options?: Configuration): Promise<AppEncryptionDeclarationDocumentResponse> {
        const result = this.api.appEncryptionDeclarationDocumentsCreateInstance(appEncryptionDeclarationDocumentCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppEncryptionDeclarationDocuments the fields to include for returned resources of type appEncryptionDeclarationDocuments
     */
    public appEncryptionDeclarationDocumentsGetInstanceWithHttpInfo(id: string, fieldsAppEncryptionDeclarationDocuments?: Array<'appEncryptionDeclaration' | 'assetDeliveryState' | 'assetToken' | 'downloadUrl' | 'fileName' | 'fileSize' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, _options?: Configuration): Promise<HttpInfo<AppEncryptionDeclarationDocumentResponse>> {
        const result = this.api.appEncryptionDeclarationDocumentsGetInstanceWithHttpInfo(id, fieldsAppEncryptionDeclarationDocuments, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppEncryptionDeclarationDocuments the fields to include for returned resources of type appEncryptionDeclarationDocuments
     */
    public appEncryptionDeclarationDocumentsGetInstance(id: string, fieldsAppEncryptionDeclarationDocuments?: Array<'appEncryptionDeclaration' | 'assetDeliveryState' | 'assetToken' | 'downloadUrl' | 'fileName' | 'fileSize' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, _options?: Configuration): Promise<AppEncryptionDeclarationDocumentResponse> {
        const result = this.api.appEncryptionDeclarationDocumentsGetInstance(id, fieldsAppEncryptionDeclarationDocuments, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param appEncryptionDeclarationDocumentUpdateRequest AppEncryptionDeclarationDocument representation
     */
    public appEncryptionDeclarationDocumentsUpdateInstanceWithHttpInfo(id: string, appEncryptionDeclarationDocumentUpdateRequest: AppEncryptionDeclarationDocumentUpdateRequest, _options?: Configuration): Promise<HttpInfo<AppEncryptionDeclarationDocumentResponse>> {
        const result = this.api.appEncryptionDeclarationDocumentsUpdateInstanceWithHttpInfo(id, appEncryptionDeclarationDocumentUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param appEncryptionDeclarationDocumentUpdateRequest AppEncryptionDeclarationDocument representation
     */
    public appEncryptionDeclarationDocumentsUpdateInstance(id: string, appEncryptionDeclarationDocumentUpdateRequest: AppEncryptionDeclarationDocumentUpdateRequest, _options?: Configuration): Promise<AppEncryptionDeclarationDocumentResponse> {
        const result = this.api.appEncryptionDeclarationDocumentsUpdateInstance(id, appEncryptionDeclarationDocumentUpdateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableAppEncryptionDeclarationsApi } from './ObservableAPI.ts';

import { AppEncryptionDeclarationsApiRequestFactory, AppEncryptionDeclarationsApiResponseProcessor} from "../apis/AppEncryptionDeclarationsApi.ts";
export class PromiseAppEncryptionDeclarationsApi {
    private api: ObservableAppEncryptionDeclarationsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: AppEncryptionDeclarationsApiRequestFactory,
        responseProcessor?: AppEncryptionDeclarationsApiResponseProcessor
    ) {
        this.api = new ObservableAppEncryptionDeclarationsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppEncryptionDeclarationDocuments the fields to include for returned resources of type appEncryptionDeclarationDocuments
     */
    public appEncryptionDeclarationsAppEncryptionDeclarationDocumentGetToOneRelatedWithHttpInfo(id: string, fieldsAppEncryptionDeclarationDocuments?: Array<'appEncryptionDeclaration' | 'assetDeliveryState' | 'assetToken' | 'downloadUrl' | 'fileName' | 'fileSize' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, _options?: Configuration): Promise<HttpInfo<AppEncryptionDeclarationDocumentResponse>> {
        const result = this.api.appEncryptionDeclarationsAppEncryptionDeclarationDocumentGetToOneRelatedWithHttpInfo(id, fieldsAppEncryptionDeclarationDocuments, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppEncryptionDeclarationDocuments the fields to include for returned resources of type appEncryptionDeclarationDocuments
     */
    public appEncryptionDeclarationsAppEncryptionDeclarationDocumentGetToOneRelated(id: string, fieldsAppEncryptionDeclarationDocuments?: Array<'appEncryptionDeclaration' | 'assetDeliveryState' | 'assetToken' | 'downloadUrl' | 'fileName' | 'fileSize' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, _options?: Configuration): Promise<AppEncryptionDeclarationDocumentResponse> {
        const result = this.api.appEncryptionDeclarationsAppEncryptionDeclarationDocumentGetToOneRelated(id, fieldsAppEncryptionDeclarationDocuments, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsApps the fields to include for returned resources of type apps
     */
    public appEncryptionDeclarationsAppGetToOneRelatedWithHttpInfo(id: string, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, _options?: Configuration): Promise<HttpInfo<AppWithoutIncludesResponse>> {
        const result = this.api.appEncryptionDeclarationsAppGetToOneRelatedWithHttpInfo(id, fieldsApps, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsApps the fields to include for returned resources of type apps
     */
    public appEncryptionDeclarationsAppGetToOneRelated(id: string, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, _options?: Configuration): Promise<AppWithoutIncludesResponse> {
        const result = this.api.appEncryptionDeclarationsAppGetToOneRelated(id, fieldsApps, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param appEncryptionDeclarationBuildsLinkagesRequest List of related linkages
     */
    public appEncryptionDeclarationsBuildsCreateToManyRelationshipWithHttpInfo(id: string, appEncryptionDeclarationBuildsLinkagesRequest: AppEncryptionDeclarationBuildsLinkagesRequest, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.appEncryptionDeclarationsBuildsCreateToManyRelationshipWithHttpInfo(id, appEncryptionDeclarationBuildsLinkagesRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param appEncryptionDeclarationBuildsLinkagesRequest List of related linkages
     */
    public appEncryptionDeclarationsBuildsCreateToManyRelationship(id: string, appEncryptionDeclarationBuildsLinkagesRequest: AppEncryptionDeclarationBuildsLinkagesRequest, _options?: Configuration): Promise<void> {
        const result = this.api.appEncryptionDeclarationsBuildsCreateToManyRelationship(id, appEncryptionDeclarationBuildsLinkagesRequest, _options);
        return result.toPromise();
    }

    /**
     * @param filterPlatform filter by attribute \&#39;platform\&#39;
     * @param filterApp filter by id(s) of related \&#39;app\&#39;
     * @param filterBuilds filter by id(s) of related \&#39;builds\&#39;
     * @param fieldsAppEncryptionDeclarations the fields to include for returned resources of type appEncryptionDeclarations
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsAppEncryptionDeclarationDocuments the fields to include for returned resources of type appEncryptionDeclarationDocuments
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param limitBuilds maximum number of related builds returned (when they are included)
     */
    public appEncryptionDeclarationsGetCollectionWithHttpInfo(filterPlatform?: Array<'IOS' | 'MAC_OS' | 'TV_OS' | 'VISION_OS'>, filterApp?: Array<string>, filterBuilds?: Array<string>, fieldsAppEncryptionDeclarations?: Array<'app' | 'appDescription' | 'appEncryptionDeclarationDocument' | 'appEncryptionDeclarationState' | 'availableOnFrenchStore' | 'builds' | 'codeValue' | 'containsProprietaryCryptography' | 'containsThirdPartyCryptography' | 'createdDate' | 'documentName' | 'documentType' | 'documentUrl' | 'exempt' | 'platform' | 'uploadedDate' | 'usesEncryption'>, limit?: number, include?: Array<'app' | 'appEncryptionDeclarationDocument' | 'builds'>, fieldsAppEncryptionDeclarationDocuments?: Array<'appEncryptionDeclaration' | 'assetDeliveryState' | 'assetToken' | 'downloadUrl' | 'fileName' | 'fileSize' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, limitBuilds?: number, _options?: Configuration): Promise<HttpInfo<AppEncryptionDeclarationsResponse>> {
        const result = this.api.appEncryptionDeclarationsGetCollectionWithHttpInfo(filterPlatform, filterApp, filterBuilds, fieldsAppEncryptionDeclarations, limit, include, fieldsAppEncryptionDeclarationDocuments, fieldsApps, limitBuilds, _options);
        return result.toPromise();
    }

    /**
     * @param filterPlatform filter by attribute \&#39;platform\&#39;
     * @param filterApp filter by id(s) of related \&#39;app\&#39;
     * @param filterBuilds filter by id(s) of related \&#39;builds\&#39;
     * @param fieldsAppEncryptionDeclarations the fields to include for returned resources of type appEncryptionDeclarations
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsAppEncryptionDeclarationDocuments the fields to include for returned resources of type appEncryptionDeclarationDocuments
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param limitBuilds maximum number of related builds returned (when they are included)
     */
    public appEncryptionDeclarationsGetCollection(filterPlatform?: Array<'IOS' | 'MAC_OS' | 'TV_OS' | 'VISION_OS'>, filterApp?: Array<string>, filterBuilds?: Array<string>, fieldsAppEncryptionDeclarations?: Array<'app' | 'appDescription' | 'appEncryptionDeclarationDocument' | 'appEncryptionDeclarationState' | 'availableOnFrenchStore' | 'builds' | 'codeValue' | 'containsProprietaryCryptography' | 'containsThirdPartyCryptography' | 'createdDate' | 'documentName' | 'documentType' | 'documentUrl' | 'exempt' | 'platform' | 'uploadedDate' | 'usesEncryption'>, limit?: number, include?: Array<'app' | 'appEncryptionDeclarationDocument' | 'builds'>, fieldsAppEncryptionDeclarationDocuments?: Array<'appEncryptionDeclaration' | 'assetDeliveryState' | 'assetToken' | 'downloadUrl' | 'fileName' | 'fileSize' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, limitBuilds?: number, _options?: Configuration): Promise<AppEncryptionDeclarationsResponse> {
        const result = this.api.appEncryptionDeclarationsGetCollection(filterPlatform, filterApp, filterBuilds, fieldsAppEncryptionDeclarations, limit, include, fieldsAppEncryptionDeclarationDocuments, fieldsApps, limitBuilds, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppEncryptionDeclarations the fields to include for returned resources of type appEncryptionDeclarations
     * @param include comma-separated list of relationships to include
     * @param fieldsAppEncryptionDeclarationDocuments the fields to include for returned resources of type appEncryptionDeclarationDocuments
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param limitBuilds maximum number of related builds returned (when they are included)
     */
    public appEncryptionDeclarationsGetInstanceWithHttpInfo(id: string, fieldsAppEncryptionDeclarations?: Array<'app' | 'appDescription' | 'appEncryptionDeclarationDocument' | 'appEncryptionDeclarationState' | 'availableOnFrenchStore' | 'builds' | 'codeValue' | 'containsProprietaryCryptography' | 'containsThirdPartyCryptography' | 'createdDate' | 'documentName' | 'documentType' | 'documentUrl' | 'exempt' | 'platform' | 'uploadedDate' | 'usesEncryption'>, include?: Array<'app' | 'appEncryptionDeclarationDocument' | 'builds'>, fieldsAppEncryptionDeclarationDocuments?: Array<'appEncryptionDeclaration' | 'assetDeliveryState' | 'assetToken' | 'downloadUrl' | 'fileName' | 'fileSize' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, limitBuilds?: number, _options?: Configuration): Promise<HttpInfo<AppEncryptionDeclarationResponse>> {
        const result = this.api.appEncryptionDeclarationsGetInstanceWithHttpInfo(id, fieldsAppEncryptionDeclarations, include, fieldsAppEncryptionDeclarationDocuments, fieldsApps, limitBuilds, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppEncryptionDeclarations the fields to include for returned resources of type appEncryptionDeclarations
     * @param include comma-separated list of relationships to include
     * @param fieldsAppEncryptionDeclarationDocuments the fields to include for returned resources of type appEncryptionDeclarationDocuments
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param limitBuilds maximum number of related builds returned (when they are included)
     */
    public appEncryptionDeclarationsGetInstance(id: string, fieldsAppEncryptionDeclarations?: Array<'app' | 'appDescription' | 'appEncryptionDeclarationDocument' | 'appEncryptionDeclarationState' | 'availableOnFrenchStore' | 'builds' | 'codeValue' | 'containsProprietaryCryptography' | 'containsThirdPartyCryptography' | 'createdDate' | 'documentName' | 'documentType' | 'documentUrl' | 'exempt' | 'platform' | 'uploadedDate' | 'usesEncryption'>, include?: Array<'app' | 'appEncryptionDeclarationDocument' | 'builds'>, fieldsAppEncryptionDeclarationDocuments?: Array<'appEncryptionDeclaration' | 'assetDeliveryState' | 'assetToken' | 'downloadUrl' | 'fileName' | 'fileSize' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, limitBuilds?: number, _options?: Configuration): Promise<AppEncryptionDeclarationResponse> {
        const result = this.api.appEncryptionDeclarationsGetInstance(id, fieldsAppEncryptionDeclarations, include, fieldsAppEncryptionDeclarationDocuments, fieldsApps, limitBuilds, _options);
        return result.toPromise();
    }


}



import { ObservableAppEventLocalizationsApi } from './ObservableAPI.ts';

import { AppEventLocalizationsApiRequestFactory, AppEventLocalizationsApiResponseProcessor} from "../apis/AppEventLocalizationsApi.ts";
export class PromiseAppEventLocalizationsApi {
    private api: ObservableAppEventLocalizationsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: AppEventLocalizationsApiRequestFactory,
        responseProcessor?: AppEventLocalizationsApiResponseProcessor
    ) {
        this.api = new ObservableAppEventLocalizationsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppEventScreenshots the fields to include for returned resources of type appEventScreenshots
     * @param fieldsAppEventLocalizations the fields to include for returned resources of type appEventLocalizations
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public appEventLocalizationsAppEventScreenshotsGetToManyRelatedWithHttpInfo(id: string, fieldsAppEventScreenshots?: Array<'appEventAssetType' | 'appEventLocalization' | 'assetDeliveryState' | 'assetToken' | 'fileName' | 'fileSize' | 'imageAsset' | 'uploadOperations' | 'uploaded'>, fieldsAppEventLocalizations?: Array<'appEvent' | 'appEventScreenshots' | 'appEventVideoClips' | 'locale' | 'longDescription' | 'name' | 'shortDescription'>, limit?: number, include?: Array<'appEventLocalization'>, _options?: Configuration): Promise<HttpInfo<AppEventScreenshotsResponse>> {
        const result = this.api.appEventLocalizationsAppEventScreenshotsGetToManyRelatedWithHttpInfo(id, fieldsAppEventScreenshots, fieldsAppEventLocalizations, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppEventScreenshots the fields to include for returned resources of type appEventScreenshots
     * @param fieldsAppEventLocalizations the fields to include for returned resources of type appEventLocalizations
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public appEventLocalizationsAppEventScreenshotsGetToManyRelated(id: string, fieldsAppEventScreenshots?: Array<'appEventAssetType' | 'appEventLocalization' | 'assetDeliveryState' | 'assetToken' | 'fileName' | 'fileSize' | 'imageAsset' | 'uploadOperations' | 'uploaded'>, fieldsAppEventLocalizations?: Array<'appEvent' | 'appEventScreenshots' | 'appEventVideoClips' | 'locale' | 'longDescription' | 'name' | 'shortDescription'>, limit?: number, include?: Array<'appEventLocalization'>, _options?: Configuration): Promise<AppEventScreenshotsResponse> {
        const result = this.api.appEventLocalizationsAppEventScreenshotsGetToManyRelated(id, fieldsAppEventScreenshots, fieldsAppEventLocalizations, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppEventVideoClips the fields to include for returned resources of type appEventVideoClips
     * @param fieldsAppEventLocalizations the fields to include for returned resources of type appEventLocalizations
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public appEventLocalizationsAppEventVideoClipsGetToManyRelatedWithHttpInfo(id: string, fieldsAppEventVideoClips?: Array<'appEventAssetType' | 'appEventLocalization' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'previewFrameTimeCode' | 'previewImage' | 'uploadOperations' | 'uploaded' | 'videoUrl'>, fieldsAppEventLocalizations?: Array<'appEvent' | 'appEventScreenshots' | 'appEventVideoClips' | 'locale' | 'longDescription' | 'name' | 'shortDescription'>, limit?: number, include?: Array<'appEventLocalization'>, _options?: Configuration): Promise<HttpInfo<AppEventVideoClipsResponse>> {
        const result = this.api.appEventLocalizationsAppEventVideoClipsGetToManyRelatedWithHttpInfo(id, fieldsAppEventVideoClips, fieldsAppEventLocalizations, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppEventVideoClips the fields to include for returned resources of type appEventVideoClips
     * @param fieldsAppEventLocalizations the fields to include for returned resources of type appEventLocalizations
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public appEventLocalizationsAppEventVideoClipsGetToManyRelated(id: string, fieldsAppEventVideoClips?: Array<'appEventAssetType' | 'appEventLocalization' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'previewFrameTimeCode' | 'previewImage' | 'uploadOperations' | 'uploaded' | 'videoUrl'>, fieldsAppEventLocalizations?: Array<'appEvent' | 'appEventScreenshots' | 'appEventVideoClips' | 'locale' | 'longDescription' | 'name' | 'shortDescription'>, limit?: number, include?: Array<'appEventLocalization'>, _options?: Configuration): Promise<AppEventVideoClipsResponse> {
        const result = this.api.appEventLocalizationsAppEventVideoClipsGetToManyRelated(id, fieldsAppEventVideoClips, fieldsAppEventLocalizations, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param appEventLocalizationCreateRequest AppEventLocalization representation
     */
    public appEventLocalizationsCreateInstanceWithHttpInfo(appEventLocalizationCreateRequest: AppEventLocalizationCreateRequest, _options?: Configuration): Promise<HttpInfo<AppEventLocalizationResponse>> {
        const result = this.api.appEventLocalizationsCreateInstanceWithHttpInfo(appEventLocalizationCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param appEventLocalizationCreateRequest AppEventLocalization representation
     */
    public appEventLocalizationsCreateInstance(appEventLocalizationCreateRequest: AppEventLocalizationCreateRequest, _options?: Configuration): Promise<AppEventLocalizationResponse> {
        const result = this.api.appEventLocalizationsCreateInstance(appEventLocalizationCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public appEventLocalizationsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.appEventLocalizationsDeleteInstanceWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public appEventLocalizationsDeleteInstance(id: string, _options?: Configuration): Promise<void> {
        const result = this.api.appEventLocalizationsDeleteInstance(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppEventLocalizations the fields to include for returned resources of type appEventLocalizations
     * @param include comma-separated list of relationships to include
     * @param fieldsAppEventScreenshots the fields to include for returned resources of type appEventScreenshots
     * @param fieldsAppEventVideoClips the fields to include for returned resources of type appEventVideoClips
     * @param limitAppEventScreenshots maximum number of related appEventScreenshots returned (when they are included)
     * @param limitAppEventVideoClips maximum number of related appEventVideoClips returned (when they are included)
     */
    public appEventLocalizationsGetInstanceWithHttpInfo(id: string, fieldsAppEventLocalizations?: Array<'appEvent' | 'appEventScreenshots' | 'appEventVideoClips' | 'locale' | 'longDescription' | 'name' | 'shortDescription'>, include?: Array<'appEvent' | 'appEventScreenshots' | 'appEventVideoClips'>, fieldsAppEventScreenshots?: Array<'appEventAssetType' | 'appEventLocalization' | 'assetDeliveryState' | 'assetToken' | 'fileName' | 'fileSize' | 'imageAsset' | 'uploadOperations' | 'uploaded'>, fieldsAppEventVideoClips?: Array<'appEventAssetType' | 'appEventLocalization' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'previewFrameTimeCode' | 'previewImage' | 'uploadOperations' | 'uploaded' | 'videoUrl'>, limitAppEventScreenshots?: number, limitAppEventVideoClips?: number, _options?: Configuration): Promise<HttpInfo<AppEventLocalizationResponse>> {
        const result = this.api.appEventLocalizationsGetInstanceWithHttpInfo(id, fieldsAppEventLocalizations, include, fieldsAppEventScreenshots, fieldsAppEventVideoClips, limitAppEventScreenshots, limitAppEventVideoClips, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppEventLocalizations the fields to include for returned resources of type appEventLocalizations
     * @param include comma-separated list of relationships to include
     * @param fieldsAppEventScreenshots the fields to include for returned resources of type appEventScreenshots
     * @param fieldsAppEventVideoClips the fields to include for returned resources of type appEventVideoClips
     * @param limitAppEventScreenshots maximum number of related appEventScreenshots returned (when they are included)
     * @param limitAppEventVideoClips maximum number of related appEventVideoClips returned (when they are included)
     */
    public appEventLocalizationsGetInstance(id: string, fieldsAppEventLocalizations?: Array<'appEvent' | 'appEventScreenshots' | 'appEventVideoClips' | 'locale' | 'longDescription' | 'name' | 'shortDescription'>, include?: Array<'appEvent' | 'appEventScreenshots' | 'appEventVideoClips'>, fieldsAppEventScreenshots?: Array<'appEventAssetType' | 'appEventLocalization' | 'assetDeliveryState' | 'assetToken' | 'fileName' | 'fileSize' | 'imageAsset' | 'uploadOperations' | 'uploaded'>, fieldsAppEventVideoClips?: Array<'appEventAssetType' | 'appEventLocalization' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'previewFrameTimeCode' | 'previewImage' | 'uploadOperations' | 'uploaded' | 'videoUrl'>, limitAppEventScreenshots?: number, limitAppEventVideoClips?: number, _options?: Configuration): Promise<AppEventLocalizationResponse> {
        const result = this.api.appEventLocalizationsGetInstance(id, fieldsAppEventLocalizations, include, fieldsAppEventScreenshots, fieldsAppEventVideoClips, limitAppEventScreenshots, limitAppEventVideoClips, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param appEventLocalizationUpdateRequest AppEventLocalization representation
     */
    public appEventLocalizationsUpdateInstanceWithHttpInfo(id: string, appEventLocalizationUpdateRequest: AppEventLocalizationUpdateRequest, _options?: Configuration): Promise<HttpInfo<AppEventLocalizationResponse>> {
        const result = this.api.appEventLocalizationsUpdateInstanceWithHttpInfo(id, appEventLocalizationUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param appEventLocalizationUpdateRequest AppEventLocalization representation
     */
    public appEventLocalizationsUpdateInstance(id: string, appEventLocalizationUpdateRequest: AppEventLocalizationUpdateRequest, _options?: Configuration): Promise<AppEventLocalizationResponse> {
        const result = this.api.appEventLocalizationsUpdateInstance(id, appEventLocalizationUpdateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableAppEventScreenshotsApi } from './ObservableAPI.ts';

import { AppEventScreenshotsApiRequestFactory, AppEventScreenshotsApiResponseProcessor} from "../apis/AppEventScreenshotsApi.ts";
export class PromiseAppEventScreenshotsApi {
    private api: ObservableAppEventScreenshotsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: AppEventScreenshotsApiRequestFactory,
        responseProcessor?: AppEventScreenshotsApiResponseProcessor
    ) {
        this.api = new ObservableAppEventScreenshotsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param appEventScreenshotCreateRequest AppEventScreenshot representation
     */
    public appEventScreenshotsCreateInstanceWithHttpInfo(appEventScreenshotCreateRequest: AppEventScreenshotCreateRequest, _options?: Configuration): Promise<HttpInfo<AppEventScreenshotResponse>> {
        const result = this.api.appEventScreenshotsCreateInstanceWithHttpInfo(appEventScreenshotCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param appEventScreenshotCreateRequest AppEventScreenshot representation
     */
    public appEventScreenshotsCreateInstance(appEventScreenshotCreateRequest: AppEventScreenshotCreateRequest, _options?: Configuration): Promise<AppEventScreenshotResponse> {
        const result = this.api.appEventScreenshotsCreateInstance(appEventScreenshotCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public appEventScreenshotsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.appEventScreenshotsDeleteInstanceWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public appEventScreenshotsDeleteInstance(id: string, _options?: Configuration): Promise<void> {
        const result = this.api.appEventScreenshotsDeleteInstance(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppEventScreenshots the fields to include for returned resources of type appEventScreenshots
     * @param include comma-separated list of relationships to include
     */
    public appEventScreenshotsGetInstanceWithHttpInfo(id: string, fieldsAppEventScreenshots?: Array<'appEventAssetType' | 'appEventLocalization' | 'assetDeliveryState' | 'assetToken' | 'fileName' | 'fileSize' | 'imageAsset' | 'uploadOperations' | 'uploaded'>, include?: Array<'appEventLocalization'>, _options?: Configuration): Promise<HttpInfo<AppEventScreenshotResponse>> {
        const result = this.api.appEventScreenshotsGetInstanceWithHttpInfo(id, fieldsAppEventScreenshots, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppEventScreenshots the fields to include for returned resources of type appEventScreenshots
     * @param include comma-separated list of relationships to include
     */
    public appEventScreenshotsGetInstance(id: string, fieldsAppEventScreenshots?: Array<'appEventAssetType' | 'appEventLocalization' | 'assetDeliveryState' | 'assetToken' | 'fileName' | 'fileSize' | 'imageAsset' | 'uploadOperations' | 'uploaded'>, include?: Array<'appEventLocalization'>, _options?: Configuration): Promise<AppEventScreenshotResponse> {
        const result = this.api.appEventScreenshotsGetInstance(id, fieldsAppEventScreenshots, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param appEventScreenshotUpdateRequest AppEventScreenshot representation
     */
    public appEventScreenshotsUpdateInstanceWithHttpInfo(id: string, appEventScreenshotUpdateRequest: AppEventScreenshotUpdateRequest, _options?: Configuration): Promise<HttpInfo<AppEventScreenshotResponse>> {
        const result = this.api.appEventScreenshotsUpdateInstanceWithHttpInfo(id, appEventScreenshotUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param appEventScreenshotUpdateRequest AppEventScreenshot representation
     */
    public appEventScreenshotsUpdateInstance(id: string, appEventScreenshotUpdateRequest: AppEventScreenshotUpdateRequest, _options?: Configuration): Promise<AppEventScreenshotResponse> {
        const result = this.api.appEventScreenshotsUpdateInstance(id, appEventScreenshotUpdateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableAppEventVideoClipsApi } from './ObservableAPI.ts';

import { AppEventVideoClipsApiRequestFactory, AppEventVideoClipsApiResponseProcessor} from "../apis/AppEventVideoClipsApi.ts";
export class PromiseAppEventVideoClipsApi {
    private api: ObservableAppEventVideoClipsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: AppEventVideoClipsApiRequestFactory,
        responseProcessor?: AppEventVideoClipsApiResponseProcessor
    ) {
        this.api = new ObservableAppEventVideoClipsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param appEventVideoClipCreateRequest AppEventVideoClip representation
     */
    public appEventVideoClipsCreateInstanceWithHttpInfo(appEventVideoClipCreateRequest: AppEventVideoClipCreateRequest, _options?: Configuration): Promise<HttpInfo<AppEventVideoClipResponse>> {
        const result = this.api.appEventVideoClipsCreateInstanceWithHttpInfo(appEventVideoClipCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param appEventVideoClipCreateRequest AppEventVideoClip representation
     */
    public appEventVideoClipsCreateInstance(appEventVideoClipCreateRequest: AppEventVideoClipCreateRequest, _options?: Configuration): Promise<AppEventVideoClipResponse> {
        const result = this.api.appEventVideoClipsCreateInstance(appEventVideoClipCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public appEventVideoClipsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.appEventVideoClipsDeleteInstanceWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public appEventVideoClipsDeleteInstance(id: string, _options?: Configuration): Promise<void> {
        const result = this.api.appEventVideoClipsDeleteInstance(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppEventVideoClips the fields to include for returned resources of type appEventVideoClips
     * @param include comma-separated list of relationships to include
     */
    public appEventVideoClipsGetInstanceWithHttpInfo(id: string, fieldsAppEventVideoClips?: Array<'appEventAssetType' | 'appEventLocalization' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'previewFrameTimeCode' | 'previewImage' | 'uploadOperations' | 'uploaded' | 'videoUrl'>, include?: Array<'appEventLocalization'>, _options?: Configuration): Promise<HttpInfo<AppEventVideoClipResponse>> {
        const result = this.api.appEventVideoClipsGetInstanceWithHttpInfo(id, fieldsAppEventVideoClips, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppEventVideoClips the fields to include for returned resources of type appEventVideoClips
     * @param include comma-separated list of relationships to include
     */
    public appEventVideoClipsGetInstance(id: string, fieldsAppEventVideoClips?: Array<'appEventAssetType' | 'appEventLocalization' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'previewFrameTimeCode' | 'previewImage' | 'uploadOperations' | 'uploaded' | 'videoUrl'>, include?: Array<'appEventLocalization'>, _options?: Configuration): Promise<AppEventVideoClipResponse> {
        const result = this.api.appEventVideoClipsGetInstance(id, fieldsAppEventVideoClips, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param appEventVideoClipUpdateRequest AppEventVideoClip representation
     */
    public appEventVideoClipsUpdateInstanceWithHttpInfo(id: string, appEventVideoClipUpdateRequest: AppEventVideoClipUpdateRequest, _options?: Configuration): Promise<HttpInfo<AppEventVideoClipResponse>> {
        const result = this.api.appEventVideoClipsUpdateInstanceWithHttpInfo(id, appEventVideoClipUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param appEventVideoClipUpdateRequest AppEventVideoClip representation
     */
    public appEventVideoClipsUpdateInstance(id: string, appEventVideoClipUpdateRequest: AppEventVideoClipUpdateRequest, _options?: Configuration): Promise<AppEventVideoClipResponse> {
        const result = this.api.appEventVideoClipsUpdateInstance(id, appEventVideoClipUpdateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableAppEventsApi } from './ObservableAPI.ts';

import { AppEventsApiRequestFactory, AppEventsApiResponseProcessor} from "../apis/AppEventsApi.ts";
export class PromiseAppEventsApi {
    private api: ObservableAppEventsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: AppEventsApiRequestFactory,
        responseProcessor?: AppEventsApiResponseProcessor
    ) {
        this.api = new ObservableAppEventsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param appEventCreateRequest AppEvent representation
     */
    public appEventsCreateInstanceWithHttpInfo(appEventCreateRequest: AppEventCreateRequest, _options?: Configuration): Promise<HttpInfo<AppEventResponse>> {
        const result = this.api.appEventsCreateInstanceWithHttpInfo(appEventCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param appEventCreateRequest AppEvent representation
     */
    public appEventsCreateInstance(appEventCreateRequest: AppEventCreateRequest, _options?: Configuration): Promise<AppEventResponse> {
        const result = this.api.appEventsCreateInstance(appEventCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public appEventsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.appEventsDeleteInstanceWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public appEventsDeleteInstance(id: string, _options?: Configuration): Promise<void> {
        const result = this.api.appEventsDeleteInstance(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppEvents the fields to include for returned resources of type appEvents
     * @param include comma-separated list of relationships to include
     * @param fieldsAppEventLocalizations the fields to include for returned resources of type appEventLocalizations
     * @param limitLocalizations maximum number of related localizations returned (when they are included)
     */
    public appEventsGetInstanceWithHttpInfo(id: string, fieldsAppEvents?: Array<'app' | 'archivedTerritorySchedules' | 'badge' | 'deepLink' | 'eventState' | 'localizations' | 'primaryLocale' | 'priority' | 'purchaseRequirement' | 'purpose' | 'referenceName' | 'territorySchedules'>, include?: Array<'localizations'>, fieldsAppEventLocalizations?: Array<'appEvent' | 'appEventScreenshots' | 'appEventVideoClips' | 'locale' | 'longDescription' | 'name' | 'shortDescription'>, limitLocalizations?: number, _options?: Configuration): Promise<HttpInfo<AppEventResponse>> {
        const result = this.api.appEventsGetInstanceWithHttpInfo(id, fieldsAppEvents, include, fieldsAppEventLocalizations, limitLocalizations, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppEvents the fields to include for returned resources of type appEvents
     * @param include comma-separated list of relationships to include
     * @param fieldsAppEventLocalizations the fields to include for returned resources of type appEventLocalizations
     * @param limitLocalizations maximum number of related localizations returned (when they are included)
     */
    public appEventsGetInstance(id: string, fieldsAppEvents?: Array<'app' | 'archivedTerritorySchedules' | 'badge' | 'deepLink' | 'eventState' | 'localizations' | 'primaryLocale' | 'priority' | 'purchaseRequirement' | 'purpose' | 'referenceName' | 'territorySchedules'>, include?: Array<'localizations'>, fieldsAppEventLocalizations?: Array<'appEvent' | 'appEventScreenshots' | 'appEventVideoClips' | 'locale' | 'longDescription' | 'name' | 'shortDescription'>, limitLocalizations?: number, _options?: Configuration): Promise<AppEventResponse> {
        const result = this.api.appEventsGetInstance(id, fieldsAppEvents, include, fieldsAppEventLocalizations, limitLocalizations, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppEventScreenshots the fields to include for returned resources of type appEventScreenshots
     * @param fieldsAppEventVideoClips the fields to include for returned resources of type appEventVideoClips
     * @param fieldsAppEventLocalizations the fields to include for returned resources of type appEventLocalizations
     * @param fieldsAppEvents the fields to include for returned resources of type appEvents
     * @param limit maximum resources per page
     * @param limitAppEventScreenshots maximum number of related appEventScreenshots returned (when they are included)
     * @param limitAppEventVideoClips maximum number of related appEventVideoClips returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appEventsLocalizationsGetToManyRelatedWithHttpInfo(id: string, fieldsAppEventScreenshots?: Array<'appEventAssetType' | 'appEventLocalization' | 'assetDeliveryState' | 'assetToken' | 'fileName' | 'fileSize' | 'imageAsset' | 'uploadOperations' | 'uploaded'>, fieldsAppEventVideoClips?: Array<'appEventAssetType' | 'appEventLocalization' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'previewFrameTimeCode' | 'previewImage' | 'uploadOperations' | 'uploaded' | 'videoUrl'>, fieldsAppEventLocalizations?: Array<'appEvent' | 'appEventScreenshots' | 'appEventVideoClips' | 'locale' | 'longDescription' | 'name' | 'shortDescription'>, fieldsAppEvents?: Array<'app' | 'archivedTerritorySchedules' | 'badge' | 'deepLink' | 'eventState' | 'localizations' | 'primaryLocale' | 'priority' | 'purchaseRequirement' | 'purpose' | 'referenceName' | 'territorySchedules'>, limit?: number, limitAppEventScreenshots?: number, limitAppEventVideoClips?: number, include?: Array<'appEvent' | 'appEventScreenshots' | 'appEventVideoClips'>, _options?: Configuration): Promise<HttpInfo<AppEventLocalizationsResponse>> {
        const result = this.api.appEventsLocalizationsGetToManyRelatedWithHttpInfo(id, fieldsAppEventScreenshots, fieldsAppEventVideoClips, fieldsAppEventLocalizations, fieldsAppEvents, limit, limitAppEventScreenshots, limitAppEventVideoClips, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppEventScreenshots the fields to include for returned resources of type appEventScreenshots
     * @param fieldsAppEventVideoClips the fields to include for returned resources of type appEventVideoClips
     * @param fieldsAppEventLocalizations the fields to include for returned resources of type appEventLocalizations
     * @param fieldsAppEvents the fields to include for returned resources of type appEvents
     * @param limit maximum resources per page
     * @param limitAppEventScreenshots maximum number of related appEventScreenshots returned (when they are included)
     * @param limitAppEventVideoClips maximum number of related appEventVideoClips returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appEventsLocalizationsGetToManyRelated(id: string, fieldsAppEventScreenshots?: Array<'appEventAssetType' | 'appEventLocalization' | 'assetDeliveryState' | 'assetToken' | 'fileName' | 'fileSize' | 'imageAsset' | 'uploadOperations' | 'uploaded'>, fieldsAppEventVideoClips?: Array<'appEventAssetType' | 'appEventLocalization' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'previewFrameTimeCode' | 'previewImage' | 'uploadOperations' | 'uploaded' | 'videoUrl'>, fieldsAppEventLocalizations?: Array<'appEvent' | 'appEventScreenshots' | 'appEventVideoClips' | 'locale' | 'longDescription' | 'name' | 'shortDescription'>, fieldsAppEvents?: Array<'app' | 'archivedTerritorySchedules' | 'badge' | 'deepLink' | 'eventState' | 'localizations' | 'primaryLocale' | 'priority' | 'purchaseRequirement' | 'purpose' | 'referenceName' | 'territorySchedules'>, limit?: number, limitAppEventScreenshots?: number, limitAppEventVideoClips?: number, include?: Array<'appEvent' | 'appEventScreenshots' | 'appEventVideoClips'>, _options?: Configuration): Promise<AppEventLocalizationsResponse> {
        const result = this.api.appEventsLocalizationsGetToManyRelated(id, fieldsAppEventScreenshots, fieldsAppEventVideoClips, fieldsAppEventLocalizations, fieldsAppEvents, limit, limitAppEventScreenshots, limitAppEventVideoClips, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param appEventUpdateRequest AppEvent representation
     */
    public appEventsUpdateInstanceWithHttpInfo(id: string, appEventUpdateRequest: AppEventUpdateRequest, _options?: Configuration): Promise<HttpInfo<AppEventResponse>> {
        const result = this.api.appEventsUpdateInstanceWithHttpInfo(id, appEventUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param appEventUpdateRequest AppEvent representation
     */
    public appEventsUpdateInstance(id: string, appEventUpdateRequest: AppEventUpdateRequest, _options?: Configuration): Promise<AppEventResponse> {
        const result = this.api.appEventsUpdateInstance(id, appEventUpdateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableAppInfoLocalizationsApi } from './ObservableAPI.ts';

import { AppInfoLocalizationsApiRequestFactory, AppInfoLocalizationsApiResponseProcessor} from "../apis/AppInfoLocalizationsApi.ts";
export class PromiseAppInfoLocalizationsApi {
    private api: ObservableAppInfoLocalizationsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: AppInfoLocalizationsApiRequestFactory,
        responseProcessor?: AppInfoLocalizationsApiResponseProcessor
    ) {
        this.api = new ObservableAppInfoLocalizationsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param appInfoLocalizationCreateRequest AppInfoLocalization representation
     */
    public appInfoLocalizationsCreateInstanceWithHttpInfo(appInfoLocalizationCreateRequest: AppInfoLocalizationCreateRequest, _options?: Configuration): Promise<HttpInfo<AppInfoLocalizationResponse>> {
        const result = this.api.appInfoLocalizationsCreateInstanceWithHttpInfo(appInfoLocalizationCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param appInfoLocalizationCreateRequest AppInfoLocalization representation
     */
    public appInfoLocalizationsCreateInstance(appInfoLocalizationCreateRequest: AppInfoLocalizationCreateRequest, _options?: Configuration): Promise<AppInfoLocalizationResponse> {
        const result = this.api.appInfoLocalizationsCreateInstance(appInfoLocalizationCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public appInfoLocalizationsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.appInfoLocalizationsDeleteInstanceWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public appInfoLocalizationsDeleteInstance(id: string, _options?: Configuration): Promise<void> {
        const result = this.api.appInfoLocalizationsDeleteInstance(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppInfoLocalizations the fields to include for returned resources of type appInfoLocalizations
     * @param include comma-separated list of relationships to include
     */
    public appInfoLocalizationsGetInstanceWithHttpInfo(id: string, fieldsAppInfoLocalizations?: Array<'appInfo' | 'locale' | 'name' | 'privacyChoicesUrl' | 'privacyPolicyText' | 'privacyPolicyUrl' | 'subtitle'>, include?: Array<'appInfo'>, _options?: Configuration): Promise<HttpInfo<AppInfoLocalizationResponse>> {
        const result = this.api.appInfoLocalizationsGetInstanceWithHttpInfo(id, fieldsAppInfoLocalizations, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppInfoLocalizations the fields to include for returned resources of type appInfoLocalizations
     * @param include comma-separated list of relationships to include
     */
    public appInfoLocalizationsGetInstance(id: string, fieldsAppInfoLocalizations?: Array<'appInfo' | 'locale' | 'name' | 'privacyChoicesUrl' | 'privacyPolicyText' | 'privacyPolicyUrl' | 'subtitle'>, include?: Array<'appInfo'>, _options?: Configuration): Promise<AppInfoLocalizationResponse> {
        const result = this.api.appInfoLocalizationsGetInstance(id, fieldsAppInfoLocalizations, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param appInfoLocalizationUpdateRequest AppInfoLocalization representation
     */
    public appInfoLocalizationsUpdateInstanceWithHttpInfo(id: string, appInfoLocalizationUpdateRequest: AppInfoLocalizationUpdateRequest, _options?: Configuration): Promise<HttpInfo<AppInfoLocalizationResponse>> {
        const result = this.api.appInfoLocalizationsUpdateInstanceWithHttpInfo(id, appInfoLocalizationUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param appInfoLocalizationUpdateRequest AppInfoLocalization representation
     */
    public appInfoLocalizationsUpdateInstance(id: string, appInfoLocalizationUpdateRequest: AppInfoLocalizationUpdateRequest, _options?: Configuration): Promise<AppInfoLocalizationResponse> {
        const result = this.api.appInfoLocalizationsUpdateInstance(id, appInfoLocalizationUpdateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableAppInfosApi } from './ObservableAPI.ts';

import { AppInfosApiRequestFactory, AppInfosApiResponseProcessor} from "../apis/AppInfosApi.ts";
export class PromiseAppInfosApi {
    private api: ObservableAppInfosApi

    public constructor(
        configuration: Configuration,
        requestFactory?: AppInfosApiRequestFactory,
        responseProcessor?: AppInfosApiResponseProcessor
    ) {
        this.api = new ObservableAppInfosApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAgeRatingDeclarations the fields to include for returned resources of type ageRatingDeclarations
     */
    public appInfosAgeRatingDeclarationGetToOneRelatedWithHttpInfo(id: string, fieldsAgeRatingDeclarations?: Array<'ageRatingOverride' | 'alcoholTobaccoOrDrugUseOrReferences' | 'contests' | 'gambling' | 'gamblingAndContests' | 'gamblingSimulated' | 'horrorOrFearThemes' | 'kidsAgeBand' | 'matureOrSuggestiveThemes' | 'medicalOrTreatmentInformation' | 'profanityOrCrudeHumor' | 'seventeenPlus' | 'sexualContentGraphicAndNudity' | 'sexualContentOrNudity' | 'unrestrictedWebAccess' | 'violenceCartoonOrFantasy' | 'violenceRealistic' | 'violenceRealisticProlongedGraphicOrSadistic'>, _options?: Configuration): Promise<HttpInfo<AgeRatingDeclarationResponse>> {
        const result = this.api.appInfosAgeRatingDeclarationGetToOneRelatedWithHttpInfo(id, fieldsAgeRatingDeclarations, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAgeRatingDeclarations the fields to include for returned resources of type ageRatingDeclarations
     */
    public appInfosAgeRatingDeclarationGetToOneRelated(id: string, fieldsAgeRatingDeclarations?: Array<'ageRatingOverride' | 'alcoholTobaccoOrDrugUseOrReferences' | 'contests' | 'gambling' | 'gamblingAndContests' | 'gamblingSimulated' | 'horrorOrFearThemes' | 'kidsAgeBand' | 'matureOrSuggestiveThemes' | 'medicalOrTreatmentInformation' | 'profanityOrCrudeHumor' | 'seventeenPlus' | 'sexualContentGraphicAndNudity' | 'sexualContentOrNudity' | 'unrestrictedWebAccess' | 'violenceCartoonOrFantasy' | 'violenceRealistic' | 'violenceRealisticProlongedGraphicOrSadistic'>, _options?: Configuration): Promise<AgeRatingDeclarationResponse> {
        const result = this.api.appInfosAgeRatingDeclarationGetToOneRelated(id, fieldsAgeRatingDeclarations, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterLocale filter by attribute \&#39;locale\&#39;
     * @param fieldsAppInfos the fields to include for returned resources of type appInfos
     * @param fieldsAppInfoLocalizations the fields to include for returned resources of type appInfoLocalizations
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public appInfosAppInfoLocalizationsGetToManyRelatedWithHttpInfo(id: string, filterLocale?: Array<string>, fieldsAppInfos?: Array<'ageRatingDeclaration' | 'app' | 'appInfoLocalizations' | 'appStoreAgeRating' | 'appStoreState' | 'brazilAgeRating' | 'brazilAgeRatingV2' | 'kidsAgeBand' | 'primaryCategory' | 'primarySubcategoryOne' | 'primarySubcategoryTwo' | 'secondaryCategory' | 'secondarySubcategoryOne' | 'secondarySubcategoryTwo' | 'state'>, fieldsAppInfoLocalizations?: Array<'appInfo' | 'locale' | 'name' | 'privacyChoicesUrl' | 'privacyPolicyText' | 'privacyPolicyUrl' | 'subtitle'>, limit?: number, include?: Array<'appInfo'>, _options?: Configuration): Promise<HttpInfo<AppInfoLocalizationsResponse>> {
        const result = this.api.appInfosAppInfoLocalizationsGetToManyRelatedWithHttpInfo(id, filterLocale, fieldsAppInfos, fieldsAppInfoLocalizations, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterLocale filter by attribute \&#39;locale\&#39;
     * @param fieldsAppInfos the fields to include for returned resources of type appInfos
     * @param fieldsAppInfoLocalizations the fields to include for returned resources of type appInfoLocalizations
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public appInfosAppInfoLocalizationsGetToManyRelated(id: string, filterLocale?: Array<string>, fieldsAppInfos?: Array<'ageRatingDeclaration' | 'app' | 'appInfoLocalizations' | 'appStoreAgeRating' | 'appStoreState' | 'brazilAgeRating' | 'brazilAgeRatingV2' | 'kidsAgeBand' | 'primaryCategory' | 'primarySubcategoryOne' | 'primarySubcategoryTwo' | 'secondaryCategory' | 'secondarySubcategoryOne' | 'secondarySubcategoryTwo' | 'state'>, fieldsAppInfoLocalizations?: Array<'appInfo' | 'locale' | 'name' | 'privacyChoicesUrl' | 'privacyPolicyText' | 'privacyPolicyUrl' | 'subtitle'>, limit?: number, include?: Array<'appInfo'>, _options?: Configuration): Promise<AppInfoLocalizationsResponse> {
        const result = this.api.appInfosAppInfoLocalizationsGetToManyRelated(id, filterLocale, fieldsAppInfos, fieldsAppInfoLocalizations, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppInfos the fields to include for returned resources of type appInfos
     * @param include comma-separated list of relationships to include
     * @param fieldsAgeRatingDeclarations the fields to include for returned resources of type ageRatingDeclarations
     * @param fieldsAppInfoLocalizations the fields to include for returned resources of type appInfoLocalizations
     * @param fieldsAppCategories the fields to include for returned resources of type appCategories
     * @param limitAppInfoLocalizations maximum number of related appInfoLocalizations returned (when they are included)
     */
    public appInfosGetInstanceWithHttpInfo(id: string, fieldsAppInfos?: Array<'ageRatingDeclaration' | 'app' | 'appInfoLocalizations' | 'appStoreAgeRating' | 'appStoreState' | 'brazilAgeRating' | 'brazilAgeRatingV2' | 'kidsAgeBand' | 'primaryCategory' | 'primarySubcategoryOne' | 'primarySubcategoryTwo' | 'secondaryCategory' | 'secondarySubcategoryOne' | 'secondarySubcategoryTwo' | 'state'>, include?: Array<'ageRatingDeclaration' | 'app' | 'appInfoLocalizations' | 'primaryCategory' | 'primarySubcategoryOne' | 'primarySubcategoryTwo' | 'secondaryCategory' | 'secondarySubcategoryOne' | 'secondarySubcategoryTwo'>, fieldsAgeRatingDeclarations?: Array<'ageRatingOverride' | 'alcoholTobaccoOrDrugUseOrReferences' | 'contests' | 'gambling' | 'gamblingAndContests' | 'gamblingSimulated' | 'horrorOrFearThemes' | 'kidsAgeBand' | 'matureOrSuggestiveThemes' | 'medicalOrTreatmentInformation' | 'profanityOrCrudeHumor' | 'seventeenPlus' | 'sexualContentGraphicAndNudity' | 'sexualContentOrNudity' | 'unrestrictedWebAccess' | 'violenceCartoonOrFantasy' | 'violenceRealistic' | 'violenceRealisticProlongedGraphicOrSadistic'>, fieldsAppInfoLocalizations?: Array<'appInfo' | 'locale' | 'name' | 'privacyChoicesUrl' | 'privacyPolicyText' | 'privacyPolicyUrl' | 'subtitle'>, fieldsAppCategories?: Array<'parent' | 'platforms' | 'subcategories'>, limitAppInfoLocalizations?: number, _options?: Configuration): Promise<HttpInfo<AppInfoResponse>> {
        const result = this.api.appInfosGetInstanceWithHttpInfo(id, fieldsAppInfos, include, fieldsAgeRatingDeclarations, fieldsAppInfoLocalizations, fieldsAppCategories, limitAppInfoLocalizations, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppInfos the fields to include for returned resources of type appInfos
     * @param include comma-separated list of relationships to include
     * @param fieldsAgeRatingDeclarations the fields to include for returned resources of type ageRatingDeclarations
     * @param fieldsAppInfoLocalizations the fields to include for returned resources of type appInfoLocalizations
     * @param fieldsAppCategories the fields to include for returned resources of type appCategories
     * @param limitAppInfoLocalizations maximum number of related appInfoLocalizations returned (when they are included)
     */
    public appInfosGetInstance(id: string, fieldsAppInfos?: Array<'ageRatingDeclaration' | 'app' | 'appInfoLocalizations' | 'appStoreAgeRating' | 'appStoreState' | 'brazilAgeRating' | 'brazilAgeRatingV2' | 'kidsAgeBand' | 'primaryCategory' | 'primarySubcategoryOne' | 'primarySubcategoryTwo' | 'secondaryCategory' | 'secondarySubcategoryOne' | 'secondarySubcategoryTwo' | 'state'>, include?: Array<'ageRatingDeclaration' | 'app' | 'appInfoLocalizations' | 'primaryCategory' | 'primarySubcategoryOne' | 'primarySubcategoryTwo' | 'secondaryCategory' | 'secondarySubcategoryOne' | 'secondarySubcategoryTwo'>, fieldsAgeRatingDeclarations?: Array<'ageRatingOverride' | 'alcoholTobaccoOrDrugUseOrReferences' | 'contests' | 'gambling' | 'gamblingAndContests' | 'gamblingSimulated' | 'horrorOrFearThemes' | 'kidsAgeBand' | 'matureOrSuggestiveThemes' | 'medicalOrTreatmentInformation' | 'profanityOrCrudeHumor' | 'seventeenPlus' | 'sexualContentGraphicAndNudity' | 'sexualContentOrNudity' | 'unrestrictedWebAccess' | 'violenceCartoonOrFantasy' | 'violenceRealistic' | 'violenceRealisticProlongedGraphicOrSadistic'>, fieldsAppInfoLocalizations?: Array<'appInfo' | 'locale' | 'name' | 'privacyChoicesUrl' | 'privacyPolicyText' | 'privacyPolicyUrl' | 'subtitle'>, fieldsAppCategories?: Array<'parent' | 'platforms' | 'subcategories'>, limitAppInfoLocalizations?: number, _options?: Configuration): Promise<AppInfoResponse> {
        const result = this.api.appInfosGetInstance(id, fieldsAppInfos, include, fieldsAgeRatingDeclarations, fieldsAppInfoLocalizations, fieldsAppCategories, limitAppInfoLocalizations, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppCategories the fields to include for returned resources of type appCategories
     * @param limitSubcategories maximum number of related subcategories returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appInfosPrimaryCategoryGetToOneRelatedWithHttpInfo(id: string, fieldsAppCategories?: Array<'parent' | 'platforms' | 'subcategories'>, limitSubcategories?: number, include?: Array<'parent' | 'subcategories'>, _options?: Configuration): Promise<HttpInfo<AppCategoryResponse>> {
        const result = this.api.appInfosPrimaryCategoryGetToOneRelatedWithHttpInfo(id, fieldsAppCategories, limitSubcategories, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppCategories the fields to include for returned resources of type appCategories
     * @param limitSubcategories maximum number of related subcategories returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appInfosPrimaryCategoryGetToOneRelated(id: string, fieldsAppCategories?: Array<'parent' | 'platforms' | 'subcategories'>, limitSubcategories?: number, include?: Array<'parent' | 'subcategories'>, _options?: Configuration): Promise<AppCategoryResponse> {
        const result = this.api.appInfosPrimaryCategoryGetToOneRelated(id, fieldsAppCategories, limitSubcategories, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppCategories the fields to include for returned resources of type appCategories
     * @param limitSubcategories maximum number of related subcategories returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appInfosPrimarySubcategoryOneGetToOneRelatedWithHttpInfo(id: string, fieldsAppCategories?: Array<'parent' | 'platforms' | 'subcategories'>, limitSubcategories?: number, include?: Array<'parent' | 'subcategories'>, _options?: Configuration): Promise<HttpInfo<AppCategoryResponse>> {
        const result = this.api.appInfosPrimarySubcategoryOneGetToOneRelatedWithHttpInfo(id, fieldsAppCategories, limitSubcategories, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppCategories the fields to include for returned resources of type appCategories
     * @param limitSubcategories maximum number of related subcategories returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appInfosPrimarySubcategoryOneGetToOneRelated(id: string, fieldsAppCategories?: Array<'parent' | 'platforms' | 'subcategories'>, limitSubcategories?: number, include?: Array<'parent' | 'subcategories'>, _options?: Configuration): Promise<AppCategoryResponse> {
        const result = this.api.appInfosPrimarySubcategoryOneGetToOneRelated(id, fieldsAppCategories, limitSubcategories, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppCategories the fields to include for returned resources of type appCategories
     * @param limitSubcategories maximum number of related subcategories returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appInfosPrimarySubcategoryTwoGetToOneRelatedWithHttpInfo(id: string, fieldsAppCategories?: Array<'parent' | 'platforms' | 'subcategories'>, limitSubcategories?: number, include?: Array<'parent' | 'subcategories'>, _options?: Configuration): Promise<HttpInfo<AppCategoryResponse>> {
        const result = this.api.appInfosPrimarySubcategoryTwoGetToOneRelatedWithHttpInfo(id, fieldsAppCategories, limitSubcategories, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppCategories the fields to include for returned resources of type appCategories
     * @param limitSubcategories maximum number of related subcategories returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appInfosPrimarySubcategoryTwoGetToOneRelated(id: string, fieldsAppCategories?: Array<'parent' | 'platforms' | 'subcategories'>, limitSubcategories?: number, include?: Array<'parent' | 'subcategories'>, _options?: Configuration): Promise<AppCategoryResponse> {
        const result = this.api.appInfosPrimarySubcategoryTwoGetToOneRelated(id, fieldsAppCategories, limitSubcategories, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppCategories the fields to include for returned resources of type appCategories
     * @param limitSubcategories maximum number of related subcategories returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appInfosSecondaryCategoryGetToOneRelatedWithHttpInfo(id: string, fieldsAppCategories?: Array<'parent' | 'platforms' | 'subcategories'>, limitSubcategories?: number, include?: Array<'parent' | 'subcategories'>, _options?: Configuration): Promise<HttpInfo<AppCategoryResponse>> {
        const result = this.api.appInfosSecondaryCategoryGetToOneRelatedWithHttpInfo(id, fieldsAppCategories, limitSubcategories, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppCategories the fields to include for returned resources of type appCategories
     * @param limitSubcategories maximum number of related subcategories returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appInfosSecondaryCategoryGetToOneRelated(id: string, fieldsAppCategories?: Array<'parent' | 'platforms' | 'subcategories'>, limitSubcategories?: number, include?: Array<'parent' | 'subcategories'>, _options?: Configuration): Promise<AppCategoryResponse> {
        const result = this.api.appInfosSecondaryCategoryGetToOneRelated(id, fieldsAppCategories, limitSubcategories, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppCategories the fields to include for returned resources of type appCategories
     * @param limitSubcategories maximum number of related subcategories returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appInfosSecondarySubcategoryOneGetToOneRelatedWithHttpInfo(id: string, fieldsAppCategories?: Array<'parent' | 'platforms' | 'subcategories'>, limitSubcategories?: number, include?: Array<'parent' | 'subcategories'>, _options?: Configuration): Promise<HttpInfo<AppCategoryResponse>> {
        const result = this.api.appInfosSecondarySubcategoryOneGetToOneRelatedWithHttpInfo(id, fieldsAppCategories, limitSubcategories, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppCategories the fields to include for returned resources of type appCategories
     * @param limitSubcategories maximum number of related subcategories returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appInfosSecondarySubcategoryOneGetToOneRelated(id: string, fieldsAppCategories?: Array<'parent' | 'platforms' | 'subcategories'>, limitSubcategories?: number, include?: Array<'parent' | 'subcategories'>, _options?: Configuration): Promise<AppCategoryResponse> {
        const result = this.api.appInfosSecondarySubcategoryOneGetToOneRelated(id, fieldsAppCategories, limitSubcategories, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppCategories the fields to include for returned resources of type appCategories
     * @param limitSubcategories maximum number of related subcategories returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appInfosSecondarySubcategoryTwoGetToOneRelatedWithHttpInfo(id: string, fieldsAppCategories?: Array<'parent' | 'platforms' | 'subcategories'>, limitSubcategories?: number, include?: Array<'parent' | 'subcategories'>, _options?: Configuration): Promise<HttpInfo<AppCategoryResponse>> {
        const result = this.api.appInfosSecondarySubcategoryTwoGetToOneRelatedWithHttpInfo(id, fieldsAppCategories, limitSubcategories, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppCategories the fields to include for returned resources of type appCategories
     * @param limitSubcategories maximum number of related subcategories returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appInfosSecondarySubcategoryTwoGetToOneRelated(id: string, fieldsAppCategories?: Array<'parent' | 'platforms' | 'subcategories'>, limitSubcategories?: number, include?: Array<'parent' | 'subcategories'>, _options?: Configuration): Promise<AppCategoryResponse> {
        const result = this.api.appInfosSecondarySubcategoryTwoGetToOneRelated(id, fieldsAppCategories, limitSubcategories, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param appInfoUpdateRequest AppInfo representation
     */
    public appInfosUpdateInstanceWithHttpInfo(id: string, appInfoUpdateRequest: AppInfoUpdateRequest, _options?: Configuration): Promise<HttpInfo<AppInfoResponse>> {
        const result = this.api.appInfosUpdateInstanceWithHttpInfo(id, appInfoUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param appInfoUpdateRequest AppInfo representation
     */
    public appInfosUpdateInstance(id: string, appInfoUpdateRequest: AppInfoUpdateRequest, _options?: Configuration): Promise<AppInfoResponse> {
        const result = this.api.appInfosUpdateInstance(id, appInfoUpdateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableAppPreOrdersApi } from './ObservableAPI.ts';

import { AppPreOrdersApiRequestFactory, AppPreOrdersApiResponseProcessor} from "../apis/AppPreOrdersApi.ts";
export class PromiseAppPreOrdersApi {
    private api: ObservableAppPreOrdersApi

    public constructor(
        configuration: Configuration,
        requestFactory?: AppPreOrdersApiRequestFactory,
        responseProcessor?: AppPreOrdersApiResponseProcessor
    ) {
        this.api = new ObservableAppPreOrdersApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param appPreOrderCreateRequest AppPreOrder representation
     */
    public appPreOrdersCreateInstanceWithHttpInfo(appPreOrderCreateRequest: AppPreOrderCreateRequest, _options?: Configuration): Promise<HttpInfo<AppPreOrderResponse>> {
        const result = this.api.appPreOrdersCreateInstanceWithHttpInfo(appPreOrderCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param appPreOrderCreateRequest AppPreOrder representation
     */
    public appPreOrdersCreateInstance(appPreOrderCreateRequest: AppPreOrderCreateRequest, _options?: Configuration): Promise<AppPreOrderResponse> {
        const result = this.api.appPreOrdersCreateInstance(appPreOrderCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public appPreOrdersDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.appPreOrdersDeleteInstanceWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public appPreOrdersDeleteInstance(id: string, _options?: Configuration): Promise<void> {
        const result = this.api.appPreOrdersDeleteInstance(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppPreOrders the fields to include for returned resources of type appPreOrders
     * @param include comma-separated list of relationships to include
     */
    public appPreOrdersGetInstanceWithHttpInfo(id: string, fieldsAppPreOrders?: Array<'app' | 'appReleaseDate' | 'preOrderAvailableDate'>, include?: Array<'app'>, _options?: Configuration): Promise<HttpInfo<AppPreOrderResponse>> {
        const result = this.api.appPreOrdersGetInstanceWithHttpInfo(id, fieldsAppPreOrders, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppPreOrders the fields to include for returned resources of type appPreOrders
     * @param include comma-separated list of relationships to include
     */
    public appPreOrdersGetInstance(id: string, fieldsAppPreOrders?: Array<'app' | 'appReleaseDate' | 'preOrderAvailableDate'>, include?: Array<'app'>, _options?: Configuration): Promise<AppPreOrderResponse> {
        const result = this.api.appPreOrdersGetInstance(id, fieldsAppPreOrders, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param appPreOrderUpdateRequest AppPreOrder representation
     */
    public appPreOrdersUpdateInstanceWithHttpInfo(id: string, appPreOrderUpdateRequest: AppPreOrderUpdateRequest, _options?: Configuration): Promise<HttpInfo<AppPreOrderResponse>> {
        const result = this.api.appPreOrdersUpdateInstanceWithHttpInfo(id, appPreOrderUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param appPreOrderUpdateRequest AppPreOrder representation
     */
    public appPreOrdersUpdateInstance(id: string, appPreOrderUpdateRequest: AppPreOrderUpdateRequest, _options?: Configuration): Promise<AppPreOrderResponse> {
        const result = this.api.appPreOrdersUpdateInstance(id, appPreOrderUpdateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableAppPreviewSetsApi } from './ObservableAPI.ts';

import { AppPreviewSetsApiRequestFactory, AppPreviewSetsApiResponseProcessor} from "../apis/AppPreviewSetsApi.ts";
export class PromiseAppPreviewSetsApi {
    private api: ObservableAppPreviewSetsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: AppPreviewSetsApiRequestFactory,
        responseProcessor?: AppPreviewSetsApiResponseProcessor
    ) {
        this.api = new ObservableAppPreviewSetsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppPreviews the fields to include for returned resources of type appPreviews
     * @param fieldsAppPreviewSets the fields to include for returned resources of type appPreviewSets
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public appPreviewSetsAppPreviewsGetToManyRelatedWithHttpInfo(id: string, fieldsAppPreviews?: Array<'appPreviewSet' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'mimeType' | 'previewFrameTimeCode' | 'previewImage' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded' | 'videoUrl'>, fieldsAppPreviewSets?: Array<'appCustomProductPageLocalization' | 'appPreviews' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'previewType'>, limit?: number, include?: Array<'appPreviewSet'>, _options?: Configuration): Promise<HttpInfo<AppPreviewsResponse>> {
        const result = this.api.appPreviewSetsAppPreviewsGetToManyRelatedWithHttpInfo(id, fieldsAppPreviews, fieldsAppPreviewSets, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppPreviews the fields to include for returned resources of type appPreviews
     * @param fieldsAppPreviewSets the fields to include for returned resources of type appPreviewSets
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public appPreviewSetsAppPreviewsGetToManyRelated(id: string, fieldsAppPreviews?: Array<'appPreviewSet' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'mimeType' | 'previewFrameTimeCode' | 'previewImage' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded' | 'videoUrl'>, fieldsAppPreviewSets?: Array<'appCustomProductPageLocalization' | 'appPreviews' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'previewType'>, limit?: number, include?: Array<'appPreviewSet'>, _options?: Configuration): Promise<AppPreviewsResponse> {
        const result = this.api.appPreviewSetsAppPreviewsGetToManyRelated(id, fieldsAppPreviews, fieldsAppPreviewSets, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public appPreviewSetsAppPreviewsGetToManyRelationshipWithHttpInfo(id: string, limit?: number, _options?: Configuration): Promise<HttpInfo<AppPreviewSetAppPreviewsLinkagesResponse>> {
        const result = this.api.appPreviewSetsAppPreviewsGetToManyRelationshipWithHttpInfo(id, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public appPreviewSetsAppPreviewsGetToManyRelationship(id: string, limit?: number, _options?: Configuration): Promise<AppPreviewSetAppPreviewsLinkagesResponse> {
        const result = this.api.appPreviewSetsAppPreviewsGetToManyRelationship(id, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param appPreviewSetAppPreviewsLinkagesRequest List of related linkages
     */
    public appPreviewSetsAppPreviewsReplaceToManyRelationshipWithHttpInfo(id: string, appPreviewSetAppPreviewsLinkagesRequest: AppPreviewSetAppPreviewsLinkagesRequest, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.appPreviewSetsAppPreviewsReplaceToManyRelationshipWithHttpInfo(id, appPreviewSetAppPreviewsLinkagesRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param appPreviewSetAppPreviewsLinkagesRequest List of related linkages
     */
    public appPreviewSetsAppPreviewsReplaceToManyRelationship(id: string, appPreviewSetAppPreviewsLinkagesRequest: AppPreviewSetAppPreviewsLinkagesRequest, _options?: Configuration): Promise<void> {
        const result = this.api.appPreviewSetsAppPreviewsReplaceToManyRelationship(id, appPreviewSetAppPreviewsLinkagesRequest, _options);
        return result.toPromise();
    }

    /**
     * @param appPreviewSetCreateRequest AppPreviewSet representation
     */
    public appPreviewSetsCreateInstanceWithHttpInfo(appPreviewSetCreateRequest: AppPreviewSetCreateRequest, _options?: Configuration): Promise<HttpInfo<AppPreviewSetResponse>> {
        const result = this.api.appPreviewSetsCreateInstanceWithHttpInfo(appPreviewSetCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param appPreviewSetCreateRequest AppPreviewSet representation
     */
    public appPreviewSetsCreateInstance(appPreviewSetCreateRequest: AppPreviewSetCreateRequest, _options?: Configuration): Promise<AppPreviewSetResponse> {
        const result = this.api.appPreviewSetsCreateInstance(appPreviewSetCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public appPreviewSetsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.appPreviewSetsDeleteInstanceWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public appPreviewSetsDeleteInstance(id: string, _options?: Configuration): Promise<void> {
        const result = this.api.appPreviewSetsDeleteInstance(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppPreviewSets the fields to include for returned resources of type appPreviewSets
     * @param include comma-separated list of relationships to include
     * @param fieldsAppPreviews the fields to include for returned resources of type appPreviews
     * @param limitAppPreviews maximum number of related appPreviews returned (when they are included)
     */
    public appPreviewSetsGetInstanceWithHttpInfo(id: string, fieldsAppPreviewSets?: Array<'appCustomProductPageLocalization' | 'appPreviews' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'previewType'>, include?: Array<'appCustomProductPageLocalization' | 'appPreviews' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization'>, fieldsAppPreviews?: Array<'appPreviewSet' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'mimeType' | 'previewFrameTimeCode' | 'previewImage' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded' | 'videoUrl'>, limitAppPreviews?: number, _options?: Configuration): Promise<HttpInfo<AppPreviewSetResponse>> {
        const result = this.api.appPreviewSetsGetInstanceWithHttpInfo(id, fieldsAppPreviewSets, include, fieldsAppPreviews, limitAppPreviews, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppPreviewSets the fields to include for returned resources of type appPreviewSets
     * @param include comma-separated list of relationships to include
     * @param fieldsAppPreviews the fields to include for returned resources of type appPreviews
     * @param limitAppPreviews maximum number of related appPreviews returned (when they are included)
     */
    public appPreviewSetsGetInstance(id: string, fieldsAppPreviewSets?: Array<'appCustomProductPageLocalization' | 'appPreviews' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'previewType'>, include?: Array<'appCustomProductPageLocalization' | 'appPreviews' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization'>, fieldsAppPreviews?: Array<'appPreviewSet' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'mimeType' | 'previewFrameTimeCode' | 'previewImage' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded' | 'videoUrl'>, limitAppPreviews?: number, _options?: Configuration): Promise<AppPreviewSetResponse> {
        const result = this.api.appPreviewSetsGetInstance(id, fieldsAppPreviewSets, include, fieldsAppPreviews, limitAppPreviews, _options);
        return result.toPromise();
    }


}



import { ObservableAppPreviewsApi } from './ObservableAPI.ts';

import { AppPreviewsApiRequestFactory, AppPreviewsApiResponseProcessor} from "../apis/AppPreviewsApi.ts";
export class PromiseAppPreviewsApi {
    private api: ObservableAppPreviewsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: AppPreviewsApiRequestFactory,
        responseProcessor?: AppPreviewsApiResponseProcessor
    ) {
        this.api = new ObservableAppPreviewsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param appPreviewCreateRequest AppPreview representation
     */
    public appPreviewsCreateInstanceWithHttpInfo(appPreviewCreateRequest: AppPreviewCreateRequest, _options?: Configuration): Promise<HttpInfo<AppPreviewResponse>> {
        const result = this.api.appPreviewsCreateInstanceWithHttpInfo(appPreviewCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param appPreviewCreateRequest AppPreview representation
     */
    public appPreviewsCreateInstance(appPreviewCreateRequest: AppPreviewCreateRequest, _options?: Configuration): Promise<AppPreviewResponse> {
        const result = this.api.appPreviewsCreateInstance(appPreviewCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public appPreviewsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.appPreviewsDeleteInstanceWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public appPreviewsDeleteInstance(id: string, _options?: Configuration): Promise<void> {
        const result = this.api.appPreviewsDeleteInstance(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppPreviews the fields to include for returned resources of type appPreviews
     * @param include comma-separated list of relationships to include
     */
    public appPreviewsGetInstanceWithHttpInfo(id: string, fieldsAppPreviews?: Array<'appPreviewSet' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'mimeType' | 'previewFrameTimeCode' | 'previewImage' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded' | 'videoUrl'>, include?: Array<'appPreviewSet'>, _options?: Configuration): Promise<HttpInfo<AppPreviewResponse>> {
        const result = this.api.appPreviewsGetInstanceWithHttpInfo(id, fieldsAppPreviews, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppPreviews the fields to include for returned resources of type appPreviews
     * @param include comma-separated list of relationships to include
     */
    public appPreviewsGetInstance(id: string, fieldsAppPreviews?: Array<'appPreviewSet' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'mimeType' | 'previewFrameTimeCode' | 'previewImage' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded' | 'videoUrl'>, include?: Array<'appPreviewSet'>, _options?: Configuration): Promise<AppPreviewResponse> {
        const result = this.api.appPreviewsGetInstance(id, fieldsAppPreviews, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param appPreviewUpdateRequest AppPreview representation
     */
    public appPreviewsUpdateInstanceWithHttpInfo(id: string, appPreviewUpdateRequest: AppPreviewUpdateRequest, _options?: Configuration): Promise<HttpInfo<AppPreviewResponse>> {
        const result = this.api.appPreviewsUpdateInstanceWithHttpInfo(id, appPreviewUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param appPreviewUpdateRequest AppPreview representation
     */
    public appPreviewsUpdateInstance(id: string, appPreviewUpdateRequest: AppPreviewUpdateRequest, _options?: Configuration): Promise<AppPreviewResponse> {
        const result = this.api.appPreviewsUpdateInstance(id, appPreviewUpdateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableAppPricePointsApi } from './ObservableAPI.ts';

import { AppPricePointsApiRequestFactory, AppPricePointsApiResponseProcessor} from "../apis/AppPricePointsApi.ts";
export class PromiseAppPricePointsApi {
    private api: ObservableAppPricePointsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: AppPricePointsApiRequestFactory,
        responseProcessor?: AppPricePointsApiResponseProcessor
    ) {
        this.api = new ObservableAppPricePointsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param filterPriceTier filter by id(s) of related \&#39;priceTier\&#39;
     * @param filterTerritory filter by id(s) of related \&#39;territory\&#39;
     * @param fieldsAppPricePoints the fields to include for returned resources of type appPricePoints
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsTerritories the fields to include for returned resources of type territories
     */
    public appPricePointsGetCollectionWithHttpInfo(filterPriceTier?: Array<string>, filterTerritory?: Array<string>, fieldsAppPricePoints?: Array<'customerPrice' | 'priceTier' | 'proceeds' | 'territory'>, limit?: number, include?: Array<'priceTier' | 'territory'>, fieldsTerritories?: Array<'currency'>, _options?: Configuration): Promise<HttpInfo<AppPricePointsResponse>> {
        const result = this.api.appPricePointsGetCollectionWithHttpInfo(filterPriceTier, filterTerritory, fieldsAppPricePoints, limit, include, fieldsTerritories, _options);
        return result.toPromise();
    }

    /**
     * @param filterPriceTier filter by id(s) of related \&#39;priceTier\&#39;
     * @param filterTerritory filter by id(s) of related \&#39;territory\&#39;
     * @param fieldsAppPricePoints the fields to include for returned resources of type appPricePoints
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsTerritories the fields to include for returned resources of type territories
     */
    public appPricePointsGetCollection(filterPriceTier?: Array<string>, filterTerritory?: Array<string>, fieldsAppPricePoints?: Array<'customerPrice' | 'priceTier' | 'proceeds' | 'territory'>, limit?: number, include?: Array<'priceTier' | 'territory'>, fieldsTerritories?: Array<'currency'>, _options?: Configuration): Promise<AppPricePointsResponse> {
        const result = this.api.appPricePointsGetCollection(filterPriceTier, filterTerritory, fieldsAppPricePoints, limit, include, fieldsTerritories, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppPricePoints the fields to include for returned resources of type appPricePoints
     * @param include comma-separated list of relationships to include
     * @param fieldsTerritories the fields to include for returned resources of type territories
     */
    public appPricePointsGetInstanceWithHttpInfo(id: string, fieldsAppPricePoints?: Array<'customerPrice' | 'priceTier' | 'proceeds' | 'territory'>, include?: Array<'priceTier' | 'territory'>, fieldsTerritories?: Array<'currency'>, _options?: Configuration): Promise<HttpInfo<AppPricePointResponse>> {
        const result = this.api.appPricePointsGetInstanceWithHttpInfo(id, fieldsAppPricePoints, include, fieldsTerritories, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppPricePoints the fields to include for returned resources of type appPricePoints
     * @param include comma-separated list of relationships to include
     * @param fieldsTerritories the fields to include for returned resources of type territories
     */
    public appPricePointsGetInstance(id: string, fieldsAppPricePoints?: Array<'customerPrice' | 'priceTier' | 'proceeds' | 'territory'>, include?: Array<'priceTier' | 'territory'>, fieldsTerritories?: Array<'currency'>, _options?: Configuration): Promise<AppPricePointResponse> {
        const result = this.api.appPricePointsGetInstance(id, fieldsAppPricePoints, include, fieldsTerritories, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsTerritories the fields to include for returned resources of type territories
     */
    public appPricePointsTerritoryGetToOneRelatedWithHttpInfo(id: string, fieldsTerritories?: Array<'currency'>, _options?: Configuration): Promise<HttpInfo<TerritoryResponse>> {
        const result = this.api.appPricePointsTerritoryGetToOneRelatedWithHttpInfo(id, fieldsTerritories, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsTerritories the fields to include for returned resources of type territories
     */
    public appPricePointsTerritoryGetToOneRelated(id: string, fieldsTerritories?: Array<'currency'>, _options?: Configuration): Promise<TerritoryResponse> {
        const result = this.api.appPricePointsTerritoryGetToOneRelated(id, fieldsTerritories, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterTerritory filter by id(s) of related \&#39;territory\&#39;
     * @param fieldsAppPricePoints the fields to include for returned resources of type appPricePoints
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public appPricePointsV3EqualizationsGetToManyRelatedWithHttpInfo(id: string, filterTerritory?: Array<string>, fieldsAppPricePoints?: Array<'app' | 'customerPrice' | 'equalizations' | 'proceeds' | 'territory'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsTerritories?: Array<'currency'>, limit?: number, include?: Array<'app' | 'territory'>, _options?: Configuration): Promise<HttpInfo<AppPricePointsV3Response>> {
        const result = this.api.appPricePointsV3EqualizationsGetToManyRelatedWithHttpInfo(id, filterTerritory, fieldsAppPricePoints, fieldsApps, fieldsTerritories, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterTerritory filter by id(s) of related \&#39;territory\&#39;
     * @param fieldsAppPricePoints the fields to include for returned resources of type appPricePoints
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public appPricePointsV3EqualizationsGetToManyRelated(id: string, filterTerritory?: Array<string>, fieldsAppPricePoints?: Array<'app' | 'customerPrice' | 'equalizations' | 'proceeds' | 'territory'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsTerritories?: Array<'currency'>, limit?: number, include?: Array<'app' | 'territory'>, _options?: Configuration): Promise<AppPricePointsV3Response> {
        const result = this.api.appPricePointsV3EqualizationsGetToManyRelated(id, filterTerritory, fieldsAppPricePoints, fieldsApps, fieldsTerritories, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppPricePoints the fields to include for returned resources of type appPricePoints
     * @param include comma-separated list of relationships to include
     */
    public appPricePointsV3GetInstanceWithHttpInfo(id: string, fieldsAppPricePoints?: Array<'app' | 'customerPrice' | 'equalizations' | 'proceeds' | 'territory'>, include?: Array<'app' | 'territory'>, _options?: Configuration): Promise<HttpInfo<AppPricePointV3Response>> {
        const result = this.api.appPricePointsV3GetInstanceWithHttpInfo(id, fieldsAppPricePoints, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppPricePoints the fields to include for returned resources of type appPricePoints
     * @param include comma-separated list of relationships to include
     */
    public appPricePointsV3GetInstance(id: string, fieldsAppPricePoints?: Array<'app' | 'customerPrice' | 'equalizations' | 'proceeds' | 'territory'>, include?: Array<'app' | 'territory'>, _options?: Configuration): Promise<AppPricePointV3Response> {
        const result = this.api.appPricePointsV3GetInstance(id, fieldsAppPricePoints, include, _options);
        return result.toPromise();
    }


}



import { ObservableAppPriceSchedulesApi } from './ObservableAPI.ts';

import { AppPriceSchedulesApiRequestFactory, AppPriceSchedulesApiResponseProcessor} from "../apis/AppPriceSchedulesApi.ts";
export class PromiseAppPriceSchedulesApi {
    private api: ObservableAppPriceSchedulesApi

    public constructor(
        configuration: Configuration,
        requestFactory?: AppPriceSchedulesApiRequestFactory,
        responseProcessor?: AppPriceSchedulesApiResponseProcessor
    ) {
        this.api = new ObservableAppPriceSchedulesApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param id the id of the requested resource
     * @param filterEndDate filter by attribute \&#39;endDate\&#39;
     * @param filterStartDate filter by attribute \&#39;startDate\&#39;
     * @param filterTerritory filter by id(s) of related \&#39;territory\&#39;
     * @param fieldsAppPrices the fields to include for returned resources of type appPrices
     * @param fieldsAppPricePoints the fields to include for returned resources of type appPricePoints
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public appPriceSchedulesAutomaticPricesGetToManyRelatedWithHttpInfo(id: string, filterEndDate?: Array<string>, filterStartDate?: Array<string>, filterTerritory?: Array<string>, fieldsAppPrices?: Array<'appPricePoint' | 'endDate' | 'manual' | 'startDate' | 'territory'>, fieldsAppPricePoints?: Array<'app' | 'customerPrice' | 'equalizations' | 'proceeds' | 'territory'>, fieldsTerritories?: Array<'currency'>, limit?: number, include?: Array<'appPricePoint' | 'territory'>, _options?: Configuration): Promise<HttpInfo<AppPricesV2Response>> {
        const result = this.api.appPriceSchedulesAutomaticPricesGetToManyRelatedWithHttpInfo(id, filterEndDate, filterStartDate, filterTerritory, fieldsAppPrices, fieldsAppPricePoints, fieldsTerritories, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterEndDate filter by attribute \&#39;endDate\&#39;
     * @param filterStartDate filter by attribute \&#39;startDate\&#39;
     * @param filterTerritory filter by id(s) of related \&#39;territory\&#39;
     * @param fieldsAppPrices the fields to include for returned resources of type appPrices
     * @param fieldsAppPricePoints the fields to include for returned resources of type appPricePoints
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public appPriceSchedulesAutomaticPricesGetToManyRelated(id: string, filterEndDate?: Array<string>, filterStartDate?: Array<string>, filterTerritory?: Array<string>, fieldsAppPrices?: Array<'appPricePoint' | 'endDate' | 'manual' | 'startDate' | 'territory'>, fieldsAppPricePoints?: Array<'app' | 'customerPrice' | 'equalizations' | 'proceeds' | 'territory'>, fieldsTerritories?: Array<'currency'>, limit?: number, include?: Array<'appPricePoint' | 'territory'>, _options?: Configuration): Promise<AppPricesV2Response> {
        const result = this.api.appPriceSchedulesAutomaticPricesGetToManyRelated(id, filterEndDate, filterStartDate, filterTerritory, fieldsAppPrices, fieldsAppPricePoints, fieldsTerritories, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsTerritories the fields to include for returned resources of type territories
     */
    public appPriceSchedulesBaseTerritoryGetToOneRelatedWithHttpInfo(id: string, fieldsTerritories?: Array<'currency'>, _options?: Configuration): Promise<HttpInfo<TerritoryResponse>> {
        const result = this.api.appPriceSchedulesBaseTerritoryGetToOneRelatedWithHttpInfo(id, fieldsTerritories, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsTerritories the fields to include for returned resources of type territories
     */
    public appPriceSchedulesBaseTerritoryGetToOneRelated(id: string, fieldsTerritories?: Array<'currency'>, _options?: Configuration): Promise<TerritoryResponse> {
        const result = this.api.appPriceSchedulesBaseTerritoryGetToOneRelated(id, fieldsTerritories, _options);
        return result.toPromise();
    }

    /**
     * @param appPriceScheduleCreateRequest AppPriceSchedule representation
     */
    public appPriceSchedulesCreateInstanceWithHttpInfo(appPriceScheduleCreateRequest: AppPriceScheduleCreateRequest, _options?: Configuration): Promise<HttpInfo<AppPriceScheduleResponse>> {
        const result = this.api.appPriceSchedulesCreateInstanceWithHttpInfo(appPriceScheduleCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param appPriceScheduleCreateRequest AppPriceSchedule representation
     */
    public appPriceSchedulesCreateInstance(appPriceScheduleCreateRequest: AppPriceScheduleCreateRequest, _options?: Configuration): Promise<AppPriceScheduleResponse> {
        const result = this.api.appPriceSchedulesCreateInstance(appPriceScheduleCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppPriceSchedules the fields to include for returned resources of type appPriceSchedules
     * @param include comma-separated list of relationships to include
     * @param fieldsAppPrices the fields to include for returned resources of type appPrices
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limitAutomaticPrices maximum number of related automaticPrices returned (when they are included)
     * @param limitManualPrices maximum number of related manualPrices returned (when they are included)
     */
    public appPriceSchedulesGetInstanceWithHttpInfo(id: string, fieldsAppPriceSchedules?: Array<'app' | 'automaticPrices' | 'baseTerritory' | 'manualPrices'>, include?: Array<'app' | 'automaticPrices' | 'baseTerritory' | 'manualPrices'>, fieldsAppPrices?: Array<'appPricePoint' | 'endDate' | 'manual' | 'startDate' | 'territory'>, fieldsTerritories?: Array<'currency'>, limitAutomaticPrices?: number, limitManualPrices?: number, _options?: Configuration): Promise<HttpInfo<AppPriceScheduleResponse>> {
        const result = this.api.appPriceSchedulesGetInstanceWithHttpInfo(id, fieldsAppPriceSchedules, include, fieldsAppPrices, fieldsTerritories, limitAutomaticPrices, limitManualPrices, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppPriceSchedules the fields to include for returned resources of type appPriceSchedules
     * @param include comma-separated list of relationships to include
     * @param fieldsAppPrices the fields to include for returned resources of type appPrices
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limitAutomaticPrices maximum number of related automaticPrices returned (when they are included)
     * @param limitManualPrices maximum number of related manualPrices returned (when they are included)
     */
    public appPriceSchedulesGetInstance(id: string, fieldsAppPriceSchedules?: Array<'app' | 'automaticPrices' | 'baseTerritory' | 'manualPrices'>, include?: Array<'app' | 'automaticPrices' | 'baseTerritory' | 'manualPrices'>, fieldsAppPrices?: Array<'appPricePoint' | 'endDate' | 'manual' | 'startDate' | 'territory'>, fieldsTerritories?: Array<'currency'>, limitAutomaticPrices?: number, limitManualPrices?: number, _options?: Configuration): Promise<AppPriceScheduleResponse> {
        const result = this.api.appPriceSchedulesGetInstance(id, fieldsAppPriceSchedules, include, fieldsAppPrices, fieldsTerritories, limitAutomaticPrices, limitManualPrices, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterEndDate filter by attribute \&#39;endDate\&#39;
     * @param filterStartDate filter by attribute \&#39;startDate\&#39;
     * @param filterTerritory filter by id(s) of related \&#39;territory\&#39;
     * @param fieldsAppPrices the fields to include for returned resources of type appPrices
     * @param fieldsAppPricePoints the fields to include for returned resources of type appPricePoints
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public appPriceSchedulesManualPricesGetToManyRelatedWithHttpInfo(id: string, filterEndDate?: Array<string>, filterStartDate?: Array<string>, filterTerritory?: Array<string>, fieldsAppPrices?: Array<'appPricePoint' | 'endDate' | 'manual' | 'startDate' | 'territory'>, fieldsAppPricePoints?: Array<'app' | 'customerPrice' | 'equalizations' | 'proceeds' | 'territory'>, fieldsTerritories?: Array<'currency'>, limit?: number, include?: Array<'appPricePoint' | 'territory'>, _options?: Configuration): Promise<HttpInfo<AppPricesV2Response>> {
        const result = this.api.appPriceSchedulesManualPricesGetToManyRelatedWithHttpInfo(id, filterEndDate, filterStartDate, filterTerritory, fieldsAppPrices, fieldsAppPricePoints, fieldsTerritories, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterEndDate filter by attribute \&#39;endDate\&#39;
     * @param filterStartDate filter by attribute \&#39;startDate\&#39;
     * @param filterTerritory filter by id(s) of related \&#39;territory\&#39;
     * @param fieldsAppPrices the fields to include for returned resources of type appPrices
     * @param fieldsAppPricePoints the fields to include for returned resources of type appPricePoints
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public appPriceSchedulesManualPricesGetToManyRelated(id: string, filterEndDate?: Array<string>, filterStartDate?: Array<string>, filterTerritory?: Array<string>, fieldsAppPrices?: Array<'appPricePoint' | 'endDate' | 'manual' | 'startDate' | 'territory'>, fieldsAppPricePoints?: Array<'app' | 'customerPrice' | 'equalizations' | 'proceeds' | 'territory'>, fieldsTerritories?: Array<'currency'>, limit?: number, include?: Array<'appPricePoint' | 'territory'>, _options?: Configuration): Promise<AppPricesV2Response> {
        const result = this.api.appPriceSchedulesManualPricesGetToManyRelated(id, filterEndDate, filterStartDate, filterTerritory, fieldsAppPrices, fieldsAppPricePoints, fieldsTerritories, limit, include, _options);
        return result.toPromise();
    }


}



import { ObservableAppPriceTiersApi } from './ObservableAPI.ts';

import { AppPriceTiersApiRequestFactory, AppPriceTiersApiResponseProcessor} from "../apis/AppPriceTiersApi.ts";
export class PromiseAppPriceTiersApi {
    private api: ObservableAppPriceTiersApi

    public constructor(
        configuration: Configuration,
        requestFactory?: AppPriceTiersApiRequestFactory,
        responseProcessor?: AppPriceTiersApiResponseProcessor
    ) {
        this.api = new ObservableAppPriceTiersApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param filterId filter by id(s)
     * @param fieldsAppPriceTiers the fields to include for returned resources of type appPriceTiers
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsAppPricePoints the fields to include for returned resources of type appPricePoints
     * @param limitPricePoints maximum number of related pricePoints returned (when they are included)
     */
    public appPriceTiersGetCollectionWithHttpInfo(filterId?: Array<string>, fieldsAppPriceTiers?: Array<'pricePoints'>, limit?: number, include?: Array<'pricePoints'>, fieldsAppPricePoints?: Array<'customerPrice' | 'priceTier' | 'proceeds' | 'territory'>, limitPricePoints?: number, _options?: Configuration): Promise<HttpInfo<AppPriceTiersResponse>> {
        const result = this.api.appPriceTiersGetCollectionWithHttpInfo(filterId, fieldsAppPriceTiers, limit, include, fieldsAppPricePoints, limitPricePoints, _options);
        return result.toPromise();
    }

    /**
     * @param filterId filter by id(s)
     * @param fieldsAppPriceTiers the fields to include for returned resources of type appPriceTiers
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsAppPricePoints the fields to include for returned resources of type appPricePoints
     * @param limitPricePoints maximum number of related pricePoints returned (when they are included)
     */
    public appPriceTiersGetCollection(filterId?: Array<string>, fieldsAppPriceTiers?: Array<'pricePoints'>, limit?: number, include?: Array<'pricePoints'>, fieldsAppPricePoints?: Array<'customerPrice' | 'priceTier' | 'proceeds' | 'territory'>, limitPricePoints?: number, _options?: Configuration): Promise<AppPriceTiersResponse> {
        const result = this.api.appPriceTiersGetCollection(filterId, fieldsAppPriceTiers, limit, include, fieldsAppPricePoints, limitPricePoints, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppPriceTiers the fields to include for returned resources of type appPriceTiers
     * @param include comma-separated list of relationships to include
     * @param fieldsAppPricePoints the fields to include for returned resources of type appPricePoints
     * @param limitPricePoints maximum number of related pricePoints returned (when they are included)
     */
    public appPriceTiersGetInstanceWithHttpInfo(id: string, fieldsAppPriceTiers?: Array<'pricePoints'>, include?: Array<'pricePoints'>, fieldsAppPricePoints?: Array<'customerPrice' | 'priceTier' | 'proceeds' | 'territory'>, limitPricePoints?: number, _options?: Configuration): Promise<HttpInfo<AppPriceTierResponse>> {
        const result = this.api.appPriceTiersGetInstanceWithHttpInfo(id, fieldsAppPriceTiers, include, fieldsAppPricePoints, limitPricePoints, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppPriceTiers the fields to include for returned resources of type appPriceTiers
     * @param include comma-separated list of relationships to include
     * @param fieldsAppPricePoints the fields to include for returned resources of type appPricePoints
     * @param limitPricePoints maximum number of related pricePoints returned (when they are included)
     */
    public appPriceTiersGetInstance(id: string, fieldsAppPriceTiers?: Array<'pricePoints'>, include?: Array<'pricePoints'>, fieldsAppPricePoints?: Array<'customerPrice' | 'priceTier' | 'proceeds' | 'territory'>, limitPricePoints?: number, _options?: Configuration): Promise<AppPriceTierResponse> {
        const result = this.api.appPriceTiersGetInstance(id, fieldsAppPriceTiers, include, fieldsAppPricePoints, limitPricePoints, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterTerritory filter by id(s) of related \&#39;territory\&#39;
     * @param fieldsAppPriceTiers the fields to include for returned resources of type appPriceTiers
     * @param fieldsAppPricePoints the fields to include for returned resources of type appPricePoints
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public appPriceTiersPricePointsGetToManyRelatedWithHttpInfo(id: string, filterTerritory?: Array<string>, fieldsAppPriceTiers?: Array<'pricePoints'>, fieldsAppPricePoints?: Array<'customerPrice' | 'priceTier' | 'proceeds' | 'territory'>, fieldsTerritories?: Array<'currency'>, limit?: number, include?: Array<'priceTier' | 'territory'>, _options?: Configuration): Promise<HttpInfo<AppPricePointsResponse>> {
        const result = this.api.appPriceTiersPricePointsGetToManyRelatedWithHttpInfo(id, filterTerritory, fieldsAppPriceTiers, fieldsAppPricePoints, fieldsTerritories, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterTerritory filter by id(s) of related \&#39;territory\&#39;
     * @param fieldsAppPriceTiers the fields to include for returned resources of type appPriceTiers
     * @param fieldsAppPricePoints the fields to include for returned resources of type appPricePoints
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public appPriceTiersPricePointsGetToManyRelated(id: string, filterTerritory?: Array<string>, fieldsAppPriceTiers?: Array<'pricePoints'>, fieldsAppPricePoints?: Array<'customerPrice' | 'priceTier' | 'proceeds' | 'territory'>, fieldsTerritories?: Array<'currency'>, limit?: number, include?: Array<'priceTier' | 'territory'>, _options?: Configuration): Promise<AppPricePointsResponse> {
        const result = this.api.appPriceTiersPricePointsGetToManyRelated(id, filterTerritory, fieldsAppPriceTiers, fieldsAppPricePoints, fieldsTerritories, limit, include, _options);
        return result.toPromise();
    }


}



import { ObservableAppPricesApi } from './ObservableAPI.ts';

import { AppPricesApiRequestFactory, AppPricesApiResponseProcessor} from "../apis/AppPricesApi.ts";
export class PromiseAppPricesApi {
    private api: ObservableAppPricesApi

    public constructor(
        configuration: Configuration,
        requestFactory?: AppPricesApiRequestFactory,
        responseProcessor?: AppPricesApiResponseProcessor
    ) {
        this.api = new ObservableAppPricesApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppPrices the fields to include for returned resources of type appPrices
     * @param include comma-separated list of relationships to include
     */
    public appPricesGetInstanceWithHttpInfo(id: string, fieldsAppPrices?: Array<'app' | 'priceTier'>, include?: Array<'app' | 'priceTier'>, _options?: Configuration): Promise<HttpInfo<AppPriceResponse>> {
        const result = this.api.appPricesGetInstanceWithHttpInfo(id, fieldsAppPrices, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppPrices the fields to include for returned resources of type appPrices
     * @param include comma-separated list of relationships to include
     */
    public appPricesGetInstance(id: string, fieldsAppPrices?: Array<'app' | 'priceTier'>, include?: Array<'app' | 'priceTier'>, _options?: Configuration): Promise<AppPriceResponse> {
        const result = this.api.appPricesGetInstance(id, fieldsAppPrices, include, _options);
        return result.toPromise();
    }


}



import { ObservableAppScreenshotSetsApi } from './ObservableAPI.ts';

import { AppScreenshotSetsApiRequestFactory, AppScreenshotSetsApiResponseProcessor} from "../apis/AppScreenshotSetsApi.ts";
export class PromiseAppScreenshotSetsApi {
    private api: ObservableAppScreenshotSetsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: AppScreenshotSetsApiRequestFactory,
        responseProcessor?: AppScreenshotSetsApiResponseProcessor
    ) {
        this.api = new ObservableAppScreenshotSetsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppScreenshotSets the fields to include for returned resources of type appScreenshotSets
     * @param fieldsAppScreenshots the fields to include for returned resources of type appScreenshots
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public appScreenshotSetsAppScreenshotsGetToManyRelatedWithHttpInfo(id: string, fieldsAppScreenshotSets?: Array<'appCustomProductPageLocalization' | 'appScreenshots' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'screenshotDisplayType'>, fieldsAppScreenshots?: Array<'appScreenshotSet' | 'assetDeliveryState' | 'assetToken' | 'assetType' | 'fileName' | 'fileSize' | 'imageAsset' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, limit?: number, include?: Array<'appScreenshotSet'>, _options?: Configuration): Promise<HttpInfo<AppScreenshotsResponse>> {
        const result = this.api.appScreenshotSetsAppScreenshotsGetToManyRelatedWithHttpInfo(id, fieldsAppScreenshotSets, fieldsAppScreenshots, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppScreenshotSets the fields to include for returned resources of type appScreenshotSets
     * @param fieldsAppScreenshots the fields to include for returned resources of type appScreenshots
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public appScreenshotSetsAppScreenshotsGetToManyRelated(id: string, fieldsAppScreenshotSets?: Array<'appCustomProductPageLocalization' | 'appScreenshots' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'screenshotDisplayType'>, fieldsAppScreenshots?: Array<'appScreenshotSet' | 'assetDeliveryState' | 'assetToken' | 'assetType' | 'fileName' | 'fileSize' | 'imageAsset' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, limit?: number, include?: Array<'appScreenshotSet'>, _options?: Configuration): Promise<AppScreenshotsResponse> {
        const result = this.api.appScreenshotSetsAppScreenshotsGetToManyRelated(id, fieldsAppScreenshotSets, fieldsAppScreenshots, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public appScreenshotSetsAppScreenshotsGetToManyRelationshipWithHttpInfo(id: string, limit?: number, _options?: Configuration): Promise<HttpInfo<AppScreenshotSetAppScreenshotsLinkagesResponse>> {
        const result = this.api.appScreenshotSetsAppScreenshotsGetToManyRelationshipWithHttpInfo(id, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public appScreenshotSetsAppScreenshotsGetToManyRelationship(id: string, limit?: number, _options?: Configuration): Promise<AppScreenshotSetAppScreenshotsLinkagesResponse> {
        const result = this.api.appScreenshotSetsAppScreenshotsGetToManyRelationship(id, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param appScreenshotSetAppScreenshotsLinkagesRequest List of related linkages
     */
    public appScreenshotSetsAppScreenshotsReplaceToManyRelationshipWithHttpInfo(id: string, appScreenshotSetAppScreenshotsLinkagesRequest: AppScreenshotSetAppScreenshotsLinkagesRequest, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.appScreenshotSetsAppScreenshotsReplaceToManyRelationshipWithHttpInfo(id, appScreenshotSetAppScreenshotsLinkagesRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param appScreenshotSetAppScreenshotsLinkagesRequest List of related linkages
     */
    public appScreenshotSetsAppScreenshotsReplaceToManyRelationship(id: string, appScreenshotSetAppScreenshotsLinkagesRequest: AppScreenshotSetAppScreenshotsLinkagesRequest, _options?: Configuration): Promise<void> {
        const result = this.api.appScreenshotSetsAppScreenshotsReplaceToManyRelationship(id, appScreenshotSetAppScreenshotsLinkagesRequest, _options);
        return result.toPromise();
    }

    /**
     * @param appScreenshotSetCreateRequest AppScreenshotSet representation
     */
    public appScreenshotSetsCreateInstanceWithHttpInfo(appScreenshotSetCreateRequest: AppScreenshotSetCreateRequest, _options?: Configuration): Promise<HttpInfo<AppScreenshotSetResponse>> {
        const result = this.api.appScreenshotSetsCreateInstanceWithHttpInfo(appScreenshotSetCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param appScreenshotSetCreateRequest AppScreenshotSet representation
     */
    public appScreenshotSetsCreateInstance(appScreenshotSetCreateRequest: AppScreenshotSetCreateRequest, _options?: Configuration): Promise<AppScreenshotSetResponse> {
        const result = this.api.appScreenshotSetsCreateInstance(appScreenshotSetCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public appScreenshotSetsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.appScreenshotSetsDeleteInstanceWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public appScreenshotSetsDeleteInstance(id: string, _options?: Configuration): Promise<void> {
        const result = this.api.appScreenshotSetsDeleteInstance(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppScreenshotSets the fields to include for returned resources of type appScreenshotSets
     * @param include comma-separated list of relationships to include
     * @param fieldsAppScreenshots the fields to include for returned resources of type appScreenshots
     * @param limitAppScreenshots maximum number of related appScreenshots returned (when they are included)
     */
    public appScreenshotSetsGetInstanceWithHttpInfo(id: string, fieldsAppScreenshotSets?: Array<'appCustomProductPageLocalization' | 'appScreenshots' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'screenshotDisplayType'>, include?: Array<'appCustomProductPageLocalization' | 'appScreenshots' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization'>, fieldsAppScreenshots?: Array<'appScreenshotSet' | 'assetDeliveryState' | 'assetToken' | 'assetType' | 'fileName' | 'fileSize' | 'imageAsset' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, limitAppScreenshots?: number, _options?: Configuration): Promise<HttpInfo<AppScreenshotSetResponse>> {
        const result = this.api.appScreenshotSetsGetInstanceWithHttpInfo(id, fieldsAppScreenshotSets, include, fieldsAppScreenshots, limitAppScreenshots, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppScreenshotSets the fields to include for returned resources of type appScreenshotSets
     * @param include comma-separated list of relationships to include
     * @param fieldsAppScreenshots the fields to include for returned resources of type appScreenshots
     * @param limitAppScreenshots maximum number of related appScreenshots returned (when they are included)
     */
    public appScreenshotSetsGetInstance(id: string, fieldsAppScreenshotSets?: Array<'appCustomProductPageLocalization' | 'appScreenshots' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'screenshotDisplayType'>, include?: Array<'appCustomProductPageLocalization' | 'appScreenshots' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization'>, fieldsAppScreenshots?: Array<'appScreenshotSet' | 'assetDeliveryState' | 'assetToken' | 'assetType' | 'fileName' | 'fileSize' | 'imageAsset' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, limitAppScreenshots?: number, _options?: Configuration): Promise<AppScreenshotSetResponse> {
        const result = this.api.appScreenshotSetsGetInstance(id, fieldsAppScreenshotSets, include, fieldsAppScreenshots, limitAppScreenshots, _options);
        return result.toPromise();
    }


}



import { ObservableAppScreenshotsApi } from './ObservableAPI.ts';

import { AppScreenshotsApiRequestFactory, AppScreenshotsApiResponseProcessor} from "../apis/AppScreenshotsApi.ts";
export class PromiseAppScreenshotsApi {
    private api: ObservableAppScreenshotsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: AppScreenshotsApiRequestFactory,
        responseProcessor?: AppScreenshotsApiResponseProcessor
    ) {
        this.api = new ObservableAppScreenshotsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param appScreenshotCreateRequest AppScreenshot representation
     */
    public appScreenshotsCreateInstanceWithHttpInfo(appScreenshotCreateRequest: AppScreenshotCreateRequest, _options?: Configuration): Promise<HttpInfo<AppScreenshotResponse>> {
        const result = this.api.appScreenshotsCreateInstanceWithHttpInfo(appScreenshotCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param appScreenshotCreateRequest AppScreenshot representation
     */
    public appScreenshotsCreateInstance(appScreenshotCreateRequest: AppScreenshotCreateRequest, _options?: Configuration): Promise<AppScreenshotResponse> {
        const result = this.api.appScreenshotsCreateInstance(appScreenshotCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public appScreenshotsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.appScreenshotsDeleteInstanceWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public appScreenshotsDeleteInstance(id: string, _options?: Configuration): Promise<void> {
        const result = this.api.appScreenshotsDeleteInstance(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppScreenshots the fields to include for returned resources of type appScreenshots
     * @param include comma-separated list of relationships to include
     */
    public appScreenshotsGetInstanceWithHttpInfo(id: string, fieldsAppScreenshots?: Array<'appScreenshotSet' | 'assetDeliveryState' | 'assetToken' | 'assetType' | 'fileName' | 'fileSize' | 'imageAsset' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, include?: Array<'appScreenshotSet'>, _options?: Configuration): Promise<HttpInfo<AppScreenshotResponse>> {
        const result = this.api.appScreenshotsGetInstanceWithHttpInfo(id, fieldsAppScreenshots, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppScreenshots the fields to include for returned resources of type appScreenshots
     * @param include comma-separated list of relationships to include
     */
    public appScreenshotsGetInstance(id: string, fieldsAppScreenshots?: Array<'appScreenshotSet' | 'assetDeliveryState' | 'assetToken' | 'assetType' | 'fileName' | 'fileSize' | 'imageAsset' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, include?: Array<'appScreenshotSet'>, _options?: Configuration): Promise<AppScreenshotResponse> {
        const result = this.api.appScreenshotsGetInstance(id, fieldsAppScreenshots, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param appScreenshotUpdateRequest AppScreenshot representation
     */
    public appScreenshotsUpdateInstanceWithHttpInfo(id: string, appScreenshotUpdateRequest: AppScreenshotUpdateRequest, _options?: Configuration): Promise<HttpInfo<AppScreenshotResponse>> {
        const result = this.api.appScreenshotsUpdateInstanceWithHttpInfo(id, appScreenshotUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param appScreenshotUpdateRequest AppScreenshot representation
     */
    public appScreenshotsUpdateInstance(id: string, appScreenshotUpdateRequest: AppScreenshotUpdateRequest, _options?: Configuration): Promise<AppScreenshotResponse> {
        const result = this.api.appScreenshotsUpdateInstance(id, appScreenshotUpdateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableAppStoreReviewAttachmentsApi } from './ObservableAPI.ts';

import { AppStoreReviewAttachmentsApiRequestFactory, AppStoreReviewAttachmentsApiResponseProcessor} from "../apis/AppStoreReviewAttachmentsApi.ts";
export class PromiseAppStoreReviewAttachmentsApi {
    private api: ObservableAppStoreReviewAttachmentsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: AppStoreReviewAttachmentsApiRequestFactory,
        responseProcessor?: AppStoreReviewAttachmentsApiResponseProcessor
    ) {
        this.api = new ObservableAppStoreReviewAttachmentsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param appStoreReviewAttachmentCreateRequest AppStoreReviewAttachment representation
     */
    public appStoreReviewAttachmentsCreateInstanceWithHttpInfo(appStoreReviewAttachmentCreateRequest: AppStoreReviewAttachmentCreateRequest, _options?: Configuration): Promise<HttpInfo<AppStoreReviewAttachmentResponse>> {
        const result = this.api.appStoreReviewAttachmentsCreateInstanceWithHttpInfo(appStoreReviewAttachmentCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param appStoreReviewAttachmentCreateRequest AppStoreReviewAttachment representation
     */
    public appStoreReviewAttachmentsCreateInstance(appStoreReviewAttachmentCreateRequest: AppStoreReviewAttachmentCreateRequest, _options?: Configuration): Promise<AppStoreReviewAttachmentResponse> {
        const result = this.api.appStoreReviewAttachmentsCreateInstance(appStoreReviewAttachmentCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public appStoreReviewAttachmentsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.appStoreReviewAttachmentsDeleteInstanceWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public appStoreReviewAttachmentsDeleteInstance(id: string, _options?: Configuration): Promise<void> {
        const result = this.api.appStoreReviewAttachmentsDeleteInstance(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppStoreReviewAttachments the fields to include for returned resources of type appStoreReviewAttachments
     * @param include comma-separated list of relationships to include
     */
    public appStoreReviewAttachmentsGetInstanceWithHttpInfo(id: string, fieldsAppStoreReviewAttachments?: Array<'appStoreReviewDetail' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, include?: Array<'appStoreReviewDetail'>, _options?: Configuration): Promise<HttpInfo<AppStoreReviewAttachmentResponse>> {
        const result = this.api.appStoreReviewAttachmentsGetInstanceWithHttpInfo(id, fieldsAppStoreReviewAttachments, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppStoreReviewAttachments the fields to include for returned resources of type appStoreReviewAttachments
     * @param include comma-separated list of relationships to include
     */
    public appStoreReviewAttachmentsGetInstance(id: string, fieldsAppStoreReviewAttachments?: Array<'appStoreReviewDetail' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, include?: Array<'appStoreReviewDetail'>, _options?: Configuration): Promise<AppStoreReviewAttachmentResponse> {
        const result = this.api.appStoreReviewAttachmentsGetInstance(id, fieldsAppStoreReviewAttachments, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param appStoreReviewAttachmentUpdateRequest AppStoreReviewAttachment representation
     */
    public appStoreReviewAttachmentsUpdateInstanceWithHttpInfo(id: string, appStoreReviewAttachmentUpdateRequest: AppStoreReviewAttachmentUpdateRequest, _options?: Configuration): Promise<HttpInfo<AppStoreReviewAttachmentResponse>> {
        const result = this.api.appStoreReviewAttachmentsUpdateInstanceWithHttpInfo(id, appStoreReviewAttachmentUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param appStoreReviewAttachmentUpdateRequest AppStoreReviewAttachment representation
     */
    public appStoreReviewAttachmentsUpdateInstance(id: string, appStoreReviewAttachmentUpdateRequest: AppStoreReviewAttachmentUpdateRequest, _options?: Configuration): Promise<AppStoreReviewAttachmentResponse> {
        const result = this.api.appStoreReviewAttachmentsUpdateInstance(id, appStoreReviewAttachmentUpdateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableAppStoreReviewDetailsApi } from './ObservableAPI.ts';

import { AppStoreReviewDetailsApiRequestFactory, AppStoreReviewDetailsApiResponseProcessor} from "../apis/AppStoreReviewDetailsApi.ts";
export class PromiseAppStoreReviewDetailsApi {
    private api: ObservableAppStoreReviewDetailsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: AppStoreReviewDetailsApiRequestFactory,
        responseProcessor?: AppStoreReviewDetailsApiResponseProcessor
    ) {
        this.api = new ObservableAppStoreReviewDetailsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppStoreReviewDetails the fields to include for returned resources of type appStoreReviewDetails
     * @param fieldsAppStoreReviewAttachments the fields to include for returned resources of type appStoreReviewAttachments
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public appStoreReviewDetailsAppStoreReviewAttachmentsGetToManyRelatedWithHttpInfo(id: string, fieldsAppStoreReviewDetails?: Array<'appStoreReviewAttachments' | 'appStoreVersion' | 'contactEmail' | 'contactFirstName' | 'contactLastName' | 'contactPhone' | 'demoAccountName' | 'demoAccountPassword' | 'demoAccountRequired' | 'notes'>, fieldsAppStoreReviewAttachments?: Array<'appStoreReviewDetail' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, limit?: number, include?: Array<'appStoreReviewDetail'>, _options?: Configuration): Promise<HttpInfo<AppStoreReviewAttachmentsResponse>> {
        const result = this.api.appStoreReviewDetailsAppStoreReviewAttachmentsGetToManyRelatedWithHttpInfo(id, fieldsAppStoreReviewDetails, fieldsAppStoreReviewAttachments, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppStoreReviewDetails the fields to include for returned resources of type appStoreReviewDetails
     * @param fieldsAppStoreReviewAttachments the fields to include for returned resources of type appStoreReviewAttachments
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public appStoreReviewDetailsAppStoreReviewAttachmentsGetToManyRelated(id: string, fieldsAppStoreReviewDetails?: Array<'appStoreReviewAttachments' | 'appStoreVersion' | 'contactEmail' | 'contactFirstName' | 'contactLastName' | 'contactPhone' | 'demoAccountName' | 'demoAccountPassword' | 'demoAccountRequired' | 'notes'>, fieldsAppStoreReviewAttachments?: Array<'appStoreReviewDetail' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, limit?: number, include?: Array<'appStoreReviewDetail'>, _options?: Configuration): Promise<AppStoreReviewAttachmentsResponse> {
        const result = this.api.appStoreReviewDetailsAppStoreReviewAttachmentsGetToManyRelated(id, fieldsAppStoreReviewDetails, fieldsAppStoreReviewAttachments, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param appStoreReviewDetailCreateRequest AppStoreReviewDetail representation
     */
    public appStoreReviewDetailsCreateInstanceWithHttpInfo(appStoreReviewDetailCreateRequest: AppStoreReviewDetailCreateRequest, _options?: Configuration): Promise<HttpInfo<AppStoreReviewDetailResponse>> {
        const result = this.api.appStoreReviewDetailsCreateInstanceWithHttpInfo(appStoreReviewDetailCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param appStoreReviewDetailCreateRequest AppStoreReviewDetail representation
     */
    public appStoreReviewDetailsCreateInstance(appStoreReviewDetailCreateRequest: AppStoreReviewDetailCreateRequest, _options?: Configuration): Promise<AppStoreReviewDetailResponse> {
        const result = this.api.appStoreReviewDetailsCreateInstance(appStoreReviewDetailCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppStoreReviewDetails the fields to include for returned resources of type appStoreReviewDetails
     * @param include comma-separated list of relationships to include
     * @param fieldsAppStoreReviewAttachments the fields to include for returned resources of type appStoreReviewAttachments
     * @param limitAppStoreReviewAttachments maximum number of related appStoreReviewAttachments returned (when they are included)
     */
    public appStoreReviewDetailsGetInstanceWithHttpInfo(id: string, fieldsAppStoreReviewDetails?: Array<'appStoreReviewAttachments' | 'appStoreVersion' | 'contactEmail' | 'contactFirstName' | 'contactLastName' | 'contactPhone' | 'demoAccountName' | 'demoAccountPassword' | 'demoAccountRequired' | 'notes'>, include?: Array<'appStoreReviewAttachments' | 'appStoreVersion'>, fieldsAppStoreReviewAttachments?: Array<'appStoreReviewDetail' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, limitAppStoreReviewAttachments?: number, _options?: Configuration): Promise<HttpInfo<AppStoreReviewDetailResponse>> {
        const result = this.api.appStoreReviewDetailsGetInstanceWithHttpInfo(id, fieldsAppStoreReviewDetails, include, fieldsAppStoreReviewAttachments, limitAppStoreReviewAttachments, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppStoreReviewDetails the fields to include for returned resources of type appStoreReviewDetails
     * @param include comma-separated list of relationships to include
     * @param fieldsAppStoreReviewAttachments the fields to include for returned resources of type appStoreReviewAttachments
     * @param limitAppStoreReviewAttachments maximum number of related appStoreReviewAttachments returned (when they are included)
     */
    public appStoreReviewDetailsGetInstance(id: string, fieldsAppStoreReviewDetails?: Array<'appStoreReviewAttachments' | 'appStoreVersion' | 'contactEmail' | 'contactFirstName' | 'contactLastName' | 'contactPhone' | 'demoAccountName' | 'demoAccountPassword' | 'demoAccountRequired' | 'notes'>, include?: Array<'appStoreReviewAttachments' | 'appStoreVersion'>, fieldsAppStoreReviewAttachments?: Array<'appStoreReviewDetail' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, limitAppStoreReviewAttachments?: number, _options?: Configuration): Promise<AppStoreReviewDetailResponse> {
        const result = this.api.appStoreReviewDetailsGetInstance(id, fieldsAppStoreReviewDetails, include, fieldsAppStoreReviewAttachments, limitAppStoreReviewAttachments, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param appStoreReviewDetailUpdateRequest AppStoreReviewDetail representation
     */
    public appStoreReviewDetailsUpdateInstanceWithHttpInfo(id: string, appStoreReviewDetailUpdateRequest: AppStoreReviewDetailUpdateRequest, _options?: Configuration): Promise<HttpInfo<AppStoreReviewDetailResponse>> {
        const result = this.api.appStoreReviewDetailsUpdateInstanceWithHttpInfo(id, appStoreReviewDetailUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param appStoreReviewDetailUpdateRequest AppStoreReviewDetail representation
     */
    public appStoreReviewDetailsUpdateInstance(id: string, appStoreReviewDetailUpdateRequest: AppStoreReviewDetailUpdateRequest, _options?: Configuration): Promise<AppStoreReviewDetailResponse> {
        const result = this.api.appStoreReviewDetailsUpdateInstance(id, appStoreReviewDetailUpdateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableAppStoreVersionExperimentTreatmentLocalizationsApi } from './ObservableAPI.ts';

import { AppStoreVersionExperimentTreatmentLocalizationsApiRequestFactory, AppStoreVersionExperimentTreatmentLocalizationsApiResponseProcessor} from "../apis/AppStoreVersionExperimentTreatmentLocalizationsApi.ts";
export class PromiseAppStoreVersionExperimentTreatmentLocalizationsApi {
    private api: ObservableAppStoreVersionExperimentTreatmentLocalizationsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: AppStoreVersionExperimentTreatmentLocalizationsApiRequestFactory,
        responseProcessor?: AppStoreVersionExperimentTreatmentLocalizationsApiResponseProcessor
    ) {
        this.api = new ObservableAppStoreVersionExperimentTreatmentLocalizationsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param id the id of the requested resource
     * @param filterPreviewType filter by attribute \&#39;previewType\&#39;
     * @param filterAppCustomProductPageLocalization filter by id(s) of related \&#39;appCustomProductPageLocalization\&#39;
     * @param filterAppStoreVersionLocalization filter by id(s) of related \&#39;appStoreVersionLocalization\&#39;
     * @param fieldsAppCustomProductPageLocalizations the fields to include for returned resources of type appCustomProductPageLocalizations
     * @param fieldsAppStoreVersionExperimentTreatmentLocalizations the fields to include for returned resources of type appStoreVersionExperimentTreatmentLocalizations
     * @param fieldsAppPreviews the fields to include for returned resources of type appPreviews
     * @param fieldsAppPreviewSets the fields to include for returned resources of type appPreviewSets
     * @param fieldsAppStoreVersionLocalizations the fields to include for returned resources of type appStoreVersionLocalizations
     * @param limit maximum resources per page
     * @param limitAppPreviews maximum number of related appPreviews returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appStoreVersionExperimentTreatmentLocalizationsAppPreviewSetsGetToManyRelatedWithHttpInfo(id: string, filterPreviewType?: Array<'IPHONE_67' | 'IPHONE_61' | 'IPHONE_65' | 'IPHONE_58' | 'IPHONE_55' | 'IPHONE_47' | 'IPHONE_40' | 'IPHONE_35' | 'IPAD_PRO_3GEN_129' | 'IPAD_PRO_3GEN_11' | 'IPAD_PRO_129' | 'IPAD_105' | 'IPAD_97' | 'DESKTOP' | 'APPLE_TV' | 'APPLE_VISION_PRO'>, filterAppCustomProductPageLocalization?: Array<string>, filterAppStoreVersionLocalization?: Array<string>, fieldsAppCustomProductPageLocalizations?: Array<'appCustomProductPageVersion' | 'appPreviewSets' | 'appScreenshotSets' | 'locale' | 'promotionalText'>, fieldsAppStoreVersionExperimentTreatmentLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersionExperimentTreatment' | 'locale'>, fieldsAppPreviews?: Array<'appPreviewSet' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'mimeType' | 'previewFrameTimeCode' | 'previewImage' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded' | 'videoUrl'>, fieldsAppPreviewSets?: Array<'appCustomProductPageLocalization' | 'appPreviews' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'previewType'>, fieldsAppStoreVersionLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersion' | 'description' | 'keywords' | 'locale' | 'marketingUrl' | 'promotionalText' | 'supportUrl' | 'whatsNew'>, limit?: number, limitAppPreviews?: number, include?: Array<'appCustomProductPageLocalization' | 'appPreviews' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization'>, _options?: Configuration): Promise<HttpInfo<AppPreviewSetsResponse>> {
        const result = this.api.appStoreVersionExperimentTreatmentLocalizationsAppPreviewSetsGetToManyRelatedWithHttpInfo(id, filterPreviewType, filterAppCustomProductPageLocalization, filterAppStoreVersionLocalization, fieldsAppCustomProductPageLocalizations, fieldsAppStoreVersionExperimentTreatmentLocalizations, fieldsAppPreviews, fieldsAppPreviewSets, fieldsAppStoreVersionLocalizations, limit, limitAppPreviews, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterPreviewType filter by attribute \&#39;previewType\&#39;
     * @param filterAppCustomProductPageLocalization filter by id(s) of related \&#39;appCustomProductPageLocalization\&#39;
     * @param filterAppStoreVersionLocalization filter by id(s) of related \&#39;appStoreVersionLocalization\&#39;
     * @param fieldsAppCustomProductPageLocalizations the fields to include for returned resources of type appCustomProductPageLocalizations
     * @param fieldsAppStoreVersionExperimentTreatmentLocalizations the fields to include for returned resources of type appStoreVersionExperimentTreatmentLocalizations
     * @param fieldsAppPreviews the fields to include for returned resources of type appPreviews
     * @param fieldsAppPreviewSets the fields to include for returned resources of type appPreviewSets
     * @param fieldsAppStoreVersionLocalizations the fields to include for returned resources of type appStoreVersionLocalizations
     * @param limit maximum resources per page
     * @param limitAppPreviews maximum number of related appPreviews returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appStoreVersionExperimentTreatmentLocalizationsAppPreviewSetsGetToManyRelated(id: string, filterPreviewType?: Array<'IPHONE_67' | 'IPHONE_61' | 'IPHONE_65' | 'IPHONE_58' | 'IPHONE_55' | 'IPHONE_47' | 'IPHONE_40' | 'IPHONE_35' | 'IPAD_PRO_3GEN_129' | 'IPAD_PRO_3GEN_11' | 'IPAD_PRO_129' | 'IPAD_105' | 'IPAD_97' | 'DESKTOP' | 'APPLE_TV' | 'APPLE_VISION_PRO'>, filterAppCustomProductPageLocalization?: Array<string>, filterAppStoreVersionLocalization?: Array<string>, fieldsAppCustomProductPageLocalizations?: Array<'appCustomProductPageVersion' | 'appPreviewSets' | 'appScreenshotSets' | 'locale' | 'promotionalText'>, fieldsAppStoreVersionExperimentTreatmentLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersionExperimentTreatment' | 'locale'>, fieldsAppPreviews?: Array<'appPreviewSet' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'mimeType' | 'previewFrameTimeCode' | 'previewImage' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded' | 'videoUrl'>, fieldsAppPreviewSets?: Array<'appCustomProductPageLocalization' | 'appPreviews' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'previewType'>, fieldsAppStoreVersionLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersion' | 'description' | 'keywords' | 'locale' | 'marketingUrl' | 'promotionalText' | 'supportUrl' | 'whatsNew'>, limit?: number, limitAppPreviews?: number, include?: Array<'appCustomProductPageLocalization' | 'appPreviews' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization'>, _options?: Configuration): Promise<AppPreviewSetsResponse> {
        const result = this.api.appStoreVersionExperimentTreatmentLocalizationsAppPreviewSetsGetToManyRelated(id, filterPreviewType, filterAppCustomProductPageLocalization, filterAppStoreVersionLocalization, fieldsAppCustomProductPageLocalizations, fieldsAppStoreVersionExperimentTreatmentLocalizations, fieldsAppPreviews, fieldsAppPreviewSets, fieldsAppStoreVersionLocalizations, limit, limitAppPreviews, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterScreenshotDisplayType filter by attribute \&#39;screenshotDisplayType\&#39;
     * @param filterAppCustomProductPageLocalization filter by id(s) of related \&#39;appCustomProductPageLocalization\&#39;
     * @param filterAppStoreVersionLocalization filter by id(s) of related \&#39;appStoreVersionLocalization\&#39;
     * @param fieldsAppScreenshotSets the fields to include for returned resources of type appScreenshotSets
     * @param fieldsAppCustomProductPageLocalizations the fields to include for returned resources of type appCustomProductPageLocalizations
     * @param fieldsAppStoreVersionExperimentTreatmentLocalizations the fields to include for returned resources of type appStoreVersionExperimentTreatmentLocalizations
     * @param fieldsAppScreenshots the fields to include for returned resources of type appScreenshots
     * @param fieldsAppStoreVersionLocalizations the fields to include for returned resources of type appStoreVersionLocalizations
     * @param limit maximum resources per page
     * @param limitAppScreenshots maximum number of related appScreenshots returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appStoreVersionExperimentTreatmentLocalizationsAppScreenshotSetsGetToManyRelatedWithHttpInfo(id: string, filterScreenshotDisplayType?: Array<'APP_IPHONE_67' | 'APP_IPHONE_61' | 'APP_IPHONE_65' | 'APP_IPHONE_58' | 'APP_IPHONE_55' | 'APP_IPHONE_47' | 'APP_IPHONE_40' | 'APP_IPHONE_35' | 'APP_IPAD_PRO_3GEN_129' | 'APP_IPAD_PRO_3GEN_11' | 'APP_IPAD_PRO_129' | 'APP_IPAD_105' | 'APP_IPAD_97' | 'APP_DESKTOP' | 'APP_WATCH_ULTRA' | 'APP_WATCH_SERIES_7' | 'APP_WATCH_SERIES_4' | 'APP_WATCH_SERIES_3' | 'APP_APPLE_TV' | 'APP_APPLE_VISION_PRO' | 'IMESSAGE_APP_IPHONE_67' | 'IMESSAGE_APP_IPHONE_61' | 'IMESSAGE_APP_IPHONE_65' | 'IMESSAGE_APP_IPHONE_58' | 'IMESSAGE_APP_IPHONE_55' | 'IMESSAGE_APP_IPHONE_47' | 'IMESSAGE_APP_IPHONE_40' | 'IMESSAGE_APP_IPAD_PRO_3GEN_129' | 'IMESSAGE_APP_IPAD_PRO_3GEN_11' | 'IMESSAGE_APP_IPAD_PRO_129' | 'IMESSAGE_APP_IPAD_105' | 'IMESSAGE_APP_IPAD_97'>, filterAppCustomProductPageLocalization?: Array<string>, filterAppStoreVersionLocalization?: Array<string>, fieldsAppScreenshotSets?: Array<'appCustomProductPageLocalization' | 'appScreenshots' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'screenshotDisplayType'>, fieldsAppCustomProductPageLocalizations?: Array<'appCustomProductPageVersion' | 'appPreviewSets' | 'appScreenshotSets' | 'locale' | 'promotionalText'>, fieldsAppStoreVersionExperimentTreatmentLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersionExperimentTreatment' | 'locale'>, fieldsAppScreenshots?: Array<'appScreenshotSet' | 'assetDeliveryState' | 'assetToken' | 'assetType' | 'fileName' | 'fileSize' | 'imageAsset' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, fieldsAppStoreVersionLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersion' | 'description' | 'keywords' | 'locale' | 'marketingUrl' | 'promotionalText' | 'supportUrl' | 'whatsNew'>, limit?: number, limitAppScreenshots?: number, include?: Array<'appCustomProductPageLocalization' | 'appScreenshots' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization'>, _options?: Configuration): Promise<HttpInfo<AppScreenshotSetsResponse>> {
        const result = this.api.appStoreVersionExperimentTreatmentLocalizationsAppScreenshotSetsGetToManyRelatedWithHttpInfo(id, filterScreenshotDisplayType, filterAppCustomProductPageLocalization, filterAppStoreVersionLocalization, fieldsAppScreenshotSets, fieldsAppCustomProductPageLocalizations, fieldsAppStoreVersionExperimentTreatmentLocalizations, fieldsAppScreenshots, fieldsAppStoreVersionLocalizations, limit, limitAppScreenshots, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterScreenshotDisplayType filter by attribute \&#39;screenshotDisplayType\&#39;
     * @param filterAppCustomProductPageLocalization filter by id(s) of related \&#39;appCustomProductPageLocalization\&#39;
     * @param filterAppStoreVersionLocalization filter by id(s) of related \&#39;appStoreVersionLocalization\&#39;
     * @param fieldsAppScreenshotSets the fields to include for returned resources of type appScreenshotSets
     * @param fieldsAppCustomProductPageLocalizations the fields to include for returned resources of type appCustomProductPageLocalizations
     * @param fieldsAppStoreVersionExperimentTreatmentLocalizations the fields to include for returned resources of type appStoreVersionExperimentTreatmentLocalizations
     * @param fieldsAppScreenshots the fields to include for returned resources of type appScreenshots
     * @param fieldsAppStoreVersionLocalizations the fields to include for returned resources of type appStoreVersionLocalizations
     * @param limit maximum resources per page
     * @param limitAppScreenshots maximum number of related appScreenshots returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appStoreVersionExperimentTreatmentLocalizationsAppScreenshotSetsGetToManyRelated(id: string, filterScreenshotDisplayType?: Array<'APP_IPHONE_67' | 'APP_IPHONE_61' | 'APP_IPHONE_65' | 'APP_IPHONE_58' | 'APP_IPHONE_55' | 'APP_IPHONE_47' | 'APP_IPHONE_40' | 'APP_IPHONE_35' | 'APP_IPAD_PRO_3GEN_129' | 'APP_IPAD_PRO_3GEN_11' | 'APP_IPAD_PRO_129' | 'APP_IPAD_105' | 'APP_IPAD_97' | 'APP_DESKTOP' | 'APP_WATCH_ULTRA' | 'APP_WATCH_SERIES_7' | 'APP_WATCH_SERIES_4' | 'APP_WATCH_SERIES_3' | 'APP_APPLE_TV' | 'APP_APPLE_VISION_PRO' | 'IMESSAGE_APP_IPHONE_67' | 'IMESSAGE_APP_IPHONE_61' | 'IMESSAGE_APP_IPHONE_65' | 'IMESSAGE_APP_IPHONE_58' | 'IMESSAGE_APP_IPHONE_55' | 'IMESSAGE_APP_IPHONE_47' | 'IMESSAGE_APP_IPHONE_40' | 'IMESSAGE_APP_IPAD_PRO_3GEN_129' | 'IMESSAGE_APP_IPAD_PRO_3GEN_11' | 'IMESSAGE_APP_IPAD_PRO_129' | 'IMESSAGE_APP_IPAD_105' | 'IMESSAGE_APP_IPAD_97'>, filterAppCustomProductPageLocalization?: Array<string>, filterAppStoreVersionLocalization?: Array<string>, fieldsAppScreenshotSets?: Array<'appCustomProductPageLocalization' | 'appScreenshots' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'screenshotDisplayType'>, fieldsAppCustomProductPageLocalizations?: Array<'appCustomProductPageVersion' | 'appPreviewSets' | 'appScreenshotSets' | 'locale' | 'promotionalText'>, fieldsAppStoreVersionExperimentTreatmentLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersionExperimentTreatment' | 'locale'>, fieldsAppScreenshots?: Array<'appScreenshotSet' | 'assetDeliveryState' | 'assetToken' | 'assetType' | 'fileName' | 'fileSize' | 'imageAsset' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, fieldsAppStoreVersionLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersion' | 'description' | 'keywords' | 'locale' | 'marketingUrl' | 'promotionalText' | 'supportUrl' | 'whatsNew'>, limit?: number, limitAppScreenshots?: number, include?: Array<'appCustomProductPageLocalization' | 'appScreenshots' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization'>, _options?: Configuration): Promise<AppScreenshotSetsResponse> {
        const result = this.api.appStoreVersionExperimentTreatmentLocalizationsAppScreenshotSetsGetToManyRelated(id, filterScreenshotDisplayType, filterAppCustomProductPageLocalization, filterAppStoreVersionLocalization, fieldsAppScreenshotSets, fieldsAppCustomProductPageLocalizations, fieldsAppStoreVersionExperimentTreatmentLocalizations, fieldsAppScreenshots, fieldsAppStoreVersionLocalizations, limit, limitAppScreenshots, include, _options);
        return result.toPromise();
    }

    /**
     * @param appStoreVersionExperimentTreatmentLocalizationCreateRequest AppStoreVersionExperimentTreatmentLocalization representation
     */
    public appStoreVersionExperimentTreatmentLocalizationsCreateInstanceWithHttpInfo(appStoreVersionExperimentTreatmentLocalizationCreateRequest: AppStoreVersionExperimentTreatmentLocalizationCreateRequest, _options?: Configuration): Promise<HttpInfo<AppStoreVersionExperimentTreatmentLocalizationResponse>> {
        const result = this.api.appStoreVersionExperimentTreatmentLocalizationsCreateInstanceWithHttpInfo(appStoreVersionExperimentTreatmentLocalizationCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param appStoreVersionExperimentTreatmentLocalizationCreateRequest AppStoreVersionExperimentTreatmentLocalization representation
     */
    public appStoreVersionExperimentTreatmentLocalizationsCreateInstance(appStoreVersionExperimentTreatmentLocalizationCreateRequest: AppStoreVersionExperimentTreatmentLocalizationCreateRequest, _options?: Configuration): Promise<AppStoreVersionExperimentTreatmentLocalizationResponse> {
        const result = this.api.appStoreVersionExperimentTreatmentLocalizationsCreateInstance(appStoreVersionExperimentTreatmentLocalizationCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public appStoreVersionExperimentTreatmentLocalizationsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.appStoreVersionExperimentTreatmentLocalizationsDeleteInstanceWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public appStoreVersionExperimentTreatmentLocalizationsDeleteInstance(id: string, _options?: Configuration): Promise<void> {
        const result = this.api.appStoreVersionExperimentTreatmentLocalizationsDeleteInstance(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppStoreVersionExperimentTreatmentLocalizations the fields to include for returned resources of type appStoreVersionExperimentTreatmentLocalizations
     * @param include comma-separated list of relationships to include
     * @param fieldsAppScreenshotSets the fields to include for returned resources of type appScreenshotSets
     * @param fieldsAppPreviewSets the fields to include for returned resources of type appPreviewSets
     * @param limitAppPreviewSets maximum number of related appPreviewSets returned (when they are included)
     * @param limitAppScreenshotSets maximum number of related appScreenshotSets returned (when they are included)
     */
    public appStoreVersionExperimentTreatmentLocalizationsGetInstanceWithHttpInfo(id: string, fieldsAppStoreVersionExperimentTreatmentLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersionExperimentTreatment' | 'locale'>, include?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersionExperimentTreatment'>, fieldsAppScreenshotSets?: Array<'appCustomProductPageLocalization' | 'appScreenshots' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'screenshotDisplayType'>, fieldsAppPreviewSets?: Array<'appCustomProductPageLocalization' | 'appPreviews' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'previewType'>, limitAppPreviewSets?: number, limitAppScreenshotSets?: number, _options?: Configuration): Promise<HttpInfo<AppStoreVersionExperimentTreatmentLocalizationResponse>> {
        const result = this.api.appStoreVersionExperimentTreatmentLocalizationsGetInstanceWithHttpInfo(id, fieldsAppStoreVersionExperimentTreatmentLocalizations, include, fieldsAppScreenshotSets, fieldsAppPreviewSets, limitAppPreviewSets, limitAppScreenshotSets, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppStoreVersionExperimentTreatmentLocalizations the fields to include for returned resources of type appStoreVersionExperimentTreatmentLocalizations
     * @param include comma-separated list of relationships to include
     * @param fieldsAppScreenshotSets the fields to include for returned resources of type appScreenshotSets
     * @param fieldsAppPreviewSets the fields to include for returned resources of type appPreviewSets
     * @param limitAppPreviewSets maximum number of related appPreviewSets returned (when they are included)
     * @param limitAppScreenshotSets maximum number of related appScreenshotSets returned (when they are included)
     */
    public appStoreVersionExperimentTreatmentLocalizationsGetInstance(id: string, fieldsAppStoreVersionExperimentTreatmentLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersionExperimentTreatment' | 'locale'>, include?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersionExperimentTreatment'>, fieldsAppScreenshotSets?: Array<'appCustomProductPageLocalization' | 'appScreenshots' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'screenshotDisplayType'>, fieldsAppPreviewSets?: Array<'appCustomProductPageLocalization' | 'appPreviews' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'previewType'>, limitAppPreviewSets?: number, limitAppScreenshotSets?: number, _options?: Configuration): Promise<AppStoreVersionExperimentTreatmentLocalizationResponse> {
        const result = this.api.appStoreVersionExperimentTreatmentLocalizationsGetInstance(id, fieldsAppStoreVersionExperimentTreatmentLocalizations, include, fieldsAppScreenshotSets, fieldsAppPreviewSets, limitAppPreviewSets, limitAppScreenshotSets, _options);
        return result.toPromise();
    }


}



import { ObservableAppStoreVersionExperimentTreatmentsApi } from './ObservableAPI.ts';

import { AppStoreVersionExperimentTreatmentsApiRequestFactory, AppStoreVersionExperimentTreatmentsApiResponseProcessor} from "../apis/AppStoreVersionExperimentTreatmentsApi.ts";
export class PromiseAppStoreVersionExperimentTreatmentsApi {
    private api: ObservableAppStoreVersionExperimentTreatmentsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: AppStoreVersionExperimentTreatmentsApiRequestFactory,
        responseProcessor?: AppStoreVersionExperimentTreatmentsApiResponseProcessor
    ) {
        this.api = new ObservableAppStoreVersionExperimentTreatmentsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param id the id of the requested resource
     * @param filterLocale filter by attribute \&#39;locale\&#39;
     * @param fieldsAppScreenshotSets the fields to include for returned resources of type appScreenshotSets
     * @param fieldsAppStoreVersionExperimentTreatments the fields to include for returned resources of type appStoreVersionExperimentTreatments
     * @param fieldsAppStoreVersionExperimentTreatmentLocalizations the fields to include for returned resources of type appStoreVersionExperimentTreatmentLocalizations
     * @param fieldsAppPreviewSets the fields to include for returned resources of type appPreviewSets
     * @param limit maximum resources per page
     * @param limitAppScreenshotSets maximum number of related appScreenshotSets returned (when they are included)
     * @param limitAppPreviewSets maximum number of related appPreviewSets returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appStoreVersionExperimentTreatmentsAppStoreVersionExperimentTreatmentLocalizationsGetToManyRelatedWithHttpInfo(id: string, filterLocale?: Array<string>, fieldsAppScreenshotSets?: Array<'appCustomProductPageLocalization' | 'appScreenshots' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'screenshotDisplayType'>, fieldsAppStoreVersionExperimentTreatments?: Array<'appIcon' | 'appIconName' | 'appStoreVersionExperiment' | 'appStoreVersionExperimentTreatmentLocalizations' | 'appStoreVersionExperimentV2' | 'name' | 'promotedDate'>, fieldsAppStoreVersionExperimentTreatmentLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersionExperimentTreatment' | 'locale'>, fieldsAppPreviewSets?: Array<'appCustomProductPageLocalization' | 'appPreviews' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'previewType'>, limit?: number, limitAppScreenshotSets?: number, limitAppPreviewSets?: number, include?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersionExperimentTreatment'>, _options?: Configuration): Promise<HttpInfo<AppStoreVersionExperimentTreatmentLocalizationsResponse>> {
        const result = this.api.appStoreVersionExperimentTreatmentsAppStoreVersionExperimentTreatmentLocalizationsGetToManyRelatedWithHttpInfo(id, filterLocale, fieldsAppScreenshotSets, fieldsAppStoreVersionExperimentTreatments, fieldsAppStoreVersionExperimentTreatmentLocalizations, fieldsAppPreviewSets, limit, limitAppScreenshotSets, limitAppPreviewSets, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterLocale filter by attribute \&#39;locale\&#39;
     * @param fieldsAppScreenshotSets the fields to include for returned resources of type appScreenshotSets
     * @param fieldsAppStoreVersionExperimentTreatments the fields to include for returned resources of type appStoreVersionExperimentTreatments
     * @param fieldsAppStoreVersionExperimentTreatmentLocalizations the fields to include for returned resources of type appStoreVersionExperimentTreatmentLocalizations
     * @param fieldsAppPreviewSets the fields to include for returned resources of type appPreviewSets
     * @param limit maximum resources per page
     * @param limitAppScreenshotSets maximum number of related appScreenshotSets returned (when they are included)
     * @param limitAppPreviewSets maximum number of related appPreviewSets returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appStoreVersionExperimentTreatmentsAppStoreVersionExperimentTreatmentLocalizationsGetToManyRelated(id: string, filterLocale?: Array<string>, fieldsAppScreenshotSets?: Array<'appCustomProductPageLocalization' | 'appScreenshots' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'screenshotDisplayType'>, fieldsAppStoreVersionExperimentTreatments?: Array<'appIcon' | 'appIconName' | 'appStoreVersionExperiment' | 'appStoreVersionExperimentTreatmentLocalizations' | 'appStoreVersionExperimentV2' | 'name' | 'promotedDate'>, fieldsAppStoreVersionExperimentTreatmentLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersionExperimentTreatment' | 'locale'>, fieldsAppPreviewSets?: Array<'appCustomProductPageLocalization' | 'appPreviews' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'previewType'>, limit?: number, limitAppScreenshotSets?: number, limitAppPreviewSets?: number, include?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersionExperimentTreatment'>, _options?: Configuration): Promise<AppStoreVersionExperimentTreatmentLocalizationsResponse> {
        const result = this.api.appStoreVersionExperimentTreatmentsAppStoreVersionExperimentTreatmentLocalizationsGetToManyRelated(id, filterLocale, fieldsAppScreenshotSets, fieldsAppStoreVersionExperimentTreatments, fieldsAppStoreVersionExperimentTreatmentLocalizations, fieldsAppPreviewSets, limit, limitAppScreenshotSets, limitAppPreviewSets, include, _options);
        return result.toPromise();
    }

    /**
     * @param appStoreVersionExperimentTreatmentCreateRequest AppStoreVersionExperimentTreatment representation
     */
    public appStoreVersionExperimentTreatmentsCreateInstanceWithHttpInfo(appStoreVersionExperimentTreatmentCreateRequest: AppStoreVersionExperimentTreatmentCreateRequest, _options?: Configuration): Promise<HttpInfo<AppStoreVersionExperimentTreatmentResponse>> {
        const result = this.api.appStoreVersionExperimentTreatmentsCreateInstanceWithHttpInfo(appStoreVersionExperimentTreatmentCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param appStoreVersionExperimentTreatmentCreateRequest AppStoreVersionExperimentTreatment representation
     */
    public appStoreVersionExperimentTreatmentsCreateInstance(appStoreVersionExperimentTreatmentCreateRequest: AppStoreVersionExperimentTreatmentCreateRequest, _options?: Configuration): Promise<AppStoreVersionExperimentTreatmentResponse> {
        const result = this.api.appStoreVersionExperimentTreatmentsCreateInstance(appStoreVersionExperimentTreatmentCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public appStoreVersionExperimentTreatmentsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.appStoreVersionExperimentTreatmentsDeleteInstanceWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public appStoreVersionExperimentTreatmentsDeleteInstance(id: string, _options?: Configuration): Promise<void> {
        const result = this.api.appStoreVersionExperimentTreatmentsDeleteInstance(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppStoreVersionExperimentTreatments the fields to include for returned resources of type appStoreVersionExperimentTreatments
     * @param include comma-separated list of relationships to include
     * @param fieldsAppStoreVersionExperimentTreatmentLocalizations the fields to include for returned resources of type appStoreVersionExperimentTreatmentLocalizations
     * @param limitAppStoreVersionExperimentTreatmentLocalizations maximum number of related appStoreVersionExperimentTreatmentLocalizations returned (when they are included)
     */
    public appStoreVersionExperimentTreatmentsGetInstanceWithHttpInfo(id: string, fieldsAppStoreVersionExperimentTreatments?: Array<'appIcon' | 'appIconName' | 'appStoreVersionExperiment' | 'appStoreVersionExperimentTreatmentLocalizations' | 'appStoreVersionExperimentV2' | 'name' | 'promotedDate'>, include?: Array<'appStoreVersionExperiment' | 'appStoreVersionExperimentTreatmentLocalizations' | 'appStoreVersionExperimentV2'>, fieldsAppStoreVersionExperimentTreatmentLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersionExperimentTreatment' | 'locale'>, limitAppStoreVersionExperimentTreatmentLocalizations?: number, _options?: Configuration): Promise<HttpInfo<AppStoreVersionExperimentTreatmentResponse>> {
        const result = this.api.appStoreVersionExperimentTreatmentsGetInstanceWithHttpInfo(id, fieldsAppStoreVersionExperimentTreatments, include, fieldsAppStoreVersionExperimentTreatmentLocalizations, limitAppStoreVersionExperimentTreatmentLocalizations, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppStoreVersionExperimentTreatments the fields to include for returned resources of type appStoreVersionExperimentTreatments
     * @param include comma-separated list of relationships to include
     * @param fieldsAppStoreVersionExperimentTreatmentLocalizations the fields to include for returned resources of type appStoreVersionExperimentTreatmentLocalizations
     * @param limitAppStoreVersionExperimentTreatmentLocalizations maximum number of related appStoreVersionExperimentTreatmentLocalizations returned (when they are included)
     */
    public appStoreVersionExperimentTreatmentsGetInstance(id: string, fieldsAppStoreVersionExperimentTreatments?: Array<'appIcon' | 'appIconName' | 'appStoreVersionExperiment' | 'appStoreVersionExperimentTreatmentLocalizations' | 'appStoreVersionExperimentV2' | 'name' | 'promotedDate'>, include?: Array<'appStoreVersionExperiment' | 'appStoreVersionExperimentTreatmentLocalizations' | 'appStoreVersionExperimentV2'>, fieldsAppStoreVersionExperimentTreatmentLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersionExperimentTreatment' | 'locale'>, limitAppStoreVersionExperimentTreatmentLocalizations?: number, _options?: Configuration): Promise<AppStoreVersionExperimentTreatmentResponse> {
        const result = this.api.appStoreVersionExperimentTreatmentsGetInstance(id, fieldsAppStoreVersionExperimentTreatments, include, fieldsAppStoreVersionExperimentTreatmentLocalizations, limitAppStoreVersionExperimentTreatmentLocalizations, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param appStoreVersionExperimentTreatmentUpdateRequest AppStoreVersionExperimentTreatment representation
     */
    public appStoreVersionExperimentTreatmentsUpdateInstanceWithHttpInfo(id: string, appStoreVersionExperimentTreatmentUpdateRequest: AppStoreVersionExperimentTreatmentUpdateRequest, _options?: Configuration): Promise<HttpInfo<AppStoreVersionExperimentTreatmentResponse>> {
        const result = this.api.appStoreVersionExperimentTreatmentsUpdateInstanceWithHttpInfo(id, appStoreVersionExperimentTreatmentUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param appStoreVersionExperimentTreatmentUpdateRequest AppStoreVersionExperimentTreatment representation
     */
    public appStoreVersionExperimentTreatmentsUpdateInstance(id: string, appStoreVersionExperimentTreatmentUpdateRequest: AppStoreVersionExperimentTreatmentUpdateRequest, _options?: Configuration): Promise<AppStoreVersionExperimentTreatmentResponse> {
        const result = this.api.appStoreVersionExperimentTreatmentsUpdateInstance(id, appStoreVersionExperimentTreatmentUpdateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableAppStoreVersionExperimentsApi } from './ObservableAPI.ts';

import { AppStoreVersionExperimentsApiRequestFactory, AppStoreVersionExperimentsApiResponseProcessor} from "../apis/AppStoreVersionExperimentsApi.ts";
export class PromiseAppStoreVersionExperimentsApi {
    private api: ObservableAppStoreVersionExperimentsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: AppStoreVersionExperimentsApiRequestFactory,
        responseProcessor?: AppStoreVersionExperimentsApiResponseProcessor
    ) {
        this.api = new ObservableAppStoreVersionExperimentsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppStoreVersionExperiments the fields to include for returned resources of type appStoreVersionExperiments
     * @param fieldsAppStoreVersionExperimentTreatments the fields to include for returned resources of type appStoreVersionExperimentTreatments
     * @param fieldsAppStoreVersionExperimentTreatmentLocalizations the fields to include for returned resources of type appStoreVersionExperimentTreatmentLocalizations
     * @param limit maximum resources per page
     * @param limitAppStoreVersionExperimentTreatmentLocalizations maximum number of related appStoreVersionExperimentTreatmentLocalizations returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appStoreVersionExperimentsAppStoreVersionExperimentTreatmentsGetToManyRelatedWithHttpInfo(id: string, fieldsAppStoreVersionExperiments?: Array<'app' | 'appStoreVersion' | 'appStoreVersionExperimentTreatments' | 'controlVersions' | 'endDate' | 'latestControlVersion' | 'name' | 'platform' | 'reviewRequired' | 'startDate' | 'started' | 'state' | 'trafficProportion'>, fieldsAppStoreVersionExperimentTreatments?: Array<'appIcon' | 'appIconName' | 'appStoreVersionExperiment' | 'appStoreVersionExperimentTreatmentLocalizations' | 'appStoreVersionExperimentV2' | 'name' | 'promotedDate'>, fieldsAppStoreVersionExperimentTreatmentLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersionExperimentTreatment' | 'locale'>, limit?: number, limitAppStoreVersionExperimentTreatmentLocalizations?: number, include?: Array<'appStoreVersionExperiment' | 'appStoreVersionExperimentTreatmentLocalizations' | 'appStoreVersionExperimentV2'>, _options?: Configuration): Promise<HttpInfo<AppStoreVersionExperimentTreatmentsResponse>> {
        const result = this.api.appStoreVersionExperimentsAppStoreVersionExperimentTreatmentsGetToManyRelatedWithHttpInfo(id, fieldsAppStoreVersionExperiments, fieldsAppStoreVersionExperimentTreatments, fieldsAppStoreVersionExperimentTreatmentLocalizations, limit, limitAppStoreVersionExperimentTreatmentLocalizations, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppStoreVersionExperiments the fields to include for returned resources of type appStoreVersionExperiments
     * @param fieldsAppStoreVersionExperimentTreatments the fields to include for returned resources of type appStoreVersionExperimentTreatments
     * @param fieldsAppStoreVersionExperimentTreatmentLocalizations the fields to include for returned resources of type appStoreVersionExperimentTreatmentLocalizations
     * @param limit maximum resources per page
     * @param limitAppStoreVersionExperimentTreatmentLocalizations maximum number of related appStoreVersionExperimentTreatmentLocalizations returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appStoreVersionExperimentsAppStoreVersionExperimentTreatmentsGetToManyRelated(id: string, fieldsAppStoreVersionExperiments?: Array<'app' | 'appStoreVersion' | 'appStoreVersionExperimentTreatments' | 'controlVersions' | 'endDate' | 'latestControlVersion' | 'name' | 'platform' | 'reviewRequired' | 'startDate' | 'started' | 'state' | 'trafficProportion'>, fieldsAppStoreVersionExperimentTreatments?: Array<'appIcon' | 'appIconName' | 'appStoreVersionExperiment' | 'appStoreVersionExperimentTreatmentLocalizations' | 'appStoreVersionExperimentV2' | 'name' | 'promotedDate'>, fieldsAppStoreVersionExperimentTreatmentLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersionExperimentTreatment' | 'locale'>, limit?: number, limitAppStoreVersionExperimentTreatmentLocalizations?: number, include?: Array<'appStoreVersionExperiment' | 'appStoreVersionExperimentTreatmentLocalizations' | 'appStoreVersionExperimentV2'>, _options?: Configuration): Promise<AppStoreVersionExperimentTreatmentsResponse> {
        const result = this.api.appStoreVersionExperimentsAppStoreVersionExperimentTreatmentsGetToManyRelated(id, fieldsAppStoreVersionExperiments, fieldsAppStoreVersionExperimentTreatments, fieldsAppStoreVersionExperimentTreatmentLocalizations, limit, limitAppStoreVersionExperimentTreatmentLocalizations, include, _options);
        return result.toPromise();
    }

    /**
     * @param appStoreVersionExperimentCreateRequest AppStoreVersionExperiment representation
     */
    public appStoreVersionExperimentsCreateInstanceWithHttpInfo(appStoreVersionExperimentCreateRequest: AppStoreVersionExperimentCreateRequest, _options?: Configuration): Promise<HttpInfo<AppStoreVersionExperimentResponse>> {
        const result = this.api.appStoreVersionExperimentsCreateInstanceWithHttpInfo(appStoreVersionExperimentCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param appStoreVersionExperimentCreateRequest AppStoreVersionExperiment representation
     */
    public appStoreVersionExperimentsCreateInstance(appStoreVersionExperimentCreateRequest: AppStoreVersionExperimentCreateRequest, _options?: Configuration): Promise<AppStoreVersionExperimentResponse> {
        const result = this.api.appStoreVersionExperimentsCreateInstance(appStoreVersionExperimentCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public appStoreVersionExperimentsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.appStoreVersionExperimentsDeleteInstanceWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public appStoreVersionExperimentsDeleteInstance(id: string, _options?: Configuration): Promise<void> {
        const result = this.api.appStoreVersionExperimentsDeleteInstance(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppStoreVersionExperiments the fields to include for returned resources of type appStoreVersionExperiments
     * @param include comma-separated list of relationships to include
     * @param fieldsAppStoreVersionExperimentTreatments the fields to include for returned resources of type appStoreVersionExperimentTreatments
     * @param limitAppStoreVersionExperimentTreatments maximum number of related appStoreVersionExperimentTreatments returned (when they are included)
     */
    public appStoreVersionExperimentsGetInstanceWithHttpInfo(id: string, fieldsAppStoreVersionExperiments?: Array<'appStoreVersion' | 'appStoreVersionExperimentTreatments' | 'endDate' | 'name' | 'reviewRequired' | 'startDate' | 'started' | 'state' | 'trafficProportion'>, include?: Array<'appStoreVersion' | 'appStoreVersionExperimentTreatments'>, fieldsAppStoreVersionExperimentTreatments?: Array<'appIcon' | 'appIconName' | 'appStoreVersionExperiment' | 'appStoreVersionExperimentTreatmentLocalizations' | 'appStoreVersionExperimentV2' | 'name' | 'promotedDate'>, limitAppStoreVersionExperimentTreatments?: number, _options?: Configuration): Promise<HttpInfo<AppStoreVersionExperimentResponse>> {
        const result = this.api.appStoreVersionExperimentsGetInstanceWithHttpInfo(id, fieldsAppStoreVersionExperiments, include, fieldsAppStoreVersionExperimentTreatments, limitAppStoreVersionExperimentTreatments, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppStoreVersionExperiments the fields to include for returned resources of type appStoreVersionExperiments
     * @param include comma-separated list of relationships to include
     * @param fieldsAppStoreVersionExperimentTreatments the fields to include for returned resources of type appStoreVersionExperimentTreatments
     * @param limitAppStoreVersionExperimentTreatments maximum number of related appStoreVersionExperimentTreatments returned (when they are included)
     */
    public appStoreVersionExperimentsGetInstance(id: string, fieldsAppStoreVersionExperiments?: Array<'appStoreVersion' | 'appStoreVersionExperimentTreatments' | 'endDate' | 'name' | 'reviewRequired' | 'startDate' | 'started' | 'state' | 'trafficProportion'>, include?: Array<'appStoreVersion' | 'appStoreVersionExperimentTreatments'>, fieldsAppStoreVersionExperimentTreatments?: Array<'appIcon' | 'appIconName' | 'appStoreVersionExperiment' | 'appStoreVersionExperimentTreatmentLocalizations' | 'appStoreVersionExperimentV2' | 'name' | 'promotedDate'>, limitAppStoreVersionExperimentTreatments?: number, _options?: Configuration): Promise<AppStoreVersionExperimentResponse> {
        const result = this.api.appStoreVersionExperimentsGetInstance(id, fieldsAppStoreVersionExperiments, include, fieldsAppStoreVersionExperimentTreatments, limitAppStoreVersionExperimentTreatments, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param appStoreVersionExperimentUpdateRequest AppStoreVersionExperiment representation
     */
    public appStoreVersionExperimentsUpdateInstanceWithHttpInfo(id: string, appStoreVersionExperimentUpdateRequest: AppStoreVersionExperimentUpdateRequest, _options?: Configuration): Promise<HttpInfo<AppStoreVersionExperimentResponse>> {
        const result = this.api.appStoreVersionExperimentsUpdateInstanceWithHttpInfo(id, appStoreVersionExperimentUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param appStoreVersionExperimentUpdateRequest AppStoreVersionExperiment representation
     */
    public appStoreVersionExperimentsUpdateInstance(id: string, appStoreVersionExperimentUpdateRequest: AppStoreVersionExperimentUpdateRequest, _options?: Configuration): Promise<AppStoreVersionExperimentResponse> {
        const result = this.api.appStoreVersionExperimentsUpdateInstance(id, appStoreVersionExperimentUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppStoreVersionExperiments the fields to include for returned resources of type appStoreVersionExperiments
     * @param fieldsAppStoreVersionExperimentTreatments the fields to include for returned resources of type appStoreVersionExperimentTreatments
     * @param fieldsAppStoreVersionExperimentTreatmentLocalizations the fields to include for returned resources of type appStoreVersionExperimentTreatmentLocalizations
     * @param limit maximum resources per page
     * @param limitAppStoreVersionExperimentTreatmentLocalizations maximum number of related appStoreVersionExperimentTreatmentLocalizations returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appStoreVersionExperimentsV2AppStoreVersionExperimentTreatmentsGetToManyRelatedWithHttpInfo(id: string, fieldsAppStoreVersionExperiments?: Array<'app' | 'appStoreVersion' | 'appStoreVersionExperimentTreatments' | 'controlVersions' | 'endDate' | 'latestControlVersion' | 'name' | 'platform' | 'reviewRequired' | 'startDate' | 'started' | 'state' | 'trafficProportion'>, fieldsAppStoreVersionExperimentTreatments?: Array<'appIcon' | 'appIconName' | 'appStoreVersionExperiment' | 'appStoreVersionExperimentTreatmentLocalizations' | 'appStoreVersionExperimentV2' | 'name' | 'promotedDate'>, fieldsAppStoreVersionExperimentTreatmentLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersionExperimentTreatment' | 'locale'>, limit?: number, limitAppStoreVersionExperimentTreatmentLocalizations?: number, include?: Array<'appStoreVersionExperiment' | 'appStoreVersionExperimentTreatmentLocalizations' | 'appStoreVersionExperimentV2'>, _options?: Configuration): Promise<HttpInfo<AppStoreVersionExperimentTreatmentsResponse>> {
        const result = this.api.appStoreVersionExperimentsV2AppStoreVersionExperimentTreatmentsGetToManyRelatedWithHttpInfo(id, fieldsAppStoreVersionExperiments, fieldsAppStoreVersionExperimentTreatments, fieldsAppStoreVersionExperimentTreatmentLocalizations, limit, limitAppStoreVersionExperimentTreatmentLocalizations, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppStoreVersionExperiments the fields to include for returned resources of type appStoreVersionExperiments
     * @param fieldsAppStoreVersionExperimentTreatments the fields to include for returned resources of type appStoreVersionExperimentTreatments
     * @param fieldsAppStoreVersionExperimentTreatmentLocalizations the fields to include for returned resources of type appStoreVersionExperimentTreatmentLocalizations
     * @param limit maximum resources per page
     * @param limitAppStoreVersionExperimentTreatmentLocalizations maximum number of related appStoreVersionExperimentTreatmentLocalizations returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appStoreVersionExperimentsV2AppStoreVersionExperimentTreatmentsGetToManyRelated(id: string, fieldsAppStoreVersionExperiments?: Array<'app' | 'appStoreVersion' | 'appStoreVersionExperimentTreatments' | 'controlVersions' | 'endDate' | 'latestControlVersion' | 'name' | 'platform' | 'reviewRequired' | 'startDate' | 'started' | 'state' | 'trafficProportion'>, fieldsAppStoreVersionExperimentTreatments?: Array<'appIcon' | 'appIconName' | 'appStoreVersionExperiment' | 'appStoreVersionExperimentTreatmentLocalizations' | 'appStoreVersionExperimentV2' | 'name' | 'promotedDate'>, fieldsAppStoreVersionExperimentTreatmentLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersionExperimentTreatment' | 'locale'>, limit?: number, limitAppStoreVersionExperimentTreatmentLocalizations?: number, include?: Array<'appStoreVersionExperiment' | 'appStoreVersionExperimentTreatmentLocalizations' | 'appStoreVersionExperimentV2'>, _options?: Configuration): Promise<AppStoreVersionExperimentTreatmentsResponse> {
        const result = this.api.appStoreVersionExperimentsV2AppStoreVersionExperimentTreatmentsGetToManyRelated(id, fieldsAppStoreVersionExperiments, fieldsAppStoreVersionExperimentTreatments, fieldsAppStoreVersionExperimentTreatmentLocalizations, limit, limitAppStoreVersionExperimentTreatmentLocalizations, include, _options);
        return result.toPromise();
    }

    /**
     * @param appStoreVersionExperimentV2CreateRequest AppStoreVersionExperiment representation
     */
    public appStoreVersionExperimentsV2CreateInstanceWithHttpInfo(appStoreVersionExperimentV2CreateRequest: AppStoreVersionExperimentV2CreateRequest, _options?: Configuration): Promise<HttpInfo<AppStoreVersionExperimentV2Response>> {
        const result = this.api.appStoreVersionExperimentsV2CreateInstanceWithHttpInfo(appStoreVersionExperimentV2CreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param appStoreVersionExperimentV2CreateRequest AppStoreVersionExperiment representation
     */
    public appStoreVersionExperimentsV2CreateInstance(appStoreVersionExperimentV2CreateRequest: AppStoreVersionExperimentV2CreateRequest, _options?: Configuration): Promise<AppStoreVersionExperimentV2Response> {
        const result = this.api.appStoreVersionExperimentsV2CreateInstance(appStoreVersionExperimentV2CreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public appStoreVersionExperimentsV2DeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.appStoreVersionExperimentsV2DeleteInstanceWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public appStoreVersionExperimentsV2DeleteInstance(id: string, _options?: Configuration): Promise<void> {
        const result = this.api.appStoreVersionExperimentsV2DeleteInstance(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppStoreVersionExperiments the fields to include for returned resources of type appStoreVersionExperiments
     * @param include comma-separated list of relationships to include
     * @param fieldsAppStoreVersionExperimentTreatments the fields to include for returned resources of type appStoreVersionExperimentTreatments
     * @param limitAppStoreVersionExperimentTreatments maximum number of related appStoreVersionExperimentTreatments returned (when they are included)
     * @param limitControlVersions maximum number of related controlVersions returned (when they are included)
     */
    public appStoreVersionExperimentsV2GetInstanceWithHttpInfo(id: string, fieldsAppStoreVersionExperiments?: Array<'app' | 'appStoreVersionExperimentTreatments' | 'controlVersions' | 'endDate' | 'latestControlVersion' | 'name' | 'platform' | 'reviewRequired' | 'startDate' | 'started' | 'state' | 'trafficProportion'>, include?: Array<'app' | 'appStoreVersionExperimentTreatments' | 'controlVersions' | 'latestControlVersion'>, fieldsAppStoreVersionExperimentTreatments?: Array<'appIcon' | 'appIconName' | 'appStoreVersionExperiment' | 'appStoreVersionExperimentTreatmentLocalizations' | 'appStoreVersionExperimentV2' | 'name' | 'promotedDate'>, limitAppStoreVersionExperimentTreatments?: number, limitControlVersions?: number, _options?: Configuration): Promise<HttpInfo<AppStoreVersionExperimentV2Response>> {
        const result = this.api.appStoreVersionExperimentsV2GetInstanceWithHttpInfo(id, fieldsAppStoreVersionExperiments, include, fieldsAppStoreVersionExperimentTreatments, limitAppStoreVersionExperimentTreatments, limitControlVersions, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppStoreVersionExperiments the fields to include for returned resources of type appStoreVersionExperiments
     * @param include comma-separated list of relationships to include
     * @param fieldsAppStoreVersionExperimentTreatments the fields to include for returned resources of type appStoreVersionExperimentTreatments
     * @param limitAppStoreVersionExperimentTreatments maximum number of related appStoreVersionExperimentTreatments returned (when they are included)
     * @param limitControlVersions maximum number of related controlVersions returned (when they are included)
     */
    public appStoreVersionExperimentsV2GetInstance(id: string, fieldsAppStoreVersionExperiments?: Array<'app' | 'appStoreVersionExperimentTreatments' | 'controlVersions' | 'endDate' | 'latestControlVersion' | 'name' | 'platform' | 'reviewRequired' | 'startDate' | 'started' | 'state' | 'trafficProportion'>, include?: Array<'app' | 'appStoreVersionExperimentTreatments' | 'controlVersions' | 'latestControlVersion'>, fieldsAppStoreVersionExperimentTreatments?: Array<'appIcon' | 'appIconName' | 'appStoreVersionExperiment' | 'appStoreVersionExperimentTreatmentLocalizations' | 'appStoreVersionExperimentV2' | 'name' | 'promotedDate'>, limitAppStoreVersionExperimentTreatments?: number, limitControlVersions?: number, _options?: Configuration): Promise<AppStoreVersionExperimentV2Response> {
        const result = this.api.appStoreVersionExperimentsV2GetInstance(id, fieldsAppStoreVersionExperiments, include, fieldsAppStoreVersionExperimentTreatments, limitAppStoreVersionExperimentTreatments, limitControlVersions, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param appStoreVersionExperimentV2UpdateRequest AppStoreVersionExperiment representation
     */
    public appStoreVersionExperimentsV2UpdateInstanceWithHttpInfo(id: string, appStoreVersionExperimentV2UpdateRequest: AppStoreVersionExperimentV2UpdateRequest, _options?: Configuration): Promise<HttpInfo<AppStoreVersionExperimentV2Response>> {
        const result = this.api.appStoreVersionExperimentsV2UpdateInstanceWithHttpInfo(id, appStoreVersionExperimentV2UpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param appStoreVersionExperimentV2UpdateRequest AppStoreVersionExperiment representation
     */
    public appStoreVersionExperimentsV2UpdateInstance(id: string, appStoreVersionExperimentV2UpdateRequest: AppStoreVersionExperimentV2UpdateRequest, _options?: Configuration): Promise<AppStoreVersionExperimentV2Response> {
        const result = this.api.appStoreVersionExperimentsV2UpdateInstance(id, appStoreVersionExperimentV2UpdateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableAppStoreVersionLocalizationsApi } from './ObservableAPI.ts';

import { AppStoreVersionLocalizationsApiRequestFactory, AppStoreVersionLocalizationsApiResponseProcessor} from "../apis/AppStoreVersionLocalizationsApi.ts";
export class PromiseAppStoreVersionLocalizationsApi {
    private api: ObservableAppStoreVersionLocalizationsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: AppStoreVersionLocalizationsApiRequestFactory,
        responseProcessor?: AppStoreVersionLocalizationsApiResponseProcessor
    ) {
        this.api = new ObservableAppStoreVersionLocalizationsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param id the id of the requested resource
     * @param filterPreviewType filter by attribute \&#39;previewType\&#39;
     * @param filterAppCustomProductPageLocalization filter by id(s) of related \&#39;appCustomProductPageLocalization\&#39;
     * @param filterAppStoreVersionExperimentTreatmentLocalization filter by id(s) of related \&#39;appStoreVersionExperimentTreatmentLocalization\&#39;
     * @param fieldsAppCustomProductPageLocalizations the fields to include for returned resources of type appCustomProductPageLocalizations
     * @param fieldsAppStoreVersionExperimentTreatmentLocalizations the fields to include for returned resources of type appStoreVersionExperimentTreatmentLocalizations
     * @param fieldsAppPreviews the fields to include for returned resources of type appPreviews
     * @param fieldsAppPreviewSets the fields to include for returned resources of type appPreviewSets
     * @param fieldsAppStoreVersionLocalizations the fields to include for returned resources of type appStoreVersionLocalizations
     * @param limit maximum resources per page
     * @param limitAppPreviews maximum number of related appPreviews returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appStoreVersionLocalizationsAppPreviewSetsGetToManyRelatedWithHttpInfo(id: string, filterPreviewType?: Array<'IPHONE_67' | 'IPHONE_61' | 'IPHONE_65' | 'IPHONE_58' | 'IPHONE_55' | 'IPHONE_47' | 'IPHONE_40' | 'IPHONE_35' | 'IPAD_PRO_3GEN_129' | 'IPAD_PRO_3GEN_11' | 'IPAD_PRO_129' | 'IPAD_105' | 'IPAD_97' | 'DESKTOP' | 'APPLE_TV' | 'APPLE_VISION_PRO'>, filterAppCustomProductPageLocalization?: Array<string>, filterAppStoreVersionExperimentTreatmentLocalization?: Array<string>, fieldsAppCustomProductPageLocalizations?: Array<'appCustomProductPageVersion' | 'appPreviewSets' | 'appScreenshotSets' | 'locale' | 'promotionalText'>, fieldsAppStoreVersionExperimentTreatmentLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersionExperimentTreatment' | 'locale'>, fieldsAppPreviews?: Array<'appPreviewSet' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'mimeType' | 'previewFrameTimeCode' | 'previewImage' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded' | 'videoUrl'>, fieldsAppPreviewSets?: Array<'appCustomProductPageLocalization' | 'appPreviews' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'previewType'>, fieldsAppStoreVersionLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersion' | 'description' | 'keywords' | 'locale' | 'marketingUrl' | 'promotionalText' | 'supportUrl' | 'whatsNew'>, limit?: number, limitAppPreviews?: number, include?: Array<'appCustomProductPageLocalization' | 'appPreviews' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization'>, _options?: Configuration): Promise<HttpInfo<AppPreviewSetsResponse>> {
        const result = this.api.appStoreVersionLocalizationsAppPreviewSetsGetToManyRelatedWithHttpInfo(id, filterPreviewType, filterAppCustomProductPageLocalization, filterAppStoreVersionExperimentTreatmentLocalization, fieldsAppCustomProductPageLocalizations, fieldsAppStoreVersionExperimentTreatmentLocalizations, fieldsAppPreviews, fieldsAppPreviewSets, fieldsAppStoreVersionLocalizations, limit, limitAppPreviews, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterPreviewType filter by attribute \&#39;previewType\&#39;
     * @param filterAppCustomProductPageLocalization filter by id(s) of related \&#39;appCustomProductPageLocalization\&#39;
     * @param filterAppStoreVersionExperimentTreatmentLocalization filter by id(s) of related \&#39;appStoreVersionExperimentTreatmentLocalization\&#39;
     * @param fieldsAppCustomProductPageLocalizations the fields to include for returned resources of type appCustomProductPageLocalizations
     * @param fieldsAppStoreVersionExperimentTreatmentLocalizations the fields to include for returned resources of type appStoreVersionExperimentTreatmentLocalizations
     * @param fieldsAppPreviews the fields to include for returned resources of type appPreviews
     * @param fieldsAppPreviewSets the fields to include for returned resources of type appPreviewSets
     * @param fieldsAppStoreVersionLocalizations the fields to include for returned resources of type appStoreVersionLocalizations
     * @param limit maximum resources per page
     * @param limitAppPreviews maximum number of related appPreviews returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appStoreVersionLocalizationsAppPreviewSetsGetToManyRelated(id: string, filterPreviewType?: Array<'IPHONE_67' | 'IPHONE_61' | 'IPHONE_65' | 'IPHONE_58' | 'IPHONE_55' | 'IPHONE_47' | 'IPHONE_40' | 'IPHONE_35' | 'IPAD_PRO_3GEN_129' | 'IPAD_PRO_3GEN_11' | 'IPAD_PRO_129' | 'IPAD_105' | 'IPAD_97' | 'DESKTOP' | 'APPLE_TV' | 'APPLE_VISION_PRO'>, filterAppCustomProductPageLocalization?: Array<string>, filterAppStoreVersionExperimentTreatmentLocalization?: Array<string>, fieldsAppCustomProductPageLocalizations?: Array<'appCustomProductPageVersion' | 'appPreviewSets' | 'appScreenshotSets' | 'locale' | 'promotionalText'>, fieldsAppStoreVersionExperimentTreatmentLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersionExperimentTreatment' | 'locale'>, fieldsAppPreviews?: Array<'appPreviewSet' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'mimeType' | 'previewFrameTimeCode' | 'previewImage' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded' | 'videoUrl'>, fieldsAppPreviewSets?: Array<'appCustomProductPageLocalization' | 'appPreviews' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'previewType'>, fieldsAppStoreVersionLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersion' | 'description' | 'keywords' | 'locale' | 'marketingUrl' | 'promotionalText' | 'supportUrl' | 'whatsNew'>, limit?: number, limitAppPreviews?: number, include?: Array<'appCustomProductPageLocalization' | 'appPreviews' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization'>, _options?: Configuration): Promise<AppPreviewSetsResponse> {
        const result = this.api.appStoreVersionLocalizationsAppPreviewSetsGetToManyRelated(id, filterPreviewType, filterAppCustomProductPageLocalization, filterAppStoreVersionExperimentTreatmentLocalization, fieldsAppCustomProductPageLocalizations, fieldsAppStoreVersionExperimentTreatmentLocalizations, fieldsAppPreviews, fieldsAppPreviewSets, fieldsAppStoreVersionLocalizations, limit, limitAppPreviews, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterScreenshotDisplayType filter by attribute \&#39;screenshotDisplayType\&#39;
     * @param filterAppCustomProductPageLocalization filter by id(s) of related \&#39;appCustomProductPageLocalization\&#39;
     * @param filterAppStoreVersionExperimentTreatmentLocalization filter by id(s) of related \&#39;appStoreVersionExperimentTreatmentLocalization\&#39;
     * @param fieldsAppScreenshotSets the fields to include for returned resources of type appScreenshotSets
     * @param fieldsAppCustomProductPageLocalizations the fields to include for returned resources of type appCustomProductPageLocalizations
     * @param fieldsAppStoreVersionExperimentTreatmentLocalizations the fields to include for returned resources of type appStoreVersionExperimentTreatmentLocalizations
     * @param fieldsAppScreenshots the fields to include for returned resources of type appScreenshots
     * @param fieldsAppStoreVersionLocalizations the fields to include for returned resources of type appStoreVersionLocalizations
     * @param limit maximum resources per page
     * @param limitAppScreenshots maximum number of related appScreenshots returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appStoreVersionLocalizationsAppScreenshotSetsGetToManyRelatedWithHttpInfo(id: string, filterScreenshotDisplayType?: Array<'APP_IPHONE_67' | 'APP_IPHONE_61' | 'APP_IPHONE_65' | 'APP_IPHONE_58' | 'APP_IPHONE_55' | 'APP_IPHONE_47' | 'APP_IPHONE_40' | 'APP_IPHONE_35' | 'APP_IPAD_PRO_3GEN_129' | 'APP_IPAD_PRO_3GEN_11' | 'APP_IPAD_PRO_129' | 'APP_IPAD_105' | 'APP_IPAD_97' | 'APP_DESKTOP' | 'APP_WATCH_ULTRA' | 'APP_WATCH_SERIES_7' | 'APP_WATCH_SERIES_4' | 'APP_WATCH_SERIES_3' | 'APP_APPLE_TV' | 'APP_APPLE_VISION_PRO' | 'IMESSAGE_APP_IPHONE_67' | 'IMESSAGE_APP_IPHONE_61' | 'IMESSAGE_APP_IPHONE_65' | 'IMESSAGE_APP_IPHONE_58' | 'IMESSAGE_APP_IPHONE_55' | 'IMESSAGE_APP_IPHONE_47' | 'IMESSAGE_APP_IPHONE_40' | 'IMESSAGE_APP_IPAD_PRO_3GEN_129' | 'IMESSAGE_APP_IPAD_PRO_3GEN_11' | 'IMESSAGE_APP_IPAD_PRO_129' | 'IMESSAGE_APP_IPAD_105' | 'IMESSAGE_APP_IPAD_97'>, filterAppCustomProductPageLocalization?: Array<string>, filterAppStoreVersionExperimentTreatmentLocalization?: Array<string>, fieldsAppScreenshotSets?: Array<'appCustomProductPageLocalization' | 'appScreenshots' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'screenshotDisplayType'>, fieldsAppCustomProductPageLocalizations?: Array<'appCustomProductPageVersion' | 'appPreviewSets' | 'appScreenshotSets' | 'locale' | 'promotionalText'>, fieldsAppStoreVersionExperimentTreatmentLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersionExperimentTreatment' | 'locale'>, fieldsAppScreenshots?: Array<'appScreenshotSet' | 'assetDeliveryState' | 'assetToken' | 'assetType' | 'fileName' | 'fileSize' | 'imageAsset' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, fieldsAppStoreVersionLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersion' | 'description' | 'keywords' | 'locale' | 'marketingUrl' | 'promotionalText' | 'supportUrl' | 'whatsNew'>, limit?: number, limitAppScreenshots?: number, include?: Array<'appCustomProductPageLocalization' | 'appScreenshots' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization'>, _options?: Configuration): Promise<HttpInfo<AppScreenshotSetsResponse>> {
        const result = this.api.appStoreVersionLocalizationsAppScreenshotSetsGetToManyRelatedWithHttpInfo(id, filterScreenshotDisplayType, filterAppCustomProductPageLocalization, filterAppStoreVersionExperimentTreatmentLocalization, fieldsAppScreenshotSets, fieldsAppCustomProductPageLocalizations, fieldsAppStoreVersionExperimentTreatmentLocalizations, fieldsAppScreenshots, fieldsAppStoreVersionLocalizations, limit, limitAppScreenshots, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterScreenshotDisplayType filter by attribute \&#39;screenshotDisplayType\&#39;
     * @param filterAppCustomProductPageLocalization filter by id(s) of related \&#39;appCustomProductPageLocalization\&#39;
     * @param filterAppStoreVersionExperimentTreatmentLocalization filter by id(s) of related \&#39;appStoreVersionExperimentTreatmentLocalization\&#39;
     * @param fieldsAppScreenshotSets the fields to include for returned resources of type appScreenshotSets
     * @param fieldsAppCustomProductPageLocalizations the fields to include for returned resources of type appCustomProductPageLocalizations
     * @param fieldsAppStoreVersionExperimentTreatmentLocalizations the fields to include for returned resources of type appStoreVersionExperimentTreatmentLocalizations
     * @param fieldsAppScreenshots the fields to include for returned resources of type appScreenshots
     * @param fieldsAppStoreVersionLocalizations the fields to include for returned resources of type appStoreVersionLocalizations
     * @param limit maximum resources per page
     * @param limitAppScreenshots maximum number of related appScreenshots returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appStoreVersionLocalizationsAppScreenshotSetsGetToManyRelated(id: string, filterScreenshotDisplayType?: Array<'APP_IPHONE_67' | 'APP_IPHONE_61' | 'APP_IPHONE_65' | 'APP_IPHONE_58' | 'APP_IPHONE_55' | 'APP_IPHONE_47' | 'APP_IPHONE_40' | 'APP_IPHONE_35' | 'APP_IPAD_PRO_3GEN_129' | 'APP_IPAD_PRO_3GEN_11' | 'APP_IPAD_PRO_129' | 'APP_IPAD_105' | 'APP_IPAD_97' | 'APP_DESKTOP' | 'APP_WATCH_ULTRA' | 'APP_WATCH_SERIES_7' | 'APP_WATCH_SERIES_4' | 'APP_WATCH_SERIES_3' | 'APP_APPLE_TV' | 'APP_APPLE_VISION_PRO' | 'IMESSAGE_APP_IPHONE_67' | 'IMESSAGE_APP_IPHONE_61' | 'IMESSAGE_APP_IPHONE_65' | 'IMESSAGE_APP_IPHONE_58' | 'IMESSAGE_APP_IPHONE_55' | 'IMESSAGE_APP_IPHONE_47' | 'IMESSAGE_APP_IPHONE_40' | 'IMESSAGE_APP_IPAD_PRO_3GEN_129' | 'IMESSAGE_APP_IPAD_PRO_3GEN_11' | 'IMESSAGE_APP_IPAD_PRO_129' | 'IMESSAGE_APP_IPAD_105' | 'IMESSAGE_APP_IPAD_97'>, filterAppCustomProductPageLocalization?: Array<string>, filterAppStoreVersionExperimentTreatmentLocalization?: Array<string>, fieldsAppScreenshotSets?: Array<'appCustomProductPageLocalization' | 'appScreenshots' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'screenshotDisplayType'>, fieldsAppCustomProductPageLocalizations?: Array<'appCustomProductPageVersion' | 'appPreviewSets' | 'appScreenshotSets' | 'locale' | 'promotionalText'>, fieldsAppStoreVersionExperimentTreatmentLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersionExperimentTreatment' | 'locale'>, fieldsAppScreenshots?: Array<'appScreenshotSet' | 'assetDeliveryState' | 'assetToken' | 'assetType' | 'fileName' | 'fileSize' | 'imageAsset' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, fieldsAppStoreVersionLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersion' | 'description' | 'keywords' | 'locale' | 'marketingUrl' | 'promotionalText' | 'supportUrl' | 'whatsNew'>, limit?: number, limitAppScreenshots?: number, include?: Array<'appCustomProductPageLocalization' | 'appScreenshots' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization'>, _options?: Configuration): Promise<AppScreenshotSetsResponse> {
        const result = this.api.appStoreVersionLocalizationsAppScreenshotSetsGetToManyRelated(id, filterScreenshotDisplayType, filterAppCustomProductPageLocalization, filterAppStoreVersionExperimentTreatmentLocalization, fieldsAppScreenshotSets, fieldsAppCustomProductPageLocalizations, fieldsAppStoreVersionExperimentTreatmentLocalizations, fieldsAppScreenshots, fieldsAppStoreVersionLocalizations, limit, limitAppScreenshots, include, _options);
        return result.toPromise();
    }

    /**
     * @param appStoreVersionLocalizationCreateRequest AppStoreVersionLocalization representation
     */
    public appStoreVersionLocalizationsCreateInstanceWithHttpInfo(appStoreVersionLocalizationCreateRequest: AppStoreVersionLocalizationCreateRequest, _options?: Configuration): Promise<HttpInfo<AppStoreVersionLocalizationResponse>> {
        const result = this.api.appStoreVersionLocalizationsCreateInstanceWithHttpInfo(appStoreVersionLocalizationCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param appStoreVersionLocalizationCreateRequest AppStoreVersionLocalization representation
     */
    public appStoreVersionLocalizationsCreateInstance(appStoreVersionLocalizationCreateRequest: AppStoreVersionLocalizationCreateRequest, _options?: Configuration): Promise<AppStoreVersionLocalizationResponse> {
        const result = this.api.appStoreVersionLocalizationsCreateInstance(appStoreVersionLocalizationCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public appStoreVersionLocalizationsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.appStoreVersionLocalizationsDeleteInstanceWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public appStoreVersionLocalizationsDeleteInstance(id: string, _options?: Configuration): Promise<void> {
        const result = this.api.appStoreVersionLocalizationsDeleteInstance(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppStoreVersionLocalizations the fields to include for returned resources of type appStoreVersionLocalizations
     * @param include comma-separated list of relationships to include
     * @param fieldsAppScreenshotSets the fields to include for returned resources of type appScreenshotSets
     * @param fieldsAppPreviewSets the fields to include for returned resources of type appPreviewSets
     * @param limitAppPreviewSets maximum number of related appPreviewSets returned (when they are included)
     * @param limitAppScreenshotSets maximum number of related appScreenshotSets returned (when they are included)
     */
    public appStoreVersionLocalizationsGetInstanceWithHttpInfo(id: string, fieldsAppStoreVersionLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersion' | 'description' | 'keywords' | 'locale' | 'marketingUrl' | 'promotionalText' | 'supportUrl' | 'whatsNew'>, include?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersion'>, fieldsAppScreenshotSets?: Array<'appCustomProductPageLocalization' | 'appScreenshots' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'screenshotDisplayType'>, fieldsAppPreviewSets?: Array<'appCustomProductPageLocalization' | 'appPreviews' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'previewType'>, limitAppPreviewSets?: number, limitAppScreenshotSets?: number, _options?: Configuration): Promise<HttpInfo<AppStoreVersionLocalizationResponse>> {
        const result = this.api.appStoreVersionLocalizationsGetInstanceWithHttpInfo(id, fieldsAppStoreVersionLocalizations, include, fieldsAppScreenshotSets, fieldsAppPreviewSets, limitAppPreviewSets, limitAppScreenshotSets, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppStoreVersionLocalizations the fields to include for returned resources of type appStoreVersionLocalizations
     * @param include comma-separated list of relationships to include
     * @param fieldsAppScreenshotSets the fields to include for returned resources of type appScreenshotSets
     * @param fieldsAppPreviewSets the fields to include for returned resources of type appPreviewSets
     * @param limitAppPreviewSets maximum number of related appPreviewSets returned (when they are included)
     * @param limitAppScreenshotSets maximum number of related appScreenshotSets returned (when they are included)
     */
    public appStoreVersionLocalizationsGetInstance(id: string, fieldsAppStoreVersionLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersion' | 'description' | 'keywords' | 'locale' | 'marketingUrl' | 'promotionalText' | 'supportUrl' | 'whatsNew'>, include?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersion'>, fieldsAppScreenshotSets?: Array<'appCustomProductPageLocalization' | 'appScreenshots' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'screenshotDisplayType'>, fieldsAppPreviewSets?: Array<'appCustomProductPageLocalization' | 'appPreviews' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'previewType'>, limitAppPreviewSets?: number, limitAppScreenshotSets?: number, _options?: Configuration): Promise<AppStoreVersionLocalizationResponse> {
        const result = this.api.appStoreVersionLocalizationsGetInstance(id, fieldsAppStoreVersionLocalizations, include, fieldsAppScreenshotSets, fieldsAppPreviewSets, limitAppPreviewSets, limitAppScreenshotSets, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param appStoreVersionLocalizationUpdateRequest AppStoreVersionLocalization representation
     */
    public appStoreVersionLocalizationsUpdateInstanceWithHttpInfo(id: string, appStoreVersionLocalizationUpdateRequest: AppStoreVersionLocalizationUpdateRequest, _options?: Configuration): Promise<HttpInfo<AppStoreVersionLocalizationResponse>> {
        const result = this.api.appStoreVersionLocalizationsUpdateInstanceWithHttpInfo(id, appStoreVersionLocalizationUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param appStoreVersionLocalizationUpdateRequest AppStoreVersionLocalization representation
     */
    public appStoreVersionLocalizationsUpdateInstance(id: string, appStoreVersionLocalizationUpdateRequest: AppStoreVersionLocalizationUpdateRequest, _options?: Configuration): Promise<AppStoreVersionLocalizationResponse> {
        const result = this.api.appStoreVersionLocalizationsUpdateInstance(id, appStoreVersionLocalizationUpdateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableAppStoreVersionPhasedReleasesApi } from './ObservableAPI.ts';

import { AppStoreVersionPhasedReleasesApiRequestFactory, AppStoreVersionPhasedReleasesApiResponseProcessor} from "../apis/AppStoreVersionPhasedReleasesApi.ts";
export class PromiseAppStoreVersionPhasedReleasesApi {
    private api: ObservableAppStoreVersionPhasedReleasesApi

    public constructor(
        configuration: Configuration,
        requestFactory?: AppStoreVersionPhasedReleasesApiRequestFactory,
        responseProcessor?: AppStoreVersionPhasedReleasesApiResponseProcessor
    ) {
        this.api = new ObservableAppStoreVersionPhasedReleasesApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param appStoreVersionPhasedReleaseCreateRequest AppStoreVersionPhasedRelease representation
     */
    public appStoreVersionPhasedReleasesCreateInstanceWithHttpInfo(appStoreVersionPhasedReleaseCreateRequest: AppStoreVersionPhasedReleaseCreateRequest, _options?: Configuration): Promise<HttpInfo<AppStoreVersionPhasedReleaseResponse>> {
        const result = this.api.appStoreVersionPhasedReleasesCreateInstanceWithHttpInfo(appStoreVersionPhasedReleaseCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param appStoreVersionPhasedReleaseCreateRequest AppStoreVersionPhasedRelease representation
     */
    public appStoreVersionPhasedReleasesCreateInstance(appStoreVersionPhasedReleaseCreateRequest: AppStoreVersionPhasedReleaseCreateRequest, _options?: Configuration): Promise<AppStoreVersionPhasedReleaseResponse> {
        const result = this.api.appStoreVersionPhasedReleasesCreateInstance(appStoreVersionPhasedReleaseCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public appStoreVersionPhasedReleasesDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.appStoreVersionPhasedReleasesDeleteInstanceWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public appStoreVersionPhasedReleasesDeleteInstance(id: string, _options?: Configuration): Promise<void> {
        const result = this.api.appStoreVersionPhasedReleasesDeleteInstance(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param appStoreVersionPhasedReleaseUpdateRequest AppStoreVersionPhasedRelease representation
     */
    public appStoreVersionPhasedReleasesUpdateInstanceWithHttpInfo(id: string, appStoreVersionPhasedReleaseUpdateRequest: AppStoreVersionPhasedReleaseUpdateRequest, _options?: Configuration): Promise<HttpInfo<AppStoreVersionPhasedReleaseResponse>> {
        const result = this.api.appStoreVersionPhasedReleasesUpdateInstanceWithHttpInfo(id, appStoreVersionPhasedReleaseUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param appStoreVersionPhasedReleaseUpdateRequest AppStoreVersionPhasedRelease representation
     */
    public appStoreVersionPhasedReleasesUpdateInstance(id: string, appStoreVersionPhasedReleaseUpdateRequest: AppStoreVersionPhasedReleaseUpdateRequest, _options?: Configuration): Promise<AppStoreVersionPhasedReleaseResponse> {
        const result = this.api.appStoreVersionPhasedReleasesUpdateInstance(id, appStoreVersionPhasedReleaseUpdateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableAppStoreVersionPromotionsApi } from './ObservableAPI.ts';

import { AppStoreVersionPromotionsApiRequestFactory, AppStoreVersionPromotionsApiResponseProcessor} from "../apis/AppStoreVersionPromotionsApi.ts";
export class PromiseAppStoreVersionPromotionsApi {
    private api: ObservableAppStoreVersionPromotionsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: AppStoreVersionPromotionsApiRequestFactory,
        responseProcessor?: AppStoreVersionPromotionsApiResponseProcessor
    ) {
        this.api = new ObservableAppStoreVersionPromotionsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param appStoreVersionPromotionCreateRequest AppStoreVersionPromotion representation
     */
    public appStoreVersionPromotionsCreateInstanceWithHttpInfo(appStoreVersionPromotionCreateRequest: AppStoreVersionPromotionCreateRequest, _options?: Configuration): Promise<HttpInfo<AppStoreVersionPromotionResponse>> {
        const result = this.api.appStoreVersionPromotionsCreateInstanceWithHttpInfo(appStoreVersionPromotionCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param appStoreVersionPromotionCreateRequest AppStoreVersionPromotion representation
     */
    public appStoreVersionPromotionsCreateInstance(appStoreVersionPromotionCreateRequest: AppStoreVersionPromotionCreateRequest, _options?: Configuration): Promise<AppStoreVersionPromotionResponse> {
        const result = this.api.appStoreVersionPromotionsCreateInstance(appStoreVersionPromotionCreateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableAppStoreVersionReleaseRequestsApi } from './ObservableAPI.ts';

import { AppStoreVersionReleaseRequestsApiRequestFactory, AppStoreVersionReleaseRequestsApiResponseProcessor} from "../apis/AppStoreVersionReleaseRequestsApi.ts";
export class PromiseAppStoreVersionReleaseRequestsApi {
    private api: ObservableAppStoreVersionReleaseRequestsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: AppStoreVersionReleaseRequestsApiRequestFactory,
        responseProcessor?: AppStoreVersionReleaseRequestsApiResponseProcessor
    ) {
        this.api = new ObservableAppStoreVersionReleaseRequestsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param appStoreVersionReleaseRequestCreateRequest AppStoreVersionReleaseRequest representation
     */
    public appStoreVersionReleaseRequestsCreateInstanceWithHttpInfo(appStoreVersionReleaseRequestCreateRequest: AppStoreVersionReleaseRequestCreateRequest, _options?: Configuration): Promise<HttpInfo<AppStoreVersionReleaseRequestResponse>> {
        const result = this.api.appStoreVersionReleaseRequestsCreateInstanceWithHttpInfo(appStoreVersionReleaseRequestCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param appStoreVersionReleaseRequestCreateRequest AppStoreVersionReleaseRequest representation
     */
    public appStoreVersionReleaseRequestsCreateInstance(appStoreVersionReleaseRequestCreateRequest: AppStoreVersionReleaseRequestCreateRequest, _options?: Configuration): Promise<AppStoreVersionReleaseRequestResponse> {
        const result = this.api.appStoreVersionReleaseRequestsCreateInstance(appStoreVersionReleaseRequestCreateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableAppStoreVersionSubmissionsApi } from './ObservableAPI.ts';

import { AppStoreVersionSubmissionsApiRequestFactory, AppStoreVersionSubmissionsApiResponseProcessor} from "../apis/AppStoreVersionSubmissionsApi.ts";
export class PromiseAppStoreVersionSubmissionsApi {
    private api: ObservableAppStoreVersionSubmissionsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: AppStoreVersionSubmissionsApiRequestFactory,
        responseProcessor?: AppStoreVersionSubmissionsApiResponseProcessor
    ) {
        this.api = new ObservableAppStoreVersionSubmissionsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param appStoreVersionSubmissionCreateRequest AppStoreVersionSubmission representation
     */
    public appStoreVersionSubmissionsCreateInstanceWithHttpInfo(appStoreVersionSubmissionCreateRequest: AppStoreVersionSubmissionCreateRequest, _options?: Configuration): Promise<HttpInfo<AppStoreVersionSubmissionResponse>> {
        const result = this.api.appStoreVersionSubmissionsCreateInstanceWithHttpInfo(appStoreVersionSubmissionCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param appStoreVersionSubmissionCreateRequest AppStoreVersionSubmission representation
     */
    public appStoreVersionSubmissionsCreateInstance(appStoreVersionSubmissionCreateRequest: AppStoreVersionSubmissionCreateRequest, _options?: Configuration): Promise<AppStoreVersionSubmissionResponse> {
        const result = this.api.appStoreVersionSubmissionsCreateInstance(appStoreVersionSubmissionCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public appStoreVersionSubmissionsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.appStoreVersionSubmissionsDeleteInstanceWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public appStoreVersionSubmissionsDeleteInstance(id: string, _options?: Configuration): Promise<void> {
        const result = this.api.appStoreVersionSubmissionsDeleteInstance(id, _options);
        return result.toPromise();
    }


}



import { ObservableAppStoreVersionsApi } from './ObservableAPI.ts';

import { AppStoreVersionsApiRequestFactory, AppStoreVersionsApiResponseProcessor} from "../apis/AppStoreVersionsApi.ts";
export class PromiseAppStoreVersionsApi {
    private api: ObservableAppStoreVersionsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: AppStoreVersionsApiRequestFactory,
        responseProcessor?: AppStoreVersionsApiResponseProcessor
    ) {
        this.api = new ObservableAppStoreVersionsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAgeRatingDeclarations the fields to include for returned resources of type ageRatingDeclarations
     */
    public appStoreVersionsAgeRatingDeclarationGetToOneRelatedWithHttpInfo(id: string, fieldsAgeRatingDeclarations?: Array<'ageRatingOverride' | 'alcoholTobaccoOrDrugUseOrReferences' | 'contests' | 'gambling' | 'gamblingAndContests' | 'gamblingSimulated' | 'horrorOrFearThemes' | 'kidsAgeBand' | 'matureOrSuggestiveThemes' | 'medicalOrTreatmentInformation' | 'profanityOrCrudeHumor' | 'seventeenPlus' | 'sexualContentGraphicAndNudity' | 'sexualContentOrNudity' | 'unrestrictedWebAccess' | 'violenceCartoonOrFantasy' | 'violenceRealistic' | 'violenceRealisticProlongedGraphicOrSadistic'>, _options?: Configuration): Promise<HttpInfo<AgeRatingDeclarationWithoutIncludesResponse>> {
        const result = this.api.appStoreVersionsAgeRatingDeclarationGetToOneRelatedWithHttpInfo(id, fieldsAgeRatingDeclarations, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAgeRatingDeclarations the fields to include for returned resources of type ageRatingDeclarations
     */
    public appStoreVersionsAgeRatingDeclarationGetToOneRelated(id: string, fieldsAgeRatingDeclarations?: Array<'ageRatingOverride' | 'alcoholTobaccoOrDrugUseOrReferences' | 'contests' | 'gambling' | 'gamblingAndContests' | 'gamblingSimulated' | 'horrorOrFearThemes' | 'kidsAgeBand' | 'matureOrSuggestiveThemes' | 'medicalOrTreatmentInformation' | 'profanityOrCrudeHumor' | 'seventeenPlus' | 'sexualContentGraphicAndNudity' | 'sexualContentOrNudity' | 'unrestrictedWebAccess' | 'violenceCartoonOrFantasy' | 'violenceRealistic' | 'violenceRealisticProlongedGraphicOrSadistic'>, _options?: Configuration): Promise<AgeRatingDeclarationWithoutIncludesResponse> {
        const result = this.api.appStoreVersionsAgeRatingDeclarationGetToOneRelated(id, fieldsAgeRatingDeclarations, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAlternativeDistributionPackages the fields to include for returned resources of type alternativeDistributionPackages
     * @param fieldsAlternativeDistributionPackageVersions the fields to include for returned resources of type alternativeDistributionPackageVersions
     * @param limitVersions maximum number of related versions returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appStoreVersionsAlternativeDistributionPackageGetToOneRelatedWithHttpInfo(id: string, fieldsAlternativeDistributionPackages?: Array<'appStoreVersion' | 'versions'>, fieldsAlternativeDistributionPackageVersions?: Array<'alternativeDistributionPackage' | 'deltas' | 'fileChecksum' | 'state' | 'url' | 'urlExpirationDate' | 'variants' | 'version'>, limitVersions?: number, include?: Array<'versions'>, _options?: Configuration): Promise<HttpInfo<AlternativeDistributionPackageResponse>> {
        const result = this.api.appStoreVersionsAlternativeDistributionPackageGetToOneRelatedWithHttpInfo(id, fieldsAlternativeDistributionPackages, fieldsAlternativeDistributionPackageVersions, limitVersions, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAlternativeDistributionPackages the fields to include for returned resources of type alternativeDistributionPackages
     * @param fieldsAlternativeDistributionPackageVersions the fields to include for returned resources of type alternativeDistributionPackageVersions
     * @param limitVersions maximum number of related versions returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appStoreVersionsAlternativeDistributionPackageGetToOneRelated(id: string, fieldsAlternativeDistributionPackages?: Array<'appStoreVersion' | 'versions'>, fieldsAlternativeDistributionPackageVersions?: Array<'alternativeDistributionPackage' | 'deltas' | 'fileChecksum' | 'state' | 'url' | 'urlExpirationDate' | 'variants' | 'version'>, limitVersions?: number, include?: Array<'versions'>, _options?: Configuration): Promise<AlternativeDistributionPackageResponse> {
        const result = this.api.appStoreVersionsAlternativeDistributionPackageGetToOneRelated(id, fieldsAlternativeDistributionPackages, fieldsAlternativeDistributionPackageVersions, limitVersions, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppClips the fields to include for returned resources of type appClips
     * @param fieldsAppClipAppStoreReviewDetails the fields to include for returned resources of type appClipAppStoreReviewDetails
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsAppClipDefaultExperiences the fields to include for returned resources of type appClipDefaultExperiences
     * @param fieldsAppClipDefaultExperienceLocalizations the fields to include for returned resources of type appClipDefaultExperienceLocalizations
     * @param limitAppClipDefaultExperienceLocalizations maximum number of related appClipDefaultExperienceLocalizations returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appStoreVersionsAppClipDefaultExperienceGetToOneRelatedWithHttpInfo(id: string, fieldsAppClips?: Array<'app' | 'appClipAdvancedExperiences' | 'appClipDefaultExperiences' | 'bundleId'>, fieldsAppClipAppStoreReviewDetails?: Array<'appClipDefaultExperience' | 'invocationUrls'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsAppClipDefaultExperiences?: Array<'action' | 'appClip' | 'appClipAppStoreReviewDetail' | 'appClipDefaultExperienceLocalizations' | 'appClipDefaultExperienceTemplate' | 'releaseWithAppStoreVersion'>, fieldsAppClipDefaultExperienceLocalizations?: Array<'appClipDefaultExperience' | 'appClipHeaderImage' | 'locale' | 'subtitle'>, limitAppClipDefaultExperienceLocalizations?: number, include?: Array<'appClip' | 'appClipAppStoreReviewDetail' | 'appClipDefaultExperienceLocalizations' | 'releaseWithAppStoreVersion'>, _options?: Configuration): Promise<HttpInfo<AppClipDefaultExperienceResponse>> {
        const result = this.api.appStoreVersionsAppClipDefaultExperienceGetToOneRelatedWithHttpInfo(id, fieldsAppClips, fieldsAppClipAppStoreReviewDetails, fieldsAppStoreVersions, fieldsAppClipDefaultExperiences, fieldsAppClipDefaultExperienceLocalizations, limitAppClipDefaultExperienceLocalizations, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppClips the fields to include for returned resources of type appClips
     * @param fieldsAppClipAppStoreReviewDetails the fields to include for returned resources of type appClipAppStoreReviewDetails
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsAppClipDefaultExperiences the fields to include for returned resources of type appClipDefaultExperiences
     * @param fieldsAppClipDefaultExperienceLocalizations the fields to include for returned resources of type appClipDefaultExperienceLocalizations
     * @param limitAppClipDefaultExperienceLocalizations maximum number of related appClipDefaultExperienceLocalizations returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appStoreVersionsAppClipDefaultExperienceGetToOneRelated(id: string, fieldsAppClips?: Array<'app' | 'appClipAdvancedExperiences' | 'appClipDefaultExperiences' | 'bundleId'>, fieldsAppClipAppStoreReviewDetails?: Array<'appClipDefaultExperience' | 'invocationUrls'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsAppClipDefaultExperiences?: Array<'action' | 'appClip' | 'appClipAppStoreReviewDetail' | 'appClipDefaultExperienceLocalizations' | 'appClipDefaultExperienceTemplate' | 'releaseWithAppStoreVersion'>, fieldsAppClipDefaultExperienceLocalizations?: Array<'appClipDefaultExperience' | 'appClipHeaderImage' | 'locale' | 'subtitle'>, limitAppClipDefaultExperienceLocalizations?: number, include?: Array<'appClip' | 'appClipAppStoreReviewDetail' | 'appClipDefaultExperienceLocalizations' | 'releaseWithAppStoreVersion'>, _options?: Configuration): Promise<AppClipDefaultExperienceResponse> {
        const result = this.api.appStoreVersionsAppClipDefaultExperienceGetToOneRelated(id, fieldsAppClips, fieldsAppClipAppStoreReviewDetails, fieldsAppStoreVersions, fieldsAppClipDefaultExperiences, fieldsAppClipDefaultExperienceLocalizations, limitAppClipDefaultExperienceLocalizations, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public appStoreVersionsAppClipDefaultExperienceGetToOneRelationshipWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<AppStoreVersionAppClipDefaultExperienceLinkageResponse>> {
        const result = this.api.appStoreVersionsAppClipDefaultExperienceGetToOneRelationshipWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public appStoreVersionsAppClipDefaultExperienceGetToOneRelationship(id: string, _options?: Configuration): Promise<AppStoreVersionAppClipDefaultExperienceLinkageResponse> {
        const result = this.api.appStoreVersionsAppClipDefaultExperienceGetToOneRelationship(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param appStoreVersionAppClipDefaultExperienceLinkageRequest Related linkage
     */
    public appStoreVersionsAppClipDefaultExperienceUpdateToOneRelationshipWithHttpInfo(id: string, appStoreVersionAppClipDefaultExperienceLinkageRequest: AppStoreVersionAppClipDefaultExperienceLinkageRequest, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.appStoreVersionsAppClipDefaultExperienceUpdateToOneRelationshipWithHttpInfo(id, appStoreVersionAppClipDefaultExperienceLinkageRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param appStoreVersionAppClipDefaultExperienceLinkageRequest Related linkage
     */
    public appStoreVersionsAppClipDefaultExperienceUpdateToOneRelationship(id: string, appStoreVersionAppClipDefaultExperienceLinkageRequest: AppStoreVersionAppClipDefaultExperienceLinkageRequest, _options?: Configuration): Promise<void> {
        const result = this.api.appStoreVersionsAppClipDefaultExperienceUpdateToOneRelationship(id, appStoreVersionAppClipDefaultExperienceLinkageRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppStoreReviewDetails the fields to include for returned resources of type appStoreReviewDetails
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsAppStoreReviewAttachments the fields to include for returned resources of type appStoreReviewAttachments
     * @param limitAppStoreReviewAttachments maximum number of related appStoreReviewAttachments returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appStoreVersionsAppStoreReviewDetailGetToOneRelatedWithHttpInfo(id: string, fieldsAppStoreReviewDetails?: Array<'appStoreReviewAttachments' | 'appStoreVersion' | 'contactEmail' | 'contactFirstName' | 'contactLastName' | 'contactPhone' | 'demoAccountName' | 'demoAccountPassword' | 'demoAccountRequired' | 'notes'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsAppStoreReviewAttachments?: Array<'appStoreReviewDetail' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, limitAppStoreReviewAttachments?: number, include?: Array<'appStoreReviewAttachments' | 'appStoreVersion'>, _options?: Configuration): Promise<HttpInfo<AppStoreReviewDetailResponse>> {
        const result = this.api.appStoreVersionsAppStoreReviewDetailGetToOneRelatedWithHttpInfo(id, fieldsAppStoreReviewDetails, fieldsAppStoreVersions, fieldsAppStoreReviewAttachments, limitAppStoreReviewAttachments, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppStoreReviewDetails the fields to include for returned resources of type appStoreReviewDetails
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsAppStoreReviewAttachments the fields to include for returned resources of type appStoreReviewAttachments
     * @param limitAppStoreReviewAttachments maximum number of related appStoreReviewAttachments returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appStoreVersionsAppStoreReviewDetailGetToOneRelated(id: string, fieldsAppStoreReviewDetails?: Array<'appStoreReviewAttachments' | 'appStoreVersion' | 'contactEmail' | 'contactFirstName' | 'contactLastName' | 'contactPhone' | 'demoAccountName' | 'demoAccountPassword' | 'demoAccountRequired' | 'notes'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsAppStoreReviewAttachments?: Array<'appStoreReviewDetail' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, limitAppStoreReviewAttachments?: number, include?: Array<'appStoreReviewAttachments' | 'appStoreVersion'>, _options?: Configuration): Promise<AppStoreReviewDetailResponse> {
        const result = this.api.appStoreVersionsAppStoreReviewDetailGetToOneRelated(id, fieldsAppStoreReviewDetails, fieldsAppStoreVersions, fieldsAppStoreReviewAttachments, limitAppStoreReviewAttachments, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterState filter by attribute \&#39;state\&#39;
     * @param fieldsAppStoreVersionExperiments the fields to include for returned resources of type appStoreVersionExperiments
     * @param fieldsAppStoreVersionExperimentTreatments the fields to include for returned resources of type appStoreVersionExperimentTreatments
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param limit maximum resources per page
     * @param limitAppStoreVersionExperimentTreatments maximum number of related appStoreVersionExperimentTreatments returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appStoreVersionsAppStoreVersionExperimentsGetToManyRelatedWithHttpInfo(id: string, filterState?: Array<'PREPARE_FOR_SUBMISSION' | 'READY_FOR_REVIEW' | 'WAITING_FOR_REVIEW' | 'IN_REVIEW' | 'ACCEPTED' | 'APPROVED' | 'REJECTED' | 'COMPLETED' | 'STOPPED'>, fieldsAppStoreVersionExperiments?: Array<'appStoreVersion' | 'appStoreVersionExperimentTreatments' | 'endDate' | 'name' | 'reviewRequired' | 'startDate' | 'started' | 'state' | 'trafficProportion'>, fieldsAppStoreVersionExperimentTreatments?: Array<'appIcon' | 'appIconName' | 'appStoreVersionExperiment' | 'appStoreVersionExperimentTreatmentLocalizations' | 'appStoreVersionExperimentV2' | 'name' | 'promotedDate'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, limit?: number, limitAppStoreVersionExperimentTreatments?: number, include?: Array<'appStoreVersion' | 'appStoreVersionExperimentTreatments'>, _options?: Configuration): Promise<HttpInfo<AppStoreVersionExperimentsResponse>> {
        const result = this.api.appStoreVersionsAppStoreVersionExperimentsGetToManyRelatedWithHttpInfo(id, filterState, fieldsAppStoreVersionExperiments, fieldsAppStoreVersionExperimentTreatments, fieldsAppStoreVersions, limit, limitAppStoreVersionExperimentTreatments, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterState filter by attribute \&#39;state\&#39;
     * @param fieldsAppStoreVersionExperiments the fields to include for returned resources of type appStoreVersionExperiments
     * @param fieldsAppStoreVersionExperimentTreatments the fields to include for returned resources of type appStoreVersionExperimentTreatments
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param limit maximum resources per page
     * @param limitAppStoreVersionExperimentTreatments maximum number of related appStoreVersionExperimentTreatments returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appStoreVersionsAppStoreVersionExperimentsGetToManyRelated(id: string, filterState?: Array<'PREPARE_FOR_SUBMISSION' | 'READY_FOR_REVIEW' | 'WAITING_FOR_REVIEW' | 'IN_REVIEW' | 'ACCEPTED' | 'APPROVED' | 'REJECTED' | 'COMPLETED' | 'STOPPED'>, fieldsAppStoreVersionExperiments?: Array<'appStoreVersion' | 'appStoreVersionExperimentTreatments' | 'endDate' | 'name' | 'reviewRequired' | 'startDate' | 'started' | 'state' | 'trafficProportion'>, fieldsAppStoreVersionExperimentTreatments?: Array<'appIcon' | 'appIconName' | 'appStoreVersionExperiment' | 'appStoreVersionExperimentTreatmentLocalizations' | 'appStoreVersionExperimentV2' | 'name' | 'promotedDate'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, limit?: number, limitAppStoreVersionExperimentTreatments?: number, include?: Array<'appStoreVersion' | 'appStoreVersionExperimentTreatments'>, _options?: Configuration): Promise<AppStoreVersionExperimentsResponse> {
        const result = this.api.appStoreVersionsAppStoreVersionExperimentsGetToManyRelated(id, filterState, fieldsAppStoreVersionExperiments, fieldsAppStoreVersionExperimentTreatments, fieldsAppStoreVersions, limit, limitAppStoreVersionExperimentTreatments, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterState filter by attribute \&#39;state\&#39;
     * @param fieldsAppStoreVersionExperiments the fields to include for returned resources of type appStoreVersionExperiments
     * @param fieldsAppStoreVersionExperimentTreatments the fields to include for returned resources of type appStoreVersionExperimentTreatments
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param limit maximum resources per page
     * @param limitControlVersions maximum number of related controlVersions returned (when they are included)
     * @param limitAppStoreVersionExperimentTreatments maximum number of related appStoreVersionExperimentTreatments returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appStoreVersionsAppStoreVersionExperimentsV2GetToManyRelatedWithHttpInfo(id: string, filterState?: Array<'PREPARE_FOR_SUBMISSION' | 'READY_FOR_REVIEW' | 'WAITING_FOR_REVIEW' | 'IN_REVIEW' | 'ACCEPTED' | 'APPROVED' | 'REJECTED' | 'COMPLETED' | 'STOPPED'>, fieldsAppStoreVersionExperiments?: Array<'app' | 'appStoreVersionExperimentTreatments' | 'controlVersions' | 'endDate' | 'latestControlVersion' | 'name' | 'platform' | 'reviewRequired' | 'startDate' | 'started' | 'state' | 'trafficProportion'>, fieldsAppStoreVersionExperimentTreatments?: Array<'appIcon' | 'appIconName' | 'appStoreVersionExperiment' | 'appStoreVersionExperimentTreatmentLocalizations' | 'appStoreVersionExperimentV2' | 'name' | 'promotedDate'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, limit?: number, limitControlVersions?: number, limitAppStoreVersionExperimentTreatments?: number, include?: Array<'app' | 'appStoreVersionExperimentTreatments' | 'controlVersions' | 'latestControlVersion'>, _options?: Configuration): Promise<HttpInfo<AppStoreVersionExperimentsV2Response>> {
        const result = this.api.appStoreVersionsAppStoreVersionExperimentsV2GetToManyRelatedWithHttpInfo(id, filterState, fieldsAppStoreVersionExperiments, fieldsAppStoreVersionExperimentTreatments, fieldsAppStoreVersions, fieldsApps, limit, limitControlVersions, limitAppStoreVersionExperimentTreatments, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterState filter by attribute \&#39;state\&#39;
     * @param fieldsAppStoreVersionExperiments the fields to include for returned resources of type appStoreVersionExperiments
     * @param fieldsAppStoreVersionExperimentTreatments the fields to include for returned resources of type appStoreVersionExperimentTreatments
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param limit maximum resources per page
     * @param limitControlVersions maximum number of related controlVersions returned (when they are included)
     * @param limitAppStoreVersionExperimentTreatments maximum number of related appStoreVersionExperimentTreatments returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appStoreVersionsAppStoreVersionExperimentsV2GetToManyRelated(id: string, filterState?: Array<'PREPARE_FOR_SUBMISSION' | 'READY_FOR_REVIEW' | 'WAITING_FOR_REVIEW' | 'IN_REVIEW' | 'ACCEPTED' | 'APPROVED' | 'REJECTED' | 'COMPLETED' | 'STOPPED'>, fieldsAppStoreVersionExperiments?: Array<'app' | 'appStoreVersionExperimentTreatments' | 'controlVersions' | 'endDate' | 'latestControlVersion' | 'name' | 'platform' | 'reviewRequired' | 'startDate' | 'started' | 'state' | 'trafficProportion'>, fieldsAppStoreVersionExperimentTreatments?: Array<'appIcon' | 'appIconName' | 'appStoreVersionExperiment' | 'appStoreVersionExperimentTreatmentLocalizations' | 'appStoreVersionExperimentV2' | 'name' | 'promotedDate'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, limit?: number, limitControlVersions?: number, limitAppStoreVersionExperimentTreatments?: number, include?: Array<'app' | 'appStoreVersionExperimentTreatments' | 'controlVersions' | 'latestControlVersion'>, _options?: Configuration): Promise<AppStoreVersionExperimentsV2Response> {
        const result = this.api.appStoreVersionsAppStoreVersionExperimentsV2GetToManyRelated(id, filterState, fieldsAppStoreVersionExperiments, fieldsAppStoreVersionExperimentTreatments, fieldsAppStoreVersions, fieldsApps, limit, limitControlVersions, limitAppStoreVersionExperimentTreatments, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterLocale filter by attribute \&#39;locale\&#39;
     * @param fieldsAppScreenshotSets the fields to include for returned resources of type appScreenshotSets
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsAppPreviewSets the fields to include for returned resources of type appPreviewSets
     * @param fieldsAppStoreVersionLocalizations the fields to include for returned resources of type appStoreVersionLocalizations
     * @param limit maximum resources per page
     * @param limitAppScreenshotSets maximum number of related appScreenshotSets returned (when they are included)
     * @param limitAppPreviewSets maximum number of related appPreviewSets returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appStoreVersionsAppStoreVersionLocalizationsGetToManyRelatedWithHttpInfo(id: string, filterLocale?: Array<string>, fieldsAppScreenshotSets?: Array<'appCustomProductPageLocalization' | 'appScreenshots' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'screenshotDisplayType'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsAppPreviewSets?: Array<'appCustomProductPageLocalization' | 'appPreviews' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'previewType'>, fieldsAppStoreVersionLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersion' | 'description' | 'keywords' | 'locale' | 'marketingUrl' | 'promotionalText' | 'supportUrl' | 'whatsNew'>, limit?: number, limitAppScreenshotSets?: number, limitAppPreviewSets?: number, include?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersion'>, _options?: Configuration): Promise<HttpInfo<AppStoreVersionLocalizationsResponse>> {
        const result = this.api.appStoreVersionsAppStoreVersionLocalizationsGetToManyRelatedWithHttpInfo(id, filterLocale, fieldsAppScreenshotSets, fieldsAppStoreVersions, fieldsAppPreviewSets, fieldsAppStoreVersionLocalizations, limit, limitAppScreenshotSets, limitAppPreviewSets, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterLocale filter by attribute \&#39;locale\&#39;
     * @param fieldsAppScreenshotSets the fields to include for returned resources of type appScreenshotSets
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsAppPreviewSets the fields to include for returned resources of type appPreviewSets
     * @param fieldsAppStoreVersionLocalizations the fields to include for returned resources of type appStoreVersionLocalizations
     * @param limit maximum resources per page
     * @param limitAppScreenshotSets maximum number of related appScreenshotSets returned (when they are included)
     * @param limitAppPreviewSets maximum number of related appPreviewSets returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appStoreVersionsAppStoreVersionLocalizationsGetToManyRelated(id: string, filterLocale?: Array<string>, fieldsAppScreenshotSets?: Array<'appCustomProductPageLocalization' | 'appScreenshots' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'screenshotDisplayType'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsAppPreviewSets?: Array<'appCustomProductPageLocalization' | 'appPreviews' | 'appStoreVersionExperimentTreatmentLocalization' | 'appStoreVersionLocalization' | 'previewType'>, fieldsAppStoreVersionLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersion' | 'description' | 'keywords' | 'locale' | 'marketingUrl' | 'promotionalText' | 'supportUrl' | 'whatsNew'>, limit?: number, limitAppScreenshotSets?: number, limitAppPreviewSets?: number, include?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersion'>, _options?: Configuration): Promise<AppStoreVersionLocalizationsResponse> {
        const result = this.api.appStoreVersionsAppStoreVersionLocalizationsGetToManyRelated(id, filterLocale, fieldsAppScreenshotSets, fieldsAppStoreVersions, fieldsAppPreviewSets, fieldsAppStoreVersionLocalizations, limit, limitAppScreenshotSets, limitAppPreviewSets, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppStoreVersionPhasedReleases the fields to include for returned resources of type appStoreVersionPhasedReleases
     */
    public appStoreVersionsAppStoreVersionPhasedReleaseGetToOneRelatedWithHttpInfo(id: string, fieldsAppStoreVersionPhasedReleases?: Array<'appStoreVersion' | 'currentDayNumber' | 'phasedReleaseState' | 'startDate' | 'totalPauseDuration'>, _options?: Configuration): Promise<HttpInfo<AppStoreVersionPhasedReleaseWithoutIncludesResponse>> {
        const result = this.api.appStoreVersionsAppStoreVersionPhasedReleaseGetToOneRelatedWithHttpInfo(id, fieldsAppStoreVersionPhasedReleases, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppStoreVersionPhasedReleases the fields to include for returned resources of type appStoreVersionPhasedReleases
     */
    public appStoreVersionsAppStoreVersionPhasedReleaseGetToOneRelated(id: string, fieldsAppStoreVersionPhasedReleases?: Array<'appStoreVersion' | 'currentDayNumber' | 'phasedReleaseState' | 'startDate' | 'totalPauseDuration'>, _options?: Configuration): Promise<AppStoreVersionPhasedReleaseWithoutIncludesResponse> {
        const result = this.api.appStoreVersionsAppStoreVersionPhasedReleaseGetToOneRelated(id, fieldsAppStoreVersionPhasedReleases, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppStoreVersionSubmissions the fields to include for returned resources of type appStoreVersionSubmissions
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param include comma-separated list of relationships to include
     */
    public appStoreVersionsAppStoreVersionSubmissionGetToOneRelatedWithHttpInfo(id: string, fieldsAppStoreVersionSubmissions?: Array<'appStoreVersion'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, include?: Array<'appStoreVersion'>, _options?: Configuration): Promise<HttpInfo<AppStoreVersionSubmissionResponse>> {
        const result = this.api.appStoreVersionsAppStoreVersionSubmissionGetToOneRelatedWithHttpInfo(id, fieldsAppStoreVersionSubmissions, fieldsAppStoreVersions, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppStoreVersionSubmissions the fields to include for returned resources of type appStoreVersionSubmissions
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param include comma-separated list of relationships to include
     */
    public appStoreVersionsAppStoreVersionSubmissionGetToOneRelated(id: string, fieldsAppStoreVersionSubmissions?: Array<'appStoreVersion'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, include?: Array<'appStoreVersion'>, _options?: Configuration): Promise<AppStoreVersionSubmissionResponse> {
        const result = this.api.appStoreVersionsAppStoreVersionSubmissionGetToOneRelated(id, fieldsAppStoreVersionSubmissions, fieldsAppStoreVersions, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBuilds the fields to include for returned resources of type builds
     */
    public appStoreVersionsBuildGetToOneRelatedWithHttpInfo(id: string, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, _options?: Configuration): Promise<HttpInfo<BuildWithoutIncludesResponse>> {
        const result = this.api.appStoreVersionsBuildGetToOneRelatedWithHttpInfo(id, fieldsBuilds, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBuilds the fields to include for returned resources of type builds
     */
    public appStoreVersionsBuildGetToOneRelated(id: string, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, _options?: Configuration): Promise<BuildWithoutIncludesResponse> {
        const result = this.api.appStoreVersionsBuildGetToOneRelated(id, fieldsBuilds, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public appStoreVersionsBuildGetToOneRelationshipWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<AppStoreVersionBuildLinkageResponse>> {
        const result = this.api.appStoreVersionsBuildGetToOneRelationshipWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public appStoreVersionsBuildGetToOneRelationship(id: string, _options?: Configuration): Promise<AppStoreVersionBuildLinkageResponse> {
        const result = this.api.appStoreVersionsBuildGetToOneRelationship(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param appStoreVersionBuildLinkageRequest Related linkage
     */
    public appStoreVersionsBuildUpdateToOneRelationshipWithHttpInfo(id: string, appStoreVersionBuildLinkageRequest: AppStoreVersionBuildLinkageRequest, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.appStoreVersionsBuildUpdateToOneRelationshipWithHttpInfo(id, appStoreVersionBuildLinkageRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param appStoreVersionBuildLinkageRequest Related linkage
     */
    public appStoreVersionsBuildUpdateToOneRelationship(id: string, appStoreVersionBuildLinkageRequest: AppStoreVersionBuildLinkageRequest, _options?: Configuration): Promise<void> {
        const result = this.api.appStoreVersionsBuildUpdateToOneRelationship(id, appStoreVersionBuildLinkageRequest, _options);
        return result.toPromise();
    }

    /**
     * @param appStoreVersionCreateRequest AppStoreVersion representation
     */
    public appStoreVersionsCreateInstanceWithHttpInfo(appStoreVersionCreateRequest: AppStoreVersionCreateRequest, _options?: Configuration): Promise<HttpInfo<AppStoreVersionResponse>> {
        const result = this.api.appStoreVersionsCreateInstanceWithHttpInfo(appStoreVersionCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param appStoreVersionCreateRequest AppStoreVersion representation
     */
    public appStoreVersionsCreateInstance(appStoreVersionCreateRequest: AppStoreVersionCreateRequest, _options?: Configuration): Promise<AppStoreVersionResponse> {
        const result = this.api.appStoreVersionsCreateInstance(appStoreVersionCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterRating filter by attribute \&#39;rating\&#39;
     * @param filterTerritory filter by attribute \&#39;territory\&#39;
     * @param existsPublishedResponse filter by publishedResponse
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsCustomerReviews the fields to include for returned resources of type customerReviews
     * @param fieldsCustomerReviewResponses the fields to include for returned resources of type customerReviewResponses
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public appStoreVersionsCustomerReviewsGetToManyRelatedWithHttpInfo(id: string, filterRating?: Array<string>, filterTerritory?: Array<'ABW' | 'AFG' | 'AGO' | 'AIA' | 'ALB' | 'AND' | 'ANT' | 'ARE' | 'ARG' | 'ARM' | 'ASM' | 'ATG' | 'AUS' | 'AUT' | 'AZE' | 'BDI' | 'BEL' | 'BEN' | 'BES' | 'BFA' | 'BGD' | 'BGR' | 'BHR' | 'BHS' | 'BIH' | 'BLR' | 'BLZ' | 'BMU' | 'BOL' | 'BRA' | 'BRB' | 'BRN' | 'BTN' | 'BWA' | 'CAF' | 'CAN' | 'CHE' | 'CHL' | 'CHN' | 'CIV' | 'CMR' | 'COD' | 'COG' | 'COK' | 'COL' | 'COM' | 'CPV' | 'CRI' | 'CUB' | 'CUW' | 'CXR' | 'CYM' | 'CYP' | 'CZE' | 'DEU' | 'DJI' | 'DMA' | 'DNK' | 'DOM' | 'DZA' | 'ECU' | 'EGY' | 'ERI' | 'ESP' | 'EST' | 'ETH' | 'FIN' | 'FJI' | 'FLK' | 'FRA' | 'FRO' | 'FSM' | 'GAB' | 'GBR' | 'GEO' | 'GGY' | 'GHA' | 'GIB' | 'GIN' | 'GLP' | 'GMB' | 'GNB' | 'GNQ' | 'GRC' | 'GRD' | 'GRL' | 'GTM' | 'GUF' | 'GUM' | 'GUY' | 'HKG' | 'HND' | 'HRV' | 'HTI' | 'HUN' | 'IDN' | 'IMN' | 'IND' | 'IRL' | 'IRQ' | 'ISL' | 'ISR' | 'ITA' | 'JAM' | 'JEY' | 'JOR' | 'JPN' | 'KAZ' | 'KEN' | 'KGZ' | 'KHM' | 'KIR' | 'KNA' | 'KOR' | 'KWT' | 'LAO' | 'LBN' | 'LBR' | 'LBY' | 'LCA' | 'LIE' | 'LKA' | 'LSO' | 'LTU' | 'LUX' | 'LVA' | 'MAC' | 'MAR' | 'MCO' | 'MDA' | 'MDG' | 'MDV' | 'MEX' | 'MHL' | 'MKD' | 'MLI' | 'MLT' | 'MMR' | 'MNE' | 'MNG' | 'MNP' | 'MOZ' | 'MRT' | 'MSR' | 'MTQ' | 'MUS' | 'MWI' | 'MYS' | 'MYT' | 'NAM' | 'NCL' | 'NER' | 'NFK' | 'NGA' | 'NIC' | 'NIU' | 'NLD' | 'NOR' | 'NPL' | 'NRU' | 'NZL' | 'OMN' | 'PAK' | 'PAN' | 'PER' | 'PHL' | 'PLW' | 'PNG' | 'POL' | 'PRI' | 'PRT' | 'PRY' | 'PSE' | 'PYF' | 'QAT' | 'REU' | 'ROU' | 'RUS' | 'RWA' | 'SAU' | 'SEN' | 'SGP' | 'SHN' | 'SLB' | 'SLE' | 'SLV' | 'SMR' | 'SOM' | 'SPM' | 'SRB' | 'SSD' | 'STP' | 'SUR' | 'SVK' | 'SVN' | 'SWE' | 'SWZ' | 'SXM' | 'SYC' | 'TCA' | 'TCD' | 'TGO' | 'THA' | 'TJK' | 'TKM' | 'TLS' | 'TON' | 'TTO' | 'TUN' | 'TUR' | 'TUV' | 'TWN' | 'TZA' | 'UGA' | 'UKR' | 'UMI' | 'URY' | 'USA' | 'UZB' | 'VAT' | 'VCT' | 'VEN' | 'VGB' | 'VIR' | 'VNM' | 'VUT' | 'WLF' | 'WSM' | 'YEM' | 'ZAF' | 'ZMB' | 'ZWE'>, existsPublishedResponse?: boolean, sort?: Array<'createdDate' | '-createdDate' | 'rating' | '-rating'>, fieldsCustomerReviews?: Array<'body' | 'createdDate' | 'rating' | 'response' | 'reviewerNickname' | 'territory' | 'title'>, fieldsCustomerReviewResponses?: Array<'lastModifiedDate' | 'responseBody' | 'review' | 'state'>, limit?: number, include?: Array<'response'>, _options?: Configuration): Promise<HttpInfo<CustomerReviewsResponse>> {
        const result = this.api.appStoreVersionsCustomerReviewsGetToManyRelatedWithHttpInfo(id, filterRating, filterTerritory, existsPublishedResponse, sort, fieldsCustomerReviews, fieldsCustomerReviewResponses, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterRating filter by attribute \&#39;rating\&#39;
     * @param filterTerritory filter by attribute \&#39;territory\&#39;
     * @param existsPublishedResponse filter by publishedResponse
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsCustomerReviews the fields to include for returned resources of type customerReviews
     * @param fieldsCustomerReviewResponses the fields to include for returned resources of type customerReviewResponses
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public appStoreVersionsCustomerReviewsGetToManyRelated(id: string, filterRating?: Array<string>, filterTerritory?: Array<'ABW' | 'AFG' | 'AGO' | 'AIA' | 'ALB' | 'AND' | 'ANT' | 'ARE' | 'ARG' | 'ARM' | 'ASM' | 'ATG' | 'AUS' | 'AUT' | 'AZE' | 'BDI' | 'BEL' | 'BEN' | 'BES' | 'BFA' | 'BGD' | 'BGR' | 'BHR' | 'BHS' | 'BIH' | 'BLR' | 'BLZ' | 'BMU' | 'BOL' | 'BRA' | 'BRB' | 'BRN' | 'BTN' | 'BWA' | 'CAF' | 'CAN' | 'CHE' | 'CHL' | 'CHN' | 'CIV' | 'CMR' | 'COD' | 'COG' | 'COK' | 'COL' | 'COM' | 'CPV' | 'CRI' | 'CUB' | 'CUW' | 'CXR' | 'CYM' | 'CYP' | 'CZE' | 'DEU' | 'DJI' | 'DMA' | 'DNK' | 'DOM' | 'DZA' | 'ECU' | 'EGY' | 'ERI' | 'ESP' | 'EST' | 'ETH' | 'FIN' | 'FJI' | 'FLK' | 'FRA' | 'FRO' | 'FSM' | 'GAB' | 'GBR' | 'GEO' | 'GGY' | 'GHA' | 'GIB' | 'GIN' | 'GLP' | 'GMB' | 'GNB' | 'GNQ' | 'GRC' | 'GRD' | 'GRL' | 'GTM' | 'GUF' | 'GUM' | 'GUY' | 'HKG' | 'HND' | 'HRV' | 'HTI' | 'HUN' | 'IDN' | 'IMN' | 'IND' | 'IRL' | 'IRQ' | 'ISL' | 'ISR' | 'ITA' | 'JAM' | 'JEY' | 'JOR' | 'JPN' | 'KAZ' | 'KEN' | 'KGZ' | 'KHM' | 'KIR' | 'KNA' | 'KOR' | 'KWT' | 'LAO' | 'LBN' | 'LBR' | 'LBY' | 'LCA' | 'LIE' | 'LKA' | 'LSO' | 'LTU' | 'LUX' | 'LVA' | 'MAC' | 'MAR' | 'MCO' | 'MDA' | 'MDG' | 'MDV' | 'MEX' | 'MHL' | 'MKD' | 'MLI' | 'MLT' | 'MMR' | 'MNE' | 'MNG' | 'MNP' | 'MOZ' | 'MRT' | 'MSR' | 'MTQ' | 'MUS' | 'MWI' | 'MYS' | 'MYT' | 'NAM' | 'NCL' | 'NER' | 'NFK' | 'NGA' | 'NIC' | 'NIU' | 'NLD' | 'NOR' | 'NPL' | 'NRU' | 'NZL' | 'OMN' | 'PAK' | 'PAN' | 'PER' | 'PHL' | 'PLW' | 'PNG' | 'POL' | 'PRI' | 'PRT' | 'PRY' | 'PSE' | 'PYF' | 'QAT' | 'REU' | 'ROU' | 'RUS' | 'RWA' | 'SAU' | 'SEN' | 'SGP' | 'SHN' | 'SLB' | 'SLE' | 'SLV' | 'SMR' | 'SOM' | 'SPM' | 'SRB' | 'SSD' | 'STP' | 'SUR' | 'SVK' | 'SVN' | 'SWE' | 'SWZ' | 'SXM' | 'SYC' | 'TCA' | 'TCD' | 'TGO' | 'THA' | 'TJK' | 'TKM' | 'TLS' | 'TON' | 'TTO' | 'TUN' | 'TUR' | 'TUV' | 'TWN' | 'TZA' | 'UGA' | 'UKR' | 'UMI' | 'URY' | 'USA' | 'UZB' | 'VAT' | 'VCT' | 'VEN' | 'VGB' | 'VIR' | 'VNM' | 'VUT' | 'WLF' | 'WSM' | 'YEM' | 'ZAF' | 'ZMB' | 'ZWE'>, existsPublishedResponse?: boolean, sort?: Array<'createdDate' | '-createdDate' | 'rating' | '-rating'>, fieldsCustomerReviews?: Array<'body' | 'createdDate' | 'rating' | 'response' | 'reviewerNickname' | 'territory' | 'title'>, fieldsCustomerReviewResponses?: Array<'lastModifiedDate' | 'responseBody' | 'review' | 'state'>, limit?: number, include?: Array<'response'>, _options?: Configuration): Promise<CustomerReviewsResponse> {
        const result = this.api.appStoreVersionsCustomerReviewsGetToManyRelated(id, filterRating, filterTerritory, existsPublishedResponse, sort, fieldsCustomerReviews, fieldsCustomerReviewResponses, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public appStoreVersionsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.appStoreVersionsDeleteInstanceWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public appStoreVersionsDeleteInstance(id: string, _options?: Configuration): Promise<void> {
        const result = this.api.appStoreVersionsDeleteInstance(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param include comma-separated list of relationships to include
     * @param fieldsAppStoreVersionExperiments the fields to include for returned resources of type appStoreVersionExperiments
     * @param fieldsAppStoreVersionSubmissions the fields to include for returned resources of type appStoreVersionSubmissions
     * @param fieldsAgeRatingDeclarations the fields to include for returned resources of type ageRatingDeclarations
     * @param fieldsAlternativeDistributionPackages the fields to include for returned resources of type alternativeDistributionPackages
     * @param fieldsCustomerReviews the fields to include for returned resources of type customerReviews
     * @param fieldsAppStoreReviewDetails the fields to include for returned resources of type appStoreReviewDetails
     * @param fieldsAppClipDefaultExperiences the fields to include for returned resources of type appClipDefaultExperiences
     * @param fieldsRoutingAppCoverages the fields to include for returned resources of type routingAppCoverages
     * @param fieldsAppStoreVersionPhasedReleases the fields to include for returned resources of type appStoreVersionPhasedReleases
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param fieldsAppStoreVersionLocalizations the fields to include for returned resources of type appStoreVersionLocalizations
     * @param limitAppStoreVersionExperiments maximum number of related appStoreVersionExperiments returned (when they are included)
     * @param limitAppStoreVersionExperimentsV2 maximum number of related appStoreVersionExperimentsV2 returned (when they are included)
     * @param limitAppStoreVersionLocalizations maximum number of related appStoreVersionLocalizations returned (when they are included)
     */
    public appStoreVersionsGetInstanceWithHttpInfo(id: string, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, include?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'build' | 'routingAppCoverage'>, fieldsAppStoreVersionExperiments?: Array<'app' | 'appStoreVersion' | 'appStoreVersionExperimentTreatments' | 'controlVersions' | 'endDate' | 'latestControlVersion' | 'name' | 'platform' | 'reviewRequired' | 'startDate' | 'started' | 'state' | 'trafficProportion'>, fieldsAppStoreVersionSubmissions?: Array<'appStoreVersion'>, fieldsAgeRatingDeclarations?: Array<'ageRatingOverride' | 'alcoholTobaccoOrDrugUseOrReferences' | 'contests' | 'gambling' | 'gamblingAndContests' | 'gamblingSimulated' | 'horrorOrFearThemes' | 'kidsAgeBand' | 'matureOrSuggestiveThemes' | 'medicalOrTreatmentInformation' | 'profanityOrCrudeHumor' | 'seventeenPlus' | 'sexualContentGraphicAndNudity' | 'sexualContentOrNudity' | 'unrestrictedWebAccess' | 'violenceCartoonOrFantasy' | 'violenceRealistic' | 'violenceRealisticProlongedGraphicOrSadistic'>, fieldsAlternativeDistributionPackages?: Array<'appStoreVersion' | 'versions'>, fieldsCustomerReviews?: Array<'body' | 'createdDate' | 'rating' | 'response' | 'reviewerNickname' | 'territory' | 'title'>, fieldsAppStoreReviewDetails?: Array<'appStoreReviewAttachments' | 'appStoreVersion' | 'contactEmail' | 'contactFirstName' | 'contactLastName' | 'contactPhone' | 'demoAccountName' | 'demoAccountPassword' | 'demoAccountRequired' | 'notes'>, fieldsAppClipDefaultExperiences?: Array<'action' | 'appClip' | 'appClipAppStoreReviewDetail' | 'appClipDefaultExperienceLocalizations' | 'appClipDefaultExperienceTemplate' | 'releaseWithAppStoreVersion'>, fieldsRoutingAppCoverages?: Array<'appStoreVersion' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, fieldsAppStoreVersionPhasedReleases?: Array<'appStoreVersion' | 'currentDayNumber' | 'phasedReleaseState' | 'startDate' | 'totalPauseDuration'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, fieldsAppStoreVersionLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersion' | 'description' | 'keywords' | 'locale' | 'marketingUrl' | 'promotionalText' | 'supportUrl' | 'whatsNew'>, limitAppStoreVersionExperiments?: number, limitAppStoreVersionExperimentsV2?: number, limitAppStoreVersionLocalizations?: number, _options?: Configuration): Promise<HttpInfo<AppStoreVersionResponse>> {
        const result = this.api.appStoreVersionsGetInstanceWithHttpInfo(id, fieldsAppStoreVersions, include, fieldsAppStoreVersionExperiments, fieldsAppStoreVersionSubmissions, fieldsAgeRatingDeclarations, fieldsAlternativeDistributionPackages, fieldsCustomerReviews, fieldsAppStoreReviewDetails, fieldsAppClipDefaultExperiences, fieldsRoutingAppCoverages, fieldsAppStoreVersionPhasedReleases, fieldsBuilds, fieldsAppStoreVersionLocalizations, limitAppStoreVersionExperiments, limitAppStoreVersionExperimentsV2, limitAppStoreVersionLocalizations, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param include comma-separated list of relationships to include
     * @param fieldsAppStoreVersionExperiments the fields to include for returned resources of type appStoreVersionExperiments
     * @param fieldsAppStoreVersionSubmissions the fields to include for returned resources of type appStoreVersionSubmissions
     * @param fieldsAgeRatingDeclarations the fields to include for returned resources of type ageRatingDeclarations
     * @param fieldsAlternativeDistributionPackages the fields to include for returned resources of type alternativeDistributionPackages
     * @param fieldsCustomerReviews the fields to include for returned resources of type customerReviews
     * @param fieldsAppStoreReviewDetails the fields to include for returned resources of type appStoreReviewDetails
     * @param fieldsAppClipDefaultExperiences the fields to include for returned resources of type appClipDefaultExperiences
     * @param fieldsRoutingAppCoverages the fields to include for returned resources of type routingAppCoverages
     * @param fieldsAppStoreVersionPhasedReleases the fields to include for returned resources of type appStoreVersionPhasedReleases
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param fieldsAppStoreVersionLocalizations the fields to include for returned resources of type appStoreVersionLocalizations
     * @param limitAppStoreVersionExperiments maximum number of related appStoreVersionExperiments returned (when they are included)
     * @param limitAppStoreVersionExperimentsV2 maximum number of related appStoreVersionExperimentsV2 returned (when they are included)
     * @param limitAppStoreVersionLocalizations maximum number of related appStoreVersionLocalizations returned (when they are included)
     */
    public appStoreVersionsGetInstance(id: string, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, include?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'build' | 'routingAppCoverage'>, fieldsAppStoreVersionExperiments?: Array<'app' | 'appStoreVersion' | 'appStoreVersionExperimentTreatments' | 'controlVersions' | 'endDate' | 'latestControlVersion' | 'name' | 'platform' | 'reviewRequired' | 'startDate' | 'started' | 'state' | 'trafficProportion'>, fieldsAppStoreVersionSubmissions?: Array<'appStoreVersion'>, fieldsAgeRatingDeclarations?: Array<'ageRatingOverride' | 'alcoholTobaccoOrDrugUseOrReferences' | 'contests' | 'gambling' | 'gamblingAndContests' | 'gamblingSimulated' | 'horrorOrFearThemes' | 'kidsAgeBand' | 'matureOrSuggestiveThemes' | 'medicalOrTreatmentInformation' | 'profanityOrCrudeHumor' | 'seventeenPlus' | 'sexualContentGraphicAndNudity' | 'sexualContentOrNudity' | 'unrestrictedWebAccess' | 'violenceCartoonOrFantasy' | 'violenceRealistic' | 'violenceRealisticProlongedGraphicOrSadistic'>, fieldsAlternativeDistributionPackages?: Array<'appStoreVersion' | 'versions'>, fieldsCustomerReviews?: Array<'body' | 'createdDate' | 'rating' | 'response' | 'reviewerNickname' | 'territory' | 'title'>, fieldsAppStoreReviewDetails?: Array<'appStoreReviewAttachments' | 'appStoreVersion' | 'contactEmail' | 'contactFirstName' | 'contactLastName' | 'contactPhone' | 'demoAccountName' | 'demoAccountPassword' | 'demoAccountRequired' | 'notes'>, fieldsAppClipDefaultExperiences?: Array<'action' | 'appClip' | 'appClipAppStoreReviewDetail' | 'appClipDefaultExperienceLocalizations' | 'appClipDefaultExperienceTemplate' | 'releaseWithAppStoreVersion'>, fieldsRoutingAppCoverages?: Array<'appStoreVersion' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, fieldsAppStoreVersionPhasedReleases?: Array<'appStoreVersion' | 'currentDayNumber' | 'phasedReleaseState' | 'startDate' | 'totalPauseDuration'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, fieldsAppStoreVersionLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersion' | 'description' | 'keywords' | 'locale' | 'marketingUrl' | 'promotionalText' | 'supportUrl' | 'whatsNew'>, limitAppStoreVersionExperiments?: number, limitAppStoreVersionExperimentsV2?: number, limitAppStoreVersionLocalizations?: number, _options?: Configuration): Promise<AppStoreVersionResponse> {
        const result = this.api.appStoreVersionsGetInstance(id, fieldsAppStoreVersions, include, fieldsAppStoreVersionExperiments, fieldsAppStoreVersionSubmissions, fieldsAgeRatingDeclarations, fieldsAlternativeDistributionPackages, fieldsCustomerReviews, fieldsAppStoreReviewDetails, fieldsAppClipDefaultExperiences, fieldsRoutingAppCoverages, fieldsAppStoreVersionPhasedReleases, fieldsBuilds, fieldsAppStoreVersionLocalizations, limitAppStoreVersionExperiments, limitAppStoreVersionExperimentsV2, limitAppStoreVersionLocalizations, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsRoutingAppCoverages the fields to include for returned resources of type routingAppCoverages
     */
    public appStoreVersionsRoutingAppCoverageGetToOneRelatedWithHttpInfo(id: string, fieldsRoutingAppCoverages?: Array<'appStoreVersion' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, _options?: Configuration): Promise<HttpInfo<RoutingAppCoverageWithoutIncludesResponse>> {
        const result = this.api.appStoreVersionsRoutingAppCoverageGetToOneRelatedWithHttpInfo(id, fieldsRoutingAppCoverages, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsRoutingAppCoverages the fields to include for returned resources of type routingAppCoverages
     */
    public appStoreVersionsRoutingAppCoverageGetToOneRelated(id: string, fieldsRoutingAppCoverages?: Array<'appStoreVersion' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, _options?: Configuration): Promise<RoutingAppCoverageWithoutIncludesResponse> {
        const result = this.api.appStoreVersionsRoutingAppCoverageGetToOneRelated(id, fieldsRoutingAppCoverages, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param appStoreVersionUpdateRequest AppStoreVersion representation
     */
    public appStoreVersionsUpdateInstanceWithHttpInfo(id: string, appStoreVersionUpdateRequest: AppStoreVersionUpdateRequest, _options?: Configuration): Promise<HttpInfo<AppStoreVersionResponse>> {
        const result = this.api.appStoreVersionsUpdateInstanceWithHttpInfo(id, appStoreVersionUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param appStoreVersionUpdateRequest AppStoreVersion representation
     */
    public appStoreVersionsUpdateInstance(id: string, appStoreVersionUpdateRequest: AppStoreVersionUpdateRequest, _options?: Configuration): Promise<AppStoreVersionResponse> {
        const result = this.api.appStoreVersionsUpdateInstance(id, appStoreVersionUpdateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableAppsApi } from './ObservableAPI.ts';

import { AppsApiRequestFactory, AppsApiResponseProcessor} from "../apis/AppsApi.ts";
export class PromiseAppsApi {
    private api: ObservableAppsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: AppsApiRequestFactory,
        responseProcessor?: AppsApiResponseProcessor
    ) {
        this.api = new ObservableAppsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAlternativeDistributionKeys the fields to include for returned resources of type alternativeDistributionKeys
     */
    public appsAlternativeDistributionKeyGetToOneRelatedWithHttpInfo(id: string, fieldsAlternativeDistributionKeys?: Array<'app' | 'publicKey'>, _options?: Configuration): Promise<HttpInfo<AlternativeDistributionKeyResponse>> {
        const result = this.api.appsAlternativeDistributionKeyGetToOneRelatedWithHttpInfo(id, fieldsAlternativeDistributionKeys, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAlternativeDistributionKeys the fields to include for returned resources of type alternativeDistributionKeys
     */
    public appsAlternativeDistributionKeyGetToOneRelated(id: string, fieldsAlternativeDistributionKeys?: Array<'app' | 'publicKey'>, _options?: Configuration): Promise<AlternativeDistributionKeyResponse> {
        const result = this.api.appsAlternativeDistributionKeyGetToOneRelated(id, fieldsAlternativeDistributionKeys, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterAccessType filter by attribute \&#39;accessType\&#39;
     * @param fieldsAnalyticsReportRequests the fields to include for returned resources of type analyticsReportRequests
     * @param fieldsAnalyticsReports the fields to include for returned resources of type analyticsReports
     * @param limit maximum resources per page
     * @param limitReports maximum number of related reports returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appsAnalyticsReportRequestsGetToManyRelatedWithHttpInfo(id: string, filterAccessType?: Array<'ONE_TIME_SNAPSHOT' | 'ONGOING'>, fieldsAnalyticsReportRequests?: Array<'accessType' | 'app' | 'reports' | 'stoppedDueToInactivity'>, fieldsAnalyticsReports?: Array<'category' | 'instances' | 'name'>, limit?: number, limitReports?: number, include?: Array<'reports'>, _options?: Configuration): Promise<HttpInfo<AnalyticsReportRequestsResponse>> {
        const result = this.api.appsAnalyticsReportRequestsGetToManyRelatedWithHttpInfo(id, filterAccessType, fieldsAnalyticsReportRequests, fieldsAnalyticsReports, limit, limitReports, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterAccessType filter by attribute \&#39;accessType\&#39;
     * @param fieldsAnalyticsReportRequests the fields to include for returned resources of type analyticsReportRequests
     * @param fieldsAnalyticsReports the fields to include for returned resources of type analyticsReports
     * @param limit maximum resources per page
     * @param limitReports maximum number of related reports returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appsAnalyticsReportRequestsGetToManyRelated(id: string, filterAccessType?: Array<'ONE_TIME_SNAPSHOT' | 'ONGOING'>, fieldsAnalyticsReportRequests?: Array<'accessType' | 'app' | 'reports' | 'stoppedDueToInactivity'>, fieldsAnalyticsReports?: Array<'category' | 'instances' | 'name'>, limit?: number, limitReports?: number, include?: Array<'reports'>, _options?: Configuration): Promise<AnalyticsReportRequestsResponse> {
        const result = this.api.appsAnalyticsReportRequestsGetToManyRelated(id, filterAccessType, fieldsAnalyticsReportRequests, fieldsAnalyticsReports, limit, limitReports, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppAvailabilities the fields to include for returned resources of type appAvailabilities
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limitAvailableTerritories maximum number of related availableTerritories returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appsAppAvailabilityGetToOneRelatedWithHttpInfo(id: string, fieldsAppAvailabilities?: Array<'app' | 'availableInNewTerritories' | 'availableTerritories'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsTerritories?: Array<'currency'>, limitAvailableTerritories?: number, include?: Array<'app' | 'availableTerritories'>, _options?: Configuration): Promise<HttpInfo<AppAvailabilityResponse>> {
        const result = this.api.appsAppAvailabilityGetToOneRelatedWithHttpInfo(id, fieldsAppAvailabilities, fieldsApps, fieldsTerritories, limitAvailableTerritories, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppAvailabilities the fields to include for returned resources of type appAvailabilities
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limitAvailableTerritories maximum number of related availableTerritories returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appsAppAvailabilityGetToOneRelated(id: string, fieldsAppAvailabilities?: Array<'app' | 'availableInNewTerritories' | 'availableTerritories'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsTerritories?: Array<'currency'>, limitAvailableTerritories?: number, include?: Array<'app' | 'availableTerritories'>, _options?: Configuration): Promise<AppAvailabilityResponse> {
        const result = this.api.appsAppAvailabilityGetToOneRelated(id, fieldsAppAvailabilities, fieldsApps, fieldsTerritories, limitAvailableTerritories, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterBundleId filter by attribute \&#39;bundleId\&#39;
     * @param fieldsAppClips the fields to include for returned resources of type appClips
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsAppClipDefaultExperiences the fields to include for returned resources of type appClipDefaultExperiences
     * @param limit maximum resources per page
     * @param limitAppClipDefaultExperiences maximum number of related appClipDefaultExperiences returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appsAppClipsGetToManyRelatedWithHttpInfo(id: string, filterBundleId?: Array<string>, fieldsAppClips?: Array<'app' | 'appClipAdvancedExperiences' | 'appClipDefaultExperiences' | 'bundleId'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsAppClipDefaultExperiences?: Array<'action' | 'appClip' | 'appClipAppStoreReviewDetail' | 'appClipDefaultExperienceLocalizations' | 'appClipDefaultExperienceTemplate' | 'releaseWithAppStoreVersion'>, limit?: number, limitAppClipDefaultExperiences?: number, include?: Array<'app' | 'appClipDefaultExperiences'>, _options?: Configuration): Promise<HttpInfo<AppClipsResponse>> {
        const result = this.api.appsAppClipsGetToManyRelatedWithHttpInfo(id, filterBundleId, fieldsAppClips, fieldsApps, fieldsAppClipDefaultExperiences, limit, limitAppClipDefaultExperiences, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterBundleId filter by attribute \&#39;bundleId\&#39;
     * @param fieldsAppClips the fields to include for returned resources of type appClips
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsAppClipDefaultExperiences the fields to include for returned resources of type appClipDefaultExperiences
     * @param limit maximum resources per page
     * @param limitAppClipDefaultExperiences maximum number of related appClipDefaultExperiences returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appsAppClipsGetToManyRelated(id: string, filterBundleId?: Array<string>, fieldsAppClips?: Array<'app' | 'appClipAdvancedExperiences' | 'appClipDefaultExperiences' | 'bundleId'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsAppClipDefaultExperiences?: Array<'action' | 'appClip' | 'appClipAppStoreReviewDetail' | 'appClipDefaultExperienceLocalizations' | 'appClipDefaultExperienceTemplate' | 'releaseWithAppStoreVersion'>, limit?: number, limitAppClipDefaultExperiences?: number, include?: Array<'app' | 'appClipDefaultExperiences'>, _options?: Configuration): Promise<AppClipsResponse> {
        const result = this.api.appsAppClipsGetToManyRelated(id, filterBundleId, fieldsAppClips, fieldsApps, fieldsAppClipDefaultExperiences, limit, limitAppClipDefaultExperiences, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterVisible filter by attribute \&#39;visible\&#39;
     * @param fieldsAppCustomProductPages the fields to include for returned resources of type appCustomProductPages
     * @param fieldsAppCustomProductPageVersions the fields to include for returned resources of type appCustomProductPageVersions
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param limit maximum resources per page
     * @param limitAppCustomProductPageVersions maximum number of related appCustomProductPageVersions returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appsAppCustomProductPagesGetToManyRelatedWithHttpInfo(id: string, filterVisible?: Array<string>, fieldsAppCustomProductPages?: Array<'app' | 'appCustomProductPageVersions' | 'appStoreVersionTemplate' | 'customProductPageTemplate' | 'name' | 'url' | 'visible'>, fieldsAppCustomProductPageVersions?: Array<'appCustomProductPage' | 'appCustomProductPageLocalizations' | 'state' | 'version'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, limit?: number, limitAppCustomProductPageVersions?: number, include?: Array<'app' | 'appCustomProductPageVersions'>, _options?: Configuration): Promise<HttpInfo<AppCustomProductPagesResponse>> {
        const result = this.api.appsAppCustomProductPagesGetToManyRelatedWithHttpInfo(id, filterVisible, fieldsAppCustomProductPages, fieldsAppCustomProductPageVersions, fieldsApps, limit, limitAppCustomProductPageVersions, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterVisible filter by attribute \&#39;visible\&#39;
     * @param fieldsAppCustomProductPages the fields to include for returned resources of type appCustomProductPages
     * @param fieldsAppCustomProductPageVersions the fields to include for returned resources of type appCustomProductPageVersions
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param limit maximum resources per page
     * @param limitAppCustomProductPageVersions maximum number of related appCustomProductPageVersions returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appsAppCustomProductPagesGetToManyRelated(id: string, filterVisible?: Array<string>, fieldsAppCustomProductPages?: Array<'app' | 'appCustomProductPageVersions' | 'appStoreVersionTemplate' | 'customProductPageTemplate' | 'name' | 'url' | 'visible'>, fieldsAppCustomProductPageVersions?: Array<'appCustomProductPage' | 'appCustomProductPageLocalizations' | 'state' | 'version'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, limit?: number, limitAppCustomProductPageVersions?: number, include?: Array<'app' | 'appCustomProductPageVersions'>, _options?: Configuration): Promise<AppCustomProductPagesResponse> {
        const result = this.api.appsAppCustomProductPagesGetToManyRelated(id, filterVisible, fieldsAppCustomProductPages, fieldsAppCustomProductPageVersions, fieldsApps, limit, limitAppCustomProductPageVersions, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterPlatform filter by attribute \&#39;platform\&#39;
     * @param filterBuilds filter by id(s) of related \&#39;builds\&#39;
     * @param fieldsAppEncryptionDeclarations the fields to include for returned resources of type appEncryptionDeclarations
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsAppEncryptionDeclarationDocuments the fields to include for returned resources of type appEncryptionDeclarationDocuments
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param limit maximum resources per page
     * @param limitBuilds maximum number of related builds returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appsAppEncryptionDeclarationsGetToManyRelatedWithHttpInfo(id: string, filterPlatform?: Array<'IOS' | 'MAC_OS' | 'TV_OS' | 'VISION_OS'>, filterBuilds?: Array<string>, fieldsAppEncryptionDeclarations?: Array<'app' | 'appDescription' | 'appEncryptionDeclarationDocument' | 'appEncryptionDeclarationState' | 'availableOnFrenchStore' | 'builds' | 'codeValue' | 'containsProprietaryCryptography' | 'containsThirdPartyCryptography' | 'createdDate' | 'documentName' | 'documentType' | 'documentUrl' | 'exempt' | 'platform' | 'uploadedDate' | 'usesEncryption'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsAppEncryptionDeclarationDocuments?: Array<'appEncryptionDeclaration' | 'assetDeliveryState' | 'assetToken' | 'downloadUrl' | 'fileName' | 'fileSize' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, limit?: number, limitBuilds?: number, include?: Array<'app' | 'appEncryptionDeclarationDocument' | 'builds'>, _options?: Configuration): Promise<HttpInfo<AppEncryptionDeclarationsResponse>> {
        const result = this.api.appsAppEncryptionDeclarationsGetToManyRelatedWithHttpInfo(id, filterPlatform, filterBuilds, fieldsAppEncryptionDeclarations, fieldsApps, fieldsAppEncryptionDeclarationDocuments, fieldsBuilds, limit, limitBuilds, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterPlatform filter by attribute \&#39;platform\&#39;
     * @param filterBuilds filter by id(s) of related \&#39;builds\&#39;
     * @param fieldsAppEncryptionDeclarations the fields to include for returned resources of type appEncryptionDeclarations
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsAppEncryptionDeclarationDocuments the fields to include for returned resources of type appEncryptionDeclarationDocuments
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param limit maximum resources per page
     * @param limitBuilds maximum number of related builds returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appsAppEncryptionDeclarationsGetToManyRelated(id: string, filterPlatform?: Array<'IOS' | 'MAC_OS' | 'TV_OS' | 'VISION_OS'>, filterBuilds?: Array<string>, fieldsAppEncryptionDeclarations?: Array<'app' | 'appDescription' | 'appEncryptionDeclarationDocument' | 'appEncryptionDeclarationState' | 'availableOnFrenchStore' | 'builds' | 'codeValue' | 'containsProprietaryCryptography' | 'containsThirdPartyCryptography' | 'createdDate' | 'documentName' | 'documentType' | 'documentUrl' | 'exempt' | 'platform' | 'uploadedDate' | 'usesEncryption'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsAppEncryptionDeclarationDocuments?: Array<'appEncryptionDeclaration' | 'assetDeliveryState' | 'assetToken' | 'downloadUrl' | 'fileName' | 'fileSize' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, limit?: number, limitBuilds?: number, include?: Array<'app' | 'appEncryptionDeclarationDocument' | 'builds'>, _options?: Configuration): Promise<AppEncryptionDeclarationsResponse> {
        const result = this.api.appsAppEncryptionDeclarationsGetToManyRelated(id, filterPlatform, filterBuilds, fieldsAppEncryptionDeclarations, fieldsApps, fieldsAppEncryptionDeclarationDocuments, fieldsBuilds, limit, limitBuilds, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterEventState filter by attribute \&#39;eventState\&#39;
     * @param filterId filter by id(s)
     * @param fieldsAppEventLocalizations the fields to include for returned resources of type appEventLocalizations
     * @param fieldsAppEvents the fields to include for returned resources of type appEvents
     * @param limit maximum resources per page
     * @param limitLocalizations maximum number of related localizations returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appsAppEventsGetToManyRelatedWithHttpInfo(id: string, filterEventState?: Array<'DRAFT' | 'READY_FOR_REVIEW' | 'WAITING_FOR_REVIEW' | 'IN_REVIEW' | 'REJECTED' | 'ACCEPTED' | 'APPROVED' | 'PUBLISHED' | 'PAST' | 'ARCHIVED'>, filterId?: Array<string>, fieldsAppEventLocalizations?: Array<'appEvent' | 'appEventScreenshots' | 'appEventVideoClips' | 'locale' | 'longDescription' | 'name' | 'shortDescription'>, fieldsAppEvents?: Array<'app' | 'archivedTerritorySchedules' | 'badge' | 'deepLink' | 'eventState' | 'localizations' | 'primaryLocale' | 'priority' | 'purchaseRequirement' | 'purpose' | 'referenceName' | 'territorySchedules'>, limit?: number, limitLocalizations?: number, include?: Array<'localizations'>, _options?: Configuration): Promise<HttpInfo<AppEventsResponse>> {
        const result = this.api.appsAppEventsGetToManyRelatedWithHttpInfo(id, filterEventState, filterId, fieldsAppEventLocalizations, fieldsAppEvents, limit, limitLocalizations, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterEventState filter by attribute \&#39;eventState\&#39;
     * @param filterId filter by id(s)
     * @param fieldsAppEventLocalizations the fields to include for returned resources of type appEventLocalizations
     * @param fieldsAppEvents the fields to include for returned resources of type appEvents
     * @param limit maximum resources per page
     * @param limitLocalizations maximum number of related localizations returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appsAppEventsGetToManyRelated(id: string, filterEventState?: Array<'DRAFT' | 'READY_FOR_REVIEW' | 'WAITING_FOR_REVIEW' | 'IN_REVIEW' | 'REJECTED' | 'ACCEPTED' | 'APPROVED' | 'PUBLISHED' | 'PAST' | 'ARCHIVED'>, filterId?: Array<string>, fieldsAppEventLocalizations?: Array<'appEvent' | 'appEventScreenshots' | 'appEventVideoClips' | 'locale' | 'longDescription' | 'name' | 'shortDescription'>, fieldsAppEvents?: Array<'app' | 'archivedTerritorySchedules' | 'badge' | 'deepLink' | 'eventState' | 'localizations' | 'primaryLocale' | 'priority' | 'purchaseRequirement' | 'purpose' | 'referenceName' | 'territorySchedules'>, limit?: number, limitLocalizations?: number, include?: Array<'localizations'>, _options?: Configuration): Promise<AppEventsResponse> {
        const result = this.api.appsAppEventsGetToManyRelated(id, filterEventState, filterId, fieldsAppEventLocalizations, fieldsAppEvents, limit, limitLocalizations, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAgeRatingDeclarations the fields to include for returned resources of type ageRatingDeclarations
     * @param fieldsAppInfos the fields to include for returned resources of type appInfos
     * @param fieldsAppInfoLocalizations the fields to include for returned resources of type appInfoLocalizations
     * @param fieldsAppCategories the fields to include for returned resources of type appCategories
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param limit maximum resources per page
     * @param limitAppInfoLocalizations maximum number of related appInfoLocalizations returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appsAppInfosGetToManyRelatedWithHttpInfo(id: string, fieldsAgeRatingDeclarations?: Array<'ageRatingOverride' | 'alcoholTobaccoOrDrugUseOrReferences' | 'contests' | 'gambling' | 'gamblingAndContests' | 'gamblingSimulated' | 'horrorOrFearThemes' | 'kidsAgeBand' | 'matureOrSuggestiveThemes' | 'medicalOrTreatmentInformation' | 'profanityOrCrudeHumor' | 'seventeenPlus' | 'sexualContentGraphicAndNudity' | 'sexualContentOrNudity' | 'unrestrictedWebAccess' | 'violenceCartoonOrFantasy' | 'violenceRealistic' | 'violenceRealisticProlongedGraphicOrSadistic'>, fieldsAppInfos?: Array<'ageRatingDeclaration' | 'app' | 'appInfoLocalizations' | 'appStoreAgeRating' | 'appStoreState' | 'brazilAgeRating' | 'brazilAgeRatingV2' | 'kidsAgeBand' | 'primaryCategory' | 'primarySubcategoryOne' | 'primarySubcategoryTwo' | 'secondaryCategory' | 'secondarySubcategoryOne' | 'secondarySubcategoryTwo' | 'state'>, fieldsAppInfoLocalizations?: Array<'appInfo' | 'locale' | 'name' | 'privacyChoicesUrl' | 'privacyPolicyText' | 'privacyPolicyUrl' | 'subtitle'>, fieldsAppCategories?: Array<'parent' | 'platforms' | 'subcategories'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, limit?: number, limitAppInfoLocalizations?: number, include?: Array<'ageRatingDeclaration' | 'app' | 'appInfoLocalizations' | 'primaryCategory' | 'primarySubcategoryOne' | 'primarySubcategoryTwo' | 'secondaryCategory' | 'secondarySubcategoryOne' | 'secondarySubcategoryTwo'>, _options?: Configuration): Promise<HttpInfo<AppInfosResponse>> {
        const result = this.api.appsAppInfosGetToManyRelatedWithHttpInfo(id, fieldsAgeRatingDeclarations, fieldsAppInfos, fieldsAppInfoLocalizations, fieldsAppCategories, fieldsApps, limit, limitAppInfoLocalizations, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAgeRatingDeclarations the fields to include for returned resources of type ageRatingDeclarations
     * @param fieldsAppInfos the fields to include for returned resources of type appInfos
     * @param fieldsAppInfoLocalizations the fields to include for returned resources of type appInfoLocalizations
     * @param fieldsAppCategories the fields to include for returned resources of type appCategories
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param limit maximum resources per page
     * @param limitAppInfoLocalizations maximum number of related appInfoLocalizations returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appsAppInfosGetToManyRelated(id: string, fieldsAgeRatingDeclarations?: Array<'ageRatingOverride' | 'alcoholTobaccoOrDrugUseOrReferences' | 'contests' | 'gambling' | 'gamblingAndContests' | 'gamblingSimulated' | 'horrorOrFearThemes' | 'kidsAgeBand' | 'matureOrSuggestiveThemes' | 'medicalOrTreatmentInformation' | 'profanityOrCrudeHumor' | 'seventeenPlus' | 'sexualContentGraphicAndNudity' | 'sexualContentOrNudity' | 'unrestrictedWebAccess' | 'violenceCartoonOrFantasy' | 'violenceRealistic' | 'violenceRealisticProlongedGraphicOrSadistic'>, fieldsAppInfos?: Array<'ageRatingDeclaration' | 'app' | 'appInfoLocalizations' | 'appStoreAgeRating' | 'appStoreState' | 'brazilAgeRating' | 'brazilAgeRatingV2' | 'kidsAgeBand' | 'primaryCategory' | 'primarySubcategoryOne' | 'primarySubcategoryTwo' | 'secondaryCategory' | 'secondarySubcategoryOne' | 'secondarySubcategoryTwo' | 'state'>, fieldsAppInfoLocalizations?: Array<'appInfo' | 'locale' | 'name' | 'privacyChoicesUrl' | 'privacyPolicyText' | 'privacyPolicyUrl' | 'subtitle'>, fieldsAppCategories?: Array<'parent' | 'platforms' | 'subcategories'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, limit?: number, limitAppInfoLocalizations?: number, include?: Array<'ageRatingDeclaration' | 'app' | 'appInfoLocalizations' | 'primaryCategory' | 'primarySubcategoryOne' | 'primarySubcategoryTwo' | 'secondaryCategory' | 'secondarySubcategoryOne' | 'secondarySubcategoryTwo'>, _options?: Configuration): Promise<AppInfosResponse> {
        const result = this.api.appsAppInfosGetToManyRelated(id, fieldsAgeRatingDeclarations, fieldsAppInfos, fieldsAppInfoLocalizations, fieldsAppCategories, fieldsApps, limit, limitAppInfoLocalizations, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterTerritory filter by id(s) of related \&#39;territory\&#39;
     * @param fieldsAppPricePoints the fields to include for returned resources of type appPricePoints
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public appsAppPricePointsGetToManyRelatedWithHttpInfo(id: string, filterTerritory?: Array<string>, fieldsAppPricePoints?: Array<'app' | 'customerPrice' | 'equalizations' | 'proceeds' | 'territory'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsTerritories?: Array<'currency'>, limit?: number, include?: Array<'app' | 'territory'>, _options?: Configuration): Promise<HttpInfo<AppPricePointsV3Response>> {
        const result = this.api.appsAppPricePointsGetToManyRelatedWithHttpInfo(id, filterTerritory, fieldsAppPricePoints, fieldsApps, fieldsTerritories, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterTerritory filter by id(s) of related \&#39;territory\&#39;
     * @param fieldsAppPricePoints the fields to include for returned resources of type appPricePoints
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public appsAppPricePointsGetToManyRelated(id: string, filterTerritory?: Array<string>, fieldsAppPricePoints?: Array<'app' | 'customerPrice' | 'equalizations' | 'proceeds' | 'territory'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsTerritories?: Array<'currency'>, limit?: number, include?: Array<'app' | 'territory'>, _options?: Configuration): Promise<AppPricePointsV3Response> {
        const result = this.api.appsAppPricePointsGetToManyRelated(id, filterTerritory, fieldsAppPricePoints, fieldsApps, fieldsTerritories, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppPrices the fields to include for returned resources of type appPrices
     * @param fieldsAppPriceSchedules the fields to include for returned resources of type appPriceSchedules
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limitManualPrices maximum number of related manualPrices returned (when they are included)
     * @param limitAutomaticPrices maximum number of related automaticPrices returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appsAppPriceScheduleGetToOneRelatedWithHttpInfo(id: string, fieldsAppPrices?: Array<'appPricePoint' | 'endDate' | 'manual' | 'startDate' | 'territory'>, fieldsAppPriceSchedules?: Array<'app' | 'automaticPrices' | 'baseTerritory' | 'manualPrices'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsTerritories?: Array<'currency'>, limitManualPrices?: number, limitAutomaticPrices?: number, include?: Array<'app' | 'automaticPrices' | 'baseTerritory' | 'manualPrices'>, _options?: Configuration): Promise<HttpInfo<AppPriceScheduleResponse>> {
        const result = this.api.appsAppPriceScheduleGetToOneRelatedWithHttpInfo(id, fieldsAppPrices, fieldsAppPriceSchedules, fieldsApps, fieldsTerritories, limitManualPrices, limitAutomaticPrices, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppPrices the fields to include for returned resources of type appPrices
     * @param fieldsAppPriceSchedules the fields to include for returned resources of type appPriceSchedules
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limitManualPrices maximum number of related manualPrices returned (when they are included)
     * @param limitAutomaticPrices maximum number of related automaticPrices returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appsAppPriceScheduleGetToOneRelated(id: string, fieldsAppPrices?: Array<'appPricePoint' | 'endDate' | 'manual' | 'startDate' | 'territory'>, fieldsAppPriceSchedules?: Array<'app' | 'automaticPrices' | 'baseTerritory' | 'manualPrices'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsTerritories?: Array<'currency'>, limitManualPrices?: number, limitAutomaticPrices?: number, include?: Array<'app' | 'automaticPrices' | 'baseTerritory' | 'manualPrices'>, _options?: Configuration): Promise<AppPriceScheduleResponse> {
        const result = this.api.appsAppPriceScheduleGetToOneRelated(id, fieldsAppPrices, fieldsAppPriceSchedules, fieldsApps, fieldsTerritories, limitManualPrices, limitAutomaticPrices, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterState filter by attribute \&#39;state\&#39;
     * @param fieldsAppStoreVersionExperiments the fields to include for returned resources of type appStoreVersionExperiments
     * @param fieldsAppStoreVersionExperimentTreatments the fields to include for returned resources of type appStoreVersionExperimentTreatments
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param limit maximum resources per page
     * @param limitControlVersions maximum number of related controlVersions returned (when they are included)
     * @param limitAppStoreVersionExperimentTreatments maximum number of related appStoreVersionExperimentTreatments returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appsAppStoreVersionExperimentsV2GetToManyRelatedWithHttpInfo(id: string, filterState?: Array<'PREPARE_FOR_SUBMISSION' | 'READY_FOR_REVIEW' | 'WAITING_FOR_REVIEW' | 'IN_REVIEW' | 'ACCEPTED' | 'APPROVED' | 'REJECTED' | 'COMPLETED' | 'STOPPED'>, fieldsAppStoreVersionExperiments?: Array<'app' | 'appStoreVersionExperimentTreatments' | 'controlVersions' | 'endDate' | 'latestControlVersion' | 'name' | 'platform' | 'reviewRequired' | 'startDate' | 'started' | 'state' | 'trafficProportion'>, fieldsAppStoreVersionExperimentTreatments?: Array<'appIcon' | 'appIconName' | 'appStoreVersionExperiment' | 'appStoreVersionExperimentTreatmentLocalizations' | 'appStoreVersionExperimentV2' | 'name' | 'promotedDate'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, limit?: number, limitControlVersions?: number, limitAppStoreVersionExperimentTreatments?: number, include?: Array<'app' | 'appStoreVersionExperimentTreatments' | 'controlVersions' | 'latestControlVersion'>, _options?: Configuration): Promise<HttpInfo<AppStoreVersionExperimentsV2Response>> {
        const result = this.api.appsAppStoreVersionExperimentsV2GetToManyRelatedWithHttpInfo(id, filterState, fieldsAppStoreVersionExperiments, fieldsAppStoreVersionExperimentTreatments, fieldsAppStoreVersions, fieldsApps, limit, limitControlVersions, limitAppStoreVersionExperimentTreatments, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterState filter by attribute \&#39;state\&#39;
     * @param fieldsAppStoreVersionExperiments the fields to include for returned resources of type appStoreVersionExperiments
     * @param fieldsAppStoreVersionExperimentTreatments the fields to include for returned resources of type appStoreVersionExperimentTreatments
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param limit maximum resources per page
     * @param limitControlVersions maximum number of related controlVersions returned (when they are included)
     * @param limitAppStoreVersionExperimentTreatments maximum number of related appStoreVersionExperimentTreatments returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appsAppStoreVersionExperimentsV2GetToManyRelated(id: string, filterState?: Array<'PREPARE_FOR_SUBMISSION' | 'READY_FOR_REVIEW' | 'WAITING_FOR_REVIEW' | 'IN_REVIEW' | 'ACCEPTED' | 'APPROVED' | 'REJECTED' | 'COMPLETED' | 'STOPPED'>, fieldsAppStoreVersionExperiments?: Array<'app' | 'appStoreVersionExperimentTreatments' | 'controlVersions' | 'endDate' | 'latestControlVersion' | 'name' | 'platform' | 'reviewRequired' | 'startDate' | 'started' | 'state' | 'trafficProportion'>, fieldsAppStoreVersionExperimentTreatments?: Array<'appIcon' | 'appIconName' | 'appStoreVersionExperiment' | 'appStoreVersionExperimentTreatmentLocalizations' | 'appStoreVersionExperimentV2' | 'name' | 'promotedDate'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, limit?: number, limitControlVersions?: number, limitAppStoreVersionExperimentTreatments?: number, include?: Array<'app' | 'appStoreVersionExperimentTreatments' | 'controlVersions' | 'latestControlVersion'>, _options?: Configuration): Promise<AppStoreVersionExperimentsV2Response> {
        const result = this.api.appsAppStoreVersionExperimentsV2GetToManyRelated(id, filterState, fieldsAppStoreVersionExperiments, fieldsAppStoreVersionExperimentTreatments, fieldsAppStoreVersions, fieldsApps, limit, limitControlVersions, limitAppStoreVersionExperimentTreatments, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterAppStoreState filter by attribute \&#39;appStoreState\&#39;
     * @param filterAppVersionState filter by attribute \&#39;appVersionState\&#39;
     * @param filterPlatform filter by attribute \&#39;platform\&#39;
     * @param filterVersionString filter by attribute \&#39;versionString\&#39;
     * @param filterId filter by id(s)
     * @param fieldsAgeRatingDeclarations the fields to include for returned resources of type ageRatingDeclarations
     * @param fieldsAppStoreReviewDetails the fields to include for returned resources of type appStoreReviewDetails
     * @param fieldsAppStoreVersionLocalizations the fields to include for returned resources of type appStoreVersionLocalizations
     * @param fieldsAppStoreVersionExperiments the fields to include for returned resources of type appStoreVersionExperiments
     * @param fieldsAppStoreVersionSubmissions the fields to include for returned resources of type appStoreVersionSubmissions
     * @param fieldsAlternativeDistributionPackages the fields to include for returned resources of type alternativeDistributionPackages
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsRoutingAppCoverages the fields to include for returned resources of type routingAppCoverages
     * @param fieldsAppClipDefaultExperiences the fields to include for returned resources of type appClipDefaultExperiences
     * @param fieldsAppStoreVersionPhasedReleases the fields to include for returned resources of type appStoreVersionPhasedReleases
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param limit maximum resources per page
     * @param limitAppStoreVersionLocalizations maximum number of related appStoreVersionLocalizations returned (when they are included)
     * @param limitAppStoreVersionExperiments maximum number of related appStoreVersionExperiments returned (when they are included)
     * @param limitAppStoreVersionExperimentsV2 maximum number of related appStoreVersionExperimentsV2 returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appsAppStoreVersionsGetToManyRelatedWithHttpInfo(id: string, filterAppStoreState?: Array<'ACCEPTED' | 'DEVELOPER_REMOVED_FROM_SALE' | 'DEVELOPER_REJECTED' | 'IN_REVIEW' | 'INVALID_BINARY' | 'METADATA_REJECTED' | 'PENDING_APPLE_RELEASE' | 'PENDING_CONTRACT' | 'PENDING_DEVELOPER_RELEASE' | 'PREPARE_FOR_SUBMISSION' | 'PREORDER_READY_FOR_SALE' | 'PROCESSING_FOR_APP_STORE' | 'READY_FOR_REVIEW' | 'READY_FOR_SALE' | 'REJECTED' | 'REMOVED_FROM_SALE' | 'WAITING_FOR_EXPORT_COMPLIANCE' | 'WAITING_FOR_REVIEW' | 'REPLACED_WITH_NEW_VERSION' | 'NOT_APPLICABLE'>, filterAppVersionState?: Array<'ACCEPTED' | 'DEVELOPER_REJECTED' | 'IN_REVIEW' | 'INVALID_BINARY' | 'METADATA_REJECTED' | 'PENDING_APPLE_RELEASE' | 'PENDING_DEVELOPER_RELEASE' | 'PREPARE_FOR_SUBMISSION' | 'PROCESSING_FOR_DISTRIBUTION' | 'READY_FOR_DISTRIBUTION' | 'READY_FOR_REVIEW' | 'REJECTED' | 'REPLACED_WITH_NEW_VERSION' | 'WAITING_FOR_EXPORT_COMPLIANCE' | 'WAITING_FOR_REVIEW'>, filterPlatform?: Array<'IOS' | 'MAC_OS' | 'TV_OS' | 'VISION_OS'>, filterVersionString?: Array<string>, filterId?: Array<string>, fieldsAgeRatingDeclarations?: Array<'ageRatingOverride' | 'alcoholTobaccoOrDrugUseOrReferences' | 'contests' | 'gambling' | 'gamblingAndContests' | 'gamblingSimulated' | 'horrorOrFearThemes' | 'kidsAgeBand' | 'matureOrSuggestiveThemes' | 'medicalOrTreatmentInformation' | 'profanityOrCrudeHumor' | 'seventeenPlus' | 'sexualContentGraphicAndNudity' | 'sexualContentOrNudity' | 'unrestrictedWebAccess' | 'violenceCartoonOrFantasy' | 'violenceRealistic' | 'violenceRealisticProlongedGraphicOrSadistic'>, fieldsAppStoreReviewDetails?: Array<'appStoreReviewAttachments' | 'appStoreVersion' | 'contactEmail' | 'contactFirstName' | 'contactLastName' | 'contactPhone' | 'demoAccountName' | 'demoAccountPassword' | 'demoAccountRequired' | 'notes'>, fieldsAppStoreVersionLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersion' | 'description' | 'keywords' | 'locale' | 'marketingUrl' | 'promotionalText' | 'supportUrl' | 'whatsNew'>, fieldsAppStoreVersionExperiments?: Array<'app' | 'appStoreVersion' | 'appStoreVersionExperimentTreatments' | 'controlVersions' | 'endDate' | 'latestControlVersion' | 'name' | 'platform' | 'reviewRequired' | 'startDate' | 'started' | 'state' | 'trafficProportion'>, fieldsAppStoreVersionSubmissions?: Array<'appStoreVersion'>, fieldsAlternativeDistributionPackages?: Array<'appStoreVersion' | 'versions'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsRoutingAppCoverages?: Array<'appStoreVersion' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, fieldsAppClipDefaultExperiences?: Array<'action' | 'appClip' | 'appClipAppStoreReviewDetail' | 'appClipDefaultExperienceLocalizations' | 'appClipDefaultExperienceTemplate' | 'releaseWithAppStoreVersion'>, fieldsAppStoreVersionPhasedReleases?: Array<'appStoreVersion' | 'currentDayNumber' | 'phasedReleaseState' | 'startDate' | 'totalPauseDuration'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, limit?: number, limitAppStoreVersionLocalizations?: number, limitAppStoreVersionExperiments?: number, limitAppStoreVersionExperimentsV2?: number, include?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'build' | 'routingAppCoverage'>, _options?: Configuration): Promise<HttpInfo<AppStoreVersionsResponse>> {
        const result = this.api.appsAppStoreVersionsGetToManyRelatedWithHttpInfo(id, filterAppStoreState, filterAppVersionState, filterPlatform, filterVersionString, filterId, fieldsAgeRatingDeclarations, fieldsAppStoreReviewDetails, fieldsAppStoreVersionLocalizations, fieldsAppStoreVersionExperiments, fieldsAppStoreVersionSubmissions, fieldsAlternativeDistributionPackages, fieldsAppStoreVersions, fieldsApps, fieldsRoutingAppCoverages, fieldsAppClipDefaultExperiences, fieldsAppStoreVersionPhasedReleases, fieldsBuilds, limit, limitAppStoreVersionLocalizations, limitAppStoreVersionExperiments, limitAppStoreVersionExperimentsV2, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterAppStoreState filter by attribute \&#39;appStoreState\&#39;
     * @param filterAppVersionState filter by attribute \&#39;appVersionState\&#39;
     * @param filterPlatform filter by attribute \&#39;platform\&#39;
     * @param filterVersionString filter by attribute \&#39;versionString\&#39;
     * @param filterId filter by id(s)
     * @param fieldsAgeRatingDeclarations the fields to include for returned resources of type ageRatingDeclarations
     * @param fieldsAppStoreReviewDetails the fields to include for returned resources of type appStoreReviewDetails
     * @param fieldsAppStoreVersionLocalizations the fields to include for returned resources of type appStoreVersionLocalizations
     * @param fieldsAppStoreVersionExperiments the fields to include for returned resources of type appStoreVersionExperiments
     * @param fieldsAppStoreVersionSubmissions the fields to include for returned resources of type appStoreVersionSubmissions
     * @param fieldsAlternativeDistributionPackages the fields to include for returned resources of type alternativeDistributionPackages
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsRoutingAppCoverages the fields to include for returned resources of type routingAppCoverages
     * @param fieldsAppClipDefaultExperiences the fields to include for returned resources of type appClipDefaultExperiences
     * @param fieldsAppStoreVersionPhasedReleases the fields to include for returned resources of type appStoreVersionPhasedReleases
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param limit maximum resources per page
     * @param limitAppStoreVersionLocalizations maximum number of related appStoreVersionLocalizations returned (when they are included)
     * @param limitAppStoreVersionExperiments maximum number of related appStoreVersionExperiments returned (when they are included)
     * @param limitAppStoreVersionExperimentsV2 maximum number of related appStoreVersionExperimentsV2 returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appsAppStoreVersionsGetToManyRelated(id: string, filterAppStoreState?: Array<'ACCEPTED' | 'DEVELOPER_REMOVED_FROM_SALE' | 'DEVELOPER_REJECTED' | 'IN_REVIEW' | 'INVALID_BINARY' | 'METADATA_REJECTED' | 'PENDING_APPLE_RELEASE' | 'PENDING_CONTRACT' | 'PENDING_DEVELOPER_RELEASE' | 'PREPARE_FOR_SUBMISSION' | 'PREORDER_READY_FOR_SALE' | 'PROCESSING_FOR_APP_STORE' | 'READY_FOR_REVIEW' | 'READY_FOR_SALE' | 'REJECTED' | 'REMOVED_FROM_SALE' | 'WAITING_FOR_EXPORT_COMPLIANCE' | 'WAITING_FOR_REVIEW' | 'REPLACED_WITH_NEW_VERSION' | 'NOT_APPLICABLE'>, filterAppVersionState?: Array<'ACCEPTED' | 'DEVELOPER_REJECTED' | 'IN_REVIEW' | 'INVALID_BINARY' | 'METADATA_REJECTED' | 'PENDING_APPLE_RELEASE' | 'PENDING_DEVELOPER_RELEASE' | 'PREPARE_FOR_SUBMISSION' | 'PROCESSING_FOR_DISTRIBUTION' | 'READY_FOR_DISTRIBUTION' | 'READY_FOR_REVIEW' | 'REJECTED' | 'REPLACED_WITH_NEW_VERSION' | 'WAITING_FOR_EXPORT_COMPLIANCE' | 'WAITING_FOR_REVIEW'>, filterPlatform?: Array<'IOS' | 'MAC_OS' | 'TV_OS' | 'VISION_OS'>, filterVersionString?: Array<string>, filterId?: Array<string>, fieldsAgeRatingDeclarations?: Array<'ageRatingOverride' | 'alcoholTobaccoOrDrugUseOrReferences' | 'contests' | 'gambling' | 'gamblingAndContests' | 'gamblingSimulated' | 'horrorOrFearThemes' | 'kidsAgeBand' | 'matureOrSuggestiveThemes' | 'medicalOrTreatmentInformation' | 'profanityOrCrudeHumor' | 'seventeenPlus' | 'sexualContentGraphicAndNudity' | 'sexualContentOrNudity' | 'unrestrictedWebAccess' | 'violenceCartoonOrFantasy' | 'violenceRealistic' | 'violenceRealisticProlongedGraphicOrSadistic'>, fieldsAppStoreReviewDetails?: Array<'appStoreReviewAttachments' | 'appStoreVersion' | 'contactEmail' | 'contactFirstName' | 'contactLastName' | 'contactPhone' | 'demoAccountName' | 'demoAccountPassword' | 'demoAccountRequired' | 'notes'>, fieldsAppStoreVersionLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersion' | 'description' | 'keywords' | 'locale' | 'marketingUrl' | 'promotionalText' | 'supportUrl' | 'whatsNew'>, fieldsAppStoreVersionExperiments?: Array<'app' | 'appStoreVersion' | 'appStoreVersionExperimentTreatments' | 'controlVersions' | 'endDate' | 'latestControlVersion' | 'name' | 'platform' | 'reviewRequired' | 'startDate' | 'started' | 'state' | 'trafficProportion'>, fieldsAppStoreVersionSubmissions?: Array<'appStoreVersion'>, fieldsAlternativeDistributionPackages?: Array<'appStoreVersion' | 'versions'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsRoutingAppCoverages?: Array<'appStoreVersion' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, fieldsAppClipDefaultExperiences?: Array<'action' | 'appClip' | 'appClipAppStoreReviewDetail' | 'appClipDefaultExperienceLocalizations' | 'appClipDefaultExperienceTemplate' | 'releaseWithAppStoreVersion'>, fieldsAppStoreVersionPhasedReleases?: Array<'appStoreVersion' | 'currentDayNumber' | 'phasedReleaseState' | 'startDate' | 'totalPauseDuration'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, limit?: number, limitAppStoreVersionLocalizations?: number, limitAppStoreVersionExperiments?: number, limitAppStoreVersionExperimentsV2?: number, include?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'build' | 'routingAppCoverage'>, _options?: Configuration): Promise<AppStoreVersionsResponse> {
        const result = this.api.appsAppStoreVersionsGetToManyRelated(id, filterAppStoreState, filterAppVersionState, filterPlatform, filterVersionString, filterId, fieldsAgeRatingDeclarations, fieldsAppStoreReviewDetails, fieldsAppStoreVersionLocalizations, fieldsAppStoreVersionExperiments, fieldsAppStoreVersionSubmissions, fieldsAlternativeDistributionPackages, fieldsAppStoreVersions, fieldsApps, fieldsRoutingAppCoverages, fieldsAppClipDefaultExperiences, fieldsAppStoreVersionPhasedReleases, fieldsBuilds, limit, limitAppStoreVersionLocalizations, limitAppStoreVersionExperiments, limitAppStoreVersionExperimentsV2, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limit maximum resources per page
     */
    public appsAvailableTerritoriesGetToManyRelatedWithHttpInfo(id: string, fieldsTerritories?: Array<'currency'>, limit?: number, _options?: Configuration): Promise<HttpInfo<TerritoriesResponse>> {
        const result = this.api.appsAvailableTerritoriesGetToManyRelatedWithHttpInfo(id, fieldsTerritories, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limit maximum resources per page
     */
    public appsAvailableTerritoriesGetToManyRelated(id: string, fieldsTerritories?: Array<'currency'>, limit?: number, _options?: Configuration): Promise<TerritoriesResponse> {
        const result = this.api.appsAvailableTerritoriesGetToManyRelated(id, fieldsTerritories, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBetaAppLocalizations the fields to include for returned resources of type betaAppLocalizations
     * @param limit maximum resources per page
     */
    public appsBetaAppLocalizationsGetToManyRelatedWithHttpInfo(id: string, fieldsBetaAppLocalizations?: Array<'app' | 'description' | 'feedbackEmail' | 'locale' | 'marketingUrl' | 'privacyPolicyUrl' | 'tvOsPrivacyPolicy'>, limit?: number, _options?: Configuration): Promise<HttpInfo<BetaAppLocalizationsWithoutIncludesResponse>> {
        const result = this.api.appsBetaAppLocalizationsGetToManyRelatedWithHttpInfo(id, fieldsBetaAppLocalizations, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBetaAppLocalizations the fields to include for returned resources of type betaAppLocalizations
     * @param limit maximum resources per page
     */
    public appsBetaAppLocalizationsGetToManyRelated(id: string, fieldsBetaAppLocalizations?: Array<'app' | 'description' | 'feedbackEmail' | 'locale' | 'marketingUrl' | 'privacyPolicyUrl' | 'tvOsPrivacyPolicy'>, limit?: number, _options?: Configuration): Promise<BetaAppLocalizationsWithoutIncludesResponse> {
        const result = this.api.appsBetaAppLocalizationsGetToManyRelated(id, fieldsBetaAppLocalizations, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBetaAppReviewDetails the fields to include for returned resources of type betaAppReviewDetails
     */
    public appsBetaAppReviewDetailGetToOneRelatedWithHttpInfo(id: string, fieldsBetaAppReviewDetails?: Array<'app' | 'contactEmail' | 'contactFirstName' | 'contactLastName' | 'contactPhone' | 'demoAccountName' | 'demoAccountPassword' | 'demoAccountRequired' | 'notes'>, _options?: Configuration): Promise<HttpInfo<BetaAppReviewDetailWithoutIncludesResponse>> {
        const result = this.api.appsBetaAppReviewDetailGetToOneRelatedWithHttpInfo(id, fieldsBetaAppReviewDetails, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBetaAppReviewDetails the fields to include for returned resources of type betaAppReviewDetails
     */
    public appsBetaAppReviewDetailGetToOneRelated(id: string, fieldsBetaAppReviewDetails?: Array<'app' | 'contactEmail' | 'contactFirstName' | 'contactLastName' | 'contactPhone' | 'demoAccountName' | 'demoAccountPassword' | 'demoAccountRequired' | 'notes'>, _options?: Configuration): Promise<BetaAppReviewDetailWithoutIncludesResponse> {
        const result = this.api.appsBetaAppReviewDetailGetToOneRelated(id, fieldsBetaAppReviewDetails, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBetaGroups the fields to include for returned resources of type betaGroups
     * @param limit maximum resources per page
     */
    public appsBetaGroupsGetToManyRelatedWithHttpInfo(id: string, fieldsBetaGroups?: Array<'app' | 'betaTesters' | 'builds' | 'createdDate' | 'feedbackEnabled' | 'hasAccessToAllBuilds' | 'iosBuildsAvailableForAppleSiliconMac' | 'isInternalGroup' | 'name' | 'publicLink' | 'publicLinkEnabled' | 'publicLinkId' | 'publicLinkLimit' | 'publicLinkLimitEnabled'>, limit?: number, _options?: Configuration): Promise<HttpInfo<BetaGroupsWithoutIncludesResponse>> {
        const result = this.api.appsBetaGroupsGetToManyRelatedWithHttpInfo(id, fieldsBetaGroups, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBetaGroups the fields to include for returned resources of type betaGroups
     * @param limit maximum resources per page
     */
    public appsBetaGroupsGetToManyRelated(id: string, fieldsBetaGroups?: Array<'app' | 'betaTesters' | 'builds' | 'createdDate' | 'feedbackEnabled' | 'hasAccessToAllBuilds' | 'iosBuildsAvailableForAppleSiliconMac' | 'isInternalGroup' | 'name' | 'publicLink' | 'publicLinkEnabled' | 'publicLinkId' | 'publicLinkLimit' | 'publicLinkLimitEnabled'>, limit?: number, _options?: Configuration): Promise<BetaGroupsWithoutIncludesResponse> {
        const result = this.api.appsBetaGroupsGetToManyRelated(id, fieldsBetaGroups, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBetaLicenseAgreements the fields to include for returned resources of type betaLicenseAgreements
     */
    public appsBetaLicenseAgreementGetToOneRelatedWithHttpInfo(id: string, fieldsBetaLicenseAgreements?: Array<'agreementText' | 'app'>, _options?: Configuration): Promise<HttpInfo<BetaLicenseAgreementWithoutIncludesResponse>> {
        const result = this.api.appsBetaLicenseAgreementGetToOneRelatedWithHttpInfo(id, fieldsBetaLicenseAgreements, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBetaLicenseAgreements the fields to include for returned resources of type betaLicenseAgreements
     */
    public appsBetaLicenseAgreementGetToOneRelated(id: string, fieldsBetaLicenseAgreements?: Array<'agreementText' | 'app'>, _options?: Configuration): Promise<BetaLicenseAgreementWithoutIncludesResponse> {
        const result = this.api.appsBetaLicenseAgreementGetToOneRelated(id, fieldsBetaLicenseAgreements, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum number of groups to return per page
     * @param groupBy the dimension by which to group the results
     * @param filterBetaTesters filter by \&#39;betaTesters\&#39; relationship dimension
     * @param period the duration of the reporting period
     */
    public appsBetaTesterUsagesGetMetricsWithHttpInfo(id: string, limit?: number, groupBy?: Array<'betaTesters'>, filterBetaTesters?: string, period?: 'P7D' | 'P30D' | 'P90D' | 'P365D', _options?: Configuration): Promise<HttpInfo<AppsBetaTesterUsagesV1MetricResponse>> {
        const result = this.api.appsBetaTesterUsagesGetMetricsWithHttpInfo(id, limit, groupBy, filterBetaTesters, period, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum number of groups to return per page
     * @param groupBy the dimension by which to group the results
     * @param filterBetaTesters filter by \&#39;betaTesters\&#39; relationship dimension
     * @param period the duration of the reporting period
     */
    public appsBetaTesterUsagesGetMetrics(id: string, limit?: number, groupBy?: Array<'betaTesters'>, filterBetaTesters?: string, period?: 'P7D' | 'P30D' | 'P90D' | 'P365D', _options?: Configuration): Promise<AppsBetaTesterUsagesV1MetricResponse> {
        const result = this.api.appsBetaTesterUsagesGetMetrics(id, limit, groupBy, filterBetaTesters, period, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param appBetaTestersLinkagesRequest List of related linkages
     */
    public appsBetaTestersDeleteToManyRelationshipWithHttpInfo(id: string, appBetaTestersLinkagesRequest: AppBetaTestersLinkagesRequest, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.appsBetaTestersDeleteToManyRelationshipWithHttpInfo(id, appBetaTestersLinkagesRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param appBetaTestersLinkagesRequest List of related linkages
     */
    public appsBetaTestersDeleteToManyRelationship(id: string, appBetaTestersLinkagesRequest: AppBetaTestersLinkagesRequest, _options?: Configuration): Promise<void> {
        const result = this.api.appsBetaTestersDeleteToManyRelationship(id, appBetaTestersLinkagesRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param limit maximum resources per page
     */
    public appsBuildsGetToManyRelatedWithHttpInfo(id: string, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, limit?: number, _options?: Configuration): Promise<HttpInfo<BuildsWithoutIncludesResponse>> {
        const result = this.api.appsBuildsGetToManyRelatedWithHttpInfo(id, fieldsBuilds, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param limit maximum resources per page
     */
    public appsBuildsGetToManyRelated(id: string, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, limit?: number, _options?: Configuration): Promise<BuildsWithoutIncludesResponse> {
        const result = this.api.appsBuildsGetToManyRelated(id, fieldsBuilds, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCiProducts the fields to include for returned resources of type ciProducts
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsScmRepositories the fields to include for returned resources of type scmRepositories
     * @param fieldsBundleIds the fields to include for returned resources of type bundleIds
     * @param limitPrimaryRepositories maximum number of related primaryRepositories returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appsCiProductGetToOneRelatedWithHttpInfo(id: string, fieldsCiProducts?: Array<'additionalRepositories' | 'app' | 'buildRuns' | 'bundleId' | 'createdDate' | 'name' | 'primaryRepositories' | 'productType' | 'workflows'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsScmRepositories?: Array<'defaultBranch' | 'gitReferences' | 'httpCloneUrl' | 'lastAccessedDate' | 'ownerName' | 'pullRequests' | 'repositoryName' | 'scmProvider' | 'sshCloneUrl'>, fieldsBundleIds?: Array<'app' | 'bundleIdCapabilities' | 'identifier' | 'name' | 'platform' | 'profiles' | 'seedId'>, limitPrimaryRepositories?: number, include?: Array<'app' | 'bundleId' | 'primaryRepositories'>, _options?: Configuration): Promise<HttpInfo<CiProductResponse>> {
        const result = this.api.appsCiProductGetToOneRelatedWithHttpInfo(id, fieldsCiProducts, fieldsApps, fieldsScmRepositories, fieldsBundleIds, limitPrimaryRepositories, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCiProducts the fields to include for returned resources of type ciProducts
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsScmRepositories the fields to include for returned resources of type scmRepositories
     * @param fieldsBundleIds the fields to include for returned resources of type bundleIds
     * @param limitPrimaryRepositories maximum number of related primaryRepositories returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appsCiProductGetToOneRelated(id: string, fieldsCiProducts?: Array<'additionalRepositories' | 'app' | 'buildRuns' | 'bundleId' | 'createdDate' | 'name' | 'primaryRepositories' | 'productType' | 'workflows'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsScmRepositories?: Array<'defaultBranch' | 'gitReferences' | 'httpCloneUrl' | 'lastAccessedDate' | 'ownerName' | 'pullRequests' | 'repositoryName' | 'scmProvider' | 'sshCloneUrl'>, fieldsBundleIds?: Array<'app' | 'bundleIdCapabilities' | 'identifier' | 'name' | 'platform' | 'profiles' | 'seedId'>, limitPrimaryRepositories?: number, include?: Array<'app' | 'bundleId' | 'primaryRepositories'>, _options?: Configuration): Promise<CiProductResponse> {
        const result = this.api.appsCiProductGetToOneRelated(id, fieldsCiProducts, fieldsApps, fieldsScmRepositories, fieldsBundleIds, limitPrimaryRepositories, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterRating filter by attribute \&#39;rating\&#39;
     * @param filterTerritory filter by attribute \&#39;territory\&#39;
     * @param existsPublishedResponse filter by publishedResponse
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsCustomerReviews the fields to include for returned resources of type customerReviews
     * @param fieldsCustomerReviewResponses the fields to include for returned resources of type customerReviewResponses
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public appsCustomerReviewsGetToManyRelatedWithHttpInfo(id: string, filterRating?: Array<string>, filterTerritory?: Array<'ABW' | 'AFG' | 'AGO' | 'AIA' | 'ALB' | 'AND' | 'ANT' | 'ARE' | 'ARG' | 'ARM' | 'ASM' | 'ATG' | 'AUS' | 'AUT' | 'AZE' | 'BDI' | 'BEL' | 'BEN' | 'BES' | 'BFA' | 'BGD' | 'BGR' | 'BHR' | 'BHS' | 'BIH' | 'BLR' | 'BLZ' | 'BMU' | 'BOL' | 'BRA' | 'BRB' | 'BRN' | 'BTN' | 'BWA' | 'CAF' | 'CAN' | 'CHE' | 'CHL' | 'CHN' | 'CIV' | 'CMR' | 'COD' | 'COG' | 'COK' | 'COL' | 'COM' | 'CPV' | 'CRI' | 'CUB' | 'CUW' | 'CXR' | 'CYM' | 'CYP' | 'CZE' | 'DEU' | 'DJI' | 'DMA' | 'DNK' | 'DOM' | 'DZA' | 'ECU' | 'EGY' | 'ERI' | 'ESP' | 'EST' | 'ETH' | 'FIN' | 'FJI' | 'FLK' | 'FRA' | 'FRO' | 'FSM' | 'GAB' | 'GBR' | 'GEO' | 'GGY' | 'GHA' | 'GIB' | 'GIN' | 'GLP' | 'GMB' | 'GNB' | 'GNQ' | 'GRC' | 'GRD' | 'GRL' | 'GTM' | 'GUF' | 'GUM' | 'GUY' | 'HKG' | 'HND' | 'HRV' | 'HTI' | 'HUN' | 'IDN' | 'IMN' | 'IND' | 'IRL' | 'IRQ' | 'ISL' | 'ISR' | 'ITA' | 'JAM' | 'JEY' | 'JOR' | 'JPN' | 'KAZ' | 'KEN' | 'KGZ' | 'KHM' | 'KIR' | 'KNA' | 'KOR' | 'KWT' | 'LAO' | 'LBN' | 'LBR' | 'LBY' | 'LCA' | 'LIE' | 'LKA' | 'LSO' | 'LTU' | 'LUX' | 'LVA' | 'MAC' | 'MAR' | 'MCO' | 'MDA' | 'MDG' | 'MDV' | 'MEX' | 'MHL' | 'MKD' | 'MLI' | 'MLT' | 'MMR' | 'MNE' | 'MNG' | 'MNP' | 'MOZ' | 'MRT' | 'MSR' | 'MTQ' | 'MUS' | 'MWI' | 'MYS' | 'MYT' | 'NAM' | 'NCL' | 'NER' | 'NFK' | 'NGA' | 'NIC' | 'NIU' | 'NLD' | 'NOR' | 'NPL' | 'NRU' | 'NZL' | 'OMN' | 'PAK' | 'PAN' | 'PER' | 'PHL' | 'PLW' | 'PNG' | 'POL' | 'PRI' | 'PRT' | 'PRY' | 'PSE' | 'PYF' | 'QAT' | 'REU' | 'ROU' | 'RUS' | 'RWA' | 'SAU' | 'SEN' | 'SGP' | 'SHN' | 'SLB' | 'SLE' | 'SLV' | 'SMR' | 'SOM' | 'SPM' | 'SRB' | 'SSD' | 'STP' | 'SUR' | 'SVK' | 'SVN' | 'SWE' | 'SWZ' | 'SXM' | 'SYC' | 'TCA' | 'TCD' | 'TGO' | 'THA' | 'TJK' | 'TKM' | 'TLS' | 'TON' | 'TTO' | 'TUN' | 'TUR' | 'TUV' | 'TWN' | 'TZA' | 'UGA' | 'UKR' | 'UMI' | 'URY' | 'USA' | 'UZB' | 'VAT' | 'VCT' | 'VEN' | 'VGB' | 'VIR' | 'VNM' | 'VUT' | 'WLF' | 'WSM' | 'YEM' | 'ZAF' | 'ZMB' | 'ZWE'>, existsPublishedResponse?: boolean, sort?: Array<'createdDate' | '-createdDate' | 'rating' | '-rating'>, fieldsCustomerReviews?: Array<'body' | 'createdDate' | 'rating' | 'response' | 'reviewerNickname' | 'territory' | 'title'>, fieldsCustomerReviewResponses?: Array<'lastModifiedDate' | 'responseBody' | 'review' | 'state'>, limit?: number, include?: Array<'response'>, _options?: Configuration): Promise<HttpInfo<CustomerReviewsResponse>> {
        const result = this.api.appsCustomerReviewsGetToManyRelatedWithHttpInfo(id, filterRating, filterTerritory, existsPublishedResponse, sort, fieldsCustomerReviews, fieldsCustomerReviewResponses, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterRating filter by attribute \&#39;rating\&#39;
     * @param filterTerritory filter by attribute \&#39;territory\&#39;
     * @param existsPublishedResponse filter by publishedResponse
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsCustomerReviews the fields to include for returned resources of type customerReviews
     * @param fieldsCustomerReviewResponses the fields to include for returned resources of type customerReviewResponses
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public appsCustomerReviewsGetToManyRelated(id: string, filterRating?: Array<string>, filterTerritory?: Array<'ABW' | 'AFG' | 'AGO' | 'AIA' | 'ALB' | 'AND' | 'ANT' | 'ARE' | 'ARG' | 'ARM' | 'ASM' | 'ATG' | 'AUS' | 'AUT' | 'AZE' | 'BDI' | 'BEL' | 'BEN' | 'BES' | 'BFA' | 'BGD' | 'BGR' | 'BHR' | 'BHS' | 'BIH' | 'BLR' | 'BLZ' | 'BMU' | 'BOL' | 'BRA' | 'BRB' | 'BRN' | 'BTN' | 'BWA' | 'CAF' | 'CAN' | 'CHE' | 'CHL' | 'CHN' | 'CIV' | 'CMR' | 'COD' | 'COG' | 'COK' | 'COL' | 'COM' | 'CPV' | 'CRI' | 'CUB' | 'CUW' | 'CXR' | 'CYM' | 'CYP' | 'CZE' | 'DEU' | 'DJI' | 'DMA' | 'DNK' | 'DOM' | 'DZA' | 'ECU' | 'EGY' | 'ERI' | 'ESP' | 'EST' | 'ETH' | 'FIN' | 'FJI' | 'FLK' | 'FRA' | 'FRO' | 'FSM' | 'GAB' | 'GBR' | 'GEO' | 'GGY' | 'GHA' | 'GIB' | 'GIN' | 'GLP' | 'GMB' | 'GNB' | 'GNQ' | 'GRC' | 'GRD' | 'GRL' | 'GTM' | 'GUF' | 'GUM' | 'GUY' | 'HKG' | 'HND' | 'HRV' | 'HTI' | 'HUN' | 'IDN' | 'IMN' | 'IND' | 'IRL' | 'IRQ' | 'ISL' | 'ISR' | 'ITA' | 'JAM' | 'JEY' | 'JOR' | 'JPN' | 'KAZ' | 'KEN' | 'KGZ' | 'KHM' | 'KIR' | 'KNA' | 'KOR' | 'KWT' | 'LAO' | 'LBN' | 'LBR' | 'LBY' | 'LCA' | 'LIE' | 'LKA' | 'LSO' | 'LTU' | 'LUX' | 'LVA' | 'MAC' | 'MAR' | 'MCO' | 'MDA' | 'MDG' | 'MDV' | 'MEX' | 'MHL' | 'MKD' | 'MLI' | 'MLT' | 'MMR' | 'MNE' | 'MNG' | 'MNP' | 'MOZ' | 'MRT' | 'MSR' | 'MTQ' | 'MUS' | 'MWI' | 'MYS' | 'MYT' | 'NAM' | 'NCL' | 'NER' | 'NFK' | 'NGA' | 'NIC' | 'NIU' | 'NLD' | 'NOR' | 'NPL' | 'NRU' | 'NZL' | 'OMN' | 'PAK' | 'PAN' | 'PER' | 'PHL' | 'PLW' | 'PNG' | 'POL' | 'PRI' | 'PRT' | 'PRY' | 'PSE' | 'PYF' | 'QAT' | 'REU' | 'ROU' | 'RUS' | 'RWA' | 'SAU' | 'SEN' | 'SGP' | 'SHN' | 'SLB' | 'SLE' | 'SLV' | 'SMR' | 'SOM' | 'SPM' | 'SRB' | 'SSD' | 'STP' | 'SUR' | 'SVK' | 'SVN' | 'SWE' | 'SWZ' | 'SXM' | 'SYC' | 'TCA' | 'TCD' | 'TGO' | 'THA' | 'TJK' | 'TKM' | 'TLS' | 'TON' | 'TTO' | 'TUN' | 'TUR' | 'TUV' | 'TWN' | 'TZA' | 'UGA' | 'UKR' | 'UMI' | 'URY' | 'USA' | 'UZB' | 'VAT' | 'VCT' | 'VEN' | 'VGB' | 'VIR' | 'VNM' | 'VUT' | 'WLF' | 'WSM' | 'YEM' | 'ZAF' | 'ZMB' | 'ZWE'>, existsPublishedResponse?: boolean, sort?: Array<'createdDate' | '-createdDate' | 'rating' | '-rating'>, fieldsCustomerReviews?: Array<'body' | 'createdDate' | 'rating' | 'response' | 'reviewerNickname' | 'territory' | 'title'>, fieldsCustomerReviewResponses?: Array<'lastModifiedDate' | 'responseBody' | 'review' | 'state'>, limit?: number, include?: Array<'response'>, _options?: Configuration): Promise<CustomerReviewsResponse> {
        const result = this.api.appsCustomerReviewsGetToManyRelated(id, filterRating, filterTerritory, existsPublishedResponse, sort, fieldsCustomerReviews, fieldsCustomerReviewResponses, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsEndUserLicenseAgreements the fields to include for returned resources of type endUserLicenseAgreements
     */
    public appsEndUserLicenseAgreementGetToOneRelatedWithHttpInfo(id: string, fieldsEndUserLicenseAgreements?: Array<'agreementText' | 'app' | 'territories'>, _options?: Configuration): Promise<HttpInfo<EndUserLicenseAgreementWithoutIncludesResponse>> {
        const result = this.api.appsEndUserLicenseAgreementGetToOneRelatedWithHttpInfo(id, fieldsEndUserLicenseAgreements, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsEndUserLicenseAgreements the fields to include for returned resources of type endUserLicenseAgreements
     */
    public appsEndUserLicenseAgreementGetToOneRelated(id: string, fieldsEndUserLicenseAgreements?: Array<'agreementText' | 'app' | 'territories'>, _options?: Configuration): Promise<EndUserLicenseAgreementWithoutIncludesResponse> {
        const result = this.api.appsEndUserLicenseAgreementGetToOneRelated(id, fieldsEndUserLicenseAgreements, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterAchievementReleases the fields to include for returned resources of type gameCenterAchievementReleases
     * @param fieldsGameCenterLeaderboardSetReleases the fields to include for returned resources of type gameCenterLeaderboardSetReleases
     * @param fieldsGameCenterLeaderboardSets the fields to include for returned resources of type gameCenterLeaderboardSets
     * @param fieldsGameCenterGroups the fields to include for returned resources of type gameCenterGroups
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     * @param fieldsGameCenterAppVersions the fields to include for returned resources of type gameCenterAppVersions
     * @param fieldsGameCenterAchievements the fields to include for returned resources of type gameCenterAchievements
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsGameCenterLeaderboardReleases the fields to include for returned resources of type gameCenterLeaderboardReleases
     * @param limitGameCenterAppVersions maximum number of related gameCenterAppVersions returned (when they are included)
     * @param limitGameCenterLeaderboards maximum number of related gameCenterLeaderboards returned (when they are included)
     * @param limitGameCenterLeaderboardSets maximum number of related gameCenterLeaderboardSets returned (when they are included)
     * @param limitGameCenterAchievements maximum number of related gameCenterAchievements returned (when they are included)
     * @param limitAchievementReleases maximum number of related achievementReleases returned (when they are included)
     * @param limitLeaderboardReleases maximum number of related leaderboardReleases returned (when they are included)
     * @param limitLeaderboardSetReleases maximum number of related leaderboardSetReleases returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appsGameCenterDetailGetToOneRelatedWithHttpInfo(id: string, fieldsGameCenterAchievementReleases?: Array<'gameCenterAchievement' | 'gameCenterDetail' | 'live'>, fieldsGameCenterLeaderboardSetReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboardSet' | 'live'>, fieldsGameCenterLeaderboardSets?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'referenceName' | 'releases' | 'vendorIdentifier'>, fieldsGameCenterGroups?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'referenceName'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, fieldsGameCenterAppVersions?: Array<'appStoreVersion' | 'compatibilityVersions' | 'enabled'>, fieldsGameCenterAchievements?: Array<'archived' | 'gameCenterDetail' | 'gameCenterGroup' | 'groupAchievement' | 'localizations' | 'points' | 'referenceName' | 'releases' | 'repeatable' | 'showBeforeEarned' | 'vendorIdentifier'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsGameCenterLeaderboardReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboard' | 'live'>, limitGameCenterAppVersions?: number, limitGameCenterLeaderboards?: number, limitGameCenterLeaderboardSets?: number, limitGameCenterAchievements?: number, limitAchievementReleases?: number, limitLeaderboardReleases?: number, limitLeaderboardSetReleases?: number, include?: Array<'achievementReleases' | 'app' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, _options?: Configuration): Promise<HttpInfo<GameCenterDetailResponse>> {
        const result = this.api.appsGameCenterDetailGetToOneRelatedWithHttpInfo(id, fieldsGameCenterAchievementReleases, fieldsGameCenterLeaderboardSetReleases, fieldsGameCenterLeaderboardSets, fieldsGameCenterGroups, fieldsGameCenterDetails, fieldsGameCenterLeaderboards, fieldsGameCenterAppVersions, fieldsGameCenterAchievements, fieldsApps, fieldsGameCenterLeaderboardReleases, limitGameCenterAppVersions, limitGameCenterLeaderboards, limitGameCenterLeaderboardSets, limitGameCenterAchievements, limitAchievementReleases, limitLeaderboardReleases, limitLeaderboardSetReleases, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterAchievementReleases the fields to include for returned resources of type gameCenterAchievementReleases
     * @param fieldsGameCenterLeaderboardSetReleases the fields to include for returned resources of type gameCenterLeaderboardSetReleases
     * @param fieldsGameCenterLeaderboardSets the fields to include for returned resources of type gameCenterLeaderboardSets
     * @param fieldsGameCenterGroups the fields to include for returned resources of type gameCenterGroups
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     * @param fieldsGameCenterAppVersions the fields to include for returned resources of type gameCenterAppVersions
     * @param fieldsGameCenterAchievements the fields to include for returned resources of type gameCenterAchievements
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsGameCenterLeaderboardReleases the fields to include for returned resources of type gameCenterLeaderboardReleases
     * @param limitGameCenterAppVersions maximum number of related gameCenterAppVersions returned (when they are included)
     * @param limitGameCenterLeaderboards maximum number of related gameCenterLeaderboards returned (when they are included)
     * @param limitGameCenterLeaderboardSets maximum number of related gameCenterLeaderboardSets returned (when they are included)
     * @param limitGameCenterAchievements maximum number of related gameCenterAchievements returned (when they are included)
     * @param limitAchievementReleases maximum number of related achievementReleases returned (when they are included)
     * @param limitLeaderboardReleases maximum number of related leaderboardReleases returned (when they are included)
     * @param limitLeaderboardSetReleases maximum number of related leaderboardSetReleases returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appsGameCenterDetailGetToOneRelated(id: string, fieldsGameCenterAchievementReleases?: Array<'gameCenterAchievement' | 'gameCenterDetail' | 'live'>, fieldsGameCenterLeaderboardSetReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboardSet' | 'live'>, fieldsGameCenterLeaderboardSets?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'referenceName' | 'releases' | 'vendorIdentifier'>, fieldsGameCenterGroups?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'referenceName'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, fieldsGameCenterAppVersions?: Array<'appStoreVersion' | 'compatibilityVersions' | 'enabled'>, fieldsGameCenterAchievements?: Array<'archived' | 'gameCenterDetail' | 'gameCenterGroup' | 'groupAchievement' | 'localizations' | 'points' | 'referenceName' | 'releases' | 'repeatable' | 'showBeforeEarned' | 'vendorIdentifier'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsGameCenterLeaderboardReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboard' | 'live'>, limitGameCenterAppVersions?: number, limitGameCenterLeaderboards?: number, limitGameCenterLeaderboardSets?: number, limitGameCenterAchievements?: number, limitAchievementReleases?: number, limitLeaderboardReleases?: number, limitLeaderboardSetReleases?: number, include?: Array<'achievementReleases' | 'app' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, _options?: Configuration): Promise<GameCenterDetailResponse> {
        const result = this.api.appsGameCenterDetailGetToOneRelated(id, fieldsGameCenterAchievementReleases, fieldsGameCenterLeaderboardSetReleases, fieldsGameCenterLeaderboardSets, fieldsGameCenterGroups, fieldsGameCenterDetails, fieldsGameCenterLeaderboards, fieldsGameCenterAppVersions, fieldsGameCenterAchievements, fieldsApps, fieldsGameCenterLeaderboardReleases, limitGameCenterAppVersions, limitGameCenterLeaderboards, limitGameCenterLeaderboardSets, limitGameCenterAchievements, limitAchievementReleases, limitLeaderboardReleases, limitLeaderboardSetReleases, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterPlatform filter by attribute \&#39;platform\&#39;
     * @param filterVersionString filter by attribute \&#39;versionString\&#39;
     * @param filterId filter by id(s)
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsGameCenterEnabledVersions the fields to include for returned resources of type gameCenterEnabledVersions
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param limit maximum resources per page
     * @param limitCompatibleVersions maximum number of related compatibleVersions returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appsGameCenterEnabledVersionsGetToManyRelatedWithHttpInfo(id: string, filterPlatform?: Array<'IOS' | 'MAC_OS' | 'TV_OS' | 'VISION_OS'>, filterVersionString?: Array<string>, filterId?: Array<string>, sort?: Array<'versionString' | '-versionString'>, fieldsGameCenterEnabledVersions?: Array<'app' | 'compatibleVersions' | 'iconAsset' | 'platform' | 'versionString'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, limit?: number, limitCompatibleVersions?: number, include?: Array<'app' | 'compatibleVersions'>, _options?: Configuration): Promise<HttpInfo<GameCenterEnabledVersionsResponse>> {
        const result = this.api.appsGameCenterEnabledVersionsGetToManyRelatedWithHttpInfo(id, filterPlatform, filterVersionString, filterId, sort, fieldsGameCenterEnabledVersions, fieldsApps, limit, limitCompatibleVersions, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterPlatform filter by attribute \&#39;platform\&#39;
     * @param filterVersionString filter by attribute \&#39;versionString\&#39;
     * @param filterId filter by id(s)
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsGameCenterEnabledVersions the fields to include for returned resources of type gameCenterEnabledVersions
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param limit maximum resources per page
     * @param limitCompatibleVersions maximum number of related compatibleVersions returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appsGameCenterEnabledVersionsGetToManyRelated(id: string, filterPlatform?: Array<'IOS' | 'MAC_OS' | 'TV_OS' | 'VISION_OS'>, filterVersionString?: Array<string>, filterId?: Array<string>, sort?: Array<'versionString' | '-versionString'>, fieldsGameCenterEnabledVersions?: Array<'app' | 'compatibleVersions' | 'iconAsset' | 'platform' | 'versionString'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, limit?: number, limitCompatibleVersions?: number, include?: Array<'app' | 'compatibleVersions'>, _options?: Configuration): Promise<GameCenterEnabledVersionsResponse> {
        const result = this.api.appsGameCenterEnabledVersionsGetToManyRelated(id, filterPlatform, filterVersionString, filterId, sort, fieldsGameCenterEnabledVersions, fieldsApps, limit, limitCompatibleVersions, include, _options);
        return result.toPromise();
    }

    /**
     * @param filterAppStoreVersionsAppStoreState filter by attribute \&#39;appStoreVersions.appStoreState\&#39;
     * @param filterAppStoreVersionsAppVersionState filter by attribute \&#39;appStoreVersions.appVersionState\&#39;
     * @param filterAppStoreVersionsPlatform filter by attribute \&#39;appStoreVersions.platform\&#39;
     * @param filterBundleId filter by attribute \&#39;bundleId\&#39;
     * @param filterName filter by attribute \&#39;name\&#39;
     * @param filterSku filter by attribute \&#39;sku\&#39;
     * @param filterAppStoreVersions filter by id(s) of related \&#39;appStoreVersions\&#39;
     * @param filterId filter by id(s)
     * @param existsGameCenterEnabledVersions filter by existence or non-existence of related \&#39;gameCenterEnabledVersions\&#39;
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsBetaAppReviewDetails the fields to include for returned resources of type betaAppReviewDetails
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsAppPriceSchedules the fields to include for returned resources of type appPriceSchedules
     * @param fieldsCiProducts the fields to include for returned resources of type ciProducts
     * @param fieldsAlternativeDistributionKeys the fields to include for returned resources of type alternativeDistributionKeys
     * @param fieldsReviewSubmissions the fields to include for returned resources of type reviewSubmissions
     * @param fieldsBetaGroups the fields to include for returned resources of type betaGroups
     * @param fieldsPromotedPurchases the fields to include for returned resources of type promotedPurchases
     * @param fieldsAppAvailabilities the fields to include for returned resources of type appAvailabilities
     * @param fieldsCustomerReviews the fields to include for returned resources of type customerReviews
     * @param fieldsAppEvents the fields to include for returned resources of type appEvents
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param fieldsBetaLicenseAgreements the fields to include for returned resources of type betaLicenseAgreements
     * @param fieldsMarketplaceSearchDetails the fields to include for returned resources of type marketplaceSearchDetails
     * @param fieldsAppClips the fields to include for returned resources of type appClips
     * @param fieldsAppInfos the fields to include for returned resources of type appInfos
     * @param fieldsBetaAppLocalizations the fields to include for returned resources of type betaAppLocalizations
     * @param fieldsAppPricePoints the fields to include for returned resources of type appPricePoints
     * @param fieldsInAppPurchases the fields to include for returned resources of type inAppPurchases
     * @param fieldsPreReleaseVersions the fields to include for returned resources of type preReleaseVersions
     * @param fieldsSubscriptionGroups the fields to include for returned resources of type subscriptionGroups
     * @param fieldsAnalyticsReportRequests the fields to include for returned resources of type analyticsReportRequests
     * @param fieldsAppPrices the fields to include for returned resources of type appPrices
     * @param fieldsAppPreOrders the fields to include for returned resources of type appPreOrders
     * @param fieldsAppStoreVersionExperiments the fields to include for returned resources of type appStoreVersionExperiments
     * @param fieldsGameCenterEnabledVersions the fields to include for returned resources of type gameCenterEnabledVersions
     * @param fieldsSubscriptionGracePeriods the fields to include for returned resources of type subscriptionGracePeriods
     * @param fieldsEndUserLicenseAgreements the fields to include for returned resources of type endUserLicenseAgreements
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsAppCustomProductPages the fields to include for returned resources of type appCustomProductPages
     * @param fieldsAppEncryptionDeclarations the fields to include for returned resources of type appEncryptionDeclarations
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param fieldsPerfPowerMetrics the fields to include for returned resources of type perfPowerMetrics
     * @param limitAppClips maximum number of related appClips returned (when they are included)
     * @param limitAppCustomProductPages maximum number of related appCustomProductPages returned (when they are included)
     * @param limitAppEncryptionDeclarations maximum number of related appEncryptionDeclarations returned (when they are included)
     * @param limitAppEvents maximum number of related appEvents returned (when they are included)
     * @param limitAppInfos maximum number of related appInfos returned (when they are included)
     * @param limitAppStoreVersionExperimentsV2 maximum number of related appStoreVersionExperimentsV2 returned (when they are included)
     * @param limitAppStoreVersions maximum number of related appStoreVersions returned (when they are included)
     * @param limitAvailableTerritories maximum number of related availableTerritories returned (when they are included)
     * @param limitBetaAppLocalizations maximum number of related betaAppLocalizations returned (when they are included)
     * @param limitBetaGroups maximum number of related betaGroups returned (when they are included)
     * @param limitBuilds maximum number of related builds returned (when they are included)
     * @param limitGameCenterEnabledVersions maximum number of related gameCenterEnabledVersions returned (when they are included)
     * @param limitInAppPurchases maximum number of related inAppPurchases returned (when they are included)
     * @param limitInAppPurchasesV2 maximum number of related inAppPurchasesV2 returned (when they are included)
     * @param limitPreReleaseVersions maximum number of related preReleaseVersions returned (when they are included)
     * @param limitPrices maximum number of related prices returned (when they are included)
     * @param limitPromotedPurchases maximum number of related promotedPurchases returned (when they are included)
     * @param limitReviewSubmissions maximum number of related reviewSubmissions returned (when they are included)
     * @param limitSubscriptionGroups maximum number of related subscriptionGroups returned (when they are included)
     */
    public appsGetCollectionWithHttpInfo(filterAppStoreVersionsAppStoreState?: Array<'ACCEPTED' | 'DEVELOPER_REMOVED_FROM_SALE' | 'DEVELOPER_REJECTED' | 'IN_REVIEW' | 'INVALID_BINARY' | 'METADATA_REJECTED' | 'PENDING_APPLE_RELEASE' | 'PENDING_CONTRACT' | 'PENDING_DEVELOPER_RELEASE' | 'PREPARE_FOR_SUBMISSION' | 'PREORDER_READY_FOR_SALE' | 'PROCESSING_FOR_APP_STORE' | 'READY_FOR_REVIEW' | 'READY_FOR_SALE' | 'REJECTED' | 'REMOVED_FROM_SALE' | 'WAITING_FOR_EXPORT_COMPLIANCE' | 'WAITING_FOR_REVIEW' | 'REPLACED_WITH_NEW_VERSION' | 'NOT_APPLICABLE'>, filterAppStoreVersionsAppVersionState?: Array<'ACCEPTED' | 'DEVELOPER_REJECTED' | 'IN_REVIEW' | 'INVALID_BINARY' | 'METADATA_REJECTED' | 'PENDING_APPLE_RELEASE' | 'PENDING_DEVELOPER_RELEASE' | 'PREPARE_FOR_SUBMISSION' | 'PROCESSING_FOR_DISTRIBUTION' | 'READY_FOR_DISTRIBUTION' | 'READY_FOR_REVIEW' | 'REJECTED' | 'REPLACED_WITH_NEW_VERSION' | 'WAITING_FOR_EXPORT_COMPLIANCE' | 'WAITING_FOR_REVIEW'>, filterAppStoreVersionsPlatform?: Array<'IOS' | 'MAC_OS' | 'TV_OS' | 'VISION_OS'>, filterBundleId?: Array<string>, filterName?: Array<string>, filterSku?: Array<string>, filterAppStoreVersions?: Array<string>, filterId?: Array<string>, existsGameCenterEnabledVersions?: boolean, sort?: Array<'bundleId' | '-bundleId' | 'name' | '-name' | 'sku' | '-sku'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, limit?: number, include?: Array<'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'builds' | 'ciProduct' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'preOrder' | 'preReleaseVersions' | 'prices' | 'promotedPurchases' | 'reviewSubmissions' | 'subscriptionGracePeriod' | 'subscriptionGroups'>, fieldsBetaAppReviewDetails?: Array<'app' | 'contactEmail' | 'contactFirstName' | 'contactLastName' | 'contactPhone' | 'demoAccountName' | 'demoAccountPassword' | 'demoAccountRequired' | 'notes'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsAppPriceSchedules?: Array<'app' | 'automaticPrices' | 'baseTerritory' | 'manualPrices'>, fieldsCiProducts?: Array<'additionalRepositories' | 'app' | 'buildRuns' | 'bundleId' | 'createdDate' | 'name' | 'primaryRepositories' | 'productType' | 'workflows'>, fieldsAlternativeDistributionKeys?: Array<'app' | 'publicKey'>, fieldsReviewSubmissions?: Array<'app' | 'appStoreVersionForReview' | 'canceled' | 'items' | 'lastUpdatedByActor' | 'platform' | 'state' | 'submitted' | 'submittedByActor' | 'submittedDate'>, fieldsBetaGroups?: Array<'app' | 'betaTesters' | 'builds' | 'createdDate' | 'feedbackEnabled' | 'hasAccessToAllBuilds' | 'iosBuildsAvailableForAppleSiliconMac' | 'isInternalGroup' | 'name' | 'publicLink' | 'publicLinkEnabled' | 'publicLinkId' | 'publicLinkLimit' | 'publicLinkLimitEnabled'>, fieldsPromotedPurchases?: Array<'app' | 'enabled' | 'inAppPurchaseV2' | 'promotionImages' | 'state' | 'subscription' | 'visibleForAllUsers'>, fieldsAppAvailabilities?: Array<'app' | 'availableInNewTerritories' | 'availableTerritories'>, fieldsCustomerReviews?: Array<'body' | 'createdDate' | 'rating' | 'response' | 'reviewerNickname' | 'territory' | 'title'>, fieldsAppEvents?: Array<'app' | 'archivedTerritorySchedules' | 'badge' | 'deepLink' | 'eventState' | 'localizations' | 'primaryLocale' | 'priority' | 'purchaseRequirement' | 'purpose' | 'referenceName' | 'territorySchedules'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, fieldsBetaLicenseAgreements?: Array<'agreementText' | 'app'>, fieldsMarketplaceSearchDetails?: Array<'app' | 'catalogUrl'>, fieldsAppClips?: Array<'app' | 'appClipAdvancedExperiences' | 'appClipDefaultExperiences' | 'bundleId'>, fieldsAppInfos?: Array<'ageRatingDeclaration' | 'app' | 'appInfoLocalizations' | 'appStoreAgeRating' | 'appStoreState' | 'brazilAgeRating' | 'brazilAgeRatingV2' | 'kidsAgeBand' | 'primaryCategory' | 'primarySubcategoryOne' | 'primarySubcategoryTwo' | 'secondaryCategory' | 'secondarySubcategoryOne' | 'secondarySubcategoryTwo' | 'state'>, fieldsBetaAppLocalizations?: Array<'app' | 'description' | 'feedbackEmail' | 'locale' | 'marketingUrl' | 'privacyPolicyUrl' | 'tvOsPrivacyPolicy'>, fieldsAppPricePoints?: Array<'app' | 'customerPrice' | 'equalizations' | 'priceTier' | 'proceeds' | 'territory'>, fieldsInAppPurchases?: Array<'app' | 'appStoreReviewScreenshot' | 'apps' | 'content' | 'contentHosting' | 'familySharable' | 'iapPriceSchedule' | 'inAppPurchaseAvailability' | 'inAppPurchaseLocalizations' | 'inAppPurchaseType' | 'name' | 'pricePoints' | 'productId' | 'promotedPurchase' | 'referenceName' | 'reviewNote' | 'state'>, fieldsPreReleaseVersions?: Array<'app' | 'builds' | 'platform' | 'version'>, fieldsSubscriptionGroups?: Array<'app' | 'referenceName' | 'subscriptionGroupLocalizations' | 'subscriptions'>, fieldsAnalyticsReportRequests?: Array<'accessType' | 'app' | 'reports' | 'stoppedDueToInactivity'>, fieldsAppPrices?: Array<'app' | 'priceTier'>, fieldsAppPreOrders?: Array<'app' | 'appReleaseDate' | 'preOrderAvailableDate'>, fieldsAppStoreVersionExperiments?: Array<'app' | 'appStoreVersionExperimentTreatments' | 'controlVersions' | 'endDate' | 'latestControlVersion' | 'name' | 'platform' | 'reviewRequired' | 'startDate' | 'started' | 'state' | 'trafficProportion'>, fieldsGameCenterEnabledVersions?: Array<'app' | 'compatibleVersions' | 'iconAsset' | 'platform' | 'versionString'>, fieldsSubscriptionGracePeriods?: Array<'duration' | 'optIn' | 'renewalType' | 'sandboxOptIn'>, fieldsEndUserLicenseAgreements?: Array<'agreementText' | 'app' | 'territories'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsAppCustomProductPages?: Array<'app' | 'appCustomProductPageVersions' | 'appStoreVersionTemplate' | 'customProductPageTemplate' | 'name' | 'url' | 'visible'>, fieldsAppEncryptionDeclarations?: Array<'app' | 'appDescription' | 'appEncryptionDeclarationDocument' | 'appEncryptionDeclarationState' | 'availableOnFrenchStore' | 'builds' | 'codeValue' | 'containsProprietaryCryptography' | 'containsThirdPartyCryptography' | 'createdDate' | 'documentName' | 'documentType' | 'documentUrl' | 'exempt' | 'platform' | 'uploadedDate' | 'usesEncryption'>, fieldsTerritories?: Array<'currency'>, fieldsPerfPowerMetrics?: Array<'deviceType' | 'metricType' | 'platform'>, limitAppClips?: number, limitAppCustomProductPages?: number, limitAppEncryptionDeclarations?: number, limitAppEvents?: number, limitAppInfos?: number, limitAppStoreVersionExperimentsV2?: number, limitAppStoreVersions?: number, limitAvailableTerritories?: number, limitBetaAppLocalizations?: number, limitBetaGroups?: number, limitBuilds?: number, limitGameCenterEnabledVersions?: number, limitInAppPurchases?: number, limitInAppPurchasesV2?: number, limitPreReleaseVersions?: number, limitPrices?: number, limitPromotedPurchases?: number, limitReviewSubmissions?: number, limitSubscriptionGroups?: number, _options?: Configuration): Promise<HttpInfo<AppsResponse>> {
        const result = this.api.appsGetCollectionWithHttpInfo(filterAppStoreVersionsAppStoreState, filterAppStoreVersionsAppVersionState, filterAppStoreVersionsPlatform, filterBundleId, filterName, filterSku, filterAppStoreVersions, filterId, existsGameCenterEnabledVersions, sort, fieldsApps, limit, include, fieldsBetaAppReviewDetails, fieldsGameCenterDetails, fieldsAppPriceSchedules, fieldsCiProducts, fieldsAlternativeDistributionKeys, fieldsReviewSubmissions, fieldsBetaGroups, fieldsPromotedPurchases, fieldsAppAvailabilities, fieldsCustomerReviews, fieldsAppEvents, fieldsBuilds, fieldsBetaLicenseAgreements, fieldsMarketplaceSearchDetails, fieldsAppClips, fieldsAppInfos, fieldsBetaAppLocalizations, fieldsAppPricePoints, fieldsInAppPurchases, fieldsPreReleaseVersions, fieldsSubscriptionGroups, fieldsAnalyticsReportRequests, fieldsAppPrices, fieldsAppPreOrders, fieldsAppStoreVersionExperiments, fieldsGameCenterEnabledVersions, fieldsSubscriptionGracePeriods, fieldsEndUserLicenseAgreements, fieldsAppStoreVersions, fieldsAppCustomProductPages, fieldsAppEncryptionDeclarations, fieldsTerritories, fieldsPerfPowerMetrics, limitAppClips, limitAppCustomProductPages, limitAppEncryptionDeclarations, limitAppEvents, limitAppInfos, limitAppStoreVersionExperimentsV2, limitAppStoreVersions, limitAvailableTerritories, limitBetaAppLocalizations, limitBetaGroups, limitBuilds, limitGameCenterEnabledVersions, limitInAppPurchases, limitInAppPurchasesV2, limitPreReleaseVersions, limitPrices, limitPromotedPurchases, limitReviewSubmissions, limitSubscriptionGroups, _options);
        return result.toPromise();
    }

    /**
     * @param filterAppStoreVersionsAppStoreState filter by attribute \&#39;appStoreVersions.appStoreState\&#39;
     * @param filterAppStoreVersionsAppVersionState filter by attribute \&#39;appStoreVersions.appVersionState\&#39;
     * @param filterAppStoreVersionsPlatform filter by attribute \&#39;appStoreVersions.platform\&#39;
     * @param filterBundleId filter by attribute \&#39;bundleId\&#39;
     * @param filterName filter by attribute \&#39;name\&#39;
     * @param filterSku filter by attribute \&#39;sku\&#39;
     * @param filterAppStoreVersions filter by id(s) of related \&#39;appStoreVersions\&#39;
     * @param filterId filter by id(s)
     * @param existsGameCenterEnabledVersions filter by existence or non-existence of related \&#39;gameCenterEnabledVersions\&#39;
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsBetaAppReviewDetails the fields to include for returned resources of type betaAppReviewDetails
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsAppPriceSchedules the fields to include for returned resources of type appPriceSchedules
     * @param fieldsCiProducts the fields to include for returned resources of type ciProducts
     * @param fieldsAlternativeDistributionKeys the fields to include for returned resources of type alternativeDistributionKeys
     * @param fieldsReviewSubmissions the fields to include for returned resources of type reviewSubmissions
     * @param fieldsBetaGroups the fields to include for returned resources of type betaGroups
     * @param fieldsPromotedPurchases the fields to include for returned resources of type promotedPurchases
     * @param fieldsAppAvailabilities the fields to include for returned resources of type appAvailabilities
     * @param fieldsCustomerReviews the fields to include for returned resources of type customerReviews
     * @param fieldsAppEvents the fields to include for returned resources of type appEvents
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param fieldsBetaLicenseAgreements the fields to include for returned resources of type betaLicenseAgreements
     * @param fieldsMarketplaceSearchDetails the fields to include for returned resources of type marketplaceSearchDetails
     * @param fieldsAppClips the fields to include for returned resources of type appClips
     * @param fieldsAppInfos the fields to include for returned resources of type appInfos
     * @param fieldsBetaAppLocalizations the fields to include for returned resources of type betaAppLocalizations
     * @param fieldsAppPricePoints the fields to include for returned resources of type appPricePoints
     * @param fieldsInAppPurchases the fields to include for returned resources of type inAppPurchases
     * @param fieldsPreReleaseVersions the fields to include for returned resources of type preReleaseVersions
     * @param fieldsSubscriptionGroups the fields to include for returned resources of type subscriptionGroups
     * @param fieldsAnalyticsReportRequests the fields to include for returned resources of type analyticsReportRequests
     * @param fieldsAppPrices the fields to include for returned resources of type appPrices
     * @param fieldsAppPreOrders the fields to include for returned resources of type appPreOrders
     * @param fieldsAppStoreVersionExperiments the fields to include for returned resources of type appStoreVersionExperiments
     * @param fieldsGameCenterEnabledVersions the fields to include for returned resources of type gameCenterEnabledVersions
     * @param fieldsSubscriptionGracePeriods the fields to include for returned resources of type subscriptionGracePeriods
     * @param fieldsEndUserLicenseAgreements the fields to include for returned resources of type endUserLicenseAgreements
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsAppCustomProductPages the fields to include for returned resources of type appCustomProductPages
     * @param fieldsAppEncryptionDeclarations the fields to include for returned resources of type appEncryptionDeclarations
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param fieldsPerfPowerMetrics the fields to include for returned resources of type perfPowerMetrics
     * @param limitAppClips maximum number of related appClips returned (when they are included)
     * @param limitAppCustomProductPages maximum number of related appCustomProductPages returned (when they are included)
     * @param limitAppEncryptionDeclarations maximum number of related appEncryptionDeclarations returned (when they are included)
     * @param limitAppEvents maximum number of related appEvents returned (when they are included)
     * @param limitAppInfos maximum number of related appInfos returned (when they are included)
     * @param limitAppStoreVersionExperimentsV2 maximum number of related appStoreVersionExperimentsV2 returned (when they are included)
     * @param limitAppStoreVersions maximum number of related appStoreVersions returned (when they are included)
     * @param limitAvailableTerritories maximum number of related availableTerritories returned (when they are included)
     * @param limitBetaAppLocalizations maximum number of related betaAppLocalizations returned (when they are included)
     * @param limitBetaGroups maximum number of related betaGroups returned (when they are included)
     * @param limitBuilds maximum number of related builds returned (when they are included)
     * @param limitGameCenterEnabledVersions maximum number of related gameCenterEnabledVersions returned (when they are included)
     * @param limitInAppPurchases maximum number of related inAppPurchases returned (when they are included)
     * @param limitInAppPurchasesV2 maximum number of related inAppPurchasesV2 returned (when they are included)
     * @param limitPreReleaseVersions maximum number of related preReleaseVersions returned (when they are included)
     * @param limitPrices maximum number of related prices returned (when they are included)
     * @param limitPromotedPurchases maximum number of related promotedPurchases returned (when they are included)
     * @param limitReviewSubmissions maximum number of related reviewSubmissions returned (when they are included)
     * @param limitSubscriptionGroups maximum number of related subscriptionGroups returned (when they are included)
     */
    public appsGetCollection(filterAppStoreVersionsAppStoreState?: Array<'ACCEPTED' | 'DEVELOPER_REMOVED_FROM_SALE' | 'DEVELOPER_REJECTED' | 'IN_REVIEW' | 'INVALID_BINARY' | 'METADATA_REJECTED' | 'PENDING_APPLE_RELEASE' | 'PENDING_CONTRACT' | 'PENDING_DEVELOPER_RELEASE' | 'PREPARE_FOR_SUBMISSION' | 'PREORDER_READY_FOR_SALE' | 'PROCESSING_FOR_APP_STORE' | 'READY_FOR_REVIEW' | 'READY_FOR_SALE' | 'REJECTED' | 'REMOVED_FROM_SALE' | 'WAITING_FOR_EXPORT_COMPLIANCE' | 'WAITING_FOR_REVIEW' | 'REPLACED_WITH_NEW_VERSION' | 'NOT_APPLICABLE'>, filterAppStoreVersionsAppVersionState?: Array<'ACCEPTED' | 'DEVELOPER_REJECTED' | 'IN_REVIEW' | 'INVALID_BINARY' | 'METADATA_REJECTED' | 'PENDING_APPLE_RELEASE' | 'PENDING_DEVELOPER_RELEASE' | 'PREPARE_FOR_SUBMISSION' | 'PROCESSING_FOR_DISTRIBUTION' | 'READY_FOR_DISTRIBUTION' | 'READY_FOR_REVIEW' | 'REJECTED' | 'REPLACED_WITH_NEW_VERSION' | 'WAITING_FOR_EXPORT_COMPLIANCE' | 'WAITING_FOR_REVIEW'>, filterAppStoreVersionsPlatform?: Array<'IOS' | 'MAC_OS' | 'TV_OS' | 'VISION_OS'>, filterBundleId?: Array<string>, filterName?: Array<string>, filterSku?: Array<string>, filterAppStoreVersions?: Array<string>, filterId?: Array<string>, existsGameCenterEnabledVersions?: boolean, sort?: Array<'bundleId' | '-bundleId' | 'name' | '-name' | 'sku' | '-sku'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, limit?: number, include?: Array<'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'builds' | 'ciProduct' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'preOrder' | 'preReleaseVersions' | 'prices' | 'promotedPurchases' | 'reviewSubmissions' | 'subscriptionGracePeriod' | 'subscriptionGroups'>, fieldsBetaAppReviewDetails?: Array<'app' | 'contactEmail' | 'contactFirstName' | 'contactLastName' | 'contactPhone' | 'demoAccountName' | 'demoAccountPassword' | 'demoAccountRequired' | 'notes'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsAppPriceSchedules?: Array<'app' | 'automaticPrices' | 'baseTerritory' | 'manualPrices'>, fieldsCiProducts?: Array<'additionalRepositories' | 'app' | 'buildRuns' | 'bundleId' | 'createdDate' | 'name' | 'primaryRepositories' | 'productType' | 'workflows'>, fieldsAlternativeDistributionKeys?: Array<'app' | 'publicKey'>, fieldsReviewSubmissions?: Array<'app' | 'appStoreVersionForReview' | 'canceled' | 'items' | 'lastUpdatedByActor' | 'platform' | 'state' | 'submitted' | 'submittedByActor' | 'submittedDate'>, fieldsBetaGroups?: Array<'app' | 'betaTesters' | 'builds' | 'createdDate' | 'feedbackEnabled' | 'hasAccessToAllBuilds' | 'iosBuildsAvailableForAppleSiliconMac' | 'isInternalGroup' | 'name' | 'publicLink' | 'publicLinkEnabled' | 'publicLinkId' | 'publicLinkLimit' | 'publicLinkLimitEnabled'>, fieldsPromotedPurchases?: Array<'app' | 'enabled' | 'inAppPurchaseV2' | 'promotionImages' | 'state' | 'subscription' | 'visibleForAllUsers'>, fieldsAppAvailabilities?: Array<'app' | 'availableInNewTerritories' | 'availableTerritories'>, fieldsCustomerReviews?: Array<'body' | 'createdDate' | 'rating' | 'response' | 'reviewerNickname' | 'territory' | 'title'>, fieldsAppEvents?: Array<'app' | 'archivedTerritorySchedules' | 'badge' | 'deepLink' | 'eventState' | 'localizations' | 'primaryLocale' | 'priority' | 'purchaseRequirement' | 'purpose' | 'referenceName' | 'territorySchedules'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, fieldsBetaLicenseAgreements?: Array<'agreementText' | 'app'>, fieldsMarketplaceSearchDetails?: Array<'app' | 'catalogUrl'>, fieldsAppClips?: Array<'app' | 'appClipAdvancedExperiences' | 'appClipDefaultExperiences' | 'bundleId'>, fieldsAppInfos?: Array<'ageRatingDeclaration' | 'app' | 'appInfoLocalizations' | 'appStoreAgeRating' | 'appStoreState' | 'brazilAgeRating' | 'brazilAgeRatingV2' | 'kidsAgeBand' | 'primaryCategory' | 'primarySubcategoryOne' | 'primarySubcategoryTwo' | 'secondaryCategory' | 'secondarySubcategoryOne' | 'secondarySubcategoryTwo' | 'state'>, fieldsBetaAppLocalizations?: Array<'app' | 'description' | 'feedbackEmail' | 'locale' | 'marketingUrl' | 'privacyPolicyUrl' | 'tvOsPrivacyPolicy'>, fieldsAppPricePoints?: Array<'app' | 'customerPrice' | 'equalizations' | 'priceTier' | 'proceeds' | 'territory'>, fieldsInAppPurchases?: Array<'app' | 'appStoreReviewScreenshot' | 'apps' | 'content' | 'contentHosting' | 'familySharable' | 'iapPriceSchedule' | 'inAppPurchaseAvailability' | 'inAppPurchaseLocalizations' | 'inAppPurchaseType' | 'name' | 'pricePoints' | 'productId' | 'promotedPurchase' | 'referenceName' | 'reviewNote' | 'state'>, fieldsPreReleaseVersions?: Array<'app' | 'builds' | 'platform' | 'version'>, fieldsSubscriptionGroups?: Array<'app' | 'referenceName' | 'subscriptionGroupLocalizations' | 'subscriptions'>, fieldsAnalyticsReportRequests?: Array<'accessType' | 'app' | 'reports' | 'stoppedDueToInactivity'>, fieldsAppPrices?: Array<'app' | 'priceTier'>, fieldsAppPreOrders?: Array<'app' | 'appReleaseDate' | 'preOrderAvailableDate'>, fieldsAppStoreVersionExperiments?: Array<'app' | 'appStoreVersionExperimentTreatments' | 'controlVersions' | 'endDate' | 'latestControlVersion' | 'name' | 'platform' | 'reviewRequired' | 'startDate' | 'started' | 'state' | 'trafficProportion'>, fieldsGameCenterEnabledVersions?: Array<'app' | 'compatibleVersions' | 'iconAsset' | 'platform' | 'versionString'>, fieldsSubscriptionGracePeriods?: Array<'duration' | 'optIn' | 'renewalType' | 'sandboxOptIn'>, fieldsEndUserLicenseAgreements?: Array<'agreementText' | 'app' | 'territories'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsAppCustomProductPages?: Array<'app' | 'appCustomProductPageVersions' | 'appStoreVersionTemplate' | 'customProductPageTemplate' | 'name' | 'url' | 'visible'>, fieldsAppEncryptionDeclarations?: Array<'app' | 'appDescription' | 'appEncryptionDeclarationDocument' | 'appEncryptionDeclarationState' | 'availableOnFrenchStore' | 'builds' | 'codeValue' | 'containsProprietaryCryptography' | 'containsThirdPartyCryptography' | 'createdDate' | 'documentName' | 'documentType' | 'documentUrl' | 'exempt' | 'platform' | 'uploadedDate' | 'usesEncryption'>, fieldsTerritories?: Array<'currency'>, fieldsPerfPowerMetrics?: Array<'deviceType' | 'metricType' | 'platform'>, limitAppClips?: number, limitAppCustomProductPages?: number, limitAppEncryptionDeclarations?: number, limitAppEvents?: number, limitAppInfos?: number, limitAppStoreVersionExperimentsV2?: number, limitAppStoreVersions?: number, limitAvailableTerritories?: number, limitBetaAppLocalizations?: number, limitBetaGroups?: number, limitBuilds?: number, limitGameCenterEnabledVersions?: number, limitInAppPurchases?: number, limitInAppPurchasesV2?: number, limitPreReleaseVersions?: number, limitPrices?: number, limitPromotedPurchases?: number, limitReviewSubmissions?: number, limitSubscriptionGroups?: number, _options?: Configuration): Promise<AppsResponse> {
        const result = this.api.appsGetCollection(filterAppStoreVersionsAppStoreState, filterAppStoreVersionsAppVersionState, filterAppStoreVersionsPlatform, filterBundleId, filterName, filterSku, filterAppStoreVersions, filterId, existsGameCenterEnabledVersions, sort, fieldsApps, limit, include, fieldsBetaAppReviewDetails, fieldsGameCenterDetails, fieldsAppPriceSchedules, fieldsCiProducts, fieldsAlternativeDistributionKeys, fieldsReviewSubmissions, fieldsBetaGroups, fieldsPromotedPurchases, fieldsAppAvailabilities, fieldsCustomerReviews, fieldsAppEvents, fieldsBuilds, fieldsBetaLicenseAgreements, fieldsMarketplaceSearchDetails, fieldsAppClips, fieldsAppInfos, fieldsBetaAppLocalizations, fieldsAppPricePoints, fieldsInAppPurchases, fieldsPreReleaseVersions, fieldsSubscriptionGroups, fieldsAnalyticsReportRequests, fieldsAppPrices, fieldsAppPreOrders, fieldsAppStoreVersionExperiments, fieldsGameCenterEnabledVersions, fieldsSubscriptionGracePeriods, fieldsEndUserLicenseAgreements, fieldsAppStoreVersions, fieldsAppCustomProductPages, fieldsAppEncryptionDeclarations, fieldsTerritories, fieldsPerfPowerMetrics, limitAppClips, limitAppCustomProductPages, limitAppEncryptionDeclarations, limitAppEvents, limitAppInfos, limitAppStoreVersionExperimentsV2, limitAppStoreVersions, limitAvailableTerritories, limitBetaAppLocalizations, limitBetaGroups, limitBuilds, limitGameCenterEnabledVersions, limitInAppPurchases, limitInAppPurchasesV2, limitPreReleaseVersions, limitPrices, limitPromotedPurchases, limitReviewSubmissions, limitSubscriptionGroups, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param include comma-separated list of relationships to include
     * @param fieldsBetaAppReviewDetails the fields to include for returned resources of type betaAppReviewDetails
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsAppPriceSchedules the fields to include for returned resources of type appPriceSchedules
     * @param fieldsCiProducts the fields to include for returned resources of type ciProducts
     * @param fieldsAlternativeDistributionKeys the fields to include for returned resources of type alternativeDistributionKeys
     * @param fieldsReviewSubmissions the fields to include for returned resources of type reviewSubmissions
     * @param fieldsBetaGroups the fields to include for returned resources of type betaGroups
     * @param fieldsPromotedPurchases the fields to include for returned resources of type promotedPurchases
     * @param fieldsAppAvailabilities the fields to include for returned resources of type appAvailabilities
     * @param fieldsCustomerReviews the fields to include for returned resources of type customerReviews
     * @param fieldsAppEvents the fields to include for returned resources of type appEvents
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param fieldsBetaLicenseAgreements the fields to include for returned resources of type betaLicenseAgreements
     * @param fieldsMarketplaceSearchDetails the fields to include for returned resources of type marketplaceSearchDetails
     * @param fieldsAppClips the fields to include for returned resources of type appClips
     * @param fieldsAppInfos the fields to include for returned resources of type appInfos
     * @param fieldsBetaAppLocalizations the fields to include for returned resources of type betaAppLocalizations
     * @param fieldsAppPricePoints the fields to include for returned resources of type appPricePoints
     * @param fieldsInAppPurchases the fields to include for returned resources of type inAppPurchases
     * @param fieldsPreReleaseVersions the fields to include for returned resources of type preReleaseVersions
     * @param fieldsSubscriptionGroups the fields to include for returned resources of type subscriptionGroups
     * @param fieldsAnalyticsReportRequests the fields to include for returned resources of type analyticsReportRequests
     * @param fieldsAppPrices the fields to include for returned resources of type appPrices
     * @param fieldsAppPreOrders the fields to include for returned resources of type appPreOrders
     * @param fieldsAppStoreVersionExperiments the fields to include for returned resources of type appStoreVersionExperiments
     * @param fieldsGameCenterEnabledVersions the fields to include for returned resources of type gameCenterEnabledVersions
     * @param fieldsSubscriptionGracePeriods the fields to include for returned resources of type subscriptionGracePeriods
     * @param fieldsEndUserLicenseAgreements the fields to include for returned resources of type endUserLicenseAgreements
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsAppCustomProductPages the fields to include for returned resources of type appCustomProductPages
     * @param fieldsAppEncryptionDeclarations the fields to include for returned resources of type appEncryptionDeclarations
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param fieldsPerfPowerMetrics the fields to include for returned resources of type perfPowerMetrics
     * @param limitAppClips maximum number of related appClips returned (when they are included)
     * @param limitAppCustomProductPages maximum number of related appCustomProductPages returned (when they are included)
     * @param limitAppEncryptionDeclarations maximum number of related appEncryptionDeclarations returned (when they are included)
     * @param limitAppEvents maximum number of related appEvents returned (when they are included)
     * @param limitAppInfos maximum number of related appInfos returned (when they are included)
     * @param limitAppStoreVersionExperimentsV2 maximum number of related appStoreVersionExperimentsV2 returned (when they are included)
     * @param limitAppStoreVersions maximum number of related appStoreVersions returned (when they are included)
     * @param limitAvailableTerritories maximum number of related availableTerritories returned (when they are included)
     * @param limitBetaAppLocalizations maximum number of related betaAppLocalizations returned (when they are included)
     * @param limitBetaGroups maximum number of related betaGroups returned (when they are included)
     * @param limitBuilds maximum number of related builds returned (when they are included)
     * @param limitGameCenterEnabledVersions maximum number of related gameCenterEnabledVersions returned (when they are included)
     * @param limitInAppPurchases maximum number of related inAppPurchases returned (when they are included)
     * @param limitInAppPurchasesV2 maximum number of related inAppPurchasesV2 returned (when they are included)
     * @param limitPreReleaseVersions maximum number of related preReleaseVersions returned (when they are included)
     * @param limitPrices maximum number of related prices returned (when they are included)
     * @param limitPromotedPurchases maximum number of related promotedPurchases returned (when they are included)
     * @param limitReviewSubmissions maximum number of related reviewSubmissions returned (when they are included)
     * @param limitSubscriptionGroups maximum number of related subscriptionGroups returned (when they are included)
     */
    public appsGetInstanceWithHttpInfo(id: string, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, include?: Array<'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'builds' | 'ciProduct' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'preOrder' | 'preReleaseVersions' | 'prices' | 'promotedPurchases' | 'reviewSubmissions' | 'subscriptionGracePeriod' | 'subscriptionGroups'>, fieldsBetaAppReviewDetails?: Array<'app' | 'contactEmail' | 'contactFirstName' | 'contactLastName' | 'contactPhone' | 'demoAccountName' | 'demoAccountPassword' | 'demoAccountRequired' | 'notes'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsAppPriceSchedules?: Array<'app' | 'automaticPrices' | 'baseTerritory' | 'manualPrices'>, fieldsCiProducts?: Array<'additionalRepositories' | 'app' | 'buildRuns' | 'bundleId' | 'createdDate' | 'name' | 'primaryRepositories' | 'productType' | 'workflows'>, fieldsAlternativeDistributionKeys?: Array<'app' | 'publicKey'>, fieldsReviewSubmissions?: Array<'app' | 'appStoreVersionForReview' | 'canceled' | 'items' | 'lastUpdatedByActor' | 'platform' | 'state' | 'submitted' | 'submittedByActor' | 'submittedDate'>, fieldsBetaGroups?: Array<'app' | 'betaTesters' | 'builds' | 'createdDate' | 'feedbackEnabled' | 'hasAccessToAllBuilds' | 'iosBuildsAvailableForAppleSiliconMac' | 'isInternalGroup' | 'name' | 'publicLink' | 'publicLinkEnabled' | 'publicLinkId' | 'publicLinkLimit' | 'publicLinkLimitEnabled'>, fieldsPromotedPurchases?: Array<'app' | 'enabled' | 'inAppPurchaseV2' | 'promotionImages' | 'state' | 'subscription' | 'visibleForAllUsers'>, fieldsAppAvailabilities?: Array<'app' | 'availableInNewTerritories' | 'availableTerritories'>, fieldsCustomerReviews?: Array<'body' | 'createdDate' | 'rating' | 'response' | 'reviewerNickname' | 'territory' | 'title'>, fieldsAppEvents?: Array<'app' | 'archivedTerritorySchedules' | 'badge' | 'deepLink' | 'eventState' | 'localizations' | 'primaryLocale' | 'priority' | 'purchaseRequirement' | 'purpose' | 'referenceName' | 'territorySchedules'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, fieldsBetaLicenseAgreements?: Array<'agreementText' | 'app'>, fieldsMarketplaceSearchDetails?: Array<'app' | 'catalogUrl'>, fieldsAppClips?: Array<'app' | 'appClipAdvancedExperiences' | 'appClipDefaultExperiences' | 'bundleId'>, fieldsAppInfos?: Array<'ageRatingDeclaration' | 'app' | 'appInfoLocalizations' | 'appStoreAgeRating' | 'appStoreState' | 'brazilAgeRating' | 'brazilAgeRatingV2' | 'kidsAgeBand' | 'primaryCategory' | 'primarySubcategoryOne' | 'primarySubcategoryTwo' | 'secondaryCategory' | 'secondarySubcategoryOne' | 'secondarySubcategoryTwo' | 'state'>, fieldsBetaAppLocalizations?: Array<'app' | 'description' | 'feedbackEmail' | 'locale' | 'marketingUrl' | 'privacyPolicyUrl' | 'tvOsPrivacyPolicy'>, fieldsAppPricePoints?: Array<'app' | 'customerPrice' | 'equalizations' | 'priceTier' | 'proceeds' | 'territory'>, fieldsInAppPurchases?: Array<'app' | 'appStoreReviewScreenshot' | 'apps' | 'content' | 'contentHosting' | 'familySharable' | 'iapPriceSchedule' | 'inAppPurchaseAvailability' | 'inAppPurchaseLocalizations' | 'inAppPurchaseType' | 'name' | 'pricePoints' | 'productId' | 'promotedPurchase' | 'referenceName' | 'reviewNote' | 'state'>, fieldsPreReleaseVersions?: Array<'app' | 'builds' | 'platform' | 'version'>, fieldsSubscriptionGroups?: Array<'app' | 'referenceName' | 'subscriptionGroupLocalizations' | 'subscriptions'>, fieldsAnalyticsReportRequests?: Array<'accessType' | 'app' | 'reports' | 'stoppedDueToInactivity'>, fieldsAppPrices?: Array<'app' | 'priceTier'>, fieldsAppPreOrders?: Array<'app' | 'appReleaseDate' | 'preOrderAvailableDate'>, fieldsAppStoreVersionExperiments?: Array<'app' | 'appStoreVersionExperimentTreatments' | 'controlVersions' | 'endDate' | 'latestControlVersion' | 'name' | 'platform' | 'reviewRequired' | 'startDate' | 'started' | 'state' | 'trafficProportion'>, fieldsGameCenterEnabledVersions?: Array<'app' | 'compatibleVersions' | 'iconAsset' | 'platform' | 'versionString'>, fieldsSubscriptionGracePeriods?: Array<'duration' | 'optIn' | 'renewalType' | 'sandboxOptIn'>, fieldsEndUserLicenseAgreements?: Array<'agreementText' | 'app' | 'territories'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsAppCustomProductPages?: Array<'app' | 'appCustomProductPageVersions' | 'appStoreVersionTemplate' | 'customProductPageTemplate' | 'name' | 'url' | 'visible'>, fieldsAppEncryptionDeclarations?: Array<'app' | 'appDescription' | 'appEncryptionDeclarationDocument' | 'appEncryptionDeclarationState' | 'availableOnFrenchStore' | 'builds' | 'codeValue' | 'containsProprietaryCryptography' | 'containsThirdPartyCryptography' | 'createdDate' | 'documentName' | 'documentType' | 'documentUrl' | 'exempt' | 'platform' | 'uploadedDate' | 'usesEncryption'>, fieldsTerritories?: Array<'currency'>, fieldsPerfPowerMetrics?: Array<'deviceType' | 'metricType' | 'platform'>, limitAppClips?: number, limitAppCustomProductPages?: number, limitAppEncryptionDeclarations?: number, limitAppEvents?: number, limitAppInfos?: number, limitAppStoreVersionExperimentsV2?: number, limitAppStoreVersions?: number, limitAvailableTerritories?: number, limitBetaAppLocalizations?: number, limitBetaGroups?: number, limitBuilds?: number, limitGameCenterEnabledVersions?: number, limitInAppPurchases?: number, limitInAppPurchasesV2?: number, limitPreReleaseVersions?: number, limitPrices?: number, limitPromotedPurchases?: number, limitReviewSubmissions?: number, limitSubscriptionGroups?: number, _options?: Configuration): Promise<HttpInfo<AppResponse>> {
        const result = this.api.appsGetInstanceWithHttpInfo(id, fieldsApps, include, fieldsBetaAppReviewDetails, fieldsGameCenterDetails, fieldsAppPriceSchedules, fieldsCiProducts, fieldsAlternativeDistributionKeys, fieldsReviewSubmissions, fieldsBetaGroups, fieldsPromotedPurchases, fieldsAppAvailabilities, fieldsCustomerReviews, fieldsAppEvents, fieldsBuilds, fieldsBetaLicenseAgreements, fieldsMarketplaceSearchDetails, fieldsAppClips, fieldsAppInfos, fieldsBetaAppLocalizations, fieldsAppPricePoints, fieldsInAppPurchases, fieldsPreReleaseVersions, fieldsSubscriptionGroups, fieldsAnalyticsReportRequests, fieldsAppPrices, fieldsAppPreOrders, fieldsAppStoreVersionExperiments, fieldsGameCenterEnabledVersions, fieldsSubscriptionGracePeriods, fieldsEndUserLicenseAgreements, fieldsAppStoreVersions, fieldsAppCustomProductPages, fieldsAppEncryptionDeclarations, fieldsTerritories, fieldsPerfPowerMetrics, limitAppClips, limitAppCustomProductPages, limitAppEncryptionDeclarations, limitAppEvents, limitAppInfos, limitAppStoreVersionExperimentsV2, limitAppStoreVersions, limitAvailableTerritories, limitBetaAppLocalizations, limitBetaGroups, limitBuilds, limitGameCenterEnabledVersions, limitInAppPurchases, limitInAppPurchasesV2, limitPreReleaseVersions, limitPrices, limitPromotedPurchases, limitReviewSubmissions, limitSubscriptionGroups, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param include comma-separated list of relationships to include
     * @param fieldsBetaAppReviewDetails the fields to include for returned resources of type betaAppReviewDetails
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsAppPriceSchedules the fields to include for returned resources of type appPriceSchedules
     * @param fieldsCiProducts the fields to include for returned resources of type ciProducts
     * @param fieldsAlternativeDistributionKeys the fields to include for returned resources of type alternativeDistributionKeys
     * @param fieldsReviewSubmissions the fields to include for returned resources of type reviewSubmissions
     * @param fieldsBetaGroups the fields to include for returned resources of type betaGroups
     * @param fieldsPromotedPurchases the fields to include for returned resources of type promotedPurchases
     * @param fieldsAppAvailabilities the fields to include for returned resources of type appAvailabilities
     * @param fieldsCustomerReviews the fields to include for returned resources of type customerReviews
     * @param fieldsAppEvents the fields to include for returned resources of type appEvents
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param fieldsBetaLicenseAgreements the fields to include for returned resources of type betaLicenseAgreements
     * @param fieldsMarketplaceSearchDetails the fields to include for returned resources of type marketplaceSearchDetails
     * @param fieldsAppClips the fields to include for returned resources of type appClips
     * @param fieldsAppInfos the fields to include for returned resources of type appInfos
     * @param fieldsBetaAppLocalizations the fields to include for returned resources of type betaAppLocalizations
     * @param fieldsAppPricePoints the fields to include for returned resources of type appPricePoints
     * @param fieldsInAppPurchases the fields to include for returned resources of type inAppPurchases
     * @param fieldsPreReleaseVersions the fields to include for returned resources of type preReleaseVersions
     * @param fieldsSubscriptionGroups the fields to include for returned resources of type subscriptionGroups
     * @param fieldsAnalyticsReportRequests the fields to include for returned resources of type analyticsReportRequests
     * @param fieldsAppPrices the fields to include for returned resources of type appPrices
     * @param fieldsAppPreOrders the fields to include for returned resources of type appPreOrders
     * @param fieldsAppStoreVersionExperiments the fields to include for returned resources of type appStoreVersionExperiments
     * @param fieldsGameCenterEnabledVersions the fields to include for returned resources of type gameCenterEnabledVersions
     * @param fieldsSubscriptionGracePeriods the fields to include for returned resources of type subscriptionGracePeriods
     * @param fieldsEndUserLicenseAgreements the fields to include for returned resources of type endUserLicenseAgreements
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsAppCustomProductPages the fields to include for returned resources of type appCustomProductPages
     * @param fieldsAppEncryptionDeclarations the fields to include for returned resources of type appEncryptionDeclarations
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param fieldsPerfPowerMetrics the fields to include for returned resources of type perfPowerMetrics
     * @param limitAppClips maximum number of related appClips returned (when they are included)
     * @param limitAppCustomProductPages maximum number of related appCustomProductPages returned (when they are included)
     * @param limitAppEncryptionDeclarations maximum number of related appEncryptionDeclarations returned (when they are included)
     * @param limitAppEvents maximum number of related appEvents returned (when they are included)
     * @param limitAppInfos maximum number of related appInfos returned (when they are included)
     * @param limitAppStoreVersionExperimentsV2 maximum number of related appStoreVersionExperimentsV2 returned (when they are included)
     * @param limitAppStoreVersions maximum number of related appStoreVersions returned (when they are included)
     * @param limitAvailableTerritories maximum number of related availableTerritories returned (when they are included)
     * @param limitBetaAppLocalizations maximum number of related betaAppLocalizations returned (when they are included)
     * @param limitBetaGroups maximum number of related betaGroups returned (when they are included)
     * @param limitBuilds maximum number of related builds returned (when they are included)
     * @param limitGameCenterEnabledVersions maximum number of related gameCenterEnabledVersions returned (when they are included)
     * @param limitInAppPurchases maximum number of related inAppPurchases returned (when they are included)
     * @param limitInAppPurchasesV2 maximum number of related inAppPurchasesV2 returned (when they are included)
     * @param limitPreReleaseVersions maximum number of related preReleaseVersions returned (when they are included)
     * @param limitPrices maximum number of related prices returned (when they are included)
     * @param limitPromotedPurchases maximum number of related promotedPurchases returned (when they are included)
     * @param limitReviewSubmissions maximum number of related reviewSubmissions returned (when they are included)
     * @param limitSubscriptionGroups maximum number of related subscriptionGroups returned (when they are included)
     */
    public appsGetInstance(id: string, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, include?: Array<'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'builds' | 'ciProduct' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'preOrder' | 'preReleaseVersions' | 'prices' | 'promotedPurchases' | 'reviewSubmissions' | 'subscriptionGracePeriod' | 'subscriptionGroups'>, fieldsBetaAppReviewDetails?: Array<'app' | 'contactEmail' | 'contactFirstName' | 'contactLastName' | 'contactPhone' | 'demoAccountName' | 'demoAccountPassword' | 'demoAccountRequired' | 'notes'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsAppPriceSchedules?: Array<'app' | 'automaticPrices' | 'baseTerritory' | 'manualPrices'>, fieldsCiProducts?: Array<'additionalRepositories' | 'app' | 'buildRuns' | 'bundleId' | 'createdDate' | 'name' | 'primaryRepositories' | 'productType' | 'workflows'>, fieldsAlternativeDistributionKeys?: Array<'app' | 'publicKey'>, fieldsReviewSubmissions?: Array<'app' | 'appStoreVersionForReview' | 'canceled' | 'items' | 'lastUpdatedByActor' | 'platform' | 'state' | 'submitted' | 'submittedByActor' | 'submittedDate'>, fieldsBetaGroups?: Array<'app' | 'betaTesters' | 'builds' | 'createdDate' | 'feedbackEnabled' | 'hasAccessToAllBuilds' | 'iosBuildsAvailableForAppleSiliconMac' | 'isInternalGroup' | 'name' | 'publicLink' | 'publicLinkEnabled' | 'publicLinkId' | 'publicLinkLimit' | 'publicLinkLimitEnabled'>, fieldsPromotedPurchases?: Array<'app' | 'enabled' | 'inAppPurchaseV2' | 'promotionImages' | 'state' | 'subscription' | 'visibleForAllUsers'>, fieldsAppAvailabilities?: Array<'app' | 'availableInNewTerritories' | 'availableTerritories'>, fieldsCustomerReviews?: Array<'body' | 'createdDate' | 'rating' | 'response' | 'reviewerNickname' | 'territory' | 'title'>, fieldsAppEvents?: Array<'app' | 'archivedTerritorySchedules' | 'badge' | 'deepLink' | 'eventState' | 'localizations' | 'primaryLocale' | 'priority' | 'purchaseRequirement' | 'purpose' | 'referenceName' | 'territorySchedules'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, fieldsBetaLicenseAgreements?: Array<'agreementText' | 'app'>, fieldsMarketplaceSearchDetails?: Array<'app' | 'catalogUrl'>, fieldsAppClips?: Array<'app' | 'appClipAdvancedExperiences' | 'appClipDefaultExperiences' | 'bundleId'>, fieldsAppInfos?: Array<'ageRatingDeclaration' | 'app' | 'appInfoLocalizations' | 'appStoreAgeRating' | 'appStoreState' | 'brazilAgeRating' | 'brazilAgeRatingV2' | 'kidsAgeBand' | 'primaryCategory' | 'primarySubcategoryOne' | 'primarySubcategoryTwo' | 'secondaryCategory' | 'secondarySubcategoryOne' | 'secondarySubcategoryTwo' | 'state'>, fieldsBetaAppLocalizations?: Array<'app' | 'description' | 'feedbackEmail' | 'locale' | 'marketingUrl' | 'privacyPolicyUrl' | 'tvOsPrivacyPolicy'>, fieldsAppPricePoints?: Array<'app' | 'customerPrice' | 'equalizations' | 'priceTier' | 'proceeds' | 'territory'>, fieldsInAppPurchases?: Array<'app' | 'appStoreReviewScreenshot' | 'apps' | 'content' | 'contentHosting' | 'familySharable' | 'iapPriceSchedule' | 'inAppPurchaseAvailability' | 'inAppPurchaseLocalizations' | 'inAppPurchaseType' | 'name' | 'pricePoints' | 'productId' | 'promotedPurchase' | 'referenceName' | 'reviewNote' | 'state'>, fieldsPreReleaseVersions?: Array<'app' | 'builds' | 'platform' | 'version'>, fieldsSubscriptionGroups?: Array<'app' | 'referenceName' | 'subscriptionGroupLocalizations' | 'subscriptions'>, fieldsAnalyticsReportRequests?: Array<'accessType' | 'app' | 'reports' | 'stoppedDueToInactivity'>, fieldsAppPrices?: Array<'app' | 'priceTier'>, fieldsAppPreOrders?: Array<'app' | 'appReleaseDate' | 'preOrderAvailableDate'>, fieldsAppStoreVersionExperiments?: Array<'app' | 'appStoreVersionExperimentTreatments' | 'controlVersions' | 'endDate' | 'latestControlVersion' | 'name' | 'platform' | 'reviewRequired' | 'startDate' | 'started' | 'state' | 'trafficProportion'>, fieldsGameCenterEnabledVersions?: Array<'app' | 'compatibleVersions' | 'iconAsset' | 'platform' | 'versionString'>, fieldsSubscriptionGracePeriods?: Array<'duration' | 'optIn' | 'renewalType' | 'sandboxOptIn'>, fieldsEndUserLicenseAgreements?: Array<'agreementText' | 'app' | 'territories'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsAppCustomProductPages?: Array<'app' | 'appCustomProductPageVersions' | 'appStoreVersionTemplate' | 'customProductPageTemplate' | 'name' | 'url' | 'visible'>, fieldsAppEncryptionDeclarations?: Array<'app' | 'appDescription' | 'appEncryptionDeclarationDocument' | 'appEncryptionDeclarationState' | 'availableOnFrenchStore' | 'builds' | 'codeValue' | 'containsProprietaryCryptography' | 'containsThirdPartyCryptography' | 'createdDate' | 'documentName' | 'documentType' | 'documentUrl' | 'exempt' | 'platform' | 'uploadedDate' | 'usesEncryption'>, fieldsTerritories?: Array<'currency'>, fieldsPerfPowerMetrics?: Array<'deviceType' | 'metricType' | 'platform'>, limitAppClips?: number, limitAppCustomProductPages?: number, limitAppEncryptionDeclarations?: number, limitAppEvents?: number, limitAppInfos?: number, limitAppStoreVersionExperimentsV2?: number, limitAppStoreVersions?: number, limitAvailableTerritories?: number, limitBetaAppLocalizations?: number, limitBetaGroups?: number, limitBuilds?: number, limitGameCenterEnabledVersions?: number, limitInAppPurchases?: number, limitInAppPurchasesV2?: number, limitPreReleaseVersions?: number, limitPrices?: number, limitPromotedPurchases?: number, limitReviewSubmissions?: number, limitSubscriptionGroups?: number, _options?: Configuration): Promise<AppResponse> {
        const result = this.api.appsGetInstance(id, fieldsApps, include, fieldsBetaAppReviewDetails, fieldsGameCenterDetails, fieldsAppPriceSchedules, fieldsCiProducts, fieldsAlternativeDistributionKeys, fieldsReviewSubmissions, fieldsBetaGroups, fieldsPromotedPurchases, fieldsAppAvailabilities, fieldsCustomerReviews, fieldsAppEvents, fieldsBuilds, fieldsBetaLicenseAgreements, fieldsMarketplaceSearchDetails, fieldsAppClips, fieldsAppInfos, fieldsBetaAppLocalizations, fieldsAppPricePoints, fieldsInAppPurchases, fieldsPreReleaseVersions, fieldsSubscriptionGroups, fieldsAnalyticsReportRequests, fieldsAppPrices, fieldsAppPreOrders, fieldsAppStoreVersionExperiments, fieldsGameCenterEnabledVersions, fieldsSubscriptionGracePeriods, fieldsEndUserLicenseAgreements, fieldsAppStoreVersions, fieldsAppCustomProductPages, fieldsAppEncryptionDeclarations, fieldsTerritories, fieldsPerfPowerMetrics, limitAppClips, limitAppCustomProductPages, limitAppEncryptionDeclarations, limitAppEvents, limitAppInfos, limitAppStoreVersionExperimentsV2, limitAppStoreVersions, limitAvailableTerritories, limitBetaAppLocalizations, limitBetaGroups, limitBuilds, limitGameCenterEnabledVersions, limitInAppPurchases, limitInAppPurchasesV2, limitPreReleaseVersions, limitPrices, limitPromotedPurchases, limitReviewSubmissions, limitSubscriptionGroups, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterInAppPurchaseType filter by attribute \&#39;inAppPurchaseType\&#39;
     * @param filterCanBeSubmitted filter by canBeSubmitted
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsInAppPurchases the fields to include for returned resources of type inAppPurchases
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param limit maximum resources per page
     * @param limitApps maximum number of related apps returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appsInAppPurchasesGetToManyRelatedWithHttpInfo(id: string, filterInAppPurchaseType?: Array<'AUTOMATICALLY_RENEWABLE_SUBSCRIPTION' | 'NON_CONSUMABLE' | 'CONSUMABLE' | 'NON_RENEWING_SUBSCRIPTION' | 'FREE_SUBSCRIPTION'>, filterCanBeSubmitted?: Array<string>, sort?: Array<'inAppPurchaseType' | '-inAppPurchaseType' | 'productId' | '-productId' | 'referenceName' | '-referenceName'>, fieldsInAppPurchases?: Array<'apps' | 'inAppPurchaseType' | 'productId' | 'referenceName' | 'state'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, limit?: number, limitApps?: number, include?: Array<'apps'>, _options?: Configuration): Promise<HttpInfo<InAppPurchasesResponse>> {
        const result = this.api.appsInAppPurchasesGetToManyRelatedWithHttpInfo(id, filterInAppPurchaseType, filterCanBeSubmitted, sort, fieldsInAppPurchases, fieldsApps, limit, limitApps, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterInAppPurchaseType filter by attribute \&#39;inAppPurchaseType\&#39;
     * @param filterCanBeSubmitted filter by canBeSubmitted
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsInAppPurchases the fields to include for returned resources of type inAppPurchases
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param limit maximum resources per page
     * @param limitApps maximum number of related apps returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appsInAppPurchasesGetToManyRelated(id: string, filterInAppPurchaseType?: Array<'AUTOMATICALLY_RENEWABLE_SUBSCRIPTION' | 'NON_CONSUMABLE' | 'CONSUMABLE' | 'NON_RENEWING_SUBSCRIPTION' | 'FREE_SUBSCRIPTION'>, filterCanBeSubmitted?: Array<string>, sort?: Array<'inAppPurchaseType' | '-inAppPurchaseType' | 'productId' | '-productId' | 'referenceName' | '-referenceName'>, fieldsInAppPurchases?: Array<'apps' | 'inAppPurchaseType' | 'productId' | 'referenceName' | 'state'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, limit?: number, limitApps?: number, include?: Array<'apps'>, _options?: Configuration): Promise<InAppPurchasesResponse> {
        const result = this.api.appsInAppPurchasesGetToManyRelated(id, filterInAppPurchaseType, filterCanBeSubmitted, sort, fieldsInAppPurchases, fieldsApps, limit, limitApps, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterInAppPurchaseType filter by attribute \&#39;inAppPurchaseType\&#39;
     * @param filterName filter by attribute \&#39;name\&#39;
     * @param filterProductId filter by attribute \&#39;productId\&#39;
     * @param filterState filter by attribute \&#39;state\&#39;
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsInAppPurchaseAppStoreReviewScreenshots the fields to include for returned resources of type inAppPurchaseAppStoreReviewScreenshots
     * @param fieldsInAppPurchaseAvailabilities the fields to include for returned resources of type inAppPurchaseAvailabilities
     * @param fieldsPromotedPurchases the fields to include for returned resources of type promotedPurchases
     * @param fieldsInAppPurchaseLocalizations the fields to include for returned resources of type inAppPurchaseLocalizations
     * @param fieldsInAppPurchases the fields to include for returned resources of type inAppPurchases
     * @param fieldsInAppPurchasePriceSchedules the fields to include for returned resources of type inAppPurchasePriceSchedules
     * @param fieldsInAppPurchaseContents the fields to include for returned resources of type inAppPurchaseContents
     * @param limit maximum resources per page
     * @param limitInAppPurchaseLocalizations maximum number of related inAppPurchaseLocalizations returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appsInAppPurchasesV2GetToManyRelatedWithHttpInfo(id: string, filterInAppPurchaseType?: Array<'CONSUMABLE' | 'NON_CONSUMABLE' | 'NON_RENEWING_SUBSCRIPTION'>, filterName?: Array<string>, filterProductId?: Array<string>, filterState?: Array<'MISSING_METADATA' | 'WAITING_FOR_UPLOAD' | 'PROCESSING_CONTENT' | 'READY_TO_SUBMIT' | 'WAITING_FOR_REVIEW' | 'IN_REVIEW' | 'DEVELOPER_ACTION_NEEDED' | 'PENDING_BINARY_APPROVAL' | 'APPROVED' | 'DEVELOPER_REMOVED_FROM_SALE' | 'REMOVED_FROM_SALE' | 'REJECTED'>, sort?: Array<'inAppPurchaseType' | '-inAppPurchaseType' | 'name' | '-name'>, fieldsInAppPurchaseAppStoreReviewScreenshots?: Array<'assetDeliveryState' | 'assetToken' | 'assetType' | 'fileName' | 'fileSize' | 'imageAsset' | 'inAppPurchaseV2' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, fieldsInAppPurchaseAvailabilities?: Array<'availableInNewTerritories' | 'availableTerritories' | 'inAppPurchase'>, fieldsPromotedPurchases?: Array<'app' | 'enabled' | 'inAppPurchaseV2' | 'promotionImages' | 'state' | 'subscription' | 'visibleForAllUsers'>, fieldsInAppPurchaseLocalizations?: Array<'description' | 'inAppPurchaseV2' | 'locale' | 'name' | 'state'>, fieldsInAppPurchases?: Array<'app' | 'appStoreReviewScreenshot' | 'content' | 'contentHosting' | 'familySharable' | 'iapPriceSchedule' | 'inAppPurchaseAvailability' | 'inAppPurchaseLocalizations' | 'inAppPurchaseType' | 'name' | 'productId' | 'promotedPurchase' | 'reviewNote' | 'state'>, fieldsInAppPurchasePriceSchedules?: Array<'automaticPrices' | 'baseTerritory' | 'inAppPurchase' | 'manualPrices'>, fieldsInAppPurchaseContents?: Array<'fileName' | 'fileSize' | 'inAppPurchaseV2' | 'lastModifiedDate' | 'url'>, limit?: number, limitInAppPurchaseLocalizations?: number, include?: Array<'appStoreReviewScreenshot' | 'content' | 'iapPriceSchedule' | 'inAppPurchaseAvailability' | 'inAppPurchaseLocalizations' | 'promotedPurchase'>, _options?: Configuration): Promise<HttpInfo<InAppPurchasesV2Response>> {
        const result = this.api.appsInAppPurchasesV2GetToManyRelatedWithHttpInfo(id, filterInAppPurchaseType, filterName, filterProductId, filterState, sort, fieldsInAppPurchaseAppStoreReviewScreenshots, fieldsInAppPurchaseAvailabilities, fieldsPromotedPurchases, fieldsInAppPurchaseLocalizations, fieldsInAppPurchases, fieldsInAppPurchasePriceSchedules, fieldsInAppPurchaseContents, limit, limitInAppPurchaseLocalizations, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterInAppPurchaseType filter by attribute \&#39;inAppPurchaseType\&#39;
     * @param filterName filter by attribute \&#39;name\&#39;
     * @param filterProductId filter by attribute \&#39;productId\&#39;
     * @param filterState filter by attribute \&#39;state\&#39;
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsInAppPurchaseAppStoreReviewScreenshots the fields to include for returned resources of type inAppPurchaseAppStoreReviewScreenshots
     * @param fieldsInAppPurchaseAvailabilities the fields to include for returned resources of type inAppPurchaseAvailabilities
     * @param fieldsPromotedPurchases the fields to include for returned resources of type promotedPurchases
     * @param fieldsInAppPurchaseLocalizations the fields to include for returned resources of type inAppPurchaseLocalizations
     * @param fieldsInAppPurchases the fields to include for returned resources of type inAppPurchases
     * @param fieldsInAppPurchasePriceSchedules the fields to include for returned resources of type inAppPurchasePriceSchedules
     * @param fieldsInAppPurchaseContents the fields to include for returned resources of type inAppPurchaseContents
     * @param limit maximum resources per page
     * @param limitInAppPurchaseLocalizations maximum number of related inAppPurchaseLocalizations returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appsInAppPurchasesV2GetToManyRelated(id: string, filterInAppPurchaseType?: Array<'CONSUMABLE' | 'NON_CONSUMABLE' | 'NON_RENEWING_SUBSCRIPTION'>, filterName?: Array<string>, filterProductId?: Array<string>, filterState?: Array<'MISSING_METADATA' | 'WAITING_FOR_UPLOAD' | 'PROCESSING_CONTENT' | 'READY_TO_SUBMIT' | 'WAITING_FOR_REVIEW' | 'IN_REVIEW' | 'DEVELOPER_ACTION_NEEDED' | 'PENDING_BINARY_APPROVAL' | 'APPROVED' | 'DEVELOPER_REMOVED_FROM_SALE' | 'REMOVED_FROM_SALE' | 'REJECTED'>, sort?: Array<'inAppPurchaseType' | '-inAppPurchaseType' | 'name' | '-name'>, fieldsInAppPurchaseAppStoreReviewScreenshots?: Array<'assetDeliveryState' | 'assetToken' | 'assetType' | 'fileName' | 'fileSize' | 'imageAsset' | 'inAppPurchaseV2' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, fieldsInAppPurchaseAvailabilities?: Array<'availableInNewTerritories' | 'availableTerritories' | 'inAppPurchase'>, fieldsPromotedPurchases?: Array<'app' | 'enabled' | 'inAppPurchaseV2' | 'promotionImages' | 'state' | 'subscription' | 'visibleForAllUsers'>, fieldsInAppPurchaseLocalizations?: Array<'description' | 'inAppPurchaseV2' | 'locale' | 'name' | 'state'>, fieldsInAppPurchases?: Array<'app' | 'appStoreReviewScreenshot' | 'content' | 'contentHosting' | 'familySharable' | 'iapPriceSchedule' | 'inAppPurchaseAvailability' | 'inAppPurchaseLocalizations' | 'inAppPurchaseType' | 'name' | 'productId' | 'promotedPurchase' | 'reviewNote' | 'state'>, fieldsInAppPurchasePriceSchedules?: Array<'automaticPrices' | 'baseTerritory' | 'inAppPurchase' | 'manualPrices'>, fieldsInAppPurchaseContents?: Array<'fileName' | 'fileSize' | 'inAppPurchaseV2' | 'lastModifiedDate' | 'url'>, limit?: number, limitInAppPurchaseLocalizations?: number, include?: Array<'appStoreReviewScreenshot' | 'content' | 'iapPriceSchedule' | 'inAppPurchaseAvailability' | 'inAppPurchaseLocalizations' | 'promotedPurchase'>, _options?: Configuration): Promise<InAppPurchasesV2Response> {
        const result = this.api.appsInAppPurchasesV2GetToManyRelated(id, filterInAppPurchaseType, filterName, filterProductId, filterState, sort, fieldsInAppPurchaseAppStoreReviewScreenshots, fieldsInAppPurchaseAvailabilities, fieldsPromotedPurchases, fieldsInAppPurchaseLocalizations, fieldsInAppPurchases, fieldsInAppPurchasePriceSchedules, fieldsInAppPurchaseContents, limit, limitInAppPurchaseLocalizations, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsMarketplaceSearchDetails the fields to include for returned resources of type marketplaceSearchDetails
     */
    public appsMarketplaceSearchDetailGetToOneRelatedWithHttpInfo(id: string, fieldsMarketplaceSearchDetails?: Array<'app' | 'catalogUrl'>, _options?: Configuration): Promise<HttpInfo<MarketplaceSearchDetailResponse>> {
        const result = this.api.appsMarketplaceSearchDetailGetToOneRelatedWithHttpInfo(id, fieldsMarketplaceSearchDetails, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsMarketplaceSearchDetails the fields to include for returned resources of type marketplaceSearchDetails
     */
    public appsMarketplaceSearchDetailGetToOneRelated(id: string, fieldsMarketplaceSearchDetails?: Array<'app' | 'catalogUrl'>, _options?: Configuration): Promise<MarketplaceSearchDetailResponse> {
        const result = this.api.appsMarketplaceSearchDetailGetToOneRelated(id, fieldsMarketplaceSearchDetails, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterDeviceType filter by attribute \&#39;deviceType\&#39;
     * @param filterMetricType filter by attribute \&#39;metricType\&#39;
     * @param filterPlatform filter by attribute \&#39;platform\&#39;
     */
    public appsPerfPowerMetricsGetToManyRelatedWithHttpInfo(id: string, filterDeviceType?: Array<string>, filterMetricType?: Array<'DISK' | 'HANG' | 'BATTERY' | 'LAUNCH' | 'MEMORY' | 'ANIMATION' | 'TERMINATION'>, filterPlatform?: Array<'IOS'>, _options?: Configuration): Promise<HttpInfo<XcodeMetrics>> {
        const result = this.api.appsPerfPowerMetricsGetToManyRelatedWithHttpInfo(id, filterDeviceType, filterMetricType, filterPlatform, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterDeviceType filter by attribute \&#39;deviceType\&#39;
     * @param filterMetricType filter by attribute \&#39;metricType\&#39;
     * @param filterPlatform filter by attribute \&#39;platform\&#39;
     */
    public appsPerfPowerMetricsGetToManyRelated(id: string, filterDeviceType?: Array<string>, filterMetricType?: Array<'DISK' | 'HANG' | 'BATTERY' | 'LAUNCH' | 'MEMORY' | 'ANIMATION' | 'TERMINATION'>, filterPlatform?: Array<'IOS'>, _options?: Configuration): Promise<XcodeMetrics> {
        const result = this.api.appsPerfPowerMetricsGetToManyRelated(id, filterDeviceType, filterMetricType, filterPlatform, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppPreOrders the fields to include for returned resources of type appPreOrders
     */
    public appsPreOrderGetToOneRelatedWithHttpInfo(id: string, fieldsAppPreOrders?: Array<'app' | 'appReleaseDate' | 'preOrderAvailableDate'>, _options?: Configuration): Promise<HttpInfo<AppPreOrderWithoutIncludesResponse>> {
        const result = this.api.appsPreOrderGetToOneRelatedWithHttpInfo(id, fieldsAppPreOrders, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppPreOrders the fields to include for returned resources of type appPreOrders
     */
    public appsPreOrderGetToOneRelated(id: string, fieldsAppPreOrders?: Array<'app' | 'appReleaseDate' | 'preOrderAvailableDate'>, _options?: Configuration): Promise<AppPreOrderWithoutIncludesResponse> {
        const result = this.api.appsPreOrderGetToOneRelated(id, fieldsAppPreOrders, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsPreReleaseVersions the fields to include for returned resources of type preReleaseVersions
     * @param limit maximum resources per page
     */
    public appsPreReleaseVersionsGetToManyRelatedWithHttpInfo(id: string, fieldsPreReleaseVersions?: Array<'app' | 'builds' | 'platform' | 'version'>, limit?: number, _options?: Configuration): Promise<HttpInfo<PreReleaseVersionsWithoutIncludesResponse>> {
        const result = this.api.appsPreReleaseVersionsGetToManyRelatedWithHttpInfo(id, fieldsPreReleaseVersions, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsPreReleaseVersions the fields to include for returned resources of type preReleaseVersions
     * @param limit maximum resources per page
     */
    public appsPreReleaseVersionsGetToManyRelated(id: string, fieldsPreReleaseVersions?: Array<'app' | 'builds' | 'platform' | 'version'>, limit?: number, _options?: Configuration): Promise<PreReleaseVersionsWithoutIncludesResponse> {
        const result = this.api.appsPreReleaseVersionsGetToManyRelated(id, fieldsPreReleaseVersions, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterPriceTier filter by id(s) of related \&#39;priceTier\&#39;
     * @param filterTerritory filter by id(s) of related \&#39;territory\&#39;
     * @param fieldsAppPriceTiers the fields to include for returned resources of type appPriceTiers
     * @param fieldsAppPricePoints the fields to include for returned resources of type appPricePoints
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public appsPricePointsGetToManyRelatedWithHttpInfo(id: string, filterPriceTier?: Array<string>, filterTerritory?: Array<string>, fieldsAppPriceTiers?: Array<'pricePoints'>, fieldsAppPricePoints?: Array<'app' | 'customerPrice' | 'priceTier' | 'proceeds' | 'territory'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsTerritories?: Array<'currency'>, limit?: number, include?: Array<'app' | 'priceTier' | 'territory'>, _options?: Configuration): Promise<HttpInfo<AppPricePointsV2Response>> {
        const result = this.api.appsPricePointsGetToManyRelatedWithHttpInfo(id, filterPriceTier, filterTerritory, fieldsAppPriceTiers, fieldsAppPricePoints, fieldsApps, fieldsTerritories, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterPriceTier filter by id(s) of related \&#39;priceTier\&#39;
     * @param filterTerritory filter by id(s) of related \&#39;territory\&#39;
     * @param fieldsAppPriceTiers the fields to include for returned resources of type appPriceTiers
     * @param fieldsAppPricePoints the fields to include for returned resources of type appPricePoints
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public appsPricePointsGetToManyRelated(id: string, filterPriceTier?: Array<string>, filterTerritory?: Array<string>, fieldsAppPriceTiers?: Array<'pricePoints'>, fieldsAppPricePoints?: Array<'app' | 'customerPrice' | 'priceTier' | 'proceeds' | 'territory'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsTerritories?: Array<'currency'>, limit?: number, include?: Array<'app' | 'priceTier' | 'territory'>, _options?: Configuration): Promise<AppPricePointsV2Response> {
        const result = this.api.appsPricePointsGetToManyRelated(id, filterPriceTier, filterTerritory, fieldsAppPriceTiers, fieldsAppPricePoints, fieldsApps, fieldsTerritories, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppPriceTiers the fields to include for returned resources of type appPriceTiers
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsAppPrices the fields to include for returned resources of type appPrices
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public appsPricesGetToManyRelatedWithHttpInfo(id: string, fieldsAppPriceTiers?: Array<'pricePoints'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsAppPrices?: Array<'app' | 'priceTier'>, limit?: number, include?: Array<'app' | 'priceTier'>, _options?: Configuration): Promise<HttpInfo<AppPricesResponse>> {
        const result = this.api.appsPricesGetToManyRelatedWithHttpInfo(id, fieldsAppPriceTiers, fieldsApps, fieldsAppPrices, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppPriceTiers the fields to include for returned resources of type appPriceTiers
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsAppPrices the fields to include for returned resources of type appPrices
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public appsPricesGetToManyRelated(id: string, fieldsAppPriceTiers?: Array<'pricePoints'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsAppPrices?: Array<'app' | 'priceTier'>, limit?: number, include?: Array<'app' | 'priceTier'>, _options?: Configuration): Promise<AppPricesResponse> {
        const result = this.api.appsPricesGetToManyRelated(id, fieldsAppPriceTiers, fieldsApps, fieldsAppPrices, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsPromotedPurchases the fields to include for returned resources of type promotedPurchases
     * @param fieldsSubscriptions the fields to include for returned resources of type subscriptions
     * @param fieldsInAppPurchases the fields to include for returned resources of type inAppPurchases
     * @param fieldsPromotedPurchaseImages the fields to include for returned resources of type promotedPurchaseImages
     * @param limit maximum resources per page
     * @param limitPromotionImages maximum number of related promotionImages returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appsPromotedPurchasesGetToManyRelatedWithHttpInfo(id: string, fieldsPromotedPurchases?: Array<'app' | 'enabled' | 'inAppPurchaseV2' | 'promotionImages' | 'state' | 'subscription' | 'visibleForAllUsers'>, fieldsSubscriptions?: Array<'appStoreReviewScreenshot' | 'familySharable' | 'group' | 'groupLevel' | 'introductoryOffers' | 'name' | 'offerCodes' | 'pricePoints' | 'prices' | 'productId' | 'promotedPurchase' | 'promotionalOffers' | 'reviewNote' | 'state' | 'subscriptionAvailability' | 'subscriptionLocalizations' | 'subscriptionPeriod'>, fieldsInAppPurchases?: Array<'app' | 'appStoreReviewScreenshot' | 'content' | 'contentHosting' | 'familySharable' | 'iapPriceSchedule' | 'inAppPurchaseAvailability' | 'inAppPurchaseLocalizations' | 'inAppPurchaseType' | 'name' | 'pricePoints' | 'productId' | 'promotedPurchase' | 'reviewNote' | 'state'>, fieldsPromotedPurchaseImages?: Array<'assetToken' | 'assetType' | 'fileName' | 'fileSize' | 'imageAsset' | 'promotedPurchase' | 'sourceFileChecksum' | 'state' | 'uploadOperations' | 'uploaded'>, limit?: number, limitPromotionImages?: number, include?: Array<'inAppPurchaseV2' | 'promotionImages' | 'subscription'>, _options?: Configuration): Promise<HttpInfo<PromotedPurchasesResponse>> {
        const result = this.api.appsPromotedPurchasesGetToManyRelatedWithHttpInfo(id, fieldsPromotedPurchases, fieldsSubscriptions, fieldsInAppPurchases, fieldsPromotedPurchaseImages, limit, limitPromotionImages, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsPromotedPurchases the fields to include for returned resources of type promotedPurchases
     * @param fieldsSubscriptions the fields to include for returned resources of type subscriptions
     * @param fieldsInAppPurchases the fields to include for returned resources of type inAppPurchases
     * @param fieldsPromotedPurchaseImages the fields to include for returned resources of type promotedPurchaseImages
     * @param limit maximum resources per page
     * @param limitPromotionImages maximum number of related promotionImages returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appsPromotedPurchasesGetToManyRelated(id: string, fieldsPromotedPurchases?: Array<'app' | 'enabled' | 'inAppPurchaseV2' | 'promotionImages' | 'state' | 'subscription' | 'visibleForAllUsers'>, fieldsSubscriptions?: Array<'appStoreReviewScreenshot' | 'familySharable' | 'group' | 'groupLevel' | 'introductoryOffers' | 'name' | 'offerCodes' | 'pricePoints' | 'prices' | 'productId' | 'promotedPurchase' | 'promotionalOffers' | 'reviewNote' | 'state' | 'subscriptionAvailability' | 'subscriptionLocalizations' | 'subscriptionPeriod'>, fieldsInAppPurchases?: Array<'app' | 'appStoreReviewScreenshot' | 'content' | 'contentHosting' | 'familySharable' | 'iapPriceSchedule' | 'inAppPurchaseAvailability' | 'inAppPurchaseLocalizations' | 'inAppPurchaseType' | 'name' | 'pricePoints' | 'productId' | 'promotedPurchase' | 'reviewNote' | 'state'>, fieldsPromotedPurchaseImages?: Array<'assetToken' | 'assetType' | 'fileName' | 'fileSize' | 'imageAsset' | 'promotedPurchase' | 'sourceFileChecksum' | 'state' | 'uploadOperations' | 'uploaded'>, limit?: number, limitPromotionImages?: number, include?: Array<'inAppPurchaseV2' | 'promotionImages' | 'subscription'>, _options?: Configuration): Promise<PromotedPurchasesResponse> {
        const result = this.api.appsPromotedPurchasesGetToManyRelated(id, fieldsPromotedPurchases, fieldsSubscriptions, fieldsInAppPurchases, fieldsPromotedPurchaseImages, limit, limitPromotionImages, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public appsPromotedPurchasesGetToManyRelationshipWithHttpInfo(id: string, limit?: number, _options?: Configuration): Promise<HttpInfo<AppPromotedPurchasesLinkagesResponse>> {
        const result = this.api.appsPromotedPurchasesGetToManyRelationshipWithHttpInfo(id, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public appsPromotedPurchasesGetToManyRelationship(id: string, limit?: number, _options?: Configuration): Promise<AppPromotedPurchasesLinkagesResponse> {
        const result = this.api.appsPromotedPurchasesGetToManyRelationship(id, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param appPromotedPurchasesLinkagesRequest List of related linkages
     */
    public appsPromotedPurchasesReplaceToManyRelationshipWithHttpInfo(id: string, appPromotedPurchasesLinkagesRequest: AppPromotedPurchasesLinkagesRequest, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.appsPromotedPurchasesReplaceToManyRelationshipWithHttpInfo(id, appPromotedPurchasesLinkagesRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param appPromotedPurchasesLinkagesRequest List of related linkages
     */
    public appsPromotedPurchasesReplaceToManyRelationship(id: string, appPromotedPurchasesLinkagesRequest: AppPromotedPurchasesLinkagesRequest, _options?: Configuration): Promise<void> {
        const result = this.api.appsPromotedPurchasesReplaceToManyRelationship(id, appPromotedPurchasesLinkagesRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterPlatform filter by attribute \&#39;platform\&#39;
     * @param filterState filter by attribute \&#39;state\&#39;
     * @param fieldsReviewSubmissionItems the fields to include for returned resources of type reviewSubmissionItems
     * @param fieldsActors the fields to include for returned resources of type actors
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsReviewSubmissions the fields to include for returned resources of type reviewSubmissions
     * @param limit maximum resources per page
     * @param limitItems maximum number of related items returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appsReviewSubmissionsGetToManyRelatedWithHttpInfo(id: string, filterPlatform?: Array<'IOS' | 'MAC_OS' | 'TV_OS' | 'VISION_OS'>, filterState?: Array<'READY_FOR_REVIEW' | 'WAITING_FOR_REVIEW' | 'IN_REVIEW' | 'UNRESOLVED_ISSUES' | 'CANCELING' | 'COMPLETING' | 'COMPLETE'>, fieldsReviewSubmissionItems?: Array<'appCustomProductPageVersion' | 'appEvent' | 'appStoreVersion' | 'appStoreVersionExperiment' | 'appStoreVersionExperimentV2' | 'removed' | 'resolved' | 'reviewSubmission' | 'state'>, fieldsActors?: Array<'actorType' | 'apiKeyId' | 'userEmail' | 'userFirstName' | 'userLastName'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsReviewSubmissions?: Array<'app' | 'appStoreVersionForReview' | 'canceled' | 'items' | 'lastUpdatedByActor' | 'platform' | 'state' | 'submitted' | 'submittedByActor' | 'submittedDate'>, limit?: number, limitItems?: number, include?: Array<'app' | 'appStoreVersionForReview' | 'items' | 'lastUpdatedByActor' | 'submittedByActor'>, _options?: Configuration): Promise<HttpInfo<ReviewSubmissionsResponse>> {
        const result = this.api.appsReviewSubmissionsGetToManyRelatedWithHttpInfo(id, filterPlatform, filterState, fieldsReviewSubmissionItems, fieldsActors, fieldsAppStoreVersions, fieldsApps, fieldsReviewSubmissions, limit, limitItems, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterPlatform filter by attribute \&#39;platform\&#39;
     * @param filterState filter by attribute \&#39;state\&#39;
     * @param fieldsReviewSubmissionItems the fields to include for returned resources of type reviewSubmissionItems
     * @param fieldsActors the fields to include for returned resources of type actors
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsReviewSubmissions the fields to include for returned resources of type reviewSubmissions
     * @param limit maximum resources per page
     * @param limitItems maximum number of related items returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appsReviewSubmissionsGetToManyRelated(id: string, filterPlatform?: Array<'IOS' | 'MAC_OS' | 'TV_OS' | 'VISION_OS'>, filterState?: Array<'READY_FOR_REVIEW' | 'WAITING_FOR_REVIEW' | 'IN_REVIEW' | 'UNRESOLVED_ISSUES' | 'CANCELING' | 'COMPLETING' | 'COMPLETE'>, fieldsReviewSubmissionItems?: Array<'appCustomProductPageVersion' | 'appEvent' | 'appStoreVersion' | 'appStoreVersionExperiment' | 'appStoreVersionExperimentV2' | 'removed' | 'resolved' | 'reviewSubmission' | 'state'>, fieldsActors?: Array<'actorType' | 'apiKeyId' | 'userEmail' | 'userFirstName' | 'userLastName'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsReviewSubmissions?: Array<'app' | 'appStoreVersionForReview' | 'canceled' | 'items' | 'lastUpdatedByActor' | 'platform' | 'state' | 'submitted' | 'submittedByActor' | 'submittedDate'>, limit?: number, limitItems?: number, include?: Array<'app' | 'appStoreVersionForReview' | 'items' | 'lastUpdatedByActor' | 'submittedByActor'>, _options?: Configuration): Promise<ReviewSubmissionsResponse> {
        const result = this.api.appsReviewSubmissionsGetToManyRelated(id, filterPlatform, filterState, fieldsReviewSubmissionItems, fieldsActors, fieldsAppStoreVersions, fieldsApps, fieldsReviewSubmissions, limit, limitItems, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsSubscriptionGracePeriods the fields to include for returned resources of type subscriptionGracePeriods
     */
    public appsSubscriptionGracePeriodGetToOneRelatedWithHttpInfo(id: string, fieldsSubscriptionGracePeriods?: Array<'duration' | 'optIn' | 'renewalType' | 'sandboxOptIn'>, _options?: Configuration): Promise<HttpInfo<SubscriptionGracePeriodResponse>> {
        const result = this.api.appsSubscriptionGracePeriodGetToOneRelatedWithHttpInfo(id, fieldsSubscriptionGracePeriods, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsSubscriptionGracePeriods the fields to include for returned resources of type subscriptionGracePeriods
     */
    public appsSubscriptionGracePeriodGetToOneRelated(id: string, fieldsSubscriptionGracePeriods?: Array<'duration' | 'optIn' | 'renewalType' | 'sandboxOptIn'>, _options?: Configuration): Promise<SubscriptionGracePeriodResponse> {
        const result = this.api.appsSubscriptionGracePeriodGetToOneRelated(id, fieldsSubscriptionGracePeriods, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterReferenceName filter by attribute \&#39;referenceName\&#39;
     * @param filterSubscriptionsState filter by attribute \&#39;subscriptions.state\&#39;
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsSubscriptions the fields to include for returned resources of type subscriptions
     * @param fieldsSubscriptionGroups the fields to include for returned resources of type subscriptionGroups
     * @param fieldsSubscriptionGroupLocalizations the fields to include for returned resources of type subscriptionGroupLocalizations
     * @param limit maximum resources per page
     * @param limitSubscriptions maximum number of related subscriptions returned (when they are included)
     * @param limitSubscriptionGroupLocalizations maximum number of related subscriptionGroupLocalizations returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appsSubscriptionGroupsGetToManyRelatedWithHttpInfo(id: string, filterReferenceName?: Array<string>, filterSubscriptionsState?: Array<'MISSING_METADATA' | 'READY_TO_SUBMIT' | 'WAITING_FOR_REVIEW' | 'IN_REVIEW' | 'DEVELOPER_ACTION_NEEDED' | 'PENDING_BINARY_APPROVAL' | 'APPROVED' | 'DEVELOPER_REMOVED_FROM_SALE' | 'REMOVED_FROM_SALE' | 'REJECTED'>, sort?: Array<'referenceName' | '-referenceName'>, fieldsSubscriptions?: Array<'appStoreReviewScreenshot' | 'familySharable' | 'group' | 'groupLevel' | 'introductoryOffers' | 'name' | 'offerCodes' | 'pricePoints' | 'prices' | 'productId' | 'promotedPurchase' | 'promotionalOffers' | 'reviewNote' | 'state' | 'subscriptionAvailability' | 'subscriptionLocalizations' | 'subscriptionPeriod'>, fieldsSubscriptionGroups?: Array<'app' | 'referenceName' | 'subscriptionGroupLocalizations' | 'subscriptions'>, fieldsSubscriptionGroupLocalizations?: Array<'customAppName' | 'locale' | 'name' | 'state' | 'subscriptionGroup'>, limit?: number, limitSubscriptions?: number, limitSubscriptionGroupLocalizations?: number, include?: Array<'subscriptionGroupLocalizations' | 'subscriptions'>, _options?: Configuration): Promise<HttpInfo<SubscriptionGroupsResponse>> {
        const result = this.api.appsSubscriptionGroupsGetToManyRelatedWithHttpInfo(id, filterReferenceName, filterSubscriptionsState, sort, fieldsSubscriptions, fieldsSubscriptionGroups, fieldsSubscriptionGroupLocalizations, limit, limitSubscriptions, limitSubscriptionGroupLocalizations, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterReferenceName filter by attribute \&#39;referenceName\&#39;
     * @param filterSubscriptionsState filter by attribute \&#39;subscriptions.state\&#39;
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsSubscriptions the fields to include for returned resources of type subscriptions
     * @param fieldsSubscriptionGroups the fields to include for returned resources of type subscriptionGroups
     * @param fieldsSubscriptionGroupLocalizations the fields to include for returned resources of type subscriptionGroupLocalizations
     * @param limit maximum resources per page
     * @param limitSubscriptions maximum number of related subscriptions returned (when they are included)
     * @param limitSubscriptionGroupLocalizations maximum number of related subscriptionGroupLocalizations returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public appsSubscriptionGroupsGetToManyRelated(id: string, filterReferenceName?: Array<string>, filterSubscriptionsState?: Array<'MISSING_METADATA' | 'READY_TO_SUBMIT' | 'WAITING_FOR_REVIEW' | 'IN_REVIEW' | 'DEVELOPER_ACTION_NEEDED' | 'PENDING_BINARY_APPROVAL' | 'APPROVED' | 'DEVELOPER_REMOVED_FROM_SALE' | 'REMOVED_FROM_SALE' | 'REJECTED'>, sort?: Array<'referenceName' | '-referenceName'>, fieldsSubscriptions?: Array<'appStoreReviewScreenshot' | 'familySharable' | 'group' | 'groupLevel' | 'introductoryOffers' | 'name' | 'offerCodes' | 'pricePoints' | 'prices' | 'productId' | 'promotedPurchase' | 'promotionalOffers' | 'reviewNote' | 'state' | 'subscriptionAvailability' | 'subscriptionLocalizations' | 'subscriptionPeriod'>, fieldsSubscriptionGroups?: Array<'app' | 'referenceName' | 'subscriptionGroupLocalizations' | 'subscriptions'>, fieldsSubscriptionGroupLocalizations?: Array<'customAppName' | 'locale' | 'name' | 'state' | 'subscriptionGroup'>, limit?: number, limitSubscriptions?: number, limitSubscriptionGroupLocalizations?: number, include?: Array<'subscriptionGroupLocalizations' | 'subscriptions'>, _options?: Configuration): Promise<SubscriptionGroupsResponse> {
        const result = this.api.appsSubscriptionGroupsGetToManyRelated(id, filterReferenceName, filterSubscriptionsState, sort, fieldsSubscriptions, fieldsSubscriptionGroups, fieldsSubscriptionGroupLocalizations, limit, limitSubscriptions, limitSubscriptionGroupLocalizations, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param appUpdateRequest App representation
     */
    public appsUpdateInstanceWithHttpInfo(id: string, appUpdateRequest: AppUpdateRequest, _options?: Configuration): Promise<HttpInfo<AppResponse>> {
        const result = this.api.appsUpdateInstanceWithHttpInfo(id, appUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param appUpdateRequest App representation
     */
    public appsUpdateInstance(id: string, appUpdateRequest: AppUpdateRequest, _options?: Configuration): Promise<AppResponse> {
        const result = this.api.appsUpdateInstance(id, appUpdateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableBetaAppClipInvocationLocalizationsApi } from './ObservableAPI.ts';

import { BetaAppClipInvocationLocalizationsApiRequestFactory, BetaAppClipInvocationLocalizationsApiResponseProcessor} from "../apis/BetaAppClipInvocationLocalizationsApi.ts";
export class PromiseBetaAppClipInvocationLocalizationsApi {
    private api: ObservableBetaAppClipInvocationLocalizationsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: BetaAppClipInvocationLocalizationsApiRequestFactory,
        responseProcessor?: BetaAppClipInvocationLocalizationsApiResponseProcessor
    ) {
        this.api = new ObservableBetaAppClipInvocationLocalizationsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param betaAppClipInvocationLocalizationCreateRequest BetaAppClipInvocationLocalization representation
     */
    public betaAppClipInvocationLocalizationsCreateInstanceWithHttpInfo(betaAppClipInvocationLocalizationCreateRequest: BetaAppClipInvocationLocalizationCreateRequest, _options?: Configuration): Promise<HttpInfo<BetaAppClipInvocationLocalizationResponse>> {
        const result = this.api.betaAppClipInvocationLocalizationsCreateInstanceWithHttpInfo(betaAppClipInvocationLocalizationCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param betaAppClipInvocationLocalizationCreateRequest BetaAppClipInvocationLocalization representation
     */
    public betaAppClipInvocationLocalizationsCreateInstance(betaAppClipInvocationLocalizationCreateRequest: BetaAppClipInvocationLocalizationCreateRequest, _options?: Configuration): Promise<BetaAppClipInvocationLocalizationResponse> {
        const result = this.api.betaAppClipInvocationLocalizationsCreateInstance(betaAppClipInvocationLocalizationCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public betaAppClipInvocationLocalizationsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.betaAppClipInvocationLocalizationsDeleteInstanceWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public betaAppClipInvocationLocalizationsDeleteInstance(id: string, _options?: Configuration): Promise<void> {
        const result = this.api.betaAppClipInvocationLocalizationsDeleteInstance(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param betaAppClipInvocationLocalizationUpdateRequest BetaAppClipInvocationLocalization representation
     */
    public betaAppClipInvocationLocalizationsUpdateInstanceWithHttpInfo(id: string, betaAppClipInvocationLocalizationUpdateRequest: BetaAppClipInvocationLocalizationUpdateRequest, _options?: Configuration): Promise<HttpInfo<BetaAppClipInvocationLocalizationResponse>> {
        const result = this.api.betaAppClipInvocationLocalizationsUpdateInstanceWithHttpInfo(id, betaAppClipInvocationLocalizationUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param betaAppClipInvocationLocalizationUpdateRequest BetaAppClipInvocationLocalization representation
     */
    public betaAppClipInvocationLocalizationsUpdateInstance(id: string, betaAppClipInvocationLocalizationUpdateRequest: BetaAppClipInvocationLocalizationUpdateRequest, _options?: Configuration): Promise<BetaAppClipInvocationLocalizationResponse> {
        const result = this.api.betaAppClipInvocationLocalizationsUpdateInstance(id, betaAppClipInvocationLocalizationUpdateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableBetaAppClipInvocationsApi } from './ObservableAPI.ts';

import { BetaAppClipInvocationsApiRequestFactory, BetaAppClipInvocationsApiResponseProcessor} from "../apis/BetaAppClipInvocationsApi.ts";
export class PromiseBetaAppClipInvocationsApi {
    private api: ObservableBetaAppClipInvocationsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: BetaAppClipInvocationsApiRequestFactory,
        responseProcessor?: BetaAppClipInvocationsApiResponseProcessor
    ) {
        this.api = new ObservableBetaAppClipInvocationsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param betaAppClipInvocationCreateRequest BetaAppClipInvocation representation
     */
    public betaAppClipInvocationsCreateInstanceWithHttpInfo(betaAppClipInvocationCreateRequest: BetaAppClipInvocationCreateRequest, _options?: Configuration): Promise<HttpInfo<BetaAppClipInvocationResponse>> {
        const result = this.api.betaAppClipInvocationsCreateInstanceWithHttpInfo(betaAppClipInvocationCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param betaAppClipInvocationCreateRequest BetaAppClipInvocation representation
     */
    public betaAppClipInvocationsCreateInstance(betaAppClipInvocationCreateRequest: BetaAppClipInvocationCreateRequest, _options?: Configuration): Promise<BetaAppClipInvocationResponse> {
        const result = this.api.betaAppClipInvocationsCreateInstance(betaAppClipInvocationCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public betaAppClipInvocationsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.betaAppClipInvocationsDeleteInstanceWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public betaAppClipInvocationsDeleteInstance(id: string, _options?: Configuration): Promise<void> {
        const result = this.api.betaAppClipInvocationsDeleteInstance(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBetaAppClipInvocations the fields to include for returned resources of type betaAppClipInvocations
     * @param include comma-separated list of relationships to include
     * @param limitBetaAppClipInvocationLocalizations maximum number of related betaAppClipInvocationLocalizations returned (when they are included)
     */
    public betaAppClipInvocationsGetInstanceWithHttpInfo(id: string, fieldsBetaAppClipInvocations?: Array<'betaAppClipInvocationLocalizations' | 'buildBundle' | 'url'>, include?: Array<'betaAppClipInvocationLocalizations'>, limitBetaAppClipInvocationLocalizations?: number, _options?: Configuration): Promise<HttpInfo<BetaAppClipInvocationResponse>> {
        const result = this.api.betaAppClipInvocationsGetInstanceWithHttpInfo(id, fieldsBetaAppClipInvocations, include, limitBetaAppClipInvocationLocalizations, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBetaAppClipInvocations the fields to include for returned resources of type betaAppClipInvocations
     * @param include comma-separated list of relationships to include
     * @param limitBetaAppClipInvocationLocalizations maximum number of related betaAppClipInvocationLocalizations returned (when they are included)
     */
    public betaAppClipInvocationsGetInstance(id: string, fieldsBetaAppClipInvocations?: Array<'betaAppClipInvocationLocalizations' | 'buildBundle' | 'url'>, include?: Array<'betaAppClipInvocationLocalizations'>, limitBetaAppClipInvocationLocalizations?: number, _options?: Configuration): Promise<BetaAppClipInvocationResponse> {
        const result = this.api.betaAppClipInvocationsGetInstance(id, fieldsBetaAppClipInvocations, include, limitBetaAppClipInvocationLocalizations, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param betaAppClipInvocationUpdateRequest BetaAppClipInvocation representation
     */
    public betaAppClipInvocationsUpdateInstanceWithHttpInfo(id: string, betaAppClipInvocationUpdateRequest: BetaAppClipInvocationUpdateRequest, _options?: Configuration): Promise<HttpInfo<BetaAppClipInvocationResponse>> {
        const result = this.api.betaAppClipInvocationsUpdateInstanceWithHttpInfo(id, betaAppClipInvocationUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param betaAppClipInvocationUpdateRequest BetaAppClipInvocation representation
     */
    public betaAppClipInvocationsUpdateInstance(id: string, betaAppClipInvocationUpdateRequest: BetaAppClipInvocationUpdateRequest, _options?: Configuration): Promise<BetaAppClipInvocationResponse> {
        const result = this.api.betaAppClipInvocationsUpdateInstance(id, betaAppClipInvocationUpdateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableBetaAppLocalizationsApi } from './ObservableAPI.ts';

import { BetaAppLocalizationsApiRequestFactory, BetaAppLocalizationsApiResponseProcessor} from "../apis/BetaAppLocalizationsApi.ts";
export class PromiseBetaAppLocalizationsApi {
    private api: ObservableBetaAppLocalizationsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: BetaAppLocalizationsApiRequestFactory,
        responseProcessor?: BetaAppLocalizationsApiResponseProcessor
    ) {
        this.api = new ObservableBetaAppLocalizationsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsApps the fields to include for returned resources of type apps
     */
    public betaAppLocalizationsAppGetToOneRelatedWithHttpInfo(id: string, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, _options?: Configuration): Promise<HttpInfo<AppWithoutIncludesResponse>> {
        const result = this.api.betaAppLocalizationsAppGetToOneRelatedWithHttpInfo(id, fieldsApps, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsApps the fields to include for returned resources of type apps
     */
    public betaAppLocalizationsAppGetToOneRelated(id: string, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, _options?: Configuration): Promise<AppWithoutIncludesResponse> {
        const result = this.api.betaAppLocalizationsAppGetToOneRelated(id, fieldsApps, _options);
        return result.toPromise();
    }

    /**
     * @param betaAppLocalizationCreateRequest BetaAppLocalization representation
     */
    public betaAppLocalizationsCreateInstanceWithHttpInfo(betaAppLocalizationCreateRequest: BetaAppLocalizationCreateRequest, _options?: Configuration): Promise<HttpInfo<BetaAppLocalizationResponse>> {
        const result = this.api.betaAppLocalizationsCreateInstanceWithHttpInfo(betaAppLocalizationCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param betaAppLocalizationCreateRequest BetaAppLocalization representation
     */
    public betaAppLocalizationsCreateInstance(betaAppLocalizationCreateRequest: BetaAppLocalizationCreateRequest, _options?: Configuration): Promise<BetaAppLocalizationResponse> {
        const result = this.api.betaAppLocalizationsCreateInstance(betaAppLocalizationCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public betaAppLocalizationsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.betaAppLocalizationsDeleteInstanceWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public betaAppLocalizationsDeleteInstance(id: string, _options?: Configuration): Promise<void> {
        const result = this.api.betaAppLocalizationsDeleteInstance(id, _options);
        return result.toPromise();
    }

    /**
     * @param filterLocale filter by attribute \&#39;locale\&#39;
     * @param filterApp filter by id(s) of related \&#39;app\&#39;
     * @param fieldsBetaAppLocalizations the fields to include for returned resources of type betaAppLocalizations
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsApps the fields to include for returned resources of type apps
     */
    public betaAppLocalizationsGetCollectionWithHttpInfo(filterLocale?: Array<string>, filterApp?: Array<string>, fieldsBetaAppLocalizations?: Array<'app' | 'description' | 'feedbackEmail' | 'locale' | 'marketingUrl' | 'privacyPolicyUrl' | 'tvOsPrivacyPolicy'>, limit?: number, include?: Array<'app'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, _options?: Configuration): Promise<HttpInfo<BetaAppLocalizationsResponse>> {
        const result = this.api.betaAppLocalizationsGetCollectionWithHttpInfo(filterLocale, filterApp, fieldsBetaAppLocalizations, limit, include, fieldsApps, _options);
        return result.toPromise();
    }

    /**
     * @param filterLocale filter by attribute \&#39;locale\&#39;
     * @param filterApp filter by id(s) of related \&#39;app\&#39;
     * @param fieldsBetaAppLocalizations the fields to include for returned resources of type betaAppLocalizations
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsApps the fields to include for returned resources of type apps
     */
    public betaAppLocalizationsGetCollection(filterLocale?: Array<string>, filterApp?: Array<string>, fieldsBetaAppLocalizations?: Array<'app' | 'description' | 'feedbackEmail' | 'locale' | 'marketingUrl' | 'privacyPolicyUrl' | 'tvOsPrivacyPolicy'>, limit?: number, include?: Array<'app'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, _options?: Configuration): Promise<BetaAppLocalizationsResponse> {
        const result = this.api.betaAppLocalizationsGetCollection(filterLocale, filterApp, fieldsBetaAppLocalizations, limit, include, fieldsApps, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBetaAppLocalizations the fields to include for returned resources of type betaAppLocalizations
     * @param include comma-separated list of relationships to include
     * @param fieldsApps the fields to include for returned resources of type apps
     */
    public betaAppLocalizationsGetInstanceWithHttpInfo(id: string, fieldsBetaAppLocalizations?: Array<'app' | 'description' | 'feedbackEmail' | 'locale' | 'marketingUrl' | 'privacyPolicyUrl' | 'tvOsPrivacyPolicy'>, include?: Array<'app'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, _options?: Configuration): Promise<HttpInfo<BetaAppLocalizationResponse>> {
        const result = this.api.betaAppLocalizationsGetInstanceWithHttpInfo(id, fieldsBetaAppLocalizations, include, fieldsApps, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBetaAppLocalizations the fields to include for returned resources of type betaAppLocalizations
     * @param include comma-separated list of relationships to include
     * @param fieldsApps the fields to include for returned resources of type apps
     */
    public betaAppLocalizationsGetInstance(id: string, fieldsBetaAppLocalizations?: Array<'app' | 'description' | 'feedbackEmail' | 'locale' | 'marketingUrl' | 'privacyPolicyUrl' | 'tvOsPrivacyPolicy'>, include?: Array<'app'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, _options?: Configuration): Promise<BetaAppLocalizationResponse> {
        const result = this.api.betaAppLocalizationsGetInstance(id, fieldsBetaAppLocalizations, include, fieldsApps, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param betaAppLocalizationUpdateRequest BetaAppLocalization representation
     */
    public betaAppLocalizationsUpdateInstanceWithHttpInfo(id: string, betaAppLocalizationUpdateRequest: BetaAppLocalizationUpdateRequest, _options?: Configuration): Promise<HttpInfo<BetaAppLocalizationResponse>> {
        const result = this.api.betaAppLocalizationsUpdateInstanceWithHttpInfo(id, betaAppLocalizationUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param betaAppLocalizationUpdateRequest BetaAppLocalization representation
     */
    public betaAppLocalizationsUpdateInstance(id: string, betaAppLocalizationUpdateRequest: BetaAppLocalizationUpdateRequest, _options?: Configuration): Promise<BetaAppLocalizationResponse> {
        const result = this.api.betaAppLocalizationsUpdateInstance(id, betaAppLocalizationUpdateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableBetaAppReviewDetailsApi } from './ObservableAPI.ts';

import { BetaAppReviewDetailsApiRequestFactory, BetaAppReviewDetailsApiResponseProcessor} from "../apis/BetaAppReviewDetailsApi.ts";
export class PromiseBetaAppReviewDetailsApi {
    private api: ObservableBetaAppReviewDetailsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: BetaAppReviewDetailsApiRequestFactory,
        responseProcessor?: BetaAppReviewDetailsApiResponseProcessor
    ) {
        this.api = new ObservableBetaAppReviewDetailsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsApps the fields to include for returned resources of type apps
     */
    public betaAppReviewDetailsAppGetToOneRelatedWithHttpInfo(id: string, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, _options?: Configuration): Promise<HttpInfo<AppWithoutIncludesResponse>> {
        const result = this.api.betaAppReviewDetailsAppGetToOneRelatedWithHttpInfo(id, fieldsApps, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsApps the fields to include for returned resources of type apps
     */
    public betaAppReviewDetailsAppGetToOneRelated(id: string, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, _options?: Configuration): Promise<AppWithoutIncludesResponse> {
        const result = this.api.betaAppReviewDetailsAppGetToOneRelated(id, fieldsApps, _options);
        return result.toPromise();
    }

    /**
     * @param filterApp filter by id(s) of related \&#39;app\&#39;
     * @param fieldsBetaAppReviewDetails the fields to include for returned resources of type betaAppReviewDetails
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsApps the fields to include for returned resources of type apps
     */
    public betaAppReviewDetailsGetCollectionWithHttpInfo(filterApp: Array<string>, fieldsBetaAppReviewDetails?: Array<'app' | 'contactEmail' | 'contactFirstName' | 'contactLastName' | 'contactPhone' | 'demoAccountName' | 'demoAccountPassword' | 'demoAccountRequired' | 'notes'>, limit?: number, include?: Array<'app'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, _options?: Configuration): Promise<HttpInfo<BetaAppReviewDetailsResponse>> {
        const result = this.api.betaAppReviewDetailsGetCollectionWithHttpInfo(filterApp, fieldsBetaAppReviewDetails, limit, include, fieldsApps, _options);
        return result.toPromise();
    }

    /**
     * @param filterApp filter by id(s) of related \&#39;app\&#39;
     * @param fieldsBetaAppReviewDetails the fields to include for returned resources of type betaAppReviewDetails
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsApps the fields to include for returned resources of type apps
     */
    public betaAppReviewDetailsGetCollection(filterApp: Array<string>, fieldsBetaAppReviewDetails?: Array<'app' | 'contactEmail' | 'contactFirstName' | 'contactLastName' | 'contactPhone' | 'demoAccountName' | 'demoAccountPassword' | 'demoAccountRequired' | 'notes'>, limit?: number, include?: Array<'app'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, _options?: Configuration): Promise<BetaAppReviewDetailsResponse> {
        const result = this.api.betaAppReviewDetailsGetCollection(filterApp, fieldsBetaAppReviewDetails, limit, include, fieldsApps, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBetaAppReviewDetails the fields to include for returned resources of type betaAppReviewDetails
     * @param include comma-separated list of relationships to include
     * @param fieldsApps the fields to include for returned resources of type apps
     */
    public betaAppReviewDetailsGetInstanceWithHttpInfo(id: string, fieldsBetaAppReviewDetails?: Array<'app' | 'contactEmail' | 'contactFirstName' | 'contactLastName' | 'contactPhone' | 'demoAccountName' | 'demoAccountPassword' | 'demoAccountRequired' | 'notes'>, include?: Array<'app'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, _options?: Configuration): Promise<HttpInfo<BetaAppReviewDetailResponse>> {
        const result = this.api.betaAppReviewDetailsGetInstanceWithHttpInfo(id, fieldsBetaAppReviewDetails, include, fieldsApps, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBetaAppReviewDetails the fields to include for returned resources of type betaAppReviewDetails
     * @param include comma-separated list of relationships to include
     * @param fieldsApps the fields to include for returned resources of type apps
     */
    public betaAppReviewDetailsGetInstance(id: string, fieldsBetaAppReviewDetails?: Array<'app' | 'contactEmail' | 'contactFirstName' | 'contactLastName' | 'contactPhone' | 'demoAccountName' | 'demoAccountPassword' | 'demoAccountRequired' | 'notes'>, include?: Array<'app'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, _options?: Configuration): Promise<BetaAppReviewDetailResponse> {
        const result = this.api.betaAppReviewDetailsGetInstance(id, fieldsBetaAppReviewDetails, include, fieldsApps, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param betaAppReviewDetailUpdateRequest BetaAppReviewDetail representation
     */
    public betaAppReviewDetailsUpdateInstanceWithHttpInfo(id: string, betaAppReviewDetailUpdateRequest: BetaAppReviewDetailUpdateRequest, _options?: Configuration): Promise<HttpInfo<BetaAppReviewDetailResponse>> {
        const result = this.api.betaAppReviewDetailsUpdateInstanceWithHttpInfo(id, betaAppReviewDetailUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param betaAppReviewDetailUpdateRequest BetaAppReviewDetail representation
     */
    public betaAppReviewDetailsUpdateInstance(id: string, betaAppReviewDetailUpdateRequest: BetaAppReviewDetailUpdateRequest, _options?: Configuration): Promise<BetaAppReviewDetailResponse> {
        const result = this.api.betaAppReviewDetailsUpdateInstance(id, betaAppReviewDetailUpdateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableBetaAppReviewSubmissionsApi } from './ObservableAPI.ts';

import { BetaAppReviewSubmissionsApiRequestFactory, BetaAppReviewSubmissionsApiResponseProcessor} from "../apis/BetaAppReviewSubmissionsApi.ts";
export class PromiseBetaAppReviewSubmissionsApi {
    private api: ObservableBetaAppReviewSubmissionsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: BetaAppReviewSubmissionsApiRequestFactory,
        responseProcessor?: BetaAppReviewSubmissionsApiResponseProcessor
    ) {
        this.api = new ObservableBetaAppReviewSubmissionsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBuilds the fields to include for returned resources of type builds
     */
    public betaAppReviewSubmissionsBuildGetToOneRelatedWithHttpInfo(id: string, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, _options?: Configuration): Promise<HttpInfo<BuildWithoutIncludesResponse>> {
        const result = this.api.betaAppReviewSubmissionsBuildGetToOneRelatedWithHttpInfo(id, fieldsBuilds, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBuilds the fields to include for returned resources of type builds
     */
    public betaAppReviewSubmissionsBuildGetToOneRelated(id: string, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, _options?: Configuration): Promise<BuildWithoutIncludesResponse> {
        const result = this.api.betaAppReviewSubmissionsBuildGetToOneRelated(id, fieldsBuilds, _options);
        return result.toPromise();
    }

    /**
     * @param betaAppReviewSubmissionCreateRequest BetaAppReviewSubmission representation
     */
    public betaAppReviewSubmissionsCreateInstanceWithHttpInfo(betaAppReviewSubmissionCreateRequest: BetaAppReviewSubmissionCreateRequest, _options?: Configuration): Promise<HttpInfo<BetaAppReviewSubmissionResponse>> {
        const result = this.api.betaAppReviewSubmissionsCreateInstanceWithHttpInfo(betaAppReviewSubmissionCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param betaAppReviewSubmissionCreateRequest BetaAppReviewSubmission representation
     */
    public betaAppReviewSubmissionsCreateInstance(betaAppReviewSubmissionCreateRequest: BetaAppReviewSubmissionCreateRequest, _options?: Configuration): Promise<BetaAppReviewSubmissionResponse> {
        const result = this.api.betaAppReviewSubmissionsCreateInstance(betaAppReviewSubmissionCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param filterBuild filter by id(s) of related \&#39;build\&#39;
     * @param filterBetaReviewState filter by attribute \&#39;betaReviewState\&#39;
     * @param fieldsBetaAppReviewSubmissions the fields to include for returned resources of type betaAppReviewSubmissions
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsBuilds the fields to include for returned resources of type builds
     */
    public betaAppReviewSubmissionsGetCollectionWithHttpInfo(filterBuild: Array<string>, filterBetaReviewState?: Array<'WAITING_FOR_REVIEW' | 'IN_REVIEW' | 'REJECTED' | 'APPROVED'>, fieldsBetaAppReviewSubmissions?: Array<'betaReviewState' | 'build' | 'submittedDate'>, limit?: number, include?: Array<'build'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, _options?: Configuration): Promise<HttpInfo<BetaAppReviewSubmissionsResponse>> {
        const result = this.api.betaAppReviewSubmissionsGetCollectionWithHttpInfo(filterBuild, filterBetaReviewState, fieldsBetaAppReviewSubmissions, limit, include, fieldsBuilds, _options);
        return result.toPromise();
    }

    /**
     * @param filterBuild filter by id(s) of related \&#39;build\&#39;
     * @param filterBetaReviewState filter by attribute \&#39;betaReviewState\&#39;
     * @param fieldsBetaAppReviewSubmissions the fields to include for returned resources of type betaAppReviewSubmissions
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsBuilds the fields to include for returned resources of type builds
     */
    public betaAppReviewSubmissionsGetCollection(filterBuild: Array<string>, filterBetaReviewState?: Array<'WAITING_FOR_REVIEW' | 'IN_REVIEW' | 'REJECTED' | 'APPROVED'>, fieldsBetaAppReviewSubmissions?: Array<'betaReviewState' | 'build' | 'submittedDate'>, limit?: number, include?: Array<'build'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, _options?: Configuration): Promise<BetaAppReviewSubmissionsResponse> {
        const result = this.api.betaAppReviewSubmissionsGetCollection(filterBuild, filterBetaReviewState, fieldsBetaAppReviewSubmissions, limit, include, fieldsBuilds, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBetaAppReviewSubmissions the fields to include for returned resources of type betaAppReviewSubmissions
     * @param include comma-separated list of relationships to include
     * @param fieldsBuilds the fields to include for returned resources of type builds
     */
    public betaAppReviewSubmissionsGetInstanceWithHttpInfo(id: string, fieldsBetaAppReviewSubmissions?: Array<'betaReviewState' | 'build' | 'submittedDate'>, include?: Array<'build'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, _options?: Configuration): Promise<HttpInfo<BetaAppReviewSubmissionResponse>> {
        const result = this.api.betaAppReviewSubmissionsGetInstanceWithHttpInfo(id, fieldsBetaAppReviewSubmissions, include, fieldsBuilds, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBetaAppReviewSubmissions the fields to include for returned resources of type betaAppReviewSubmissions
     * @param include comma-separated list of relationships to include
     * @param fieldsBuilds the fields to include for returned resources of type builds
     */
    public betaAppReviewSubmissionsGetInstance(id: string, fieldsBetaAppReviewSubmissions?: Array<'betaReviewState' | 'build' | 'submittedDate'>, include?: Array<'build'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, _options?: Configuration): Promise<BetaAppReviewSubmissionResponse> {
        const result = this.api.betaAppReviewSubmissionsGetInstance(id, fieldsBetaAppReviewSubmissions, include, fieldsBuilds, _options);
        return result.toPromise();
    }


}



import { ObservableBetaBuildLocalizationsApi } from './ObservableAPI.ts';

import { BetaBuildLocalizationsApiRequestFactory, BetaBuildLocalizationsApiResponseProcessor} from "../apis/BetaBuildLocalizationsApi.ts";
export class PromiseBetaBuildLocalizationsApi {
    private api: ObservableBetaBuildLocalizationsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: BetaBuildLocalizationsApiRequestFactory,
        responseProcessor?: BetaBuildLocalizationsApiResponseProcessor
    ) {
        this.api = new ObservableBetaBuildLocalizationsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBuilds the fields to include for returned resources of type builds
     */
    public betaBuildLocalizationsBuildGetToOneRelatedWithHttpInfo(id: string, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, _options?: Configuration): Promise<HttpInfo<BuildWithoutIncludesResponse>> {
        const result = this.api.betaBuildLocalizationsBuildGetToOneRelatedWithHttpInfo(id, fieldsBuilds, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBuilds the fields to include for returned resources of type builds
     */
    public betaBuildLocalizationsBuildGetToOneRelated(id: string, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, _options?: Configuration): Promise<BuildWithoutIncludesResponse> {
        const result = this.api.betaBuildLocalizationsBuildGetToOneRelated(id, fieldsBuilds, _options);
        return result.toPromise();
    }

    /**
     * @param betaBuildLocalizationCreateRequest BetaBuildLocalization representation
     */
    public betaBuildLocalizationsCreateInstanceWithHttpInfo(betaBuildLocalizationCreateRequest: BetaBuildLocalizationCreateRequest, _options?: Configuration): Promise<HttpInfo<BetaBuildLocalizationResponse>> {
        const result = this.api.betaBuildLocalizationsCreateInstanceWithHttpInfo(betaBuildLocalizationCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param betaBuildLocalizationCreateRequest BetaBuildLocalization representation
     */
    public betaBuildLocalizationsCreateInstance(betaBuildLocalizationCreateRequest: BetaBuildLocalizationCreateRequest, _options?: Configuration): Promise<BetaBuildLocalizationResponse> {
        const result = this.api.betaBuildLocalizationsCreateInstance(betaBuildLocalizationCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public betaBuildLocalizationsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.betaBuildLocalizationsDeleteInstanceWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public betaBuildLocalizationsDeleteInstance(id: string, _options?: Configuration): Promise<void> {
        const result = this.api.betaBuildLocalizationsDeleteInstance(id, _options);
        return result.toPromise();
    }

    /**
     * @param filterLocale filter by attribute \&#39;locale\&#39;
     * @param filterBuild filter by id(s) of related \&#39;build\&#39;
     * @param fieldsBetaBuildLocalizations the fields to include for returned resources of type betaBuildLocalizations
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsBuilds the fields to include for returned resources of type builds
     */
    public betaBuildLocalizationsGetCollectionWithHttpInfo(filterLocale?: Array<string>, filterBuild?: Array<string>, fieldsBetaBuildLocalizations?: Array<'build' | 'locale' | 'whatsNew'>, limit?: number, include?: Array<'build'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, _options?: Configuration): Promise<HttpInfo<BetaBuildLocalizationsResponse>> {
        const result = this.api.betaBuildLocalizationsGetCollectionWithHttpInfo(filterLocale, filterBuild, fieldsBetaBuildLocalizations, limit, include, fieldsBuilds, _options);
        return result.toPromise();
    }

    /**
     * @param filterLocale filter by attribute \&#39;locale\&#39;
     * @param filterBuild filter by id(s) of related \&#39;build\&#39;
     * @param fieldsBetaBuildLocalizations the fields to include for returned resources of type betaBuildLocalizations
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsBuilds the fields to include for returned resources of type builds
     */
    public betaBuildLocalizationsGetCollection(filterLocale?: Array<string>, filterBuild?: Array<string>, fieldsBetaBuildLocalizations?: Array<'build' | 'locale' | 'whatsNew'>, limit?: number, include?: Array<'build'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, _options?: Configuration): Promise<BetaBuildLocalizationsResponse> {
        const result = this.api.betaBuildLocalizationsGetCollection(filterLocale, filterBuild, fieldsBetaBuildLocalizations, limit, include, fieldsBuilds, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBetaBuildLocalizations the fields to include for returned resources of type betaBuildLocalizations
     * @param include comma-separated list of relationships to include
     * @param fieldsBuilds the fields to include for returned resources of type builds
     */
    public betaBuildLocalizationsGetInstanceWithHttpInfo(id: string, fieldsBetaBuildLocalizations?: Array<'build' | 'locale' | 'whatsNew'>, include?: Array<'build'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, _options?: Configuration): Promise<HttpInfo<BetaBuildLocalizationResponse>> {
        const result = this.api.betaBuildLocalizationsGetInstanceWithHttpInfo(id, fieldsBetaBuildLocalizations, include, fieldsBuilds, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBetaBuildLocalizations the fields to include for returned resources of type betaBuildLocalizations
     * @param include comma-separated list of relationships to include
     * @param fieldsBuilds the fields to include for returned resources of type builds
     */
    public betaBuildLocalizationsGetInstance(id: string, fieldsBetaBuildLocalizations?: Array<'build' | 'locale' | 'whatsNew'>, include?: Array<'build'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, _options?: Configuration): Promise<BetaBuildLocalizationResponse> {
        const result = this.api.betaBuildLocalizationsGetInstance(id, fieldsBetaBuildLocalizations, include, fieldsBuilds, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param betaBuildLocalizationUpdateRequest BetaBuildLocalization representation
     */
    public betaBuildLocalizationsUpdateInstanceWithHttpInfo(id: string, betaBuildLocalizationUpdateRequest: BetaBuildLocalizationUpdateRequest, _options?: Configuration): Promise<HttpInfo<BetaBuildLocalizationResponse>> {
        const result = this.api.betaBuildLocalizationsUpdateInstanceWithHttpInfo(id, betaBuildLocalizationUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param betaBuildLocalizationUpdateRequest BetaBuildLocalization representation
     */
    public betaBuildLocalizationsUpdateInstance(id: string, betaBuildLocalizationUpdateRequest: BetaBuildLocalizationUpdateRequest, _options?: Configuration): Promise<BetaBuildLocalizationResponse> {
        const result = this.api.betaBuildLocalizationsUpdateInstance(id, betaBuildLocalizationUpdateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableBetaGroupsApi } from './ObservableAPI.ts';

import { BetaGroupsApiRequestFactory, BetaGroupsApiResponseProcessor} from "../apis/BetaGroupsApi.ts";
export class PromiseBetaGroupsApi {
    private api: ObservableBetaGroupsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: BetaGroupsApiRequestFactory,
        responseProcessor?: BetaGroupsApiResponseProcessor
    ) {
        this.api = new ObservableBetaGroupsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsApps the fields to include for returned resources of type apps
     */
    public betaGroupsAppGetToOneRelatedWithHttpInfo(id: string, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, _options?: Configuration): Promise<HttpInfo<AppWithoutIncludesResponse>> {
        const result = this.api.betaGroupsAppGetToOneRelatedWithHttpInfo(id, fieldsApps, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsApps the fields to include for returned resources of type apps
     */
    public betaGroupsAppGetToOneRelated(id: string, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, _options?: Configuration): Promise<AppWithoutIncludesResponse> {
        const result = this.api.betaGroupsAppGetToOneRelated(id, fieldsApps, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum number of groups to return per page
     * @param groupBy the dimension by which to group the results
     * @param filterBetaTesters filter by \&#39;betaTesters\&#39; relationship dimension
     * @param period the duration of the reporting period
     */
    public betaGroupsBetaTesterUsagesGetMetricsWithHttpInfo(id: string, limit?: number, groupBy?: Array<'betaTesters'>, filterBetaTesters?: string, period?: 'P7D' | 'P30D' | 'P90D' | 'P365D', _options?: Configuration): Promise<HttpInfo<AppsBetaTesterUsagesV1MetricResponse>> {
        const result = this.api.betaGroupsBetaTesterUsagesGetMetricsWithHttpInfo(id, limit, groupBy, filterBetaTesters, period, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum number of groups to return per page
     * @param groupBy the dimension by which to group the results
     * @param filterBetaTesters filter by \&#39;betaTesters\&#39; relationship dimension
     * @param period the duration of the reporting period
     */
    public betaGroupsBetaTesterUsagesGetMetrics(id: string, limit?: number, groupBy?: Array<'betaTesters'>, filterBetaTesters?: string, period?: 'P7D' | 'P30D' | 'P90D' | 'P365D', _options?: Configuration): Promise<AppsBetaTesterUsagesV1MetricResponse> {
        const result = this.api.betaGroupsBetaTesterUsagesGetMetrics(id, limit, groupBy, filterBetaTesters, period, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param betaGroupBetaTestersLinkagesRequest List of related linkages
     */
    public betaGroupsBetaTestersCreateToManyRelationshipWithHttpInfo(id: string, betaGroupBetaTestersLinkagesRequest: BetaGroupBetaTestersLinkagesRequest, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.betaGroupsBetaTestersCreateToManyRelationshipWithHttpInfo(id, betaGroupBetaTestersLinkagesRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param betaGroupBetaTestersLinkagesRequest List of related linkages
     */
    public betaGroupsBetaTestersCreateToManyRelationship(id: string, betaGroupBetaTestersLinkagesRequest: BetaGroupBetaTestersLinkagesRequest, _options?: Configuration): Promise<void> {
        const result = this.api.betaGroupsBetaTestersCreateToManyRelationship(id, betaGroupBetaTestersLinkagesRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param betaGroupBetaTestersLinkagesRequest List of related linkages
     */
    public betaGroupsBetaTestersDeleteToManyRelationshipWithHttpInfo(id: string, betaGroupBetaTestersLinkagesRequest: BetaGroupBetaTestersLinkagesRequest, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.betaGroupsBetaTestersDeleteToManyRelationshipWithHttpInfo(id, betaGroupBetaTestersLinkagesRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param betaGroupBetaTestersLinkagesRequest List of related linkages
     */
    public betaGroupsBetaTestersDeleteToManyRelationship(id: string, betaGroupBetaTestersLinkagesRequest: BetaGroupBetaTestersLinkagesRequest, _options?: Configuration): Promise<void> {
        const result = this.api.betaGroupsBetaTestersDeleteToManyRelationship(id, betaGroupBetaTestersLinkagesRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBetaTesters the fields to include for returned resources of type betaTesters
     * @param limit maximum resources per page
     */
    public betaGroupsBetaTestersGetToManyRelatedWithHttpInfo(id: string, fieldsBetaTesters?: Array<'apps' | 'betaGroups' | 'builds' | 'email' | 'firstName' | 'inviteType' | 'lastName'>, limit?: number, _options?: Configuration): Promise<HttpInfo<BetaTestersWithoutIncludesResponse>> {
        const result = this.api.betaGroupsBetaTestersGetToManyRelatedWithHttpInfo(id, fieldsBetaTesters, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBetaTesters the fields to include for returned resources of type betaTesters
     * @param limit maximum resources per page
     */
    public betaGroupsBetaTestersGetToManyRelated(id: string, fieldsBetaTesters?: Array<'apps' | 'betaGroups' | 'builds' | 'email' | 'firstName' | 'inviteType' | 'lastName'>, limit?: number, _options?: Configuration): Promise<BetaTestersWithoutIncludesResponse> {
        const result = this.api.betaGroupsBetaTestersGetToManyRelated(id, fieldsBetaTesters, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public betaGroupsBetaTestersGetToManyRelationshipWithHttpInfo(id: string, limit?: number, _options?: Configuration): Promise<HttpInfo<BetaGroupBetaTestersLinkagesResponse>> {
        const result = this.api.betaGroupsBetaTestersGetToManyRelationshipWithHttpInfo(id, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public betaGroupsBetaTestersGetToManyRelationship(id: string, limit?: number, _options?: Configuration): Promise<BetaGroupBetaTestersLinkagesResponse> {
        const result = this.api.betaGroupsBetaTestersGetToManyRelationship(id, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param betaGroupBuildsLinkagesRequest List of related linkages
     */
    public betaGroupsBuildsCreateToManyRelationshipWithHttpInfo(id: string, betaGroupBuildsLinkagesRequest: BetaGroupBuildsLinkagesRequest, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.betaGroupsBuildsCreateToManyRelationshipWithHttpInfo(id, betaGroupBuildsLinkagesRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param betaGroupBuildsLinkagesRequest List of related linkages
     */
    public betaGroupsBuildsCreateToManyRelationship(id: string, betaGroupBuildsLinkagesRequest: BetaGroupBuildsLinkagesRequest, _options?: Configuration): Promise<void> {
        const result = this.api.betaGroupsBuildsCreateToManyRelationship(id, betaGroupBuildsLinkagesRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param betaGroupBuildsLinkagesRequest List of related linkages
     */
    public betaGroupsBuildsDeleteToManyRelationshipWithHttpInfo(id: string, betaGroupBuildsLinkagesRequest: BetaGroupBuildsLinkagesRequest, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.betaGroupsBuildsDeleteToManyRelationshipWithHttpInfo(id, betaGroupBuildsLinkagesRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param betaGroupBuildsLinkagesRequest List of related linkages
     */
    public betaGroupsBuildsDeleteToManyRelationship(id: string, betaGroupBuildsLinkagesRequest: BetaGroupBuildsLinkagesRequest, _options?: Configuration): Promise<void> {
        const result = this.api.betaGroupsBuildsDeleteToManyRelationship(id, betaGroupBuildsLinkagesRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param limit maximum resources per page
     */
    public betaGroupsBuildsGetToManyRelatedWithHttpInfo(id: string, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, limit?: number, _options?: Configuration): Promise<HttpInfo<BuildsWithoutIncludesResponse>> {
        const result = this.api.betaGroupsBuildsGetToManyRelatedWithHttpInfo(id, fieldsBuilds, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param limit maximum resources per page
     */
    public betaGroupsBuildsGetToManyRelated(id: string, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, limit?: number, _options?: Configuration): Promise<BuildsWithoutIncludesResponse> {
        const result = this.api.betaGroupsBuildsGetToManyRelated(id, fieldsBuilds, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public betaGroupsBuildsGetToManyRelationshipWithHttpInfo(id: string, limit?: number, _options?: Configuration): Promise<HttpInfo<BetaGroupBuildsLinkagesResponse>> {
        const result = this.api.betaGroupsBuildsGetToManyRelationshipWithHttpInfo(id, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public betaGroupsBuildsGetToManyRelationship(id: string, limit?: number, _options?: Configuration): Promise<BetaGroupBuildsLinkagesResponse> {
        const result = this.api.betaGroupsBuildsGetToManyRelationship(id, limit, _options);
        return result.toPromise();
    }

    /**
     * @param betaGroupCreateRequest BetaGroup representation
     */
    public betaGroupsCreateInstanceWithHttpInfo(betaGroupCreateRequest: BetaGroupCreateRequest, _options?: Configuration): Promise<HttpInfo<BetaGroupResponse>> {
        const result = this.api.betaGroupsCreateInstanceWithHttpInfo(betaGroupCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param betaGroupCreateRequest BetaGroup representation
     */
    public betaGroupsCreateInstance(betaGroupCreateRequest: BetaGroupCreateRequest, _options?: Configuration): Promise<BetaGroupResponse> {
        const result = this.api.betaGroupsCreateInstance(betaGroupCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public betaGroupsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.betaGroupsDeleteInstanceWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public betaGroupsDeleteInstance(id: string, _options?: Configuration): Promise<void> {
        const result = this.api.betaGroupsDeleteInstance(id, _options);
        return result.toPromise();
    }

    /**
     * @param filterIsInternalGroup filter by attribute \&#39;isInternalGroup\&#39;
     * @param filterName filter by attribute \&#39;name\&#39;
     * @param filterPublicLink filter by attribute \&#39;publicLink\&#39;
     * @param filterPublicLinkEnabled filter by attribute \&#39;publicLinkEnabled\&#39;
     * @param filterPublicLinkLimitEnabled filter by attribute \&#39;publicLinkLimitEnabled\&#39;
     * @param filterApp filter by id(s) of related \&#39;app\&#39;
     * @param filterBuilds filter by id(s) of related \&#39;builds\&#39;
     * @param filterId filter by id(s)
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsBetaGroups the fields to include for returned resources of type betaGroups
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsBetaTesters the fields to include for returned resources of type betaTesters
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param limitBetaTesters maximum number of related betaTesters returned (when they are included)
     * @param limitBuilds maximum number of related builds returned (when they are included)
     */
    public betaGroupsGetCollectionWithHttpInfo(filterIsInternalGroup?: Array<string>, filterName?: Array<string>, filterPublicLink?: Array<string>, filterPublicLinkEnabled?: Array<string>, filterPublicLinkLimitEnabled?: Array<string>, filterApp?: Array<string>, filterBuilds?: Array<string>, filterId?: Array<string>, sort?: Array<'createdDate' | '-createdDate' | 'name' | '-name' | 'publicLinkEnabled' | '-publicLinkEnabled' | 'publicLinkLimit' | '-publicLinkLimit'>, fieldsBetaGroups?: Array<'app' | 'betaTesters' | 'builds' | 'createdDate' | 'feedbackEnabled' | 'hasAccessToAllBuilds' | 'iosBuildsAvailableForAppleSiliconMac' | 'isInternalGroup' | 'name' | 'publicLink' | 'publicLinkEnabled' | 'publicLinkId' | 'publicLinkLimit' | 'publicLinkLimitEnabled'>, limit?: number, include?: Array<'app' | 'betaTesters' | 'builds'>, fieldsBetaTesters?: Array<'apps' | 'betaGroups' | 'builds' | 'email' | 'firstName' | 'inviteType' | 'lastName'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, limitBetaTesters?: number, limitBuilds?: number, _options?: Configuration): Promise<HttpInfo<BetaGroupsResponse>> {
        const result = this.api.betaGroupsGetCollectionWithHttpInfo(filterIsInternalGroup, filterName, filterPublicLink, filterPublicLinkEnabled, filterPublicLinkLimitEnabled, filterApp, filterBuilds, filterId, sort, fieldsBetaGroups, limit, include, fieldsBetaTesters, fieldsApps, fieldsBuilds, limitBetaTesters, limitBuilds, _options);
        return result.toPromise();
    }

    /**
     * @param filterIsInternalGroup filter by attribute \&#39;isInternalGroup\&#39;
     * @param filterName filter by attribute \&#39;name\&#39;
     * @param filterPublicLink filter by attribute \&#39;publicLink\&#39;
     * @param filterPublicLinkEnabled filter by attribute \&#39;publicLinkEnabled\&#39;
     * @param filterPublicLinkLimitEnabled filter by attribute \&#39;publicLinkLimitEnabled\&#39;
     * @param filterApp filter by id(s) of related \&#39;app\&#39;
     * @param filterBuilds filter by id(s) of related \&#39;builds\&#39;
     * @param filterId filter by id(s)
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsBetaGroups the fields to include for returned resources of type betaGroups
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsBetaTesters the fields to include for returned resources of type betaTesters
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param limitBetaTesters maximum number of related betaTesters returned (when they are included)
     * @param limitBuilds maximum number of related builds returned (when they are included)
     */
    public betaGroupsGetCollection(filterIsInternalGroup?: Array<string>, filterName?: Array<string>, filterPublicLink?: Array<string>, filterPublicLinkEnabled?: Array<string>, filterPublicLinkLimitEnabled?: Array<string>, filterApp?: Array<string>, filterBuilds?: Array<string>, filterId?: Array<string>, sort?: Array<'createdDate' | '-createdDate' | 'name' | '-name' | 'publicLinkEnabled' | '-publicLinkEnabled' | 'publicLinkLimit' | '-publicLinkLimit'>, fieldsBetaGroups?: Array<'app' | 'betaTesters' | 'builds' | 'createdDate' | 'feedbackEnabled' | 'hasAccessToAllBuilds' | 'iosBuildsAvailableForAppleSiliconMac' | 'isInternalGroup' | 'name' | 'publicLink' | 'publicLinkEnabled' | 'publicLinkId' | 'publicLinkLimit' | 'publicLinkLimitEnabled'>, limit?: number, include?: Array<'app' | 'betaTesters' | 'builds'>, fieldsBetaTesters?: Array<'apps' | 'betaGroups' | 'builds' | 'email' | 'firstName' | 'inviteType' | 'lastName'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, limitBetaTesters?: number, limitBuilds?: number, _options?: Configuration): Promise<BetaGroupsResponse> {
        const result = this.api.betaGroupsGetCollection(filterIsInternalGroup, filterName, filterPublicLink, filterPublicLinkEnabled, filterPublicLinkLimitEnabled, filterApp, filterBuilds, filterId, sort, fieldsBetaGroups, limit, include, fieldsBetaTesters, fieldsApps, fieldsBuilds, limitBetaTesters, limitBuilds, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBetaGroups the fields to include for returned resources of type betaGroups
     * @param include comma-separated list of relationships to include
     * @param fieldsBetaTesters the fields to include for returned resources of type betaTesters
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param limitBetaTesters maximum number of related betaTesters returned (when they are included)
     * @param limitBuilds maximum number of related builds returned (when they are included)
     */
    public betaGroupsGetInstanceWithHttpInfo(id: string, fieldsBetaGroups?: Array<'app' | 'betaTesters' | 'builds' | 'createdDate' | 'feedbackEnabled' | 'hasAccessToAllBuilds' | 'iosBuildsAvailableForAppleSiliconMac' | 'isInternalGroup' | 'name' | 'publicLink' | 'publicLinkEnabled' | 'publicLinkId' | 'publicLinkLimit' | 'publicLinkLimitEnabled'>, include?: Array<'app' | 'betaTesters' | 'builds'>, fieldsBetaTesters?: Array<'apps' | 'betaGroups' | 'builds' | 'email' | 'firstName' | 'inviteType' | 'lastName'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, limitBetaTesters?: number, limitBuilds?: number, _options?: Configuration): Promise<HttpInfo<BetaGroupResponse>> {
        const result = this.api.betaGroupsGetInstanceWithHttpInfo(id, fieldsBetaGroups, include, fieldsBetaTesters, fieldsApps, fieldsBuilds, limitBetaTesters, limitBuilds, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBetaGroups the fields to include for returned resources of type betaGroups
     * @param include comma-separated list of relationships to include
     * @param fieldsBetaTesters the fields to include for returned resources of type betaTesters
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param limitBetaTesters maximum number of related betaTesters returned (when they are included)
     * @param limitBuilds maximum number of related builds returned (when they are included)
     */
    public betaGroupsGetInstance(id: string, fieldsBetaGroups?: Array<'app' | 'betaTesters' | 'builds' | 'createdDate' | 'feedbackEnabled' | 'hasAccessToAllBuilds' | 'iosBuildsAvailableForAppleSiliconMac' | 'isInternalGroup' | 'name' | 'publicLink' | 'publicLinkEnabled' | 'publicLinkId' | 'publicLinkLimit' | 'publicLinkLimitEnabled'>, include?: Array<'app' | 'betaTesters' | 'builds'>, fieldsBetaTesters?: Array<'apps' | 'betaGroups' | 'builds' | 'email' | 'firstName' | 'inviteType' | 'lastName'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, limitBetaTesters?: number, limitBuilds?: number, _options?: Configuration): Promise<BetaGroupResponse> {
        const result = this.api.betaGroupsGetInstance(id, fieldsBetaGroups, include, fieldsBetaTesters, fieldsApps, fieldsBuilds, limitBetaTesters, limitBuilds, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param betaGroupUpdateRequest BetaGroup representation
     */
    public betaGroupsUpdateInstanceWithHttpInfo(id: string, betaGroupUpdateRequest: BetaGroupUpdateRequest, _options?: Configuration): Promise<HttpInfo<BetaGroupResponse>> {
        const result = this.api.betaGroupsUpdateInstanceWithHttpInfo(id, betaGroupUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param betaGroupUpdateRequest BetaGroup representation
     */
    public betaGroupsUpdateInstance(id: string, betaGroupUpdateRequest: BetaGroupUpdateRequest, _options?: Configuration): Promise<BetaGroupResponse> {
        const result = this.api.betaGroupsUpdateInstance(id, betaGroupUpdateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableBetaLicenseAgreementsApi } from './ObservableAPI.ts';

import { BetaLicenseAgreementsApiRequestFactory, BetaLicenseAgreementsApiResponseProcessor} from "../apis/BetaLicenseAgreementsApi.ts";
export class PromiseBetaLicenseAgreementsApi {
    private api: ObservableBetaLicenseAgreementsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: BetaLicenseAgreementsApiRequestFactory,
        responseProcessor?: BetaLicenseAgreementsApiResponseProcessor
    ) {
        this.api = new ObservableBetaLicenseAgreementsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsApps the fields to include for returned resources of type apps
     */
    public betaLicenseAgreementsAppGetToOneRelatedWithHttpInfo(id: string, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, _options?: Configuration): Promise<HttpInfo<AppWithoutIncludesResponse>> {
        const result = this.api.betaLicenseAgreementsAppGetToOneRelatedWithHttpInfo(id, fieldsApps, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsApps the fields to include for returned resources of type apps
     */
    public betaLicenseAgreementsAppGetToOneRelated(id: string, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, _options?: Configuration): Promise<AppWithoutIncludesResponse> {
        const result = this.api.betaLicenseAgreementsAppGetToOneRelated(id, fieldsApps, _options);
        return result.toPromise();
    }

    /**
     * @param filterApp filter by id(s) of related \&#39;app\&#39;
     * @param fieldsBetaLicenseAgreements the fields to include for returned resources of type betaLicenseAgreements
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsApps the fields to include for returned resources of type apps
     */
    public betaLicenseAgreementsGetCollectionWithHttpInfo(filterApp?: Array<string>, fieldsBetaLicenseAgreements?: Array<'agreementText' | 'app'>, limit?: number, include?: Array<'app'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, _options?: Configuration): Promise<HttpInfo<BetaLicenseAgreementsResponse>> {
        const result = this.api.betaLicenseAgreementsGetCollectionWithHttpInfo(filterApp, fieldsBetaLicenseAgreements, limit, include, fieldsApps, _options);
        return result.toPromise();
    }

    /**
     * @param filterApp filter by id(s) of related \&#39;app\&#39;
     * @param fieldsBetaLicenseAgreements the fields to include for returned resources of type betaLicenseAgreements
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsApps the fields to include for returned resources of type apps
     */
    public betaLicenseAgreementsGetCollection(filterApp?: Array<string>, fieldsBetaLicenseAgreements?: Array<'agreementText' | 'app'>, limit?: number, include?: Array<'app'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, _options?: Configuration): Promise<BetaLicenseAgreementsResponse> {
        const result = this.api.betaLicenseAgreementsGetCollection(filterApp, fieldsBetaLicenseAgreements, limit, include, fieldsApps, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBetaLicenseAgreements the fields to include for returned resources of type betaLicenseAgreements
     * @param include comma-separated list of relationships to include
     * @param fieldsApps the fields to include for returned resources of type apps
     */
    public betaLicenseAgreementsGetInstanceWithHttpInfo(id: string, fieldsBetaLicenseAgreements?: Array<'agreementText' | 'app'>, include?: Array<'app'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, _options?: Configuration): Promise<HttpInfo<BetaLicenseAgreementResponse>> {
        const result = this.api.betaLicenseAgreementsGetInstanceWithHttpInfo(id, fieldsBetaLicenseAgreements, include, fieldsApps, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBetaLicenseAgreements the fields to include for returned resources of type betaLicenseAgreements
     * @param include comma-separated list of relationships to include
     * @param fieldsApps the fields to include for returned resources of type apps
     */
    public betaLicenseAgreementsGetInstance(id: string, fieldsBetaLicenseAgreements?: Array<'agreementText' | 'app'>, include?: Array<'app'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, _options?: Configuration): Promise<BetaLicenseAgreementResponse> {
        const result = this.api.betaLicenseAgreementsGetInstance(id, fieldsBetaLicenseAgreements, include, fieldsApps, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param betaLicenseAgreementUpdateRequest BetaLicenseAgreement representation
     */
    public betaLicenseAgreementsUpdateInstanceWithHttpInfo(id: string, betaLicenseAgreementUpdateRequest: BetaLicenseAgreementUpdateRequest, _options?: Configuration): Promise<HttpInfo<BetaLicenseAgreementResponse>> {
        const result = this.api.betaLicenseAgreementsUpdateInstanceWithHttpInfo(id, betaLicenseAgreementUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param betaLicenseAgreementUpdateRequest BetaLicenseAgreement representation
     */
    public betaLicenseAgreementsUpdateInstance(id: string, betaLicenseAgreementUpdateRequest: BetaLicenseAgreementUpdateRequest, _options?: Configuration): Promise<BetaLicenseAgreementResponse> {
        const result = this.api.betaLicenseAgreementsUpdateInstance(id, betaLicenseAgreementUpdateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableBetaTesterInvitationsApi } from './ObservableAPI.ts';

import { BetaTesterInvitationsApiRequestFactory, BetaTesterInvitationsApiResponseProcessor} from "../apis/BetaTesterInvitationsApi.ts";
export class PromiseBetaTesterInvitationsApi {
    private api: ObservableBetaTesterInvitationsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: BetaTesterInvitationsApiRequestFactory,
        responseProcessor?: BetaTesterInvitationsApiResponseProcessor
    ) {
        this.api = new ObservableBetaTesterInvitationsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param betaTesterInvitationCreateRequest BetaTesterInvitation representation
     */
    public betaTesterInvitationsCreateInstanceWithHttpInfo(betaTesterInvitationCreateRequest: BetaTesterInvitationCreateRequest, _options?: Configuration): Promise<HttpInfo<BetaTesterInvitationResponse>> {
        const result = this.api.betaTesterInvitationsCreateInstanceWithHttpInfo(betaTesterInvitationCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param betaTesterInvitationCreateRequest BetaTesterInvitation representation
     */
    public betaTesterInvitationsCreateInstance(betaTesterInvitationCreateRequest: BetaTesterInvitationCreateRequest, _options?: Configuration): Promise<BetaTesterInvitationResponse> {
        const result = this.api.betaTesterInvitationsCreateInstance(betaTesterInvitationCreateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableBetaTestersApi } from './ObservableAPI.ts';

import { BetaTestersApiRequestFactory, BetaTestersApiResponseProcessor} from "../apis/BetaTestersApi.ts";
export class PromiseBetaTestersApi {
    private api: ObservableBetaTestersApi

    public constructor(
        configuration: Configuration,
        requestFactory?: BetaTestersApiRequestFactory,
        responseProcessor?: BetaTestersApiResponseProcessor
    ) {
        this.api = new ObservableBetaTestersApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param id the id of the requested resource
     * @param betaTesterAppsLinkagesRequest List of related linkages
     */
    public betaTestersAppsDeleteToManyRelationshipWithHttpInfo(id: string, betaTesterAppsLinkagesRequest: BetaTesterAppsLinkagesRequest, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.betaTestersAppsDeleteToManyRelationshipWithHttpInfo(id, betaTesterAppsLinkagesRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param betaTesterAppsLinkagesRequest List of related linkages
     */
    public betaTestersAppsDeleteToManyRelationship(id: string, betaTesterAppsLinkagesRequest: BetaTesterAppsLinkagesRequest, _options?: Configuration): Promise<void> {
        const result = this.api.betaTestersAppsDeleteToManyRelationship(id, betaTesterAppsLinkagesRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param limit maximum resources per page
     */
    public betaTestersAppsGetToManyRelatedWithHttpInfo(id: string, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, limit?: number, _options?: Configuration): Promise<HttpInfo<AppsWithoutIncludesResponse>> {
        const result = this.api.betaTestersAppsGetToManyRelatedWithHttpInfo(id, fieldsApps, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param limit maximum resources per page
     */
    public betaTestersAppsGetToManyRelated(id: string, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, limit?: number, _options?: Configuration): Promise<AppsWithoutIncludesResponse> {
        const result = this.api.betaTestersAppsGetToManyRelated(id, fieldsApps, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public betaTestersAppsGetToManyRelationshipWithHttpInfo(id: string, limit?: number, _options?: Configuration): Promise<HttpInfo<BetaTesterAppsLinkagesResponse>> {
        const result = this.api.betaTestersAppsGetToManyRelationshipWithHttpInfo(id, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public betaTestersAppsGetToManyRelationship(id: string, limit?: number, _options?: Configuration): Promise<BetaTesterAppsLinkagesResponse> {
        const result = this.api.betaTestersAppsGetToManyRelationship(id, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param betaTesterBetaGroupsLinkagesRequest List of related linkages
     */
    public betaTestersBetaGroupsCreateToManyRelationshipWithHttpInfo(id: string, betaTesterBetaGroupsLinkagesRequest: BetaTesterBetaGroupsLinkagesRequest, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.betaTestersBetaGroupsCreateToManyRelationshipWithHttpInfo(id, betaTesterBetaGroupsLinkagesRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param betaTesterBetaGroupsLinkagesRequest List of related linkages
     */
    public betaTestersBetaGroupsCreateToManyRelationship(id: string, betaTesterBetaGroupsLinkagesRequest: BetaTesterBetaGroupsLinkagesRequest, _options?: Configuration): Promise<void> {
        const result = this.api.betaTestersBetaGroupsCreateToManyRelationship(id, betaTesterBetaGroupsLinkagesRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param betaTesterBetaGroupsLinkagesRequest List of related linkages
     */
    public betaTestersBetaGroupsDeleteToManyRelationshipWithHttpInfo(id: string, betaTesterBetaGroupsLinkagesRequest: BetaTesterBetaGroupsLinkagesRequest, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.betaTestersBetaGroupsDeleteToManyRelationshipWithHttpInfo(id, betaTesterBetaGroupsLinkagesRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param betaTesterBetaGroupsLinkagesRequest List of related linkages
     */
    public betaTestersBetaGroupsDeleteToManyRelationship(id: string, betaTesterBetaGroupsLinkagesRequest: BetaTesterBetaGroupsLinkagesRequest, _options?: Configuration): Promise<void> {
        const result = this.api.betaTestersBetaGroupsDeleteToManyRelationship(id, betaTesterBetaGroupsLinkagesRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBetaGroups the fields to include for returned resources of type betaGroups
     * @param limit maximum resources per page
     */
    public betaTestersBetaGroupsGetToManyRelatedWithHttpInfo(id: string, fieldsBetaGroups?: Array<'app' | 'betaTesters' | 'builds' | 'createdDate' | 'feedbackEnabled' | 'hasAccessToAllBuilds' | 'iosBuildsAvailableForAppleSiliconMac' | 'isInternalGroup' | 'name' | 'publicLink' | 'publicLinkEnabled' | 'publicLinkId' | 'publicLinkLimit' | 'publicLinkLimitEnabled'>, limit?: number, _options?: Configuration): Promise<HttpInfo<BetaGroupsWithoutIncludesResponse>> {
        const result = this.api.betaTestersBetaGroupsGetToManyRelatedWithHttpInfo(id, fieldsBetaGroups, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBetaGroups the fields to include for returned resources of type betaGroups
     * @param limit maximum resources per page
     */
    public betaTestersBetaGroupsGetToManyRelated(id: string, fieldsBetaGroups?: Array<'app' | 'betaTesters' | 'builds' | 'createdDate' | 'feedbackEnabled' | 'hasAccessToAllBuilds' | 'iosBuildsAvailableForAppleSiliconMac' | 'isInternalGroup' | 'name' | 'publicLink' | 'publicLinkEnabled' | 'publicLinkId' | 'publicLinkLimit' | 'publicLinkLimitEnabled'>, limit?: number, _options?: Configuration): Promise<BetaGroupsWithoutIncludesResponse> {
        const result = this.api.betaTestersBetaGroupsGetToManyRelated(id, fieldsBetaGroups, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public betaTestersBetaGroupsGetToManyRelationshipWithHttpInfo(id: string, limit?: number, _options?: Configuration): Promise<HttpInfo<BetaTesterBetaGroupsLinkagesResponse>> {
        const result = this.api.betaTestersBetaGroupsGetToManyRelationshipWithHttpInfo(id, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public betaTestersBetaGroupsGetToManyRelationship(id: string, limit?: number, _options?: Configuration): Promise<BetaTesterBetaGroupsLinkagesResponse> {
        const result = this.api.betaTestersBetaGroupsGetToManyRelationship(id, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterApps filter by \&#39;apps\&#39; relationship dimension
     * @param limit maximum number of groups to return per page
     * @param period the duration of the reporting period
     */
    public betaTestersBetaTesterUsagesGetMetricsWithHttpInfo(id: string, filterApps: string, limit?: number, period?: 'P7D' | 'P30D' | 'P90D' | 'P365D', _options?: Configuration): Promise<HttpInfo<BetaTesterUsagesV1MetricResponse>> {
        const result = this.api.betaTestersBetaTesterUsagesGetMetricsWithHttpInfo(id, filterApps, limit, period, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterApps filter by \&#39;apps\&#39; relationship dimension
     * @param limit maximum number of groups to return per page
     * @param period the duration of the reporting period
     */
    public betaTestersBetaTesterUsagesGetMetrics(id: string, filterApps: string, limit?: number, period?: 'P7D' | 'P30D' | 'P90D' | 'P365D', _options?: Configuration): Promise<BetaTesterUsagesV1MetricResponse> {
        const result = this.api.betaTestersBetaTesterUsagesGetMetrics(id, filterApps, limit, period, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param betaTesterBuildsLinkagesRequest List of related linkages
     */
    public betaTestersBuildsCreateToManyRelationshipWithHttpInfo(id: string, betaTesterBuildsLinkagesRequest: BetaTesterBuildsLinkagesRequest, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.betaTestersBuildsCreateToManyRelationshipWithHttpInfo(id, betaTesterBuildsLinkagesRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param betaTesterBuildsLinkagesRequest List of related linkages
     */
    public betaTestersBuildsCreateToManyRelationship(id: string, betaTesterBuildsLinkagesRequest: BetaTesterBuildsLinkagesRequest, _options?: Configuration): Promise<void> {
        const result = this.api.betaTestersBuildsCreateToManyRelationship(id, betaTesterBuildsLinkagesRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param betaTesterBuildsLinkagesRequest List of related linkages
     */
    public betaTestersBuildsDeleteToManyRelationshipWithHttpInfo(id: string, betaTesterBuildsLinkagesRequest: BetaTesterBuildsLinkagesRequest, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.betaTestersBuildsDeleteToManyRelationshipWithHttpInfo(id, betaTesterBuildsLinkagesRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param betaTesterBuildsLinkagesRequest List of related linkages
     */
    public betaTestersBuildsDeleteToManyRelationship(id: string, betaTesterBuildsLinkagesRequest: BetaTesterBuildsLinkagesRequest, _options?: Configuration): Promise<void> {
        const result = this.api.betaTestersBuildsDeleteToManyRelationship(id, betaTesterBuildsLinkagesRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param limit maximum resources per page
     */
    public betaTestersBuildsGetToManyRelatedWithHttpInfo(id: string, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, limit?: number, _options?: Configuration): Promise<HttpInfo<BuildsWithoutIncludesResponse>> {
        const result = this.api.betaTestersBuildsGetToManyRelatedWithHttpInfo(id, fieldsBuilds, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param limit maximum resources per page
     */
    public betaTestersBuildsGetToManyRelated(id: string, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, limit?: number, _options?: Configuration): Promise<BuildsWithoutIncludesResponse> {
        const result = this.api.betaTestersBuildsGetToManyRelated(id, fieldsBuilds, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public betaTestersBuildsGetToManyRelationshipWithHttpInfo(id: string, limit?: number, _options?: Configuration): Promise<HttpInfo<BetaTesterBuildsLinkagesResponse>> {
        const result = this.api.betaTestersBuildsGetToManyRelationshipWithHttpInfo(id, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public betaTestersBuildsGetToManyRelationship(id: string, limit?: number, _options?: Configuration): Promise<BetaTesterBuildsLinkagesResponse> {
        const result = this.api.betaTestersBuildsGetToManyRelationship(id, limit, _options);
        return result.toPromise();
    }

    /**
     * @param betaTesterCreateRequest BetaTester representation
     */
    public betaTestersCreateInstanceWithHttpInfo(betaTesterCreateRequest: BetaTesterCreateRequest, _options?: Configuration): Promise<HttpInfo<BetaTesterResponse>> {
        const result = this.api.betaTestersCreateInstanceWithHttpInfo(betaTesterCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param betaTesterCreateRequest BetaTester representation
     */
    public betaTestersCreateInstance(betaTesterCreateRequest: BetaTesterCreateRequest, _options?: Configuration): Promise<BetaTesterResponse> {
        const result = this.api.betaTestersCreateInstance(betaTesterCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public betaTestersDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.betaTestersDeleteInstanceWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public betaTestersDeleteInstance(id: string, _options?: Configuration): Promise<void> {
        const result = this.api.betaTestersDeleteInstance(id, _options);
        return result.toPromise();
    }

    /**
     * @param filterEmail filter by attribute \&#39;email\&#39;
     * @param filterFirstName filter by attribute \&#39;firstName\&#39;
     * @param filterInviteType filter by attribute \&#39;inviteType\&#39;
     * @param filterLastName filter by attribute \&#39;lastName\&#39;
     * @param filterApps filter by id(s) of related \&#39;apps\&#39;
     * @param filterBetaGroups filter by id(s) of related \&#39;betaGroups\&#39;
     * @param filterBuilds filter by id(s) of related \&#39;builds\&#39;
     * @param filterId filter by id(s)
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsBetaTesters the fields to include for returned resources of type betaTesters
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param fieldsBetaGroups the fields to include for returned resources of type betaGroups
     * @param limitApps maximum number of related apps returned (when they are included)
     * @param limitBetaGroups maximum number of related betaGroups returned (when they are included)
     * @param limitBuilds maximum number of related builds returned (when they are included)
     */
    public betaTestersGetCollectionWithHttpInfo(filterEmail?: Array<string>, filterFirstName?: Array<string>, filterInviteType?: Array<'EMAIL' | 'PUBLIC_LINK'>, filterLastName?: Array<string>, filterApps?: Array<string>, filterBetaGroups?: Array<string>, filterBuilds?: Array<string>, filterId?: Array<string>, sort?: Array<'email' | '-email' | 'firstName' | '-firstName' | 'inviteType' | '-inviteType' | 'lastName' | '-lastName'>, fieldsBetaTesters?: Array<'apps' | 'betaGroups' | 'builds' | 'email' | 'firstName' | 'inviteType' | 'lastName'>, limit?: number, include?: Array<'apps' | 'betaGroups' | 'builds'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, fieldsBetaGroups?: Array<'app' | 'betaTesters' | 'builds' | 'createdDate' | 'feedbackEnabled' | 'hasAccessToAllBuilds' | 'iosBuildsAvailableForAppleSiliconMac' | 'isInternalGroup' | 'name' | 'publicLink' | 'publicLinkEnabled' | 'publicLinkId' | 'publicLinkLimit' | 'publicLinkLimitEnabled'>, limitApps?: number, limitBetaGroups?: number, limitBuilds?: number, _options?: Configuration): Promise<HttpInfo<BetaTestersResponse>> {
        const result = this.api.betaTestersGetCollectionWithHttpInfo(filterEmail, filterFirstName, filterInviteType, filterLastName, filterApps, filterBetaGroups, filterBuilds, filterId, sort, fieldsBetaTesters, limit, include, fieldsApps, fieldsBuilds, fieldsBetaGroups, limitApps, limitBetaGroups, limitBuilds, _options);
        return result.toPromise();
    }

    /**
     * @param filterEmail filter by attribute \&#39;email\&#39;
     * @param filterFirstName filter by attribute \&#39;firstName\&#39;
     * @param filterInviteType filter by attribute \&#39;inviteType\&#39;
     * @param filterLastName filter by attribute \&#39;lastName\&#39;
     * @param filterApps filter by id(s) of related \&#39;apps\&#39;
     * @param filterBetaGroups filter by id(s) of related \&#39;betaGroups\&#39;
     * @param filterBuilds filter by id(s) of related \&#39;builds\&#39;
     * @param filterId filter by id(s)
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsBetaTesters the fields to include for returned resources of type betaTesters
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param fieldsBetaGroups the fields to include for returned resources of type betaGroups
     * @param limitApps maximum number of related apps returned (when they are included)
     * @param limitBetaGroups maximum number of related betaGroups returned (when they are included)
     * @param limitBuilds maximum number of related builds returned (when they are included)
     */
    public betaTestersGetCollection(filterEmail?: Array<string>, filterFirstName?: Array<string>, filterInviteType?: Array<'EMAIL' | 'PUBLIC_LINK'>, filterLastName?: Array<string>, filterApps?: Array<string>, filterBetaGroups?: Array<string>, filterBuilds?: Array<string>, filterId?: Array<string>, sort?: Array<'email' | '-email' | 'firstName' | '-firstName' | 'inviteType' | '-inviteType' | 'lastName' | '-lastName'>, fieldsBetaTesters?: Array<'apps' | 'betaGroups' | 'builds' | 'email' | 'firstName' | 'inviteType' | 'lastName'>, limit?: number, include?: Array<'apps' | 'betaGroups' | 'builds'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, fieldsBetaGroups?: Array<'app' | 'betaTesters' | 'builds' | 'createdDate' | 'feedbackEnabled' | 'hasAccessToAllBuilds' | 'iosBuildsAvailableForAppleSiliconMac' | 'isInternalGroup' | 'name' | 'publicLink' | 'publicLinkEnabled' | 'publicLinkId' | 'publicLinkLimit' | 'publicLinkLimitEnabled'>, limitApps?: number, limitBetaGroups?: number, limitBuilds?: number, _options?: Configuration): Promise<BetaTestersResponse> {
        const result = this.api.betaTestersGetCollection(filterEmail, filterFirstName, filterInviteType, filterLastName, filterApps, filterBetaGroups, filterBuilds, filterId, sort, fieldsBetaTesters, limit, include, fieldsApps, fieldsBuilds, fieldsBetaGroups, limitApps, limitBetaGroups, limitBuilds, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBetaTesters the fields to include for returned resources of type betaTesters
     * @param include comma-separated list of relationships to include
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param fieldsBetaGroups the fields to include for returned resources of type betaGroups
     * @param limitApps maximum number of related apps returned (when they are included)
     * @param limitBetaGroups maximum number of related betaGroups returned (when they are included)
     * @param limitBuilds maximum number of related builds returned (when they are included)
     */
    public betaTestersGetInstanceWithHttpInfo(id: string, fieldsBetaTesters?: Array<'apps' | 'betaGroups' | 'builds' | 'email' | 'firstName' | 'inviteType' | 'lastName'>, include?: Array<'apps' | 'betaGroups' | 'builds'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, fieldsBetaGroups?: Array<'app' | 'betaTesters' | 'builds' | 'createdDate' | 'feedbackEnabled' | 'hasAccessToAllBuilds' | 'iosBuildsAvailableForAppleSiliconMac' | 'isInternalGroup' | 'name' | 'publicLink' | 'publicLinkEnabled' | 'publicLinkId' | 'publicLinkLimit' | 'publicLinkLimitEnabled'>, limitApps?: number, limitBetaGroups?: number, limitBuilds?: number, _options?: Configuration): Promise<HttpInfo<BetaTesterResponse>> {
        const result = this.api.betaTestersGetInstanceWithHttpInfo(id, fieldsBetaTesters, include, fieldsApps, fieldsBuilds, fieldsBetaGroups, limitApps, limitBetaGroups, limitBuilds, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBetaTesters the fields to include for returned resources of type betaTesters
     * @param include comma-separated list of relationships to include
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param fieldsBetaGroups the fields to include for returned resources of type betaGroups
     * @param limitApps maximum number of related apps returned (when they are included)
     * @param limitBetaGroups maximum number of related betaGroups returned (when they are included)
     * @param limitBuilds maximum number of related builds returned (when they are included)
     */
    public betaTestersGetInstance(id: string, fieldsBetaTesters?: Array<'apps' | 'betaGroups' | 'builds' | 'email' | 'firstName' | 'inviteType' | 'lastName'>, include?: Array<'apps' | 'betaGroups' | 'builds'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, fieldsBetaGroups?: Array<'app' | 'betaTesters' | 'builds' | 'createdDate' | 'feedbackEnabled' | 'hasAccessToAllBuilds' | 'iosBuildsAvailableForAppleSiliconMac' | 'isInternalGroup' | 'name' | 'publicLink' | 'publicLinkEnabled' | 'publicLinkId' | 'publicLinkLimit' | 'publicLinkLimitEnabled'>, limitApps?: number, limitBetaGroups?: number, limitBuilds?: number, _options?: Configuration): Promise<BetaTesterResponse> {
        const result = this.api.betaTestersGetInstance(id, fieldsBetaTesters, include, fieldsApps, fieldsBuilds, fieldsBetaGroups, limitApps, limitBetaGroups, limitBuilds, _options);
        return result.toPromise();
    }


}



import { ObservableBuildBetaDetailsApi } from './ObservableAPI.ts';

import { BuildBetaDetailsApiRequestFactory, BuildBetaDetailsApiResponseProcessor} from "../apis/BuildBetaDetailsApi.ts";
export class PromiseBuildBetaDetailsApi {
    private api: ObservableBuildBetaDetailsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: BuildBetaDetailsApiRequestFactory,
        responseProcessor?: BuildBetaDetailsApiResponseProcessor
    ) {
        this.api = new ObservableBuildBetaDetailsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBuilds the fields to include for returned resources of type builds
     */
    public buildBetaDetailsBuildGetToOneRelatedWithHttpInfo(id: string, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, _options?: Configuration): Promise<HttpInfo<BuildWithoutIncludesResponse>> {
        const result = this.api.buildBetaDetailsBuildGetToOneRelatedWithHttpInfo(id, fieldsBuilds, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBuilds the fields to include for returned resources of type builds
     */
    public buildBetaDetailsBuildGetToOneRelated(id: string, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, _options?: Configuration): Promise<BuildWithoutIncludesResponse> {
        const result = this.api.buildBetaDetailsBuildGetToOneRelated(id, fieldsBuilds, _options);
        return result.toPromise();
    }

    /**
     * @param filterBuild filter by id(s) of related \&#39;build\&#39;
     * @param filterId filter by id(s)
     * @param fieldsBuildBetaDetails the fields to include for returned resources of type buildBetaDetails
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsBuilds the fields to include for returned resources of type builds
     */
    public buildBetaDetailsGetCollectionWithHttpInfo(filterBuild?: Array<string>, filterId?: Array<string>, fieldsBuildBetaDetails?: Array<'autoNotifyEnabled' | 'build' | 'externalBuildState' | 'internalBuildState'>, limit?: number, include?: Array<'build'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, _options?: Configuration): Promise<HttpInfo<BuildBetaDetailsResponse>> {
        const result = this.api.buildBetaDetailsGetCollectionWithHttpInfo(filterBuild, filterId, fieldsBuildBetaDetails, limit, include, fieldsBuilds, _options);
        return result.toPromise();
    }

    /**
     * @param filterBuild filter by id(s) of related \&#39;build\&#39;
     * @param filterId filter by id(s)
     * @param fieldsBuildBetaDetails the fields to include for returned resources of type buildBetaDetails
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsBuilds the fields to include for returned resources of type builds
     */
    public buildBetaDetailsGetCollection(filterBuild?: Array<string>, filterId?: Array<string>, fieldsBuildBetaDetails?: Array<'autoNotifyEnabled' | 'build' | 'externalBuildState' | 'internalBuildState'>, limit?: number, include?: Array<'build'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, _options?: Configuration): Promise<BuildBetaDetailsResponse> {
        const result = this.api.buildBetaDetailsGetCollection(filterBuild, filterId, fieldsBuildBetaDetails, limit, include, fieldsBuilds, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBuildBetaDetails the fields to include for returned resources of type buildBetaDetails
     * @param include comma-separated list of relationships to include
     * @param fieldsBuilds the fields to include for returned resources of type builds
     */
    public buildBetaDetailsGetInstanceWithHttpInfo(id: string, fieldsBuildBetaDetails?: Array<'autoNotifyEnabled' | 'build' | 'externalBuildState' | 'internalBuildState'>, include?: Array<'build'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, _options?: Configuration): Promise<HttpInfo<BuildBetaDetailResponse>> {
        const result = this.api.buildBetaDetailsGetInstanceWithHttpInfo(id, fieldsBuildBetaDetails, include, fieldsBuilds, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBuildBetaDetails the fields to include for returned resources of type buildBetaDetails
     * @param include comma-separated list of relationships to include
     * @param fieldsBuilds the fields to include for returned resources of type builds
     */
    public buildBetaDetailsGetInstance(id: string, fieldsBuildBetaDetails?: Array<'autoNotifyEnabled' | 'build' | 'externalBuildState' | 'internalBuildState'>, include?: Array<'build'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, _options?: Configuration): Promise<BuildBetaDetailResponse> {
        const result = this.api.buildBetaDetailsGetInstance(id, fieldsBuildBetaDetails, include, fieldsBuilds, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param buildBetaDetailUpdateRequest BuildBetaDetail representation
     */
    public buildBetaDetailsUpdateInstanceWithHttpInfo(id: string, buildBetaDetailUpdateRequest: BuildBetaDetailUpdateRequest, _options?: Configuration): Promise<HttpInfo<BuildBetaDetailResponse>> {
        const result = this.api.buildBetaDetailsUpdateInstanceWithHttpInfo(id, buildBetaDetailUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param buildBetaDetailUpdateRequest BuildBetaDetail representation
     */
    public buildBetaDetailsUpdateInstance(id: string, buildBetaDetailUpdateRequest: BuildBetaDetailUpdateRequest, _options?: Configuration): Promise<BuildBetaDetailResponse> {
        const result = this.api.buildBetaDetailsUpdateInstance(id, buildBetaDetailUpdateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableBuildBetaNotificationsApi } from './ObservableAPI.ts';

import { BuildBetaNotificationsApiRequestFactory, BuildBetaNotificationsApiResponseProcessor} from "../apis/BuildBetaNotificationsApi.ts";
export class PromiseBuildBetaNotificationsApi {
    private api: ObservableBuildBetaNotificationsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: BuildBetaNotificationsApiRequestFactory,
        responseProcessor?: BuildBetaNotificationsApiResponseProcessor
    ) {
        this.api = new ObservableBuildBetaNotificationsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param buildBetaNotificationCreateRequest BuildBetaNotification representation
     */
    public buildBetaNotificationsCreateInstanceWithHttpInfo(buildBetaNotificationCreateRequest: BuildBetaNotificationCreateRequest, _options?: Configuration): Promise<HttpInfo<BuildBetaNotificationResponse>> {
        const result = this.api.buildBetaNotificationsCreateInstanceWithHttpInfo(buildBetaNotificationCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param buildBetaNotificationCreateRequest BuildBetaNotification representation
     */
    public buildBetaNotificationsCreateInstance(buildBetaNotificationCreateRequest: BuildBetaNotificationCreateRequest, _options?: Configuration): Promise<BuildBetaNotificationResponse> {
        const result = this.api.buildBetaNotificationsCreateInstance(buildBetaNotificationCreateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableBuildBundlesApi } from './ObservableAPI.ts';

import { BuildBundlesApiRequestFactory, BuildBundlesApiResponseProcessor} from "../apis/BuildBundlesApi.ts";
export class PromiseBuildBundlesApi {
    private api: ObservableBuildBundlesApi

    public constructor(
        configuration: Configuration,
        requestFactory?: BuildBundlesApiRequestFactory,
        responseProcessor?: BuildBundlesApiResponseProcessor
    ) {
        this.api = new ObservableBuildBundlesApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppClipDomainStatuses the fields to include for returned resources of type appClipDomainStatuses
     */
    public buildBundlesAppClipDomainCacheStatusGetToOneRelatedWithHttpInfo(id: string, fieldsAppClipDomainStatuses?: Array<'domains' | 'lastUpdatedDate'>, _options?: Configuration): Promise<HttpInfo<AppClipDomainStatusResponse>> {
        const result = this.api.buildBundlesAppClipDomainCacheStatusGetToOneRelatedWithHttpInfo(id, fieldsAppClipDomainStatuses, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppClipDomainStatuses the fields to include for returned resources of type appClipDomainStatuses
     */
    public buildBundlesAppClipDomainCacheStatusGetToOneRelated(id: string, fieldsAppClipDomainStatuses?: Array<'domains' | 'lastUpdatedDate'>, _options?: Configuration): Promise<AppClipDomainStatusResponse> {
        const result = this.api.buildBundlesAppClipDomainCacheStatusGetToOneRelated(id, fieldsAppClipDomainStatuses, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppClipDomainStatuses the fields to include for returned resources of type appClipDomainStatuses
     */
    public buildBundlesAppClipDomainDebugStatusGetToOneRelatedWithHttpInfo(id: string, fieldsAppClipDomainStatuses?: Array<'domains' | 'lastUpdatedDate'>, _options?: Configuration): Promise<HttpInfo<AppClipDomainStatusResponse>> {
        const result = this.api.buildBundlesAppClipDomainDebugStatusGetToOneRelatedWithHttpInfo(id, fieldsAppClipDomainStatuses, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppClipDomainStatuses the fields to include for returned resources of type appClipDomainStatuses
     */
    public buildBundlesAppClipDomainDebugStatusGetToOneRelated(id: string, fieldsAppClipDomainStatuses?: Array<'domains' | 'lastUpdatedDate'>, _options?: Configuration): Promise<AppClipDomainStatusResponse> {
        const result = this.api.buildBundlesAppClipDomainDebugStatusGetToOneRelated(id, fieldsAppClipDomainStatuses, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBetaAppClipInvocations the fields to include for returned resources of type betaAppClipInvocations
     * @param fieldsBetaAppClipInvocationLocalizations the fields to include for returned resources of type betaAppClipInvocationLocalizations
     * @param limit maximum resources per page
     * @param limitBetaAppClipInvocationLocalizations maximum number of related betaAppClipInvocationLocalizations returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public buildBundlesBetaAppClipInvocationsGetToManyRelatedWithHttpInfo(id: string, fieldsBetaAppClipInvocations?: Array<'betaAppClipInvocationLocalizations' | 'buildBundle' | 'url'>, fieldsBetaAppClipInvocationLocalizations?: Array<'betaAppClipInvocation' | 'locale' | 'title'>, limit?: number, limitBetaAppClipInvocationLocalizations?: number, include?: Array<'betaAppClipInvocationLocalizations'>, _options?: Configuration): Promise<HttpInfo<BetaAppClipInvocationsResponse>> {
        const result = this.api.buildBundlesBetaAppClipInvocationsGetToManyRelatedWithHttpInfo(id, fieldsBetaAppClipInvocations, fieldsBetaAppClipInvocationLocalizations, limit, limitBetaAppClipInvocationLocalizations, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBetaAppClipInvocations the fields to include for returned resources of type betaAppClipInvocations
     * @param fieldsBetaAppClipInvocationLocalizations the fields to include for returned resources of type betaAppClipInvocationLocalizations
     * @param limit maximum resources per page
     * @param limitBetaAppClipInvocationLocalizations maximum number of related betaAppClipInvocationLocalizations returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public buildBundlesBetaAppClipInvocationsGetToManyRelated(id: string, fieldsBetaAppClipInvocations?: Array<'betaAppClipInvocationLocalizations' | 'buildBundle' | 'url'>, fieldsBetaAppClipInvocationLocalizations?: Array<'betaAppClipInvocation' | 'locale' | 'title'>, limit?: number, limitBetaAppClipInvocationLocalizations?: number, include?: Array<'betaAppClipInvocationLocalizations'>, _options?: Configuration): Promise<BetaAppClipInvocationsResponse> {
        const result = this.api.buildBundlesBetaAppClipInvocationsGetToManyRelated(id, fieldsBetaAppClipInvocations, fieldsBetaAppClipInvocationLocalizations, limit, limitBetaAppClipInvocationLocalizations, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBuildBundleFileSizes the fields to include for returned resources of type buildBundleFileSizes
     * @param limit maximum resources per page
     */
    public buildBundlesBuildBundleFileSizesGetToManyRelatedWithHttpInfo(id: string, fieldsBuildBundleFileSizes?: Array<'deviceModel' | 'downloadBytes' | 'installBytes' | 'osVersion'>, limit?: number, _options?: Configuration): Promise<HttpInfo<BuildBundleFileSizesResponse>> {
        const result = this.api.buildBundlesBuildBundleFileSizesGetToManyRelatedWithHttpInfo(id, fieldsBuildBundleFileSizes, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBuildBundleFileSizes the fields to include for returned resources of type buildBundleFileSizes
     * @param limit maximum resources per page
     */
    public buildBundlesBuildBundleFileSizesGetToManyRelated(id: string, fieldsBuildBundleFileSizes?: Array<'deviceModel' | 'downloadBytes' | 'installBytes' | 'osVersion'>, limit?: number, _options?: Configuration): Promise<BuildBundleFileSizesResponse> {
        const result = this.api.buildBundlesBuildBundleFileSizesGetToManyRelated(id, fieldsBuildBundleFileSizes, limit, _options);
        return result.toPromise();
    }


}



import { ObservableBuildsApi } from './ObservableAPI.ts';

import { BuildsApiRequestFactory, BuildsApiResponseProcessor} from "../apis/BuildsApi.ts";
export class PromiseBuildsApi {
    private api: ObservableBuildsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: BuildsApiRequestFactory,
        responseProcessor?: BuildsApiResponseProcessor
    ) {
        this.api = new ObservableBuildsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppEncryptionDeclarations the fields to include for returned resources of type appEncryptionDeclarations
     */
    public buildsAppEncryptionDeclarationGetToOneRelatedWithHttpInfo(id: string, fieldsAppEncryptionDeclarations?: Array<'app' | 'appDescription' | 'appEncryptionDeclarationDocument' | 'appEncryptionDeclarationState' | 'availableOnFrenchStore' | 'builds' | 'codeValue' | 'containsProprietaryCryptography' | 'containsThirdPartyCryptography' | 'createdDate' | 'documentName' | 'documentType' | 'documentUrl' | 'exempt' | 'platform' | 'uploadedDate' | 'usesEncryption'>, _options?: Configuration): Promise<HttpInfo<AppEncryptionDeclarationWithoutIncludesResponse>> {
        const result = this.api.buildsAppEncryptionDeclarationGetToOneRelatedWithHttpInfo(id, fieldsAppEncryptionDeclarations, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppEncryptionDeclarations the fields to include for returned resources of type appEncryptionDeclarations
     */
    public buildsAppEncryptionDeclarationGetToOneRelated(id: string, fieldsAppEncryptionDeclarations?: Array<'app' | 'appDescription' | 'appEncryptionDeclarationDocument' | 'appEncryptionDeclarationState' | 'availableOnFrenchStore' | 'builds' | 'codeValue' | 'containsProprietaryCryptography' | 'containsThirdPartyCryptography' | 'createdDate' | 'documentName' | 'documentType' | 'documentUrl' | 'exempt' | 'platform' | 'uploadedDate' | 'usesEncryption'>, _options?: Configuration): Promise<AppEncryptionDeclarationWithoutIncludesResponse> {
        const result = this.api.buildsAppEncryptionDeclarationGetToOneRelated(id, fieldsAppEncryptionDeclarations, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public buildsAppEncryptionDeclarationGetToOneRelationshipWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<BuildAppEncryptionDeclarationLinkageResponse>> {
        const result = this.api.buildsAppEncryptionDeclarationGetToOneRelationshipWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public buildsAppEncryptionDeclarationGetToOneRelationship(id: string, _options?: Configuration): Promise<BuildAppEncryptionDeclarationLinkageResponse> {
        const result = this.api.buildsAppEncryptionDeclarationGetToOneRelationship(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param buildAppEncryptionDeclarationLinkageRequest Related linkage
     */
    public buildsAppEncryptionDeclarationUpdateToOneRelationshipWithHttpInfo(id: string, buildAppEncryptionDeclarationLinkageRequest: BuildAppEncryptionDeclarationLinkageRequest, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.buildsAppEncryptionDeclarationUpdateToOneRelationshipWithHttpInfo(id, buildAppEncryptionDeclarationLinkageRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param buildAppEncryptionDeclarationLinkageRequest Related linkage
     */
    public buildsAppEncryptionDeclarationUpdateToOneRelationship(id: string, buildAppEncryptionDeclarationLinkageRequest: BuildAppEncryptionDeclarationLinkageRequest, _options?: Configuration): Promise<void> {
        const result = this.api.buildsAppEncryptionDeclarationUpdateToOneRelationship(id, buildAppEncryptionDeclarationLinkageRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsApps the fields to include for returned resources of type apps
     */
    public buildsAppGetToOneRelatedWithHttpInfo(id: string, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, _options?: Configuration): Promise<HttpInfo<AppWithoutIncludesResponse>> {
        const result = this.api.buildsAppGetToOneRelatedWithHttpInfo(id, fieldsApps, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsApps the fields to include for returned resources of type apps
     */
    public buildsAppGetToOneRelated(id: string, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, _options?: Configuration): Promise<AppWithoutIncludesResponse> {
        const result = this.api.buildsAppGetToOneRelated(id, fieldsApps, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAgeRatingDeclarations the fields to include for returned resources of type ageRatingDeclarations
     * @param fieldsAppStoreReviewDetails the fields to include for returned resources of type appStoreReviewDetails
     * @param fieldsAppStoreVersionLocalizations the fields to include for returned resources of type appStoreVersionLocalizations
     * @param fieldsAppStoreVersionExperiments the fields to include for returned resources of type appStoreVersionExperiments
     * @param fieldsAppStoreVersionSubmissions the fields to include for returned resources of type appStoreVersionSubmissions
     * @param fieldsAlternativeDistributionPackages the fields to include for returned resources of type alternativeDistributionPackages
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsRoutingAppCoverages the fields to include for returned resources of type routingAppCoverages
     * @param fieldsAppClipDefaultExperiences the fields to include for returned resources of type appClipDefaultExperiences
     * @param fieldsAppStoreVersionPhasedReleases the fields to include for returned resources of type appStoreVersionPhasedReleases
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param limitAppStoreVersionLocalizations maximum number of related appStoreVersionLocalizations returned (when they are included)
     * @param limitAppStoreVersionExperiments maximum number of related appStoreVersionExperiments returned (when they are included)
     * @param limitAppStoreVersionExperimentsV2 maximum number of related appStoreVersionExperimentsV2 returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public buildsAppStoreVersionGetToOneRelatedWithHttpInfo(id: string, fieldsAgeRatingDeclarations?: Array<'ageRatingOverride' | 'alcoholTobaccoOrDrugUseOrReferences' | 'contests' | 'gambling' | 'gamblingAndContests' | 'gamblingSimulated' | 'horrorOrFearThemes' | 'kidsAgeBand' | 'matureOrSuggestiveThemes' | 'medicalOrTreatmentInformation' | 'profanityOrCrudeHumor' | 'seventeenPlus' | 'sexualContentGraphicAndNudity' | 'sexualContentOrNudity' | 'unrestrictedWebAccess' | 'violenceCartoonOrFantasy' | 'violenceRealistic' | 'violenceRealisticProlongedGraphicOrSadistic'>, fieldsAppStoreReviewDetails?: Array<'appStoreReviewAttachments' | 'appStoreVersion' | 'contactEmail' | 'contactFirstName' | 'contactLastName' | 'contactPhone' | 'demoAccountName' | 'demoAccountPassword' | 'demoAccountRequired' | 'notes'>, fieldsAppStoreVersionLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersion' | 'description' | 'keywords' | 'locale' | 'marketingUrl' | 'promotionalText' | 'supportUrl' | 'whatsNew'>, fieldsAppStoreVersionExperiments?: Array<'app' | 'appStoreVersion' | 'appStoreVersionExperimentTreatments' | 'controlVersions' | 'endDate' | 'latestControlVersion' | 'name' | 'platform' | 'reviewRequired' | 'startDate' | 'started' | 'state' | 'trafficProportion'>, fieldsAppStoreVersionSubmissions?: Array<'appStoreVersion'>, fieldsAlternativeDistributionPackages?: Array<'appStoreVersion' | 'versions'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsRoutingAppCoverages?: Array<'appStoreVersion' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, fieldsAppClipDefaultExperiences?: Array<'action' | 'appClip' | 'appClipAppStoreReviewDetail' | 'appClipDefaultExperienceLocalizations' | 'appClipDefaultExperienceTemplate' | 'releaseWithAppStoreVersion'>, fieldsAppStoreVersionPhasedReleases?: Array<'appStoreVersion' | 'currentDayNumber' | 'phasedReleaseState' | 'startDate' | 'totalPauseDuration'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, limitAppStoreVersionLocalizations?: number, limitAppStoreVersionExperiments?: number, limitAppStoreVersionExperimentsV2?: number, include?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'build' | 'routingAppCoverage'>, _options?: Configuration): Promise<HttpInfo<AppStoreVersionResponse>> {
        const result = this.api.buildsAppStoreVersionGetToOneRelatedWithHttpInfo(id, fieldsAgeRatingDeclarations, fieldsAppStoreReviewDetails, fieldsAppStoreVersionLocalizations, fieldsAppStoreVersionExperiments, fieldsAppStoreVersionSubmissions, fieldsAlternativeDistributionPackages, fieldsAppStoreVersions, fieldsApps, fieldsRoutingAppCoverages, fieldsAppClipDefaultExperiences, fieldsAppStoreVersionPhasedReleases, fieldsBuilds, limitAppStoreVersionLocalizations, limitAppStoreVersionExperiments, limitAppStoreVersionExperimentsV2, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAgeRatingDeclarations the fields to include for returned resources of type ageRatingDeclarations
     * @param fieldsAppStoreReviewDetails the fields to include for returned resources of type appStoreReviewDetails
     * @param fieldsAppStoreVersionLocalizations the fields to include for returned resources of type appStoreVersionLocalizations
     * @param fieldsAppStoreVersionExperiments the fields to include for returned resources of type appStoreVersionExperiments
     * @param fieldsAppStoreVersionSubmissions the fields to include for returned resources of type appStoreVersionSubmissions
     * @param fieldsAlternativeDistributionPackages the fields to include for returned resources of type alternativeDistributionPackages
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsRoutingAppCoverages the fields to include for returned resources of type routingAppCoverages
     * @param fieldsAppClipDefaultExperiences the fields to include for returned resources of type appClipDefaultExperiences
     * @param fieldsAppStoreVersionPhasedReleases the fields to include for returned resources of type appStoreVersionPhasedReleases
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param limitAppStoreVersionLocalizations maximum number of related appStoreVersionLocalizations returned (when they are included)
     * @param limitAppStoreVersionExperiments maximum number of related appStoreVersionExperiments returned (when they are included)
     * @param limitAppStoreVersionExperimentsV2 maximum number of related appStoreVersionExperimentsV2 returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public buildsAppStoreVersionGetToOneRelated(id: string, fieldsAgeRatingDeclarations?: Array<'ageRatingOverride' | 'alcoholTobaccoOrDrugUseOrReferences' | 'contests' | 'gambling' | 'gamblingAndContests' | 'gamblingSimulated' | 'horrorOrFearThemes' | 'kidsAgeBand' | 'matureOrSuggestiveThemes' | 'medicalOrTreatmentInformation' | 'profanityOrCrudeHumor' | 'seventeenPlus' | 'sexualContentGraphicAndNudity' | 'sexualContentOrNudity' | 'unrestrictedWebAccess' | 'violenceCartoonOrFantasy' | 'violenceRealistic' | 'violenceRealisticProlongedGraphicOrSadistic'>, fieldsAppStoreReviewDetails?: Array<'appStoreReviewAttachments' | 'appStoreVersion' | 'contactEmail' | 'contactFirstName' | 'contactLastName' | 'contactPhone' | 'demoAccountName' | 'demoAccountPassword' | 'demoAccountRequired' | 'notes'>, fieldsAppStoreVersionLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersion' | 'description' | 'keywords' | 'locale' | 'marketingUrl' | 'promotionalText' | 'supportUrl' | 'whatsNew'>, fieldsAppStoreVersionExperiments?: Array<'app' | 'appStoreVersion' | 'appStoreVersionExperimentTreatments' | 'controlVersions' | 'endDate' | 'latestControlVersion' | 'name' | 'platform' | 'reviewRequired' | 'startDate' | 'started' | 'state' | 'trafficProportion'>, fieldsAppStoreVersionSubmissions?: Array<'appStoreVersion'>, fieldsAlternativeDistributionPackages?: Array<'appStoreVersion' | 'versions'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsRoutingAppCoverages?: Array<'appStoreVersion' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, fieldsAppClipDefaultExperiences?: Array<'action' | 'appClip' | 'appClipAppStoreReviewDetail' | 'appClipDefaultExperienceLocalizations' | 'appClipDefaultExperienceTemplate' | 'releaseWithAppStoreVersion'>, fieldsAppStoreVersionPhasedReleases?: Array<'appStoreVersion' | 'currentDayNumber' | 'phasedReleaseState' | 'startDate' | 'totalPauseDuration'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, limitAppStoreVersionLocalizations?: number, limitAppStoreVersionExperiments?: number, limitAppStoreVersionExperimentsV2?: number, include?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'build' | 'routingAppCoverage'>, _options?: Configuration): Promise<AppStoreVersionResponse> {
        const result = this.api.buildsAppStoreVersionGetToOneRelated(id, fieldsAgeRatingDeclarations, fieldsAppStoreReviewDetails, fieldsAppStoreVersionLocalizations, fieldsAppStoreVersionExperiments, fieldsAppStoreVersionSubmissions, fieldsAlternativeDistributionPackages, fieldsAppStoreVersions, fieldsApps, fieldsRoutingAppCoverages, fieldsAppClipDefaultExperiences, fieldsAppStoreVersionPhasedReleases, fieldsBuilds, limitAppStoreVersionLocalizations, limitAppStoreVersionExperiments, limitAppStoreVersionExperimentsV2, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBetaAppReviewSubmissions the fields to include for returned resources of type betaAppReviewSubmissions
     */
    public buildsBetaAppReviewSubmissionGetToOneRelatedWithHttpInfo(id: string, fieldsBetaAppReviewSubmissions?: Array<'betaReviewState' | 'build' | 'submittedDate'>, _options?: Configuration): Promise<HttpInfo<BetaAppReviewSubmissionWithoutIncludesResponse>> {
        const result = this.api.buildsBetaAppReviewSubmissionGetToOneRelatedWithHttpInfo(id, fieldsBetaAppReviewSubmissions, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBetaAppReviewSubmissions the fields to include for returned resources of type betaAppReviewSubmissions
     */
    public buildsBetaAppReviewSubmissionGetToOneRelated(id: string, fieldsBetaAppReviewSubmissions?: Array<'betaReviewState' | 'build' | 'submittedDate'>, _options?: Configuration): Promise<BetaAppReviewSubmissionWithoutIncludesResponse> {
        const result = this.api.buildsBetaAppReviewSubmissionGetToOneRelated(id, fieldsBetaAppReviewSubmissions, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBetaBuildLocalizations the fields to include for returned resources of type betaBuildLocalizations
     * @param limit maximum resources per page
     */
    public buildsBetaBuildLocalizationsGetToManyRelatedWithHttpInfo(id: string, fieldsBetaBuildLocalizations?: Array<'build' | 'locale' | 'whatsNew'>, limit?: number, _options?: Configuration): Promise<HttpInfo<BetaBuildLocalizationsWithoutIncludesResponse>> {
        const result = this.api.buildsBetaBuildLocalizationsGetToManyRelatedWithHttpInfo(id, fieldsBetaBuildLocalizations, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBetaBuildLocalizations the fields to include for returned resources of type betaBuildLocalizations
     * @param limit maximum resources per page
     */
    public buildsBetaBuildLocalizationsGetToManyRelated(id: string, fieldsBetaBuildLocalizations?: Array<'build' | 'locale' | 'whatsNew'>, limit?: number, _options?: Configuration): Promise<BetaBuildLocalizationsWithoutIncludesResponse> {
        const result = this.api.buildsBetaBuildLocalizationsGetToManyRelated(id, fieldsBetaBuildLocalizations, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum number of groups to return per page
     */
    public buildsBetaBuildUsagesGetMetricsWithHttpInfo(id: string, limit?: number, _options?: Configuration): Promise<HttpInfo<BetaBuildUsagesV1MetricResponse>> {
        const result = this.api.buildsBetaBuildUsagesGetMetricsWithHttpInfo(id, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum number of groups to return per page
     */
    public buildsBetaBuildUsagesGetMetrics(id: string, limit?: number, _options?: Configuration): Promise<BetaBuildUsagesV1MetricResponse> {
        const result = this.api.buildsBetaBuildUsagesGetMetrics(id, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param buildBetaGroupsLinkagesRequest List of related linkages
     */
    public buildsBetaGroupsCreateToManyRelationshipWithHttpInfo(id: string, buildBetaGroupsLinkagesRequest: BuildBetaGroupsLinkagesRequest, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.buildsBetaGroupsCreateToManyRelationshipWithHttpInfo(id, buildBetaGroupsLinkagesRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param buildBetaGroupsLinkagesRequest List of related linkages
     */
    public buildsBetaGroupsCreateToManyRelationship(id: string, buildBetaGroupsLinkagesRequest: BuildBetaGroupsLinkagesRequest, _options?: Configuration): Promise<void> {
        const result = this.api.buildsBetaGroupsCreateToManyRelationship(id, buildBetaGroupsLinkagesRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param buildBetaGroupsLinkagesRequest List of related linkages
     */
    public buildsBetaGroupsDeleteToManyRelationshipWithHttpInfo(id: string, buildBetaGroupsLinkagesRequest: BuildBetaGroupsLinkagesRequest, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.buildsBetaGroupsDeleteToManyRelationshipWithHttpInfo(id, buildBetaGroupsLinkagesRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param buildBetaGroupsLinkagesRequest List of related linkages
     */
    public buildsBetaGroupsDeleteToManyRelationship(id: string, buildBetaGroupsLinkagesRequest: BuildBetaGroupsLinkagesRequest, _options?: Configuration): Promise<void> {
        const result = this.api.buildsBetaGroupsDeleteToManyRelationship(id, buildBetaGroupsLinkagesRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBuildBetaDetails the fields to include for returned resources of type buildBetaDetails
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param include comma-separated list of relationships to include
     */
    public buildsBuildBetaDetailGetToOneRelatedWithHttpInfo(id: string, fieldsBuildBetaDetails?: Array<'autoNotifyEnabled' | 'build' | 'externalBuildState' | 'internalBuildState'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, include?: Array<'build'>, _options?: Configuration): Promise<HttpInfo<BuildBetaDetailResponse>> {
        const result = this.api.buildsBuildBetaDetailGetToOneRelatedWithHttpInfo(id, fieldsBuildBetaDetails, fieldsBuilds, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBuildBetaDetails the fields to include for returned resources of type buildBetaDetails
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param include comma-separated list of relationships to include
     */
    public buildsBuildBetaDetailGetToOneRelated(id: string, fieldsBuildBetaDetails?: Array<'autoNotifyEnabled' | 'build' | 'externalBuildState' | 'internalBuildState'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, include?: Array<'build'>, _options?: Configuration): Promise<BuildBetaDetailResponse> {
        const result = this.api.buildsBuildBetaDetailGetToOneRelated(id, fieldsBuildBetaDetails, fieldsBuilds, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterDiagnosticType filter by attribute \&#39;diagnosticType\&#39;
     * @param fieldsDiagnosticSignatures the fields to include for returned resources of type diagnosticSignatures
     * @param limit maximum resources per page
     */
    public buildsDiagnosticSignaturesGetToManyRelatedWithHttpInfo(id: string, filterDiagnosticType?: Array<'DISK_WRITES' | 'HANGS'>, fieldsDiagnosticSignatures?: Array<'diagnosticType' | 'logs' | 'signature' | 'weight'>, limit?: number, _options?: Configuration): Promise<HttpInfo<DiagnosticSignaturesResponse>> {
        const result = this.api.buildsDiagnosticSignaturesGetToManyRelatedWithHttpInfo(id, filterDiagnosticType, fieldsDiagnosticSignatures, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterDiagnosticType filter by attribute \&#39;diagnosticType\&#39;
     * @param fieldsDiagnosticSignatures the fields to include for returned resources of type diagnosticSignatures
     * @param limit maximum resources per page
     */
    public buildsDiagnosticSignaturesGetToManyRelated(id: string, filterDiagnosticType?: Array<'DISK_WRITES' | 'HANGS'>, fieldsDiagnosticSignatures?: Array<'diagnosticType' | 'logs' | 'signature' | 'weight'>, limit?: number, _options?: Configuration): Promise<DiagnosticSignaturesResponse> {
        const result = this.api.buildsDiagnosticSignaturesGetToManyRelated(id, filterDiagnosticType, fieldsDiagnosticSignatures, limit, _options);
        return result.toPromise();
    }

    /**
     * @param filterBetaAppReviewSubmissionBetaReviewState filter by attribute \&#39;betaAppReviewSubmission.betaReviewState\&#39;
     * @param filterBuildAudienceType filter by attribute \&#39;buildAudienceType\&#39;
     * @param filterExpired filter by attribute \&#39;expired\&#39;
     * @param filterPreReleaseVersionPlatform filter by attribute \&#39;preReleaseVersion.platform\&#39;
     * @param filterPreReleaseVersionVersion filter by attribute \&#39;preReleaseVersion.version\&#39;
     * @param filterProcessingState filter by attribute \&#39;processingState\&#39;
     * @param filterUsesNonExemptEncryption filter by attribute \&#39;usesNonExemptEncryption\&#39;
     * @param filterVersion filter by attribute \&#39;version\&#39;
     * @param filterApp filter by id(s) of related \&#39;app\&#39;
     * @param filterAppStoreVersion filter by id(s) of related \&#39;appStoreVersion\&#39;
     * @param filterBetaGroups filter by id(s) of related \&#39;betaGroups\&#39;
     * @param filterPreReleaseVersion filter by id(s) of related \&#39;preReleaseVersion\&#39;
     * @param filterId filter by id(s)
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsDiagnosticSignatures the fields to include for returned resources of type diagnosticSignatures
     * @param fieldsBuildIcons the fields to include for returned resources of type buildIcons
     * @param fieldsBuildBetaDetails the fields to include for returned resources of type buildBetaDetails
     * @param fieldsBetaAppReviewSubmissions the fields to include for returned resources of type betaAppReviewSubmissions
     * @param fieldsBetaTesters the fields to include for returned resources of type betaTesters
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsBetaBuildLocalizations the fields to include for returned resources of type betaBuildLocalizations
     * @param fieldsPreReleaseVersions the fields to include for returned resources of type preReleaseVersions
     * @param fieldsAppEncryptionDeclarations the fields to include for returned resources of type appEncryptionDeclarations
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsPerfPowerMetrics the fields to include for returned resources of type perfPowerMetrics
     * @param limitBetaBuildLocalizations maximum number of related betaBuildLocalizations returned (when they are included)
     * @param limitBetaGroups maximum number of related betaGroups returned (when they are included)
     * @param limitBuildBundles maximum number of related buildBundles returned (when they are included)
     * @param limitIcons maximum number of related icons returned (when they are included)
     * @param limitIndividualTesters maximum number of related individualTesters returned (when they are included)
     */
    public buildsGetCollectionWithHttpInfo(filterBetaAppReviewSubmissionBetaReviewState?: Array<'WAITING_FOR_REVIEW' | 'IN_REVIEW' | 'REJECTED' | 'APPROVED'>, filterBuildAudienceType?: Array<'INTERNAL_ONLY' | 'APP_STORE_ELIGIBLE'>, filterExpired?: Array<string>, filterPreReleaseVersionPlatform?: Array<'IOS' | 'MAC_OS' | 'TV_OS' | 'VISION_OS'>, filterPreReleaseVersionVersion?: Array<string>, filterProcessingState?: Array<'PROCESSING' | 'FAILED' | 'INVALID' | 'VALID'>, filterUsesNonExemptEncryption?: Array<string>, filterVersion?: Array<string>, filterApp?: Array<string>, filterAppStoreVersion?: Array<string>, filterBetaGroups?: Array<string>, filterPreReleaseVersion?: Array<string>, filterId?: Array<string>, sort?: Array<'preReleaseVersion' | '-preReleaseVersion' | 'uploadedDate' | '-uploadedDate' | 'version' | '-version'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, limit?: number, include?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildBetaDetail' | 'buildBundles' | 'icons' | 'individualTesters' | 'preReleaseVersion'>, fieldsDiagnosticSignatures?: Array<'diagnosticType' | 'logs' | 'signature' | 'weight'>, fieldsBuildIcons?: Array<'iconAsset' | 'iconType' | 'name'>, fieldsBuildBetaDetails?: Array<'autoNotifyEnabled' | 'build' | 'externalBuildState' | 'internalBuildState'>, fieldsBetaAppReviewSubmissions?: Array<'betaReviewState' | 'build' | 'submittedDate'>, fieldsBetaTesters?: Array<'apps' | 'betaGroups' | 'builds' | 'email' | 'firstName' | 'inviteType' | 'lastName'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsBetaBuildLocalizations?: Array<'build' | 'locale' | 'whatsNew'>, fieldsPreReleaseVersions?: Array<'app' | 'builds' | 'platform' | 'version'>, fieldsAppEncryptionDeclarations?: Array<'app' | 'appDescription' | 'appEncryptionDeclarationDocument' | 'appEncryptionDeclarationState' | 'availableOnFrenchStore' | 'builds' | 'codeValue' | 'containsProprietaryCryptography' | 'containsThirdPartyCryptography' | 'createdDate' | 'documentName' | 'documentType' | 'documentUrl' | 'exempt' | 'platform' | 'uploadedDate' | 'usesEncryption'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsPerfPowerMetrics?: Array<'deviceType' | 'metricType' | 'platform'>, limitBetaBuildLocalizations?: number, limitBetaGroups?: number, limitBuildBundles?: number, limitIcons?: number, limitIndividualTesters?: number, _options?: Configuration): Promise<HttpInfo<BuildsResponse>> {
        const result = this.api.buildsGetCollectionWithHttpInfo(filterBetaAppReviewSubmissionBetaReviewState, filterBuildAudienceType, filterExpired, filterPreReleaseVersionPlatform, filterPreReleaseVersionVersion, filterProcessingState, filterUsesNonExemptEncryption, filterVersion, filterApp, filterAppStoreVersion, filterBetaGroups, filterPreReleaseVersion, filterId, sort, fieldsBuilds, limit, include, fieldsDiagnosticSignatures, fieldsBuildIcons, fieldsBuildBetaDetails, fieldsBetaAppReviewSubmissions, fieldsBetaTesters, fieldsAppStoreVersions, fieldsBetaBuildLocalizations, fieldsPreReleaseVersions, fieldsAppEncryptionDeclarations, fieldsApps, fieldsPerfPowerMetrics, limitBetaBuildLocalizations, limitBetaGroups, limitBuildBundles, limitIcons, limitIndividualTesters, _options);
        return result.toPromise();
    }

    /**
     * @param filterBetaAppReviewSubmissionBetaReviewState filter by attribute \&#39;betaAppReviewSubmission.betaReviewState\&#39;
     * @param filterBuildAudienceType filter by attribute \&#39;buildAudienceType\&#39;
     * @param filterExpired filter by attribute \&#39;expired\&#39;
     * @param filterPreReleaseVersionPlatform filter by attribute \&#39;preReleaseVersion.platform\&#39;
     * @param filterPreReleaseVersionVersion filter by attribute \&#39;preReleaseVersion.version\&#39;
     * @param filterProcessingState filter by attribute \&#39;processingState\&#39;
     * @param filterUsesNonExemptEncryption filter by attribute \&#39;usesNonExemptEncryption\&#39;
     * @param filterVersion filter by attribute \&#39;version\&#39;
     * @param filterApp filter by id(s) of related \&#39;app\&#39;
     * @param filterAppStoreVersion filter by id(s) of related \&#39;appStoreVersion\&#39;
     * @param filterBetaGroups filter by id(s) of related \&#39;betaGroups\&#39;
     * @param filterPreReleaseVersion filter by id(s) of related \&#39;preReleaseVersion\&#39;
     * @param filterId filter by id(s)
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsDiagnosticSignatures the fields to include for returned resources of type diagnosticSignatures
     * @param fieldsBuildIcons the fields to include for returned resources of type buildIcons
     * @param fieldsBuildBetaDetails the fields to include for returned resources of type buildBetaDetails
     * @param fieldsBetaAppReviewSubmissions the fields to include for returned resources of type betaAppReviewSubmissions
     * @param fieldsBetaTesters the fields to include for returned resources of type betaTesters
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsBetaBuildLocalizations the fields to include for returned resources of type betaBuildLocalizations
     * @param fieldsPreReleaseVersions the fields to include for returned resources of type preReleaseVersions
     * @param fieldsAppEncryptionDeclarations the fields to include for returned resources of type appEncryptionDeclarations
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsPerfPowerMetrics the fields to include for returned resources of type perfPowerMetrics
     * @param limitBetaBuildLocalizations maximum number of related betaBuildLocalizations returned (when they are included)
     * @param limitBetaGroups maximum number of related betaGroups returned (when they are included)
     * @param limitBuildBundles maximum number of related buildBundles returned (when they are included)
     * @param limitIcons maximum number of related icons returned (when they are included)
     * @param limitIndividualTesters maximum number of related individualTesters returned (when they are included)
     */
    public buildsGetCollection(filterBetaAppReviewSubmissionBetaReviewState?: Array<'WAITING_FOR_REVIEW' | 'IN_REVIEW' | 'REJECTED' | 'APPROVED'>, filterBuildAudienceType?: Array<'INTERNAL_ONLY' | 'APP_STORE_ELIGIBLE'>, filterExpired?: Array<string>, filterPreReleaseVersionPlatform?: Array<'IOS' | 'MAC_OS' | 'TV_OS' | 'VISION_OS'>, filterPreReleaseVersionVersion?: Array<string>, filterProcessingState?: Array<'PROCESSING' | 'FAILED' | 'INVALID' | 'VALID'>, filterUsesNonExemptEncryption?: Array<string>, filterVersion?: Array<string>, filterApp?: Array<string>, filterAppStoreVersion?: Array<string>, filterBetaGroups?: Array<string>, filterPreReleaseVersion?: Array<string>, filterId?: Array<string>, sort?: Array<'preReleaseVersion' | '-preReleaseVersion' | 'uploadedDate' | '-uploadedDate' | 'version' | '-version'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, limit?: number, include?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildBetaDetail' | 'buildBundles' | 'icons' | 'individualTesters' | 'preReleaseVersion'>, fieldsDiagnosticSignatures?: Array<'diagnosticType' | 'logs' | 'signature' | 'weight'>, fieldsBuildIcons?: Array<'iconAsset' | 'iconType' | 'name'>, fieldsBuildBetaDetails?: Array<'autoNotifyEnabled' | 'build' | 'externalBuildState' | 'internalBuildState'>, fieldsBetaAppReviewSubmissions?: Array<'betaReviewState' | 'build' | 'submittedDate'>, fieldsBetaTesters?: Array<'apps' | 'betaGroups' | 'builds' | 'email' | 'firstName' | 'inviteType' | 'lastName'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsBetaBuildLocalizations?: Array<'build' | 'locale' | 'whatsNew'>, fieldsPreReleaseVersions?: Array<'app' | 'builds' | 'platform' | 'version'>, fieldsAppEncryptionDeclarations?: Array<'app' | 'appDescription' | 'appEncryptionDeclarationDocument' | 'appEncryptionDeclarationState' | 'availableOnFrenchStore' | 'builds' | 'codeValue' | 'containsProprietaryCryptography' | 'containsThirdPartyCryptography' | 'createdDate' | 'documentName' | 'documentType' | 'documentUrl' | 'exempt' | 'platform' | 'uploadedDate' | 'usesEncryption'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsPerfPowerMetrics?: Array<'deviceType' | 'metricType' | 'platform'>, limitBetaBuildLocalizations?: number, limitBetaGroups?: number, limitBuildBundles?: number, limitIcons?: number, limitIndividualTesters?: number, _options?: Configuration): Promise<BuildsResponse> {
        const result = this.api.buildsGetCollection(filterBetaAppReviewSubmissionBetaReviewState, filterBuildAudienceType, filterExpired, filterPreReleaseVersionPlatform, filterPreReleaseVersionVersion, filterProcessingState, filterUsesNonExemptEncryption, filterVersion, filterApp, filterAppStoreVersion, filterBetaGroups, filterPreReleaseVersion, filterId, sort, fieldsBuilds, limit, include, fieldsDiagnosticSignatures, fieldsBuildIcons, fieldsBuildBetaDetails, fieldsBetaAppReviewSubmissions, fieldsBetaTesters, fieldsAppStoreVersions, fieldsBetaBuildLocalizations, fieldsPreReleaseVersions, fieldsAppEncryptionDeclarations, fieldsApps, fieldsPerfPowerMetrics, limitBetaBuildLocalizations, limitBetaGroups, limitBuildBundles, limitIcons, limitIndividualTesters, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param include comma-separated list of relationships to include
     * @param fieldsDiagnosticSignatures the fields to include for returned resources of type diagnosticSignatures
     * @param fieldsBuildIcons the fields to include for returned resources of type buildIcons
     * @param fieldsBuildBetaDetails the fields to include for returned resources of type buildBetaDetails
     * @param fieldsBetaAppReviewSubmissions the fields to include for returned resources of type betaAppReviewSubmissions
     * @param fieldsBetaTesters the fields to include for returned resources of type betaTesters
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsBetaBuildLocalizations the fields to include for returned resources of type betaBuildLocalizations
     * @param fieldsPreReleaseVersions the fields to include for returned resources of type preReleaseVersions
     * @param fieldsAppEncryptionDeclarations the fields to include for returned resources of type appEncryptionDeclarations
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsPerfPowerMetrics the fields to include for returned resources of type perfPowerMetrics
     * @param limitBetaBuildLocalizations maximum number of related betaBuildLocalizations returned (when they are included)
     * @param limitBetaGroups maximum number of related betaGroups returned (when they are included)
     * @param limitBuildBundles maximum number of related buildBundles returned (when they are included)
     * @param limitIcons maximum number of related icons returned (when they are included)
     * @param limitIndividualTesters maximum number of related individualTesters returned (when they are included)
     */
    public buildsGetInstanceWithHttpInfo(id: string, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, include?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildBetaDetail' | 'buildBundles' | 'icons' | 'individualTesters' | 'preReleaseVersion'>, fieldsDiagnosticSignatures?: Array<'diagnosticType' | 'logs' | 'signature' | 'weight'>, fieldsBuildIcons?: Array<'iconAsset' | 'iconType' | 'name'>, fieldsBuildBetaDetails?: Array<'autoNotifyEnabled' | 'build' | 'externalBuildState' | 'internalBuildState'>, fieldsBetaAppReviewSubmissions?: Array<'betaReviewState' | 'build' | 'submittedDate'>, fieldsBetaTesters?: Array<'apps' | 'betaGroups' | 'builds' | 'email' | 'firstName' | 'inviteType' | 'lastName'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsBetaBuildLocalizations?: Array<'build' | 'locale' | 'whatsNew'>, fieldsPreReleaseVersions?: Array<'app' | 'builds' | 'platform' | 'version'>, fieldsAppEncryptionDeclarations?: Array<'app' | 'appDescription' | 'appEncryptionDeclarationDocument' | 'appEncryptionDeclarationState' | 'availableOnFrenchStore' | 'builds' | 'codeValue' | 'containsProprietaryCryptography' | 'containsThirdPartyCryptography' | 'createdDate' | 'documentName' | 'documentType' | 'documentUrl' | 'exempt' | 'platform' | 'uploadedDate' | 'usesEncryption'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsPerfPowerMetrics?: Array<'deviceType' | 'metricType' | 'platform'>, limitBetaBuildLocalizations?: number, limitBetaGroups?: number, limitBuildBundles?: number, limitIcons?: number, limitIndividualTesters?: number, _options?: Configuration): Promise<HttpInfo<BuildResponse>> {
        const result = this.api.buildsGetInstanceWithHttpInfo(id, fieldsBuilds, include, fieldsDiagnosticSignatures, fieldsBuildIcons, fieldsBuildBetaDetails, fieldsBetaAppReviewSubmissions, fieldsBetaTesters, fieldsAppStoreVersions, fieldsBetaBuildLocalizations, fieldsPreReleaseVersions, fieldsAppEncryptionDeclarations, fieldsApps, fieldsPerfPowerMetrics, limitBetaBuildLocalizations, limitBetaGroups, limitBuildBundles, limitIcons, limitIndividualTesters, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param include comma-separated list of relationships to include
     * @param fieldsDiagnosticSignatures the fields to include for returned resources of type diagnosticSignatures
     * @param fieldsBuildIcons the fields to include for returned resources of type buildIcons
     * @param fieldsBuildBetaDetails the fields to include for returned resources of type buildBetaDetails
     * @param fieldsBetaAppReviewSubmissions the fields to include for returned resources of type betaAppReviewSubmissions
     * @param fieldsBetaTesters the fields to include for returned resources of type betaTesters
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsBetaBuildLocalizations the fields to include for returned resources of type betaBuildLocalizations
     * @param fieldsPreReleaseVersions the fields to include for returned resources of type preReleaseVersions
     * @param fieldsAppEncryptionDeclarations the fields to include for returned resources of type appEncryptionDeclarations
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsPerfPowerMetrics the fields to include for returned resources of type perfPowerMetrics
     * @param limitBetaBuildLocalizations maximum number of related betaBuildLocalizations returned (when they are included)
     * @param limitBetaGroups maximum number of related betaGroups returned (when they are included)
     * @param limitBuildBundles maximum number of related buildBundles returned (when they are included)
     * @param limitIcons maximum number of related icons returned (when they are included)
     * @param limitIndividualTesters maximum number of related individualTesters returned (when they are included)
     */
    public buildsGetInstance(id: string, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, include?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildBetaDetail' | 'buildBundles' | 'icons' | 'individualTesters' | 'preReleaseVersion'>, fieldsDiagnosticSignatures?: Array<'diagnosticType' | 'logs' | 'signature' | 'weight'>, fieldsBuildIcons?: Array<'iconAsset' | 'iconType' | 'name'>, fieldsBuildBetaDetails?: Array<'autoNotifyEnabled' | 'build' | 'externalBuildState' | 'internalBuildState'>, fieldsBetaAppReviewSubmissions?: Array<'betaReviewState' | 'build' | 'submittedDate'>, fieldsBetaTesters?: Array<'apps' | 'betaGroups' | 'builds' | 'email' | 'firstName' | 'inviteType' | 'lastName'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsBetaBuildLocalizations?: Array<'build' | 'locale' | 'whatsNew'>, fieldsPreReleaseVersions?: Array<'app' | 'builds' | 'platform' | 'version'>, fieldsAppEncryptionDeclarations?: Array<'app' | 'appDescription' | 'appEncryptionDeclarationDocument' | 'appEncryptionDeclarationState' | 'availableOnFrenchStore' | 'builds' | 'codeValue' | 'containsProprietaryCryptography' | 'containsThirdPartyCryptography' | 'createdDate' | 'documentName' | 'documentType' | 'documentUrl' | 'exempt' | 'platform' | 'uploadedDate' | 'usesEncryption'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsPerfPowerMetrics?: Array<'deviceType' | 'metricType' | 'platform'>, limitBetaBuildLocalizations?: number, limitBetaGroups?: number, limitBuildBundles?: number, limitIcons?: number, limitIndividualTesters?: number, _options?: Configuration): Promise<BuildResponse> {
        const result = this.api.buildsGetInstance(id, fieldsBuilds, include, fieldsDiagnosticSignatures, fieldsBuildIcons, fieldsBuildBetaDetails, fieldsBetaAppReviewSubmissions, fieldsBetaTesters, fieldsAppStoreVersions, fieldsBetaBuildLocalizations, fieldsPreReleaseVersions, fieldsAppEncryptionDeclarations, fieldsApps, fieldsPerfPowerMetrics, limitBetaBuildLocalizations, limitBetaGroups, limitBuildBundles, limitIcons, limitIndividualTesters, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBuildIcons the fields to include for returned resources of type buildIcons
     * @param limit maximum resources per page
     */
    public buildsIconsGetToManyRelatedWithHttpInfo(id: string, fieldsBuildIcons?: Array<'iconAsset' | 'iconType' | 'name'>, limit?: number, _options?: Configuration): Promise<HttpInfo<BuildIconsWithoutIncludesResponse>> {
        const result = this.api.buildsIconsGetToManyRelatedWithHttpInfo(id, fieldsBuildIcons, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBuildIcons the fields to include for returned resources of type buildIcons
     * @param limit maximum resources per page
     */
    public buildsIconsGetToManyRelated(id: string, fieldsBuildIcons?: Array<'iconAsset' | 'iconType' | 'name'>, limit?: number, _options?: Configuration): Promise<BuildIconsWithoutIncludesResponse> {
        const result = this.api.buildsIconsGetToManyRelated(id, fieldsBuildIcons, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param buildIndividualTestersLinkagesRequest List of related linkages
     */
    public buildsIndividualTestersCreateToManyRelationshipWithHttpInfo(id: string, buildIndividualTestersLinkagesRequest: BuildIndividualTestersLinkagesRequest, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.buildsIndividualTestersCreateToManyRelationshipWithHttpInfo(id, buildIndividualTestersLinkagesRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param buildIndividualTestersLinkagesRequest List of related linkages
     */
    public buildsIndividualTestersCreateToManyRelationship(id: string, buildIndividualTestersLinkagesRequest: BuildIndividualTestersLinkagesRequest, _options?: Configuration): Promise<void> {
        const result = this.api.buildsIndividualTestersCreateToManyRelationship(id, buildIndividualTestersLinkagesRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param buildIndividualTestersLinkagesRequest List of related linkages
     */
    public buildsIndividualTestersDeleteToManyRelationshipWithHttpInfo(id: string, buildIndividualTestersLinkagesRequest: BuildIndividualTestersLinkagesRequest, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.buildsIndividualTestersDeleteToManyRelationshipWithHttpInfo(id, buildIndividualTestersLinkagesRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param buildIndividualTestersLinkagesRequest List of related linkages
     */
    public buildsIndividualTestersDeleteToManyRelationship(id: string, buildIndividualTestersLinkagesRequest: BuildIndividualTestersLinkagesRequest, _options?: Configuration): Promise<void> {
        const result = this.api.buildsIndividualTestersDeleteToManyRelationship(id, buildIndividualTestersLinkagesRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBetaTesters the fields to include for returned resources of type betaTesters
     * @param limit maximum resources per page
     */
    public buildsIndividualTestersGetToManyRelatedWithHttpInfo(id: string, fieldsBetaTesters?: Array<'apps' | 'betaGroups' | 'builds' | 'email' | 'firstName' | 'inviteType' | 'lastName'>, limit?: number, _options?: Configuration): Promise<HttpInfo<BetaTestersWithoutIncludesResponse>> {
        const result = this.api.buildsIndividualTestersGetToManyRelatedWithHttpInfo(id, fieldsBetaTesters, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBetaTesters the fields to include for returned resources of type betaTesters
     * @param limit maximum resources per page
     */
    public buildsIndividualTestersGetToManyRelated(id: string, fieldsBetaTesters?: Array<'apps' | 'betaGroups' | 'builds' | 'email' | 'firstName' | 'inviteType' | 'lastName'>, limit?: number, _options?: Configuration): Promise<BetaTestersWithoutIncludesResponse> {
        const result = this.api.buildsIndividualTestersGetToManyRelated(id, fieldsBetaTesters, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public buildsIndividualTestersGetToManyRelationshipWithHttpInfo(id: string, limit?: number, _options?: Configuration): Promise<HttpInfo<BuildIndividualTestersLinkagesResponse>> {
        const result = this.api.buildsIndividualTestersGetToManyRelationshipWithHttpInfo(id, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public buildsIndividualTestersGetToManyRelationship(id: string, limit?: number, _options?: Configuration): Promise<BuildIndividualTestersLinkagesResponse> {
        const result = this.api.buildsIndividualTestersGetToManyRelationship(id, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterDeviceType filter by attribute \&#39;deviceType\&#39;
     * @param filterMetricType filter by attribute \&#39;metricType\&#39;
     * @param filterPlatform filter by attribute \&#39;platform\&#39;
     */
    public buildsPerfPowerMetricsGetToManyRelatedWithHttpInfo(id: string, filterDeviceType?: Array<string>, filterMetricType?: Array<'DISK' | 'HANG' | 'BATTERY' | 'LAUNCH' | 'MEMORY' | 'ANIMATION' | 'TERMINATION'>, filterPlatform?: Array<'IOS'>, _options?: Configuration): Promise<HttpInfo<XcodeMetrics>> {
        const result = this.api.buildsPerfPowerMetricsGetToManyRelatedWithHttpInfo(id, filterDeviceType, filterMetricType, filterPlatform, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterDeviceType filter by attribute \&#39;deviceType\&#39;
     * @param filterMetricType filter by attribute \&#39;metricType\&#39;
     * @param filterPlatform filter by attribute \&#39;platform\&#39;
     */
    public buildsPerfPowerMetricsGetToManyRelated(id: string, filterDeviceType?: Array<string>, filterMetricType?: Array<'DISK' | 'HANG' | 'BATTERY' | 'LAUNCH' | 'MEMORY' | 'ANIMATION' | 'TERMINATION'>, filterPlatform?: Array<'IOS'>, _options?: Configuration): Promise<XcodeMetrics> {
        const result = this.api.buildsPerfPowerMetricsGetToManyRelated(id, filterDeviceType, filterMetricType, filterPlatform, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsPreReleaseVersions the fields to include for returned resources of type preReleaseVersions
     */
    public buildsPreReleaseVersionGetToOneRelatedWithHttpInfo(id: string, fieldsPreReleaseVersions?: Array<'app' | 'builds' | 'platform' | 'version'>, _options?: Configuration): Promise<HttpInfo<PrereleaseVersionWithoutIncludesResponse>> {
        const result = this.api.buildsPreReleaseVersionGetToOneRelatedWithHttpInfo(id, fieldsPreReleaseVersions, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsPreReleaseVersions the fields to include for returned resources of type preReleaseVersions
     */
    public buildsPreReleaseVersionGetToOneRelated(id: string, fieldsPreReleaseVersions?: Array<'app' | 'builds' | 'platform' | 'version'>, _options?: Configuration): Promise<PrereleaseVersionWithoutIncludesResponse> {
        const result = this.api.buildsPreReleaseVersionGetToOneRelated(id, fieldsPreReleaseVersions, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param buildUpdateRequest Build representation
     */
    public buildsUpdateInstanceWithHttpInfo(id: string, buildUpdateRequest: BuildUpdateRequest, _options?: Configuration): Promise<HttpInfo<BuildResponse>> {
        const result = this.api.buildsUpdateInstanceWithHttpInfo(id, buildUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param buildUpdateRequest Build representation
     */
    public buildsUpdateInstance(id: string, buildUpdateRequest: BuildUpdateRequest, _options?: Configuration): Promise<BuildResponse> {
        const result = this.api.buildsUpdateInstance(id, buildUpdateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableBundleIdCapabilitiesApi } from './ObservableAPI.ts';

import { BundleIdCapabilitiesApiRequestFactory, BundleIdCapabilitiesApiResponseProcessor} from "../apis/BundleIdCapabilitiesApi.ts";
export class PromiseBundleIdCapabilitiesApi {
    private api: ObservableBundleIdCapabilitiesApi

    public constructor(
        configuration: Configuration,
        requestFactory?: BundleIdCapabilitiesApiRequestFactory,
        responseProcessor?: BundleIdCapabilitiesApiResponseProcessor
    ) {
        this.api = new ObservableBundleIdCapabilitiesApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param bundleIdCapabilityCreateRequest BundleIdCapability representation
     */
    public bundleIdCapabilitiesCreateInstanceWithHttpInfo(bundleIdCapabilityCreateRequest: BundleIdCapabilityCreateRequest, _options?: Configuration): Promise<HttpInfo<BundleIdCapabilityResponse>> {
        const result = this.api.bundleIdCapabilitiesCreateInstanceWithHttpInfo(bundleIdCapabilityCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param bundleIdCapabilityCreateRequest BundleIdCapability representation
     */
    public bundleIdCapabilitiesCreateInstance(bundleIdCapabilityCreateRequest: BundleIdCapabilityCreateRequest, _options?: Configuration): Promise<BundleIdCapabilityResponse> {
        const result = this.api.bundleIdCapabilitiesCreateInstance(bundleIdCapabilityCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public bundleIdCapabilitiesDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.bundleIdCapabilitiesDeleteInstanceWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public bundleIdCapabilitiesDeleteInstance(id: string, _options?: Configuration): Promise<void> {
        const result = this.api.bundleIdCapabilitiesDeleteInstance(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param bundleIdCapabilityUpdateRequest BundleIdCapability representation
     */
    public bundleIdCapabilitiesUpdateInstanceWithHttpInfo(id: string, bundleIdCapabilityUpdateRequest: BundleIdCapabilityUpdateRequest, _options?: Configuration): Promise<HttpInfo<BundleIdCapabilityResponse>> {
        const result = this.api.bundleIdCapabilitiesUpdateInstanceWithHttpInfo(id, bundleIdCapabilityUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param bundleIdCapabilityUpdateRequest BundleIdCapability representation
     */
    public bundleIdCapabilitiesUpdateInstance(id: string, bundleIdCapabilityUpdateRequest: BundleIdCapabilityUpdateRequest, _options?: Configuration): Promise<BundleIdCapabilityResponse> {
        const result = this.api.bundleIdCapabilitiesUpdateInstance(id, bundleIdCapabilityUpdateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableBundleIdsApi } from './ObservableAPI.ts';

import { BundleIdsApiRequestFactory, BundleIdsApiResponseProcessor} from "../apis/BundleIdsApi.ts";
export class PromiseBundleIdsApi {
    private api: ObservableBundleIdsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: BundleIdsApiRequestFactory,
        responseProcessor?: BundleIdsApiResponseProcessor
    ) {
        this.api = new ObservableBundleIdsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsApps the fields to include for returned resources of type apps
     */
    public bundleIdsAppGetToOneRelatedWithHttpInfo(id: string, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, _options?: Configuration): Promise<HttpInfo<AppWithoutIncludesResponse>> {
        const result = this.api.bundleIdsAppGetToOneRelatedWithHttpInfo(id, fieldsApps, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsApps the fields to include for returned resources of type apps
     */
    public bundleIdsAppGetToOneRelated(id: string, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, _options?: Configuration): Promise<AppWithoutIncludesResponse> {
        const result = this.api.bundleIdsAppGetToOneRelated(id, fieldsApps, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBundleIdCapabilities the fields to include for returned resources of type bundleIdCapabilities
     * @param limit maximum resources per page
     */
    public bundleIdsBundleIdCapabilitiesGetToManyRelatedWithHttpInfo(id: string, fieldsBundleIdCapabilities?: Array<'bundleId' | 'capabilityType' | 'settings'>, limit?: number, _options?: Configuration): Promise<HttpInfo<BundleIdCapabilitiesWithoutIncludesResponse>> {
        const result = this.api.bundleIdsBundleIdCapabilitiesGetToManyRelatedWithHttpInfo(id, fieldsBundleIdCapabilities, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBundleIdCapabilities the fields to include for returned resources of type bundleIdCapabilities
     * @param limit maximum resources per page
     */
    public bundleIdsBundleIdCapabilitiesGetToManyRelated(id: string, fieldsBundleIdCapabilities?: Array<'bundleId' | 'capabilityType' | 'settings'>, limit?: number, _options?: Configuration): Promise<BundleIdCapabilitiesWithoutIncludesResponse> {
        const result = this.api.bundleIdsBundleIdCapabilitiesGetToManyRelated(id, fieldsBundleIdCapabilities, limit, _options);
        return result.toPromise();
    }

    /**
     * @param bundleIdCreateRequest BundleId representation
     */
    public bundleIdsCreateInstanceWithHttpInfo(bundleIdCreateRequest: BundleIdCreateRequest, _options?: Configuration): Promise<HttpInfo<BundleIdResponse>> {
        const result = this.api.bundleIdsCreateInstanceWithHttpInfo(bundleIdCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param bundleIdCreateRequest BundleId representation
     */
    public bundleIdsCreateInstance(bundleIdCreateRequest: BundleIdCreateRequest, _options?: Configuration): Promise<BundleIdResponse> {
        const result = this.api.bundleIdsCreateInstance(bundleIdCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public bundleIdsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.bundleIdsDeleteInstanceWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public bundleIdsDeleteInstance(id: string, _options?: Configuration): Promise<void> {
        const result = this.api.bundleIdsDeleteInstance(id, _options);
        return result.toPromise();
    }

    /**
     * @param filterIdentifier filter by attribute \&#39;identifier\&#39;
     * @param filterName filter by attribute \&#39;name\&#39;
     * @param filterPlatform filter by attribute \&#39;platform\&#39;
     * @param filterSeedId filter by attribute \&#39;seedId\&#39;
     * @param filterId filter by id(s)
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsBundleIds the fields to include for returned resources of type bundleIds
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsBundleIdCapabilities the fields to include for returned resources of type bundleIdCapabilities
     * @param fieldsProfiles the fields to include for returned resources of type profiles
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param limitBundleIdCapabilities maximum number of related bundleIdCapabilities returned (when they are included)
     * @param limitProfiles maximum number of related profiles returned (when they are included)
     */
    public bundleIdsGetCollectionWithHttpInfo(filterIdentifier?: Array<string>, filterName?: Array<string>, filterPlatform?: Array<'IOS' | 'MAC_OS'>, filterSeedId?: Array<string>, filterId?: Array<string>, sort?: Array<'id' | '-id' | 'identifier' | '-identifier' | 'name' | '-name' | 'platform' | '-platform' | 'seedId' | '-seedId'>, fieldsBundleIds?: Array<'app' | 'bundleIdCapabilities' | 'identifier' | 'name' | 'platform' | 'profiles' | 'seedId'>, limit?: number, include?: Array<'app' | 'bundleIdCapabilities' | 'profiles'>, fieldsBundleIdCapabilities?: Array<'bundleId' | 'capabilityType' | 'settings'>, fieldsProfiles?: Array<'bundleId' | 'certificates' | 'createdDate' | 'devices' | 'expirationDate' | 'name' | 'platform' | 'profileContent' | 'profileState' | 'profileType' | 'uuid'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, limitBundleIdCapabilities?: number, limitProfiles?: number, _options?: Configuration): Promise<HttpInfo<BundleIdsResponse>> {
        const result = this.api.bundleIdsGetCollectionWithHttpInfo(filterIdentifier, filterName, filterPlatform, filterSeedId, filterId, sort, fieldsBundleIds, limit, include, fieldsBundleIdCapabilities, fieldsProfiles, fieldsApps, limitBundleIdCapabilities, limitProfiles, _options);
        return result.toPromise();
    }

    /**
     * @param filterIdentifier filter by attribute \&#39;identifier\&#39;
     * @param filterName filter by attribute \&#39;name\&#39;
     * @param filterPlatform filter by attribute \&#39;platform\&#39;
     * @param filterSeedId filter by attribute \&#39;seedId\&#39;
     * @param filterId filter by id(s)
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsBundleIds the fields to include for returned resources of type bundleIds
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsBundleIdCapabilities the fields to include for returned resources of type bundleIdCapabilities
     * @param fieldsProfiles the fields to include for returned resources of type profiles
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param limitBundleIdCapabilities maximum number of related bundleIdCapabilities returned (when they are included)
     * @param limitProfiles maximum number of related profiles returned (when they are included)
     */
    public bundleIdsGetCollection(filterIdentifier?: Array<string>, filterName?: Array<string>, filterPlatform?: Array<'IOS' | 'MAC_OS'>, filterSeedId?: Array<string>, filterId?: Array<string>, sort?: Array<'id' | '-id' | 'identifier' | '-identifier' | 'name' | '-name' | 'platform' | '-platform' | 'seedId' | '-seedId'>, fieldsBundleIds?: Array<'app' | 'bundleIdCapabilities' | 'identifier' | 'name' | 'platform' | 'profiles' | 'seedId'>, limit?: number, include?: Array<'app' | 'bundleIdCapabilities' | 'profiles'>, fieldsBundleIdCapabilities?: Array<'bundleId' | 'capabilityType' | 'settings'>, fieldsProfiles?: Array<'bundleId' | 'certificates' | 'createdDate' | 'devices' | 'expirationDate' | 'name' | 'platform' | 'profileContent' | 'profileState' | 'profileType' | 'uuid'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, limitBundleIdCapabilities?: number, limitProfiles?: number, _options?: Configuration): Promise<BundleIdsResponse> {
        const result = this.api.bundleIdsGetCollection(filterIdentifier, filterName, filterPlatform, filterSeedId, filterId, sort, fieldsBundleIds, limit, include, fieldsBundleIdCapabilities, fieldsProfiles, fieldsApps, limitBundleIdCapabilities, limitProfiles, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBundleIds the fields to include for returned resources of type bundleIds
     * @param include comma-separated list of relationships to include
     * @param fieldsBundleIdCapabilities the fields to include for returned resources of type bundleIdCapabilities
     * @param fieldsProfiles the fields to include for returned resources of type profiles
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param limitBundleIdCapabilities maximum number of related bundleIdCapabilities returned (when they are included)
     * @param limitProfiles maximum number of related profiles returned (when they are included)
     */
    public bundleIdsGetInstanceWithHttpInfo(id: string, fieldsBundleIds?: Array<'app' | 'bundleIdCapabilities' | 'identifier' | 'name' | 'platform' | 'profiles' | 'seedId'>, include?: Array<'app' | 'bundleIdCapabilities' | 'profiles'>, fieldsBundleIdCapabilities?: Array<'bundleId' | 'capabilityType' | 'settings'>, fieldsProfiles?: Array<'bundleId' | 'certificates' | 'createdDate' | 'devices' | 'expirationDate' | 'name' | 'platform' | 'profileContent' | 'profileState' | 'profileType' | 'uuid'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, limitBundleIdCapabilities?: number, limitProfiles?: number, _options?: Configuration): Promise<HttpInfo<BundleIdResponse>> {
        const result = this.api.bundleIdsGetInstanceWithHttpInfo(id, fieldsBundleIds, include, fieldsBundleIdCapabilities, fieldsProfiles, fieldsApps, limitBundleIdCapabilities, limitProfiles, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBundleIds the fields to include for returned resources of type bundleIds
     * @param include comma-separated list of relationships to include
     * @param fieldsBundleIdCapabilities the fields to include for returned resources of type bundleIdCapabilities
     * @param fieldsProfiles the fields to include for returned resources of type profiles
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param limitBundleIdCapabilities maximum number of related bundleIdCapabilities returned (when they are included)
     * @param limitProfiles maximum number of related profiles returned (when they are included)
     */
    public bundleIdsGetInstance(id: string, fieldsBundleIds?: Array<'app' | 'bundleIdCapabilities' | 'identifier' | 'name' | 'platform' | 'profiles' | 'seedId'>, include?: Array<'app' | 'bundleIdCapabilities' | 'profiles'>, fieldsBundleIdCapabilities?: Array<'bundleId' | 'capabilityType' | 'settings'>, fieldsProfiles?: Array<'bundleId' | 'certificates' | 'createdDate' | 'devices' | 'expirationDate' | 'name' | 'platform' | 'profileContent' | 'profileState' | 'profileType' | 'uuid'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, limitBundleIdCapabilities?: number, limitProfiles?: number, _options?: Configuration): Promise<BundleIdResponse> {
        const result = this.api.bundleIdsGetInstance(id, fieldsBundleIds, include, fieldsBundleIdCapabilities, fieldsProfiles, fieldsApps, limitBundleIdCapabilities, limitProfiles, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsProfiles the fields to include for returned resources of type profiles
     * @param limit maximum resources per page
     */
    public bundleIdsProfilesGetToManyRelatedWithHttpInfo(id: string, fieldsProfiles?: Array<'bundleId' | 'certificates' | 'createdDate' | 'devices' | 'expirationDate' | 'name' | 'platform' | 'profileContent' | 'profileState' | 'profileType' | 'uuid'>, limit?: number, _options?: Configuration): Promise<HttpInfo<ProfilesWithoutIncludesResponse>> {
        const result = this.api.bundleIdsProfilesGetToManyRelatedWithHttpInfo(id, fieldsProfiles, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsProfiles the fields to include for returned resources of type profiles
     * @param limit maximum resources per page
     */
    public bundleIdsProfilesGetToManyRelated(id: string, fieldsProfiles?: Array<'bundleId' | 'certificates' | 'createdDate' | 'devices' | 'expirationDate' | 'name' | 'platform' | 'profileContent' | 'profileState' | 'profileType' | 'uuid'>, limit?: number, _options?: Configuration): Promise<ProfilesWithoutIncludesResponse> {
        const result = this.api.bundleIdsProfilesGetToManyRelated(id, fieldsProfiles, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param bundleIdUpdateRequest BundleId representation
     */
    public bundleIdsUpdateInstanceWithHttpInfo(id: string, bundleIdUpdateRequest: BundleIdUpdateRequest, _options?: Configuration): Promise<HttpInfo<BundleIdResponse>> {
        const result = this.api.bundleIdsUpdateInstanceWithHttpInfo(id, bundleIdUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param bundleIdUpdateRequest BundleId representation
     */
    public bundleIdsUpdateInstance(id: string, bundleIdUpdateRequest: BundleIdUpdateRequest, _options?: Configuration): Promise<BundleIdResponse> {
        const result = this.api.bundleIdsUpdateInstance(id, bundleIdUpdateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableCertificatesApi } from './ObservableAPI.ts';

import { CertificatesApiRequestFactory, CertificatesApiResponseProcessor} from "../apis/CertificatesApi.ts";
export class PromiseCertificatesApi {
    private api: ObservableCertificatesApi

    public constructor(
        configuration: Configuration,
        requestFactory?: CertificatesApiRequestFactory,
        responseProcessor?: CertificatesApiResponseProcessor
    ) {
        this.api = new ObservableCertificatesApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param certificateCreateRequest Certificate representation
     */
    public certificatesCreateInstanceWithHttpInfo(certificateCreateRequest: CertificateCreateRequest, _options?: Configuration): Promise<HttpInfo<CertificateResponse>> {
        const result = this.api.certificatesCreateInstanceWithHttpInfo(certificateCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param certificateCreateRequest Certificate representation
     */
    public certificatesCreateInstance(certificateCreateRequest: CertificateCreateRequest, _options?: Configuration): Promise<CertificateResponse> {
        const result = this.api.certificatesCreateInstance(certificateCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public certificatesDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.certificatesDeleteInstanceWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public certificatesDeleteInstance(id: string, _options?: Configuration): Promise<void> {
        const result = this.api.certificatesDeleteInstance(id, _options);
        return result.toPromise();
    }

    /**
     * @param filterCertificateType filter by attribute \&#39;certificateType\&#39;
     * @param filterDisplayName filter by attribute \&#39;displayName\&#39;
     * @param filterSerialNumber filter by attribute \&#39;serialNumber\&#39;
     * @param filterId filter by id(s)
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsCertificates the fields to include for returned resources of type certificates
     * @param limit maximum resources per page
     */
    public certificatesGetCollectionWithHttpInfo(filterCertificateType?: Array<'IOS_DEVELOPMENT' | 'IOS_DISTRIBUTION' | 'MAC_APP_DISTRIBUTION' | 'MAC_INSTALLER_DISTRIBUTION' | 'MAC_APP_DEVELOPMENT' | 'DEVELOPER_ID_KEXT' | 'DEVELOPER_ID_APPLICATION' | 'DEVELOPMENT' | 'DISTRIBUTION' | 'PASS_TYPE_ID' | 'PASS_TYPE_ID_WITH_NFC'>, filterDisplayName?: Array<string>, filterSerialNumber?: Array<string>, filterId?: Array<string>, sort?: Array<'certificateType' | '-certificateType' | 'displayName' | '-displayName' | 'id' | '-id' | 'serialNumber' | '-serialNumber'>, fieldsCertificates?: Array<'certificateContent' | 'certificateType' | 'csrContent' | 'displayName' | 'expirationDate' | 'name' | 'platform' | 'serialNumber'>, limit?: number, _options?: Configuration): Promise<HttpInfo<CertificatesResponse>> {
        const result = this.api.certificatesGetCollectionWithHttpInfo(filterCertificateType, filterDisplayName, filterSerialNumber, filterId, sort, fieldsCertificates, limit, _options);
        return result.toPromise();
    }

    /**
     * @param filterCertificateType filter by attribute \&#39;certificateType\&#39;
     * @param filterDisplayName filter by attribute \&#39;displayName\&#39;
     * @param filterSerialNumber filter by attribute \&#39;serialNumber\&#39;
     * @param filterId filter by id(s)
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsCertificates the fields to include for returned resources of type certificates
     * @param limit maximum resources per page
     */
    public certificatesGetCollection(filterCertificateType?: Array<'IOS_DEVELOPMENT' | 'IOS_DISTRIBUTION' | 'MAC_APP_DISTRIBUTION' | 'MAC_INSTALLER_DISTRIBUTION' | 'MAC_APP_DEVELOPMENT' | 'DEVELOPER_ID_KEXT' | 'DEVELOPER_ID_APPLICATION' | 'DEVELOPMENT' | 'DISTRIBUTION' | 'PASS_TYPE_ID' | 'PASS_TYPE_ID_WITH_NFC'>, filterDisplayName?: Array<string>, filterSerialNumber?: Array<string>, filterId?: Array<string>, sort?: Array<'certificateType' | '-certificateType' | 'displayName' | '-displayName' | 'id' | '-id' | 'serialNumber' | '-serialNumber'>, fieldsCertificates?: Array<'certificateContent' | 'certificateType' | 'csrContent' | 'displayName' | 'expirationDate' | 'name' | 'platform' | 'serialNumber'>, limit?: number, _options?: Configuration): Promise<CertificatesResponse> {
        const result = this.api.certificatesGetCollection(filterCertificateType, filterDisplayName, filterSerialNumber, filterId, sort, fieldsCertificates, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCertificates the fields to include for returned resources of type certificates
     */
    public certificatesGetInstanceWithHttpInfo(id: string, fieldsCertificates?: Array<'certificateContent' | 'certificateType' | 'csrContent' | 'displayName' | 'expirationDate' | 'name' | 'platform' | 'serialNumber'>, _options?: Configuration): Promise<HttpInfo<CertificateResponse>> {
        const result = this.api.certificatesGetInstanceWithHttpInfo(id, fieldsCertificates, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCertificates the fields to include for returned resources of type certificates
     */
    public certificatesGetInstance(id: string, fieldsCertificates?: Array<'certificateContent' | 'certificateType' | 'csrContent' | 'displayName' | 'expirationDate' | 'name' | 'platform' | 'serialNumber'>, _options?: Configuration): Promise<CertificateResponse> {
        const result = this.api.certificatesGetInstance(id, fieldsCertificates, _options);
        return result.toPromise();
    }


}



import { ObservableCiArtifactsApi } from './ObservableAPI.ts';

import { CiArtifactsApiRequestFactory, CiArtifactsApiResponseProcessor} from "../apis/CiArtifactsApi.ts";
export class PromiseCiArtifactsApi {
    private api: ObservableCiArtifactsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: CiArtifactsApiRequestFactory,
        responseProcessor?: CiArtifactsApiResponseProcessor
    ) {
        this.api = new ObservableCiArtifactsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCiArtifacts the fields to include for returned resources of type ciArtifacts
     */
    public ciArtifactsGetInstanceWithHttpInfo(id: string, fieldsCiArtifacts?: Array<'downloadUrl' | 'fileName' | 'fileSize' | 'fileType'>, _options?: Configuration): Promise<HttpInfo<CiArtifactResponse>> {
        const result = this.api.ciArtifactsGetInstanceWithHttpInfo(id, fieldsCiArtifacts, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCiArtifacts the fields to include for returned resources of type ciArtifacts
     */
    public ciArtifactsGetInstance(id: string, fieldsCiArtifacts?: Array<'downloadUrl' | 'fileName' | 'fileSize' | 'fileType'>, _options?: Configuration): Promise<CiArtifactResponse> {
        const result = this.api.ciArtifactsGetInstance(id, fieldsCiArtifacts, _options);
        return result.toPromise();
    }


}



import { ObservableCiBuildActionsApi } from './ObservableAPI.ts';

import { CiBuildActionsApiRequestFactory, CiBuildActionsApiResponseProcessor} from "../apis/CiBuildActionsApi.ts";
export class PromiseCiBuildActionsApi {
    private api: ObservableCiBuildActionsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: CiBuildActionsApiRequestFactory,
        responseProcessor?: CiBuildActionsApiResponseProcessor
    ) {
        this.api = new ObservableCiBuildActionsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCiArtifacts the fields to include for returned resources of type ciArtifacts
     * @param limit maximum resources per page
     */
    public ciBuildActionsArtifactsGetToManyRelatedWithHttpInfo(id: string, fieldsCiArtifacts?: Array<'downloadUrl' | 'fileName' | 'fileSize' | 'fileType'>, limit?: number, _options?: Configuration): Promise<HttpInfo<CiArtifactsResponse>> {
        const result = this.api.ciBuildActionsArtifactsGetToManyRelatedWithHttpInfo(id, fieldsCiArtifacts, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCiArtifacts the fields to include for returned resources of type ciArtifacts
     * @param limit maximum resources per page
     */
    public ciBuildActionsArtifactsGetToManyRelated(id: string, fieldsCiArtifacts?: Array<'downloadUrl' | 'fileName' | 'fileSize' | 'fileType'>, limit?: number, _options?: Configuration): Promise<CiArtifactsResponse> {
        const result = this.api.ciBuildActionsArtifactsGetToManyRelated(id, fieldsCiArtifacts, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsScmGitReferences the fields to include for returned resources of type scmGitReferences
     * @param fieldsCiBuildRuns the fields to include for returned resources of type ciBuildRuns
     * @param fieldsCiWorkflows the fields to include for returned resources of type ciWorkflows
     * @param fieldsScmPullRequests the fields to include for returned resources of type scmPullRequests
     * @param fieldsCiProducts the fields to include for returned resources of type ciProducts
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param limitBuilds maximum number of related builds returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public ciBuildActionsBuildRunGetToOneRelatedWithHttpInfo(id: string, fieldsScmGitReferences?: Array<'canonicalName' | 'isDeleted' | 'kind' | 'name' | 'repository'>, fieldsCiBuildRuns?: Array<'actions' | 'buildRun' | 'builds' | 'cancelReason' | 'clean' | 'completionStatus' | 'createdDate' | 'destinationBranch' | 'destinationCommit' | 'executionProgress' | 'finishedDate' | 'isPullRequestBuild' | 'issueCounts' | 'number' | 'product' | 'pullRequest' | 'sourceBranchOrTag' | 'sourceCommit' | 'startReason' | 'startedDate' | 'workflow'>, fieldsCiWorkflows?: Array<'actions' | 'branchStartCondition' | 'buildRuns' | 'clean' | 'containerFilePath' | 'description' | 'isEnabled' | 'isLockedForEditing' | 'lastModifiedDate' | 'macOsVersion' | 'manualBranchStartCondition' | 'manualPullRequestStartCondition' | 'manualTagStartCondition' | 'name' | 'product' | 'pullRequestStartCondition' | 'repository' | 'scheduledStartCondition' | 'tagStartCondition' | 'xcodeVersion'>, fieldsScmPullRequests?: Array<'destinationBranchName' | 'destinationRepositoryName' | 'destinationRepositoryOwner' | 'isClosed' | 'isCrossRepository' | 'number' | 'repository' | 'sourceBranchName' | 'sourceRepositoryName' | 'sourceRepositoryOwner' | 'title' | 'webUrl'>, fieldsCiProducts?: Array<'additionalRepositories' | 'app' | 'buildRuns' | 'bundleId' | 'createdDate' | 'name' | 'primaryRepositories' | 'productType' | 'workflows'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, limitBuilds?: number, include?: Array<'builds' | 'destinationBranch' | 'product' | 'pullRequest' | 'sourceBranchOrTag' | 'workflow'>, _options?: Configuration): Promise<HttpInfo<CiBuildRunResponse>> {
        const result = this.api.ciBuildActionsBuildRunGetToOneRelatedWithHttpInfo(id, fieldsScmGitReferences, fieldsCiBuildRuns, fieldsCiWorkflows, fieldsScmPullRequests, fieldsCiProducts, fieldsBuilds, limitBuilds, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsScmGitReferences the fields to include for returned resources of type scmGitReferences
     * @param fieldsCiBuildRuns the fields to include for returned resources of type ciBuildRuns
     * @param fieldsCiWorkflows the fields to include for returned resources of type ciWorkflows
     * @param fieldsScmPullRequests the fields to include for returned resources of type scmPullRequests
     * @param fieldsCiProducts the fields to include for returned resources of type ciProducts
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param limitBuilds maximum number of related builds returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public ciBuildActionsBuildRunGetToOneRelated(id: string, fieldsScmGitReferences?: Array<'canonicalName' | 'isDeleted' | 'kind' | 'name' | 'repository'>, fieldsCiBuildRuns?: Array<'actions' | 'buildRun' | 'builds' | 'cancelReason' | 'clean' | 'completionStatus' | 'createdDate' | 'destinationBranch' | 'destinationCommit' | 'executionProgress' | 'finishedDate' | 'isPullRequestBuild' | 'issueCounts' | 'number' | 'product' | 'pullRequest' | 'sourceBranchOrTag' | 'sourceCommit' | 'startReason' | 'startedDate' | 'workflow'>, fieldsCiWorkflows?: Array<'actions' | 'branchStartCondition' | 'buildRuns' | 'clean' | 'containerFilePath' | 'description' | 'isEnabled' | 'isLockedForEditing' | 'lastModifiedDate' | 'macOsVersion' | 'manualBranchStartCondition' | 'manualPullRequestStartCondition' | 'manualTagStartCondition' | 'name' | 'product' | 'pullRequestStartCondition' | 'repository' | 'scheduledStartCondition' | 'tagStartCondition' | 'xcodeVersion'>, fieldsScmPullRequests?: Array<'destinationBranchName' | 'destinationRepositoryName' | 'destinationRepositoryOwner' | 'isClosed' | 'isCrossRepository' | 'number' | 'repository' | 'sourceBranchName' | 'sourceRepositoryName' | 'sourceRepositoryOwner' | 'title' | 'webUrl'>, fieldsCiProducts?: Array<'additionalRepositories' | 'app' | 'buildRuns' | 'bundleId' | 'createdDate' | 'name' | 'primaryRepositories' | 'productType' | 'workflows'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, limitBuilds?: number, include?: Array<'builds' | 'destinationBranch' | 'product' | 'pullRequest' | 'sourceBranchOrTag' | 'workflow'>, _options?: Configuration): Promise<CiBuildRunResponse> {
        const result = this.api.ciBuildActionsBuildRunGetToOneRelated(id, fieldsScmGitReferences, fieldsCiBuildRuns, fieldsCiWorkflows, fieldsScmPullRequests, fieldsCiProducts, fieldsBuilds, limitBuilds, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCiBuildActions the fields to include for returned resources of type ciBuildActions
     * @param include comma-separated list of relationships to include
     * @param fieldsCiIssues the fields to include for returned resources of type ciIssues
     * @param fieldsCiBuildRuns the fields to include for returned resources of type ciBuildRuns
     * @param fieldsCiTestResults the fields to include for returned resources of type ciTestResults
     * @param fieldsCiArtifacts the fields to include for returned resources of type ciArtifacts
     */
    public ciBuildActionsGetInstanceWithHttpInfo(id: string, fieldsCiBuildActions?: Array<'actionType' | 'artifacts' | 'buildRun' | 'completionStatus' | 'executionProgress' | 'finishedDate' | 'isRequiredToPass' | 'issueCounts' | 'issues' | 'name' | 'startedDate' | 'testResults'>, include?: Array<'buildRun'>, fieldsCiIssues?: Array<'category' | 'fileSource' | 'issueType' | 'message'>, fieldsCiBuildRuns?: Array<'actions' | 'buildRun' | 'builds' | 'cancelReason' | 'clean' | 'completionStatus' | 'createdDate' | 'destinationBranch' | 'destinationCommit' | 'executionProgress' | 'finishedDate' | 'isPullRequestBuild' | 'issueCounts' | 'number' | 'product' | 'pullRequest' | 'sourceBranchOrTag' | 'sourceCommit' | 'startReason' | 'startedDate' | 'workflow'>, fieldsCiTestResults?: Array<'className' | 'destinationTestResults' | 'fileSource' | 'message' | 'name' | 'status'>, fieldsCiArtifacts?: Array<'downloadUrl' | 'fileName' | 'fileSize' | 'fileType'>, _options?: Configuration): Promise<HttpInfo<CiBuildActionResponse>> {
        const result = this.api.ciBuildActionsGetInstanceWithHttpInfo(id, fieldsCiBuildActions, include, fieldsCiIssues, fieldsCiBuildRuns, fieldsCiTestResults, fieldsCiArtifacts, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCiBuildActions the fields to include for returned resources of type ciBuildActions
     * @param include comma-separated list of relationships to include
     * @param fieldsCiIssues the fields to include for returned resources of type ciIssues
     * @param fieldsCiBuildRuns the fields to include for returned resources of type ciBuildRuns
     * @param fieldsCiTestResults the fields to include for returned resources of type ciTestResults
     * @param fieldsCiArtifacts the fields to include for returned resources of type ciArtifacts
     */
    public ciBuildActionsGetInstance(id: string, fieldsCiBuildActions?: Array<'actionType' | 'artifacts' | 'buildRun' | 'completionStatus' | 'executionProgress' | 'finishedDate' | 'isRequiredToPass' | 'issueCounts' | 'issues' | 'name' | 'startedDate' | 'testResults'>, include?: Array<'buildRun'>, fieldsCiIssues?: Array<'category' | 'fileSource' | 'issueType' | 'message'>, fieldsCiBuildRuns?: Array<'actions' | 'buildRun' | 'builds' | 'cancelReason' | 'clean' | 'completionStatus' | 'createdDate' | 'destinationBranch' | 'destinationCommit' | 'executionProgress' | 'finishedDate' | 'isPullRequestBuild' | 'issueCounts' | 'number' | 'product' | 'pullRequest' | 'sourceBranchOrTag' | 'sourceCommit' | 'startReason' | 'startedDate' | 'workflow'>, fieldsCiTestResults?: Array<'className' | 'destinationTestResults' | 'fileSource' | 'message' | 'name' | 'status'>, fieldsCiArtifacts?: Array<'downloadUrl' | 'fileName' | 'fileSize' | 'fileType'>, _options?: Configuration): Promise<CiBuildActionResponse> {
        const result = this.api.ciBuildActionsGetInstance(id, fieldsCiBuildActions, include, fieldsCiIssues, fieldsCiBuildRuns, fieldsCiTestResults, fieldsCiArtifacts, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCiIssues the fields to include for returned resources of type ciIssues
     * @param limit maximum resources per page
     */
    public ciBuildActionsIssuesGetToManyRelatedWithHttpInfo(id: string, fieldsCiIssues?: Array<'category' | 'fileSource' | 'issueType' | 'message'>, limit?: number, _options?: Configuration): Promise<HttpInfo<CiIssuesResponse>> {
        const result = this.api.ciBuildActionsIssuesGetToManyRelatedWithHttpInfo(id, fieldsCiIssues, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCiIssues the fields to include for returned resources of type ciIssues
     * @param limit maximum resources per page
     */
    public ciBuildActionsIssuesGetToManyRelated(id: string, fieldsCiIssues?: Array<'category' | 'fileSource' | 'issueType' | 'message'>, limit?: number, _options?: Configuration): Promise<CiIssuesResponse> {
        const result = this.api.ciBuildActionsIssuesGetToManyRelated(id, fieldsCiIssues, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCiTestResults the fields to include for returned resources of type ciTestResults
     * @param limit maximum resources per page
     */
    public ciBuildActionsTestResultsGetToManyRelatedWithHttpInfo(id: string, fieldsCiTestResults?: Array<'className' | 'destinationTestResults' | 'fileSource' | 'message' | 'name' | 'status'>, limit?: number, _options?: Configuration): Promise<HttpInfo<CiTestResultsResponse>> {
        const result = this.api.ciBuildActionsTestResultsGetToManyRelatedWithHttpInfo(id, fieldsCiTestResults, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCiTestResults the fields to include for returned resources of type ciTestResults
     * @param limit maximum resources per page
     */
    public ciBuildActionsTestResultsGetToManyRelated(id: string, fieldsCiTestResults?: Array<'className' | 'destinationTestResults' | 'fileSource' | 'message' | 'name' | 'status'>, limit?: number, _options?: Configuration): Promise<CiTestResultsResponse> {
        const result = this.api.ciBuildActionsTestResultsGetToManyRelated(id, fieldsCiTestResults, limit, _options);
        return result.toPromise();
    }


}



import { ObservableCiBuildRunsApi } from './ObservableAPI.ts';

import { CiBuildRunsApiRequestFactory, CiBuildRunsApiResponseProcessor} from "../apis/CiBuildRunsApi.ts";
export class PromiseCiBuildRunsApi {
    private api: ObservableCiBuildRunsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: CiBuildRunsApiRequestFactory,
        responseProcessor?: CiBuildRunsApiResponseProcessor
    ) {
        this.api = new ObservableCiBuildRunsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCiBuildRuns the fields to include for returned resources of type ciBuildRuns
     * @param fieldsCiBuildActions the fields to include for returned resources of type ciBuildActions
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public ciBuildRunsActionsGetToManyRelatedWithHttpInfo(id: string, fieldsCiBuildRuns?: Array<'actions' | 'buildRun' | 'builds' | 'cancelReason' | 'clean' | 'completionStatus' | 'createdDate' | 'destinationBranch' | 'destinationCommit' | 'executionProgress' | 'finishedDate' | 'isPullRequestBuild' | 'issueCounts' | 'number' | 'product' | 'pullRequest' | 'sourceBranchOrTag' | 'sourceCommit' | 'startReason' | 'startedDate' | 'workflow'>, fieldsCiBuildActions?: Array<'actionType' | 'artifacts' | 'buildRun' | 'completionStatus' | 'executionProgress' | 'finishedDate' | 'isRequiredToPass' | 'issueCounts' | 'issues' | 'name' | 'startedDate' | 'testResults'>, limit?: number, include?: Array<'buildRun'>, _options?: Configuration): Promise<HttpInfo<CiBuildActionsResponse>> {
        const result = this.api.ciBuildRunsActionsGetToManyRelatedWithHttpInfo(id, fieldsCiBuildRuns, fieldsCiBuildActions, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCiBuildRuns the fields to include for returned resources of type ciBuildRuns
     * @param fieldsCiBuildActions the fields to include for returned resources of type ciBuildActions
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public ciBuildRunsActionsGetToManyRelated(id: string, fieldsCiBuildRuns?: Array<'actions' | 'buildRun' | 'builds' | 'cancelReason' | 'clean' | 'completionStatus' | 'createdDate' | 'destinationBranch' | 'destinationCommit' | 'executionProgress' | 'finishedDate' | 'isPullRequestBuild' | 'issueCounts' | 'number' | 'product' | 'pullRequest' | 'sourceBranchOrTag' | 'sourceCommit' | 'startReason' | 'startedDate' | 'workflow'>, fieldsCiBuildActions?: Array<'actionType' | 'artifacts' | 'buildRun' | 'completionStatus' | 'executionProgress' | 'finishedDate' | 'isRequiredToPass' | 'issueCounts' | 'issues' | 'name' | 'startedDate' | 'testResults'>, limit?: number, include?: Array<'buildRun'>, _options?: Configuration): Promise<CiBuildActionsResponse> {
        const result = this.api.ciBuildRunsActionsGetToManyRelated(id, fieldsCiBuildRuns, fieldsCiBuildActions, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterBetaAppReviewSubmissionBetaReviewState filter by attribute \&#39;betaAppReviewSubmission.betaReviewState\&#39;
     * @param filterBuildAudienceType filter by attribute \&#39;buildAudienceType\&#39;
     * @param filterExpired filter by attribute \&#39;expired\&#39;
     * @param filterPreReleaseVersionPlatform filter by attribute \&#39;preReleaseVersion.platform\&#39;
     * @param filterPreReleaseVersionVersion filter by attribute \&#39;preReleaseVersion.version\&#39;
     * @param filterProcessingState filter by attribute \&#39;processingState\&#39;
     * @param filterUsesNonExemptEncryption filter by attribute \&#39;usesNonExemptEncryption\&#39;
     * @param filterVersion filter by attribute \&#39;version\&#39;
     * @param filterApp filter by id(s) of related \&#39;app\&#39;
     * @param filterAppStoreVersion filter by id(s) of related \&#39;appStoreVersion\&#39;
     * @param filterBetaGroups filter by id(s) of related \&#39;betaGroups\&#39;
     * @param filterPreReleaseVersion filter by id(s) of related \&#39;preReleaseVersion\&#39;
     * @param filterId filter by id(s)
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsBuildBundles the fields to include for returned resources of type buildBundles
     * @param fieldsBuildIcons the fields to include for returned resources of type buildIcons
     * @param fieldsBetaAppReviewSubmissions the fields to include for returned resources of type betaAppReviewSubmissions
     * @param fieldsBuildBetaDetails the fields to include for returned resources of type buildBetaDetails
     * @param fieldsBetaTesters the fields to include for returned resources of type betaTesters
     * @param fieldsPreReleaseVersions the fields to include for returned resources of type preReleaseVersions
     * @param fieldsBetaBuildLocalizations the fields to include for returned resources of type betaBuildLocalizations
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsAppEncryptionDeclarations the fields to include for returned resources of type appEncryptionDeclarations
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param fieldsBetaGroups the fields to include for returned resources of type betaGroups
     * @param limit maximum resources per page
     * @param limitIndividualTesters maximum number of related individualTesters returned (when they are included)
     * @param limitBetaGroups maximum number of related betaGroups returned (when they are included)
     * @param limitBetaBuildLocalizations maximum number of related betaBuildLocalizations returned (when they are included)
     * @param limitIcons maximum number of related icons returned (when they are included)
     * @param limitBuildBundles maximum number of related buildBundles returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public ciBuildRunsBuildsGetToManyRelatedWithHttpInfo(id: string, filterBetaAppReviewSubmissionBetaReviewState?: Array<'WAITING_FOR_REVIEW' | 'IN_REVIEW' | 'REJECTED' | 'APPROVED'>, filterBuildAudienceType?: Array<'INTERNAL_ONLY' | 'APP_STORE_ELIGIBLE'>, filterExpired?: Array<string>, filterPreReleaseVersionPlatform?: Array<'IOS' | 'MAC_OS' | 'TV_OS' | 'VISION_OS'>, filterPreReleaseVersionVersion?: Array<string>, filterProcessingState?: Array<'PROCESSING' | 'FAILED' | 'INVALID' | 'VALID'>, filterUsesNonExemptEncryption?: Array<string>, filterVersion?: Array<string>, filterApp?: Array<string>, filterAppStoreVersion?: Array<string>, filterBetaGroups?: Array<string>, filterPreReleaseVersion?: Array<string>, filterId?: Array<string>, sort?: Array<'preReleaseVersion' | '-preReleaseVersion' | 'uploadedDate' | '-uploadedDate' | 'version' | '-version'>, fieldsBuildBundles?: Array<'appClipDomainCacheStatus' | 'appClipDomainDebugStatus' | 'betaAppClipInvocations' | 'buildBundleFileSizes' | 'bundleId' | 'bundleType' | 'dSYMUrl' | 'deviceProtocols' | 'entitlements' | 'fileName' | 'hasOnDemandResources' | 'hasPrerenderedIcon' | 'hasSirikit' | 'includesSymbols' | 'isIosBuildMacAppStoreCompatible' | 'locales' | 'platformBuild' | 'requiredCapabilities' | 'sdkBuild' | 'supportedArchitectures' | 'usesLocationServices'>, fieldsBuildIcons?: Array<'iconAsset' | 'iconType' | 'name'>, fieldsBetaAppReviewSubmissions?: Array<'betaReviewState' | 'build' | 'submittedDate'>, fieldsBuildBetaDetails?: Array<'autoNotifyEnabled' | 'build' | 'externalBuildState' | 'internalBuildState'>, fieldsBetaTesters?: Array<'apps' | 'betaGroups' | 'builds' | 'email' | 'firstName' | 'inviteType' | 'lastName'>, fieldsPreReleaseVersions?: Array<'app' | 'builds' | 'platform' | 'version'>, fieldsBetaBuildLocalizations?: Array<'build' | 'locale' | 'whatsNew'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsAppEncryptionDeclarations?: Array<'app' | 'appDescription' | 'appEncryptionDeclarationDocument' | 'appEncryptionDeclarationState' | 'availableOnFrenchStore' | 'builds' | 'codeValue' | 'containsProprietaryCryptography' | 'containsThirdPartyCryptography' | 'createdDate' | 'documentName' | 'documentType' | 'documentUrl' | 'exempt' | 'platform' | 'uploadedDate' | 'usesEncryption'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, fieldsBetaGroups?: Array<'app' | 'betaTesters' | 'builds' | 'createdDate' | 'feedbackEnabled' | 'hasAccessToAllBuilds' | 'iosBuildsAvailableForAppleSiliconMac' | 'isInternalGroup' | 'name' | 'publicLink' | 'publicLinkEnabled' | 'publicLinkId' | 'publicLinkLimit' | 'publicLinkLimitEnabled'>, limit?: number, limitIndividualTesters?: number, limitBetaGroups?: number, limitBetaBuildLocalizations?: number, limitIcons?: number, limitBuildBundles?: number, include?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildBetaDetail' | 'buildBundles' | 'icons' | 'individualTesters' | 'preReleaseVersion'>, _options?: Configuration): Promise<HttpInfo<BuildsResponse>> {
        const result = this.api.ciBuildRunsBuildsGetToManyRelatedWithHttpInfo(id, filterBetaAppReviewSubmissionBetaReviewState, filterBuildAudienceType, filterExpired, filterPreReleaseVersionPlatform, filterPreReleaseVersionVersion, filterProcessingState, filterUsesNonExemptEncryption, filterVersion, filterApp, filterAppStoreVersion, filterBetaGroups, filterPreReleaseVersion, filterId, sort, fieldsBuildBundles, fieldsBuildIcons, fieldsBetaAppReviewSubmissions, fieldsBuildBetaDetails, fieldsBetaTesters, fieldsPreReleaseVersions, fieldsBetaBuildLocalizations, fieldsAppStoreVersions, fieldsAppEncryptionDeclarations, fieldsApps, fieldsBuilds, fieldsBetaGroups, limit, limitIndividualTesters, limitBetaGroups, limitBetaBuildLocalizations, limitIcons, limitBuildBundles, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterBetaAppReviewSubmissionBetaReviewState filter by attribute \&#39;betaAppReviewSubmission.betaReviewState\&#39;
     * @param filterBuildAudienceType filter by attribute \&#39;buildAudienceType\&#39;
     * @param filterExpired filter by attribute \&#39;expired\&#39;
     * @param filterPreReleaseVersionPlatform filter by attribute \&#39;preReleaseVersion.platform\&#39;
     * @param filterPreReleaseVersionVersion filter by attribute \&#39;preReleaseVersion.version\&#39;
     * @param filterProcessingState filter by attribute \&#39;processingState\&#39;
     * @param filterUsesNonExemptEncryption filter by attribute \&#39;usesNonExemptEncryption\&#39;
     * @param filterVersion filter by attribute \&#39;version\&#39;
     * @param filterApp filter by id(s) of related \&#39;app\&#39;
     * @param filterAppStoreVersion filter by id(s) of related \&#39;appStoreVersion\&#39;
     * @param filterBetaGroups filter by id(s) of related \&#39;betaGroups\&#39;
     * @param filterPreReleaseVersion filter by id(s) of related \&#39;preReleaseVersion\&#39;
     * @param filterId filter by id(s)
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsBuildBundles the fields to include for returned resources of type buildBundles
     * @param fieldsBuildIcons the fields to include for returned resources of type buildIcons
     * @param fieldsBetaAppReviewSubmissions the fields to include for returned resources of type betaAppReviewSubmissions
     * @param fieldsBuildBetaDetails the fields to include for returned resources of type buildBetaDetails
     * @param fieldsBetaTesters the fields to include for returned resources of type betaTesters
     * @param fieldsPreReleaseVersions the fields to include for returned resources of type preReleaseVersions
     * @param fieldsBetaBuildLocalizations the fields to include for returned resources of type betaBuildLocalizations
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsAppEncryptionDeclarations the fields to include for returned resources of type appEncryptionDeclarations
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param fieldsBetaGroups the fields to include for returned resources of type betaGroups
     * @param limit maximum resources per page
     * @param limitIndividualTesters maximum number of related individualTesters returned (when they are included)
     * @param limitBetaGroups maximum number of related betaGroups returned (when they are included)
     * @param limitBetaBuildLocalizations maximum number of related betaBuildLocalizations returned (when they are included)
     * @param limitIcons maximum number of related icons returned (when they are included)
     * @param limitBuildBundles maximum number of related buildBundles returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public ciBuildRunsBuildsGetToManyRelated(id: string, filterBetaAppReviewSubmissionBetaReviewState?: Array<'WAITING_FOR_REVIEW' | 'IN_REVIEW' | 'REJECTED' | 'APPROVED'>, filterBuildAudienceType?: Array<'INTERNAL_ONLY' | 'APP_STORE_ELIGIBLE'>, filterExpired?: Array<string>, filterPreReleaseVersionPlatform?: Array<'IOS' | 'MAC_OS' | 'TV_OS' | 'VISION_OS'>, filterPreReleaseVersionVersion?: Array<string>, filterProcessingState?: Array<'PROCESSING' | 'FAILED' | 'INVALID' | 'VALID'>, filterUsesNonExemptEncryption?: Array<string>, filterVersion?: Array<string>, filterApp?: Array<string>, filterAppStoreVersion?: Array<string>, filterBetaGroups?: Array<string>, filterPreReleaseVersion?: Array<string>, filterId?: Array<string>, sort?: Array<'preReleaseVersion' | '-preReleaseVersion' | 'uploadedDate' | '-uploadedDate' | 'version' | '-version'>, fieldsBuildBundles?: Array<'appClipDomainCacheStatus' | 'appClipDomainDebugStatus' | 'betaAppClipInvocations' | 'buildBundleFileSizes' | 'bundleId' | 'bundleType' | 'dSYMUrl' | 'deviceProtocols' | 'entitlements' | 'fileName' | 'hasOnDemandResources' | 'hasPrerenderedIcon' | 'hasSirikit' | 'includesSymbols' | 'isIosBuildMacAppStoreCompatible' | 'locales' | 'platformBuild' | 'requiredCapabilities' | 'sdkBuild' | 'supportedArchitectures' | 'usesLocationServices'>, fieldsBuildIcons?: Array<'iconAsset' | 'iconType' | 'name'>, fieldsBetaAppReviewSubmissions?: Array<'betaReviewState' | 'build' | 'submittedDate'>, fieldsBuildBetaDetails?: Array<'autoNotifyEnabled' | 'build' | 'externalBuildState' | 'internalBuildState'>, fieldsBetaTesters?: Array<'apps' | 'betaGroups' | 'builds' | 'email' | 'firstName' | 'inviteType' | 'lastName'>, fieldsPreReleaseVersions?: Array<'app' | 'builds' | 'platform' | 'version'>, fieldsBetaBuildLocalizations?: Array<'build' | 'locale' | 'whatsNew'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsAppEncryptionDeclarations?: Array<'app' | 'appDescription' | 'appEncryptionDeclarationDocument' | 'appEncryptionDeclarationState' | 'availableOnFrenchStore' | 'builds' | 'codeValue' | 'containsProprietaryCryptography' | 'containsThirdPartyCryptography' | 'createdDate' | 'documentName' | 'documentType' | 'documentUrl' | 'exempt' | 'platform' | 'uploadedDate' | 'usesEncryption'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, fieldsBetaGroups?: Array<'app' | 'betaTesters' | 'builds' | 'createdDate' | 'feedbackEnabled' | 'hasAccessToAllBuilds' | 'iosBuildsAvailableForAppleSiliconMac' | 'isInternalGroup' | 'name' | 'publicLink' | 'publicLinkEnabled' | 'publicLinkId' | 'publicLinkLimit' | 'publicLinkLimitEnabled'>, limit?: number, limitIndividualTesters?: number, limitBetaGroups?: number, limitBetaBuildLocalizations?: number, limitIcons?: number, limitBuildBundles?: number, include?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildBetaDetail' | 'buildBundles' | 'icons' | 'individualTesters' | 'preReleaseVersion'>, _options?: Configuration): Promise<BuildsResponse> {
        const result = this.api.ciBuildRunsBuildsGetToManyRelated(id, filterBetaAppReviewSubmissionBetaReviewState, filterBuildAudienceType, filterExpired, filterPreReleaseVersionPlatform, filterPreReleaseVersionVersion, filterProcessingState, filterUsesNonExemptEncryption, filterVersion, filterApp, filterAppStoreVersion, filterBetaGroups, filterPreReleaseVersion, filterId, sort, fieldsBuildBundles, fieldsBuildIcons, fieldsBetaAppReviewSubmissions, fieldsBuildBetaDetails, fieldsBetaTesters, fieldsPreReleaseVersions, fieldsBetaBuildLocalizations, fieldsAppStoreVersions, fieldsAppEncryptionDeclarations, fieldsApps, fieldsBuilds, fieldsBetaGroups, limit, limitIndividualTesters, limitBetaGroups, limitBetaBuildLocalizations, limitIcons, limitBuildBundles, include, _options);
        return result.toPromise();
    }

    /**
     * @param ciBuildRunCreateRequest CiBuildRun representation
     */
    public ciBuildRunsCreateInstanceWithHttpInfo(ciBuildRunCreateRequest: CiBuildRunCreateRequest, _options?: Configuration): Promise<HttpInfo<CiBuildRunResponse>> {
        const result = this.api.ciBuildRunsCreateInstanceWithHttpInfo(ciBuildRunCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param ciBuildRunCreateRequest CiBuildRun representation
     */
    public ciBuildRunsCreateInstance(ciBuildRunCreateRequest: CiBuildRunCreateRequest, _options?: Configuration): Promise<CiBuildRunResponse> {
        const result = this.api.ciBuildRunsCreateInstance(ciBuildRunCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCiBuildRuns the fields to include for returned resources of type ciBuildRuns
     * @param include comma-separated list of relationships to include
     * @param fieldsCiBuildActions the fields to include for returned resources of type ciBuildActions
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param limitBuilds maximum number of related builds returned (when they are included)
     */
    public ciBuildRunsGetInstanceWithHttpInfo(id: string, fieldsCiBuildRuns?: Array<'actions' | 'buildRun' | 'builds' | 'cancelReason' | 'clean' | 'completionStatus' | 'createdDate' | 'destinationBranch' | 'destinationCommit' | 'executionProgress' | 'finishedDate' | 'isPullRequestBuild' | 'issueCounts' | 'number' | 'product' | 'pullRequest' | 'sourceBranchOrTag' | 'sourceCommit' | 'startReason' | 'startedDate' | 'workflow'>, include?: Array<'builds' | 'destinationBranch' | 'product' | 'pullRequest' | 'sourceBranchOrTag' | 'workflow'>, fieldsCiBuildActions?: Array<'actionType' | 'artifacts' | 'buildRun' | 'completionStatus' | 'executionProgress' | 'finishedDate' | 'isRequiredToPass' | 'issueCounts' | 'issues' | 'name' | 'startedDate' | 'testResults'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, limitBuilds?: number, _options?: Configuration): Promise<HttpInfo<CiBuildRunResponse>> {
        const result = this.api.ciBuildRunsGetInstanceWithHttpInfo(id, fieldsCiBuildRuns, include, fieldsCiBuildActions, fieldsBuilds, limitBuilds, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCiBuildRuns the fields to include for returned resources of type ciBuildRuns
     * @param include comma-separated list of relationships to include
     * @param fieldsCiBuildActions the fields to include for returned resources of type ciBuildActions
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param limitBuilds maximum number of related builds returned (when they are included)
     */
    public ciBuildRunsGetInstance(id: string, fieldsCiBuildRuns?: Array<'actions' | 'buildRun' | 'builds' | 'cancelReason' | 'clean' | 'completionStatus' | 'createdDate' | 'destinationBranch' | 'destinationCommit' | 'executionProgress' | 'finishedDate' | 'isPullRequestBuild' | 'issueCounts' | 'number' | 'product' | 'pullRequest' | 'sourceBranchOrTag' | 'sourceCommit' | 'startReason' | 'startedDate' | 'workflow'>, include?: Array<'builds' | 'destinationBranch' | 'product' | 'pullRequest' | 'sourceBranchOrTag' | 'workflow'>, fieldsCiBuildActions?: Array<'actionType' | 'artifacts' | 'buildRun' | 'completionStatus' | 'executionProgress' | 'finishedDate' | 'isRequiredToPass' | 'issueCounts' | 'issues' | 'name' | 'startedDate' | 'testResults'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, limitBuilds?: number, _options?: Configuration): Promise<CiBuildRunResponse> {
        const result = this.api.ciBuildRunsGetInstance(id, fieldsCiBuildRuns, include, fieldsCiBuildActions, fieldsBuilds, limitBuilds, _options);
        return result.toPromise();
    }


}



import { ObservableCiIssuesApi } from './ObservableAPI.ts';

import { CiIssuesApiRequestFactory, CiIssuesApiResponseProcessor} from "../apis/CiIssuesApi.ts";
export class PromiseCiIssuesApi {
    private api: ObservableCiIssuesApi

    public constructor(
        configuration: Configuration,
        requestFactory?: CiIssuesApiRequestFactory,
        responseProcessor?: CiIssuesApiResponseProcessor
    ) {
        this.api = new ObservableCiIssuesApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCiIssues the fields to include for returned resources of type ciIssues
     */
    public ciIssuesGetInstanceWithHttpInfo(id: string, fieldsCiIssues?: Array<'category' | 'fileSource' | 'issueType' | 'message'>, _options?: Configuration): Promise<HttpInfo<CiIssueResponse>> {
        const result = this.api.ciIssuesGetInstanceWithHttpInfo(id, fieldsCiIssues, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCiIssues the fields to include for returned resources of type ciIssues
     */
    public ciIssuesGetInstance(id: string, fieldsCiIssues?: Array<'category' | 'fileSource' | 'issueType' | 'message'>, _options?: Configuration): Promise<CiIssueResponse> {
        const result = this.api.ciIssuesGetInstance(id, fieldsCiIssues, _options);
        return result.toPromise();
    }


}



import { ObservableCiMacOsVersionsApi } from './ObservableAPI.ts';

import { CiMacOsVersionsApiRequestFactory, CiMacOsVersionsApiResponseProcessor} from "../apis/CiMacOsVersionsApi.ts";
export class PromiseCiMacOsVersionsApi {
    private api: ObservableCiMacOsVersionsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: CiMacOsVersionsApiRequestFactory,
        responseProcessor?: CiMacOsVersionsApiResponseProcessor
    ) {
        this.api = new ObservableCiMacOsVersionsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param fieldsCiMacOsVersions the fields to include for returned resources of type ciMacOsVersions
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsCiXcodeVersions the fields to include for returned resources of type ciXcodeVersions
     * @param limitXcodeVersions maximum number of related xcodeVersions returned (when they are included)
     */
    public ciMacOsVersionsGetCollectionWithHttpInfo(fieldsCiMacOsVersions?: Array<'name' | 'version' | 'xcodeVersions'>, limit?: number, include?: Array<'xcodeVersions'>, fieldsCiXcodeVersions?: Array<'macOsVersions' | 'name' | 'testDestinations' | 'version'>, limitXcodeVersions?: number, _options?: Configuration): Promise<HttpInfo<CiMacOsVersionsResponse>> {
        const result = this.api.ciMacOsVersionsGetCollectionWithHttpInfo(fieldsCiMacOsVersions, limit, include, fieldsCiXcodeVersions, limitXcodeVersions, _options);
        return result.toPromise();
    }

    /**
     * @param fieldsCiMacOsVersions the fields to include for returned resources of type ciMacOsVersions
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsCiXcodeVersions the fields to include for returned resources of type ciXcodeVersions
     * @param limitXcodeVersions maximum number of related xcodeVersions returned (when they are included)
     */
    public ciMacOsVersionsGetCollection(fieldsCiMacOsVersions?: Array<'name' | 'version' | 'xcodeVersions'>, limit?: number, include?: Array<'xcodeVersions'>, fieldsCiXcodeVersions?: Array<'macOsVersions' | 'name' | 'testDestinations' | 'version'>, limitXcodeVersions?: number, _options?: Configuration): Promise<CiMacOsVersionsResponse> {
        const result = this.api.ciMacOsVersionsGetCollection(fieldsCiMacOsVersions, limit, include, fieldsCiXcodeVersions, limitXcodeVersions, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCiMacOsVersions the fields to include for returned resources of type ciMacOsVersions
     * @param include comma-separated list of relationships to include
     * @param fieldsCiXcodeVersions the fields to include for returned resources of type ciXcodeVersions
     * @param limitXcodeVersions maximum number of related xcodeVersions returned (when they are included)
     */
    public ciMacOsVersionsGetInstanceWithHttpInfo(id: string, fieldsCiMacOsVersions?: Array<'name' | 'version' | 'xcodeVersions'>, include?: Array<'xcodeVersions'>, fieldsCiXcodeVersions?: Array<'macOsVersions' | 'name' | 'testDestinations' | 'version'>, limitXcodeVersions?: number, _options?: Configuration): Promise<HttpInfo<CiMacOsVersionResponse>> {
        const result = this.api.ciMacOsVersionsGetInstanceWithHttpInfo(id, fieldsCiMacOsVersions, include, fieldsCiXcodeVersions, limitXcodeVersions, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCiMacOsVersions the fields to include for returned resources of type ciMacOsVersions
     * @param include comma-separated list of relationships to include
     * @param fieldsCiXcodeVersions the fields to include for returned resources of type ciXcodeVersions
     * @param limitXcodeVersions maximum number of related xcodeVersions returned (when they are included)
     */
    public ciMacOsVersionsGetInstance(id: string, fieldsCiMacOsVersions?: Array<'name' | 'version' | 'xcodeVersions'>, include?: Array<'xcodeVersions'>, fieldsCiXcodeVersions?: Array<'macOsVersions' | 'name' | 'testDestinations' | 'version'>, limitXcodeVersions?: number, _options?: Configuration): Promise<CiMacOsVersionResponse> {
        const result = this.api.ciMacOsVersionsGetInstance(id, fieldsCiMacOsVersions, include, fieldsCiXcodeVersions, limitXcodeVersions, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCiXcodeVersions the fields to include for returned resources of type ciXcodeVersions
     * @param fieldsCiMacOsVersions the fields to include for returned resources of type ciMacOsVersions
     * @param limit maximum resources per page
     * @param limitMacOsVersions maximum number of related macOsVersions returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public ciMacOsVersionsXcodeVersionsGetToManyRelatedWithHttpInfo(id: string, fieldsCiXcodeVersions?: Array<'macOsVersions' | 'name' | 'testDestinations' | 'version'>, fieldsCiMacOsVersions?: Array<'name' | 'version' | 'xcodeVersions'>, limit?: number, limitMacOsVersions?: number, include?: Array<'macOsVersions'>, _options?: Configuration): Promise<HttpInfo<CiXcodeVersionsResponse>> {
        const result = this.api.ciMacOsVersionsXcodeVersionsGetToManyRelatedWithHttpInfo(id, fieldsCiXcodeVersions, fieldsCiMacOsVersions, limit, limitMacOsVersions, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCiXcodeVersions the fields to include for returned resources of type ciXcodeVersions
     * @param fieldsCiMacOsVersions the fields to include for returned resources of type ciMacOsVersions
     * @param limit maximum resources per page
     * @param limitMacOsVersions maximum number of related macOsVersions returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public ciMacOsVersionsXcodeVersionsGetToManyRelated(id: string, fieldsCiXcodeVersions?: Array<'macOsVersions' | 'name' | 'testDestinations' | 'version'>, fieldsCiMacOsVersions?: Array<'name' | 'version' | 'xcodeVersions'>, limit?: number, limitMacOsVersions?: number, include?: Array<'macOsVersions'>, _options?: Configuration): Promise<CiXcodeVersionsResponse> {
        const result = this.api.ciMacOsVersionsXcodeVersionsGetToManyRelated(id, fieldsCiXcodeVersions, fieldsCiMacOsVersions, limit, limitMacOsVersions, include, _options);
        return result.toPromise();
    }


}



import { ObservableCiProductsApi } from './ObservableAPI.ts';

import { CiProductsApiRequestFactory, CiProductsApiResponseProcessor} from "../apis/CiProductsApi.ts";
export class PromiseCiProductsApi {
    private api: ObservableCiProductsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: CiProductsApiRequestFactory,
        responseProcessor?: CiProductsApiResponseProcessor
    ) {
        this.api = new ObservableCiProductsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param id the id of the requested resource
     * @param filterId filter by id(s)
     * @param fieldsScmGitReferences the fields to include for returned resources of type scmGitReferences
     * @param fieldsScmProviders the fields to include for returned resources of type scmProviders
     * @param fieldsScmRepositories the fields to include for returned resources of type scmRepositories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public ciProductsAdditionalRepositoriesGetToManyRelatedWithHttpInfo(id: string, filterId?: Array<string>, fieldsScmGitReferences?: Array<'canonicalName' | 'isDeleted' | 'kind' | 'name' | 'repository'>, fieldsScmProviders?: Array<'repositories' | 'scmProviderType' | 'url'>, fieldsScmRepositories?: Array<'defaultBranch' | 'gitReferences' | 'httpCloneUrl' | 'lastAccessedDate' | 'ownerName' | 'pullRequests' | 'repositoryName' | 'scmProvider' | 'sshCloneUrl'>, limit?: number, include?: Array<'defaultBranch' | 'scmProvider'>, _options?: Configuration): Promise<HttpInfo<ScmRepositoriesResponse>> {
        const result = this.api.ciProductsAdditionalRepositoriesGetToManyRelatedWithHttpInfo(id, filterId, fieldsScmGitReferences, fieldsScmProviders, fieldsScmRepositories, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterId filter by id(s)
     * @param fieldsScmGitReferences the fields to include for returned resources of type scmGitReferences
     * @param fieldsScmProviders the fields to include for returned resources of type scmProviders
     * @param fieldsScmRepositories the fields to include for returned resources of type scmRepositories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public ciProductsAdditionalRepositoriesGetToManyRelated(id: string, filterId?: Array<string>, fieldsScmGitReferences?: Array<'canonicalName' | 'isDeleted' | 'kind' | 'name' | 'repository'>, fieldsScmProviders?: Array<'repositories' | 'scmProviderType' | 'url'>, fieldsScmRepositories?: Array<'defaultBranch' | 'gitReferences' | 'httpCloneUrl' | 'lastAccessedDate' | 'ownerName' | 'pullRequests' | 'repositoryName' | 'scmProvider' | 'sshCloneUrl'>, limit?: number, include?: Array<'defaultBranch' | 'scmProvider'>, _options?: Configuration): Promise<ScmRepositoriesResponse> {
        const result = this.api.ciProductsAdditionalRepositoriesGetToManyRelated(id, filterId, fieldsScmGitReferences, fieldsScmProviders, fieldsScmRepositories, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBetaAppReviewDetails the fields to include for returned resources of type betaAppReviewDetails
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsCiProducts the fields to include for returned resources of type ciProducts
     * @param fieldsReviewSubmissions the fields to include for returned resources of type reviewSubmissions
     * @param fieldsBetaGroups the fields to include for returned resources of type betaGroups
     * @param fieldsPromotedPurchases the fields to include for returned resources of type promotedPurchases
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsAppEvents the fields to include for returned resources of type appEvents
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param fieldsBetaLicenseAgreements the fields to include for returned resources of type betaLicenseAgreements
     * @param fieldsAppClips the fields to include for returned resources of type appClips
     * @param fieldsBetaAppLocalizations the fields to include for returned resources of type betaAppLocalizations
     * @param fieldsAppInfos the fields to include for returned resources of type appInfos
     * @param fieldsPreReleaseVersions the fields to include for returned resources of type preReleaseVersions
     * @param fieldsInAppPurchases the fields to include for returned resources of type inAppPurchases
     * @param fieldsSubscriptionGroups the fields to include for returned resources of type subscriptionGroups
     * @param fieldsAppPreOrders the fields to include for returned resources of type appPreOrders
     * @param fieldsAppPrices the fields to include for returned resources of type appPrices
     * @param fieldsGameCenterEnabledVersions the fields to include for returned resources of type gameCenterEnabledVersions
     * @param fieldsAppStoreVersionExperiments the fields to include for returned resources of type appStoreVersionExperiments
     * @param fieldsSubscriptionGracePeriods the fields to include for returned resources of type subscriptionGracePeriods
     * @param fieldsEndUserLicenseAgreements the fields to include for returned resources of type endUserLicenseAgreements
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsAppEncryptionDeclarations the fields to include for returned resources of type appEncryptionDeclarations
     * @param fieldsAppCustomProductPages the fields to include for returned resources of type appCustomProductPages
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limitAppEncryptionDeclarations maximum number of related appEncryptionDeclarations returned (when they are included)
     * @param limitBetaGroups maximum number of related betaGroups returned (when they are included)
     * @param limitAppStoreVersions maximum number of related appStoreVersions returned (when they are included)
     * @param limitPreReleaseVersions maximum number of related preReleaseVersions returned (when they are included)
     * @param limitBetaAppLocalizations maximum number of related betaAppLocalizations returned (when they are included)
     * @param limitBuilds maximum number of related builds returned (when they are included)
     * @param limitAppInfos maximum number of related appInfos returned (when they are included)
     * @param limitAppClips maximum number of related appClips returned (when they are included)
     * @param limitPrices maximum number of related prices returned (when they are included)
     * @param limitAvailableTerritories maximum number of related availableTerritories returned (when they are included)
     * @param limitInAppPurchases maximum number of related inAppPurchases returned (when they are included)
     * @param limitSubscriptionGroups maximum number of related subscriptionGroups returned (when they are included)
     * @param limitGameCenterEnabledVersions maximum number of related gameCenterEnabledVersions returned (when they are included)
     * @param limitAppCustomProductPages maximum number of related appCustomProductPages returned (when they are included)
     * @param limitInAppPurchasesV2 maximum number of related inAppPurchasesV2 returned (when they are included)
     * @param limitPromotedPurchases maximum number of related promotedPurchases returned (when they are included)
     * @param limitAppEvents maximum number of related appEvents returned (when they are included)
     * @param limitReviewSubmissions maximum number of related reviewSubmissions returned (when they are included)
     * @param limitAppStoreVersionExperimentsV2 maximum number of related appStoreVersionExperimentsV2 returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public ciProductsAppGetToOneRelatedWithHttpInfo(id: string, fieldsBetaAppReviewDetails?: Array<'app' | 'contactEmail' | 'contactFirstName' | 'contactLastName' | 'contactPhone' | 'demoAccountName' | 'demoAccountPassword' | 'demoAccountRequired' | 'notes'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsCiProducts?: Array<'additionalRepositories' | 'app' | 'buildRuns' | 'bundleId' | 'createdDate' | 'name' | 'primaryRepositories' | 'productType' | 'workflows'>, fieldsReviewSubmissions?: Array<'app' | 'appStoreVersionForReview' | 'canceled' | 'items' | 'lastUpdatedByActor' | 'platform' | 'state' | 'submitted' | 'submittedByActor' | 'submittedDate'>, fieldsBetaGroups?: Array<'app' | 'betaTesters' | 'builds' | 'createdDate' | 'feedbackEnabled' | 'hasAccessToAllBuilds' | 'iosBuildsAvailableForAppleSiliconMac' | 'isInternalGroup' | 'name' | 'publicLink' | 'publicLinkEnabled' | 'publicLinkId' | 'publicLinkLimit' | 'publicLinkLimitEnabled'>, fieldsPromotedPurchases?: Array<'app' | 'enabled' | 'inAppPurchaseV2' | 'promotionImages' | 'state' | 'subscription' | 'visibleForAllUsers'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsAppEvents?: Array<'app' | 'archivedTerritorySchedules' | 'badge' | 'deepLink' | 'eventState' | 'localizations' | 'primaryLocale' | 'priority' | 'purchaseRequirement' | 'purpose' | 'referenceName' | 'territorySchedules'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, fieldsBetaLicenseAgreements?: Array<'agreementText' | 'app'>, fieldsAppClips?: Array<'app' | 'appClipAdvancedExperiences' | 'appClipDefaultExperiences' | 'bundleId'>, fieldsBetaAppLocalizations?: Array<'app' | 'description' | 'feedbackEmail' | 'locale' | 'marketingUrl' | 'privacyPolicyUrl' | 'tvOsPrivacyPolicy'>, fieldsAppInfos?: Array<'ageRatingDeclaration' | 'app' | 'appInfoLocalizations' | 'appStoreAgeRating' | 'appStoreState' | 'brazilAgeRating' | 'brazilAgeRatingV2' | 'kidsAgeBand' | 'primaryCategory' | 'primarySubcategoryOne' | 'primarySubcategoryTwo' | 'secondaryCategory' | 'secondarySubcategoryOne' | 'secondarySubcategoryTwo' | 'state'>, fieldsPreReleaseVersions?: Array<'app' | 'builds' | 'platform' | 'version'>, fieldsInAppPurchases?: Array<'app' | 'appStoreReviewScreenshot' | 'apps' | 'content' | 'contentHosting' | 'familySharable' | 'iapPriceSchedule' | 'inAppPurchaseAvailability' | 'inAppPurchaseLocalizations' | 'inAppPurchaseType' | 'name' | 'pricePoints' | 'productId' | 'promotedPurchase' | 'referenceName' | 'reviewNote' | 'state'>, fieldsSubscriptionGroups?: Array<'app' | 'referenceName' | 'subscriptionGroupLocalizations' | 'subscriptions'>, fieldsAppPreOrders?: Array<'app' | 'appReleaseDate' | 'preOrderAvailableDate'>, fieldsAppPrices?: Array<'app' | 'priceTier'>, fieldsGameCenterEnabledVersions?: Array<'app' | 'compatibleVersions' | 'iconAsset' | 'platform' | 'versionString'>, fieldsAppStoreVersionExperiments?: Array<'app' | 'appStoreVersionExperimentTreatments' | 'controlVersions' | 'endDate' | 'latestControlVersion' | 'name' | 'platform' | 'reviewRequired' | 'startDate' | 'started' | 'state' | 'trafficProportion'>, fieldsSubscriptionGracePeriods?: Array<'duration' | 'optIn' | 'renewalType' | 'sandboxOptIn'>, fieldsEndUserLicenseAgreements?: Array<'agreementText' | 'app' | 'territories'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsAppEncryptionDeclarations?: Array<'app' | 'appDescription' | 'appEncryptionDeclarationDocument' | 'appEncryptionDeclarationState' | 'availableOnFrenchStore' | 'builds' | 'codeValue' | 'containsProprietaryCryptography' | 'containsThirdPartyCryptography' | 'createdDate' | 'documentName' | 'documentType' | 'documentUrl' | 'exempt' | 'platform' | 'uploadedDate' | 'usesEncryption'>, fieldsAppCustomProductPages?: Array<'app' | 'appCustomProductPageVersions' | 'appStoreVersionTemplate' | 'customProductPageTemplate' | 'name' | 'url' | 'visible'>, fieldsTerritories?: Array<'currency'>, limitAppEncryptionDeclarations?: number, limitBetaGroups?: number, limitAppStoreVersions?: number, limitPreReleaseVersions?: number, limitBetaAppLocalizations?: number, limitBuilds?: number, limitAppInfos?: number, limitAppClips?: number, limitPrices?: number, limitAvailableTerritories?: number, limitInAppPurchases?: number, limitSubscriptionGroups?: number, limitGameCenterEnabledVersions?: number, limitAppCustomProductPages?: number, limitInAppPurchasesV2?: number, limitPromotedPurchases?: number, limitAppEvents?: number, limitReviewSubmissions?: number, limitAppStoreVersionExperimentsV2?: number, include?: Array<'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'builds' | 'ciProduct' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'preOrder' | 'preReleaseVersions' | 'prices' | 'promotedPurchases' | 'reviewSubmissions' | 'subscriptionGracePeriod' | 'subscriptionGroups'>, _options?: Configuration): Promise<HttpInfo<AppResponse>> {
        const result = this.api.ciProductsAppGetToOneRelatedWithHttpInfo(id, fieldsBetaAppReviewDetails, fieldsGameCenterDetails, fieldsCiProducts, fieldsReviewSubmissions, fieldsBetaGroups, fieldsPromotedPurchases, fieldsApps, fieldsAppEvents, fieldsBuilds, fieldsBetaLicenseAgreements, fieldsAppClips, fieldsBetaAppLocalizations, fieldsAppInfos, fieldsPreReleaseVersions, fieldsInAppPurchases, fieldsSubscriptionGroups, fieldsAppPreOrders, fieldsAppPrices, fieldsGameCenterEnabledVersions, fieldsAppStoreVersionExperiments, fieldsSubscriptionGracePeriods, fieldsEndUserLicenseAgreements, fieldsAppStoreVersions, fieldsAppEncryptionDeclarations, fieldsAppCustomProductPages, fieldsTerritories, limitAppEncryptionDeclarations, limitBetaGroups, limitAppStoreVersions, limitPreReleaseVersions, limitBetaAppLocalizations, limitBuilds, limitAppInfos, limitAppClips, limitPrices, limitAvailableTerritories, limitInAppPurchases, limitSubscriptionGroups, limitGameCenterEnabledVersions, limitAppCustomProductPages, limitInAppPurchasesV2, limitPromotedPurchases, limitAppEvents, limitReviewSubmissions, limitAppStoreVersionExperimentsV2, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBetaAppReviewDetails the fields to include for returned resources of type betaAppReviewDetails
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsCiProducts the fields to include for returned resources of type ciProducts
     * @param fieldsReviewSubmissions the fields to include for returned resources of type reviewSubmissions
     * @param fieldsBetaGroups the fields to include for returned resources of type betaGroups
     * @param fieldsPromotedPurchases the fields to include for returned resources of type promotedPurchases
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsAppEvents the fields to include for returned resources of type appEvents
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param fieldsBetaLicenseAgreements the fields to include for returned resources of type betaLicenseAgreements
     * @param fieldsAppClips the fields to include for returned resources of type appClips
     * @param fieldsBetaAppLocalizations the fields to include for returned resources of type betaAppLocalizations
     * @param fieldsAppInfos the fields to include for returned resources of type appInfos
     * @param fieldsPreReleaseVersions the fields to include for returned resources of type preReleaseVersions
     * @param fieldsInAppPurchases the fields to include for returned resources of type inAppPurchases
     * @param fieldsSubscriptionGroups the fields to include for returned resources of type subscriptionGroups
     * @param fieldsAppPreOrders the fields to include for returned resources of type appPreOrders
     * @param fieldsAppPrices the fields to include for returned resources of type appPrices
     * @param fieldsGameCenterEnabledVersions the fields to include for returned resources of type gameCenterEnabledVersions
     * @param fieldsAppStoreVersionExperiments the fields to include for returned resources of type appStoreVersionExperiments
     * @param fieldsSubscriptionGracePeriods the fields to include for returned resources of type subscriptionGracePeriods
     * @param fieldsEndUserLicenseAgreements the fields to include for returned resources of type endUserLicenseAgreements
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsAppEncryptionDeclarations the fields to include for returned resources of type appEncryptionDeclarations
     * @param fieldsAppCustomProductPages the fields to include for returned resources of type appCustomProductPages
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limitAppEncryptionDeclarations maximum number of related appEncryptionDeclarations returned (when they are included)
     * @param limitBetaGroups maximum number of related betaGroups returned (when they are included)
     * @param limitAppStoreVersions maximum number of related appStoreVersions returned (when they are included)
     * @param limitPreReleaseVersions maximum number of related preReleaseVersions returned (when they are included)
     * @param limitBetaAppLocalizations maximum number of related betaAppLocalizations returned (when they are included)
     * @param limitBuilds maximum number of related builds returned (when they are included)
     * @param limitAppInfos maximum number of related appInfos returned (when they are included)
     * @param limitAppClips maximum number of related appClips returned (when they are included)
     * @param limitPrices maximum number of related prices returned (when they are included)
     * @param limitAvailableTerritories maximum number of related availableTerritories returned (when they are included)
     * @param limitInAppPurchases maximum number of related inAppPurchases returned (when they are included)
     * @param limitSubscriptionGroups maximum number of related subscriptionGroups returned (when they are included)
     * @param limitGameCenterEnabledVersions maximum number of related gameCenterEnabledVersions returned (when they are included)
     * @param limitAppCustomProductPages maximum number of related appCustomProductPages returned (when they are included)
     * @param limitInAppPurchasesV2 maximum number of related inAppPurchasesV2 returned (when they are included)
     * @param limitPromotedPurchases maximum number of related promotedPurchases returned (when they are included)
     * @param limitAppEvents maximum number of related appEvents returned (when they are included)
     * @param limitReviewSubmissions maximum number of related reviewSubmissions returned (when they are included)
     * @param limitAppStoreVersionExperimentsV2 maximum number of related appStoreVersionExperimentsV2 returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public ciProductsAppGetToOneRelated(id: string, fieldsBetaAppReviewDetails?: Array<'app' | 'contactEmail' | 'contactFirstName' | 'contactLastName' | 'contactPhone' | 'demoAccountName' | 'demoAccountPassword' | 'demoAccountRequired' | 'notes'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsCiProducts?: Array<'additionalRepositories' | 'app' | 'buildRuns' | 'bundleId' | 'createdDate' | 'name' | 'primaryRepositories' | 'productType' | 'workflows'>, fieldsReviewSubmissions?: Array<'app' | 'appStoreVersionForReview' | 'canceled' | 'items' | 'lastUpdatedByActor' | 'platform' | 'state' | 'submitted' | 'submittedByActor' | 'submittedDate'>, fieldsBetaGroups?: Array<'app' | 'betaTesters' | 'builds' | 'createdDate' | 'feedbackEnabled' | 'hasAccessToAllBuilds' | 'iosBuildsAvailableForAppleSiliconMac' | 'isInternalGroup' | 'name' | 'publicLink' | 'publicLinkEnabled' | 'publicLinkId' | 'publicLinkLimit' | 'publicLinkLimitEnabled'>, fieldsPromotedPurchases?: Array<'app' | 'enabled' | 'inAppPurchaseV2' | 'promotionImages' | 'state' | 'subscription' | 'visibleForAllUsers'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsAppEvents?: Array<'app' | 'archivedTerritorySchedules' | 'badge' | 'deepLink' | 'eventState' | 'localizations' | 'primaryLocale' | 'priority' | 'purchaseRequirement' | 'purpose' | 'referenceName' | 'territorySchedules'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, fieldsBetaLicenseAgreements?: Array<'agreementText' | 'app'>, fieldsAppClips?: Array<'app' | 'appClipAdvancedExperiences' | 'appClipDefaultExperiences' | 'bundleId'>, fieldsBetaAppLocalizations?: Array<'app' | 'description' | 'feedbackEmail' | 'locale' | 'marketingUrl' | 'privacyPolicyUrl' | 'tvOsPrivacyPolicy'>, fieldsAppInfos?: Array<'ageRatingDeclaration' | 'app' | 'appInfoLocalizations' | 'appStoreAgeRating' | 'appStoreState' | 'brazilAgeRating' | 'brazilAgeRatingV2' | 'kidsAgeBand' | 'primaryCategory' | 'primarySubcategoryOne' | 'primarySubcategoryTwo' | 'secondaryCategory' | 'secondarySubcategoryOne' | 'secondarySubcategoryTwo' | 'state'>, fieldsPreReleaseVersions?: Array<'app' | 'builds' | 'platform' | 'version'>, fieldsInAppPurchases?: Array<'app' | 'appStoreReviewScreenshot' | 'apps' | 'content' | 'contentHosting' | 'familySharable' | 'iapPriceSchedule' | 'inAppPurchaseAvailability' | 'inAppPurchaseLocalizations' | 'inAppPurchaseType' | 'name' | 'pricePoints' | 'productId' | 'promotedPurchase' | 'referenceName' | 'reviewNote' | 'state'>, fieldsSubscriptionGroups?: Array<'app' | 'referenceName' | 'subscriptionGroupLocalizations' | 'subscriptions'>, fieldsAppPreOrders?: Array<'app' | 'appReleaseDate' | 'preOrderAvailableDate'>, fieldsAppPrices?: Array<'app' | 'priceTier'>, fieldsGameCenterEnabledVersions?: Array<'app' | 'compatibleVersions' | 'iconAsset' | 'platform' | 'versionString'>, fieldsAppStoreVersionExperiments?: Array<'app' | 'appStoreVersionExperimentTreatments' | 'controlVersions' | 'endDate' | 'latestControlVersion' | 'name' | 'platform' | 'reviewRequired' | 'startDate' | 'started' | 'state' | 'trafficProportion'>, fieldsSubscriptionGracePeriods?: Array<'duration' | 'optIn' | 'renewalType' | 'sandboxOptIn'>, fieldsEndUserLicenseAgreements?: Array<'agreementText' | 'app' | 'territories'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsAppEncryptionDeclarations?: Array<'app' | 'appDescription' | 'appEncryptionDeclarationDocument' | 'appEncryptionDeclarationState' | 'availableOnFrenchStore' | 'builds' | 'codeValue' | 'containsProprietaryCryptography' | 'containsThirdPartyCryptography' | 'createdDate' | 'documentName' | 'documentType' | 'documentUrl' | 'exempt' | 'platform' | 'uploadedDate' | 'usesEncryption'>, fieldsAppCustomProductPages?: Array<'app' | 'appCustomProductPageVersions' | 'appStoreVersionTemplate' | 'customProductPageTemplate' | 'name' | 'url' | 'visible'>, fieldsTerritories?: Array<'currency'>, limitAppEncryptionDeclarations?: number, limitBetaGroups?: number, limitAppStoreVersions?: number, limitPreReleaseVersions?: number, limitBetaAppLocalizations?: number, limitBuilds?: number, limitAppInfos?: number, limitAppClips?: number, limitPrices?: number, limitAvailableTerritories?: number, limitInAppPurchases?: number, limitSubscriptionGroups?: number, limitGameCenterEnabledVersions?: number, limitAppCustomProductPages?: number, limitInAppPurchasesV2?: number, limitPromotedPurchases?: number, limitAppEvents?: number, limitReviewSubmissions?: number, limitAppStoreVersionExperimentsV2?: number, include?: Array<'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'builds' | 'ciProduct' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'preOrder' | 'preReleaseVersions' | 'prices' | 'promotedPurchases' | 'reviewSubmissions' | 'subscriptionGracePeriod' | 'subscriptionGroups'>, _options?: Configuration): Promise<AppResponse> {
        const result = this.api.ciProductsAppGetToOneRelated(id, fieldsBetaAppReviewDetails, fieldsGameCenterDetails, fieldsCiProducts, fieldsReviewSubmissions, fieldsBetaGroups, fieldsPromotedPurchases, fieldsApps, fieldsAppEvents, fieldsBuilds, fieldsBetaLicenseAgreements, fieldsAppClips, fieldsBetaAppLocalizations, fieldsAppInfos, fieldsPreReleaseVersions, fieldsInAppPurchases, fieldsSubscriptionGroups, fieldsAppPreOrders, fieldsAppPrices, fieldsGameCenterEnabledVersions, fieldsAppStoreVersionExperiments, fieldsSubscriptionGracePeriods, fieldsEndUserLicenseAgreements, fieldsAppStoreVersions, fieldsAppEncryptionDeclarations, fieldsAppCustomProductPages, fieldsTerritories, limitAppEncryptionDeclarations, limitBetaGroups, limitAppStoreVersions, limitPreReleaseVersions, limitBetaAppLocalizations, limitBuilds, limitAppInfos, limitAppClips, limitPrices, limitAvailableTerritories, limitInAppPurchases, limitSubscriptionGroups, limitGameCenterEnabledVersions, limitAppCustomProductPages, limitInAppPurchasesV2, limitPromotedPurchases, limitAppEvents, limitReviewSubmissions, limitAppStoreVersionExperimentsV2, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterBuilds filter by id(s) of related \&#39;builds\&#39;
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsScmGitReferences the fields to include for returned resources of type scmGitReferences
     * @param fieldsCiBuildRuns the fields to include for returned resources of type ciBuildRuns
     * @param fieldsCiWorkflows the fields to include for returned resources of type ciWorkflows
     * @param fieldsScmPullRequests the fields to include for returned resources of type scmPullRequests
     * @param fieldsCiProducts the fields to include for returned resources of type ciProducts
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param limit maximum resources per page
     * @param limitBuilds maximum number of related builds returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public ciProductsBuildRunsGetToManyRelatedWithHttpInfo(id: string, filterBuilds?: Array<string>, sort?: Array<'number' | '-number'>, fieldsScmGitReferences?: Array<'canonicalName' | 'isDeleted' | 'kind' | 'name' | 'repository'>, fieldsCiBuildRuns?: Array<'actions' | 'buildRun' | 'builds' | 'cancelReason' | 'clean' | 'completionStatus' | 'createdDate' | 'destinationBranch' | 'destinationCommit' | 'executionProgress' | 'finishedDate' | 'isPullRequestBuild' | 'issueCounts' | 'number' | 'product' | 'pullRequest' | 'sourceBranchOrTag' | 'sourceCommit' | 'startReason' | 'startedDate' | 'workflow'>, fieldsCiWorkflows?: Array<'actions' | 'branchStartCondition' | 'buildRuns' | 'clean' | 'containerFilePath' | 'description' | 'isEnabled' | 'isLockedForEditing' | 'lastModifiedDate' | 'macOsVersion' | 'manualBranchStartCondition' | 'manualPullRequestStartCondition' | 'manualTagStartCondition' | 'name' | 'product' | 'pullRequestStartCondition' | 'repository' | 'scheduledStartCondition' | 'tagStartCondition' | 'xcodeVersion'>, fieldsScmPullRequests?: Array<'destinationBranchName' | 'destinationRepositoryName' | 'destinationRepositoryOwner' | 'isClosed' | 'isCrossRepository' | 'number' | 'repository' | 'sourceBranchName' | 'sourceRepositoryName' | 'sourceRepositoryOwner' | 'title' | 'webUrl'>, fieldsCiProducts?: Array<'additionalRepositories' | 'app' | 'buildRuns' | 'bundleId' | 'createdDate' | 'name' | 'primaryRepositories' | 'productType' | 'workflows'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, limit?: number, limitBuilds?: number, include?: Array<'builds' | 'destinationBranch' | 'product' | 'pullRequest' | 'sourceBranchOrTag' | 'workflow'>, _options?: Configuration): Promise<HttpInfo<CiBuildRunsResponse>> {
        const result = this.api.ciProductsBuildRunsGetToManyRelatedWithHttpInfo(id, filterBuilds, sort, fieldsScmGitReferences, fieldsCiBuildRuns, fieldsCiWorkflows, fieldsScmPullRequests, fieldsCiProducts, fieldsBuilds, limit, limitBuilds, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterBuilds filter by id(s) of related \&#39;builds\&#39;
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsScmGitReferences the fields to include for returned resources of type scmGitReferences
     * @param fieldsCiBuildRuns the fields to include for returned resources of type ciBuildRuns
     * @param fieldsCiWorkflows the fields to include for returned resources of type ciWorkflows
     * @param fieldsScmPullRequests the fields to include for returned resources of type scmPullRequests
     * @param fieldsCiProducts the fields to include for returned resources of type ciProducts
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param limit maximum resources per page
     * @param limitBuilds maximum number of related builds returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public ciProductsBuildRunsGetToManyRelated(id: string, filterBuilds?: Array<string>, sort?: Array<'number' | '-number'>, fieldsScmGitReferences?: Array<'canonicalName' | 'isDeleted' | 'kind' | 'name' | 'repository'>, fieldsCiBuildRuns?: Array<'actions' | 'buildRun' | 'builds' | 'cancelReason' | 'clean' | 'completionStatus' | 'createdDate' | 'destinationBranch' | 'destinationCommit' | 'executionProgress' | 'finishedDate' | 'isPullRequestBuild' | 'issueCounts' | 'number' | 'product' | 'pullRequest' | 'sourceBranchOrTag' | 'sourceCommit' | 'startReason' | 'startedDate' | 'workflow'>, fieldsCiWorkflows?: Array<'actions' | 'branchStartCondition' | 'buildRuns' | 'clean' | 'containerFilePath' | 'description' | 'isEnabled' | 'isLockedForEditing' | 'lastModifiedDate' | 'macOsVersion' | 'manualBranchStartCondition' | 'manualPullRequestStartCondition' | 'manualTagStartCondition' | 'name' | 'product' | 'pullRequestStartCondition' | 'repository' | 'scheduledStartCondition' | 'tagStartCondition' | 'xcodeVersion'>, fieldsScmPullRequests?: Array<'destinationBranchName' | 'destinationRepositoryName' | 'destinationRepositoryOwner' | 'isClosed' | 'isCrossRepository' | 'number' | 'repository' | 'sourceBranchName' | 'sourceRepositoryName' | 'sourceRepositoryOwner' | 'title' | 'webUrl'>, fieldsCiProducts?: Array<'additionalRepositories' | 'app' | 'buildRuns' | 'bundleId' | 'createdDate' | 'name' | 'primaryRepositories' | 'productType' | 'workflows'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, limit?: number, limitBuilds?: number, include?: Array<'builds' | 'destinationBranch' | 'product' | 'pullRequest' | 'sourceBranchOrTag' | 'workflow'>, _options?: Configuration): Promise<CiBuildRunsResponse> {
        const result = this.api.ciProductsBuildRunsGetToManyRelated(id, filterBuilds, sort, fieldsScmGitReferences, fieldsCiBuildRuns, fieldsCiWorkflows, fieldsScmPullRequests, fieldsCiProducts, fieldsBuilds, limit, limitBuilds, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public ciProductsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.ciProductsDeleteInstanceWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public ciProductsDeleteInstance(id: string, _options?: Configuration): Promise<void> {
        const result = this.api.ciProductsDeleteInstance(id, _options);
        return result.toPromise();
    }

    /**
     * @param filterProductType filter by attribute \&#39;productType\&#39;
     * @param filterApp filter by id(s) of related \&#39;app\&#39;
     * @param fieldsCiProducts the fields to include for returned resources of type ciProducts
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsCiBuildRuns the fields to include for returned resources of type ciBuildRuns
     * @param fieldsCiWorkflows the fields to include for returned resources of type ciWorkflows
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsScmRepositories the fields to include for returned resources of type scmRepositories
     * @param limitPrimaryRepositories maximum number of related primaryRepositories returned (when they are included)
     */
    public ciProductsGetCollectionWithHttpInfo(filterProductType?: Array<'APP' | 'FRAMEWORK'>, filterApp?: Array<string>, fieldsCiProducts?: Array<'additionalRepositories' | 'app' | 'buildRuns' | 'bundleId' | 'createdDate' | 'name' | 'primaryRepositories' | 'productType' | 'workflows'>, limit?: number, include?: Array<'app' | 'bundleId' | 'primaryRepositories'>, fieldsCiBuildRuns?: Array<'actions' | 'buildRun' | 'builds' | 'cancelReason' | 'clean' | 'completionStatus' | 'createdDate' | 'destinationBranch' | 'destinationCommit' | 'executionProgress' | 'finishedDate' | 'isPullRequestBuild' | 'issueCounts' | 'number' | 'product' | 'pullRequest' | 'sourceBranchOrTag' | 'sourceCommit' | 'startReason' | 'startedDate' | 'workflow'>, fieldsCiWorkflows?: Array<'actions' | 'branchStartCondition' | 'buildRuns' | 'clean' | 'containerFilePath' | 'description' | 'isEnabled' | 'isLockedForEditing' | 'lastModifiedDate' | 'macOsVersion' | 'manualBranchStartCondition' | 'manualPullRequestStartCondition' | 'manualTagStartCondition' | 'name' | 'product' | 'pullRequestStartCondition' | 'repository' | 'scheduledStartCondition' | 'tagStartCondition' | 'xcodeVersion'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsScmRepositories?: Array<'defaultBranch' | 'gitReferences' | 'httpCloneUrl' | 'lastAccessedDate' | 'ownerName' | 'pullRequests' | 'repositoryName' | 'scmProvider' | 'sshCloneUrl'>, limitPrimaryRepositories?: number, _options?: Configuration): Promise<HttpInfo<CiProductsResponse>> {
        const result = this.api.ciProductsGetCollectionWithHttpInfo(filterProductType, filterApp, fieldsCiProducts, limit, include, fieldsCiBuildRuns, fieldsCiWorkflows, fieldsApps, fieldsScmRepositories, limitPrimaryRepositories, _options);
        return result.toPromise();
    }

    /**
     * @param filterProductType filter by attribute \&#39;productType\&#39;
     * @param filterApp filter by id(s) of related \&#39;app\&#39;
     * @param fieldsCiProducts the fields to include for returned resources of type ciProducts
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsCiBuildRuns the fields to include for returned resources of type ciBuildRuns
     * @param fieldsCiWorkflows the fields to include for returned resources of type ciWorkflows
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsScmRepositories the fields to include for returned resources of type scmRepositories
     * @param limitPrimaryRepositories maximum number of related primaryRepositories returned (when they are included)
     */
    public ciProductsGetCollection(filterProductType?: Array<'APP' | 'FRAMEWORK'>, filterApp?: Array<string>, fieldsCiProducts?: Array<'additionalRepositories' | 'app' | 'buildRuns' | 'bundleId' | 'createdDate' | 'name' | 'primaryRepositories' | 'productType' | 'workflows'>, limit?: number, include?: Array<'app' | 'bundleId' | 'primaryRepositories'>, fieldsCiBuildRuns?: Array<'actions' | 'buildRun' | 'builds' | 'cancelReason' | 'clean' | 'completionStatus' | 'createdDate' | 'destinationBranch' | 'destinationCommit' | 'executionProgress' | 'finishedDate' | 'isPullRequestBuild' | 'issueCounts' | 'number' | 'product' | 'pullRequest' | 'sourceBranchOrTag' | 'sourceCommit' | 'startReason' | 'startedDate' | 'workflow'>, fieldsCiWorkflows?: Array<'actions' | 'branchStartCondition' | 'buildRuns' | 'clean' | 'containerFilePath' | 'description' | 'isEnabled' | 'isLockedForEditing' | 'lastModifiedDate' | 'macOsVersion' | 'manualBranchStartCondition' | 'manualPullRequestStartCondition' | 'manualTagStartCondition' | 'name' | 'product' | 'pullRequestStartCondition' | 'repository' | 'scheduledStartCondition' | 'tagStartCondition' | 'xcodeVersion'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsScmRepositories?: Array<'defaultBranch' | 'gitReferences' | 'httpCloneUrl' | 'lastAccessedDate' | 'ownerName' | 'pullRequests' | 'repositoryName' | 'scmProvider' | 'sshCloneUrl'>, limitPrimaryRepositories?: number, _options?: Configuration): Promise<CiProductsResponse> {
        const result = this.api.ciProductsGetCollection(filterProductType, filterApp, fieldsCiProducts, limit, include, fieldsCiBuildRuns, fieldsCiWorkflows, fieldsApps, fieldsScmRepositories, limitPrimaryRepositories, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCiProducts the fields to include for returned resources of type ciProducts
     * @param include comma-separated list of relationships to include
     * @param fieldsCiBuildRuns the fields to include for returned resources of type ciBuildRuns
     * @param fieldsCiWorkflows the fields to include for returned resources of type ciWorkflows
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsScmRepositories the fields to include for returned resources of type scmRepositories
     * @param limitPrimaryRepositories maximum number of related primaryRepositories returned (when they are included)
     */
    public ciProductsGetInstanceWithHttpInfo(id: string, fieldsCiProducts?: Array<'additionalRepositories' | 'app' | 'buildRuns' | 'bundleId' | 'createdDate' | 'name' | 'primaryRepositories' | 'productType' | 'workflows'>, include?: Array<'app' | 'bundleId' | 'primaryRepositories'>, fieldsCiBuildRuns?: Array<'actions' | 'buildRun' | 'builds' | 'cancelReason' | 'clean' | 'completionStatus' | 'createdDate' | 'destinationBranch' | 'destinationCommit' | 'executionProgress' | 'finishedDate' | 'isPullRequestBuild' | 'issueCounts' | 'number' | 'product' | 'pullRequest' | 'sourceBranchOrTag' | 'sourceCommit' | 'startReason' | 'startedDate' | 'workflow'>, fieldsCiWorkflows?: Array<'actions' | 'branchStartCondition' | 'buildRuns' | 'clean' | 'containerFilePath' | 'description' | 'isEnabled' | 'isLockedForEditing' | 'lastModifiedDate' | 'macOsVersion' | 'manualBranchStartCondition' | 'manualPullRequestStartCondition' | 'manualTagStartCondition' | 'name' | 'product' | 'pullRequestStartCondition' | 'repository' | 'scheduledStartCondition' | 'tagStartCondition' | 'xcodeVersion'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsScmRepositories?: Array<'defaultBranch' | 'gitReferences' | 'httpCloneUrl' | 'lastAccessedDate' | 'ownerName' | 'pullRequests' | 'repositoryName' | 'scmProvider' | 'sshCloneUrl'>, limitPrimaryRepositories?: number, _options?: Configuration): Promise<HttpInfo<CiProductResponse>> {
        const result = this.api.ciProductsGetInstanceWithHttpInfo(id, fieldsCiProducts, include, fieldsCiBuildRuns, fieldsCiWorkflows, fieldsApps, fieldsScmRepositories, limitPrimaryRepositories, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCiProducts the fields to include for returned resources of type ciProducts
     * @param include comma-separated list of relationships to include
     * @param fieldsCiBuildRuns the fields to include for returned resources of type ciBuildRuns
     * @param fieldsCiWorkflows the fields to include for returned resources of type ciWorkflows
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsScmRepositories the fields to include for returned resources of type scmRepositories
     * @param limitPrimaryRepositories maximum number of related primaryRepositories returned (when they are included)
     */
    public ciProductsGetInstance(id: string, fieldsCiProducts?: Array<'additionalRepositories' | 'app' | 'buildRuns' | 'bundleId' | 'createdDate' | 'name' | 'primaryRepositories' | 'productType' | 'workflows'>, include?: Array<'app' | 'bundleId' | 'primaryRepositories'>, fieldsCiBuildRuns?: Array<'actions' | 'buildRun' | 'builds' | 'cancelReason' | 'clean' | 'completionStatus' | 'createdDate' | 'destinationBranch' | 'destinationCommit' | 'executionProgress' | 'finishedDate' | 'isPullRequestBuild' | 'issueCounts' | 'number' | 'product' | 'pullRequest' | 'sourceBranchOrTag' | 'sourceCommit' | 'startReason' | 'startedDate' | 'workflow'>, fieldsCiWorkflows?: Array<'actions' | 'branchStartCondition' | 'buildRuns' | 'clean' | 'containerFilePath' | 'description' | 'isEnabled' | 'isLockedForEditing' | 'lastModifiedDate' | 'macOsVersion' | 'manualBranchStartCondition' | 'manualPullRequestStartCondition' | 'manualTagStartCondition' | 'name' | 'product' | 'pullRequestStartCondition' | 'repository' | 'scheduledStartCondition' | 'tagStartCondition' | 'xcodeVersion'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsScmRepositories?: Array<'defaultBranch' | 'gitReferences' | 'httpCloneUrl' | 'lastAccessedDate' | 'ownerName' | 'pullRequests' | 'repositoryName' | 'scmProvider' | 'sshCloneUrl'>, limitPrimaryRepositories?: number, _options?: Configuration): Promise<CiProductResponse> {
        const result = this.api.ciProductsGetInstance(id, fieldsCiProducts, include, fieldsCiBuildRuns, fieldsCiWorkflows, fieldsApps, fieldsScmRepositories, limitPrimaryRepositories, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterId filter by id(s)
     * @param fieldsScmGitReferences the fields to include for returned resources of type scmGitReferences
     * @param fieldsScmProviders the fields to include for returned resources of type scmProviders
     * @param fieldsScmRepositories the fields to include for returned resources of type scmRepositories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public ciProductsPrimaryRepositoriesGetToManyRelatedWithHttpInfo(id: string, filterId?: Array<string>, fieldsScmGitReferences?: Array<'canonicalName' | 'isDeleted' | 'kind' | 'name' | 'repository'>, fieldsScmProviders?: Array<'repositories' | 'scmProviderType' | 'url'>, fieldsScmRepositories?: Array<'defaultBranch' | 'gitReferences' | 'httpCloneUrl' | 'lastAccessedDate' | 'ownerName' | 'pullRequests' | 'repositoryName' | 'scmProvider' | 'sshCloneUrl'>, limit?: number, include?: Array<'defaultBranch' | 'scmProvider'>, _options?: Configuration): Promise<HttpInfo<ScmRepositoriesResponse>> {
        const result = this.api.ciProductsPrimaryRepositoriesGetToManyRelatedWithHttpInfo(id, filterId, fieldsScmGitReferences, fieldsScmProviders, fieldsScmRepositories, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterId filter by id(s)
     * @param fieldsScmGitReferences the fields to include for returned resources of type scmGitReferences
     * @param fieldsScmProviders the fields to include for returned resources of type scmProviders
     * @param fieldsScmRepositories the fields to include for returned resources of type scmRepositories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public ciProductsPrimaryRepositoriesGetToManyRelated(id: string, filterId?: Array<string>, fieldsScmGitReferences?: Array<'canonicalName' | 'isDeleted' | 'kind' | 'name' | 'repository'>, fieldsScmProviders?: Array<'repositories' | 'scmProviderType' | 'url'>, fieldsScmRepositories?: Array<'defaultBranch' | 'gitReferences' | 'httpCloneUrl' | 'lastAccessedDate' | 'ownerName' | 'pullRequests' | 'repositoryName' | 'scmProvider' | 'sshCloneUrl'>, limit?: number, include?: Array<'defaultBranch' | 'scmProvider'>, _options?: Configuration): Promise<ScmRepositoriesResponse> {
        const result = this.api.ciProductsPrimaryRepositoriesGetToManyRelated(id, filterId, fieldsScmGitReferences, fieldsScmProviders, fieldsScmRepositories, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCiXcodeVersions the fields to include for returned resources of type ciXcodeVersions
     * @param fieldsCiWorkflows the fields to include for returned resources of type ciWorkflows
     * @param fieldsCiMacOsVersions the fields to include for returned resources of type ciMacOsVersions
     * @param fieldsCiProducts the fields to include for returned resources of type ciProducts
     * @param fieldsScmRepositories the fields to include for returned resources of type scmRepositories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public ciProductsWorkflowsGetToManyRelatedWithHttpInfo(id: string, fieldsCiXcodeVersions?: Array<'macOsVersions' | 'name' | 'testDestinations' | 'version'>, fieldsCiWorkflows?: Array<'actions' | 'branchStartCondition' | 'buildRuns' | 'clean' | 'containerFilePath' | 'description' | 'isEnabled' | 'isLockedForEditing' | 'lastModifiedDate' | 'macOsVersion' | 'manualBranchStartCondition' | 'manualPullRequestStartCondition' | 'manualTagStartCondition' | 'name' | 'product' | 'pullRequestStartCondition' | 'repository' | 'scheduledStartCondition' | 'tagStartCondition' | 'xcodeVersion'>, fieldsCiMacOsVersions?: Array<'name' | 'version' | 'xcodeVersions'>, fieldsCiProducts?: Array<'additionalRepositories' | 'app' | 'buildRuns' | 'bundleId' | 'createdDate' | 'name' | 'primaryRepositories' | 'productType' | 'workflows'>, fieldsScmRepositories?: Array<'defaultBranch' | 'gitReferences' | 'httpCloneUrl' | 'lastAccessedDate' | 'ownerName' | 'pullRequests' | 'repositoryName' | 'scmProvider' | 'sshCloneUrl'>, limit?: number, include?: Array<'macOsVersion' | 'product' | 'repository' | 'xcodeVersion'>, _options?: Configuration): Promise<HttpInfo<CiWorkflowsResponse>> {
        const result = this.api.ciProductsWorkflowsGetToManyRelatedWithHttpInfo(id, fieldsCiXcodeVersions, fieldsCiWorkflows, fieldsCiMacOsVersions, fieldsCiProducts, fieldsScmRepositories, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCiXcodeVersions the fields to include for returned resources of type ciXcodeVersions
     * @param fieldsCiWorkflows the fields to include for returned resources of type ciWorkflows
     * @param fieldsCiMacOsVersions the fields to include for returned resources of type ciMacOsVersions
     * @param fieldsCiProducts the fields to include for returned resources of type ciProducts
     * @param fieldsScmRepositories the fields to include for returned resources of type scmRepositories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public ciProductsWorkflowsGetToManyRelated(id: string, fieldsCiXcodeVersions?: Array<'macOsVersions' | 'name' | 'testDestinations' | 'version'>, fieldsCiWorkflows?: Array<'actions' | 'branchStartCondition' | 'buildRuns' | 'clean' | 'containerFilePath' | 'description' | 'isEnabled' | 'isLockedForEditing' | 'lastModifiedDate' | 'macOsVersion' | 'manualBranchStartCondition' | 'manualPullRequestStartCondition' | 'manualTagStartCondition' | 'name' | 'product' | 'pullRequestStartCondition' | 'repository' | 'scheduledStartCondition' | 'tagStartCondition' | 'xcodeVersion'>, fieldsCiMacOsVersions?: Array<'name' | 'version' | 'xcodeVersions'>, fieldsCiProducts?: Array<'additionalRepositories' | 'app' | 'buildRuns' | 'bundleId' | 'createdDate' | 'name' | 'primaryRepositories' | 'productType' | 'workflows'>, fieldsScmRepositories?: Array<'defaultBranch' | 'gitReferences' | 'httpCloneUrl' | 'lastAccessedDate' | 'ownerName' | 'pullRequests' | 'repositoryName' | 'scmProvider' | 'sshCloneUrl'>, limit?: number, include?: Array<'macOsVersion' | 'product' | 'repository' | 'xcodeVersion'>, _options?: Configuration): Promise<CiWorkflowsResponse> {
        const result = this.api.ciProductsWorkflowsGetToManyRelated(id, fieldsCiXcodeVersions, fieldsCiWorkflows, fieldsCiMacOsVersions, fieldsCiProducts, fieldsScmRepositories, limit, include, _options);
        return result.toPromise();
    }


}



import { ObservableCiTestResultsApi } from './ObservableAPI.ts';

import { CiTestResultsApiRequestFactory, CiTestResultsApiResponseProcessor} from "../apis/CiTestResultsApi.ts";
export class PromiseCiTestResultsApi {
    private api: ObservableCiTestResultsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: CiTestResultsApiRequestFactory,
        responseProcessor?: CiTestResultsApiResponseProcessor
    ) {
        this.api = new ObservableCiTestResultsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCiTestResults the fields to include for returned resources of type ciTestResults
     */
    public ciTestResultsGetInstanceWithHttpInfo(id: string, fieldsCiTestResults?: Array<'className' | 'destinationTestResults' | 'fileSource' | 'message' | 'name' | 'status'>, _options?: Configuration): Promise<HttpInfo<CiTestResultResponse>> {
        const result = this.api.ciTestResultsGetInstanceWithHttpInfo(id, fieldsCiTestResults, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCiTestResults the fields to include for returned resources of type ciTestResults
     */
    public ciTestResultsGetInstance(id: string, fieldsCiTestResults?: Array<'className' | 'destinationTestResults' | 'fileSource' | 'message' | 'name' | 'status'>, _options?: Configuration): Promise<CiTestResultResponse> {
        const result = this.api.ciTestResultsGetInstance(id, fieldsCiTestResults, _options);
        return result.toPromise();
    }


}



import { ObservableCiWorkflowsApi } from './ObservableAPI.ts';

import { CiWorkflowsApiRequestFactory, CiWorkflowsApiResponseProcessor} from "../apis/CiWorkflowsApi.ts";
export class PromiseCiWorkflowsApi {
    private api: ObservableCiWorkflowsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: CiWorkflowsApiRequestFactory,
        responseProcessor?: CiWorkflowsApiResponseProcessor
    ) {
        this.api = new ObservableCiWorkflowsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param id the id of the requested resource
     * @param filterBuilds filter by id(s) of related \&#39;builds\&#39;
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsScmGitReferences the fields to include for returned resources of type scmGitReferences
     * @param fieldsCiBuildRuns the fields to include for returned resources of type ciBuildRuns
     * @param fieldsCiWorkflows the fields to include for returned resources of type ciWorkflows
     * @param fieldsScmPullRequests the fields to include for returned resources of type scmPullRequests
     * @param fieldsCiProducts the fields to include for returned resources of type ciProducts
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param limit maximum resources per page
     * @param limitBuilds maximum number of related builds returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public ciWorkflowsBuildRunsGetToManyRelatedWithHttpInfo(id: string, filterBuilds?: Array<string>, sort?: Array<'number' | '-number'>, fieldsScmGitReferences?: Array<'canonicalName' | 'isDeleted' | 'kind' | 'name' | 'repository'>, fieldsCiBuildRuns?: Array<'actions' | 'buildRun' | 'builds' | 'cancelReason' | 'clean' | 'completionStatus' | 'createdDate' | 'destinationBranch' | 'destinationCommit' | 'executionProgress' | 'finishedDate' | 'isPullRequestBuild' | 'issueCounts' | 'number' | 'product' | 'pullRequest' | 'sourceBranchOrTag' | 'sourceCommit' | 'startReason' | 'startedDate' | 'workflow'>, fieldsCiWorkflows?: Array<'actions' | 'branchStartCondition' | 'buildRuns' | 'clean' | 'containerFilePath' | 'description' | 'isEnabled' | 'isLockedForEditing' | 'lastModifiedDate' | 'macOsVersion' | 'manualBranchStartCondition' | 'manualPullRequestStartCondition' | 'manualTagStartCondition' | 'name' | 'product' | 'pullRequestStartCondition' | 'repository' | 'scheduledStartCondition' | 'tagStartCondition' | 'xcodeVersion'>, fieldsScmPullRequests?: Array<'destinationBranchName' | 'destinationRepositoryName' | 'destinationRepositoryOwner' | 'isClosed' | 'isCrossRepository' | 'number' | 'repository' | 'sourceBranchName' | 'sourceRepositoryName' | 'sourceRepositoryOwner' | 'title' | 'webUrl'>, fieldsCiProducts?: Array<'additionalRepositories' | 'app' | 'buildRuns' | 'bundleId' | 'createdDate' | 'name' | 'primaryRepositories' | 'productType' | 'workflows'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, limit?: number, limitBuilds?: number, include?: Array<'builds' | 'destinationBranch' | 'product' | 'pullRequest' | 'sourceBranchOrTag' | 'workflow'>, _options?: Configuration): Promise<HttpInfo<CiBuildRunsResponse>> {
        const result = this.api.ciWorkflowsBuildRunsGetToManyRelatedWithHttpInfo(id, filterBuilds, sort, fieldsScmGitReferences, fieldsCiBuildRuns, fieldsCiWorkflows, fieldsScmPullRequests, fieldsCiProducts, fieldsBuilds, limit, limitBuilds, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterBuilds filter by id(s) of related \&#39;builds\&#39;
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsScmGitReferences the fields to include for returned resources of type scmGitReferences
     * @param fieldsCiBuildRuns the fields to include for returned resources of type ciBuildRuns
     * @param fieldsCiWorkflows the fields to include for returned resources of type ciWorkflows
     * @param fieldsScmPullRequests the fields to include for returned resources of type scmPullRequests
     * @param fieldsCiProducts the fields to include for returned resources of type ciProducts
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param limit maximum resources per page
     * @param limitBuilds maximum number of related builds returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public ciWorkflowsBuildRunsGetToManyRelated(id: string, filterBuilds?: Array<string>, sort?: Array<'number' | '-number'>, fieldsScmGitReferences?: Array<'canonicalName' | 'isDeleted' | 'kind' | 'name' | 'repository'>, fieldsCiBuildRuns?: Array<'actions' | 'buildRun' | 'builds' | 'cancelReason' | 'clean' | 'completionStatus' | 'createdDate' | 'destinationBranch' | 'destinationCommit' | 'executionProgress' | 'finishedDate' | 'isPullRequestBuild' | 'issueCounts' | 'number' | 'product' | 'pullRequest' | 'sourceBranchOrTag' | 'sourceCommit' | 'startReason' | 'startedDate' | 'workflow'>, fieldsCiWorkflows?: Array<'actions' | 'branchStartCondition' | 'buildRuns' | 'clean' | 'containerFilePath' | 'description' | 'isEnabled' | 'isLockedForEditing' | 'lastModifiedDate' | 'macOsVersion' | 'manualBranchStartCondition' | 'manualPullRequestStartCondition' | 'manualTagStartCondition' | 'name' | 'product' | 'pullRequestStartCondition' | 'repository' | 'scheduledStartCondition' | 'tagStartCondition' | 'xcodeVersion'>, fieldsScmPullRequests?: Array<'destinationBranchName' | 'destinationRepositoryName' | 'destinationRepositoryOwner' | 'isClosed' | 'isCrossRepository' | 'number' | 'repository' | 'sourceBranchName' | 'sourceRepositoryName' | 'sourceRepositoryOwner' | 'title' | 'webUrl'>, fieldsCiProducts?: Array<'additionalRepositories' | 'app' | 'buildRuns' | 'bundleId' | 'createdDate' | 'name' | 'primaryRepositories' | 'productType' | 'workflows'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, limit?: number, limitBuilds?: number, include?: Array<'builds' | 'destinationBranch' | 'product' | 'pullRequest' | 'sourceBranchOrTag' | 'workflow'>, _options?: Configuration): Promise<CiBuildRunsResponse> {
        const result = this.api.ciWorkflowsBuildRunsGetToManyRelated(id, filterBuilds, sort, fieldsScmGitReferences, fieldsCiBuildRuns, fieldsCiWorkflows, fieldsScmPullRequests, fieldsCiProducts, fieldsBuilds, limit, limitBuilds, include, _options);
        return result.toPromise();
    }

    /**
     * @param ciWorkflowCreateRequest CiWorkflow representation
     */
    public ciWorkflowsCreateInstanceWithHttpInfo(ciWorkflowCreateRequest: CiWorkflowCreateRequest, _options?: Configuration): Promise<HttpInfo<CiWorkflowResponse>> {
        const result = this.api.ciWorkflowsCreateInstanceWithHttpInfo(ciWorkflowCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param ciWorkflowCreateRequest CiWorkflow representation
     */
    public ciWorkflowsCreateInstance(ciWorkflowCreateRequest: CiWorkflowCreateRequest, _options?: Configuration): Promise<CiWorkflowResponse> {
        const result = this.api.ciWorkflowsCreateInstance(ciWorkflowCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public ciWorkflowsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.ciWorkflowsDeleteInstanceWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public ciWorkflowsDeleteInstance(id: string, _options?: Configuration): Promise<void> {
        const result = this.api.ciWorkflowsDeleteInstance(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCiWorkflows the fields to include for returned resources of type ciWorkflows
     * @param include comma-separated list of relationships to include
     * @param fieldsCiBuildRuns the fields to include for returned resources of type ciBuildRuns
     * @param fieldsScmRepositories the fields to include for returned resources of type scmRepositories
     */
    public ciWorkflowsGetInstanceWithHttpInfo(id: string, fieldsCiWorkflows?: Array<'actions' | 'branchStartCondition' | 'buildRuns' | 'clean' | 'containerFilePath' | 'description' | 'isEnabled' | 'isLockedForEditing' | 'lastModifiedDate' | 'macOsVersion' | 'manualBranchStartCondition' | 'manualPullRequestStartCondition' | 'manualTagStartCondition' | 'name' | 'product' | 'pullRequestStartCondition' | 'repository' | 'scheduledStartCondition' | 'tagStartCondition' | 'xcodeVersion'>, include?: Array<'macOsVersion' | 'product' | 'repository' | 'xcodeVersion'>, fieldsCiBuildRuns?: Array<'actions' | 'buildRun' | 'builds' | 'cancelReason' | 'clean' | 'completionStatus' | 'createdDate' | 'destinationBranch' | 'destinationCommit' | 'executionProgress' | 'finishedDate' | 'isPullRequestBuild' | 'issueCounts' | 'number' | 'product' | 'pullRequest' | 'sourceBranchOrTag' | 'sourceCommit' | 'startReason' | 'startedDate' | 'workflow'>, fieldsScmRepositories?: Array<'defaultBranch' | 'gitReferences' | 'httpCloneUrl' | 'lastAccessedDate' | 'ownerName' | 'pullRequests' | 'repositoryName' | 'scmProvider' | 'sshCloneUrl'>, _options?: Configuration): Promise<HttpInfo<CiWorkflowResponse>> {
        const result = this.api.ciWorkflowsGetInstanceWithHttpInfo(id, fieldsCiWorkflows, include, fieldsCiBuildRuns, fieldsScmRepositories, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCiWorkflows the fields to include for returned resources of type ciWorkflows
     * @param include comma-separated list of relationships to include
     * @param fieldsCiBuildRuns the fields to include for returned resources of type ciBuildRuns
     * @param fieldsScmRepositories the fields to include for returned resources of type scmRepositories
     */
    public ciWorkflowsGetInstance(id: string, fieldsCiWorkflows?: Array<'actions' | 'branchStartCondition' | 'buildRuns' | 'clean' | 'containerFilePath' | 'description' | 'isEnabled' | 'isLockedForEditing' | 'lastModifiedDate' | 'macOsVersion' | 'manualBranchStartCondition' | 'manualPullRequestStartCondition' | 'manualTagStartCondition' | 'name' | 'product' | 'pullRequestStartCondition' | 'repository' | 'scheduledStartCondition' | 'tagStartCondition' | 'xcodeVersion'>, include?: Array<'macOsVersion' | 'product' | 'repository' | 'xcodeVersion'>, fieldsCiBuildRuns?: Array<'actions' | 'buildRun' | 'builds' | 'cancelReason' | 'clean' | 'completionStatus' | 'createdDate' | 'destinationBranch' | 'destinationCommit' | 'executionProgress' | 'finishedDate' | 'isPullRequestBuild' | 'issueCounts' | 'number' | 'product' | 'pullRequest' | 'sourceBranchOrTag' | 'sourceCommit' | 'startReason' | 'startedDate' | 'workflow'>, fieldsScmRepositories?: Array<'defaultBranch' | 'gitReferences' | 'httpCloneUrl' | 'lastAccessedDate' | 'ownerName' | 'pullRequests' | 'repositoryName' | 'scmProvider' | 'sshCloneUrl'>, _options?: Configuration): Promise<CiWorkflowResponse> {
        const result = this.api.ciWorkflowsGetInstance(id, fieldsCiWorkflows, include, fieldsCiBuildRuns, fieldsScmRepositories, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsScmGitReferences the fields to include for returned resources of type scmGitReferences
     * @param fieldsScmProviders the fields to include for returned resources of type scmProviders
     * @param fieldsScmRepositories the fields to include for returned resources of type scmRepositories
     * @param include comma-separated list of relationships to include
     */
    public ciWorkflowsRepositoryGetToOneRelatedWithHttpInfo(id: string, fieldsScmGitReferences?: Array<'canonicalName' | 'isDeleted' | 'kind' | 'name' | 'repository'>, fieldsScmProviders?: Array<'repositories' | 'scmProviderType' | 'url'>, fieldsScmRepositories?: Array<'defaultBranch' | 'gitReferences' | 'httpCloneUrl' | 'lastAccessedDate' | 'ownerName' | 'pullRequests' | 'repositoryName' | 'scmProvider' | 'sshCloneUrl'>, include?: Array<'defaultBranch' | 'scmProvider'>, _options?: Configuration): Promise<HttpInfo<ScmRepositoryResponse>> {
        const result = this.api.ciWorkflowsRepositoryGetToOneRelatedWithHttpInfo(id, fieldsScmGitReferences, fieldsScmProviders, fieldsScmRepositories, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsScmGitReferences the fields to include for returned resources of type scmGitReferences
     * @param fieldsScmProviders the fields to include for returned resources of type scmProviders
     * @param fieldsScmRepositories the fields to include for returned resources of type scmRepositories
     * @param include comma-separated list of relationships to include
     */
    public ciWorkflowsRepositoryGetToOneRelated(id: string, fieldsScmGitReferences?: Array<'canonicalName' | 'isDeleted' | 'kind' | 'name' | 'repository'>, fieldsScmProviders?: Array<'repositories' | 'scmProviderType' | 'url'>, fieldsScmRepositories?: Array<'defaultBranch' | 'gitReferences' | 'httpCloneUrl' | 'lastAccessedDate' | 'ownerName' | 'pullRequests' | 'repositoryName' | 'scmProvider' | 'sshCloneUrl'>, include?: Array<'defaultBranch' | 'scmProvider'>, _options?: Configuration): Promise<ScmRepositoryResponse> {
        const result = this.api.ciWorkflowsRepositoryGetToOneRelated(id, fieldsScmGitReferences, fieldsScmProviders, fieldsScmRepositories, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param ciWorkflowUpdateRequest CiWorkflow representation
     */
    public ciWorkflowsUpdateInstanceWithHttpInfo(id: string, ciWorkflowUpdateRequest: CiWorkflowUpdateRequest, _options?: Configuration): Promise<HttpInfo<CiWorkflowResponse>> {
        const result = this.api.ciWorkflowsUpdateInstanceWithHttpInfo(id, ciWorkflowUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param ciWorkflowUpdateRequest CiWorkflow representation
     */
    public ciWorkflowsUpdateInstance(id: string, ciWorkflowUpdateRequest: CiWorkflowUpdateRequest, _options?: Configuration): Promise<CiWorkflowResponse> {
        const result = this.api.ciWorkflowsUpdateInstance(id, ciWorkflowUpdateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableCiXcodeVersionsApi } from './ObservableAPI.ts';

import { CiXcodeVersionsApiRequestFactory, CiXcodeVersionsApiResponseProcessor} from "../apis/CiXcodeVersionsApi.ts";
export class PromiseCiXcodeVersionsApi {
    private api: ObservableCiXcodeVersionsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: CiXcodeVersionsApiRequestFactory,
        responseProcessor?: CiXcodeVersionsApiResponseProcessor
    ) {
        this.api = new ObservableCiXcodeVersionsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param fieldsCiXcodeVersions the fields to include for returned resources of type ciXcodeVersions
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsCiMacOsVersions the fields to include for returned resources of type ciMacOsVersions
     * @param limitMacOsVersions maximum number of related macOsVersions returned (when they are included)
     */
    public ciXcodeVersionsGetCollectionWithHttpInfo(fieldsCiXcodeVersions?: Array<'macOsVersions' | 'name' | 'testDestinations' | 'version'>, limit?: number, include?: Array<'macOsVersions'>, fieldsCiMacOsVersions?: Array<'name' | 'version' | 'xcodeVersions'>, limitMacOsVersions?: number, _options?: Configuration): Promise<HttpInfo<CiXcodeVersionsResponse>> {
        const result = this.api.ciXcodeVersionsGetCollectionWithHttpInfo(fieldsCiXcodeVersions, limit, include, fieldsCiMacOsVersions, limitMacOsVersions, _options);
        return result.toPromise();
    }

    /**
     * @param fieldsCiXcodeVersions the fields to include for returned resources of type ciXcodeVersions
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsCiMacOsVersions the fields to include for returned resources of type ciMacOsVersions
     * @param limitMacOsVersions maximum number of related macOsVersions returned (when they are included)
     */
    public ciXcodeVersionsGetCollection(fieldsCiXcodeVersions?: Array<'macOsVersions' | 'name' | 'testDestinations' | 'version'>, limit?: number, include?: Array<'macOsVersions'>, fieldsCiMacOsVersions?: Array<'name' | 'version' | 'xcodeVersions'>, limitMacOsVersions?: number, _options?: Configuration): Promise<CiXcodeVersionsResponse> {
        const result = this.api.ciXcodeVersionsGetCollection(fieldsCiXcodeVersions, limit, include, fieldsCiMacOsVersions, limitMacOsVersions, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCiXcodeVersions the fields to include for returned resources of type ciXcodeVersions
     * @param include comma-separated list of relationships to include
     * @param fieldsCiMacOsVersions the fields to include for returned resources of type ciMacOsVersions
     * @param limitMacOsVersions maximum number of related macOsVersions returned (when they are included)
     */
    public ciXcodeVersionsGetInstanceWithHttpInfo(id: string, fieldsCiXcodeVersions?: Array<'macOsVersions' | 'name' | 'testDestinations' | 'version'>, include?: Array<'macOsVersions'>, fieldsCiMacOsVersions?: Array<'name' | 'version' | 'xcodeVersions'>, limitMacOsVersions?: number, _options?: Configuration): Promise<HttpInfo<CiXcodeVersionResponse>> {
        const result = this.api.ciXcodeVersionsGetInstanceWithHttpInfo(id, fieldsCiXcodeVersions, include, fieldsCiMacOsVersions, limitMacOsVersions, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCiXcodeVersions the fields to include for returned resources of type ciXcodeVersions
     * @param include comma-separated list of relationships to include
     * @param fieldsCiMacOsVersions the fields to include for returned resources of type ciMacOsVersions
     * @param limitMacOsVersions maximum number of related macOsVersions returned (when they are included)
     */
    public ciXcodeVersionsGetInstance(id: string, fieldsCiXcodeVersions?: Array<'macOsVersions' | 'name' | 'testDestinations' | 'version'>, include?: Array<'macOsVersions'>, fieldsCiMacOsVersions?: Array<'name' | 'version' | 'xcodeVersions'>, limitMacOsVersions?: number, _options?: Configuration): Promise<CiXcodeVersionResponse> {
        const result = this.api.ciXcodeVersionsGetInstance(id, fieldsCiXcodeVersions, include, fieldsCiMacOsVersions, limitMacOsVersions, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCiXcodeVersions the fields to include for returned resources of type ciXcodeVersions
     * @param fieldsCiMacOsVersions the fields to include for returned resources of type ciMacOsVersions
     * @param limit maximum resources per page
     * @param limitXcodeVersions maximum number of related xcodeVersions returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public ciXcodeVersionsMacOsVersionsGetToManyRelatedWithHttpInfo(id: string, fieldsCiXcodeVersions?: Array<'macOsVersions' | 'name' | 'testDestinations' | 'version'>, fieldsCiMacOsVersions?: Array<'name' | 'version' | 'xcodeVersions'>, limit?: number, limitXcodeVersions?: number, include?: Array<'xcodeVersions'>, _options?: Configuration): Promise<HttpInfo<CiMacOsVersionsResponse>> {
        const result = this.api.ciXcodeVersionsMacOsVersionsGetToManyRelatedWithHttpInfo(id, fieldsCiXcodeVersions, fieldsCiMacOsVersions, limit, limitXcodeVersions, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCiXcodeVersions the fields to include for returned resources of type ciXcodeVersions
     * @param fieldsCiMacOsVersions the fields to include for returned resources of type ciMacOsVersions
     * @param limit maximum resources per page
     * @param limitXcodeVersions maximum number of related xcodeVersions returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public ciXcodeVersionsMacOsVersionsGetToManyRelated(id: string, fieldsCiXcodeVersions?: Array<'macOsVersions' | 'name' | 'testDestinations' | 'version'>, fieldsCiMacOsVersions?: Array<'name' | 'version' | 'xcodeVersions'>, limit?: number, limitXcodeVersions?: number, include?: Array<'xcodeVersions'>, _options?: Configuration): Promise<CiMacOsVersionsResponse> {
        const result = this.api.ciXcodeVersionsMacOsVersionsGetToManyRelated(id, fieldsCiXcodeVersions, fieldsCiMacOsVersions, limit, limitXcodeVersions, include, _options);
        return result.toPromise();
    }


}



import { ObservableCustomerReviewResponsesApi } from './ObservableAPI.ts';

import { CustomerReviewResponsesApiRequestFactory, CustomerReviewResponsesApiResponseProcessor} from "../apis/CustomerReviewResponsesApi.ts";
export class PromiseCustomerReviewResponsesApi {
    private api: ObservableCustomerReviewResponsesApi

    public constructor(
        configuration: Configuration,
        requestFactory?: CustomerReviewResponsesApiRequestFactory,
        responseProcessor?: CustomerReviewResponsesApiResponseProcessor
    ) {
        this.api = new ObservableCustomerReviewResponsesApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param customerReviewResponseV1CreateRequest CustomerReviewResponse representation
     */
    public customerReviewResponsesCreateInstanceWithHttpInfo(customerReviewResponseV1CreateRequest: CustomerReviewResponseV1CreateRequest, _options?: Configuration): Promise<HttpInfo<CustomerReviewResponseV1Response>> {
        const result = this.api.customerReviewResponsesCreateInstanceWithHttpInfo(customerReviewResponseV1CreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param customerReviewResponseV1CreateRequest CustomerReviewResponse representation
     */
    public customerReviewResponsesCreateInstance(customerReviewResponseV1CreateRequest: CustomerReviewResponseV1CreateRequest, _options?: Configuration): Promise<CustomerReviewResponseV1Response> {
        const result = this.api.customerReviewResponsesCreateInstance(customerReviewResponseV1CreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public customerReviewResponsesDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.customerReviewResponsesDeleteInstanceWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public customerReviewResponsesDeleteInstance(id: string, _options?: Configuration): Promise<void> {
        const result = this.api.customerReviewResponsesDeleteInstance(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCustomerReviewResponses the fields to include for returned resources of type customerReviewResponses
     * @param include comma-separated list of relationships to include
     */
    public customerReviewResponsesGetInstanceWithHttpInfo(id: string, fieldsCustomerReviewResponses?: Array<'lastModifiedDate' | 'responseBody' | 'review' | 'state'>, include?: Array<'review'>, _options?: Configuration): Promise<HttpInfo<CustomerReviewResponseV1Response>> {
        const result = this.api.customerReviewResponsesGetInstanceWithHttpInfo(id, fieldsCustomerReviewResponses, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCustomerReviewResponses the fields to include for returned resources of type customerReviewResponses
     * @param include comma-separated list of relationships to include
     */
    public customerReviewResponsesGetInstance(id: string, fieldsCustomerReviewResponses?: Array<'lastModifiedDate' | 'responseBody' | 'review' | 'state'>, include?: Array<'review'>, _options?: Configuration): Promise<CustomerReviewResponseV1Response> {
        const result = this.api.customerReviewResponsesGetInstance(id, fieldsCustomerReviewResponses, include, _options);
        return result.toPromise();
    }


}



import { ObservableCustomerReviewsApi } from './ObservableAPI.ts';

import { CustomerReviewsApiRequestFactory, CustomerReviewsApiResponseProcessor} from "../apis/CustomerReviewsApi.ts";
export class PromiseCustomerReviewsApi {
    private api: ObservableCustomerReviewsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: CustomerReviewsApiRequestFactory,
        responseProcessor?: CustomerReviewsApiResponseProcessor
    ) {
        this.api = new ObservableCustomerReviewsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCustomerReviews the fields to include for returned resources of type customerReviews
     * @param include comma-separated list of relationships to include
     * @param fieldsCustomerReviewResponses the fields to include for returned resources of type customerReviewResponses
     */
    public customerReviewsGetInstanceWithHttpInfo(id: string, fieldsCustomerReviews?: Array<'body' | 'createdDate' | 'rating' | 'response' | 'reviewerNickname' | 'territory' | 'title'>, include?: Array<'response'>, fieldsCustomerReviewResponses?: Array<'lastModifiedDate' | 'responseBody' | 'review' | 'state'>, _options?: Configuration): Promise<HttpInfo<CustomerReviewResponse>> {
        const result = this.api.customerReviewsGetInstanceWithHttpInfo(id, fieldsCustomerReviews, include, fieldsCustomerReviewResponses, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCustomerReviews the fields to include for returned resources of type customerReviews
     * @param include comma-separated list of relationships to include
     * @param fieldsCustomerReviewResponses the fields to include for returned resources of type customerReviewResponses
     */
    public customerReviewsGetInstance(id: string, fieldsCustomerReviews?: Array<'body' | 'createdDate' | 'rating' | 'response' | 'reviewerNickname' | 'territory' | 'title'>, include?: Array<'response'>, fieldsCustomerReviewResponses?: Array<'lastModifiedDate' | 'responseBody' | 'review' | 'state'>, _options?: Configuration): Promise<CustomerReviewResponse> {
        const result = this.api.customerReviewsGetInstance(id, fieldsCustomerReviews, include, fieldsCustomerReviewResponses, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCustomerReviews the fields to include for returned resources of type customerReviews
     * @param fieldsCustomerReviewResponses the fields to include for returned resources of type customerReviewResponses
     * @param include comma-separated list of relationships to include
     */
    public customerReviewsResponseGetToOneRelatedWithHttpInfo(id: string, fieldsCustomerReviews?: Array<'body' | 'createdDate' | 'rating' | 'response' | 'reviewerNickname' | 'territory' | 'title'>, fieldsCustomerReviewResponses?: Array<'lastModifiedDate' | 'responseBody' | 'review' | 'state'>, include?: Array<'review'>, _options?: Configuration): Promise<HttpInfo<CustomerReviewResponseV1Response>> {
        const result = this.api.customerReviewsResponseGetToOneRelatedWithHttpInfo(id, fieldsCustomerReviews, fieldsCustomerReviewResponses, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCustomerReviews the fields to include for returned resources of type customerReviews
     * @param fieldsCustomerReviewResponses the fields to include for returned resources of type customerReviewResponses
     * @param include comma-separated list of relationships to include
     */
    public customerReviewsResponseGetToOneRelated(id: string, fieldsCustomerReviews?: Array<'body' | 'createdDate' | 'rating' | 'response' | 'reviewerNickname' | 'territory' | 'title'>, fieldsCustomerReviewResponses?: Array<'lastModifiedDate' | 'responseBody' | 'review' | 'state'>, include?: Array<'review'>, _options?: Configuration): Promise<CustomerReviewResponseV1Response> {
        const result = this.api.customerReviewsResponseGetToOneRelated(id, fieldsCustomerReviews, fieldsCustomerReviewResponses, include, _options);
        return result.toPromise();
    }


}



import { ObservableDevicesApi } from './ObservableAPI.ts';

import { DevicesApiRequestFactory, DevicesApiResponseProcessor} from "../apis/DevicesApi.ts";
export class PromiseDevicesApi {
    private api: ObservableDevicesApi

    public constructor(
        configuration: Configuration,
        requestFactory?: DevicesApiRequestFactory,
        responseProcessor?: DevicesApiResponseProcessor
    ) {
        this.api = new ObservableDevicesApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param deviceCreateRequest Device representation
     */
    public devicesCreateInstanceWithHttpInfo(deviceCreateRequest: DeviceCreateRequest, _options?: Configuration): Promise<HttpInfo<DeviceResponse>> {
        const result = this.api.devicesCreateInstanceWithHttpInfo(deviceCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param deviceCreateRequest Device representation
     */
    public devicesCreateInstance(deviceCreateRequest: DeviceCreateRequest, _options?: Configuration): Promise<DeviceResponse> {
        const result = this.api.devicesCreateInstance(deviceCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param filterName filter by attribute \&#39;name\&#39;
     * @param filterPlatform filter by attribute \&#39;platform\&#39;
     * @param filterStatus filter by attribute \&#39;status\&#39;
     * @param filterUdid filter by attribute \&#39;udid\&#39;
     * @param filterId filter by id(s)
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsDevices the fields to include for returned resources of type devices
     * @param limit maximum resources per page
     */
    public devicesGetCollectionWithHttpInfo(filterName?: Array<string>, filterPlatform?: Array<'IOS' | 'MAC_OS'>, filterStatus?: Array<'ENABLED' | 'DISABLED'>, filterUdid?: Array<string>, filterId?: Array<string>, sort?: Array<'id' | '-id' | 'name' | '-name' | 'platform' | '-platform' | 'status' | '-status' | 'udid' | '-udid'>, fieldsDevices?: Array<'addedDate' | 'deviceClass' | 'model' | 'name' | 'platform' | 'status' | 'udid'>, limit?: number, _options?: Configuration): Promise<HttpInfo<DevicesResponse>> {
        const result = this.api.devicesGetCollectionWithHttpInfo(filterName, filterPlatform, filterStatus, filterUdid, filterId, sort, fieldsDevices, limit, _options);
        return result.toPromise();
    }

    /**
     * @param filterName filter by attribute \&#39;name\&#39;
     * @param filterPlatform filter by attribute \&#39;platform\&#39;
     * @param filterStatus filter by attribute \&#39;status\&#39;
     * @param filterUdid filter by attribute \&#39;udid\&#39;
     * @param filterId filter by id(s)
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsDevices the fields to include for returned resources of type devices
     * @param limit maximum resources per page
     */
    public devicesGetCollection(filterName?: Array<string>, filterPlatform?: Array<'IOS' | 'MAC_OS'>, filterStatus?: Array<'ENABLED' | 'DISABLED'>, filterUdid?: Array<string>, filterId?: Array<string>, sort?: Array<'id' | '-id' | 'name' | '-name' | 'platform' | '-platform' | 'status' | '-status' | 'udid' | '-udid'>, fieldsDevices?: Array<'addedDate' | 'deviceClass' | 'model' | 'name' | 'platform' | 'status' | 'udid'>, limit?: number, _options?: Configuration): Promise<DevicesResponse> {
        const result = this.api.devicesGetCollection(filterName, filterPlatform, filterStatus, filterUdid, filterId, sort, fieldsDevices, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsDevices the fields to include for returned resources of type devices
     */
    public devicesGetInstanceWithHttpInfo(id: string, fieldsDevices?: Array<'addedDate' | 'deviceClass' | 'model' | 'name' | 'platform' | 'status' | 'udid'>, _options?: Configuration): Promise<HttpInfo<DeviceResponse>> {
        const result = this.api.devicesGetInstanceWithHttpInfo(id, fieldsDevices, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsDevices the fields to include for returned resources of type devices
     */
    public devicesGetInstance(id: string, fieldsDevices?: Array<'addedDate' | 'deviceClass' | 'model' | 'name' | 'platform' | 'status' | 'udid'>, _options?: Configuration): Promise<DeviceResponse> {
        const result = this.api.devicesGetInstance(id, fieldsDevices, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param deviceUpdateRequest Device representation
     */
    public devicesUpdateInstanceWithHttpInfo(id: string, deviceUpdateRequest: DeviceUpdateRequest, _options?: Configuration): Promise<HttpInfo<DeviceResponse>> {
        const result = this.api.devicesUpdateInstanceWithHttpInfo(id, deviceUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param deviceUpdateRequest Device representation
     */
    public devicesUpdateInstance(id: string, deviceUpdateRequest: DeviceUpdateRequest, _options?: Configuration): Promise<DeviceResponse> {
        const result = this.api.devicesUpdateInstance(id, deviceUpdateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableDiagnosticSignaturesApi } from './ObservableAPI.ts';

import { DiagnosticSignaturesApiRequestFactory, DiagnosticSignaturesApiResponseProcessor} from "../apis/DiagnosticSignaturesApi.ts";
export class PromiseDiagnosticSignaturesApi {
    private api: ObservableDiagnosticSignaturesApi

    public constructor(
        configuration: Configuration,
        requestFactory?: DiagnosticSignaturesApiRequestFactory,
        responseProcessor?: DiagnosticSignaturesApiResponseProcessor
    ) {
        this.api = new ObservableDiagnosticSignaturesApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public diagnosticSignaturesLogsGetToManyRelatedWithHttpInfo(id: string, limit?: number, _options?: Configuration): Promise<HttpInfo<DiagnosticLogs>> {
        const result = this.api.diagnosticSignaturesLogsGetToManyRelatedWithHttpInfo(id, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public diagnosticSignaturesLogsGetToManyRelated(id: string, limit?: number, _options?: Configuration): Promise<DiagnosticLogs> {
        const result = this.api.diagnosticSignaturesLogsGetToManyRelated(id, limit, _options);
        return result.toPromise();
    }


}



import { ObservableEndAppAvailabilityPreOrdersApi } from './ObservableAPI.ts';

import { EndAppAvailabilityPreOrdersApiRequestFactory, EndAppAvailabilityPreOrdersApiResponseProcessor} from "../apis/EndAppAvailabilityPreOrdersApi.ts";
export class PromiseEndAppAvailabilityPreOrdersApi {
    private api: ObservableEndAppAvailabilityPreOrdersApi

    public constructor(
        configuration: Configuration,
        requestFactory?: EndAppAvailabilityPreOrdersApiRequestFactory,
        responseProcessor?: EndAppAvailabilityPreOrdersApiResponseProcessor
    ) {
        this.api = new ObservableEndAppAvailabilityPreOrdersApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param endAppAvailabilityPreOrderCreateRequest EndAppAvailabilityPreOrder representation
     */
    public endAppAvailabilityPreOrdersCreateInstanceWithHttpInfo(endAppAvailabilityPreOrderCreateRequest: EndAppAvailabilityPreOrderCreateRequest, _options?: Configuration): Promise<HttpInfo<EndAppAvailabilityPreOrderResponse>> {
        const result = this.api.endAppAvailabilityPreOrdersCreateInstanceWithHttpInfo(endAppAvailabilityPreOrderCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param endAppAvailabilityPreOrderCreateRequest EndAppAvailabilityPreOrder representation
     */
    public endAppAvailabilityPreOrdersCreateInstance(endAppAvailabilityPreOrderCreateRequest: EndAppAvailabilityPreOrderCreateRequest, _options?: Configuration): Promise<EndAppAvailabilityPreOrderResponse> {
        const result = this.api.endAppAvailabilityPreOrdersCreateInstance(endAppAvailabilityPreOrderCreateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableEndUserLicenseAgreementsApi } from './ObservableAPI.ts';

import { EndUserLicenseAgreementsApiRequestFactory, EndUserLicenseAgreementsApiResponseProcessor} from "../apis/EndUserLicenseAgreementsApi.ts";
export class PromiseEndUserLicenseAgreementsApi {
    private api: ObservableEndUserLicenseAgreementsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: EndUserLicenseAgreementsApiRequestFactory,
        responseProcessor?: EndUserLicenseAgreementsApiResponseProcessor
    ) {
        this.api = new ObservableEndUserLicenseAgreementsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param endUserLicenseAgreementCreateRequest EndUserLicenseAgreement representation
     */
    public endUserLicenseAgreementsCreateInstanceWithHttpInfo(endUserLicenseAgreementCreateRequest: EndUserLicenseAgreementCreateRequest, _options?: Configuration): Promise<HttpInfo<EndUserLicenseAgreementResponse>> {
        const result = this.api.endUserLicenseAgreementsCreateInstanceWithHttpInfo(endUserLicenseAgreementCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param endUserLicenseAgreementCreateRequest EndUserLicenseAgreement representation
     */
    public endUserLicenseAgreementsCreateInstance(endUserLicenseAgreementCreateRequest: EndUserLicenseAgreementCreateRequest, _options?: Configuration): Promise<EndUserLicenseAgreementResponse> {
        const result = this.api.endUserLicenseAgreementsCreateInstance(endUserLicenseAgreementCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public endUserLicenseAgreementsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.endUserLicenseAgreementsDeleteInstanceWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public endUserLicenseAgreementsDeleteInstance(id: string, _options?: Configuration): Promise<void> {
        const result = this.api.endUserLicenseAgreementsDeleteInstance(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsEndUserLicenseAgreements the fields to include for returned resources of type endUserLicenseAgreements
     * @param include comma-separated list of relationships to include
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limitTerritories maximum number of related territories returned (when they are included)
     */
    public endUserLicenseAgreementsGetInstanceWithHttpInfo(id: string, fieldsEndUserLicenseAgreements?: Array<'agreementText' | 'app' | 'territories'>, include?: Array<'app' | 'territories'>, fieldsTerritories?: Array<'currency'>, limitTerritories?: number, _options?: Configuration): Promise<HttpInfo<EndUserLicenseAgreementResponse>> {
        const result = this.api.endUserLicenseAgreementsGetInstanceWithHttpInfo(id, fieldsEndUserLicenseAgreements, include, fieldsTerritories, limitTerritories, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsEndUserLicenseAgreements the fields to include for returned resources of type endUserLicenseAgreements
     * @param include comma-separated list of relationships to include
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limitTerritories maximum number of related territories returned (when they are included)
     */
    public endUserLicenseAgreementsGetInstance(id: string, fieldsEndUserLicenseAgreements?: Array<'agreementText' | 'app' | 'territories'>, include?: Array<'app' | 'territories'>, fieldsTerritories?: Array<'currency'>, limitTerritories?: number, _options?: Configuration): Promise<EndUserLicenseAgreementResponse> {
        const result = this.api.endUserLicenseAgreementsGetInstance(id, fieldsEndUserLicenseAgreements, include, fieldsTerritories, limitTerritories, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limit maximum resources per page
     */
    public endUserLicenseAgreementsTerritoriesGetToManyRelatedWithHttpInfo(id: string, fieldsTerritories?: Array<'currency'>, limit?: number, _options?: Configuration): Promise<HttpInfo<TerritoriesWithoutIncludesResponse>> {
        const result = this.api.endUserLicenseAgreementsTerritoriesGetToManyRelatedWithHttpInfo(id, fieldsTerritories, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limit maximum resources per page
     */
    public endUserLicenseAgreementsTerritoriesGetToManyRelated(id: string, fieldsTerritories?: Array<'currency'>, limit?: number, _options?: Configuration): Promise<TerritoriesWithoutIncludesResponse> {
        const result = this.api.endUserLicenseAgreementsTerritoriesGetToManyRelated(id, fieldsTerritories, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param endUserLicenseAgreementUpdateRequest EndUserLicenseAgreement representation
     */
    public endUserLicenseAgreementsUpdateInstanceWithHttpInfo(id: string, endUserLicenseAgreementUpdateRequest: EndUserLicenseAgreementUpdateRequest, _options?: Configuration): Promise<HttpInfo<EndUserLicenseAgreementResponse>> {
        const result = this.api.endUserLicenseAgreementsUpdateInstanceWithHttpInfo(id, endUserLicenseAgreementUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param endUserLicenseAgreementUpdateRequest EndUserLicenseAgreement representation
     */
    public endUserLicenseAgreementsUpdateInstance(id: string, endUserLicenseAgreementUpdateRequest: EndUserLicenseAgreementUpdateRequest, _options?: Configuration): Promise<EndUserLicenseAgreementResponse> {
        const result = this.api.endUserLicenseAgreementsUpdateInstance(id, endUserLicenseAgreementUpdateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableFinanceReportsApi } from './ObservableAPI.ts';

import { FinanceReportsApiRequestFactory, FinanceReportsApiResponseProcessor} from "../apis/FinanceReportsApi.ts";
export class PromiseFinanceReportsApi {
    private api: ObservableFinanceReportsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: FinanceReportsApiRequestFactory,
        responseProcessor?: FinanceReportsApiResponseProcessor
    ) {
        this.api = new ObservableFinanceReportsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param filterRegionCode filter by attribute \&#39;regionCode\&#39;
     * @param filterReportDate filter by attribute \&#39;reportDate\&#39;
     * @param filterReportType filter by attribute \&#39;reportType\&#39;
     * @param filterVendorNumber filter by attribute \&#39;vendorNumber\&#39;
     */
    public financeReportsGetCollectionWithHttpInfo(filterRegionCode: Array<string>, filterReportDate: Array<string>, filterReportType: Array<'FINANCIAL' | 'FINANCE_DETAIL'>, filterVendorNumber: Array<string>, _options?: Configuration): Promise<HttpInfo<HttpFile>> {
        const result = this.api.financeReportsGetCollectionWithHttpInfo(filterRegionCode, filterReportDate, filterReportType, filterVendorNumber, _options);
        return result.toPromise();
    }

    /**
     * @param filterRegionCode filter by attribute \&#39;regionCode\&#39;
     * @param filterReportDate filter by attribute \&#39;reportDate\&#39;
     * @param filterReportType filter by attribute \&#39;reportType\&#39;
     * @param filterVendorNumber filter by attribute \&#39;vendorNumber\&#39;
     */
    public financeReportsGetCollection(filterRegionCode: Array<string>, filterReportDate: Array<string>, filterReportType: Array<'FINANCIAL' | 'FINANCE_DETAIL'>, filterVendorNumber: Array<string>, _options?: Configuration): Promise<HttpFile> {
        const result = this.api.financeReportsGetCollection(filterRegionCode, filterReportDate, filterReportType, filterVendorNumber, _options);
        return result.toPromise();
    }


}



import { ObservableGameCenterAchievementImagesApi } from './ObservableAPI.ts';

import { GameCenterAchievementImagesApiRequestFactory, GameCenterAchievementImagesApiResponseProcessor} from "../apis/GameCenterAchievementImagesApi.ts";
export class PromiseGameCenterAchievementImagesApi {
    private api: ObservableGameCenterAchievementImagesApi

    public constructor(
        configuration: Configuration,
        requestFactory?: GameCenterAchievementImagesApiRequestFactory,
        responseProcessor?: GameCenterAchievementImagesApiResponseProcessor
    ) {
        this.api = new ObservableGameCenterAchievementImagesApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param gameCenterAchievementImageCreateRequest GameCenterAchievementImage representation
     */
    public gameCenterAchievementImagesCreateInstanceWithHttpInfo(gameCenterAchievementImageCreateRequest: GameCenterAchievementImageCreateRequest, _options?: Configuration): Promise<HttpInfo<GameCenterAchievementImageResponse>> {
        const result = this.api.gameCenterAchievementImagesCreateInstanceWithHttpInfo(gameCenterAchievementImageCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param gameCenterAchievementImageCreateRequest GameCenterAchievementImage representation
     */
    public gameCenterAchievementImagesCreateInstance(gameCenterAchievementImageCreateRequest: GameCenterAchievementImageCreateRequest, _options?: Configuration): Promise<GameCenterAchievementImageResponse> {
        const result = this.api.gameCenterAchievementImagesCreateInstance(gameCenterAchievementImageCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterAchievementImagesDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.gameCenterAchievementImagesDeleteInstanceWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterAchievementImagesDeleteInstance(id: string, _options?: Configuration): Promise<void> {
        const result = this.api.gameCenterAchievementImagesDeleteInstance(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterAchievementImages the fields to include for returned resources of type gameCenterAchievementImages
     * @param include comma-separated list of relationships to include
     */
    public gameCenterAchievementImagesGetInstanceWithHttpInfo(id: string, fieldsGameCenterAchievementImages?: Array<'assetDeliveryState' | 'fileName' | 'fileSize' | 'gameCenterAchievementLocalization' | 'imageAsset' | 'uploadOperations' | 'uploaded'>, include?: Array<'gameCenterAchievementLocalization'>, _options?: Configuration): Promise<HttpInfo<GameCenterAchievementImageResponse>> {
        const result = this.api.gameCenterAchievementImagesGetInstanceWithHttpInfo(id, fieldsGameCenterAchievementImages, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterAchievementImages the fields to include for returned resources of type gameCenterAchievementImages
     * @param include comma-separated list of relationships to include
     */
    public gameCenterAchievementImagesGetInstance(id: string, fieldsGameCenterAchievementImages?: Array<'assetDeliveryState' | 'fileName' | 'fileSize' | 'gameCenterAchievementLocalization' | 'imageAsset' | 'uploadOperations' | 'uploaded'>, include?: Array<'gameCenterAchievementLocalization'>, _options?: Configuration): Promise<GameCenterAchievementImageResponse> {
        const result = this.api.gameCenterAchievementImagesGetInstance(id, fieldsGameCenterAchievementImages, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterAchievementImageUpdateRequest GameCenterAchievementImage representation
     */
    public gameCenterAchievementImagesUpdateInstanceWithHttpInfo(id: string, gameCenterAchievementImageUpdateRequest: GameCenterAchievementImageUpdateRequest, _options?: Configuration): Promise<HttpInfo<GameCenterAchievementImageResponse>> {
        const result = this.api.gameCenterAchievementImagesUpdateInstanceWithHttpInfo(id, gameCenterAchievementImageUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterAchievementImageUpdateRequest GameCenterAchievementImage representation
     */
    public gameCenterAchievementImagesUpdateInstance(id: string, gameCenterAchievementImageUpdateRequest: GameCenterAchievementImageUpdateRequest, _options?: Configuration): Promise<GameCenterAchievementImageResponse> {
        const result = this.api.gameCenterAchievementImagesUpdateInstance(id, gameCenterAchievementImageUpdateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableGameCenterAchievementLocalizationsApi } from './ObservableAPI.ts';

import { GameCenterAchievementLocalizationsApiRequestFactory, GameCenterAchievementLocalizationsApiResponseProcessor} from "../apis/GameCenterAchievementLocalizationsApi.ts";
export class PromiseGameCenterAchievementLocalizationsApi {
    private api: ObservableGameCenterAchievementLocalizationsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: GameCenterAchievementLocalizationsApiRequestFactory,
        responseProcessor?: GameCenterAchievementLocalizationsApiResponseProcessor
    ) {
        this.api = new ObservableGameCenterAchievementLocalizationsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param gameCenterAchievementLocalizationCreateRequest GameCenterAchievementLocalization representation
     */
    public gameCenterAchievementLocalizationsCreateInstanceWithHttpInfo(gameCenterAchievementLocalizationCreateRequest: GameCenterAchievementLocalizationCreateRequest, _options?: Configuration): Promise<HttpInfo<GameCenterAchievementLocalizationResponse>> {
        const result = this.api.gameCenterAchievementLocalizationsCreateInstanceWithHttpInfo(gameCenterAchievementLocalizationCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param gameCenterAchievementLocalizationCreateRequest GameCenterAchievementLocalization representation
     */
    public gameCenterAchievementLocalizationsCreateInstance(gameCenterAchievementLocalizationCreateRequest: GameCenterAchievementLocalizationCreateRequest, _options?: Configuration): Promise<GameCenterAchievementLocalizationResponse> {
        const result = this.api.gameCenterAchievementLocalizationsCreateInstance(gameCenterAchievementLocalizationCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterAchievementLocalizationsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.gameCenterAchievementLocalizationsDeleteInstanceWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterAchievementLocalizationsDeleteInstance(id: string, _options?: Configuration): Promise<void> {
        const result = this.api.gameCenterAchievementLocalizationsDeleteInstance(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterAchievementReleases the fields to include for returned resources of type gameCenterAchievementReleases
     * @param fieldsGameCenterGroups the fields to include for returned resources of type gameCenterGroups
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterAchievementLocalizations the fields to include for returned resources of type gameCenterAchievementLocalizations
     * @param fieldsGameCenterAchievements the fields to include for returned resources of type gameCenterAchievements
     * @param limitLocalizations maximum number of related localizations returned (when they are included)
     * @param limitReleases maximum number of related releases returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public gameCenterAchievementLocalizationsGameCenterAchievementGetToOneRelatedWithHttpInfo(id: string, fieldsGameCenterAchievementReleases?: Array<'gameCenterAchievement' | 'gameCenterDetail' | 'live'>, fieldsGameCenterGroups?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'referenceName'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterAchievementLocalizations?: Array<'afterEarnedDescription' | 'beforeEarnedDescription' | 'gameCenterAchievement' | 'gameCenterAchievementImage' | 'locale' | 'name'>, fieldsGameCenterAchievements?: Array<'archived' | 'gameCenterDetail' | 'gameCenterGroup' | 'groupAchievement' | 'localizations' | 'points' | 'referenceName' | 'releases' | 'repeatable' | 'showBeforeEarned' | 'vendorIdentifier'>, limitLocalizations?: number, limitReleases?: number, include?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'groupAchievement' | 'localizations' | 'releases'>, _options?: Configuration): Promise<HttpInfo<GameCenterAchievementResponse>> {
        const result = this.api.gameCenterAchievementLocalizationsGameCenterAchievementGetToOneRelatedWithHttpInfo(id, fieldsGameCenterAchievementReleases, fieldsGameCenterGroups, fieldsGameCenterDetails, fieldsGameCenterAchievementLocalizations, fieldsGameCenterAchievements, limitLocalizations, limitReleases, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterAchievementReleases the fields to include for returned resources of type gameCenterAchievementReleases
     * @param fieldsGameCenterGroups the fields to include for returned resources of type gameCenterGroups
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterAchievementLocalizations the fields to include for returned resources of type gameCenterAchievementLocalizations
     * @param fieldsGameCenterAchievements the fields to include for returned resources of type gameCenterAchievements
     * @param limitLocalizations maximum number of related localizations returned (when they are included)
     * @param limitReleases maximum number of related releases returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public gameCenterAchievementLocalizationsGameCenterAchievementGetToOneRelated(id: string, fieldsGameCenterAchievementReleases?: Array<'gameCenterAchievement' | 'gameCenterDetail' | 'live'>, fieldsGameCenterGroups?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'referenceName'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterAchievementLocalizations?: Array<'afterEarnedDescription' | 'beforeEarnedDescription' | 'gameCenterAchievement' | 'gameCenterAchievementImage' | 'locale' | 'name'>, fieldsGameCenterAchievements?: Array<'archived' | 'gameCenterDetail' | 'gameCenterGroup' | 'groupAchievement' | 'localizations' | 'points' | 'referenceName' | 'releases' | 'repeatable' | 'showBeforeEarned' | 'vendorIdentifier'>, limitLocalizations?: number, limitReleases?: number, include?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'groupAchievement' | 'localizations' | 'releases'>, _options?: Configuration): Promise<GameCenterAchievementResponse> {
        const result = this.api.gameCenterAchievementLocalizationsGameCenterAchievementGetToOneRelated(id, fieldsGameCenterAchievementReleases, fieldsGameCenterGroups, fieldsGameCenterDetails, fieldsGameCenterAchievementLocalizations, fieldsGameCenterAchievements, limitLocalizations, limitReleases, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterAchievementImages the fields to include for returned resources of type gameCenterAchievementImages
     * @param fieldsGameCenterAchievementLocalizations the fields to include for returned resources of type gameCenterAchievementLocalizations
     * @param include comma-separated list of relationships to include
     */
    public gameCenterAchievementLocalizationsGameCenterAchievementImageGetToOneRelatedWithHttpInfo(id: string, fieldsGameCenterAchievementImages?: Array<'assetDeliveryState' | 'fileName' | 'fileSize' | 'gameCenterAchievementLocalization' | 'imageAsset' | 'uploadOperations' | 'uploaded'>, fieldsGameCenterAchievementLocalizations?: Array<'afterEarnedDescription' | 'beforeEarnedDescription' | 'gameCenterAchievement' | 'gameCenterAchievementImage' | 'locale' | 'name'>, include?: Array<'gameCenterAchievementLocalization'>, _options?: Configuration): Promise<HttpInfo<GameCenterAchievementImageResponse>> {
        const result = this.api.gameCenterAchievementLocalizationsGameCenterAchievementImageGetToOneRelatedWithHttpInfo(id, fieldsGameCenterAchievementImages, fieldsGameCenterAchievementLocalizations, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterAchievementImages the fields to include for returned resources of type gameCenterAchievementImages
     * @param fieldsGameCenterAchievementLocalizations the fields to include for returned resources of type gameCenterAchievementLocalizations
     * @param include comma-separated list of relationships to include
     */
    public gameCenterAchievementLocalizationsGameCenterAchievementImageGetToOneRelated(id: string, fieldsGameCenterAchievementImages?: Array<'assetDeliveryState' | 'fileName' | 'fileSize' | 'gameCenterAchievementLocalization' | 'imageAsset' | 'uploadOperations' | 'uploaded'>, fieldsGameCenterAchievementLocalizations?: Array<'afterEarnedDescription' | 'beforeEarnedDescription' | 'gameCenterAchievement' | 'gameCenterAchievementImage' | 'locale' | 'name'>, include?: Array<'gameCenterAchievementLocalization'>, _options?: Configuration): Promise<GameCenterAchievementImageResponse> {
        const result = this.api.gameCenterAchievementLocalizationsGameCenterAchievementImageGetToOneRelated(id, fieldsGameCenterAchievementImages, fieldsGameCenterAchievementLocalizations, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterAchievementLocalizations the fields to include for returned resources of type gameCenterAchievementLocalizations
     * @param include comma-separated list of relationships to include
     * @param fieldsGameCenterAchievementImages the fields to include for returned resources of type gameCenterAchievementImages
     * @param fieldsGameCenterAchievements the fields to include for returned resources of type gameCenterAchievements
     */
    public gameCenterAchievementLocalizationsGetInstanceWithHttpInfo(id: string, fieldsGameCenterAchievementLocalizations?: Array<'afterEarnedDescription' | 'beforeEarnedDescription' | 'gameCenterAchievement' | 'gameCenterAchievementImage' | 'locale' | 'name'>, include?: Array<'gameCenterAchievement' | 'gameCenterAchievementImage'>, fieldsGameCenterAchievementImages?: Array<'assetDeliveryState' | 'fileName' | 'fileSize' | 'gameCenterAchievementLocalization' | 'imageAsset' | 'uploadOperations' | 'uploaded'>, fieldsGameCenterAchievements?: Array<'archived' | 'gameCenterDetail' | 'gameCenterGroup' | 'groupAchievement' | 'localizations' | 'points' | 'referenceName' | 'releases' | 'repeatable' | 'showBeforeEarned' | 'vendorIdentifier'>, _options?: Configuration): Promise<HttpInfo<GameCenterAchievementLocalizationResponse>> {
        const result = this.api.gameCenterAchievementLocalizationsGetInstanceWithHttpInfo(id, fieldsGameCenterAchievementLocalizations, include, fieldsGameCenterAchievementImages, fieldsGameCenterAchievements, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterAchievementLocalizations the fields to include for returned resources of type gameCenterAchievementLocalizations
     * @param include comma-separated list of relationships to include
     * @param fieldsGameCenterAchievementImages the fields to include for returned resources of type gameCenterAchievementImages
     * @param fieldsGameCenterAchievements the fields to include for returned resources of type gameCenterAchievements
     */
    public gameCenterAchievementLocalizationsGetInstance(id: string, fieldsGameCenterAchievementLocalizations?: Array<'afterEarnedDescription' | 'beforeEarnedDescription' | 'gameCenterAchievement' | 'gameCenterAchievementImage' | 'locale' | 'name'>, include?: Array<'gameCenterAchievement' | 'gameCenterAchievementImage'>, fieldsGameCenterAchievementImages?: Array<'assetDeliveryState' | 'fileName' | 'fileSize' | 'gameCenterAchievementLocalization' | 'imageAsset' | 'uploadOperations' | 'uploaded'>, fieldsGameCenterAchievements?: Array<'archived' | 'gameCenterDetail' | 'gameCenterGroup' | 'groupAchievement' | 'localizations' | 'points' | 'referenceName' | 'releases' | 'repeatable' | 'showBeforeEarned' | 'vendorIdentifier'>, _options?: Configuration): Promise<GameCenterAchievementLocalizationResponse> {
        const result = this.api.gameCenterAchievementLocalizationsGetInstance(id, fieldsGameCenterAchievementLocalizations, include, fieldsGameCenterAchievementImages, fieldsGameCenterAchievements, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterAchievementLocalizationUpdateRequest GameCenterAchievementLocalization representation
     */
    public gameCenterAchievementLocalizationsUpdateInstanceWithHttpInfo(id: string, gameCenterAchievementLocalizationUpdateRequest: GameCenterAchievementLocalizationUpdateRequest, _options?: Configuration): Promise<HttpInfo<GameCenterAchievementLocalizationResponse>> {
        const result = this.api.gameCenterAchievementLocalizationsUpdateInstanceWithHttpInfo(id, gameCenterAchievementLocalizationUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterAchievementLocalizationUpdateRequest GameCenterAchievementLocalization representation
     */
    public gameCenterAchievementLocalizationsUpdateInstance(id: string, gameCenterAchievementLocalizationUpdateRequest: GameCenterAchievementLocalizationUpdateRequest, _options?: Configuration): Promise<GameCenterAchievementLocalizationResponse> {
        const result = this.api.gameCenterAchievementLocalizationsUpdateInstance(id, gameCenterAchievementLocalizationUpdateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableGameCenterAchievementReleasesApi } from './ObservableAPI.ts';

import { GameCenterAchievementReleasesApiRequestFactory, GameCenterAchievementReleasesApiResponseProcessor} from "../apis/GameCenterAchievementReleasesApi.ts";
export class PromiseGameCenterAchievementReleasesApi {
    private api: ObservableGameCenterAchievementReleasesApi

    public constructor(
        configuration: Configuration,
        requestFactory?: GameCenterAchievementReleasesApiRequestFactory,
        responseProcessor?: GameCenterAchievementReleasesApiResponseProcessor
    ) {
        this.api = new ObservableGameCenterAchievementReleasesApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param gameCenterAchievementReleaseCreateRequest GameCenterAchievementRelease representation
     */
    public gameCenterAchievementReleasesCreateInstanceWithHttpInfo(gameCenterAchievementReleaseCreateRequest: GameCenterAchievementReleaseCreateRequest, _options?: Configuration): Promise<HttpInfo<GameCenterAchievementReleaseResponse>> {
        const result = this.api.gameCenterAchievementReleasesCreateInstanceWithHttpInfo(gameCenterAchievementReleaseCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param gameCenterAchievementReleaseCreateRequest GameCenterAchievementRelease representation
     */
    public gameCenterAchievementReleasesCreateInstance(gameCenterAchievementReleaseCreateRequest: GameCenterAchievementReleaseCreateRequest, _options?: Configuration): Promise<GameCenterAchievementReleaseResponse> {
        const result = this.api.gameCenterAchievementReleasesCreateInstance(gameCenterAchievementReleaseCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterAchievementReleasesDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.gameCenterAchievementReleasesDeleteInstanceWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterAchievementReleasesDeleteInstance(id: string, _options?: Configuration): Promise<void> {
        const result = this.api.gameCenterAchievementReleasesDeleteInstance(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterAchievementReleases the fields to include for returned resources of type gameCenterAchievementReleases
     * @param include comma-separated list of relationships to include
     */
    public gameCenterAchievementReleasesGetInstanceWithHttpInfo(id: string, fieldsGameCenterAchievementReleases?: Array<'gameCenterAchievement' | 'gameCenterDetail' | 'live'>, include?: Array<'gameCenterAchievement' | 'gameCenterDetail'>, _options?: Configuration): Promise<HttpInfo<GameCenterAchievementReleaseResponse>> {
        const result = this.api.gameCenterAchievementReleasesGetInstanceWithHttpInfo(id, fieldsGameCenterAchievementReleases, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterAchievementReleases the fields to include for returned resources of type gameCenterAchievementReleases
     * @param include comma-separated list of relationships to include
     */
    public gameCenterAchievementReleasesGetInstance(id: string, fieldsGameCenterAchievementReleases?: Array<'gameCenterAchievement' | 'gameCenterDetail' | 'live'>, include?: Array<'gameCenterAchievement' | 'gameCenterDetail'>, _options?: Configuration): Promise<GameCenterAchievementReleaseResponse> {
        const result = this.api.gameCenterAchievementReleasesGetInstance(id, fieldsGameCenterAchievementReleases, include, _options);
        return result.toPromise();
    }


}



import { ObservableGameCenterAchievementsApi } from './ObservableAPI.ts';

import { GameCenterAchievementsApiRequestFactory, GameCenterAchievementsApiResponseProcessor} from "../apis/GameCenterAchievementsApi.ts";
export class PromiseGameCenterAchievementsApi {
    private api: ObservableGameCenterAchievementsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: GameCenterAchievementsApiRequestFactory,
        responseProcessor?: GameCenterAchievementsApiResponseProcessor
    ) {
        this.api = new ObservableGameCenterAchievementsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param gameCenterAchievementCreateRequest GameCenterAchievement representation
     */
    public gameCenterAchievementsCreateInstanceWithHttpInfo(gameCenterAchievementCreateRequest: GameCenterAchievementCreateRequest, _options?: Configuration): Promise<HttpInfo<GameCenterAchievementResponse>> {
        const result = this.api.gameCenterAchievementsCreateInstanceWithHttpInfo(gameCenterAchievementCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param gameCenterAchievementCreateRequest GameCenterAchievement representation
     */
    public gameCenterAchievementsCreateInstance(gameCenterAchievementCreateRequest: GameCenterAchievementCreateRequest, _options?: Configuration): Promise<GameCenterAchievementResponse> {
        const result = this.api.gameCenterAchievementsCreateInstance(gameCenterAchievementCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterAchievementsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.gameCenterAchievementsDeleteInstanceWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterAchievementsDeleteInstance(id: string, _options?: Configuration): Promise<void> {
        const result = this.api.gameCenterAchievementsDeleteInstance(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterAchievements the fields to include for returned resources of type gameCenterAchievements
     * @param include comma-separated list of relationships to include
     * @param fieldsGameCenterAchievementReleases the fields to include for returned resources of type gameCenterAchievementReleases
     * @param fieldsGameCenterAchievementLocalizations the fields to include for returned resources of type gameCenterAchievementLocalizations
     * @param limitLocalizations maximum number of related localizations returned (when they are included)
     * @param limitReleases maximum number of related releases returned (when they are included)
     */
    public gameCenterAchievementsGetInstanceWithHttpInfo(id: string, fieldsGameCenterAchievements?: Array<'archived' | 'gameCenterDetail' | 'gameCenterGroup' | 'groupAchievement' | 'localizations' | 'points' | 'referenceName' | 'releases' | 'repeatable' | 'showBeforeEarned' | 'vendorIdentifier'>, include?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'groupAchievement' | 'localizations' | 'releases'>, fieldsGameCenterAchievementReleases?: Array<'gameCenterAchievement' | 'gameCenterDetail' | 'live'>, fieldsGameCenterAchievementLocalizations?: Array<'afterEarnedDescription' | 'beforeEarnedDescription' | 'gameCenterAchievement' | 'gameCenterAchievementImage' | 'locale' | 'name'>, limitLocalizations?: number, limitReleases?: number, _options?: Configuration): Promise<HttpInfo<GameCenterAchievementResponse>> {
        const result = this.api.gameCenterAchievementsGetInstanceWithHttpInfo(id, fieldsGameCenterAchievements, include, fieldsGameCenterAchievementReleases, fieldsGameCenterAchievementLocalizations, limitLocalizations, limitReleases, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterAchievements the fields to include for returned resources of type gameCenterAchievements
     * @param include comma-separated list of relationships to include
     * @param fieldsGameCenterAchievementReleases the fields to include for returned resources of type gameCenterAchievementReleases
     * @param fieldsGameCenterAchievementLocalizations the fields to include for returned resources of type gameCenterAchievementLocalizations
     * @param limitLocalizations maximum number of related localizations returned (when they are included)
     * @param limitReleases maximum number of related releases returned (when they are included)
     */
    public gameCenterAchievementsGetInstance(id: string, fieldsGameCenterAchievements?: Array<'archived' | 'gameCenterDetail' | 'gameCenterGroup' | 'groupAchievement' | 'localizations' | 'points' | 'referenceName' | 'releases' | 'repeatable' | 'showBeforeEarned' | 'vendorIdentifier'>, include?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'groupAchievement' | 'localizations' | 'releases'>, fieldsGameCenterAchievementReleases?: Array<'gameCenterAchievement' | 'gameCenterDetail' | 'live'>, fieldsGameCenterAchievementLocalizations?: Array<'afterEarnedDescription' | 'beforeEarnedDescription' | 'gameCenterAchievement' | 'gameCenterAchievementImage' | 'locale' | 'name'>, limitLocalizations?: number, limitReleases?: number, _options?: Configuration): Promise<GameCenterAchievementResponse> {
        const result = this.api.gameCenterAchievementsGetInstance(id, fieldsGameCenterAchievements, include, fieldsGameCenterAchievementReleases, fieldsGameCenterAchievementLocalizations, limitLocalizations, limitReleases, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterAchievementReleases the fields to include for returned resources of type gameCenterAchievementReleases
     * @param fieldsGameCenterGroups the fields to include for returned resources of type gameCenterGroups
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterAchievementLocalizations the fields to include for returned resources of type gameCenterAchievementLocalizations
     * @param fieldsGameCenterAchievements the fields to include for returned resources of type gameCenterAchievements
     * @param limitLocalizations maximum number of related localizations returned (when they are included)
     * @param limitReleases maximum number of related releases returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public gameCenterAchievementsGroupAchievementGetToOneRelatedWithHttpInfo(id: string, fieldsGameCenterAchievementReleases?: Array<'gameCenterAchievement' | 'gameCenterDetail' | 'live'>, fieldsGameCenterGroups?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'referenceName'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterAchievementLocalizations?: Array<'afterEarnedDescription' | 'beforeEarnedDescription' | 'gameCenterAchievement' | 'gameCenterAchievementImage' | 'locale' | 'name'>, fieldsGameCenterAchievements?: Array<'archived' | 'gameCenterDetail' | 'gameCenterGroup' | 'groupAchievement' | 'localizations' | 'points' | 'referenceName' | 'releases' | 'repeatable' | 'showBeforeEarned' | 'vendorIdentifier'>, limitLocalizations?: number, limitReleases?: number, include?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'groupAchievement' | 'localizations' | 'releases'>, _options?: Configuration): Promise<HttpInfo<GameCenterAchievementResponse>> {
        const result = this.api.gameCenterAchievementsGroupAchievementGetToOneRelatedWithHttpInfo(id, fieldsGameCenterAchievementReleases, fieldsGameCenterGroups, fieldsGameCenterDetails, fieldsGameCenterAchievementLocalizations, fieldsGameCenterAchievements, limitLocalizations, limitReleases, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterAchievementReleases the fields to include for returned resources of type gameCenterAchievementReleases
     * @param fieldsGameCenterGroups the fields to include for returned resources of type gameCenterGroups
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterAchievementLocalizations the fields to include for returned resources of type gameCenterAchievementLocalizations
     * @param fieldsGameCenterAchievements the fields to include for returned resources of type gameCenterAchievements
     * @param limitLocalizations maximum number of related localizations returned (when they are included)
     * @param limitReleases maximum number of related releases returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public gameCenterAchievementsGroupAchievementGetToOneRelated(id: string, fieldsGameCenterAchievementReleases?: Array<'gameCenterAchievement' | 'gameCenterDetail' | 'live'>, fieldsGameCenterGroups?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'referenceName'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterAchievementLocalizations?: Array<'afterEarnedDescription' | 'beforeEarnedDescription' | 'gameCenterAchievement' | 'gameCenterAchievementImage' | 'locale' | 'name'>, fieldsGameCenterAchievements?: Array<'archived' | 'gameCenterDetail' | 'gameCenterGroup' | 'groupAchievement' | 'localizations' | 'points' | 'referenceName' | 'releases' | 'repeatable' | 'showBeforeEarned' | 'vendorIdentifier'>, limitLocalizations?: number, limitReleases?: number, include?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'groupAchievement' | 'localizations' | 'releases'>, _options?: Configuration): Promise<GameCenterAchievementResponse> {
        const result = this.api.gameCenterAchievementsGroupAchievementGetToOneRelated(id, fieldsGameCenterAchievementReleases, fieldsGameCenterGroups, fieldsGameCenterDetails, fieldsGameCenterAchievementLocalizations, fieldsGameCenterAchievements, limitLocalizations, limitReleases, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterAchievementsGroupAchievementGetToOneRelationshipWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<GameCenterAchievementGroupAchievementLinkageResponse>> {
        const result = this.api.gameCenterAchievementsGroupAchievementGetToOneRelationshipWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterAchievementsGroupAchievementGetToOneRelationship(id: string, _options?: Configuration): Promise<GameCenterAchievementGroupAchievementLinkageResponse> {
        const result = this.api.gameCenterAchievementsGroupAchievementGetToOneRelationship(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterAchievementGroupAchievementLinkageRequest Related linkage
     */
    public gameCenterAchievementsGroupAchievementUpdateToOneRelationshipWithHttpInfo(id: string, gameCenterAchievementGroupAchievementLinkageRequest: GameCenterAchievementGroupAchievementLinkageRequest, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.gameCenterAchievementsGroupAchievementUpdateToOneRelationshipWithHttpInfo(id, gameCenterAchievementGroupAchievementLinkageRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterAchievementGroupAchievementLinkageRequest Related linkage
     */
    public gameCenterAchievementsGroupAchievementUpdateToOneRelationship(id: string, gameCenterAchievementGroupAchievementLinkageRequest: GameCenterAchievementGroupAchievementLinkageRequest, _options?: Configuration): Promise<void> {
        const result = this.api.gameCenterAchievementsGroupAchievementUpdateToOneRelationship(id, gameCenterAchievementGroupAchievementLinkageRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterAchievementImages the fields to include for returned resources of type gameCenterAchievementImages
     * @param fieldsGameCenterAchievementLocalizations the fields to include for returned resources of type gameCenterAchievementLocalizations
     * @param fieldsGameCenterAchievements the fields to include for returned resources of type gameCenterAchievements
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public gameCenterAchievementsLocalizationsGetToManyRelatedWithHttpInfo(id: string, fieldsGameCenterAchievementImages?: Array<'assetDeliveryState' | 'fileName' | 'fileSize' | 'gameCenterAchievementLocalization' | 'imageAsset' | 'uploadOperations' | 'uploaded'>, fieldsGameCenterAchievementLocalizations?: Array<'afterEarnedDescription' | 'beforeEarnedDescription' | 'gameCenterAchievement' | 'gameCenterAchievementImage' | 'locale' | 'name'>, fieldsGameCenterAchievements?: Array<'archived' | 'gameCenterDetail' | 'gameCenterGroup' | 'groupAchievement' | 'localizations' | 'points' | 'referenceName' | 'releases' | 'repeatable' | 'showBeforeEarned' | 'vendorIdentifier'>, limit?: number, include?: Array<'gameCenterAchievement' | 'gameCenterAchievementImage'>, _options?: Configuration): Promise<HttpInfo<GameCenterAchievementLocalizationsResponse>> {
        const result = this.api.gameCenterAchievementsLocalizationsGetToManyRelatedWithHttpInfo(id, fieldsGameCenterAchievementImages, fieldsGameCenterAchievementLocalizations, fieldsGameCenterAchievements, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterAchievementImages the fields to include for returned resources of type gameCenterAchievementImages
     * @param fieldsGameCenterAchievementLocalizations the fields to include for returned resources of type gameCenterAchievementLocalizations
     * @param fieldsGameCenterAchievements the fields to include for returned resources of type gameCenterAchievements
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public gameCenterAchievementsLocalizationsGetToManyRelated(id: string, fieldsGameCenterAchievementImages?: Array<'assetDeliveryState' | 'fileName' | 'fileSize' | 'gameCenterAchievementLocalization' | 'imageAsset' | 'uploadOperations' | 'uploaded'>, fieldsGameCenterAchievementLocalizations?: Array<'afterEarnedDescription' | 'beforeEarnedDescription' | 'gameCenterAchievement' | 'gameCenterAchievementImage' | 'locale' | 'name'>, fieldsGameCenterAchievements?: Array<'archived' | 'gameCenterDetail' | 'gameCenterGroup' | 'groupAchievement' | 'localizations' | 'points' | 'referenceName' | 'releases' | 'repeatable' | 'showBeforeEarned' | 'vendorIdentifier'>, limit?: number, include?: Array<'gameCenterAchievement' | 'gameCenterAchievementImage'>, _options?: Configuration): Promise<GameCenterAchievementLocalizationsResponse> {
        const result = this.api.gameCenterAchievementsLocalizationsGetToManyRelated(id, fieldsGameCenterAchievementImages, fieldsGameCenterAchievementLocalizations, fieldsGameCenterAchievements, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterLive filter by attribute \&#39;live\&#39;
     * @param filterGameCenterDetail filter by id(s) of related \&#39;gameCenterDetail\&#39;
     * @param fieldsGameCenterAchievementReleases the fields to include for returned resources of type gameCenterAchievementReleases
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterAchievements the fields to include for returned resources of type gameCenterAchievements
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public gameCenterAchievementsReleasesGetToManyRelatedWithHttpInfo(id: string, filterLive?: Array<string>, filterGameCenterDetail?: Array<string>, fieldsGameCenterAchievementReleases?: Array<'gameCenterAchievement' | 'gameCenterDetail' | 'live'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterAchievements?: Array<'archived' | 'gameCenterDetail' | 'gameCenterGroup' | 'groupAchievement' | 'localizations' | 'points' | 'referenceName' | 'releases' | 'repeatable' | 'showBeforeEarned' | 'vendorIdentifier'>, limit?: number, include?: Array<'gameCenterAchievement' | 'gameCenterDetail'>, _options?: Configuration): Promise<HttpInfo<GameCenterAchievementReleasesResponse>> {
        const result = this.api.gameCenterAchievementsReleasesGetToManyRelatedWithHttpInfo(id, filterLive, filterGameCenterDetail, fieldsGameCenterAchievementReleases, fieldsGameCenterDetails, fieldsGameCenterAchievements, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterLive filter by attribute \&#39;live\&#39;
     * @param filterGameCenterDetail filter by id(s) of related \&#39;gameCenterDetail\&#39;
     * @param fieldsGameCenterAchievementReleases the fields to include for returned resources of type gameCenterAchievementReleases
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterAchievements the fields to include for returned resources of type gameCenterAchievements
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public gameCenterAchievementsReleasesGetToManyRelated(id: string, filterLive?: Array<string>, filterGameCenterDetail?: Array<string>, fieldsGameCenterAchievementReleases?: Array<'gameCenterAchievement' | 'gameCenterDetail' | 'live'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterAchievements?: Array<'archived' | 'gameCenterDetail' | 'gameCenterGroup' | 'groupAchievement' | 'localizations' | 'points' | 'referenceName' | 'releases' | 'repeatable' | 'showBeforeEarned' | 'vendorIdentifier'>, limit?: number, include?: Array<'gameCenterAchievement' | 'gameCenterDetail'>, _options?: Configuration): Promise<GameCenterAchievementReleasesResponse> {
        const result = this.api.gameCenterAchievementsReleasesGetToManyRelated(id, filterLive, filterGameCenterDetail, fieldsGameCenterAchievementReleases, fieldsGameCenterDetails, fieldsGameCenterAchievements, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterAchievementUpdateRequest GameCenterAchievement representation
     */
    public gameCenterAchievementsUpdateInstanceWithHttpInfo(id: string, gameCenterAchievementUpdateRequest: GameCenterAchievementUpdateRequest, _options?: Configuration): Promise<HttpInfo<GameCenterAchievementResponse>> {
        const result = this.api.gameCenterAchievementsUpdateInstanceWithHttpInfo(id, gameCenterAchievementUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterAchievementUpdateRequest GameCenterAchievement representation
     */
    public gameCenterAchievementsUpdateInstance(id: string, gameCenterAchievementUpdateRequest: GameCenterAchievementUpdateRequest, _options?: Configuration): Promise<GameCenterAchievementResponse> {
        const result = this.api.gameCenterAchievementsUpdateInstance(id, gameCenterAchievementUpdateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableGameCenterAppVersionsApi } from './ObservableAPI.ts';

import { GameCenterAppVersionsApiRequestFactory, GameCenterAppVersionsApiResponseProcessor} from "../apis/GameCenterAppVersionsApi.ts";
export class PromiseGameCenterAppVersionsApi {
    private api: ObservableGameCenterAppVersionsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: GameCenterAppVersionsApiRequestFactory,
        responseProcessor?: GameCenterAppVersionsApiResponseProcessor
    ) {
        this.api = new ObservableGameCenterAppVersionsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAgeRatingDeclarations the fields to include for returned resources of type ageRatingDeclarations
     * @param fieldsAppStoreReviewDetails the fields to include for returned resources of type appStoreReviewDetails
     * @param fieldsAppStoreVersionLocalizations the fields to include for returned resources of type appStoreVersionLocalizations
     * @param fieldsAppStoreVersionExperiments the fields to include for returned resources of type appStoreVersionExperiments
     * @param fieldsAppStoreVersionSubmissions the fields to include for returned resources of type appStoreVersionSubmissions
     * @param fieldsAlternativeDistributionPackages the fields to include for returned resources of type alternativeDistributionPackages
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsRoutingAppCoverages the fields to include for returned resources of type routingAppCoverages
     * @param fieldsAppClipDefaultExperiences the fields to include for returned resources of type appClipDefaultExperiences
     * @param fieldsAppStoreVersionPhasedReleases the fields to include for returned resources of type appStoreVersionPhasedReleases
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param limitAppStoreVersionLocalizations maximum number of related appStoreVersionLocalizations returned (when they are included)
     * @param limitAppStoreVersionExperiments maximum number of related appStoreVersionExperiments returned (when they are included)
     * @param limitAppStoreVersionExperimentsV2 maximum number of related appStoreVersionExperimentsV2 returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public gameCenterAppVersionsAppStoreVersionGetToOneRelatedWithHttpInfo(id: string, fieldsAgeRatingDeclarations?: Array<'ageRatingOverride' | 'alcoholTobaccoOrDrugUseOrReferences' | 'contests' | 'gambling' | 'gamblingAndContests' | 'gamblingSimulated' | 'horrorOrFearThemes' | 'kidsAgeBand' | 'matureOrSuggestiveThemes' | 'medicalOrTreatmentInformation' | 'profanityOrCrudeHumor' | 'seventeenPlus' | 'sexualContentGraphicAndNudity' | 'sexualContentOrNudity' | 'unrestrictedWebAccess' | 'violenceCartoonOrFantasy' | 'violenceRealistic' | 'violenceRealisticProlongedGraphicOrSadistic'>, fieldsAppStoreReviewDetails?: Array<'appStoreReviewAttachments' | 'appStoreVersion' | 'contactEmail' | 'contactFirstName' | 'contactLastName' | 'contactPhone' | 'demoAccountName' | 'demoAccountPassword' | 'demoAccountRequired' | 'notes'>, fieldsAppStoreVersionLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersion' | 'description' | 'keywords' | 'locale' | 'marketingUrl' | 'promotionalText' | 'supportUrl' | 'whatsNew'>, fieldsAppStoreVersionExperiments?: Array<'app' | 'appStoreVersion' | 'appStoreVersionExperimentTreatments' | 'controlVersions' | 'endDate' | 'latestControlVersion' | 'name' | 'platform' | 'reviewRequired' | 'startDate' | 'started' | 'state' | 'trafficProportion'>, fieldsAppStoreVersionSubmissions?: Array<'appStoreVersion'>, fieldsAlternativeDistributionPackages?: Array<'appStoreVersion' | 'versions'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsRoutingAppCoverages?: Array<'appStoreVersion' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, fieldsAppClipDefaultExperiences?: Array<'action' | 'appClip' | 'appClipAppStoreReviewDetail' | 'appClipDefaultExperienceLocalizations' | 'appClipDefaultExperienceTemplate' | 'releaseWithAppStoreVersion'>, fieldsAppStoreVersionPhasedReleases?: Array<'appStoreVersion' | 'currentDayNumber' | 'phasedReleaseState' | 'startDate' | 'totalPauseDuration'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, limitAppStoreVersionLocalizations?: number, limitAppStoreVersionExperiments?: number, limitAppStoreVersionExperimentsV2?: number, include?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'build' | 'routingAppCoverage'>, _options?: Configuration): Promise<HttpInfo<AppStoreVersionResponse>> {
        const result = this.api.gameCenterAppVersionsAppStoreVersionGetToOneRelatedWithHttpInfo(id, fieldsAgeRatingDeclarations, fieldsAppStoreReviewDetails, fieldsAppStoreVersionLocalizations, fieldsAppStoreVersionExperiments, fieldsAppStoreVersionSubmissions, fieldsAlternativeDistributionPackages, fieldsAppStoreVersions, fieldsApps, fieldsRoutingAppCoverages, fieldsAppClipDefaultExperiences, fieldsAppStoreVersionPhasedReleases, fieldsBuilds, limitAppStoreVersionLocalizations, limitAppStoreVersionExperiments, limitAppStoreVersionExperimentsV2, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAgeRatingDeclarations the fields to include for returned resources of type ageRatingDeclarations
     * @param fieldsAppStoreReviewDetails the fields to include for returned resources of type appStoreReviewDetails
     * @param fieldsAppStoreVersionLocalizations the fields to include for returned resources of type appStoreVersionLocalizations
     * @param fieldsAppStoreVersionExperiments the fields to include for returned resources of type appStoreVersionExperiments
     * @param fieldsAppStoreVersionSubmissions the fields to include for returned resources of type appStoreVersionSubmissions
     * @param fieldsAlternativeDistributionPackages the fields to include for returned resources of type alternativeDistributionPackages
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsRoutingAppCoverages the fields to include for returned resources of type routingAppCoverages
     * @param fieldsAppClipDefaultExperiences the fields to include for returned resources of type appClipDefaultExperiences
     * @param fieldsAppStoreVersionPhasedReleases the fields to include for returned resources of type appStoreVersionPhasedReleases
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param limitAppStoreVersionLocalizations maximum number of related appStoreVersionLocalizations returned (when they are included)
     * @param limitAppStoreVersionExperiments maximum number of related appStoreVersionExperiments returned (when they are included)
     * @param limitAppStoreVersionExperimentsV2 maximum number of related appStoreVersionExperimentsV2 returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public gameCenterAppVersionsAppStoreVersionGetToOneRelated(id: string, fieldsAgeRatingDeclarations?: Array<'ageRatingOverride' | 'alcoholTobaccoOrDrugUseOrReferences' | 'contests' | 'gambling' | 'gamblingAndContests' | 'gamblingSimulated' | 'horrorOrFearThemes' | 'kidsAgeBand' | 'matureOrSuggestiveThemes' | 'medicalOrTreatmentInformation' | 'profanityOrCrudeHumor' | 'seventeenPlus' | 'sexualContentGraphicAndNudity' | 'sexualContentOrNudity' | 'unrestrictedWebAccess' | 'violenceCartoonOrFantasy' | 'violenceRealistic' | 'violenceRealisticProlongedGraphicOrSadistic'>, fieldsAppStoreReviewDetails?: Array<'appStoreReviewAttachments' | 'appStoreVersion' | 'contactEmail' | 'contactFirstName' | 'contactLastName' | 'contactPhone' | 'demoAccountName' | 'demoAccountPassword' | 'demoAccountRequired' | 'notes'>, fieldsAppStoreVersionLocalizations?: Array<'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersion' | 'description' | 'keywords' | 'locale' | 'marketingUrl' | 'promotionalText' | 'supportUrl' | 'whatsNew'>, fieldsAppStoreVersionExperiments?: Array<'app' | 'appStoreVersion' | 'appStoreVersionExperimentTreatments' | 'controlVersions' | 'endDate' | 'latestControlVersion' | 'name' | 'platform' | 'reviewRequired' | 'startDate' | 'started' | 'state' | 'trafficProportion'>, fieldsAppStoreVersionSubmissions?: Array<'appStoreVersion'>, fieldsAlternativeDistributionPackages?: Array<'appStoreVersion' | 'versions'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsRoutingAppCoverages?: Array<'appStoreVersion' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, fieldsAppClipDefaultExperiences?: Array<'action' | 'appClip' | 'appClipAppStoreReviewDetail' | 'appClipDefaultExperienceLocalizations' | 'appClipDefaultExperienceTemplate' | 'releaseWithAppStoreVersion'>, fieldsAppStoreVersionPhasedReleases?: Array<'appStoreVersion' | 'currentDayNumber' | 'phasedReleaseState' | 'startDate' | 'totalPauseDuration'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, limitAppStoreVersionLocalizations?: number, limitAppStoreVersionExperiments?: number, limitAppStoreVersionExperimentsV2?: number, include?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'build' | 'routingAppCoverage'>, _options?: Configuration): Promise<AppStoreVersionResponse> {
        const result = this.api.gameCenterAppVersionsAppStoreVersionGetToOneRelated(id, fieldsAgeRatingDeclarations, fieldsAppStoreReviewDetails, fieldsAppStoreVersionLocalizations, fieldsAppStoreVersionExperiments, fieldsAppStoreVersionSubmissions, fieldsAlternativeDistributionPackages, fieldsAppStoreVersions, fieldsApps, fieldsRoutingAppCoverages, fieldsAppClipDefaultExperiences, fieldsAppStoreVersionPhasedReleases, fieldsBuilds, limitAppStoreVersionLocalizations, limitAppStoreVersionExperiments, limitAppStoreVersionExperimentsV2, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterAppVersionCompatibilityVersionsLinkagesRequest List of related linkages
     */
    public gameCenterAppVersionsCompatibilityVersionsCreateToManyRelationshipWithHttpInfo(id: string, gameCenterAppVersionCompatibilityVersionsLinkagesRequest: GameCenterAppVersionCompatibilityVersionsLinkagesRequest, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.gameCenterAppVersionsCompatibilityVersionsCreateToManyRelationshipWithHttpInfo(id, gameCenterAppVersionCompatibilityVersionsLinkagesRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterAppVersionCompatibilityVersionsLinkagesRequest List of related linkages
     */
    public gameCenterAppVersionsCompatibilityVersionsCreateToManyRelationship(id: string, gameCenterAppVersionCompatibilityVersionsLinkagesRequest: GameCenterAppVersionCompatibilityVersionsLinkagesRequest, _options?: Configuration): Promise<void> {
        const result = this.api.gameCenterAppVersionsCompatibilityVersionsCreateToManyRelationship(id, gameCenterAppVersionCompatibilityVersionsLinkagesRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterAppVersionCompatibilityVersionsLinkagesRequest List of related linkages
     */
    public gameCenterAppVersionsCompatibilityVersionsDeleteToManyRelationshipWithHttpInfo(id: string, gameCenterAppVersionCompatibilityVersionsLinkagesRequest: GameCenterAppVersionCompatibilityVersionsLinkagesRequest, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.gameCenterAppVersionsCompatibilityVersionsDeleteToManyRelationshipWithHttpInfo(id, gameCenterAppVersionCompatibilityVersionsLinkagesRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterAppVersionCompatibilityVersionsLinkagesRequest List of related linkages
     */
    public gameCenterAppVersionsCompatibilityVersionsDeleteToManyRelationship(id: string, gameCenterAppVersionCompatibilityVersionsLinkagesRequest: GameCenterAppVersionCompatibilityVersionsLinkagesRequest, _options?: Configuration): Promise<void> {
        const result = this.api.gameCenterAppVersionsCompatibilityVersionsDeleteToManyRelationship(id, gameCenterAppVersionCompatibilityVersionsLinkagesRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterEnabled filter by attribute \&#39;enabled\&#39;
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsGameCenterAppVersions the fields to include for returned resources of type gameCenterAppVersions
     * @param limit maximum resources per page
     * @param limitCompatibilityVersions maximum number of related compatibilityVersions returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public gameCenterAppVersionsCompatibilityVersionsGetToManyRelatedWithHttpInfo(id: string, filterEnabled?: Array<string>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsGameCenterAppVersions?: Array<'appStoreVersion' | 'compatibilityVersions' | 'enabled'>, limit?: number, limitCompatibilityVersions?: number, include?: Array<'appStoreVersion' | 'compatibilityVersions'>, _options?: Configuration): Promise<HttpInfo<GameCenterAppVersionsResponse>> {
        const result = this.api.gameCenterAppVersionsCompatibilityVersionsGetToManyRelatedWithHttpInfo(id, filterEnabled, fieldsAppStoreVersions, fieldsGameCenterAppVersions, limit, limitCompatibilityVersions, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterEnabled filter by attribute \&#39;enabled\&#39;
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsGameCenterAppVersions the fields to include for returned resources of type gameCenterAppVersions
     * @param limit maximum resources per page
     * @param limitCompatibilityVersions maximum number of related compatibilityVersions returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public gameCenterAppVersionsCompatibilityVersionsGetToManyRelated(id: string, filterEnabled?: Array<string>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsGameCenterAppVersions?: Array<'appStoreVersion' | 'compatibilityVersions' | 'enabled'>, limit?: number, limitCompatibilityVersions?: number, include?: Array<'appStoreVersion' | 'compatibilityVersions'>, _options?: Configuration): Promise<GameCenterAppVersionsResponse> {
        const result = this.api.gameCenterAppVersionsCompatibilityVersionsGetToManyRelated(id, filterEnabled, fieldsAppStoreVersions, fieldsGameCenterAppVersions, limit, limitCompatibilityVersions, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public gameCenterAppVersionsCompatibilityVersionsGetToManyRelationshipWithHttpInfo(id: string, limit?: number, _options?: Configuration): Promise<HttpInfo<GameCenterAppVersionCompatibilityVersionsLinkagesResponse>> {
        const result = this.api.gameCenterAppVersionsCompatibilityVersionsGetToManyRelationshipWithHttpInfo(id, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public gameCenterAppVersionsCompatibilityVersionsGetToManyRelationship(id: string, limit?: number, _options?: Configuration): Promise<GameCenterAppVersionCompatibilityVersionsLinkagesResponse> {
        const result = this.api.gameCenterAppVersionsCompatibilityVersionsGetToManyRelationship(id, limit, _options);
        return result.toPromise();
    }

    /**
     * @param gameCenterAppVersionCreateRequest GameCenterAppVersion representation
     */
    public gameCenterAppVersionsCreateInstanceWithHttpInfo(gameCenterAppVersionCreateRequest: GameCenterAppVersionCreateRequest, _options?: Configuration): Promise<HttpInfo<GameCenterAppVersionResponse>> {
        const result = this.api.gameCenterAppVersionsCreateInstanceWithHttpInfo(gameCenterAppVersionCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param gameCenterAppVersionCreateRequest GameCenterAppVersion representation
     */
    public gameCenterAppVersionsCreateInstance(gameCenterAppVersionCreateRequest: GameCenterAppVersionCreateRequest, _options?: Configuration): Promise<GameCenterAppVersionResponse> {
        const result = this.api.gameCenterAppVersionsCreateInstance(gameCenterAppVersionCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterAppVersions the fields to include for returned resources of type gameCenterAppVersions
     * @param include comma-separated list of relationships to include
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param limitCompatibilityVersions maximum number of related compatibilityVersions returned (when they are included)
     */
    public gameCenterAppVersionsGetInstanceWithHttpInfo(id: string, fieldsGameCenterAppVersions?: Array<'appStoreVersion' | 'compatibilityVersions' | 'enabled'>, include?: Array<'appStoreVersion' | 'compatibilityVersions'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, limitCompatibilityVersions?: number, _options?: Configuration): Promise<HttpInfo<GameCenterAppVersionResponse>> {
        const result = this.api.gameCenterAppVersionsGetInstanceWithHttpInfo(id, fieldsGameCenterAppVersions, include, fieldsAppStoreVersions, limitCompatibilityVersions, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterAppVersions the fields to include for returned resources of type gameCenterAppVersions
     * @param include comma-separated list of relationships to include
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param limitCompatibilityVersions maximum number of related compatibilityVersions returned (when they are included)
     */
    public gameCenterAppVersionsGetInstance(id: string, fieldsGameCenterAppVersions?: Array<'appStoreVersion' | 'compatibilityVersions' | 'enabled'>, include?: Array<'appStoreVersion' | 'compatibilityVersions'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, limitCompatibilityVersions?: number, _options?: Configuration): Promise<GameCenterAppVersionResponse> {
        const result = this.api.gameCenterAppVersionsGetInstance(id, fieldsGameCenterAppVersions, include, fieldsAppStoreVersions, limitCompatibilityVersions, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterAppVersionUpdateRequest GameCenterAppVersion representation
     */
    public gameCenterAppVersionsUpdateInstanceWithHttpInfo(id: string, gameCenterAppVersionUpdateRequest: GameCenterAppVersionUpdateRequest, _options?: Configuration): Promise<HttpInfo<GameCenterAppVersionResponse>> {
        const result = this.api.gameCenterAppVersionsUpdateInstanceWithHttpInfo(id, gameCenterAppVersionUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterAppVersionUpdateRequest GameCenterAppVersion representation
     */
    public gameCenterAppVersionsUpdateInstance(id: string, gameCenterAppVersionUpdateRequest: GameCenterAppVersionUpdateRequest, _options?: Configuration): Promise<GameCenterAppVersionResponse> {
        const result = this.api.gameCenterAppVersionsUpdateInstance(id, gameCenterAppVersionUpdateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableGameCenterDetailsApi } from './ObservableAPI.ts';

import { GameCenterDetailsApiRequestFactory, GameCenterDetailsApiResponseProcessor} from "../apis/GameCenterDetailsApi.ts";
export class PromiseGameCenterDetailsApi {
    private api: ObservableGameCenterDetailsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: GameCenterDetailsApiRequestFactory,
        responseProcessor?: GameCenterDetailsApiResponseProcessor
    ) {
        this.api = new ObservableGameCenterDetailsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param id the id of the requested resource
     * @param filterLive filter by attribute \&#39;live\&#39;
     * @param filterGameCenterAchievement filter by id(s) of related \&#39;gameCenterAchievement\&#39;
     * @param fieldsGameCenterAchievementReleases the fields to include for returned resources of type gameCenterAchievementReleases
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterAchievements the fields to include for returned resources of type gameCenterAchievements
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public gameCenterDetailsAchievementReleasesGetToManyRelatedWithHttpInfo(id: string, filterLive?: Array<string>, filterGameCenterAchievement?: Array<string>, fieldsGameCenterAchievementReleases?: Array<'gameCenterAchievement' | 'gameCenterDetail' | 'live'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterAchievements?: Array<'archived' | 'gameCenterDetail' | 'gameCenterGroup' | 'groupAchievement' | 'localizations' | 'points' | 'referenceName' | 'releases' | 'repeatable' | 'showBeforeEarned' | 'vendorIdentifier'>, limit?: number, include?: Array<'gameCenterAchievement' | 'gameCenterDetail'>, _options?: Configuration): Promise<HttpInfo<GameCenterAchievementReleasesResponse>> {
        const result = this.api.gameCenterDetailsAchievementReleasesGetToManyRelatedWithHttpInfo(id, filterLive, filterGameCenterAchievement, fieldsGameCenterAchievementReleases, fieldsGameCenterDetails, fieldsGameCenterAchievements, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterLive filter by attribute \&#39;live\&#39;
     * @param filterGameCenterAchievement filter by id(s) of related \&#39;gameCenterAchievement\&#39;
     * @param fieldsGameCenterAchievementReleases the fields to include for returned resources of type gameCenterAchievementReleases
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterAchievements the fields to include for returned resources of type gameCenterAchievements
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public gameCenterDetailsAchievementReleasesGetToManyRelated(id: string, filterLive?: Array<string>, filterGameCenterAchievement?: Array<string>, fieldsGameCenterAchievementReleases?: Array<'gameCenterAchievement' | 'gameCenterDetail' | 'live'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterAchievements?: Array<'archived' | 'gameCenterDetail' | 'gameCenterGroup' | 'groupAchievement' | 'localizations' | 'points' | 'referenceName' | 'releases' | 'repeatable' | 'showBeforeEarned' | 'vendorIdentifier'>, limit?: number, include?: Array<'gameCenterAchievement' | 'gameCenterDetail'>, _options?: Configuration): Promise<GameCenterAchievementReleasesResponse> {
        const result = this.api.gameCenterDetailsAchievementReleasesGetToManyRelated(id, filterLive, filterGameCenterAchievement, fieldsGameCenterAchievementReleases, fieldsGameCenterDetails, fieldsGameCenterAchievements, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param granularity the granularity of the per-group dataset
     * @param limit maximum number of groups to return per page
     * @param groupBy the dimension by which to group the results
     * @param filterResult filter by \&#39;result\&#39; attribute dimension
     * @param sort comma-separated list of sort expressions; metrics will be sorted as specified
     */
    public gameCenterDetailsClassicMatchmakingRequestsGetMetricsWithHttpInfo(id: string, granularity: 'P1D' | 'PT1H' | 'PT15M', limit?: number, groupBy?: Array<'result'>, filterResult?: 'MATCHED' | 'CANCELED' | 'EXPIRED', sort?: Array<'averageSecondsInQueue' | '-averageSecondsInQueue' | 'count' | '-count' | 'p50SecondsInQueue' | '-p50SecondsInQueue' | 'p95SecondsInQueue' | '-p95SecondsInQueue'>, _options?: Configuration): Promise<HttpInfo<GameCenterMatchmakingAppRequestsV1MetricResponse>> {
        const result = this.api.gameCenterDetailsClassicMatchmakingRequestsGetMetricsWithHttpInfo(id, granularity, limit, groupBy, filterResult, sort, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param granularity the granularity of the per-group dataset
     * @param limit maximum number of groups to return per page
     * @param groupBy the dimension by which to group the results
     * @param filterResult filter by \&#39;result\&#39; attribute dimension
     * @param sort comma-separated list of sort expressions; metrics will be sorted as specified
     */
    public gameCenterDetailsClassicMatchmakingRequestsGetMetrics(id: string, granularity: 'P1D' | 'PT1H' | 'PT15M', limit?: number, groupBy?: Array<'result'>, filterResult?: 'MATCHED' | 'CANCELED' | 'EXPIRED', sort?: Array<'averageSecondsInQueue' | '-averageSecondsInQueue' | 'count' | '-count' | 'p50SecondsInQueue' | '-p50SecondsInQueue' | 'p95SecondsInQueue' | '-p95SecondsInQueue'>, _options?: Configuration): Promise<GameCenterMatchmakingAppRequestsV1MetricResponse> {
        const result = this.api.gameCenterDetailsClassicMatchmakingRequestsGetMetrics(id, granularity, limit, groupBy, filterResult, sort, _options);
        return result.toPromise();
    }

    /**
     * @param gameCenterDetailCreateRequest GameCenterDetail representation
     */
    public gameCenterDetailsCreateInstanceWithHttpInfo(gameCenterDetailCreateRequest: GameCenterDetailCreateRequest, _options?: Configuration): Promise<HttpInfo<GameCenterDetailResponse>> {
        const result = this.api.gameCenterDetailsCreateInstanceWithHttpInfo(gameCenterDetailCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param gameCenterDetailCreateRequest GameCenterDetail representation
     */
    public gameCenterDetailsCreateInstance(gameCenterDetailCreateRequest: GameCenterDetailCreateRequest, _options?: Configuration): Promise<GameCenterDetailResponse> {
        const result = this.api.gameCenterDetailsCreateInstance(gameCenterDetailCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterArchived filter by attribute \&#39;archived\&#39;
     * @param filterReferenceName filter by attribute \&#39;referenceName\&#39;
     * @param filterId filter by id(s)
     * @param fieldsGameCenterAchievementReleases the fields to include for returned resources of type gameCenterAchievementReleases
     * @param fieldsGameCenterGroups the fields to include for returned resources of type gameCenterGroups
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterAchievementLocalizations the fields to include for returned resources of type gameCenterAchievementLocalizations
     * @param fieldsGameCenterAchievements the fields to include for returned resources of type gameCenterAchievements
     * @param limit maximum resources per page
     * @param limitLocalizations maximum number of related localizations returned (when they are included)
     * @param limitReleases maximum number of related releases returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public gameCenterDetailsGameCenterAchievementsGetToManyRelatedWithHttpInfo(id: string, filterArchived?: Array<string>, filterReferenceName?: Array<string>, filterId?: Array<string>, fieldsGameCenterAchievementReleases?: Array<'gameCenterAchievement' | 'gameCenterDetail' | 'live'>, fieldsGameCenterGroups?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'referenceName'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterAchievementLocalizations?: Array<'afterEarnedDescription' | 'beforeEarnedDescription' | 'gameCenterAchievement' | 'gameCenterAchievementImage' | 'locale' | 'name'>, fieldsGameCenterAchievements?: Array<'archived' | 'gameCenterDetail' | 'gameCenterGroup' | 'groupAchievement' | 'localizations' | 'points' | 'referenceName' | 'releases' | 'repeatable' | 'showBeforeEarned' | 'vendorIdentifier'>, limit?: number, limitLocalizations?: number, limitReleases?: number, include?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'groupAchievement' | 'localizations' | 'releases'>, _options?: Configuration): Promise<HttpInfo<GameCenterAchievementsResponse>> {
        const result = this.api.gameCenterDetailsGameCenterAchievementsGetToManyRelatedWithHttpInfo(id, filterArchived, filterReferenceName, filterId, fieldsGameCenterAchievementReleases, fieldsGameCenterGroups, fieldsGameCenterDetails, fieldsGameCenterAchievementLocalizations, fieldsGameCenterAchievements, limit, limitLocalizations, limitReleases, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterArchived filter by attribute \&#39;archived\&#39;
     * @param filterReferenceName filter by attribute \&#39;referenceName\&#39;
     * @param filterId filter by id(s)
     * @param fieldsGameCenterAchievementReleases the fields to include for returned resources of type gameCenterAchievementReleases
     * @param fieldsGameCenterGroups the fields to include for returned resources of type gameCenterGroups
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterAchievementLocalizations the fields to include for returned resources of type gameCenterAchievementLocalizations
     * @param fieldsGameCenterAchievements the fields to include for returned resources of type gameCenterAchievements
     * @param limit maximum resources per page
     * @param limitLocalizations maximum number of related localizations returned (when they are included)
     * @param limitReleases maximum number of related releases returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public gameCenterDetailsGameCenterAchievementsGetToManyRelated(id: string, filterArchived?: Array<string>, filterReferenceName?: Array<string>, filterId?: Array<string>, fieldsGameCenterAchievementReleases?: Array<'gameCenterAchievement' | 'gameCenterDetail' | 'live'>, fieldsGameCenterGroups?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'referenceName'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterAchievementLocalizations?: Array<'afterEarnedDescription' | 'beforeEarnedDescription' | 'gameCenterAchievement' | 'gameCenterAchievementImage' | 'locale' | 'name'>, fieldsGameCenterAchievements?: Array<'archived' | 'gameCenterDetail' | 'gameCenterGroup' | 'groupAchievement' | 'localizations' | 'points' | 'referenceName' | 'releases' | 'repeatable' | 'showBeforeEarned' | 'vendorIdentifier'>, limit?: number, limitLocalizations?: number, limitReleases?: number, include?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'groupAchievement' | 'localizations' | 'releases'>, _options?: Configuration): Promise<GameCenterAchievementsResponse> {
        const result = this.api.gameCenterDetailsGameCenterAchievementsGetToManyRelated(id, filterArchived, filterReferenceName, filterId, fieldsGameCenterAchievementReleases, fieldsGameCenterGroups, fieldsGameCenterDetails, fieldsGameCenterAchievementLocalizations, fieldsGameCenterAchievements, limit, limitLocalizations, limitReleases, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public gameCenterDetailsGameCenterAchievementsGetToManyRelationshipWithHttpInfo(id: string, limit?: number, _options?: Configuration): Promise<HttpInfo<GameCenterDetailGameCenterAchievementsLinkagesResponse>> {
        const result = this.api.gameCenterDetailsGameCenterAchievementsGetToManyRelationshipWithHttpInfo(id, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public gameCenterDetailsGameCenterAchievementsGetToManyRelationship(id: string, limit?: number, _options?: Configuration): Promise<GameCenterDetailGameCenterAchievementsLinkagesResponse> {
        const result = this.api.gameCenterDetailsGameCenterAchievementsGetToManyRelationship(id, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterDetailGameCenterAchievementsLinkagesRequest List of related linkages
     */
    public gameCenterDetailsGameCenterAchievementsReplaceToManyRelationshipWithHttpInfo(id: string, gameCenterDetailGameCenterAchievementsLinkagesRequest: GameCenterDetailGameCenterAchievementsLinkagesRequest, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.gameCenterDetailsGameCenterAchievementsReplaceToManyRelationshipWithHttpInfo(id, gameCenterDetailGameCenterAchievementsLinkagesRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterDetailGameCenterAchievementsLinkagesRequest List of related linkages
     */
    public gameCenterDetailsGameCenterAchievementsReplaceToManyRelationship(id: string, gameCenterDetailGameCenterAchievementsLinkagesRequest: GameCenterDetailGameCenterAchievementsLinkagesRequest, _options?: Configuration): Promise<void> {
        const result = this.api.gameCenterDetailsGameCenterAchievementsReplaceToManyRelationship(id, gameCenterDetailGameCenterAchievementsLinkagesRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterEnabled filter by attribute \&#39;enabled\&#39;
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsGameCenterAppVersions the fields to include for returned resources of type gameCenterAppVersions
     * @param limit maximum resources per page
     * @param limitCompatibilityVersions maximum number of related compatibilityVersions returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public gameCenterDetailsGameCenterAppVersionsGetToManyRelatedWithHttpInfo(id: string, filterEnabled?: Array<string>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsGameCenterAppVersions?: Array<'appStoreVersion' | 'compatibilityVersions' | 'enabled'>, limit?: number, limitCompatibilityVersions?: number, include?: Array<'appStoreVersion' | 'compatibilityVersions'>, _options?: Configuration): Promise<HttpInfo<GameCenterAppVersionsResponse>> {
        const result = this.api.gameCenterDetailsGameCenterAppVersionsGetToManyRelatedWithHttpInfo(id, filterEnabled, fieldsAppStoreVersions, fieldsGameCenterAppVersions, limit, limitCompatibilityVersions, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterEnabled filter by attribute \&#39;enabled\&#39;
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsGameCenterAppVersions the fields to include for returned resources of type gameCenterAppVersions
     * @param limit maximum resources per page
     * @param limitCompatibilityVersions maximum number of related compatibilityVersions returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public gameCenterDetailsGameCenterAppVersionsGetToManyRelated(id: string, filterEnabled?: Array<string>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsGameCenterAppVersions?: Array<'appStoreVersion' | 'compatibilityVersions' | 'enabled'>, limit?: number, limitCompatibilityVersions?: number, include?: Array<'appStoreVersion' | 'compatibilityVersions'>, _options?: Configuration): Promise<GameCenterAppVersionsResponse> {
        const result = this.api.gameCenterDetailsGameCenterAppVersionsGetToManyRelated(id, filterEnabled, fieldsAppStoreVersions, fieldsGameCenterAppVersions, limit, limitCompatibilityVersions, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterLeaderboardSets the fields to include for returned resources of type gameCenterLeaderboardSets
     * @param fieldsGameCenterGroups the fields to include for returned resources of type gameCenterGroups
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     * @param fieldsGameCenterAchievements the fields to include for returned resources of type gameCenterAchievements
     * @param limitGameCenterDetails maximum number of related gameCenterDetails returned (when they are included)
     * @param limitGameCenterLeaderboards maximum number of related gameCenterLeaderboards returned (when they are included)
     * @param limitGameCenterLeaderboardSets maximum number of related gameCenterLeaderboardSets returned (when they are included)
     * @param limitGameCenterAchievements maximum number of related gameCenterAchievements returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public gameCenterDetailsGameCenterGroupGetToOneRelatedWithHttpInfo(id: string, fieldsGameCenterLeaderboardSets?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'referenceName' | 'releases' | 'vendorIdentifier'>, fieldsGameCenterGroups?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'referenceName'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, fieldsGameCenterAchievements?: Array<'archived' | 'gameCenterDetail' | 'gameCenterGroup' | 'groupAchievement' | 'localizations' | 'points' | 'referenceName' | 'releases' | 'repeatable' | 'showBeforeEarned' | 'vendorIdentifier'>, limitGameCenterDetails?: number, limitGameCenterLeaderboards?: number, limitGameCenterLeaderboardSets?: number, limitGameCenterAchievements?: number, include?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards'>, _options?: Configuration): Promise<HttpInfo<GameCenterGroupResponse>> {
        const result = this.api.gameCenterDetailsGameCenterGroupGetToOneRelatedWithHttpInfo(id, fieldsGameCenterLeaderboardSets, fieldsGameCenterGroups, fieldsGameCenterDetails, fieldsGameCenterLeaderboards, fieldsGameCenterAchievements, limitGameCenterDetails, limitGameCenterLeaderboards, limitGameCenterLeaderboardSets, limitGameCenterAchievements, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterLeaderboardSets the fields to include for returned resources of type gameCenterLeaderboardSets
     * @param fieldsGameCenterGroups the fields to include for returned resources of type gameCenterGroups
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     * @param fieldsGameCenterAchievements the fields to include for returned resources of type gameCenterAchievements
     * @param limitGameCenterDetails maximum number of related gameCenterDetails returned (when they are included)
     * @param limitGameCenterLeaderboards maximum number of related gameCenterLeaderboards returned (when they are included)
     * @param limitGameCenterLeaderboardSets maximum number of related gameCenterLeaderboardSets returned (when they are included)
     * @param limitGameCenterAchievements maximum number of related gameCenterAchievements returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public gameCenterDetailsGameCenterGroupGetToOneRelated(id: string, fieldsGameCenterLeaderboardSets?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'referenceName' | 'releases' | 'vendorIdentifier'>, fieldsGameCenterGroups?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'referenceName'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, fieldsGameCenterAchievements?: Array<'archived' | 'gameCenterDetail' | 'gameCenterGroup' | 'groupAchievement' | 'localizations' | 'points' | 'referenceName' | 'releases' | 'repeatable' | 'showBeforeEarned' | 'vendorIdentifier'>, limitGameCenterDetails?: number, limitGameCenterLeaderboards?: number, limitGameCenterLeaderboardSets?: number, limitGameCenterAchievements?: number, include?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards'>, _options?: Configuration): Promise<GameCenterGroupResponse> {
        const result = this.api.gameCenterDetailsGameCenterGroupGetToOneRelated(id, fieldsGameCenterLeaderboardSets, fieldsGameCenterGroups, fieldsGameCenterDetails, fieldsGameCenterLeaderboards, fieldsGameCenterAchievements, limitGameCenterDetails, limitGameCenterLeaderboards, limitGameCenterLeaderboardSets, limitGameCenterAchievements, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterReferenceName filter by attribute \&#39;referenceName\&#39;
     * @param filterId filter by id(s)
     * @param fieldsGameCenterLeaderboardSetLocalizations the fields to include for returned resources of type gameCenterLeaderboardSetLocalizations
     * @param fieldsGameCenterLeaderboardSetReleases the fields to include for returned resources of type gameCenterLeaderboardSetReleases
     * @param fieldsGameCenterLeaderboardSets the fields to include for returned resources of type gameCenterLeaderboardSets
     * @param fieldsGameCenterGroups the fields to include for returned resources of type gameCenterGroups
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     * @param limit maximum resources per page
     * @param limitLocalizations maximum number of related localizations returned (when they are included)
     * @param limitGameCenterLeaderboards maximum number of related gameCenterLeaderboards returned (when they are included)
     * @param limitReleases maximum number of related releases returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public gameCenterDetailsGameCenterLeaderboardSetsGetToManyRelatedWithHttpInfo(id: string, filterReferenceName?: Array<string>, filterId?: Array<string>, fieldsGameCenterLeaderboardSetLocalizations?: Array<'gameCenterLeaderboardSet' | 'gameCenterLeaderboardSetImage' | 'locale' | 'name'>, fieldsGameCenterLeaderboardSetReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboardSet' | 'live'>, fieldsGameCenterLeaderboardSets?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'referenceName' | 'releases' | 'vendorIdentifier'>, fieldsGameCenterGroups?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'referenceName'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, limit?: number, limitLocalizations?: number, limitGameCenterLeaderboards?: number, limitReleases?: number, include?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'releases'>, _options?: Configuration): Promise<HttpInfo<GameCenterLeaderboardSetsResponse>> {
        const result = this.api.gameCenterDetailsGameCenterLeaderboardSetsGetToManyRelatedWithHttpInfo(id, filterReferenceName, filterId, fieldsGameCenterLeaderboardSetLocalizations, fieldsGameCenterLeaderboardSetReleases, fieldsGameCenterLeaderboardSets, fieldsGameCenterGroups, fieldsGameCenterDetails, fieldsGameCenterLeaderboards, limit, limitLocalizations, limitGameCenterLeaderboards, limitReleases, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterReferenceName filter by attribute \&#39;referenceName\&#39;
     * @param filterId filter by id(s)
     * @param fieldsGameCenterLeaderboardSetLocalizations the fields to include for returned resources of type gameCenterLeaderboardSetLocalizations
     * @param fieldsGameCenterLeaderboardSetReleases the fields to include for returned resources of type gameCenterLeaderboardSetReleases
     * @param fieldsGameCenterLeaderboardSets the fields to include for returned resources of type gameCenterLeaderboardSets
     * @param fieldsGameCenterGroups the fields to include for returned resources of type gameCenterGroups
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     * @param limit maximum resources per page
     * @param limitLocalizations maximum number of related localizations returned (when they are included)
     * @param limitGameCenterLeaderboards maximum number of related gameCenterLeaderboards returned (when they are included)
     * @param limitReleases maximum number of related releases returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public gameCenterDetailsGameCenterLeaderboardSetsGetToManyRelated(id: string, filterReferenceName?: Array<string>, filterId?: Array<string>, fieldsGameCenterLeaderboardSetLocalizations?: Array<'gameCenterLeaderboardSet' | 'gameCenterLeaderboardSetImage' | 'locale' | 'name'>, fieldsGameCenterLeaderboardSetReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboardSet' | 'live'>, fieldsGameCenterLeaderboardSets?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'referenceName' | 'releases' | 'vendorIdentifier'>, fieldsGameCenterGroups?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'referenceName'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, limit?: number, limitLocalizations?: number, limitGameCenterLeaderboards?: number, limitReleases?: number, include?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'releases'>, _options?: Configuration): Promise<GameCenterLeaderboardSetsResponse> {
        const result = this.api.gameCenterDetailsGameCenterLeaderboardSetsGetToManyRelated(id, filterReferenceName, filterId, fieldsGameCenterLeaderboardSetLocalizations, fieldsGameCenterLeaderboardSetReleases, fieldsGameCenterLeaderboardSets, fieldsGameCenterGroups, fieldsGameCenterDetails, fieldsGameCenterLeaderboards, limit, limitLocalizations, limitGameCenterLeaderboards, limitReleases, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public gameCenterDetailsGameCenterLeaderboardSetsGetToManyRelationshipWithHttpInfo(id: string, limit?: number, _options?: Configuration): Promise<HttpInfo<GameCenterDetailGameCenterLeaderboardSetsLinkagesResponse>> {
        const result = this.api.gameCenterDetailsGameCenterLeaderboardSetsGetToManyRelationshipWithHttpInfo(id, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public gameCenterDetailsGameCenterLeaderboardSetsGetToManyRelationship(id: string, limit?: number, _options?: Configuration): Promise<GameCenterDetailGameCenterLeaderboardSetsLinkagesResponse> {
        const result = this.api.gameCenterDetailsGameCenterLeaderboardSetsGetToManyRelationship(id, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterDetailGameCenterLeaderboardSetsLinkagesRequest List of related linkages
     */
    public gameCenterDetailsGameCenterLeaderboardSetsReplaceToManyRelationshipWithHttpInfo(id: string, gameCenterDetailGameCenterLeaderboardSetsLinkagesRequest: GameCenterDetailGameCenterLeaderboardSetsLinkagesRequest, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.gameCenterDetailsGameCenterLeaderboardSetsReplaceToManyRelationshipWithHttpInfo(id, gameCenterDetailGameCenterLeaderboardSetsLinkagesRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterDetailGameCenterLeaderboardSetsLinkagesRequest List of related linkages
     */
    public gameCenterDetailsGameCenterLeaderboardSetsReplaceToManyRelationship(id: string, gameCenterDetailGameCenterLeaderboardSetsLinkagesRequest: GameCenterDetailGameCenterLeaderboardSetsLinkagesRequest, _options?: Configuration): Promise<void> {
        const result = this.api.gameCenterDetailsGameCenterLeaderboardSetsReplaceToManyRelationship(id, gameCenterDetailGameCenterLeaderboardSetsLinkagesRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterArchived filter by attribute \&#39;archived\&#39;
     * @param filterReferenceName filter by attribute \&#39;referenceName\&#39;
     * @param filterId filter by id(s)
     * @param fieldsGameCenterLeaderboardLocalizations the fields to include for returned resources of type gameCenterLeaderboardLocalizations
     * @param fieldsGameCenterLeaderboardSets the fields to include for returned resources of type gameCenterLeaderboardSets
     * @param fieldsGameCenterGroups the fields to include for returned resources of type gameCenterGroups
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     * @param fieldsGameCenterLeaderboardReleases the fields to include for returned resources of type gameCenterLeaderboardReleases
     * @param limit maximum resources per page
     * @param limitGameCenterLeaderboardSets maximum number of related gameCenterLeaderboardSets returned (when they are included)
     * @param limitLocalizations maximum number of related localizations returned (when they are included)
     * @param limitReleases maximum number of related releases returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public gameCenterDetailsGameCenterLeaderboardsGetToManyRelatedWithHttpInfo(id: string, filterArchived?: Array<string>, filterReferenceName?: Array<string>, filterId?: Array<string>, fieldsGameCenterLeaderboardLocalizations?: Array<'formatterOverride' | 'formatterSuffix' | 'formatterSuffixSingular' | 'gameCenterLeaderboard' | 'gameCenterLeaderboardImage' | 'locale' | 'name'>, fieldsGameCenterLeaderboardSets?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'referenceName' | 'releases' | 'vendorIdentifier'>, fieldsGameCenterGroups?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'referenceName'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, fieldsGameCenterLeaderboardReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboard' | 'live'>, limit?: number, limitGameCenterLeaderboardSets?: number, limitLocalizations?: number, limitReleases?: number, include?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'releases'>, _options?: Configuration): Promise<HttpInfo<GameCenterLeaderboardsResponse>> {
        const result = this.api.gameCenterDetailsGameCenterLeaderboardsGetToManyRelatedWithHttpInfo(id, filterArchived, filterReferenceName, filterId, fieldsGameCenterLeaderboardLocalizations, fieldsGameCenterLeaderboardSets, fieldsGameCenterGroups, fieldsGameCenterDetails, fieldsGameCenterLeaderboards, fieldsGameCenterLeaderboardReleases, limit, limitGameCenterLeaderboardSets, limitLocalizations, limitReleases, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterArchived filter by attribute \&#39;archived\&#39;
     * @param filterReferenceName filter by attribute \&#39;referenceName\&#39;
     * @param filterId filter by id(s)
     * @param fieldsGameCenterLeaderboardLocalizations the fields to include for returned resources of type gameCenterLeaderboardLocalizations
     * @param fieldsGameCenterLeaderboardSets the fields to include for returned resources of type gameCenterLeaderboardSets
     * @param fieldsGameCenterGroups the fields to include for returned resources of type gameCenterGroups
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     * @param fieldsGameCenterLeaderboardReleases the fields to include for returned resources of type gameCenterLeaderboardReleases
     * @param limit maximum resources per page
     * @param limitGameCenterLeaderboardSets maximum number of related gameCenterLeaderboardSets returned (when they are included)
     * @param limitLocalizations maximum number of related localizations returned (when they are included)
     * @param limitReleases maximum number of related releases returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public gameCenterDetailsGameCenterLeaderboardsGetToManyRelated(id: string, filterArchived?: Array<string>, filterReferenceName?: Array<string>, filterId?: Array<string>, fieldsGameCenterLeaderboardLocalizations?: Array<'formatterOverride' | 'formatterSuffix' | 'formatterSuffixSingular' | 'gameCenterLeaderboard' | 'gameCenterLeaderboardImage' | 'locale' | 'name'>, fieldsGameCenterLeaderboardSets?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'referenceName' | 'releases' | 'vendorIdentifier'>, fieldsGameCenterGroups?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'referenceName'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, fieldsGameCenterLeaderboardReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboard' | 'live'>, limit?: number, limitGameCenterLeaderboardSets?: number, limitLocalizations?: number, limitReleases?: number, include?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'releases'>, _options?: Configuration): Promise<GameCenterLeaderboardsResponse> {
        const result = this.api.gameCenterDetailsGameCenterLeaderboardsGetToManyRelated(id, filterArchived, filterReferenceName, filterId, fieldsGameCenterLeaderboardLocalizations, fieldsGameCenterLeaderboardSets, fieldsGameCenterGroups, fieldsGameCenterDetails, fieldsGameCenterLeaderboards, fieldsGameCenterLeaderboardReleases, limit, limitGameCenterLeaderboardSets, limitLocalizations, limitReleases, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public gameCenterDetailsGameCenterLeaderboardsGetToManyRelationshipWithHttpInfo(id: string, limit?: number, _options?: Configuration): Promise<HttpInfo<GameCenterDetailGameCenterLeaderboardsLinkagesResponse>> {
        const result = this.api.gameCenterDetailsGameCenterLeaderboardsGetToManyRelationshipWithHttpInfo(id, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public gameCenterDetailsGameCenterLeaderboardsGetToManyRelationship(id: string, limit?: number, _options?: Configuration): Promise<GameCenterDetailGameCenterLeaderboardsLinkagesResponse> {
        const result = this.api.gameCenterDetailsGameCenterLeaderboardsGetToManyRelationship(id, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterDetailGameCenterLeaderboardsLinkagesRequest List of related linkages
     */
    public gameCenterDetailsGameCenterLeaderboardsReplaceToManyRelationshipWithHttpInfo(id: string, gameCenterDetailGameCenterLeaderboardsLinkagesRequest: GameCenterDetailGameCenterLeaderboardsLinkagesRequest, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.gameCenterDetailsGameCenterLeaderboardsReplaceToManyRelationshipWithHttpInfo(id, gameCenterDetailGameCenterLeaderboardsLinkagesRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterDetailGameCenterLeaderboardsLinkagesRequest List of related linkages
     */
    public gameCenterDetailsGameCenterLeaderboardsReplaceToManyRelationship(id: string, gameCenterDetailGameCenterLeaderboardsLinkagesRequest: GameCenterDetailGameCenterLeaderboardsLinkagesRequest, _options?: Configuration): Promise<void> {
        const result = this.api.gameCenterDetailsGameCenterLeaderboardsReplaceToManyRelationship(id, gameCenterDetailGameCenterLeaderboardsLinkagesRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param include comma-separated list of relationships to include
     * @param fieldsGameCenterAchievementReleases the fields to include for returned resources of type gameCenterAchievementReleases
     * @param fieldsGameCenterLeaderboardSetReleases the fields to include for returned resources of type gameCenterLeaderboardSetReleases
     * @param fieldsGameCenterLeaderboardSets the fields to include for returned resources of type gameCenterLeaderboardSets
     * @param fieldsGameCenterGroups the fields to include for returned resources of type gameCenterGroups
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     * @param fieldsGameCenterAchievements the fields to include for returned resources of type gameCenterAchievements
     * @param fieldsGameCenterAppVersions the fields to include for returned resources of type gameCenterAppVersions
     * @param fieldsGameCenterLeaderboardReleases the fields to include for returned resources of type gameCenterLeaderboardReleases
     * @param limitAchievementReleases maximum number of related achievementReleases returned (when they are included)
     * @param limitGameCenterAchievements maximum number of related gameCenterAchievements returned (when they are included)
     * @param limitGameCenterAppVersions maximum number of related gameCenterAppVersions returned (when they are included)
     * @param limitGameCenterLeaderboardSets maximum number of related gameCenterLeaderboardSets returned (when they are included)
     * @param limitGameCenterLeaderboards maximum number of related gameCenterLeaderboards returned (when they are included)
     * @param limitLeaderboardReleases maximum number of related leaderboardReleases returned (when they are included)
     * @param limitLeaderboardSetReleases maximum number of related leaderboardSetReleases returned (when they are included)
     */
    public gameCenterDetailsGetInstanceWithHttpInfo(id: string, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, include?: Array<'achievementReleases' | 'app' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterAchievementReleases?: Array<'gameCenterAchievement' | 'gameCenterDetail' | 'live'>, fieldsGameCenterLeaderboardSetReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboardSet' | 'live'>, fieldsGameCenterLeaderboardSets?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'referenceName' | 'releases' | 'vendorIdentifier'>, fieldsGameCenterGroups?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'referenceName'>, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, fieldsGameCenterAchievements?: Array<'archived' | 'gameCenterDetail' | 'gameCenterGroup' | 'groupAchievement' | 'localizations' | 'points' | 'referenceName' | 'releases' | 'repeatable' | 'showBeforeEarned' | 'vendorIdentifier'>, fieldsGameCenterAppVersions?: Array<'appStoreVersion' | 'compatibilityVersions' | 'enabled'>, fieldsGameCenterLeaderboardReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboard' | 'live'>, limitAchievementReleases?: number, limitGameCenterAchievements?: number, limitGameCenterAppVersions?: number, limitGameCenterLeaderboardSets?: number, limitGameCenterLeaderboards?: number, limitLeaderboardReleases?: number, limitLeaderboardSetReleases?: number, _options?: Configuration): Promise<HttpInfo<GameCenterDetailResponse>> {
        const result = this.api.gameCenterDetailsGetInstanceWithHttpInfo(id, fieldsGameCenterDetails, include, fieldsGameCenterAchievementReleases, fieldsGameCenterLeaderboardSetReleases, fieldsGameCenterLeaderboardSets, fieldsGameCenterGroups, fieldsGameCenterLeaderboards, fieldsGameCenterAchievements, fieldsGameCenterAppVersions, fieldsGameCenterLeaderboardReleases, limitAchievementReleases, limitGameCenterAchievements, limitGameCenterAppVersions, limitGameCenterLeaderboardSets, limitGameCenterLeaderboards, limitLeaderboardReleases, limitLeaderboardSetReleases, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param include comma-separated list of relationships to include
     * @param fieldsGameCenterAchievementReleases the fields to include for returned resources of type gameCenterAchievementReleases
     * @param fieldsGameCenterLeaderboardSetReleases the fields to include for returned resources of type gameCenterLeaderboardSetReleases
     * @param fieldsGameCenterLeaderboardSets the fields to include for returned resources of type gameCenterLeaderboardSets
     * @param fieldsGameCenterGroups the fields to include for returned resources of type gameCenterGroups
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     * @param fieldsGameCenterAchievements the fields to include for returned resources of type gameCenterAchievements
     * @param fieldsGameCenterAppVersions the fields to include for returned resources of type gameCenterAppVersions
     * @param fieldsGameCenterLeaderboardReleases the fields to include for returned resources of type gameCenterLeaderboardReleases
     * @param limitAchievementReleases maximum number of related achievementReleases returned (when they are included)
     * @param limitGameCenterAchievements maximum number of related gameCenterAchievements returned (when they are included)
     * @param limitGameCenterAppVersions maximum number of related gameCenterAppVersions returned (when they are included)
     * @param limitGameCenterLeaderboardSets maximum number of related gameCenterLeaderboardSets returned (when they are included)
     * @param limitGameCenterLeaderboards maximum number of related gameCenterLeaderboards returned (when they are included)
     * @param limitLeaderboardReleases maximum number of related leaderboardReleases returned (when they are included)
     * @param limitLeaderboardSetReleases maximum number of related leaderboardSetReleases returned (when they are included)
     */
    public gameCenterDetailsGetInstance(id: string, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, include?: Array<'achievementReleases' | 'app' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterAchievementReleases?: Array<'gameCenterAchievement' | 'gameCenterDetail' | 'live'>, fieldsGameCenterLeaderboardSetReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboardSet' | 'live'>, fieldsGameCenterLeaderboardSets?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'referenceName' | 'releases' | 'vendorIdentifier'>, fieldsGameCenterGroups?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'referenceName'>, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, fieldsGameCenterAchievements?: Array<'archived' | 'gameCenterDetail' | 'gameCenterGroup' | 'groupAchievement' | 'localizations' | 'points' | 'referenceName' | 'releases' | 'repeatable' | 'showBeforeEarned' | 'vendorIdentifier'>, fieldsGameCenterAppVersions?: Array<'appStoreVersion' | 'compatibilityVersions' | 'enabled'>, fieldsGameCenterLeaderboardReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboard' | 'live'>, limitAchievementReleases?: number, limitGameCenterAchievements?: number, limitGameCenterAppVersions?: number, limitGameCenterLeaderboardSets?: number, limitGameCenterLeaderboards?: number, limitLeaderboardReleases?: number, limitLeaderboardSetReleases?: number, _options?: Configuration): Promise<GameCenterDetailResponse> {
        const result = this.api.gameCenterDetailsGetInstance(id, fieldsGameCenterDetails, include, fieldsGameCenterAchievementReleases, fieldsGameCenterLeaderboardSetReleases, fieldsGameCenterLeaderboardSets, fieldsGameCenterGroups, fieldsGameCenterLeaderboards, fieldsGameCenterAchievements, fieldsGameCenterAppVersions, fieldsGameCenterLeaderboardReleases, limitAchievementReleases, limitGameCenterAchievements, limitGameCenterAppVersions, limitGameCenterLeaderboardSets, limitGameCenterLeaderboards, limitLeaderboardReleases, limitLeaderboardSetReleases, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterLive filter by attribute \&#39;live\&#39;
     * @param filterGameCenterLeaderboard filter by id(s) of related \&#39;gameCenterLeaderboard\&#39;
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     * @param fieldsGameCenterLeaderboardReleases the fields to include for returned resources of type gameCenterLeaderboardReleases
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public gameCenterDetailsLeaderboardReleasesGetToManyRelatedWithHttpInfo(id: string, filterLive?: Array<string>, filterGameCenterLeaderboard?: Array<string>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, fieldsGameCenterLeaderboardReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboard' | 'live'>, limit?: number, include?: Array<'gameCenterDetail' | 'gameCenterLeaderboard'>, _options?: Configuration): Promise<HttpInfo<GameCenterLeaderboardReleasesResponse>> {
        const result = this.api.gameCenterDetailsLeaderboardReleasesGetToManyRelatedWithHttpInfo(id, filterLive, filterGameCenterLeaderboard, fieldsGameCenterDetails, fieldsGameCenterLeaderboards, fieldsGameCenterLeaderboardReleases, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterLive filter by attribute \&#39;live\&#39;
     * @param filterGameCenterLeaderboard filter by id(s) of related \&#39;gameCenterLeaderboard\&#39;
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     * @param fieldsGameCenterLeaderboardReleases the fields to include for returned resources of type gameCenterLeaderboardReleases
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public gameCenterDetailsLeaderboardReleasesGetToManyRelated(id: string, filterLive?: Array<string>, filterGameCenterLeaderboard?: Array<string>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, fieldsGameCenterLeaderboardReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboard' | 'live'>, limit?: number, include?: Array<'gameCenterDetail' | 'gameCenterLeaderboard'>, _options?: Configuration): Promise<GameCenterLeaderboardReleasesResponse> {
        const result = this.api.gameCenterDetailsLeaderboardReleasesGetToManyRelated(id, filterLive, filterGameCenterLeaderboard, fieldsGameCenterDetails, fieldsGameCenterLeaderboards, fieldsGameCenterLeaderboardReleases, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterLive filter by attribute \&#39;live\&#39;
     * @param filterGameCenterLeaderboardSet filter by id(s) of related \&#39;gameCenterLeaderboardSet\&#39;
     * @param fieldsGameCenterLeaderboardSetReleases the fields to include for returned resources of type gameCenterLeaderboardSetReleases
     * @param fieldsGameCenterLeaderboardSets the fields to include for returned resources of type gameCenterLeaderboardSets
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public gameCenterDetailsLeaderboardSetReleasesGetToManyRelatedWithHttpInfo(id: string, filterLive?: Array<string>, filterGameCenterLeaderboardSet?: Array<string>, fieldsGameCenterLeaderboardSetReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboardSet' | 'live'>, fieldsGameCenterLeaderboardSets?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'referenceName' | 'releases' | 'vendorIdentifier'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, limit?: number, include?: Array<'gameCenterDetail' | 'gameCenterLeaderboardSet'>, _options?: Configuration): Promise<HttpInfo<GameCenterLeaderboardSetReleasesResponse>> {
        const result = this.api.gameCenterDetailsLeaderboardSetReleasesGetToManyRelatedWithHttpInfo(id, filterLive, filterGameCenterLeaderboardSet, fieldsGameCenterLeaderboardSetReleases, fieldsGameCenterLeaderboardSets, fieldsGameCenterDetails, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterLive filter by attribute \&#39;live\&#39;
     * @param filterGameCenterLeaderboardSet filter by id(s) of related \&#39;gameCenterLeaderboardSet\&#39;
     * @param fieldsGameCenterLeaderboardSetReleases the fields to include for returned resources of type gameCenterLeaderboardSetReleases
     * @param fieldsGameCenterLeaderboardSets the fields to include for returned resources of type gameCenterLeaderboardSets
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public gameCenterDetailsLeaderboardSetReleasesGetToManyRelated(id: string, filterLive?: Array<string>, filterGameCenterLeaderboardSet?: Array<string>, fieldsGameCenterLeaderboardSetReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboardSet' | 'live'>, fieldsGameCenterLeaderboardSets?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'referenceName' | 'releases' | 'vendorIdentifier'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, limit?: number, include?: Array<'gameCenterDetail' | 'gameCenterLeaderboardSet'>, _options?: Configuration): Promise<GameCenterLeaderboardSetReleasesResponse> {
        const result = this.api.gameCenterDetailsLeaderboardSetReleasesGetToManyRelated(id, filterLive, filterGameCenterLeaderboardSet, fieldsGameCenterLeaderboardSetReleases, fieldsGameCenterLeaderboardSets, fieldsGameCenterDetails, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param granularity the granularity of the per-group dataset
     * @param limit maximum number of groups to return per page
     * @param groupBy the dimension by which to group the results
     * @param filterResult filter by \&#39;result\&#39; attribute dimension
     * @param sort comma-separated list of sort expressions; metrics will be sorted as specified
     */
    public gameCenterDetailsRuleBasedMatchmakingRequestsGetMetricsWithHttpInfo(id: string, granularity: 'P1D' | 'PT1H' | 'PT15M', limit?: number, groupBy?: Array<'result'>, filterResult?: 'MATCHED' | 'CANCELED' | 'EXPIRED', sort?: Array<'averageSecondsInQueue' | '-averageSecondsInQueue' | 'count' | '-count' | 'p50SecondsInQueue' | '-p50SecondsInQueue' | 'p95SecondsInQueue' | '-p95SecondsInQueue'>, _options?: Configuration): Promise<HttpInfo<GameCenterMatchmakingAppRequestsV1MetricResponse>> {
        const result = this.api.gameCenterDetailsRuleBasedMatchmakingRequestsGetMetricsWithHttpInfo(id, granularity, limit, groupBy, filterResult, sort, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param granularity the granularity of the per-group dataset
     * @param limit maximum number of groups to return per page
     * @param groupBy the dimension by which to group the results
     * @param filterResult filter by \&#39;result\&#39; attribute dimension
     * @param sort comma-separated list of sort expressions; metrics will be sorted as specified
     */
    public gameCenterDetailsRuleBasedMatchmakingRequestsGetMetrics(id: string, granularity: 'P1D' | 'PT1H' | 'PT15M', limit?: number, groupBy?: Array<'result'>, filterResult?: 'MATCHED' | 'CANCELED' | 'EXPIRED', sort?: Array<'averageSecondsInQueue' | '-averageSecondsInQueue' | 'count' | '-count' | 'p50SecondsInQueue' | '-p50SecondsInQueue' | 'p95SecondsInQueue' | '-p95SecondsInQueue'>, _options?: Configuration): Promise<GameCenterMatchmakingAppRequestsV1MetricResponse> {
        const result = this.api.gameCenterDetailsRuleBasedMatchmakingRequestsGetMetrics(id, granularity, limit, groupBy, filterResult, sort, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterDetailUpdateRequest GameCenterDetail representation
     */
    public gameCenterDetailsUpdateInstanceWithHttpInfo(id: string, gameCenterDetailUpdateRequest: GameCenterDetailUpdateRequest, _options?: Configuration): Promise<HttpInfo<GameCenterDetailResponse>> {
        const result = this.api.gameCenterDetailsUpdateInstanceWithHttpInfo(id, gameCenterDetailUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterDetailUpdateRequest GameCenterDetail representation
     */
    public gameCenterDetailsUpdateInstance(id: string, gameCenterDetailUpdateRequest: GameCenterDetailUpdateRequest, _options?: Configuration): Promise<GameCenterDetailResponse> {
        const result = this.api.gameCenterDetailsUpdateInstance(id, gameCenterDetailUpdateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableGameCenterEnabledVersionsApi } from './ObservableAPI.ts';

import { GameCenterEnabledVersionsApiRequestFactory, GameCenterEnabledVersionsApiResponseProcessor} from "../apis/GameCenterEnabledVersionsApi.ts";
export class PromiseGameCenterEnabledVersionsApi {
    private api: ObservableGameCenterEnabledVersionsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: GameCenterEnabledVersionsApiRequestFactory,
        responseProcessor?: GameCenterEnabledVersionsApiResponseProcessor
    ) {
        this.api = new ObservableGameCenterEnabledVersionsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterEnabledVersionCompatibleVersionsLinkagesRequest List of related linkages
     */
    public gameCenterEnabledVersionsCompatibleVersionsCreateToManyRelationshipWithHttpInfo(id: string, gameCenterEnabledVersionCompatibleVersionsLinkagesRequest: GameCenterEnabledVersionCompatibleVersionsLinkagesRequest, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.gameCenterEnabledVersionsCompatibleVersionsCreateToManyRelationshipWithHttpInfo(id, gameCenterEnabledVersionCompatibleVersionsLinkagesRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterEnabledVersionCompatibleVersionsLinkagesRequest List of related linkages
     */
    public gameCenterEnabledVersionsCompatibleVersionsCreateToManyRelationship(id: string, gameCenterEnabledVersionCompatibleVersionsLinkagesRequest: GameCenterEnabledVersionCompatibleVersionsLinkagesRequest, _options?: Configuration): Promise<void> {
        const result = this.api.gameCenterEnabledVersionsCompatibleVersionsCreateToManyRelationship(id, gameCenterEnabledVersionCompatibleVersionsLinkagesRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterEnabledVersionCompatibleVersionsLinkagesRequest List of related linkages
     */
    public gameCenterEnabledVersionsCompatibleVersionsDeleteToManyRelationshipWithHttpInfo(id: string, gameCenterEnabledVersionCompatibleVersionsLinkagesRequest: GameCenterEnabledVersionCompatibleVersionsLinkagesRequest, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.gameCenterEnabledVersionsCompatibleVersionsDeleteToManyRelationshipWithHttpInfo(id, gameCenterEnabledVersionCompatibleVersionsLinkagesRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterEnabledVersionCompatibleVersionsLinkagesRequest List of related linkages
     */
    public gameCenterEnabledVersionsCompatibleVersionsDeleteToManyRelationship(id: string, gameCenterEnabledVersionCompatibleVersionsLinkagesRequest: GameCenterEnabledVersionCompatibleVersionsLinkagesRequest, _options?: Configuration): Promise<void> {
        const result = this.api.gameCenterEnabledVersionsCompatibleVersionsDeleteToManyRelationship(id, gameCenterEnabledVersionCompatibleVersionsLinkagesRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterPlatform filter by attribute \&#39;platform\&#39;
     * @param filterVersionString filter by attribute \&#39;versionString\&#39;
     * @param filterApp filter by id(s) of related \&#39;app\&#39;
     * @param filterId filter by id(s)
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsGameCenterEnabledVersions the fields to include for returned resources of type gameCenterEnabledVersions
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param limit maximum resources per page
     * @param limitCompatibleVersions maximum number of related compatibleVersions returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public gameCenterEnabledVersionsCompatibleVersionsGetToManyRelatedWithHttpInfo(id: string, filterPlatform?: Array<'IOS' | 'MAC_OS' | 'TV_OS' | 'VISION_OS'>, filterVersionString?: Array<string>, filterApp?: Array<string>, filterId?: Array<string>, sort?: Array<'versionString' | '-versionString'>, fieldsGameCenterEnabledVersions?: Array<'app' | 'compatibleVersions' | 'iconAsset' | 'platform' | 'versionString'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, limit?: number, limitCompatibleVersions?: number, include?: Array<'app' | 'compatibleVersions'>, _options?: Configuration): Promise<HttpInfo<GameCenterEnabledVersionsResponse>> {
        const result = this.api.gameCenterEnabledVersionsCompatibleVersionsGetToManyRelatedWithHttpInfo(id, filterPlatform, filterVersionString, filterApp, filterId, sort, fieldsGameCenterEnabledVersions, fieldsApps, limit, limitCompatibleVersions, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterPlatform filter by attribute \&#39;platform\&#39;
     * @param filterVersionString filter by attribute \&#39;versionString\&#39;
     * @param filterApp filter by id(s) of related \&#39;app\&#39;
     * @param filterId filter by id(s)
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsGameCenterEnabledVersions the fields to include for returned resources of type gameCenterEnabledVersions
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param limit maximum resources per page
     * @param limitCompatibleVersions maximum number of related compatibleVersions returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public gameCenterEnabledVersionsCompatibleVersionsGetToManyRelated(id: string, filterPlatform?: Array<'IOS' | 'MAC_OS' | 'TV_OS' | 'VISION_OS'>, filterVersionString?: Array<string>, filterApp?: Array<string>, filterId?: Array<string>, sort?: Array<'versionString' | '-versionString'>, fieldsGameCenterEnabledVersions?: Array<'app' | 'compatibleVersions' | 'iconAsset' | 'platform' | 'versionString'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, limit?: number, limitCompatibleVersions?: number, include?: Array<'app' | 'compatibleVersions'>, _options?: Configuration): Promise<GameCenterEnabledVersionsResponse> {
        const result = this.api.gameCenterEnabledVersionsCompatibleVersionsGetToManyRelated(id, filterPlatform, filterVersionString, filterApp, filterId, sort, fieldsGameCenterEnabledVersions, fieldsApps, limit, limitCompatibleVersions, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public gameCenterEnabledVersionsCompatibleVersionsGetToManyRelationshipWithHttpInfo(id: string, limit?: number, _options?: Configuration): Promise<HttpInfo<GameCenterEnabledVersionCompatibleVersionsLinkagesResponse>> {
        const result = this.api.gameCenterEnabledVersionsCompatibleVersionsGetToManyRelationshipWithHttpInfo(id, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public gameCenterEnabledVersionsCompatibleVersionsGetToManyRelationship(id: string, limit?: number, _options?: Configuration): Promise<GameCenterEnabledVersionCompatibleVersionsLinkagesResponse> {
        const result = this.api.gameCenterEnabledVersionsCompatibleVersionsGetToManyRelationship(id, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterEnabledVersionCompatibleVersionsLinkagesRequest List of related linkages
     */
    public gameCenterEnabledVersionsCompatibleVersionsReplaceToManyRelationshipWithHttpInfo(id: string, gameCenterEnabledVersionCompatibleVersionsLinkagesRequest: GameCenterEnabledVersionCompatibleVersionsLinkagesRequest, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.gameCenterEnabledVersionsCompatibleVersionsReplaceToManyRelationshipWithHttpInfo(id, gameCenterEnabledVersionCompatibleVersionsLinkagesRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterEnabledVersionCompatibleVersionsLinkagesRequest List of related linkages
     */
    public gameCenterEnabledVersionsCompatibleVersionsReplaceToManyRelationship(id: string, gameCenterEnabledVersionCompatibleVersionsLinkagesRequest: GameCenterEnabledVersionCompatibleVersionsLinkagesRequest, _options?: Configuration): Promise<void> {
        const result = this.api.gameCenterEnabledVersionsCompatibleVersionsReplaceToManyRelationship(id, gameCenterEnabledVersionCompatibleVersionsLinkagesRequest, _options);
        return result.toPromise();
    }


}



import { ObservableGameCenterGroupsApi } from './ObservableAPI.ts';

import { GameCenterGroupsApiRequestFactory, GameCenterGroupsApiResponseProcessor} from "../apis/GameCenterGroupsApi.ts";
export class PromiseGameCenterGroupsApi {
    private api: ObservableGameCenterGroupsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: GameCenterGroupsApiRequestFactory,
        responseProcessor?: GameCenterGroupsApiResponseProcessor
    ) {
        this.api = new ObservableGameCenterGroupsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param gameCenterGroupCreateRequest GameCenterGroup representation
     */
    public gameCenterGroupsCreateInstanceWithHttpInfo(gameCenterGroupCreateRequest: GameCenterGroupCreateRequest, _options?: Configuration): Promise<HttpInfo<GameCenterGroupResponse>> {
        const result = this.api.gameCenterGroupsCreateInstanceWithHttpInfo(gameCenterGroupCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param gameCenterGroupCreateRequest GameCenterGroup representation
     */
    public gameCenterGroupsCreateInstance(gameCenterGroupCreateRequest: GameCenterGroupCreateRequest, _options?: Configuration): Promise<GameCenterGroupResponse> {
        const result = this.api.gameCenterGroupsCreateInstance(gameCenterGroupCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterGroupsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.gameCenterGroupsDeleteInstanceWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterGroupsDeleteInstance(id: string, _options?: Configuration): Promise<void> {
        const result = this.api.gameCenterGroupsDeleteInstance(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterArchived filter by attribute \&#39;archived\&#39;
     * @param filterReferenceName filter by attribute \&#39;referenceName\&#39;
     * @param filterId filter by id(s)
     * @param fieldsGameCenterAchievementReleases the fields to include for returned resources of type gameCenterAchievementReleases
     * @param fieldsGameCenterGroups the fields to include for returned resources of type gameCenterGroups
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterAchievementLocalizations the fields to include for returned resources of type gameCenterAchievementLocalizations
     * @param fieldsGameCenterAchievements the fields to include for returned resources of type gameCenterAchievements
     * @param limit maximum resources per page
     * @param limitLocalizations maximum number of related localizations returned (when they are included)
     * @param limitReleases maximum number of related releases returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public gameCenterGroupsGameCenterAchievementsGetToManyRelatedWithHttpInfo(id: string, filterArchived?: Array<string>, filterReferenceName?: Array<string>, filterId?: Array<string>, fieldsGameCenterAchievementReleases?: Array<'gameCenterAchievement' | 'gameCenterDetail' | 'live'>, fieldsGameCenterGroups?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'referenceName'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterAchievementLocalizations?: Array<'afterEarnedDescription' | 'beforeEarnedDescription' | 'gameCenterAchievement' | 'gameCenterAchievementImage' | 'locale' | 'name'>, fieldsGameCenterAchievements?: Array<'archived' | 'gameCenterDetail' | 'gameCenterGroup' | 'groupAchievement' | 'localizations' | 'points' | 'referenceName' | 'releases' | 'repeatable' | 'showBeforeEarned' | 'vendorIdentifier'>, limit?: number, limitLocalizations?: number, limitReleases?: number, include?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'groupAchievement' | 'localizations' | 'releases'>, _options?: Configuration): Promise<HttpInfo<GameCenterAchievementsResponse>> {
        const result = this.api.gameCenterGroupsGameCenterAchievementsGetToManyRelatedWithHttpInfo(id, filterArchived, filterReferenceName, filterId, fieldsGameCenterAchievementReleases, fieldsGameCenterGroups, fieldsGameCenterDetails, fieldsGameCenterAchievementLocalizations, fieldsGameCenterAchievements, limit, limitLocalizations, limitReleases, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterArchived filter by attribute \&#39;archived\&#39;
     * @param filterReferenceName filter by attribute \&#39;referenceName\&#39;
     * @param filterId filter by id(s)
     * @param fieldsGameCenterAchievementReleases the fields to include for returned resources of type gameCenterAchievementReleases
     * @param fieldsGameCenterGroups the fields to include for returned resources of type gameCenterGroups
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterAchievementLocalizations the fields to include for returned resources of type gameCenterAchievementLocalizations
     * @param fieldsGameCenterAchievements the fields to include for returned resources of type gameCenterAchievements
     * @param limit maximum resources per page
     * @param limitLocalizations maximum number of related localizations returned (when they are included)
     * @param limitReleases maximum number of related releases returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public gameCenterGroupsGameCenterAchievementsGetToManyRelated(id: string, filterArchived?: Array<string>, filterReferenceName?: Array<string>, filterId?: Array<string>, fieldsGameCenterAchievementReleases?: Array<'gameCenterAchievement' | 'gameCenterDetail' | 'live'>, fieldsGameCenterGroups?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'referenceName'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterAchievementLocalizations?: Array<'afterEarnedDescription' | 'beforeEarnedDescription' | 'gameCenterAchievement' | 'gameCenterAchievementImage' | 'locale' | 'name'>, fieldsGameCenterAchievements?: Array<'archived' | 'gameCenterDetail' | 'gameCenterGroup' | 'groupAchievement' | 'localizations' | 'points' | 'referenceName' | 'releases' | 'repeatable' | 'showBeforeEarned' | 'vendorIdentifier'>, limit?: number, limitLocalizations?: number, limitReleases?: number, include?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'groupAchievement' | 'localizations' | 'releases'>, _options?: Configuration): Promise<GameCenterAchievementsResponse> {
        const result = this.api.gameCenterGroupsGameCenterAchievementsGetToManyRelated(id, filterArchived, filterReferenceName, filterId, fieldsGameCenterAchievementReleases, fieldsGameCenterGroups, fieldsGameCenterDetails, fieldsGameCenterAchievementLocalizations, fieldsGameCenterAchievements, limit, limitLocalizations, limitReleases, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public gameCenterGroupsGameCenterAchievementsGetToManyRelationshipWithHttpInfo(id: string, limit?: number, _options?: Configuration): Promise<HttpInfo<GameCenterGroupGameCenterAchievementsLinkagesResponse>> {
        const result = this.api.gameCenterGroupsGameCenterAchievementsGetToManyRelationshipWithHttpInfo(id, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public gameCenterGroupsGameCenterAchievementsGetToManyRelationship(id: string, limit?: number, _options?: Configuration): Promise<GameCenterGroupGameCenterAchievementsLinkagesResponse> {
        const result = this.api.gameCenterGroupsGameCenterAchievementsGetToManyRelationship(id, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterGroupGameCenterAchievementsLinkagesRequest List of related linkages
     */
    public gameCenterGroupsGameCenterAchievementsReplaceToManyRelationshipWithHttpInfo(id: string, gameCenterGroupGameCenterAchievementsLinkagesRequest: GameCenterGroupGameCenterAchievementsLinkagesRequest, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.gameCenterGroupsGameCenterAchievementsReplaceToManyRelationshipWithHttpInfo(id, gameCenterGroupGameCenterAchievementsLinkagesRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterGroupGameCenterAchievementsLinkagesRequest List of related linkages
     */
    public gameCenterGroupsGameCenterAchievementsReplaceToManyRelationship(id: string, gameCenterGroupGameCenterAchievementsLinkagesRequest: GameCenterGroupGameCenterAchievementsLinkagesRequest, _options?: Configuration): Promise<void> {
        const result = this.api.gameCenterGroupsGameCenterAchievementsReplaceToManyRelationship(id, gameCenterGroupGameCenterAchievementsLinkagesRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterGameCenterAppVersionsEnabled filter by attribute \&#39;gameCenterAppVersions.enabled\&#39;
     * @param fieldsGameCenterAchievementReleases the fields to include for returned resources of type gameCenterAchievementReleases
     * @param fieldsGameCenterLeaderboardSetReleases the fields to include for returned resources of type gameCenterLeaderboardSetReleases
     * @param fieldsGameCenterLeaderboardSets the fields to include for returned resources of type gameCenterLeaderboardSets
     * @param fieldsGameCenterGroups the fields to include for returned resources of type gameCenterGroups
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     * @param fieldsGameCenterAppVersions the fields to include for returned resources of type gameCenterAppVersions
     * @param fieldsGameCenterAchievements the fields to include for returned resources of type gameCenterAchievements
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsGameCenterLeaderboardReleases the fields to include for returned resources of type gameCenterLeaderboardReleases
     * @param limit maximum resources per page
     * @param limitGameCenterAppVersions maximum number of related gameCenterAppVersions returned (when they are included)
     * @param limitGameCenterLeaderboards maximum number of related gameCenterLeaderboards returned (when they are included)
     * @param limitGameCenterLeaderboardSets maximum number of related gameCenterLeaderboardSets returned (when they are included)
     * @param limitGameCenterAchievements maximum number of related gameCenterAchievements returned (when they are included)
     * @param limitAchievementReleases maximum number of related achievementReleases returned (when they are included)
     * @param limitLeaderboardReleases maximum number of related leaderboardReleases returned (when they are included)
     * @param limitLeaderboardSetReleases maximum number of related leaderboardSetReleases returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public gameCenterGroupsGameCenterDetailsGetToManyRelatedWithHttpInfo(id: string, filterGameCenterAppVersionsEnabled?: Array<string>, fieldsGameCenterAchievementReleases?: Array<'gameCenterAchievement' | 'gameCenterDetail' | 'live'>, fieldsGameCenterLeaderboardSetReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboardSet' | 'live'>, fieldsGameCenterLeaderboardSets?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'referenceName' | 'releases' | 'vendorIdentifier'>, fieldsGameCenterGroups?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'referenceName'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, fieldsGameCenterAppVersions?: Array<'appStoreVersion' | 'compatibilityVersions' | 'enabled'>, fieldsGameCenterAchievements?: Array<'archived' | 'gameCenterDetail' | 'gameCenterGroup' | 'groupAchievement' | 'localizations' | 'points' | 'referenceName' | 'releases' | 'repeatable' | 'showBeforeEarned' | 'vendorIdentifier'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsGameCenterLeaderboardReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboard' | 'live'>, limit?: number, limitGameCenterAppVersions?: number, limitGameCenterLeaderboards?: number, limitGameCenterLeaderboardSets?: number, limitGameCenterAchievements?: number, limitAchievementReleases?: number, limitLeaderboardReleases?: number, limitLeaderboardSetReleases?: number, include?: Array<'achievementReleases' | 'app' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, _options?: Configuration): Promise<HttpInfo<GameCenterDetailsResponse>> {
        const result = this.api.gameCenterGroupsGameCenterDetailsGetToManyRelatedWithHttpInfo(id, filterGameCenterAppVersionsEnabled, fieldsGameCenterAchievementReleases, fieldsGameCenterLeaderboardSetReleases, fieldsGameCenterLeaderboardSets, fieldsGameCenterGroups, fieldsGameCenterDetails, fieldsGameCenterLeaderboards, fieldsGameCenterAppVersions, fieldsGameCenterAchievements, fieldsApps, fieldsGameCenterLeaderboardReleases, limit, limitGameCenterAppVersions, limitGameCenterLeaderboards, limitGameCenterLeaderboardSets, limitGameCenterAchievements, limitAchievementReleases, limitLeaderboardReleases, limitLeaderboardSetReleases, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterGameCenterAppVersionsEnabled filter by attribute \&#39;gameCenterAppVersions.enabled\&#39;
     * @param fieldsGameCenterAchievementReleases the fields to include for returned resources of type gameCenterAchievementReleases
     * @param fieldsGameCenterLeaderboardSetReleases the fields to include for returned resources of type gameCenterLeaderboardSetReleases
     * @param fieldsGameCenterLeaderboardSets the fields to include for returned resources of type gameCenterLeaderboardSets
     * @param fieldsGameCenterGroups the fields to include for returned resources of type gameCenterGroups
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     * @param fieldsGameCenterAppVersions the fields to include for returned resources of type gameCenterAppVersions
     * @param fieldsGameCenterAchievements the fields to include for returned resources of type gameCenterAchievements
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsGameCenterLeaderboardReleases the fields to include for returned resources of type gameCenterLeaderboardReleases
     * @param limit maximum resources per page
     * @param limitGameCenterAppVersions maximum number of related gameCenterAppVersions returned (when they are included)
     * @param limitGameCenterLeaderboards maximum number of related gameCenterLeaderboards returned (when they are included)
     * @param limitGameCenterLeaderboardSets maximum number of related gameCenterLeaderboardSets returned (when they are included)
     * @param limitGameCenterAchievements maximum number of related gameCenterAchievements returned (when they are included)
     * @param limitAchievementReleases maximum number of related achievementReleases returned (when they are included)
     * @param limitLeaderboardReleases maximum number of related leaderboardReleases returned (when they are included)
     * @param limitLeaderboardSetReleases maximum number of related leaderboardSetReleases returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public gameCenterGroupsGameCenterDetailsGetToManyRelated(id: string, filterGameCenterAppVersionsEnabled?: Array<string>, fieldsGameCenterAchievementReleases?: Array<'gameCenterAchievement' | 'gameCenterDetail' | 'live'>, fieldsGameCenterLeaderboardSetReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboardSet' | 'live'>, fieldsGameCenterLeaderboardSets?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'referenceName' | 'releases' | 'vendorIdentifier'>, fieldsGameCenterGroups?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'referenceName'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, fieldsGameCenterAppVersions?: Array<'appStoreVersion' | 'compatibilityVersions' | 'enabled'>, fieldsGameCenterAchievements?: Array<'archived' | 'gameCenterDetail' | 'gameCenterGroup' | 'groupAchievement' | 'localizations' | 'points' | 'referenceName' | 'releases' | 'repeatable' | 'showBeforeEarned' | 'vendorIdentifier'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsGameCenterLeaderboardReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboard' | 'live'>, limit?: number, limitGameCenterAppVersions?: number, limitGameCenterLeaderboards?: number, limitGameCenterLeaderboardSets?: number, limitGameCenterAchievements?: number, limitAchievementReleases?: number, limitLeaderboardReleases?: number, limitLeaderboardSetReleases?: number, include?: Array<'achievementReleases' | 'app' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, _options?: Configuration): Promise<GameCenterDetailsResponse> {
        const result = this.api.gameCenterGroupsGameCenterDetailsGetToManyRelated(id, filterGameCenterAppVersionsEnabled, fieldsGameCenterAchievementReleases, fieldsGameCenterLeaderboardSetReleases, fieldsGameCenterLeaderboardSets, fieldsGameCenterGroups, fieldsGameCenterDetails, fieldsGameCenterLeaderboards, fieldsGameCenterAppVersions, fieldsGameCenterAchievements, fieldsApps, fieldsGameCenterLeaderboardReleases, limit, limitGameCenterAppVersions, limitGameCenterLeaderboards, limitGameCenterLeaderboardSets, limitGameCenterAchievements, limitAchievementReleases, limitLeaderboardReleases, limitLeaderboardSetReleases, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterReferenceName filter by attribute \&#39;referenceName\&#39;
     * @param filterId filter by id(s)
     * @param fieldsGameCenterLeaderboardSetLocalizations the fields to include for returned resources of type gameCenterLeaderboardSetLocalizations
     * @param fieldsGameCenterLeaderboardSetReleases the fields to include for returned resources of type gameCenterLeaderboardSetReleases
     * @param fieldsGameCenterLeaderboardSets the fields to include for returned resources of type gameCenterLeaderboardSets
     * @param fieldsGameCenterGroups the fields to include for returned resources of type gameCenterGroups
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     * @param limit maximum resources per page
     * @param limitLocalizations maximum number of related localizations returned (when they are included)
     * @param limitGameCenterLeaderboards maximum number of related gameCenterLeaderboards returned (when they are included)
     * @param limitReleases maximum number of related releases returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public gameCenterGroupsGameCenterLeaderboardSetsGetToManyRelatedWithHttpInfo(id: string, filterReferenceName?: Array<string>, filterId?: Array<string>, fieldsGameCenterLeaderboardSetLocalizations?: Array<'gameCenterLeaderboardSet' | 'gameCenterLeaderboardSetImage' | 'locale' | 'name'>, fieldsGameCenterLeaderboardSetReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboardSet' | 'live'>, fieldsGameCenterLeaderboardSets?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'referenceName' | 'releases' | 'vendorIdentifier'>, fieldsGameCenterGroups?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'referenceName'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, limit?: number, limitLocalizations?: number, limitGameCenterLeaderboards?: number, limitReleases?: number, include?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'releases'>, _options?: Configuration): Promise<HttpInfo<GameCenterLeaderboardSetsResponse>> {
        const result = this.api.gameCenterGroupsGameCenterLeaderboardSetsGetToManyRelatedWithHttpInfo(id, filterReferenceName, filterId, fieldsGameCenterLeaderboardSetLocalizations, fieldsGameCenterLeaderboardSetReleases, fieldsGameCenterLeaderboardSets, fieldsGameCenterGroups, fieldsGameCenterDetails, fieldsGameCenterLeaderboards, limit, limitLocalizations, limitGameCenterLeaderboards, limitReleases, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterReferenceName filter by attribute \&#39;referenceName\&#39;
     * @param filterId filter by id(s)
     * @param fieldsGameCenterLeaderboardSetLocalizations the fields to include for returned resources of type gameCenterLeaderboardSetLocalizations
     * @param fieldsGameCenterLeaderboardSetReleases the fields to include for returned resources of type gameCenterLeaderboardSetReleases
     * @param fieldsGameCenterLeaderboardSets the fields to include for returned resources of type gameCenterLeaderboardSets
     * @param fieldsGameCenterGroups the fields to include for returned resources of type gameCenterGroups
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     * @param limit maximum resources per page
     * @param limitLocalizations maximum number of related localizations returned (when they are included)
     * @param limitGameCenterLeaderboards maximum number of related gameCenterLeaderboards returned (when they are included)
     * @param limitReleases maximum number of related releases returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public gameCenterGroupsGameCenterLeaderboardSetsGetToManyRelated(id: string, filterReferenceName?: Array<string>, filterId?: Array<string>, fieldsGameCenterLeaderboardSetLocalizations?: Array<'gameCenterLeaderboardSet' | 'gameCenterLeaderboardSetImage' | 'locale' | 'name'>, fieldsGameCenterLeaderboardSetReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboardSet' | 'live'>, fieldsGameCenterLeaderboardSets?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'referenceName' | 'releases' | 'vendorIdentifier'>, fieldsGameCenterGroups?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'referenceName'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, limit?: number, limitLocalizations?: number, limitGameCenterLeaderboards?: number, limitReleases?: number, include?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'releases'>, _options?: Configuration): Promise<GameCenterLeaderboardSetsResponse> {
        const result = this.api.gameCenterGroupsGameCenterLeaderboardSetsGetToManyRelated(id, filterReferenceName, filterId, fieldsGameCenterLeaderboardSetLocalizations, fieldsGameCenterLeaderboardSetReleases, fieldsGameCenterLeaderboardSets, fieldsGameCenterGroups, fieldsGameCenterDetails, fieldsGameCenterLeaderboards, limit, limitLocalizations, limitGameCenterLeaderboards, limitReleases, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public gameCenterGroupsGameCenterLeaderboardSetsGetToManyRelationshipWithHttpInfo(id: string, limit?: number, _options?: Configuration): Promise<HttpInfo<GameCenterGroupGameCenterLeaderboardSetsLinkagesResponse>> {
        const result = this.api.gameCenterGroupsGameCenterLeaderboardSetsGetToManyRelationshipWithHttpInfo(id, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public gameCenterGroupsGameCenterLeaderboardSetsGetToManyRelationship(id: string, limit?: number, _options?: Configuration): Promise<GameCenterGroupGameCenterLeaderboardSetsLinkagesResponse> {
        const result = this.api.gameCenterGroupsGameCenterLeaderboardSetsGetToManyRelationship(id, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterGroupGameCenterLeaderboardSetsLinkagesRequest List of related linkages
     */
    public gameCenterGroupsGameCenterLeaderboardSetsReplaceToManyRelationshipWithHttpInfo(id: string, gameCenterGroupGameCenterLeaderboardSetsLinkagesRequest: GameCenterGroupGameCenterLeaderboardSetsLinkagesRequest, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.gameCenterGroupsGameCenterLeaderboardSetsReplaceToManyRelationshipWithHttpInfo(id, gameCenterGroupGameCenterLeaderboardSetsLinkagesRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterGroupGameCenterLeaderboardSetsLinkagesRequest List of related linkages
     */
    public gameCenterGroupsGameCenterLeaderboardSetsReplaceToManyRelationship(id: string, gameCenterGroupGameCenterLeaderboardSetsLinkagesRequest: GameCenterGroupGameCenterLeaderboardSetsLinkagesRequest, _options?: Configuration): Promise<void> {
        const result = this.api.gameCenterGroupsGameCenterLeaderboardSetsReplaceToManyRelationship(id, gameCenterGroupGameCenterLeaderboardSetsLinkagesRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterArchived filter by attribute \&#39;archived\&#39;
     * @param filterReferenceName filter by attribute \&#39;referenceName\&#39;
     * @param filterId filter by id(s)
     * @param fieldsGameCenterLeaderboardLocalizations the fields to include for returned resources of type gameCenterLeaderboardLocalizations
     * @param fieldsGameCenterLeaderboardSets the fields to include for returned resources of type gameCenterLeaderboardSets
     * @param fieldsGameCenterGroups the fields to include for returned resources of type gameCenterGroups
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     * @param fieldsGameCenterLeaderboardReleases the fields to include for returned resources of type gameCenterLeaderboardReleases
     * @param limit maximum resources per page
     * @param limitGameCenterLeaderboardSets maximum number of related gameCenterLeaderboardSets returned (when they are included)
     * @param limitLocalizations maximum number of related localizations returned (when they are included)
     * @param limitReleases maximum number of related releases returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public gameCenterGroupsGameCenterLeaderboardsGetToManyRelatedWithHttpInfo(id: string, filterArchived?: Array<string>, filterReferenceName?: Array<string>, filterId?: Array<string>, fieldsGameCenterLeaderboardLocalizations?: Array<'formatterOverride' | 'formatterSuffix' | 'formatterSuffixSingular' | 'gameCenterLeaderboard' | 'gameCenterLeaderboardImage' | 'locale' | 'name'>, fieldsGameCenterLeaderboardSets?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'referenceName' | 'releases' | 'vendorIdentifier'>, fieldsGameCenterGroups?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'referenceName'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, fieldsGameCenterLeaderboardReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboard' | 'live'>, limit?: number, limitGameCenterLeaderboardSets?: number, limitLocalizations?: number, limitReleases?: number, include?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'releases'>, _options?: Configuration): Promise<HttpInfo<GameCenterLeaderboardsResponse>> {
        const result = this.api.gameCenterGroupsGameCenterLeaderboardsGetToManyRelatedWithHttpInfo(id, filterArchived, filterReferenceName, filterId, fieldsGameCenterLeaderboardLocalizations, fieldsGameCenterLeaderboardSets, fieldsGameCenterGroups, fieldsGameCenterDetails, fieldsGameCenterLeaderboards, fieldsGameCenterLeaderboardReleases, limit, limitGameCenterLeaderboardSets, limitLocalizations, limitReleases, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterArchived filter by attribute \&#39;archived\&#39;
     * @param filterReferenceName filter by attribute \&#39;referenceName\&#39;
     * @param filterId filter by id(s)
     * @param fieldsGameCenterLeaderboardLocalizations the fields to include for returned resources of type gameCenterLeaderboardLocalizations
     * @param fieldsGameCenterLeaderboardSets the fields to include for returned resources of type gameCenterLeaderboardSets
     * @param fieldsGameCenterGroups the fields to include for returned resources of type gameCenterGroups
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     * @param fieldsGameCenterLeaderboardReleases the fields to include for returned resources of type gameCenterLeaderboardReleases
     * @param limit maximum resources per page
     * @param limitGameCenterLeaderboardSets maximum number of related gameCenterLeaderboardSets returned (when they are included)
     * @param limitLocalizations maximum number of related localizations returned (when they are included)
     * @param limitReleases maximum number of related releases returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public gameCenterGroupsGameCenterLeaderboardsGetToManyRelated(id: string, filterArchived?: Array<string>, filterReferenceName?: Array<string>, filterId?: Array<string>, fieldsGameCenterLeaderboardLocalizations?: Array<'formatterOverride' | 'formatterSuffix' | 'formatterSuffixSingular' | 'gameCenterLeaderboard' | 'gameCenterLeaderboardImage' | 'locale' | 'name'>, fieldsGameCenterLeaderboardSets?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'referenceName' | 'releases' | 'vendorIdentifier'>, fieldsGameCenterGroups?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'referenceName'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, fieldsGameCenterLeaderboardReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboard' | 'live'>, limit?: number, limitGameCenterLeaderboardSets?: number, limitLocalizations?: number, limitReleases?: number, include?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'releases'>, _options?: Configuration): Promise<GameCenterLeaderboardsResponse> {
        const result = this.api.gameCenterGroupsGameCenterLeaderboardsGetToManyRelated(id, filterArchived, filterReferenceName, filterId, fieldsGameCenterLeaderboardLocalizations, fieldsGameCenterLeaderboardSets, fieldsGameCenterGroups, fieldsGameCenterDetails, fieldsGameCenterLeaderboards, fieldsGameCenterLeaderboardReleases, limit, limitGameCenterLeaderboardSets, limitLocalizations, limitReleases, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public gameCenterGroupsGameCenterLeaderboardsGetToManyRelationshipWithHttpInfo(id: string, limit?: number, _options?: Configuration): Promise<HttpInfo<GameCenterGroupGameCenterLeaderboardsLinkagesResponse>> {
        const result = this.api.gameCenterGroupsGameCenterLeaderboardsGetToManyRelationshipWithHttpInfo(id, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public gameCenterGroupsGameCenterLeaderboardsGetToManyRelationship(id: string, limit?: number, _options?: Configuration): Promise<GameCenterGroupGameCenterLeaderboardsLinkagesResponse> {
        const result = this.api.gameCenterGroupsGameCenterLeaderboardsGetToManyRelationship(id, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterGroupGameCenterLeaderboardsLinkagesRequest List of related linkages
     */
    public gameCenterGroupsGameCenterLeaderboardsReplaceToManyRelationshipWithHttpInfo(id: string, gameCenterGroupGameCenterLeaderboardsLinkagesRequest: GameCenterGroupGameCenterLeaderboardsLinkagesRequest, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.gameCenterGroupsGameCenterLeaderboardsReplaceToManyRelationshipWithHttpInfo(id, gameCenterGroupGameCenterLeaderboardsLinkagesRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterGroupGameCenterLeaderboardsLinkagesRequest List of related linkages
     */
    public gameCenterGroupsGameCenterLeaderboardsReplaceToManyRelationship(id: string, gameCenterGroupGameCenterLeaderboardsLinkagesRequest: GameCenterGroupGameCenterLeaderboardsLinkagesRequest, _options?: Configuration): Promise<void> {
        const result = this.api.gameCenterGroupsGameCenterLeaderboardsReplaceToManyRelationship(id, gameCenterGroupGameCenterLeaderboardsLinkagesRequest, _options);
        return result.toPromise();
    }

    /**
     * @param filterGameCenterDetails filter by id(s) of related \&#39;gameCenterDetails\&#39;
     * @param fieldsGameCenterGroups the fields to include for returned resources of type gameCenterGroups
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsGameCenterLeaderboardSets the fields to include for returned resources of type gameCenterLeaderboardSets
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     * @param fieldsGameCenterAchievements the fields to include for returned resources of type gameCenterAchievements
     * @param limitGameCenterAchievements maximum number of related gameCenterAchievements returned (when they are included)
     * @param limitGameCenterDetails maximum number of related gameCenterDetails returned (when they are included)
     * @param limitGameCenterLeaderboardSets maximum number of related gameCenterLeaderboardSets returned (when they are included)
     * @param limitGameCenterLeaderboards maximum number of related gameCenterLeaderboards returned (when they are included)
     */
    public gameCenterGroupsGetCollectionWithHttpInfo(filterGameCenterDetails?: Array<string>, fieldsGameCenterGroups?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'referenceName'>, limit?: number, include?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards'>, fieldsGameCenterLeaderboardSets?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'referenceName' | 'releases' | 'vendorIdentifier'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, fieldsGameCenterAchievements?: Array<'archived' | 'gameCenterDetail' | 'gameCenterGroup' | 'groupAchievement' | 'localizations' | 'points' | 'referenceName' | 'releases' | 'repeatable' | 'showBeforeEarned' | 'vendorIdentifier'>, limitGameCenterAchievements?: number, limitGameCenterDetails?: number, limitGameCenterLeaderboardSets?: number, limitGameCenterLeaderboards?: number, _options?: Configuration): Promise<HttpInfo<GameCenterGroupsResponse>> {
        const result = this.api.gameCenterGroupsGetCollectionWithHttpInfo(filterGameCenterDetails, fieldsGameCenterGroups, limit, include, fieldsGameCenterLeaderboardSets, fieldsGameCenterDetails, fieldsGameCenterLeaderboards, fieldsGameCenterAchievements, limitGameCenterAchievements, limitGameCenterDetails, limitGameCenterLeaderboardSets, limitGameCenterLeaderboards, _options);
        return result.toPromise();
    }

    /**
     * @param filterGameCenterDetails filter by id(s) of related \&#39;gameCenterDetails\&#39;
     * @param fieldsGameCenterGroups the fields to include for returned resources of type gameCenterGroups
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsGameCenterLeaderboardSets the fields to include for returned resources of type gameCenterLeaderboardSets
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     * @param fieldsGameCenterAchievements the fields to include for returned resources of type gameCenterAchievements
     * @param limitGameCenterAchievements maximum number of related gameCenterAchievements returned (when they are included)
     * @param limitGameCenterDetails maximum number of related gameCenterDetails returned (when they are included)
     * @param limitGameCenterLeaderboardSets maximum number of related gameCenterLeaderboardSets returned (when they are included)
     * @param limitGameCenterLeaderboards maximum number of related gameCenterLeaderboards returned (when they are included)
     */
    public gameCenterGroupsGetCollection(filterGameCenterDetails?: Array<string>, fieldsGameCenterGroups?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'referenceName'>, limit?: number, include?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards'>, fieldsGameCenterLeaderboardSets?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'referenceName' | 'releases' | 'vendorIdentifier'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, fieldsGameCenterAchievements?: Array<'archived' | 'gameCenterDetail' | 'gameCenterGroup' | 'groupAchievement' | 'localizations' | 'points' | 'referenceName' | 'releases' | 'repeatable' | 'showBeforeEarned' | 'vendorIdentifier'>, limitGameCenterAchievements?: number, limitGameCenterDetails?: number, limitGameCenterLeaderboardSets?: number, limitGameCenterLeaderboards?: number, _options?: Configuration): Promise<GameCenterGroupsResponse> {
        const result = this.api.gameCenterGroupsGetCollection(filterGameCenterDetails, fieldsGameCenterGroups, limit, include, fieldsGameCenterLeaderboardSets, fieldsGameCenterDetails, fieldsGameCenterLeaderboards, fieldsGameCenterAchievements, limitGameCenterAchievements, limitGameCenterDetails, limitGameCenterLeaderboardSets, limitGameCenterLeaderboards, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterGroups the fields to include for returned resources of type gameCenterGroups
     * @param include comma-separated list of relationships to include
     * @param fieldsGameCenterLeaderboardSets the fields to include for returned resources of type gameCenterLeaderboardSets
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     * @param fieldsGameCenterAchievements the fields to include for returned resources of type gameCenterAchievements
     * @param limitGameCenterAchievements maximum number of related gameCenterAchievements returned (when they are included)
     * @param limitGameCenterDetails maximum number of related gameCenterDetails returned (when they are included)
     * @param limitGameCenterLeaderboardSets maximum number of related gameCenterLeaderboardSets returned (when they are included)
     * @param limitGameCenterLeaderboards maximum number of related gameCenterLeaderboards returned (when they are included)
     */
    public gameCenterGroupsGetInstanceWithHttpInfo(id: string, fieldsGameCenterGroups?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'referenceName'>, include?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards'>, fieldsGameCenterLeaderboardSets?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'referenceName' | 'releases' | 'vendorIdentifier'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, fieldsGameCenterAchievements?: Array<'archived' | 'gameCenterDetail' | 'gameCenterGroup' | 'groupAchievement' | 'localizations' | 'points' | 'referenceName' | 'releases' | 'repeatable' | 'showBeforeEarned' | 'vendorIdentifier'>, limitGameCenterAchievements?: number, limitGameCenterDetails?: number, limitGameCenterLeaderboardSets?: number, limitGameCenterLeaderboards?: number, _options?: Configuration): Promise<HttpInfo<GameCenterGroupResponse>> {
        const result = this.api.gameCenterGroupsGetInstanceWithHttpInfo(id, fieldsGameCenterGroups, include, fieldsGameCenterLeaderboardSets, fieldsGameCenterDetails, fieldsGameCenterLeaderboards, fieldsGameCenterAchievements, limitGameCenterAchievements, limitGameCenterDetails, limitGameCenterLeaderboardSets, limitGameCenterLeaderboards, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterGroups the fields to include for returned resources of type gameCenterGroups
     * @param include comma-separated list of relationships to include
     * @param fieldsGameCenterLeaderboardSets the fields to include for returned resources of type gameCenterLeaderboardSets
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     * @param fieldsGameCenterAchievements the fields to include for returned resources of type gameCenterAchievements
     * @param limitGameCenterAchievements maximum number of related gameCenterAchievements returned (when they are included)
     * @param limitGameCenterDetails maximum number of related gameCenterDetails returned (when they are included)
     * @param limitGameCenterLeaderboardSets maximum number of related gameCenterLeaderboardSets returned (when they are included)
     * @param limitGameCenterLeaderboards maximum number of related gameCenterLeaderboards returned (when they are included)
     */
    public gameCenterGroupsGetInstance(id: string, fieldsGameCenterGroups?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'referenceName'>, include?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards'>, fieldsGameCenterLeaderboardSets?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'referenceName' | 'releases' | 'vendorIdentifier'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, fieldsGameCenterAchievements?: Array<'archived' | 'gameCenterDetail' | 'gameCenterGroup' | 'groupAchievement' | 'localizations' | 'points' | 'referenceName' | 'releases' | 'repeatable' | 'showBeforeEarned' | 'vendorIdentifier'>, limitGameCenterAchievements?: number, limitGameCenterDetails?: number, limitGameCenterLeaderboardSets?: number, limitGameCenterLeaderboards?: number, _options?: Configuration): Promise<GameCenterGroupResponse> {
        const result = this.api.gameCenterGroupsGetInstance(id, fieldsGameCenterGroups, include, fieldsGameCenterLeaderboardSets, fieldsGameCenterDetails, fieldsGameCenterLeaderboards, fieldsGameCenterAchievements, limitGameCenterAchievements, limitGameCenterDetails, limitGameCenterLeaderboardSets, limitGameCenterLeaderboards, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterGroupUpdateRequest GameCenterGroup representation
     */
    public gameCenterGroupsUpdateInstanceWithHttpInfo(id: string, gameCenterGroupUpdateRequest: GameCenterGroupUpdateRequest, _options?: Configuration): Promise<HttpInfo<GameCenterGroupResponse>> {
        const result = this.api.gameCenterGroupsUpdateInstanceWithHttpInfo(id, gameCenterGroupUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterGroupUpdateRequest GameCenterGroup representation
     */
    public gameCenterGroupsUpdateInstance(id: string, gameCenterGroupUpdateRequest: GameCenterGroupUpdateRequest, _options?: Configuration): Promise<GameCenterGroupResponse> {
        const result = this.api.gameCenterGroupsUpdateInstance(id, gameCenterGroupUpdateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableGameCenterLeaderboardEntrySubmissionsApi } from './ObservableAPI.ts';

import { GameCenterLeaderboardEntrySubmissionsApiRequestFactory, GameCenterLeaderboardEntrySubmissionsApiResponseProcessor} from "../apis/GameCenterLeaderboardEntrySubmissionsApi.ts";
export class PromiseGameCenterLeaderboardEntrySubmissionsApi {
    private api: ObservableGameCenterLeaderboardEntrySubmissionsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: GameCenterLeaderboardEntrySubmissionsApiRequestFactory,
        responseProcessor?: GameCenterLeaderboardEntrySubmissionsApiResponseProcessor
    ) {
        this.api = new ObservableGameCenterLeaderboardEntrySubmissionsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param gameCenterLeaderboardEntrySubmissionCreateRequest GameCenterLeaderboardEntrySubmission representation
     */
    public gameCenterLeaderboardEntrySubmissionsCreateInstanceWithHttpInfo(gameCenterLeaderboardEntrySubmissionCreateRequest: GameCenterLeaderboardEntrySubmissionCreateRequest, _options?: Configuration): Promise<HttpInfo<GameCenterLeaderboardEntrySubmissionResponse>> {
        const result = this.api.gameCenterLeaderboardEntrySubmissionsCreateInstanceWithHttpInfo(gameCenterLeaderboardEntrySubmissionCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param gameCenterLeaderboardEntrySubmissionCreateRequest GameCenterLeaderboardEntrySubmission representation
     */
    public gameCenterLeaderboardEntrySubmissionsCreateInstance(gameCenterLeaderboardEntrySubmissionCreateRequest: GameCenterLeaderboardEntrySubmissionCreateRequest, _options?: Configuration): Promise<GameCenterLeaderboardEntrySubmissionResponse> {
        const result = this.api.gameCenterLeaderboardEntrySubmissionsCreateInstance(gameCenterLeaderboardEntrySubmissionCreateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableGameCenterLeaderboardImagesApi } from './ObservableAPI.ts';

import { GameCenterLeaderboardImagesApiRequestFactory, GameCenterLeaderboardImagesApiResponseProcessor} from "../apis/GameCenterLeaderboardImagesApi.ts";
export class PromiseGameCenterLeaderboardImagesApi {
    private api: ObservableGameCenterLeaderboardImagesApi

    public constructor(
        configuration: Configuration,
        requestFactory?: GameCenterLeaderboardImagesApiRequestFactory,
        responseProcessor?: GameCenterLeaderboardImagesApiResponseProcessor
    ) {
        this.api = new ObservableGameCenterLeaderboardImagesApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param gameCenterLeaderboardImageCreateRequest GameCenterLeaderboardImage representation
     */
    public gameCenterLeaderboardImagesCreateInstanceWithHttpInfo(gameCenterLeaderboardImageCreateRequest: GameCenterLeaderboardImageCreateRequest, _options?: Configuration): Promise<HttpInfo<GameCenterLeaderboardImageResponse>> {
        const result = this.api.gameCenterLeaderboardImagesCreateInstanceWithHttpInfo(gameCenterLeaderboardImageCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param gameCenterLeaderboardImageCreateRequest GameCenterLeaderboardImage representation
     */
    public gameCenterLeaderboardImagesCreateInstance(gameCenterLeaderboardImageCreateRequest: GameCenterLeaderboardImageCreateRequest, _options?: Configuration): Promise<GameCenterLeaderboardImageResponse> {
        const result = this.api.gameCenterLeaderboardImagesCreateInstance(gameCenterLeaderboardImageCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterLeaderboardImagesDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.gameCenterLeaderboardImagesDeleteInstanceWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterLeaderboardImagesDeleteInstance(id: string, _options?: Configuration): Promise<void> {
        const result = this.api.gameCenterLeaderboardImagesDeleteInstance(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterLeaderboardImages the fields to include for returned resources of type gameCenterLeaderboardImages
     * @param include comma-separated list of relationships to include
     */
    public gameCenterLeaderboardImagesGetInstanceWithHttpInfo(id: string, fieldsGameCenterLeaderboardImages?: Array<'assetDeliveryState' | 'fileName' | 'fileSize' | 'gameCenterLeaderboardLocalization' | 'imageAsset' | 'uploadOperations' | 'uploaded'>, include?: Array<'gameCenterLeaderboardLocalization'>, _options?: Configuration): Promise<HttpInfo<GameCenterLeaderboardImageResponse>> {
        const result = this.api.gameCenterLeaderboardImagesGetInstanceWithHttpInfo(id, fieldsGameCenterLeaderboardImages, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterLeaderboardImages the fields to include for returned resources of type gameCenterLeaderboardImages
     * @param include comma-separated list of relationships to include
     */
    public gameCenterLeaderboardImagesGetInstance(id: string, fieldsGameCenterLeaderboardImages?: Array<'assetDeliveryState' | 'fileName' | 'fileSize' | 'gameCenterLeaderboardLocalization' | 'imageAsset' | 'uploadOperations' | 'uploaded'>, include?: Array<'gameCenterLeaderboardLocalization'>, _options?: Configuration): Promise<GameCenterLeaderboardImageResponse> {
        const result = this.api.gameCenterLeaderboardImagesGetInstance(id, fieldsGameCenterLeaderboardImages, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterLeaderboardImageUpdateRequest GameCenterLeaderboardImage representation
     */
    public gameCenterLeaderboardImagesUpdateInstanceWithHttpInfo(id: string, gameCenterLeaderboardImageUpdateRequest: GameCenterLeaderboardImageUpdateRequest, _options?: Configuration): Promise<HttpInfo<GameCenterLeaderboardImageResponse>> {
        const result = this.api.gameCenterLeaderboardImagesUpdateInstanceWithHttpInfo(id, gameCenterLeaderboardImageUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterLeaderboardImageUpdateRequest GameCenterLeaderboardImage representation
     */
    public gameCenterLeaderboardImagesUpdateInstance(id: string, gameCenterLeaderboardImageUpdateRequest: GameCenterLeaderboardImageUpdateRequest, _options?: Configuration): Promise<GameCenterLeaderboardImageResponse> {
        const result = this.api.gameCenterLeaderboardImagesUpdateInstance(id, gameCenterLeaderboardImageUpdateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableGameCenterLeaderboardLocalizationsApi } from './ObservableAPI.ts';

import { GameCenterLeaderboardLocalizationsApiRequestFactory, GameCenterLeaderboardLocalizationsApiResponseProcessor} from "../apis/GameCenterLeaderboardLocalizationsApi.ts";
export class PromiseGameCenterLeaderboardLocalizationsApi {
    private api: ObservableGameCenterLeaderboardLocalizationsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: GameCenterLeaderboardLocalizationsApiRequestFactory,
        responseProcessor?: GameCenterLeaderboardLocalizationsApiResponseProcessor
    ) {
        this.api = new ObservableGameCenterLeaderboardLocalizationsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param gameCenterLeaderboardLocalizationCreateRequest GameCenterLeaderboardLocalization representation
     */
    public gameCenterLeaderboardLocalizationsCreateInstanceWithHttpInfo(gameCenterLeaderboardLocalizationCreateRequest: GameCenterLeaderboardLocalizationCreateRequest, _options?: Configuration): Promise<HttpInfo<GameCenterLeaderboardLocalizationResponse>> {
        const result = this.api.gameCenterLeaderboardLocalizationsCreateInstanceWithHttpInfo(gameCenterLeaderboardLocalizationCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param gameCenterLeaderboardLocalizationCreateRequest GameCenterLeaderboardLocalization representation
     */
    public gameCenterLeaderboardLocalizationsCreateInstance(gameCenterLeaderboardLocalizationCreateRequest: GameCenterLeaderboardLocalizationCreateRequest, _options?: Configuration): Promise<GameCenterLeaderboardLocalizationResponse> {
        const result = this.api.gameCenterLeaderboardLocalizationsCreateInstance(gameCenterLeaderboardLocalizationCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterLeaderboardLocalizationsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.gameCenterLeaderboardLocalizationsDeleteInstanceWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterLeaderboardLocalizationsDeleteInstance(id: string, _options?: Configuration): Promise<void> {
        const result = this.api.gameCenterLeaderboardLocalizationsDeleteInstance(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterLeaderboardImages the fields to include for returned resources of type gameCenterLeaderboardImages
     * @param fieldsGameCenterLeaderboardLocalizations the fields to include for returned resources of type gameCenterLeaderboardLocalizations
     * @param include comma-separated list of relationships to include
     */
    public gameCenterLeaderboardLocalizationsGameCenterLeaderboardImageGetToOneRelatedWithHttpInfo(id: string, fieldsGameCenterLeaderboardImages?: Array<'assetDeliveryState' | 'fileName' | 'fileSize' | 'gameCenterLeaderboardLocalization' | 'imageAsset' | 'uploadOperations' | 'uploaded'>, fieldsGameCenterLeaderboardLocalizations?: Array<'formatterOverride' | 'formatterSuffix' | 'formatterSuffixSingular' | 'gameCenterLeaderboard' | 'gameCenterLeaderboardImage' | 'locale' | 'name'>, include?: Array<'gameCenterLeaderboardLocalization'>, _options?: Configuration): Promise<HttpInfo<GameCenterLeaderboardImageResponse>> {
        const result = this.api.gameCenterLeaderboardLocalizationsGameCenterLeaderboardImageGetToOneRelatedWithHttpInfo(id, fieldsGameCenterLeaderboardImages, fieldsGameCenterLeaderboardLocalizations, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterLeaderboardImages the fields to include for returned resources of type gameCenterLeaderboardImages
     * @param fieldsGameCenterLeaderboardLocalizations the fields to include for returned resources of type gameCenterLeaderboardLocalizations
     * @param include comma-separated list of relationships to include
     */
    public gameCenterLeaderboardLocalizationsGameCenterLeaderboardImageGetToOneRelated(id: string, fieldsGameCenterLeaderboardImages?: Array<'assetDeliveryState' | 'fileName' | 'fileSize' | 'gameCenterLeaderboardLocalization' | 'imageAsset' | 'uploadOperations' | 'uploaded'>, fieldsGameCenterLeaderboardLocalizations?: Array<'formatterOverride' | 'formatterSuffix' | 'formatterSuffixSingular' | 'gameCenterLeaderboard' | 'gameCenterLeaderboardImage' | 'locale' | 'name'>, include?: Array<'gameCenterLeaderboardLocalization'>, _options?: Configuration): Promise<GameCenterLeaderboardImageResponse> {
        const result = this.api.gameCenterLeaderboardLocalizationsGameCenterLeaderboardImageGetToOneRelated(id, fieldsGameCenterLeaderboardImages, fieldsGameCenterLeaderboardLocalizations, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterLeaderboardLocalizations the fields to include for returned resources of type gameCenterLeaderboardLocalizations
     * @param include comma-separated list of relationships to include
     * @param fieldsGameCenterLeaderboardImages the fields to include for returned resources of type gameCenterLeaderboardImages
     */
    public gameCenterLeaderboardLocalizationsGetInstanceWithHttpInfo(id: string, fieldsGameCenterLeaderboardLocalizations?: Array<'formatterOverride' | 'formatterSuffix' | 'formatterSuffixSingular' | 'gameCenterLeaderboard' | 'gameCenterLeaderboardImage' | 'locale' | 'name'>, include?: Array<'gameCenterLeaderboard' | 'gameCenterLeaderboardImage'>, fieldsGameCenterLeaderboardImages?: Array<'assetDeliveryState' | 'fileName' | 'fileSize' | 'gameCenterLeaderboardLocalization' | 'imageAsset' | 'uploadOperations' | 'uploaded'>, _options?: Configuration): Promise<HttpInfo<GameCenterLeaderboardLocalizationResponse>> {
        const result = this.api.gameCenterLeaderboardLocalizationsGetInstanceWithHttpInfo(id, fieldsGameCenterLeaderboardLocalizations, include, fieldsGameCenterLeaderboardImages, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterLeaderboardLocalizations the fields to include for returned resources of type gameCenterLeaderboardLocalizations
     * @param include comma-separated list of relationships to include
     * @param fieldsGameCenterLeaderboardImages the fields to include for returned resources of type gameCenterLeaderboardImages
     */
    public gameCenterLeaderboardLocalizationsGetInstance(id: string, fieldsGameCenterLeaderboardLocalizations?: Array<'formatterOverride' | 'formatterSuffix' | 'formatterSuffixSingular' | 'gameCenterLeaderboard' | 'gameCenterLeaderboardImage' | 'locale' | 'name'>, include?: Array<'gameCenterLeaderboard' | 'gameCenterLeaderboardImage'>, fieldsGameCenterLeaderboardImages?: Array<'assetDeliveryState' | 'fileName' | 'fileSize' | 'gameCenterLeaderboardLocalization' | 'imageAsset' | 'uploadOperations' | 'uploaded'>, _options?: Configuration): Promise<GameCenterLeaderboardLocalizationResponse> {
        const result = this.api.gameCenterLeaderboardLocalizationsGetInstance(id, fieldsGameCenterLeaderboardLocalizations, include, fieldsGameCenterLeaderboardImages, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterLeaderboardLocalizationUpdateRequest GameCenterLeaderboardLocalization representation
     */
    public gameCenterLeaderboardLocalizationsUpdateInstanceWithHttpInfo(id: string, gameCenterLeaderboardLocalizationUpdateRequest: GameCenterLeaderboardLocalizationUpdateRequest, _options?: Configuration): Promise<HttpInfo<GameCenterLeaderboardLocalizationResponse>> {
        const result = this.api.gameCenterLeaderboardLocalizationsUpdateInstanceWithHttpInfo(id, gameCenterLeaderboardLocalizationUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterLeaderboardLocalizationUpdateRequest GameCenterLeaderboardLocalization representation
     */
    public gameCenterLeaderboardLocalizationsUpdateInstance(id: string, gameCenterLeaderboardLocalizationUpdateRequest: GameCenterLeaderboardLocalizationUpdateRequest, _options?: Configuration): Promise<GameCenterLeaderboardLocalizationResponse> {
        const result = this.api.gameCenterLeaderboardLocalizationsUpdateInstance(id, gameCenterLeaderboardLocalizationUpdateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableGameCenterLeaderboardReleasesApi } from './ObservableAPI.ts';

import { GameCenterLeaderboardReleasesApiRequestFactory, GameCenterLeaderboardReleasesApiResponseProcessor} from "../apis/GameCenterLeaderboardReleasesApi.ts";
export class PromiseGameCenterLeaderboardReleasesApi {
    private api: ObservableGameCenterLeaderboardReleasesApi

    public constructor(
        configuration: Configuration,
        requestFactory?: GameCenterLeaderboardReleasesApiRequestFactory,
        responseProcessor?: GameCenterLeaderboardReleasesApiResponseProcessor
    ) {
        this.api = new ObservableGameCenterLeaderboardReleasesApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param gameCenterLeaderboardReleaseCreateRequest GameCenterLeaderboardRelease representation
     */
    public gameCenterLeaderboardReleasesCreateInstanceWithHttpInfo(gameCenterLeaderboardReleaseCreateRequest: GameCenterLeaderboardReleaseCreateRequest, _options?: Configuration): Promise<HttpInfo<GameCenterLeaderboardReleaseResponse>> {
        const result = this.api.gameCenterLeaderboardReleasesCreateInstanceWithHttpInfo(gameCenterLeaderboardReleaseCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param gameCenterLeaderboardReleaseCreateRequest GameCenterLeaderboardRelease representation
     */
    public gameCenterLeaderboardReleasesCreateInstance(gameCenterLeaderboardReleaseCreateRequest: GameCenterLeaderboardReleaseCreateRequest, _options?: Configuration): Promise<GameCenterLeaderboardReleaseResponse> {
        const result = this.api.gameCenterLeaderboardReleasesCreateInstance(gameCenterLeaderboardReleaseCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterLeaderboardReleasesDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.gameCenterLeaderboardReleasesDeleteInstanceWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterLeaderboardReleasesDeleteInstance(id: string, _options?: Configuration): Promise<void> {
        const result = this.api.gameCenterLeaderboardReleasesDeleteInstance(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterLeaderboardReleases the fields to include for returned resources of type gameCenterLeaderboardReleases
     * @param include comma-separated list of relationships to include
     */
    public gameCenterLeaderboardReleasesGetInstanceWithHttpInfo(id: string, fieldsGameCenterLeaderboardReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboard' | 'live'>, include?: Array<'gameCenterDetail' | 'gameCenterLeaderboard'>, _options?: Configuration): Promise<HttpInfo<GameCenterLeaderboardReleaseResponse>> {
        const result = this.api.gameCenterLeaderboardReleasesGetInstanceWithHttpInfo(id, fieldsGameCenterLeaderboardReleases, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterLeaderboardReleases the fields to include for returned resources of type gameCenterLeaderboardReleases
     * @param include comma-separated list of relationships to include
     */
    public gameCenterLeaderboardReleasesGetInstance(id: string, fieldsGameCenterLeaderboardReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboard' | 'live'>, include?: Array<'gameCenterDetail' | 'gameCenterLeaderboard'>, _options?: Configuration): Promise<GameCenterLeaderboardReleaseResponse> {
        const result = this.api.gameCenterLeaderboardReleasesGetInstance(id, fieldsGameCenterLeaderboardReleases, include, _options);
        return result.toPromise();
    }


}



import { ObservableGameCenterLeaderboardSetImagesApi } from './ObservableAPI.ts';

import { GameCenterLeaderboardSetImagesApiRequestFactory, GameCenterLeaderboardSetImagesApiResponseProcessor} from "../apis/GameCenterLeaderboardSetImagesApi.ts";
export class PromiseGameCenterLeaderboardSetImagesApi {
    private api: ObservableGameCenterLeaderboardSetImagesApi

    public constructor(
        configuration: Configuration,
        requestFactory?: GameCenterLeaderboardSetImagesApiRequestFactory,
        responseProcessor?: GameCenterLeaderboardSetImagesApiResponseProcessor
    ) {
        this.api = new ObservableGameCenterLeaderboardSetImagesApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param gameCenterLeaderboardSetImageCreateRequest GameCenterLeaderboardSetImage representation
     */
    public gameCenterLeaderboardSetImagesCreateInstanceWithHttpInfo(gameCenterLeaderboardSetImageCreateRequest: GameCenterLeaderboardSetImageCreateRequest, _options?: Configuration): Promise<HttpInfo<GameCenterLeaderboardSetImageResponse>> {
        const result = this.api.gameCenterLeaderboardSetImagesCreateInstanceWithHttpInfo(gameCenterLeaderboardSetImageCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param gameCenterLeaderboardSetImageCreateRequest GameCenterLeaderboardSetImage representation
     */
    public gameCenterLeaderboardSetImagesCreateInstance(gameCenterLeaderboardSetImageCreateRequest: GameCenterLeaderboardSetImageCreateRequest, _options?: Configuration): Promise<GameCenterLeaderboardSetImageResponse> {
        const result = this.api.gameCenterLeaderboardSetImagesCreateInstance(gameCenterLeaderboardSetImageCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterLeaderboardSetImagesDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.gameCenterLeaderboardSetImagesDeleteInstanceWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterLeaderboardSetImagesDeleteInstance(id: string, _options?: Configuration): Promise<void> {
        const result = this.api.gameCenterLeaderboardSetImagesDeleteInstance(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterLeaderboardSetImages the fields to include for returned resources of type gameCenterLeaderboardSetImages
     * @param include comma-separated list of relationships to include
     */
    public gameCenterLeaderboardSetImagesGetInstanceWithHttpInfo(id: string, fieldsGameCenterLeaderboardSetImages?: Array<'assetDeliveryState' | 'fileName' | 'fileSize' | 'gameCenterLeaderboardSetLocalization' | 'imageAsset' | 'uploadOperations' | 'uploaded'>, include?: Array<'gameCenterLeaderboardSetLocalization'>, _options?: Configuration): Promise<HttpInfo<GameCenterLeaderboardSetImageResponse>> {
        const result = this.api.gameCenterLeaderboardSetImagesGetInstanceWithHttpInfo(id, fieldsGameCenterLeaderboardSetImages, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterLeaderboardSetImages the fields to include for returned resources of type gameCenterLeaderboardSetImages
     * @param include comma-separated list of relationships to include
     */
    public gameCenterLeaderboardSetImagesGetInstance(id: string, fieldsGameCenterLeaderboardSetImages?: Array<'assetDeliveryState' | 'fileName' | 'fileSize' | 'gameCenterLeaderboardSetLocalization' | 'imageAsset' | 'uploadOperations' | 'uploaded'>, include?: Array<'gameCenterLeaderboardSetLocalization'>, _options?: Configuration): Promise<GameCenterLeaderboardSetImageResponse> {
        const result = this.api.gameCenterLeaderboardSetImagesGetInstance(id, fieldsGameCenterLeaderboardSetImages, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterLeaderboardSetImageUpdateRequest GameCenterLeaderboardSetImage representation
     */
    public gameCenterLeaderboardSetImagesUpdateInstanceWithHttpInfo(id: string, gameCenterLeaderboardSetImageUpdateRequest: GameCenterLeaderboardSetImageUpdateRequest, _options?: Configuration): Promise<HttpInfo<GameCenterLeaderboardSetImageResponse>> {
        const result = this.api.gameCenterLeaderboardSetImagesUpdateInstanceWithHttpInfo(id, gameCenterLeaderboardSetImageUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterLeaderboardSetImageUpdateRequest GameCenterLeaderboardSetImage representation
     */
    public gameCenterLeaderboardSetImagesUpdateInstance(id: string, gameCenterLeaderboardSetImageUpdateRequest: GameCenterLeaderboardSetImageUpdateRequest, _options?: Configuration): Promise<GameCenterLeaderboardSetImageResponse> {
        const result = this.api.gameCenterLeaderboardSetImagesUpdateInstance(id, gameCenterLeaderboardSetImageUpdateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableGameCenterLeaderboardSetLocalizationsApi } from './ObservableAPI.ts';

import { GameCenterLeaderboardSetLocalizationsApiRequestFactory, GameCenterLeaderboardSetLocalizationsApiResponseProcessor} from "../apis/GameCenterLeaderboardSetLocalizationsApi.ts";
export class PromiseGameCenterLeaderboardSetLocalizationsApi {
    private api: ObservableGameCenterLeaderboardSetLocalizationsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: GameCenterLeaderboardSetLocalizationsApiRequestFactory,
        responseProcessor?: GameCenterLeaderboardSetLocalizationsApiResponseProcessor
    ) {
        this.api = new ObservableGameCenterLeaderboardSetLocalizationsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param gameCenterLeaderboardSetLocalizationCreateRequest GameCenterLeaderboardSetLocalization representation
     */
    public gameCenterLeaderboardSetLocalizationsCreateInstanceWithHttpInfo(gameCenterLeaderboardSetLocalizationCreateRequest: GameCenterLeaderboardSetLocalizationCreateRequest, _options?: Configuration): Promise<HttpInfo<GameCenterLeaderboardSetLocalizationResponse>> {
        const result = this.api.gameCenterLeaderboardSetLocalizationsCreateInstanceWithHttpInfo(gameCenterLeaderboardSetLocalizationCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param gameCenterLeaderboardSetLocalizationCreateRequest GameCenterLeaderboardSetLocalization representation
     */
    public gameCenterLeaderboardSetLocalizationsCreateInstance(gameCenterLeaderboardSetLocalizationCreateRequest: GameCenterLeaderboardSetLocalizationCreateRequest, _options?: Configuration): Promise<GameCenterLeaderboardSetLocalizationResponse> {
        const result = this.api.gameCenterLeaderboardSetLocalizationsCreateInstance(gameCenterLeaderboardSetLocalizationCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterLeaderboardSetLocalizationsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.gameCenterLeaderboardSetLocalizationsDeleteInstanceWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterLeaderboardSetLocalizationsDeleteInstance(id: string, _options?: Configuration): Promise<void> {
        const result = this.api.gameCenterLeaderboardSetLocalizationsDeleteInstance(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterLeaderboardSetLocalizations the fields to include for returned resources of type gameCenterLeaderboardSetLocalizations
     * @param fieldsGameCenterLeaderboardSetImages the fields to include for returned resources of type gameCenterLeaderboardSetImages
     * @param include comma-separated list of relationships to include
     */
    public gameCenterLeaderboardSetLocalizationsGameCenterLeaderboardSetImageGetToOneRelatedWithHttpInfo(id: string, fieldsGameCenterLeaderboardSetLocalizations?: Array<'gameCenterLeaderboardSet' | 'gameCenterLeaderboardSetImage' | 'locale' | 'name'>, fieldsGameCenterLeaderboardSetImages?: Array<'assetDeliveryState' | 'fileName' | 'fileSize' | 'gameCenterLeaderboardSetLocalization' | 'imageAsset' | 'uploadOperations' | 'uploaded'>, include?: Array<'gameCenterLeaderboardSetLocalization'>, _options?: Configuration): Promise<HttpInfo<GameCenterLeaderboardSetImageResponse>> {
        const result = this.api.gameCenterLeaderboardSetLocalizationsGameCenterLeaderboardSetImageGetToOneRelatedWithHttpInfo(id, fieldsGameCenterLeaderboardSetLocalizations, fieldsGameCenterLeaderboardSetImages, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterLeaderboardSetLocalizations the fields to include for returned resources of type gameCenterLeaderboardSetLocalizations
     * @param fieldsGameCenterLeaderboardSetImages the fields to include for returned resources of type gameCenterLeaderboardSetImages
     * @param include comma-separated list of relationships to include
     */
    public gameCenterLeaderboardSetLocalizationsGameCenterLeaderboardSetImageGetToOneRelated(id: string, fieldsGameCenterLeaderboardSetLocalizations?: Array<'gameCenterLeaderboardSet' | 'gameCenterLeaderboardSetImage' | 'locale' | 'name'>, fieldsGameCenterLeaderboardSetImages?: Array<'assetDeliveryState' | 'fileName' | 'fileSize' | 'gameCenterLeaderboardSetLocalization' | 'imageAsset' | 'uploadOperations' | 'uploaded'>, include?: Array<'gameCenterLeaderboardSetLocalization'>, _options?: Configuration): Promise<GameCenterLeaderboardSetImageResponse> {
        const result = this.api.gameCenterLeaderboardSetLocalizationsGameCenterLeaderboardSetImageGetToOneRelated(id, fieldsGameCenterLeaderboardSetLocalizations, fieldsGameCenterLeaderboardSetImages, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterLeaderboardSetLocalizations the fields to include for returned resources of type gameCenterLeaderboardSetLocalizations
     * @param include comma-separated list of relationships to include
     * @param fieldsGameCenterLeaderboardSetImages the fields to include for returned resources of type gameCenterLeaderboardSetImages
     */
    public gameCenterLeaderboardSetLocalizationsGetInstanceWithHttpInfo(id: string, fieldsGameCenterLeaderboardSetLocalizations?: Array<'gameCenterLeaderboardSet' | 'gameCenterLeaderboardSetImage' | 'locale' | 'name'>, include?: Array<'gameCenterLeaderboardSet' | 'gameCenterLeaderboardSetImage'>, fieldsGameCenterLeaderboardSetImages?: Array<'assetDeliveryState' | 'fileName' | 'fileSize' | 'gameCenterLeaderboardSetLocalization' | 'imageAsset' | 'uploadOperations' | 'uploaded'>, _options?: Configuration): Promise<HttpInfo<GameCenterLeaderboardSetLocalizationResponse>> {
        const result = this.api.gameCenterLeaderboardSetLocalizationsGetInstanceWithHttpInfo(id, fieldsGameCenterLeaderboardSetLocalizations, include, fieldsGameCenterLeaderboardSetImages, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterLeaderboardSetLocalizations the fields to include for returned resources of type gameCenterLeaderboardSetLocalizations
     * @param include comma-separated list of relationships to include
     * @param fieldsGameCenterLeaderboardSetImages the fields to include for returned resources of type gameCenterLeaderboardSetImages
     */
    public gameCenterLeaderboardSetLocalizationsGetInstance(id: string, fieldsGameCenterLeaderboardSetLocalizations?: Array<'gameCenterLeaderboardSet' | 'gameCenterLeaderboardSetImage' | 'locale' | 'name'>, include?: Array<'gameCenterLeaderboardSet' | 'gameCenterLeaderboardSetImage'>, fieldsGameCenterLeaderboardSetImages?: Array<'assetDeliveryState' | 'fileName' | 'fileSize' | 'gameCenterLeaderboardSetLocalization' | 'imageAsset' | 'uploadOperations' | 'uploaded'>, _options?: Configuration): Promise<GameCenterLeaderboardSetLocalizationResponse> {
        const result = this.api.gameCenterLeaderboardSetLocalizationsGetInstance(id, fieldsGameCenterLeaderboardSetLocalizations, include, fieldsGameCenterLeaderboardSetImages, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterLeaderboardSetLocalizationUpdateRequest GameCenterLeaderboardSetLocalization representation
     */
    public gameCenterLeaderboardSetLocalizationsUpdateInstanceWithHttpInfo(id: string, gameCenterLeaderboardSetLocalizationUpdateRequest: GameCenterLeaderboardSetLocalizationUpdateRequest, _options?: Configuration): Promise<HttpInfo<GameCenterLeaderboardSetLocalizationResponse>> {
        const result = this.api.gameCenterLeaderboardSetLocalizationsUpdateInstanceWithHttpInfo(id, gameCenterLeaderboardSetLocalizationUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterLeaderboardSetLocalizationUpdateRequest GameCenterLeaderboardSetLocalization representation
     */
    public gameCenterLeaderboardSetLocalizationsUpdateInstance(id: string, gameCenterLeaderboardSetLocalizationUpdateRequest: GameCenterLeaderboardSetLocalizationUpdateRequest, _options?: Configuration): Promise<GameCenterLeaderboardSetLocalizationResponse> {
        const result = this.api.gameCenterLeaderboardSetLocalizationsUpdateInstance(id, gameCenterLeaderboardSetLocalizationUpdateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableGameCenterLeaderboardSetMemberLocalizationsApi } from './ObservableAPI.ts';

import { GameCenterLeaderboardSetMemberLocalizationsApiRequestFactory, GameCenterLeaderboardSetMemberLocalizationsApiResponseProcessor} from "../apis/GameCenterLeaderboardSetMemberLocalizationsApi.ts";
export class PromiseGameCenterLeaderboardSetMemberLocalizationsApi {
    private api: ObservableGameCenterLeaderboardSetMemberLocalizationsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: GameCenterLeaderboardSetMemberLocalizationsApiRequestFactory,
        responseProcessor?: GameCenterLeaderboardSetMemberLocalizationsApiResponseProcessor
    ) {
        this.api = new ObservableGameCenterLeaderboardSetMemberLocalizationsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param gameCenterLeaderboardSetMemberLocalizationCreateRequest GameCenterLeaderboardSetMemberLocalization representation
     */
    public gameCenterLeaderboardSetMemberLocalizationsCreateInstanceWithHttpInfo(gameCenterLeaderboardSetMemberLocalizationCreateRequest: GameCenterLeaderboardSetMemberLocalizationCreateRequest, _options?: Configuration): Promise<HttpInfo<GameCenterLeaderboardSetMemberLocalizationResponse>> {
        const result = this.api.gameCenterLeaderboardSetMemberLocalizationsCreateInstanceWithHttpInfo(gameCenterLeaderboardSetMemberLocalizationCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param gameCenterLeaderboardSetMemberLocalizationCreateRequest GameCenterLeaderboardSetMemberLocalization representation
     */
    public gameCenterLeaderboardSetMemberLocalizationsCreateInstance(gameCenterLeaderboardSetMemberLocalizationCreateRequest: GameCenterLeaderboardSetMemberLocalizationCreateRequest, _options?: Configuration): Promise<GameCenterLeaderboardSetMemberLocalizationResponse> {
        const result = this.api.gameCenterLeaderboardSetMemberLocalizationsCreateInstance(gameCenterLeaderboardSetMemberLocalizationCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterLeaderboardSetMemberLocalizationsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.gameCenterLeaderboardSetMemberLocalizationsDeleteInstanceWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterLeaderboardSetMemberLocalizationsDeleteInstance(id: string, _options?: Configuration): Promise<void> {
        const result = this.api.gameCenterLeaderboardSetMemberLocalizationsDeleteInstance(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterLeaderboardLocalizations the fields to include for returned resources of type gameCenterLeaderboardLocalizations
     * @param fieldsGameCenterLeaderboardSets the fields to include for returned resources of type gameCenterLeaderboardSets
     * @param fieldsGameCenterGroups the fields to include for returned resources of type gameCenterGroups
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     * @param fieldsGameCenterLeaderboardReleases the fields to include for returned resources of type gameCenterLeaderboardReleases
     * @param limitGameCenterLeaderboardSets maximum number of related gameCenterLeaderboardSets returned (when they are included)
     * @param limitLocalizations maximum number of related localizations returned (when they are included)
     * @param limitReleases maximum number of related releases returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public gameCenterLeaderboardSetMemberLocalizationsGameCenterLeaderboardGetToOneRelatedWithHttpInfo(id: string, fieldsGameCenterLeaderboardLocalizations?: Array<'formatterOverride' | 'formatterSuffix' | 'formatterSuffixSingular' | 'gameCenterLeaderboard' | 'gameCenterLeaderboardImage' | 'locale' | 'name'>, fieldsGameCenterLeaderboardSets?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'referenceName' | 'releases' | 'vendorIdentifier'>, fieldsGameCenterGroups?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'referenceName'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, fieldsGameCenterLeaderboardReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboard' | 'live'>, limitGameCenterLeaderboardSets?: number, limitLocalizations?: number, limitReleases?: number, include?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'releases'>, _options?: Configuration): Promise<HttpInfo<GameCenterLeaderboardResponse>> {
        const result = this.api.gameCenterLeaderboardSetMemberLocalizationsGameCenterLeaderboardGetToOneRelatedWithHttpInfo(id, fieldsGameCenterLeaderboardLocalizations, fieldsGameCenterLeaderboardSets, fieldsGameCenterGroups, fieldsGameCenterDetails, fieldsGameCenterLeaderboards, fieldsGameCenterLeaderboardReleases, limitGameCenterLeaderboardSets, limitLocalizations, limitReleases, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterLeaderboardLocalizations the fields to include for returned resources of type gameCenterLeaderboardLocalizations
     * @param fieldsGameCenterLeaderboardSets the fields to include for returned resources of type gameCenterLeaderboardSets
     * @param fieldsGameCenterGroups the fields to include for returned resources of type gameCenterGroups
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     * @param fieldsGameCenterLeaderboardReleases the fields to include for returned resources of type gameCenterLeaderboardReleases
     * @param limitGameCenterLeaderboardSets maximum number of related gameCenterLeaderboardSets returned (when they are included)
     * @param limitLocalizations maximum number of related localizations returned (when they are included)
     * @param limitReleases maximum number of related releases returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public gameCenterLeaderboardSetMemberLocalizationsGameCenterLeaderboardGetToOneRelated(id: string, fieldsGameCenterLeaderboardLocalizations?: Array<'formatterOverride' | 'formatterSuffix' | 'formatterSuffixSingular' | 'gameCenterLeaderboard' | 'gameCenterLeaderboardImage' | 'locale' | 'name'>, fieldsGameCenterLeaderboardSets?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'referenceName' | 'releases' | 'vendorIdentifier'>, fieldsGameCenterGroups?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'referenceName'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, fieldsGameCenterLeaderboardReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboard' | 'live'>, limitGameCenterLeaderboardSets?: number, limitLocalizations?: number, limitReleases?: number, include?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'releases'>, _options?: Configuration): Promise<GameCenterLeaderboardResponse> {
        const result = this.api.gameCenterLeaderboardSetMemberLocalizationsGameCenterLeaderboardGetToOneRelated(id, fieldsGameCenterLeaderboardLocalizations, fieldsGameCenterLeaderboardSets, fieldsGameCenterGroups, fieldsGameCenterDetails, fieldsGameCenterLeaderboards, fieldsGameCenterLeaderboardReleases, limitGameCenterLeaderboardSets, limitLocalizations, limitReleases, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterLeaderboardSetLocalizations the fields to include for returned resources of type gameCenterLeaderboardSetLocalizations
     * @param fieldsGameCenterLeaderboardSetReleases the fields to include for returned resources of type gameCenterLeaderboardSetReleases
     * @param fieldsGameCenterLeaderboardSets the fields to include for returned resources of type gameCenterLeaderboardSets
     * @param fieldsGameCenterGroups the fields to include for returned resources of type gameCenterGroups
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     * @param limitLocalizations maximum number of related localizations returned (when they are included)
     * @param limitGameCenterLeaderboards maximum number of related gameCenterLeaderboards returned (when they are included)
     * @param limitReleases maximum number of related releases returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public gameCenterLeaderboardSetMemberLocalizationsGameCenterLeaderboardSetGetToOneRelatedWithHttpInfo(id: string, fieldsGameCenterLeaderboardSetLocalizations?: Array<'gameCenterLeaderboardSet' | 'gameCenterLeaderboardSetImage' | 'locale' | 'name'>, fieldsGameCenterLeaderboardSetReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboardSet' | 'live'>, fieldsGameCenterLeaderboardSets?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'referenceName' | 'releases' | 'vendorIdentifier'>, fieldsGameCenterGroups?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'referenceName'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, limitLocalizations?: number, limitGameCenterLeaderboards?: number, limitReleases?: number, include?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'releases'>, _options?: Configuration): Promise<HttpInfo<GameCenterLeaderboardSetResponse>> {
        const result = this.api.gameCenterLeaderboardSetMemberLocalizationsGameCenterLeaderboardSetGetToOneRelatedWithHttpInfo(id, fieldsGameCenterLeaderboardSetLocalizations, fieldsGameCenterLeaderboardSetReleases, fieldsGameCenterLeaderboardSets, fieldsGameCenterGroups, fieldsGameCenterDetails, fieldsGameCenterLeaderboards, limitLocalizations, limitGameCenterLeaderboards, limitReleases, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterLeaderboardSetLocalizations the fields to include for returned resources of type gameCenterLeaderboardSetLocalizations
     * @param fieldsGameCenterLeaderboardSetReleases the fields to include for returned resources of type gameCenterLeaderboardSetReleases
     * @param fieldsGameCenterLeaderboardSets the fields to include for returned resources of type gameCenterLeaderboardSets
     * @param fieldsGameCenterGroups the fields to include for returned resources of type gameCenterGroups
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     * @param limitLocalizations maximum number of related localizations returned (when they are included)
     * @param limitGameCenterLeaderboards maximum number of related gameCenterLeaderboards returned (when they are included)
     * @param limitReleases maximum number of related releases returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public gameCenterLeaderboardSetMemberLocalizationsGameCenterLeaderboardSetGetToOneRelated(id: string, fieldsGameCenterLeaderboardSetLocalizations?: Array<'gameCenterLeaderboardSet' | 'gameCenterLeaderboardSetImage' | 'locale' | 'name'>, fieldsGameCenterLeaderboardSetReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboardSet' | 'live'>, fieldsGameCenterLeaderboardSets?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'referenceName' | 'releases' | 'vendorIdentifier'>, fieldsGameCenterGroups?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'referenceName'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, limitLocalizations?: number, limitGameCenterLeaderboards?: number, limitReleases?: number, include?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'releases'>, _options?: Configuration): Promise<GameCenterLeaderboardSetResponse> {
        const result = this.api.gameCenterLeaderboardSetMemberLocalizationsGameCenterLeaderboardSetGetToOneRelated(id, fieldsGameCenterLeaderboardSetLocalizations, fieldsGameCenterLeaderboardSetReleases, fieldsGameCenterLeaderboardSets, fieldsGameCenterGroups, fieldsGameCenterDetails, fieldsGameCenterLeaderboards, limitLocalizations, limitGameCenterLeaderboards, limitReleases, include, _options);
        return result.toPromise();
    }

    /**
     * @param filterGameCenterLeaderboard filter by id(s) of related \&#39;gameCenterLeaderboard\&#39;
     * @param filterGameCenterLeaderboardSet filter by id(s) of related \&#39;gameCenterLeaderboardSet\&#39;
     * @param fieldsGameCenterLeaderboardSetMemberLocalizations the fields to include for returned resources of type gameCenterLeaderboardSetMemberLocalizations
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsGameCenterLeaderboardSets the fields to include for returned resources of type gameCenterLeaderboardSets
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     */
    public gameCenterLeaderboardSetMemberLocalizationsGetCollectionWithHttpInfo(filterGameCenterLeaderboard: Array<string>, filterGameCenterLeaderboardSet: Array<string>, fieldsGameCenterLeaderboardSetMemberLocalizations?: Array<'gameCenterLeaderboard' | 'gameCenterLeaderboardSet' | 'locale' | 'name'>, limit?: number, include?: Array<'gameCenterLeaderboard' | 'gameCenterLeaderboardSet'>, fieldsGameCenterLeaderboardSets?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'referenceName' | 'releases' | 'vendorIdentifier'>, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, _options?: Configuration): Promise<HttpInfo<GameCenterLeaderboardSetMemberLocalizationsResponse>> {
        const result = this.api.gameCenterLeaderboardSetMemberLocalizationsGetCollectionWithHttpInfo(filterGameCenterLeaderboard, filterGameCenterLeaderboardSet, fieldsGameCenterLeaderboardSetMemberLocalizations, limit, include, fieldsGameCenterLeaderboardSets, fieldsGameCenterLeaderboards, _options);
        return result.toPromise();
    }

    /**
     * @param filterGameCenterLeaderboard filter by id(s) of related \&#39;gameCenterLeaderboard\&#39;
     * @param filterGameCenterLeaderboardSet filter by id(s) of related \&#39;gameCenterLeaderboardSet\&#39;
     * @param fieldsGameCenterLeaderboardSetMemberLocalizations the fields to include for returned resources of type gameCenterLeaderboardSetMemberLocalizations
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsGameCenterLeaderboardSets the fields to include for returned resources of type gameCenterLeaderboardSets
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     */
    public gameCenterLeaderboardSetMemberLocalizationsGetCollection(filterGameCenterLeaderboard: Array<string>, filterGameCenterLeaderboardSet: Array<string>, fieldsGameCenterLeaderboardSetMemberLocalizations?: Array<'gameCenterLeaderboard' | 'gameCenterLeaderboardSet' | 'locale' | 'name'>, limit?: number, include?: Array<'gameCenterLeaderboard' | 'gameCenterLeaderboardSet'>, fieldsGameCenterLeaderboardSets?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'referenceName' | 'releases' | 'vendorIdentifier'>, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, _options?: Configuration): Promise<GameCenterLeaderboardSetMemberLocalizationsResponse> {
        const result = this.api.gameCenterLeaderboardSetMemberLocalizationsGetCollection(filterGameCenterLeaderboard, filterGameCenterLeaderboardSet, fieldsGameCenterLeaderboardSetMemberLocalizations, limit, include, fieldsGameCenterLeaderboardSets, fieldsGameCenterLeaderboards, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterLeaderboardSetMemberLocalizationUpdateRequest GameCenterLeaderboardSetMemberLocalization representation
     */
    public gameCenterLeaderboardSetMemberLocalizationsUpdateInstanceWithHttpInfo(id: string, gameCenterLeaderboardSetMemberLocalizationUpdateRequest: GameCenterLeaderboardSetMemberLocalizationUpdateRequest, _options?: Configuration): Promise<HttpInfo<GameCenterLeaderboardSetMemberLocalizationResponse>> {
        const result = this.api.gameCenterLeaderboardSetMemberLocalizationsUpdateInstanceWithHttpInfo(id, gameCenterLeaderboardSetMemberLocalizationUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterLeaderboardSetMemberLocalizationUpdateRequest GameCenterLeaderboardSetMemberLocalization representation
     */
    public gameCenterLeaderboardSetMemberLocalizationsUpdateInstance(id: string, gameCenterLeaderboardSetMemberLocalizationUpdateRequest: GameCenterLeaderboardSetMemberLocalizationUpdateRequest, _options?: Configuration): Promise<GameCenterLeaderboardSetMemberLocalizationResponse> {
        const result = this.api.gameCenterLeaderboardSetMemberLocalizationsUpdateInstance(id, gameCenterLeaderboardSetMemberLocalizationUpdateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableGameCenterLeaderboardSetReleasesApi } from './ObservableAPI.ts';

import { GameCenterLeaderboardSetReleasesApiRequestFactory, GameCenterLeaderboardSetReleasesApiResponseProcessor} from "../apis/GameCenterLeaderboardSetReleasesApi.ts";
export class PromiseGameCenterLeaderboardSetReleasesApi {
    private api: ObservableGameCenterLeaderboardSetReleasesApi

    public constructor(
        configuration: Configuration,
        requestFactory?: GameCenterLeaderboardSetReleasesApiRequestFactory,
        responseProcessor?: GameCenterLeaderboardSetReleasesApiResponseProcessor
    ) {
        this.api = new ObservableGameCenterLeaderboardSetReleasesApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param gameCenterLeaderboardSetReleaseCreateRequest GameCenterLeaderboardSetRelease representation
     */
    public gameCenterLeaderboardSetReleasesCreateInstanceWithHttpInfo(gameCenterLeaderboardSetReleaseCreateRequest: GameCenterLeaderboardSetReleaseCreateRequest, _options?: Configuration): Promise<HttpInfo<GameCenterLeaderboardSetReleaseResponse>> {
        const result = this.api.gameCenterLeaderboardSetReleasesCreateInstanceWithHttpInfo(gameCenterLeaderboardSetReleaseCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param gameCenterLeaderboardSetReleaseCreateRequest GameCenterLeaderboardSetRelease representation
     */
    public gameCenterLeaderboardSetReleasesCreateInstance(gameCenterLeaderboardSetReleaseCreateRequest: GameCenterLeaderboardSetReleaseCreateRequest, _options?: Configuration): Promise<GameCenterLeaderboardSetReleaseResponse> {
        const result = this.api.gameCenterLeaderboardSetReleasesCreateInstance(gameCenterLeaderboardSetReleaseCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterLeaderboardSetReleasesDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.gameCenterLeaderboardSetReleasesDeleteInstanceWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterLeaderboardSetReleasesDeleteInstance(id: string, _options?: Configuration): Promise<void> {
        const result = this.api.gameCenterLeaderboardSetReleasesDeleteInstance(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterLeaderboardSetReleases the fields to include for returned resources of type gameCenterLeaderboardSetReleases
     * @param include comma-separated list of relationships to include
     */
    public gameCenterLeaderboardSetReleasesGetInstanceWithHttpInfo(id: string, fieldsGameCenterLeaderboardSetReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboardSet' | 'live'>, include?: Array<'gameCenterDetail' | 'gameCenterLeaderboardSet'>, _options?: Configuration): Promise<HttpInfo<GameCenterLeaderboardSetReleaseResponse>> {
        const result = this.api.gameCenterLeaderboardSetReleasesGetInstanceWithHttpInfo(id, fieldsGameCenterLeaderboardSetReleases, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterLeaderboardSetReleases the fields to include for returned resources of type gameCenterLeaderboardSetReleases
     * @param include comma-separated list of relationships to include
     */
    public gameCenterLeaderboardSetReleasesGetInstance(id: string, fieldsGameCenterLeaderboardSetReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboardSet' | 'live'>, include?: Array<'gameCenterDetail' | 'gameCenterLeaderboardSet'>, _options?: Configuration): Promise<GameCenterLeaderboardSetReleaseResponse> {
        const result = this.api.gameCenterLeaderboardSetReleasesGetInstance(id, fieldsGameCenterLeaderboardSetReleases, include, _options);
        return result.toPromise();
    }


}



import { ObservableGameCenterLeaderboardSetsApi } from './ObservableAPI.ts';

import { GameCenterLeaderboardSetsApiRequestFactory, GameCenterLeaderboardSetsApiResponseProcessor} from "../apis/GameCenterLeaderboardSetsApi.ts";
export class PromiseGameCenterLeaderboardSetsApi {
    private api: ObservableGameCenterLeaderboardSetsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: GameCenterLeaderboardSetsApiRequestFactory,
        responseProcessor?: GameCenterLeaderboardSetsApiResponseProcessor
    ) {
        this.api = new ObservableGameCenterLeaderboardSetsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param gameCenterLeaderboardSetCreateRequest GameCenterLeaderboardSet representation
     */
    public gameCenterLeaderboardSetsCreateInstanceWithHttpInfo(gameCenterLeaderboardSetCreateRequest: GameCenterLeaderboardSetCreateRequest, _options?: Configuration): Promise<HttpInfo<GameCenterLeaderboardSetResponse>> {
        const result = this.api.gameCenterLeaderboardSetsCreateInstanceWithHttpInfo(gameCenterLeaderboardSetCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param gameCenterLeaderboardSetCreateRequest GameCenterLeaderboardSet representation
     */
    public gameCenterLeaderboardSetsCreateInstance(gameCenterLeaderboardSetCreateRequest: GameCenterLeaderboardSetCreateRequest, _options?: Configuration): Promise<GameCenterLeaderboardSetResponse> {
        const result = this.api.gameCenterLeaderboardSetsCreateInstance(gameCenterLeaderboardSetCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterLeaderboardSetsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.gameCenterLeaderboardSetsDeleteInstanceWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterLeaderboardSetsDeleteInstance(id: string, _options?: Configuration): Promise<void> {
        const result = this.api.gameCenterLeaderboardSetsDeleteInstance(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterLeaderboardSetGameCenterLeaderboardsLinkagesRequest List of related linkages
     */
    public gameCenterLeaderboardSetsGameCenterLeaderboardsCreateToManyRelationshipWithHttpInfo(id: string, gameCenterLeaderboardSetGameCenterLeaderboardsLinkagesRequest: GameCenterLeaderboardSetGameCenterLeaderboardsLinkagesRequest, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.gameCenterLeaderboardSetsGameCenterLeaderboardsCreateToManyRelationshipWithHttpInfo(id, gameCenterLeaderboardSetGameCenterLeaderboardsLinkagesRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterLeaderboardSetGameCenterLeaderboardsLinkagesRequest List of related linkages
     */
    public gameCenterLeaderboardSetsGameCenterLeaderboardsCreateToManyRelationship(id: string, gameCenterLeaderboardSetGameCenterLeaderboardsLinkagesRequest: GameCenterLeaderboardSetGameCenterLeaderboardsLinkagesRequest, _options?: Configuration): Promise<void> {
        const result = this.api.gameCenterLeaderboardSetsGameCenterLeaderboardsCreateToManyRelationship(id, gameCenterLeaderboardSetGameCenterLeaderboardsLinkagesRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterLeaderboardSetGameCenterLeaderboardsLinkagesRequest List of related linkages
     */
    public gameCenterLeaderboardSetsGameCenterLeaderboardsDeleteToManyRelationshipWithHttpInfo(id: string, gameCenterLeaderboardSetGameCenterLeaderboardsLinkagesRequest: GameCenterLeaderboardSetGameCenterLeaderboardsLinkagesRequest, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.gameCenterLeaderboardSetsGameCenterLeaderboardsDeleteToManyRelationshipWithHttpInfo(id, gameCenterLeaderboardSetGameCenterLeaderboardsLinkagesRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterLeaderboardSetGameCenterLeaderboardsLinkagesRequest List of related linkages
     */
    public gameCenterLeaderboardSetsGameCenterLeaderboardsDeleteToManyRelationship(id: string, gameCenterLeaderboardSetGameCenterLeaderboardsLinkagesRequest: GameCenterLeaderboardSetGameCenterLeaderboardsLinkagesRequest, _options?: Configuration): Promise<void> {
        const result = this.api.gameCenterLeaderboardSetsGameCenterLeaderboardsDeleteToManyRelationship(id, gameCenterLeaderboardSetGameCenterLeaderboardsLinkagesRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterArchived filter by attribute \&#39;archived\&#39;
     * @param filterReferenceName filter by attribute \&#39;referenceName\&#39;
     * @param filterId filter by id(s)
     * @param fieldsGameCenterLeaderboardLocalizations the fields to include for returned resources of type gameCenterLeaderboardLocalizations
     * @param fieldsGameCenterLeaderboardSets the fields to include for returned resources of type gameCenterLeaderboardSets
     * @param fieldsGameCenterGroups the fields to include for returned resources of type gameCenterGroups
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     * @param fieldsGameCenterLeaderboardReleases the fields to include for returned resources of type gameCenterLeaderboardReleases
     * @param limit maximum resources per page
     * @param limitGameCenterLeaderboardSets maximum number of related gameCenterLeaderboardSets returned (when they are included)
     * @param limitLocalizations maximum number of related localizations returned (when they are included)
     * @param limitReleases maximum number of related releases returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public gameCenterLeaderboardSetsGameCenterLeaderboardsGetToManyRelatedWithHttpInfo(id: string, filterArchived?: Array<string>, filterReferenceName?: Array<string>, filterId?: Array<string>, fieldsGameCenterLeaderboardLocalizations?: Array<'formatterOverride' | 'formatterSuffix' | 'formatterSuffixSingular' | 'gameCenterLeaderboard' | 'gameCenterLeaderboardImage' | 'locale' | 'name'>, fieldsGameCenterLeaderboardSets?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'referenceName' | 'releases' | 'vendorIdentifier'>, fieldsGameCenterGroups?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'referenceName'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, fieldsGameCenterLeaderboardReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboard' | 'live'>, limit?: number, limitGameCenterLeaderboardSets?: number, limitLocalizations?: number, limitReleases?: number, include?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'releases'>, _options?: Configuration): Promise<HttpInfo<GameCenterLeaderboardsResponse>> {
        const result = this.api.gameCenterLeaderboardSetsGameCenterLeaderboardsGetToManyRelatedWithHttpInfo(id, filterArchived, filterReferenceName, filterId, fieldsGameCenterLeaderboardLocalizations, fieldsGameCenterLeaderboardSets, fieldsGameCenterGroups, fieldsGameCenterDetails, fieldsGameCenterLeaderboards, fieldsGameCenterLeaderboardReleases, limit, limitGameCenterLeaderboardSets, limitLocalizations, limitReleases, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterArchived filter by attribute \&#39;archived\&#39;
     * @param filterReferenceName filter by attribute \&#39;referenceName\&#39;
     * @param filterId filter by id(s)
     * @param fieldsGameCenterLeaderboardLocalizations the fields to include for returned resources of type gameCenterLeaderboardLocalizations
     * @param fieldsGameCenterLeaderboardSets the fields to include for returned resources of type gameCenterLeaderboardSets
     * @param fieldsGameCenterGroups the fields to include for returned resources of type gameCenterGroups
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     * @param fieldsGameCenterLeaderboardReleases the fields to include for returned resources of type gameCenterLeaderboardReleases
     * @param limit maximum resources per page
     * @param limitGameCenterLeaderboardSets maximum number of related gameCenterLeaderboardSets returned (when they are included)
     * @param limitLocalizations maximum number of related localizations returned (when they are included)
     * @param limitReleases maximum number of related releases returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public gameCenterLeaderboardSetsGameCenterLeaderboardsGetToManyRelated(id: string, filterArchived?: Array<string>, filterReferenceName?: Array<string>, filterId?: Array<string>, fieldsGameCenterLeaderboardLocalizations?: Array<'formatterOverride' | 'formatterSuffix' | 'formatterSuffixSingular' | 'gameCenterLeaderboard' | 'gameCenterLeaderboardImage' | 'locale' | 'name'>, fieldsGameCenterLeaderboardSets?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'referenceName' | 'releases' | 'vendorIdentifier'>, fieldsGameCenterGroups?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'referenceName'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, fieldsGameCenterLeaderboardReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboard' | 'live'>, limit?: number, limitGameCenterLeaderboardSets?: number, limitLocalizations?: number, limitReleases?: number, include?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'releases'>, _options?: Configuration): Promise<GameCenterLeaderboardsResponse> {
        const result = this.api.gameCenterLeaderboardSetsGameCenterLeaderboardsGetToManyRelated(id, filterArchived, filterReferenceName, filterId, fieldsGameCenterLeaderboardLocalizations, fieldsGameCenterLeaderboardSets, fieldsGameCenterGroups, fieldsGameCenterDetails, fieldsGameCenterLeaderboards, fieldsGameCenterLeaderboardReleases, limit, limitGameCenterLeaderboardSets, limitLocalizations, limitReleases, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public gameCenterLeaderboardSetsGameCenterLeaderboardsGetToManyRelationshipWithHttpInfo(id: string, limit?: number, _options?: Configuration): Promise<HttpInfo<GameCenterLeaderboardSetGameCenterLeaderboardsLinkagesResponse>> {
        const result = this.api.gameCenterLeaderboardSetsGameCenterLeaderboardsGetToManyRelationshipWithHttpInfo(id, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public gameCenterLeaderboardSetsGameCenterLeaderboardsGetToManyRelationship(id: string, limit?: number, _options?: Configuration): Promise<GameCenterLeaderboardSetGameCenterLeaderboardsLinkagesResponse> {
        const result = this.api.gameCenterLeaderboardSetsGameCenterLeaderboardsGetToManyRelationship(id, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterLeaderboardSetGameCenterLeaderboardsLinkagesRequest List of related linkages
     */
    public gameCenterLeaderboardSetsGameCenterLeaderboardsReplaceToManyRelationshipWithHttpInfo(id: string, gameCenterLeaderboardSetGameCenterLeaderboardsLinkagesRequest: GameCenterLeaderboardSetGameCenterLeaderboardsLinkagesRequest, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.gameCenterLeaderboardSetsGameCenterLeaderboardsReplaceToManyRelationshipWithHttpInfo(id, gameCenterLeaderboardSetGameCenterLeaderboardsLinkagesRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterLeaderboardSetGameCenterLeaderboardsLinkagesRequest List of related linkages
     */
    public gameCenterLeaderboardSetsGameCenterLeaderboardsReplaceToManyRelationship(id: string, gameCenterLeaderboardSetGameCenterLeaderboardsLinkagesRequest: GameCenterLeaderboardSetGameCenterLeaderboardsLinkagesRequest, _options?: Configuration): Promise<void> {
        const result = this.api.gameCenterLeaderboardSetsGameCenterLeaderboardsReplaceToManyRelationship(id, gameCenterLeaderboardSetGameCenterLeaderboardsLinkagesRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterLeaderboardSets the fields to include for returned resources of type gameCenterLeaderboardSets
     * @param include comma-separated list of relationships to include
     * @param fieldsGameCenterLeaderboardSetLocalizations the fields to include for returned resources of type gameCenterLeaderboardSetLocalizations
     * @param fieldsGameCenterLeaderboardSetReleases the fields to include for returned resources of type gameCenterLeaderboardSetReleases
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     * @param limitGameCenterLeaderboards maximum number of related gameCenterLeaderboards returned (when they are included)
     * @param limitLocalizations maximum number of related localizations returned (when they are included)
     * @param limitReleases maximum number of related releases returned (when they are included)
     */
    public gameCenterLeaderboardSetsGetInstanceWithHttpInfo(id: string, fieldsGameCenterLeaderboardSets?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'referenceName' | 'releases' | 'vendorIdentifier'>, include?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'releases'>, fieldsGameCenterLeaderboardSetLocalizations?: Array<'gameCenterLeaderboardSet' | 'gameCenterLeaderboardSetImage' | 'locale' | 'name'>, fieldsGameCenterLeaderboardSetReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboardSet' | 'live'>, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, limitGameCenterLeaderboards?: number, limitLocalizations?: number, limitReleases?: number, _options?: Configuration): Promise<HttpInfo<GameCenterLeaderboardSetResponse>> {
        const result = this.api.gameCenterLeaderboardSetsGetInstanceWithHttpInfo(id, fieldsGameCenterLeaderboardSets, include, fieldsGameCenterLeaderboardSetLocalizations, fieldsGameCenterLeaderboardSetReleases, fieldsGameCenterLeaderboards, limitGameCenterLeaderboards, limitLocalizations, limitReleases, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterLeaderboardSets the fields to include for returned resources of type gameCenterLeaderboardSets
     * @param include comma-separated list of relationships to include
     * @param fieldsGameCenterLeaderboardSetLocalizations the fields to include for returned resources of type gameCenterLeaderboardSetLocalizations
     * @param fieldsGameCenterLeaderboardSetReleases the fields to include for returned resources of type gameCenterLeaderboardSetReleases
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     * @param limitGameCenterLeaderboards maximum number of related gameCenterLeaderboards returned (when they are included)
     * @param limitLocalizations maximum number of related localizations returned (when they are included)
     * @param limitReleases maximum number of related releases returned (when they are included)
     */
    public gameCenterLeaderboardSetsGetInstance(id: string, fieldsGameCenterLeaderboardSets?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'referenceName' | 'releases' | 'vendorIdentifier'>, include?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'releases'>, fieldsGameCenterLeaderboardSetLocalizations?: Array<'gameCenterLeaderboardSet' | 'gameCenterLeaderboardSetImage' | 'locale' | 'name'>, fieldsGameCenterLeaderboardSetReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboardSet' | 'live'>, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, limitGameCenterLeaderboards?: number, limitLocalizations?: number, limitReleases?: number, _options?: Configuration): Promise<GameCenterLeaderboardSetResponse> {
        const result = this.api.gameCenterLeaderboardSetsGetInstance(id, fieldsGameCenterLeaderboardSets, include, fieldsGameCenterLeaderboardSetLocalizations, fieldsGameCenterLeaderboardSetReleases, fieldsGameCenterLeaderboards, limitGameCenterLeaderboards, limitLocalizations, limitReleases, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterLeaderboardSetLocalizations the fields to include for returned resources of type gameCenterLeaderboardSetLocalizations
     * @param fieldsGameCenterLeaderboardSetReleases the fields to include for returned resources of type gameCenterLeaderboardSetReleases
     * @param fieldsGameCenterLeaderboardSets the fields to include for returned resources of type gameCenterLeaderboardSets
     * @param fieldsGameCenterGroups the fields to include for returned resources of type gameCenterGroups
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     * @param limitLocalizations maximum number of related localizations returned (when they are included)
     * @param limitGameCenterLeaderboards maximum number of related gameCenterLeaderboards returned (when they are included)
     * @param limitReleases maximum number of related releases returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public gameCenterLeaderboardSetsGroupLeaderboardSetGetToOneRelatedWithHttpInfo(id: string, fieldsGameCenterLeaderboardSetLocalizations?: Array<'gameCenterLeaderboardSet' | 'gameCenterLeaderboardSetImage' | 'locale' | 'name'>, fieldsGameCenterLeaderboardSetReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboardSet' | 'live'>, fieldsGameCenterLeaderboardSets?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'referenceName' | 'releases' | 'vendorIdentifier'>, fieldsGameCenterGroups?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'referenceName'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, limitLocalizations?: number, limitGameCenterLeaderboards?: number, limitReleases?: number, include?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'releases'>, _options?: Configuration): Promise<HttpInfo<GameCenterLeaderboardSetResponse>> {
        const result = this.api.gameCenterLeaderboardSetsGroupLeaderboardSetGetToOneRelatedWithHttpInfo(id, fieldsGameCenterLeaderboardSetLocalizations, fieldsGameCenterLeaderboardSetReleases, fieldsGameCenterLeaderboardSets, fieldsGameCenterGroups, fieldsGameCenterDetails, fieldsGameCenterLeaderboards, limitLocalizations, limitGameCenterLeaderboards, limitReleases, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterLeaderboardSetLocalizations the fields to include for returned resources of type gameCenterLeaderboardSetLocalizations
     * @param fieldsGameCenterLeaderboardSetReleases the fields to include for returned resources of type gameCenterLeaderboardSetReleases
     * @param fieldsGameCenterLeaderboardSets the fields to include for returned resources of type gameCenterLeaderboardSets
     * @param fieldsGameCenterGroups the fields to include for returned resources of type gameCenterGroups
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     * @param limitLocalizations maximum number of related localizations returned (when they are included)
     * @param limitGameCenterLeaderboards maximum number of related gameCenterLeaderboards returned (when they are included)
     * @param limitReleases maximum number of related releases returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public gameCenterLeaderboardSetsGroupLeaderboardSetGetToOneRelated(id: string, fieldsGameCenterLeaderboardSetLocalizations?: Array<'gameCenterLeaderboardSet' | 'gameCenterLeaderboardSetImage' | 'locale' | 'name'>, fieldsGameCenterLeaderboardSetReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboardSet' | 'live'>, fieldsGameCenterLeaderboardSets?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'referenceName' | 'releases' | 'vendorIdentifier'>, fieldsGameCenterGroups?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'referenceName'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, limitLocalizations?: number, limitGameCenterLeaderboards?: number, limitReleases?: number, include?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'releases'>, _options?: Configuration): Promise<GameCenterLeaderboardSetResponse> {
        const result = this.api.gameCenterLeaderboardSetsGroupLeaderboardSetGetToOneRelated(id, fieldsGameCenterLeaderboardSetLocalizations, fieldsGameCenterLeaderboardSetReleases, fieldsGameCenterLeaderboardSets, fieldsGameCenterGroups, fieldsGameCenterDetails, fieldsGameCenterLeaderboards, limitLocalizations, limitGameCenterLeaderboards, limitReleases, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterLeaderboardSetsGroupLeaderboardSetGetToOneRelationshipWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<GameCenterLeaderboardSetGroupLeaderboardSetLinkageResponse>> {
        const result = this.api.gameCenterLeaderboardSetsGroupLeaderboardSetGetToOneRelationshipWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterLeaderboardSetsGroupLeaderboardSetGetToOneRelationship(id: string, _options?: Configuration): Promise<GameCenterLeaderboardSetGroupLeaderboardSetLinkageResponse> {
        const result = this.api.gameCenterLeaderboardSetsGroupLeaderboardSetGetToOneRelationship(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterLeaderboardSetGroupLeaderboardSetLinkageRequest Related linkage
     */
    public gameCenterLeaderboardSetsGroupLeaderboardSetUpdateToOneRelationshipWithHttpInfo(id: string, gameCenterLeaderboardSetGroupLeaderboardSetLinkageRequest: GameCenterLeaderboardSetGroupLeaderboardSetLinkageRequest, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.gameCenterLeaderboardSetsGroupLeaderboardSetUpdateToOneRelationshipWithHttpInfo(id, gameCenterLeaderboardSetGroupLeaderboardSetLinkageRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterLeaderboardSetGroupLeaderboardSetLinkageRequest Related linkage
     */
    public gameCenterLeaderboardSetsGroupLeaderboardSetUpdateToOneRelationship(id: string, gameCenterLeaderboardSetGroupLeaderboardSetLinkageRequest: GameCenterLeaderboardSetGroupLeaderboardSetLinkageRequest, _options?: Configuration): Promise<void> {
        const result = this.api.gameCenterLeaderboardSetsGroupLeaderboardSetUpdateToOneRelationship(id, gameCenterLeaderboardSetGroupLeaderboardSetLinkageRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterLeaderboardSetLocalizations the fields to include for returned resources of type gameCenterLeaderboardSetLocalizations
     * @param fieldsGameCenterLeaderboardSets the fields to include for returned resources of type gameCenterLeaderboardSets
     * @param fieldsGameCenterLeaderboardSetImages the fields to include for returned resources of type gameCenterLeaderboardSetImages
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public gameCenterLeaderboardSetsLocalizationsGetToManyRelatedWithHttpInfo(id: string, fieldsGameCenterLeaderboardSetLocalizations?: Array<'gameCenterLeaderboardSet' | 'gameCenterLeaderboardSetImage' | 'locale' | 'name'>, fieldsGameCenterLeaderboardSets?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'referenceName' | 'releases' | 'vendorIdentifier'>, fieldsGameCenterLeaderboardSetImages?: Array<'assetDeliveryState' | 'fileName' | 'fileSize' | 'gameCenterLeaderboardSetLocalization' | 'imageAsset' | 'uploadOperations' | 'uploaded'>, limit?: number, include?: Array<'gameCenterLeaderboardSet' | 'gameCenterLeaderboardSetImage'>, _options?: Configuration): Promise<HttpInfo<GameCenterLeaderboardSetLocalizationsResponse>> {
        const result = this.api.gameCenterLeaderboardSetsLocalizationsGetToManyRelatedWithHttpInfo(id, fieldsGameCenterLeaderboardSetLocalizations, fieldsGameCenterLeaderboardSets, fieldsGameCenterLeaderboardSetImages, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterLeaderboardSetLocalizations the fields to include for returned resources of type gameCenterLeaderboardSetLocalizations
     * @param fieldsGameCenterLeaderboardSets the fields to include for returned resources of type gameCenterLeaderboardSets
     * @param fieldsGameCenterLeaderboardSetImages the fields to include for returned resources of type gameCenterLeaderboardSetImages
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public gameCenterLeaderboardSetsLocalizationsGetToManyRelated(id: string, fieldsGameCenterLeaderboardSetLocalizations?: Array<'gameCenterLeaderboardSet' | 'gameCenterLeaderboardSetImage' | 'locale' | 'name'>, fieldsGameCenterLeaderboardSets?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'referenceName' | 'releases' | 'vendorIdentifier'>, fieldsGameCenterLeaderboardSetImages?: Array<'assetDeliveryState' | 'fileName' | 'fileSize' | 'gameCenterLeaderboardSetLocalization' | 'imageAsset' | 'uploadOperations' | 'uploaded'>, limit?: number, include?: Array<'gameCenterLeaderboardSet' | 'gameCenterLeaderboardSetImage'>, _options?: Configuration): Promise<GameCenterLeaderboardSetLocalizationsResponse> {
        const result = this.api.gameCenterLeaderboardSetsLocalizationsGetToManyRelated(id, fieldsGameCenterLeaderboardSetLocalizations, fieldsGameCenterLeaderboardSets, fieldsGameCenterLeaderboardSetImages, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterLive filter by attribute \&#39;live\&#39;
     * @param filterGameCenterDetail filter by id(s) of related \&#39;gameCenterDetail\&#39;
     * @param fieldsGameCenterLeaderboardSetReleases the fields to include for returned resources of type gameCenterLeaderboardSetReleases
     * @param fieldsGameCenterLeaderboardSets the fields to include for returned resources of type gameCenterLeaderboardSets
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public gameCenterLeaderboardSetsReleasesGetToManyRelatedWithHttpInfo(id: string, filterLive?: Array<string>, filterGameCenterDetail?: Array<string>, fieldsGameCenterLeaderboardSetReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboardSet' | 'live'>, fieldsGameCenterLeaderboardSets?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'referenceName' | 'releases' | 'vendorIdentifier'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, limit?: number, include?: Array<'gameCenterDetail' | 'gameCenterLeaderboardSet'>, _options?: Configuration): Promise<HttpInfo<GameCenterLeaderboardSetReleasesResponse>> {
        const result = this.api.gameCenterLeaderboardSetsReleasesGetToManyRelatedWithHttpInfo(id, filterLive, filterGameCenterDetail, fieldsGameCenterLeaderboardSetReleases, fieldsGameCenterLeaderboardSets, fieldsGameCenterDetails, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterLive filter by attribute \&#39;live\&#39;
     * @param filterGameCenterDetail filter by id(s) of related \&#39;gameCenterDetail\&#39;
     * @param fieldsGameCenterLeaderboardSetReleases the fields to include for returned resources of type gameCenterLeaderboardSetReleases
     * @param fieldsGameCenterLeaderboardSets the fields to include for returned resources of type gameCenterLeaderboardSets
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public gameCenterLeaderboardSetsReleasesGetToManyRelated(id: string, filterLive?: Array<string>, filterGameCenterDetail?: Array<string>, fieldsGameCenterLeaderboardSetReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboardSet' | 'live'>, fieldsGameCenterLeaderboardSets?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'referenceName' | 'releases' | 'vendorIdentifier'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, limit?: number, include?: Array<'gameCenterDetail' | 'gameCenterLeaderboardSet'>, _options?: Configuration): Promise<GameCenterLeaderboardSetReleasesResponse> {
        const result = this.api.gameCenterLeaderboardSetsReleasesGetToManyRelated(id, filterLive, filterGameCenterDetail, fieldsGameCenterLeaderboardSetReleases, fieldsGameCenterLeaderboardSets, fieldsGameCenterDetails, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterLeaderboardSetUpdateRequest GameCenterLeaderboardSet representation
     */
    public gameCenterLeaderboardSetsUpdateInstanceWithHttpInfo(id: string, gameCenterLeaderboardSetUpdateRequest: GameCenterLeaderboardSetUpdateRequest, _options?: Configuration): Promise<HttpInfo<GameCenterLeaderboardSetResponse>> {
        const result = this.api.gameCenterLeaderboardSetsUpdateInstanceWithHttpInfo(id, gameCenterLeaderboardSetUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterLeaderboardSetUpdateRequest GameCenterLeaderboardSet representation
     */
    public gameCenterLeaderboardSetsUpdateInstance(id: string, gameCenterLeaderboardSetUpdateRequest: GameCenterLeaderboardSetUpdateRequest, _options?: Configuration): Promise<GameCenterLeaderboardSetResponse> {
        const result = this.api.gameCenterLeaderboardSetsUpdateInstance(id, gameCenterLeaderboardSetUpdateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableGameCenterLeaderboardsApi } from './ObservableAPI.ts';

import { GameCenterLeaderboardsApiRequestFactory, GameCenterLeaderboardsApiResponseProcessor} from "../apis/GameCenterLeaderboardsApi.ts";
export class PromiseGameCenterLeaderboardsApi {
    private api: ObservableGameCenterLeaderboardsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: GameCenterLeaderboardsApiRequestFactory,
        responseProcessor?: GameCenterLeaderboardsApiResponseProcessor
    ) {
        this.api = new ObservableGameCenterLeaderboardsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param gameCenterLeaderboardCreateRequest GameCenterLeaderboard representation
     */
    public gameCenterLeaderboardsCreateInstanceWithHttpInfo(gameCenterLeaderboardCreateRequest: GameCenterLeaderboardCreateRequest, _options?: Configuration): Promise<HttpInfo<GameCenterLeaderboardResponse>> {
        const result = this.api.gameCenterLeaderboardsCreateInstanceWithHttpInfo(gameCenterLeaderboardCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param gameCenterLeaderboardCreateRequest GameCenterLeaderboard representation
     */
    public gameCenterLeaderboardsCreateInstance(gameCenterLeaderboardCreateRequest: GameCenterLeaderboardCreateRequest, _options?: Configuration): Promise<GameCenterLeaderboardResponse> {
        const result = this.api.gameCenterLeaderboardsCreateInstance(gameCenterLeaderboardCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterLeaderboardsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.gameCenterLeaderboardsDeleteInstanceWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterLeaderboardsDeleteInstance(id: string, _options?: Configuration): Promise<void> {
        const result = this.api.gameCenterLeaderboardsDeleteInstance(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     * @param include comma-separated list of relationships to include
     * @param fieldsGameCenterLeaderboardLocalizations the fields to include for returned resources of type gameCenterLeaderboardLocalizations
     * @param fieldsGameCenterLeaderboardReleases the fields to include for returned resources of type gameCenterLeaderboardReleases
     * @param limitGameCenterLeaderboardSets maximum number of related gameCenterLeaderboardSets returned (when they are included)
     * @param limitLocalizations maximum number of related localizations returned (when they are included)
     * @param limitReleases maximum number of related releases returned (when they are included)
     */
    public gameCenterLeaderboardsGetInstanceWithHttpInfo(id: string, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, include?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'releases'>, fieldsGameCenterLeaderboardLocalizations?: Array<'formatterOverride' | 'formatterSuffix' | 'formatterSuffixSingular' | 'gameCenterLeaderboard' | 'gameCenterLeaderboardImage' | 'locale' | 'name'>, fieldsGameCenterLeaderboardReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboard' | 'live'>, limitGameCenterLeaderboardSets?: number, limitLocalizations?: number, limitReleases?: number, _options?: Configuration): Promise<HttpInfo<GameCenterLeaderboardResponse>> {
        const result = this.api.gameCenterLeaderboardsGetInstanceWithHttpInfo(id, fieldsGameCenterLeaderboards, include, fieldsGameCenterLeaderboardLocalizations, fieldsGameCenterLeaderboardReleases, limitGameCenterLeaderboardSets, limitLocalizations, limitReleases, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     * @param include comma-separated list of relationships to include
     * @param fieldsGameCenterLeaderboardLocalizations the fields to include for returned resources of type gameCenterLeaderboardLocalizations
     * @param fieldsGameCenterLeaderboardReleases the fields to include for returned resources of type gameCenterLeaderboardReleases
     * @param limitGameCenterLeaderboardSets maximum number of related gameCenterLeaderboardSets returned (when they are included)
     * @param limitLocalizations maximum number of related localizations returned (when they are included)
     * @param limitReleases maximum number of related releases returned (when they are included)
     */
    public gameCenterLeaderboardsGetInstance(id: string, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, include?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'releases'>, fieldsGameCenterLeaderboardLocalizations?: Array<'formatterOverride' | 'formatterSuffix' | 'formatterSuffixSingular' | 'gameCenterLeaderboard' | 'gameCenterLeaderboardImage' | 'locale' | 'name'>, fieldsGameCenterLeaderboardReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboard' | 'live'>, limitGameCenterLeaderboardSets?: number, limitLocalizations?: number, limitReleases?: number, _options?: Configuration): Promise<GameCenterLeaderboardResponse> {
        const result = this.api.gameCenterLeaderboardsGetInstance(id, fieldsGameCenterLeaderboards, include, fieldsGameCenterLeaderboardLocalizations, fieldsGameCenterLeaderboardReleases, limitGameCenterLeaderboardSets, limitLocalizations, limitReleases, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterLeaderboardLocalizations the fields to include for returned resources of type gameCenterLeaderboardLocalizations
     * @param fieldsGameCenterLeaderboardSets the fields to include for returned resources of type gameCenterLeaderboardSets
     * @param fieldsGameCenterGroups the fields to include for returned resources of type gameCenterGroups
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     * @param fieldsGameCenterLeaderboardReleases the fields to include for returned resources of type gameCenterLeaderboardReleases
     * @param limitGameCenterLeaderboardSets maximum number of related gameCenterLeaderboardSets returned (when they are included)
     * @param limitLocalizations maximum number of related localizations returned (when they are included)
     * @param limitReleases maximum number of related releases returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public gameCenterLeaderboardsGroupLeaderboardGetToOneRelatedWithHttpInfo(id: string, fieldsGameCenterLeaderboardLocalizations?: Array<'formatterOverride' | 'formatterSuffix' | 'formatterSuffixSingular' | 'gameCenterLeaderboard' | 'gameCenterLeaderboardImage' | 'locale' | 'name'>, fieldsGameCenterLeaderboardSets?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'referenceName' | 'releases' | 'vendorIdentifier'>, fieldsGameCenterGroups?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'referenceName'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, fieldsGameCenterLeaderboardReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboard' | 'live'>, limitGameCenterLeaderboardSets?: number, limitLocalizations?: number, limitReleases?: number, include?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'releases'>, _options?: Configuration): Promise<HttpInfo<GameCenterLeaderboardResponse>> {
        const result = this.api.gameCenterLeaderboardsGroupLeaderboardGetToOneRelatedWithHttpInfo(id, fieldsGameCenterLeaderboardLocalizations, fieldsGameCenterLeaderboardSets, fieldsGameCenterGroups, fieldsGameCenterDetails, fieldsGameCenterLeaderboards, fieldsGameCenterLeaderboardReleases, limitGameCenterLeaderboardSets, limitLocalizations, limitReleases, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterLeaderboardLocalizations the fields to include for returned resources of type gameCenterLeaderboardLocalizations
     * @param fieldsGameCenterLeaderboardSets the fields to include for returned resources of type gameCenterLeaderboardSets
     * @param fieldsGameCenterGroups the fields to include for returned resources of type gameCenterGroups
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     * @param fieldsGameCenterLeaderboardReleases the fields to include for returned resources of type gameCenterLeaderboardReleases
     * @param limitGameCenterLeaderboardSets maximum number of related gameCenterLeaderboardSets returned (when they are included)
     * @param limitLocalizations maximum number of related localizations returned (when they are included)
     * @param limitReleases maximum number of related releases returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public gameCenterLeaderboardsGroupLeaderboardGetToOneRelated(id: string, fieldsGameCenterLeaderboardLocalizations?: Array<'formatterOverride' | 'formatterSuffix' | 'formatterSuffixSingular' | 'gameCenterLeaderboard' | 'gameCenterLeaderboardImage' | 'locale' | 'name'>, fieldsGameCenterLeaderboardSets?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboards' | 'groupLeaderboardSet' | 'localizations' | 'referenceName' | 'releases' | 'vendorIdentifier'>, fieldsGameCenterGroups?: Array<'gameCenterAchievements' | 'gameCenterDetails' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'referenceName'>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, fieldsGameCenterLeaderboardReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboard' | 'live'>, limitGameCenterLeaderboardSets?: number, limitLocalizations?: number, limitReleases?: number, include?: Array<'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'releases'>, _options?: Configuration): Promise<GameCenterLeaderboardResponse> {
        const result = this.api.gameCenterLeaderboardsGroupLeaderboardGetToOneRelated(id, fieldsGameCenterLeaderboardLocalizations, fieldsGameCenterLeaderboardSets, fieldsGameCenterGroups, fieldsGameCenterDetails, fieldsGameCenterLeaderboards, fieldsGameCenterLeaderboardReleases, limitGameCenterLeaderboardSets, limitLocalizations, limitReleases, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterLeaderboardsGroupLeaderboardGetToOneRelationshipWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<GameCenterLeaderboardGroupLeaderboardLinkageResponse>> {
        const result = this.api.gameCenterLeaderboardsGroupLeaderboardGetToOneRelationshipWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterLeaderboardsGroupLeaderboardGetToOneRelationship(id: string, _options?: Configuration): Promise<GameCenterLeaderboardGroupLeaderboardLinkageResponse> {
        const result = this.api.gameCenterLeaderboardsGroupLeaderboardGetToOneRelationship(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterLeaderboardGroupLeaderboardLinkageRequest Related linkage
     */
    public gameCenterLeaderboardsGroupLeaderboardUpdateToOneRelationshipWithHttpInfo(id: string, gameCenterLeaderboardGroupLeaderboardLinkageRequest: GameCenterLeaderboardGroupLeaderboardLinkageRequest, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.gameCenterLeaderboardsGroupLeaderboardUpdateToOneRelationshipWithHttpInfo(id, gameCenterLeaderboardGroupLeaderboardLinkageRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterLeaderboardGroupLeaderboardLinkageRequest Related linkage
     */
    public gameCenterLeaderboardsGroupLeaderboardUpdateToOneRelationship(id: string, gameCenterLeaderboardGroupLeaderboardLinkageRequest: GameCenterLeaderboardGroupLeaderboardLinkageRequest, _options?: Configuration): Promise<void> {
        const result = this.api.gameCenterLeaderboardsGroupLeaderboardUpdateToOneRelationship(id, gameCenterLeaderboardGroupLeaderboardLinkageRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterLeaderboardLocalizations the fields to include for returned resources of type gameCenterLeaderboardLocalizations
     * @param fieldsGameCenterLeaderboardImages the fields to include for returned resources of type gameCenterLeaderboardImages
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public gameCenterLeaderboardsLocalizationsGetToManyRelatedWithHttpInfo(id: string, fieldsGameCenterLeaderboardLocalizations?: Array<'formatterOverride' | 'formatterSuffix' | 'formatterSuffixSingular' | 'gameCenterLeaderboard' | 'gameCenterLeaderboardImage' | 'locale' | 'name'>, fieldsGameCenterLeaderboardImages?: Array<'assetDeliveryState' | 'fileName' | 'fileSize' | 'gameCenterLeaderboardLocalization' | 'imageAsset' | 'uploadOperations' | 'uploaded'>, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, limit?: number, include?: Array<'gameCenterLeaderboard' | 'gameCenterLeaderboardImage'>, _options?: Configuration): Promise<HttpInfo<GameCenterLeaderboardLocalizationsResponse>> {
        const result = this.api.gameCenterLeaderboardsLocalizationsGetToManyRelatedWithHttpInfo(id, fieldsGameCenterLeaderboardLocalizations, fieldsGameCenterLeaderboardImages, fieldsGameCenterLeaderboards, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterLeaderboardLocalizations the fields to include for returned resources of type gameCenterLeaderboardLocalizations
     * @param fieldsGameCenterLeaderboardImages the fields to include for returned resources of type gameCenterLeaderboardImages
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public gameCenterLeaderboardsLocalizationsGetToManyRelated(id: string, fieldsGameCenterLeaderboardLocalizations?: Array<'formatterOverride' | 'formatterSuffix' | 'formatterSuffixSingular' | 'gameCenterLeaderboard' | 'gameCenterLeaderboardImage' | 'locale' | 'name'>, fieldsGameCenterLeaderboardImages?: Array<'assetDeliveryState' | 'fileName' | 'fileSize' | 'gameCenterLeaderboardLocalization' | 'imageAsset' | 'uploadOperations' | 'uploaded'>, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, limit?: number, include?: Array<'gameCenterLeaderboard' | 'gameCenterLeaderboardImage'>, _options?: Configuration): Promise<GameCenterLeaderboardLocalizationsResponse> {
        const result = this.api.gameCenterLeaderboardsLocalizationsGetToManyRelated(id, fieldsGameCenterLeaderboardLocalizations, fieldsGameCenterLeaderboardImages, fieldsGameCenterLeaderboards, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterLive filter by attribute \&#39;live\&#39;
     * @param filterGameCenterDetail filter by id(s) of related \&#39;gameCenterDetail\&#39;
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     * @param fieldsGameCenterLeaderboardReleases the fields to include for returned resources of type gameCenterLeaderboardReleases
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public gameCenterLeaderboardsReleasesGetToManyRelatedWithHttpInfo(id: string, filterLive?: Array<string>, filterGameCenterDetail?: Array<string>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, fieldsGameCenterLeaderboardReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboard' | 'live'>, limit?: number, include?: Array<'gameCenterDetail' | 'gameCenterLeaderboard'>, _options?: Configuration): Promise<HttpInfo<GameCenterLeaderboardReleasesResponse>> {
        const result = this.api.gameCenterLeaderboardsReleasesGetToManyRelatedWithHttpInfo(id, filterLive, filterGameCenterDetail, fieldsGameCenterDetails, fieldsGameCenterLeaderboards, fieldsGameCenterLeaderboardReleases, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterLive filter by attribute \&#39;live\&#39;
     * @param filterGameCenterDetail filter by id(s) of related \&#39;gameCenterDetail\&#39;
     * @param fieldsGameCenterDetails the fields to include for returned resources of type gameCenterDetails
     * @param fieldsGameCenterLeaderboards the fields to include for returned resources of type gameCenterLeaderboards
     * @param fieldsGameCenterLeaderboardReleases the fields to include for returned resources of type gameCenterLeaderboardReleases
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public gameCenterLeaderboardsReleasesGetToManyRelated(id: string, filterLive?: Array<string>, filterGameCenterDetail?: Array<string>, fieldsGameCenterDetails?: Array<'achievementReleases' | 'app' | 'arcadeEnabled' | 'challengeEnabled' | 'defaultGroupLeaderboard' | 'defaultLeaderboard' | 'gameCenterAchievements' | 'gameCenterAppVersions' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'gameCenterLeaderboards' | 'leaderboardReleases' | 'leaderboardSetReleases'>, fieldsGameCenterLeaderboards?: Array<'archived' | 'defaultFormatter' | 'gameCenterDetail' | 'gameCenterGroup' | 'gameCenterLeaderboardSets' | 'groupLeaderboard' | 'localizations' | 'recurrenceDuration' | 'recurrenceRule' | 'recurrenceStartDate' | 'referenceName' | 'releases' | 'scoreRangeEnd' | 'scoreRangeStart' | 'scoreSortType' | 'submissionType' | 'vendorIdentifier'>, fieldsGameCenterLeaderboardReleases?: Array<'gameCenterDetail' | 'gameCenterLeaderboard' | 'live'>, limit?: number, include?: Array<'gameCenterDetail' | 'gameCenterLeaderboard'>, _options?: Configuration): Promise<GameCenterLeaderboardReleasesResponse> {
        const result = this.api.gameCenterLeaderboardsReleasesGetToManyRelated(id, filterLive, filterGameCenterDetail, fieldsGameCenterDetails, fieldsGameCenterLeaderboards, fieldsGameCenterLeaderboardReleases, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterLeaderboardUpdateRequest GameCenterLeaderboard representation
     */
    public gameCenterLeaderboardsUpdateInstanceWithHttpInfo(id: string, gameCenterLeaderboardUpdateRequest: GameCenterLeaderboardUpdateRequest, _options?: Configuration): Promise<HttpInfo<GameCenterLeaderboardResponse>> {
        const result = this.api.gameCenterLeaderboardsUpdateInstanceWithHttpInfo(id, gameCenterLeaderboardUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterLeaderboardUpdateRequest GameCenterLeaderboard representation
     */
    public gameCenterLeaderboardsUpdateInstance(id: string, gameCenterLeaderboardUpdateRequest: GameCenterLeaderboardUpdateRequest, _options?: Configuration): Promise<GameCenterLeaderboardResponse> {
        const result = this.api.gameCenterLeaderboardsUpdateInstance(id, gameCenterLeaderboardUpdateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableGameCenterMatchmakingQueuesApi } from './ObservableAPI.ts';

import { GameCenterMatchmakingQueuesApiRequestFactory, GameCenterMatchmakingQueuesApiResponseProcessor} from "../apis/GameCenterMatchmakingQueuesApi.ts";
export class PromiseGameCenterMatchmakingQueuesApi {
    private api: ObservableGameCenterMatchmakingQueuesApi

    public constructor(
        configuration: Configuration,
        requestFactory?: GameCenterMatchmakingQueuesApiRequestFactory,
        responseProcessor?: GameCenterMatchmakingQueuesApiResponseProcessor
    ) {
        this.api = new ObservableGameCenterMatchmakingQueuesApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param gameCenterMatchmakingQueueCreateRequest GameCenterMatchmakingQueue representation
     */
    public gameCenterMatchmakingQueuesCreateInstanceWithHttpInfo(gameCenterMatchmakingQueueCreateRequest: GameCenterMatchmakingQueueCreateRequest, _options?: Configuration): Promise<HttpInfo<GameCenterMatchmakingQueueResponse>> {
        const result = this.api.gameCenterMatchmakingQueuesCreateInstanceWithHttpInfo(gameCenterMatchmakingQueueCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param gameCenterMatchmakingQueueCreateRequest GameCenterMatchmakingQueue representation
     */
    public gameCenterMatchmakingQueuesCreateInstance(gameCenterMatchmakingQueueCreateRequest: GameCenterMatchmakingQueueCreateRequest, _options?: Configuration): Promise<GameCenterMatchmakingQueueResponse> {
        const result = this.api.gameCenterMatchmakingQueuesCreateInstance(gameCenterMatchmakingQueueCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterMatchmakingQueuesDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.gameCenterMatchmakingQueuesDeleteInstanceWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterMatchmakingQueuesDeleteInstance(id: string, _options?: Configuration): Promise<void> {
        const result = this.api.gameCenterMatchmakingQueuesDeleteInstance(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param granularity the granularity of the per-group dataset
     * @param limit maximum number of groups to return per page
     * @param sort comma-separated list of sort expressions; metrics will be sorted as specified
     */
    public gameCenterMatchmakingQueuesExperimentMatchmakingQueueSizesGetMetricsWithHttpInfo(id: string, granularity: 'P1D' | 'PT1H' | 'PT15M', limit?: number, sort?: Array<'averageNumberOfRequests' | '-averageNumberOfRequests' | 'count' | '-count' | 'p50NumberOfRequests' | '-p50NumberOfRequests' | 'p95NumberOfRequests' | '-p95NumberOfRequests'>, _options?: Configuration): Promise<HttpInfo<GameCenterMatchmakingQueueSizesV1MetricResponse>> {
        const result = this.api.gameCenterMatchmakingQueuesExperimentMatchmakingQueueSizesGetMetricsWithHttpInfo(id, granularity, limit, sort, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param granularity the granularity of the per-group dataset
     * @param limit maximum number of groups to return per page
     * @param sort comma-separated list of sort expressions; metrics will be sorted as specified
     */
    public gameCenterMatchmakingQueuesExperimentMatchmakingQueueSizesGetMetrics(id: string, granularity: 'P1D' | 'PT1H' | 'PT15M', limit?: number, sort?: Array<'averageNumberOfRequests' | '-averageNumberOfRequests' | 'count' | '-count' | 'p50NumberOfRequests' | '-p50NumberOfRequests' | 'p95NumberOfRequests' | '-p95NumberOfRequests'>, _options?: Configuration): Promise<GameCenterMatchmakingQueueSizesV1MetricResponse> {
        const result = this.api.gameCenterMatchmakingQueuesExperimentMatchmakingQueueSizesGetMetrics(id, granularity, limit, sort, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param granularity the granularity of the per-group dataset
     * @param limit maximum number of groups to return per page
     * @param groupBy the dimension by which to group the results
     * @param filterResult filter by \&#39;result\&#39; attribute dimension
     * @param filterGameCenterDetail filter by \&#39;gameCenterDetail\&#39; relationship dimension
     * @param sort comma-separated list of sort expressions; metrics will be sorted as specified
     */
    public gameCenterMatchmakingQueuesExperimentMatchmakingRequestsGetMetricsWithHttpInfo(id: string, granularity: 'P1D' | 'PT1H' | 'PT15M', limit?: number, groupBy?: Array<'gameCenterDetail' | 'result'>, filterResult?: 'MATCHED' | 'CANCELED' | 'EXPIRED', filterGameCenterDetail?: string, sort?: Array<'averageSecondsInQueue' | '-averageSecondsInQueue' | 'count' | '-count' | 'p50SecondsInQueue' | '-p50SecondsInQueue' | 'p95SecondsInQueue' | '-p95SecondsInQueue'>, _options?: Configuration): Promise<HttpInfo<GameCenterMatchmakingQueueRequestsV1MetricResponse>> {
        const result = this.api.gameCenterMatchmakingQueuesExperimentMatchmakingRequestsGetMetricsWithHttpInfo(id, granularity, limit, groupBy, filterResult, filterGameCenterDetail, sort, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param granularity the granularity of the per-group dataset
     * @param limit maximum number of groups to return per page
     * @param groupBy the dimension by which to group the results
     * @param filterResult filter by \&#39;result\&#39; attribute dimension
     * @param filterGameCenterDetail filter by \&#39;gameCenterDetail\&#39; relationship dimension
     * @param sort comma-separated list of sort expressions; metrics will be sorted as specified
     */
    public gameCenterMatchmakingQueuesExperimentMatchmakingRequestsGetMetrics(id: string, granularity: 'P1D' | 'PT1H' | 'PT15M', limit?: number, groupBy?: Array<'gameCenterDetail' | 'result'>, filterResult?: 'MATCHED' | 'CANCELED' | 'EXPIRED', filterGameCenterDetail?: string, sort?: Array<'averageSecondsInQueue' | '-averageSecondsInQueue' | 'count' | '-count' | 'p50SecondsInQueue' | '-p50SecondsInQueue' | 'p95SecondsInQueue' | '-p95SecondsInQueue'>, _options?: Configuration): Promise<GameCenterMatchmakingQueueRequestsV1MetricResponse> {
        const result = this.api.gameCenterMatchmakingQueuesExperimentMatchmakingRequestsGetMetrics(id, granularity, limit, groupBy, filterResult, filterGameCenterDetail, sort, _options);
        return result.toPromise();
    }

    /**
     * @param fieldsGameCenterMatchmakingQueues the fields to include for returned resources of type gameCenterMatchmakingQueues
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public gameCenterMatchmakingQueuesGetCollectionWithHttpInfo(fieldsGameCenterMatchmakingQueues?: Array<'classicMatchmakingBundleIds' | 'experimentRuleSet' | 'referenceName' | 'ruleSet'>, limit?: number, include?: Array<'experimentRuleSet' | 'ruleSet'>, _options?: Configuration): Promise<HttpInfo<GameCenterMatchmakingQueuesResponse>> {
        const result = this.api.gameCenterMatchmakingQueuesGetCollectionWithHttpInfo(fieldsGameCenterMatchmakingQueues, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param fieldsGameCenterMatchmakingQueues the fields to include for returned resources of type gameCenterMatchmakingQueues
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public gameCenterMatchmakingQueuesGetCollection(fieldsGameCenterMatchmakingQueues?: Array<'classicMatchmakingBundleIds' | 'experimentRuleSet' | 'referenceName' | 'ruleSet'>, limit?: number, include?: Array<'experimentRuleSet' | 'ruleSet'>, _options?: Configuration): Promise<GameCenterMatchmakingQueuesResponse> {
        const result = this.api.gameCenterMatchmakingQueuesGetCollection(fieldsGameCenterMatchmakingQueues, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterMatchmakingQueues the fields to include for returned resources of type gameCenterMatchmakingQueues
     * @param include comma-separated list of relationships to include
     */
    public gameCenterMatchmakingQueuesGetInstanceWithHttpInfo(id: string, fieldsGameCenterMatchmakingQueues?: Array<'classicMatchmakingBundleIds' | 'experimentRuleSet' | 'referenceName' | 'ruleSet'>, include?: Array<'experimentRuleSet' | 'ruleSet'>, _options?: Configuration): Promise<HttpInfo<GameCenterMatchmakingQueueResponse>> {
        const result = this.api.gameCenterMatchmakingQueuesGetInstanceWithHttpInfo(id, fieldsGameCenterMatchmakingQueues, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterMatchmakingQueues the fields to include for returned resources of type gameCenterMatchmakingQueues
     * @param include comma-separated list of relationships to include
     */
    public gameCenterMatchmakingQueuesGetInstance(id: string, fieldsGameCenterMatchmakingQueues?: Array<'classicMatchmakingBundleIds' | 'experimentRuleSet' | 'referenceName' | 'ruleSet'>, include?: Array<'experimentRuleSet' | 'ruleSet'>, _options?: Configuration): Promise<GameCenterMatchmakingQueueResponse> {
        const result = this.api.gameCenterMatchmakingQueuesGetInstance(id, fieldsGameCenterMatchmakingQueues, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param granularity the granularity of the per-group dataset
     * @param limit maximum number of groups to return per page
     * @param sort comma-separated list of sort expressions; metrics will be sorted as specified
     */
    public gameCenterMatchmakingQueuesMatchmakingQueueSizesGetMetricsWithHttpInfo(id: string, granularity: 'P1D' | 'PT1H' | 'PT15M', limit?: number, sort?: Array<'averageNumberOfRequests' | '-averageNumberOfRequests' | 'count' | '-count' | 'p50NumberOfRequests' | '-p50NumberOfRequests' | 'p95NumberOfRequests' | '-p95NumberOfRequests'>, _options?: Configuration): Promise<HttpInfo<GameCenterMatchmakingQueueSizesV1MetricResponse>> {
        const result = this.api.gameCenterMatchmakingQueuesMatchmakingQueueSizesGetMetricsWithHttpInfo(id, granularity, limit, sort, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param granularity the granularity of the per-group dataset
     * @param limit maximum number of groups to return per page
     * @param sort comma-separated list of sort expressions; metrics will be sorted as specified
     */
    public gameCenterMatchmakingQueuesMatchmakingQueueSizesGetMetrics(id: string, granularity: 'P1D' | 'PT1H' | 'PT15M', limit?: number, sort?: Array<'averageNumberOfRequests' | '-averageNumberOfRequests' | 'count' | '-count' | 'p50NumberOfRequests' | '-p50NumberOfRequests' | 'p95NumberOfRequests' | '-p95NumberOfRequests'>, _options?: Configuration): Promise<GameCenterMatchmakingQueueSizesV1MetricResponse> {
        const result = this.api.gameCenterMatchmakingQueuesMatchmakingQueueSizesGetMetrics(id, granularity, limit, sort, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param granularity the granularity of the per-group dataset
     * @param limit maximum number of groups to return per page
     * @param groupBy the dimension by which to group the results
     * @param filterResult filter by \&#39;result\&#39; attribute dimension
     * @param filterGameCenterDetail filter by \&#39;gameCenterDetail\&#39; relationship dimension
     * @param sort comma-separated list of sort expressions; metrics will be sorted as specified
     */
    public gameCenterMatchmakingQueuesMatchmakingRequestsGetMetricsWithHttpInfo(id: string, granularity: 'P1D' | 'PT1H' | 'PT15M', limit?: number, groupBy?: Array<'gameCenterDetail' | 'result'>, filterResult?: 'MATCHED' | 'CANCELED' | 'EXPIRED', filterGameCenterDetail?: string, sort?: Array<'averageSecondsInQueue' | '-averageSecondsInQueue' | 'count' | '-count' | 'p50SecondsInQueue' | '-p50SecondsInQueue' | 'p95SecondsInQueue' | '-p95SecondsInQueue'>, _options?: Configuration): Promise<HttpInfo<GameCenterMatchmakingQueueRequestsV1MetricResponse>> {
        const result = this.api.gameCenterMatchmakingQueuesMatchmakingRequestsGetMetricsWithHttpInfo(id, granularity, limit, groupBy, filterResult, filterGameCenterDetail, sort, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param granularity the granularity of the per-group dataset
     * @param limit maximum number of groups to return per page
     * @param groupBy the dimension by which to group the results
     * @param filterResult filter by \&#39;result\&#39; attribute dimension
     * @param filterGameCenterDetail filter by \&#39;gameCenterDetail\&#39; relationship dimension
     * @param sort comma-separated list of sort expressions; metrics will be sorted as specified
     */
    public gameCenterMatchmakingQueuesMatchmakingRequestsGetMetrics(id: string, granularity: 'P1D' | 'PT1H' | 'PT15M', limit?: number, groupBy?: Array<'gameCenterDetail' | 'result'>, filterResult?: 'MATCHED' | 'CANCELED' | 'EXPIRED', filterGameCenterDetail?: string, sort?: Array<'averageSecondsInQueue' | '-averageSecondsInQueue' | 'count' | '-count' | 'p50SecondsInQueue' | '-p50SecondsInQueue' | 'p95SecondsInQueue' | '-p95SecondsInQueue'>, _options?: Configuration): Promise<GameCenterMatchmakingQueueRequestsV1MetricResponse> {
        const result = this.api.gameCenterMatchmakingQueuesMatchmakingRequestsGetMetrics(id, granularity, limit, groupBy, filterResult, filterGameCenterDetail, sort, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param granularity the granularity of the per-group dataset
     * @param limit maximum number of groups to return per page
     * @param sort comma-separated list of sort expressions; metrics will be sorted as specified
     */
    public gameCenterMatchmakingQueuesMatchmakingSessionsGetMetricsWithHttpInfo(id: string, granularity: 'P1D' | 'PT1H' | 'PT15M', limit?: number, sort?: Array<'averagePlayerCount' | '-averagePlayerCount' | 'count' | '-count' | 'p50PlayerCount' | '-p50PlayerCount' | 'p95PlayerCount' | '-p95PlayerCount'>, _options?: Configuration): Promise<HttpInfo<GameCenterMatchmakingSessionsV1MetricResponse>> {
        const result = this.api.gameCenterMatchmakingQueuesMatchmakingSessionsGetMetricsWithHttpInfo(id, granularity, limit, sort, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param granularity the granularity of the per-group dataset
     * @param limit maximum number of groups to return per page
     * @param sort comma-separated list of sort expressions; metrics will be sorted as specified
     */
    public gameCenterMatchmakingQueuesMatchmakingSessionsGetMetrics(id: string, granularity: 'P1D' | 'PT1H' | 'PT15M', limit?: number, sort?: Array<'averagePlayerCount' | '-averagePlayerCount' | 'count' | '-count' | 'p50PlayerCount' | '-p50PlayerCount' | 'p95PlayerCount' | '-p95PlayerCount'>, _options?: Configuration): Promise<GameCenterMatchmakingSessionsV1MetricResponse> {
        const result = this.api.gameCenterMatchmakingQueuesMatchmakingSessionsGetMetrics(id, granularity, limit, sort, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterMatchmakingQueueUpdateRequest GameCenterMatchmakingQueue representation
     */
    public gameCenterMatchmakingQueuesUpdateInstanceWithHttpInfo(id: string, gameCenterMatchmakingQueueUpdateRequest: GameCenterMatchmakingQueueUpdateRequest, _options?: Configuration): Promise<HttpInfo<GameCenterMatchmakingQueueResponse>> {
        const result = this.api.gameCenterMatchmakingQueuesUpdateInstanceWithHttpInfo(id, gameCenterMatchmakingQueueUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterMatchmakingQueueUpdateRequest GameCenterMatchmakingQueue representation
     */
    public gameCenterMatchmakingQueuesUpdateInstance(id: string, gameCenterMatchmakingQueueUpdateRequest: GameCenterMatchmakingQueueUpdateRequest, _options?: Configuration): Promise<GameCenterMatchmakingQueueResponse> {
        const result = this.api.gameCenterMatchmakingQueuesUpdateInstance(id, gameCenterMatchmakingQueueUpdateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableGameCenterMatchmakingRuleSetTestsApi } from './ObservableAPI.ts';

import { GameCenterMatchmakingRuleSetTestsApiRequestFactory, GameCenterMatchmakingRuleSetTestsApiResponseProcessor} from "../apis/GameCenterMatchmakingRuleSetTestsApi.ts";
export class PromiseGameCenterMatchmakingRuleSetTestsApi {
    private api: ObservableGameCenterMatchmakingRuleSetTestsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: GameCenterMatchmakingRuleSetTestsApiRequestFactory,
        responseProcessor?: GameCenterMatchmakingRuleSetTestsApiResponseProcessor
    ) {
        this.api = new ObservableGameCenterMatchmakingRuleSetTestsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param gameCenterMatchmakingRuleSetTestCreateRequest GameCenterMatchmakingRuleSetTest representation
     */
    public gameCenterMatchmakingRuleSetTestsCreateInstanceWithHttpInfo(gameCenterMatchmakingRuleSetTestCreateRequest: GameCenterMatchmakingRuleSetTestCreateRequest, _options?: Configuration): Promise<HttpInfo<GameCenterMatchmakingRuleSetTestResponse>> {
        const result = this.api.gameCenterMatchmakingRuleSetTestsCreateInstanceWithHttpInfo(gameCenterMatchmakingRuleSetTestCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param gameCenterMatchmakingRuleSetTestCreateRequest GameCenterMatchmakingRuleSetTest representation
     */
    public gameCenterMatchmakingRuleSetTestsCreateInstance(gameCenterMatchmakingRuleSetTestCreateRequest: GameCenterMatchmakingRuleSetTestCreateRequest, _options?: Configuration): Promise<GameCenterMatchmakingRuleSetTestResponse> {
        const result = this.api.gameCenterMatchmakingRuleSetTestsCreateInstance(gameCenterMatchmakingRuleSetTestCreateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableGameCenterMatchmakingRuleSetsApi } from './ObservableAPI.ts';

import { GameCenterMatchmakingRuleSetsApiRequestFactory, GameCenterMatchmakingRuleSetsApiResponseProcessor} from "../apis/GameCenterMatchmakingRuleSetsApi.ts";
export class PromiseGameCenterMatchmakingRuleSetsApi {
    private api: ObservableGameCenterMatchmakingRuleSetsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: GameCenterMatchmakingRuleSetsApiRequestFactory,
        responseProcessor?: GameCenterMatchmakingRuleSetsApiResponseProcessor
    ) {
        this.api = new ObservableGameCenterMatchmakingRuleSetsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param gameCenterMatchmakingRuleSetCreateRequest GameCenterMatchmakingRuleSet representation
     */
    public gameCenterMatchmakingRuleSetsCreateInstanceWithHttpInfo(gameCenterMatchmakingRuleSetCreateRequest: GameCenterMatchmakingRuleSetCreateRequest, _options?: Configuration): Promise<HttpInfo<GameCenterMatchmakingRuleSetResponse>> {
        const result = this.api.gameCenterMatchmakingRuleSetsCreateInstanceWithHttpInfo(gameCenterMatchmakingRuleSetCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param gameCenterMatchmakingRuleSetCreateRequest GameCenterMatchmakingRuleSet representation
     */
    public gameCenterMatchmakingRuleSetsCreateInstance(gameCenterMatchmakingRuleSetCreateRequest: GameCenterMatchmakingRuleSetCreateRequest, _options?: Configuration): Promise<GameCenterMatchmakingRuleSetResponse> {
        const result = this.api.gameCenterMatchmakingRuleSetsCreateInstance(gameCenterMatchmakingRuleSetCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterMatchmakingRuleSetsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.gameCenterMatchmakingRuleSetsDeleteInstanceWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterMatchmakingRuleSetsDeleteInstance(id: string, _options?: Configuration): Promise<void> {
        const result = this.api.gameCenterMatchmakingRuleSetsDeleteInstance(id, _options);
        return result.toPromise();
    }

    /**
     * @param fieldsGameCenterMatchmakingRuleSets the fields to include for returned resources of type gameCenterMatchmakingRuleSets
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsGameCenterMatchmakingQueues the fields to include for returned resources of type gameCenterMatchmakingQueues
     * @param fieldsGameCenterMatchmakingTeams the fields to include for returned resources of type gameCenterMatchmakingTeams
     * @param fieldsGameCenterMatchmakingRules the fields to include for returned resources of type gameCenterMatchmakingRules
     * @param limitMatchmakingQueues maximum number of related matchmakingQueues returned (when they are included)
     * @param limitRules maximum number of related rules returned (when they are included)
     * @param limitTeams maximum number of related teams returned (when they are included)
     */
    public gameCenterMatchmakingRuleSetsGetCollectionWithHttpInfo(fieldsGameCenterMatchmakingRuleSets?: Array<'matchmakingQueues' | 'maxPlayers' | 'minPlayers' | 'referenceName' | 'ruleLanguageVersion' | 'rules' | 'teams'>, limit?: number, include?: Array<'matchmakingQueues' | 'rules' | 'teams'>, fieldsGameCenterMatchmakingQueues?: Array<'classicMatchmakingBundleIds' | 'experimentRuleSet' | 'referenceName' | 'ruleSet'>, fieldsGameCenterMatchmakingTeams?: Array<'maxPlayers' | 'minPlayers' | 'referenceName' | 'ruleSet'>, fieldsGameCenterMatchmakingRules?: Array<'description' | 'expression' | 'referenceName' | 'ruleSet' | 'type' | 'weight'>, limitMatchmakingQueues?: number, limitRules?: number, limitTeams?: number, _options?: Configuration): Promise<HttpInfo<GameCenterMatchmakingRuleSetsResponse>> {
        const result = this.api.gameCenterMatchmakingRuleSetsGetCollectionWithHttpInfo(fieldsGameCenterMatchmakingRuleSets, limit, include, fieldsGameCenterMatchmakingQueues, fieldsGameCenterMatchmakingTeams, fieldsGameCenterMatchmakingRules, limitMatchmakingQueues, limitRules, limitTeams, _options);
        return result.toPromise();
    }

    /**
     * @param fieldsGameCenterMatchmakingRuleSets the fields to include for returned resources of type gameCenterMatchmakingRuleSets
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsGameCenterMatchmakingQueues the fields to include for returned resources of type gameCenterMatchmakingQueues
     * @param fieldsGameCenterMatchmakingTeams the fields to include for returned resources of type gameCenterMatchmakingTeams
     * @param fieldsGameCenterMatchmakingRules the fields to include for returned resources of type gameCenterMatchmakingRules
     * @param limitMatchmakingQueues maximum number of related matchmakingQueues returned (when they are included)
     * @param limitRules maximum number of related rules returned (when they are included)
     * @param limitTeams maximum number of related teams returned (when they are included)
     */
    public gameCenterMatchmakingRuleSetsGetCollection(fieldsGameCenterMatchmakingRuleSets?: Array<'matchmakingQueues' | 'maxPlayers' | 'minPlayers' | 'referenceName' | 'ruleLanguageVersion' | 'rules' | 'teams'>, limit?: number, include?: Array<'matchmakingQueues' | 'rules' | 'teams'>, fieldsGameCenterMatchmakingQueues?: Array<'classicMatchmakingBundleIds' | 'experimentRuleSet' | 'referenceName' | 'ruleSet'>, fieldsGameCenterMatchmakingTeams?: Array<'maxPlayers' | 'minPlayers' | 'referenceName' | 'ruleSet'>, fieldsGameCenterMatchmakingRules?: Array<'description' | 'expression' | 'referenceName' | 'ruleSet' | 'type' | 'weight'>, limitMatchmakingQueues?: number, limitRules?: number, limitTeams?: number, _options?: Configuration): Promise<GameCenterMatchmakingRuleSetsResponse> {
        const result = this.api.gameCenterMatchmakingRuleSetsGetCollection(fieldsGameCenterMatchmakingRuleSets, limit, include, fieldsGameCenterMatchmakingQueues, fieldsGameCenterMatchmakingTeams, fieldsGameCenterMatchmakingRules, limitMatchmakingQueues, limitRules, limitTeams, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterMatchmakingRuleSets the fields to include for returned resources of type gameCenterMatchmakingRuleSets
     * @param include comma-separated list of relationships to include
     * @param fieldsGameCenterMatchmakingQueues the fields to include for returned resources of type gameCenterMatchmakingQueues
     * @param fieldsGameCenterMatchmakingTeams the fields to include for returned resources of type gameCenterMatchmakingTeams
     * @param fieldsGameCenterMatchmakingRules the fields to include for returned resources of type gameCenterMatchmakingRules
     * @param limitMatchmakingQueues maximum number of related matchmakingQueues returned (when they are included)
     * @param limitRules maximum number of related rules returned (when they are included)
     * @param limitTeams maximum number of related teams returned (when they are included)
     */
    public gameCenterMatchmakingRuleSetsGetInstanceWithHttpInfo(id: string, fieldsGameCenterMatchmakingRuleSets?: Array<'matchmakingQueues' | 'maxPlayers' | 'minPlayers' | 'referenceName' | 'ruleLanguageVersion' | 'rules' | 'teams'>, include?: Array<'matchmakingQueues' | 'rules' | 'teams'>, fieldsGameCenterMatchmakingQueues?: Array<'classicMatchmakingBundleIds' | 'experimentRuleSet' | 'referenceName' | 'ruleSet'>, fieldsGameCenterMatchmakingTeams?: Array<'maxPlayers' | 'minPlayers' | 'referenceName' | 'ruleSet'>, fieldsGameCenterMatchmakingRules?: Array<'description' | 'expression' | 'referenceName' | 'ruleSet' | 'type' | 'weight'>, limitMatchmakingQueues?: number, limitRules?: number, limitTeams?: number, _options?: Configuration): Promise<HttpInfo<GameCenterMatchmakingRuleSetResponse>> {
        const result = this.api.gameCenterMatchmakingRuleSetsGetInstanceWithHttpInfo(id, fieldsGameCenterMatchmakingRuleSets, include, fieldsGameCenterMatchmakingQueues, fieldsGameCenterMatchmakingTeams, fieldsGameCenterMatchmakingRules, limitMatchmakingQueues, limitRules, limitTeams, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterMatchmakingRuleSets the fields to include for returned resources of type gameCenterMatchmakingRuleSets
     * @param include comma-separated list of relationships to include
     * @param fieldsGameCenterMatchmakingQueues the fields to include for returned resources of type gameCenterMatchmakingQueues
     * @param fieldsGameCenterMatchmakingTeams the fields to include for returned resources of type gameCenterMatchmakingTeams
     * @param fieldsGameCenterMatchmakingRules the fields to include for returned resources of type gameCenterMatchmakingRules
     * @param limitMatchmakingQueues maximum number of related matchmakingQueues returned (when they are included)
     * @param limitRules maximum number of related rules returned (when they are included)
     * @param limitTeams maximum number of related teams returned (when they are included)
     */
    public gameCenterMatchmakingRuleSetsGetInstance(id: string, fieldsGameCenterMatchmakingRuleSets?: Array<'matchmakingQueues' | 'maxPlayers' | 'minPlayers' | 'referenceName' | 'ruleLanguageVersion' | 'rules' | 'teams'>, include?: Array<'matchmakingQueues' | 'rules' | 'teams'>, fieldsGameCenterMatchmakingQueues?: Array<'classicMatchmakingBundleIds' | 'experimentRuleSet' | 'referenceName' | 'ruleSet'>, fieldsGameCenterMatchmakingTeams?: Array<'maxPlayers' | 'minPlayers' | 'referenceName' | 'ruleSet'>, fieldsGameCenterMatchmakingRules?: Array<'description' | 'expression' | 'referenceName' | 'ruleSet' | 'type' | 'weight'>, limitMatchmakingQueues?: number, limitRules?: number, limitTeams?: number, _options?: Configuration): Promise<GameCenterMatchmakingRuleSetResponse> {
        const result = this.api.gameCenterMatchmakingRuleSetsGetInstance(id, fieldsGameCenterMatchmakingRuleSets, include, fieldsGameCenterMatchmakingQueues, fieldsGameCenterMatchmakingTeams, fieldsGameCenterMatchmakingRules, limitMatchmakingQueues, limitRules, limitTeams, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterMatchmakingQueues the fields to include for returned resources of type gameCenterMatchmakingQueues
     * @param fieldsGameCenterMatchmakingRuleSets the fields to include for returned resources of type gameCenterMatchmakingRuleSets
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public gameCenterMatchmakingRuleSetsMatchmakingQueuesGetToManyRelatedWithHttpInfo(id: string, fieldsGameCenterMatchmakingQueues?: Array<'classicMatchmakingBundleIds' | 'experimentRuleSet' | 'referenceName' | 'ruleSet'>, fieldsGameCenterMatchmakingRuleSets?: Array<'matchmakingQueues' | 'maxPlayers' | 'minPlayers' | 'referenceName' | 'ruleLanguageVersion' | 'rules' | 'teams'>, limit?: number, include?: Array<'experimentRuleSet' | 'ruleSet'>, _options?: Configuration): Promise<HttpInfo<GameCenterMatchmakingQueuesResponse>> {
        const result = this.api.gameCenterMatchmakingRuleSetsMatchmakingQueuesGetToManyRelatedWithHttpInfo(id, fieldsGameCenterMatchmakingQueues, fieldsGameCenterMatchmakingRuleSets, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterMatchmakingQueues the fields to include for returned resources of type gameCenterMatchmakingQueues
     * @param fieldsGameCenterMatchmakingRuleSets the fields to include for returned resources of type gameCenterMatchmakingRuleSets
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public gameCenterMatchmakingRuleSetsMatchmakingQueuesGetToManyRelated(id: string, fieldsGameCenterMatchmakingQueues?: Array<'classicMatchmakingBundleIds' | 'experimentRuleSet' | 'referenceName' | 'ruleSet'>, fieldsGameCenterMatchmakingRuleSets?: Array<'matchmakingQueues' | 'maxPlayers' | 'minPlayers' | 'referenceName' | 'ruleLanguageVersion' | 'rules' | 'teams'>, limit?: number, include?: Array<'experimentRuleSet' | 'ruleSet'>, _options?: Configuration): Promise<GameCenterMatchmakingQueuesResponse> {
        const result = this.api.gameCenterMatchmakingRuleSetsMatchmakingQueuesGetToManyRelated(id, fieldsGameCenterMatchmakingQueues, fieldsGameCenterMatchmakingRuleSets, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterMatchmakingRules the fields to include for returned resources of type gameCenterMatchmakingRules
     * @param limit maximum resources per page
     */
    public gameCenterMatchmakingRuleSetsRulesGetToManyRelatedWithHttpInfo(id: string, fieldsGameCenterMatchmakingRules?: Array<'description' | 'expression' | 'referenceName' | 'ruleSet' | 'type' | 'weight'>, limit?: number, _options?: Configuration): Promise<HttpInfo<GameCenterMatchmakingRulesResponse>> {
        const result = this.api.gameCenterMatchmakingRuleSetsRulesGetToManyRelatedWithHttpInfo(id, fieldsGameCenterMatchmakingRules, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterMatchmakingRules the fields to include for returned resources of type gameCenterMatchmakingRules
     * @param limit maximum resources per page
     */
    public gameCenterMatchmakingRuleSetsRulesGetToManyRelated(id: string, fieldsGameCenterMatchmakingRules?: Array<'description' | 'expression' | 'referenceName' | 'ruleSet' | 'type' | 'weight'>, limit?: number, _options?: Configuration): Promise<GameCenterMatchmakingRulesResponse> {
        const result = this.api.gameCenterMatchmakingRuleSetsRulesGetToManyRelated(id, fieldsGameCenterMatchmakingRules, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterMatchmakingTeams the fields to include for returned resources of type gameCenterMatchmakingTeams
     * @param limit maximum resources per page
     */
    public gameCenterMatchmakingRuleSetsTeamsGetToManyRelatedWithHttpInfo(id: string, fieldsGameCenterMatchmakingTeams?: Array<'maxPlayers' | 'minPlayers' | 'referenceName' | 'ruleSet'>, limit?: number, _options?: Configuration): Promise<HttpInfo<GameCenterMatchmakingTeamsResponse>> {
        const result = this.api.gameCenterMatchmakingRuleSetsTeamsGetToManyRelatedWithHttpInfo(id, fieldsGameCenterMatchmakingTeams, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsGameCenterMatchmakingTeams the fields to include for returned resources of type gameCenterMatchmakingTeams
     * @param limit maximum resources per page
     */
    public gameCenterMatchmakingRuleSetsTeamsGetToManyRelated(id: string, fieldsGameCenterMatchmakingTeams?: Array<'maxPlayers' | 'minPlayers' | 'referenceName' | 'ruleSet'>, limit?: number, _options?: Configuration): Promise<GameCenterMatchmakingTeamsResponse> {
        const result = this.api.gameCenterMatchmakingRuleSetsTeamsGetToManyRelated(id, fieldsGameCenterMatchmakingTeams, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterMatchmakingRuleSetUpdateRequest GameCenterMatchmakingRuleSet representation
     */
    public gameCenterMatchmakingRuleSetsUpdateInstanceWithHttpInfo(id: string, gameCenterMatchmakingRuleSetUpdateRequest: GameCenterMatchmakingRuleSetUpdateRequest, _options?: Configuration): Promise<HttpInfo<GameCenterMatchmakingRuleSetResponse>> {
        const result = this.api.gameCenterMatchmakingRuleSetsUpdateInstanceWithHttpInfo(id, gameCenterMatchmakingRuleSetUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterMatchmakingRuleSetUpdateRequest GameCenterMatchmakingRuleSet representation
     */
    public gameCenterMatchmakingRuleSetsUpdateInstance(id: string, gameCenterMatchmakingRuleSetUpdateRequest: GameCenterMatchmakingRuleSetUpdateRequest, _options?: Configuration): Promise<GameCenterMatchmakingRuleSetResponse> {
        const result = this.api.gameCenterMatchmakingRuleSetsUpdateInstance(id, gameCenterMatchmakingRuleSetUpdateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableGameCenterMatchmakingRulesApi } from './ObservableAPI.ts';

import { GameCenterMatchmakingRulesApiRequestFactory, GameCenterMatchmakingRulesApiResponseProcessor} from "../apis/GameCenterMatchmakingRulesApi.ts";
export class PromiseGameCenterMatchmakingRulesApi {
    private api: ObservableGameCenterMatchmakingRulesApi

    public constructor(
        configuration: Configuration,
        requestFactory?: GameCenterMatchmakingRulesApiRequestFactory,
        responseProcessor?: GameCenterMatchmakingRulesApiResponseProcessor
    ) {
        this.api = new ObservableGameCenterMatchmakingRulesApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param gameCenterMatchmakingRuleCreateRequest GameCenterMatchmakingRule representation
     */
    public gameCenterMatchmakingRulesCreateInstanceWithHttpInfo(gameCenterMatchmakingRuleCreateRequest: GameCenterMatchmakingRuleCreateRequest, _options?: Configuration): Promise<HttpInfo<GameCenterMatchmakingRuleResponse>> {
        const result = this.api.gameCenterMatchmakingRulesCreateInstanceWithHttpInfo(gameCenterMatchmakingRuleCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param gameCenterMatchmakingRuleCreateRequest GameCenterMatchmakingRule representation
     */
    public gameCenterMatchmakingRulesCreateInstance(gameCenterMatchmakingRuleCreateRequest: GameCenterMatchmakingRuleCreateRequest, _options?: Configuration): Promise<GameCenterMatchmakingRuleResponse> {
        const result = this.api.gameCenterMatchmakingRulesCreateInstance(gameCenterMatchmakingRuleCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterMatchmakingRulesDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.gameCenterMatchmakingRulesDeleteInstanceWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterMatchmakingRulesDeleteInstance(id: string, _options?: Configuration): Promise<void> {
        const result = this.api.gameCenterMatchmakingRulesDeleteInstance(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param granularity the granularity of the per-group dataset
     * @param limit maximum number of groups to return per page
     * @param groupBy the dimension by which to group the results
     * @param filterResult filter by \&#39;result\&#39; attribute dimension
     * @param filterGameCenterMatchmakingQueue filter by \&#39;gameCenterMatchmakingQueue\&#39; relationship dimension
     * @param sort comma-separated list of sort expressions; metrics will be sorted as specified
     */
    public gameCenterMatchmakingRulesMatchmakingBooleanRuleResultsGetMetricsWithHttpInfo(id: string, granularity: 'P1D' | 'PT1H' | 'PT15M', limit?: number, groupBy?: Array<'gameCenterMatchmakingQueue' | 'result'>, filterResult?: string, filterGameCenterMatchmakingQueue?: string, sort?: Array<'count' | '-count'>, _options?: Configuration): Promise<HttpInfo<GameCenterMatchmakingBooleanRuleResultsV1MetricResponse>> {
        const result = this.api.gameCenterMatchmakingRulesMatchmakingBooleanRuleResultsGetMetricsWithHttpInfo(id, granularity, limit, groupBy, filterResult, filterGameCenterMatchmakingQueue, sort, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param granularity the granularity of the per-group dataset
     * @param limit maximum number of groups to return per page
     * @param groupBy the dimension by which to group the results
     * @param filterResult filter by \&#39;result\&#39; attribute dimension
     * @param filterGameCenterMatchmakingQueue filter by \&#39;gameCenterMatchmakingQueue\&#39; relationship dimension
     * @param sort comma-separated list of sort expressions; metrics will be sorted as specified
     */
    public gameCenterMatchmakingRulesMatchmakingBooleanRuleResultsGetMetrics(id: string, granularity: 'P1D' | 'PT1H' | 'PT15M', limit?: number, groupBy?: Array<'gameCenterMatchmakingQueue' | 'result'>, filterResult?: string, filterGameCenterMatchmakingQueue?: string, sort?: Array<'count' | '-count'>, _options?: Configuration): Promise<GameCenterMatchmakingBooleanRuleResultsV1MetricResponse> {
        const result = this.api.gameCenterMatchmakingRulesMatchmakingBooleanRuleResultsGetMetrics(id, granularity, limit, groupBy, filterResult, filterGameCenterMatchmakingQueue, sort, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param granularity the granularity of the per-group dataset
     * @param limit maximum number of groups to return per page
     * @param groupBy the dimension by which to group the results
     * @param filterGameCenterMatchmakingQueue filter by \&#39;gameCenterMatchmakingQueue\&#39; relationship dimension
     * @param sort comma-separated list of sort expressions; metrics will be sorted as specified
     */
    public gameCenterMatchmakingRulesMatchmakingNumberRuleResultsGetMetricsWithHttpInfo(id: string, granularity: 'P1D' | 'PT1H' | 'PT15M', limit?: number, groupBy?: Array<'gameCenterMatchmakingQueue'>, filterGameCenterMatchmakingQueue?: string, sort?: Array<'averageResult' | '-averageResult' | 'count' | '-count' | 'p50Result' | '-p50Result' | 'p95Result' | '-p95Result'>, _options?: Configuration): Promise<HttpInfo<GameCenterMatchmakingNumberRuleResultsV1MetricResponse>> {
        const result = this.api.gameCenterMatchmakingRulesMatchmakingNumberRuleResultsGetMetricsWithHttpInfo(id, granularity, limit, groupBy, filterGameCenterMatchmakingQueue, sort, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param granularity the granularity of the per-group dataset
     * @param limit maximum number of groups to return per page
     * @param groupBy the dimension by which to group the results
     * @param filterGameCenterMatchmakingQueue filter by \&#39;gameCenterMatchmakingQueue\&#39; relationship dimension
     * @param sort comma-separated list of sort expressions; metrics will be sorted as specified
     */
    public gameCenterMatchmakingRulesMatchmakingNumberRuleResultsGetMetrics(id: string, granularity: 'P1D' | 'PT1H' | 'PT15M', limit?: number, groupBy?: Array<'gameCenterMatchmakingQueue'>, filterGameCenterMatchmakingQueue?: string, sort?: Array<'averageResult' | '-averageResult' | 'count' | '-count' | 'p50Result' | '-p50Result' | 'p95Result' | '-p95Result'>, _options?: Configuration): Promise<GameCenterMatchmakingNumberRuleResultsV1MetricResponse> {
        const result = this.api.gameCenterMatchmakingRulesMatchmakingNumberRuleResultsGetMetrics(id, granularity, limit, groupBy, filterGameCenterMatchmakingQueue, sort, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param granularity the granularity of the per-group dataset
     * @param limit maximum number of groups to return per page
     * @param groupBy the dimension by which to group the results
     * @param filterGameCenterMatchmakingQueue filter by \&#39;gameCenterMatchmakingQueue\&#39; relationship dimension
     * @param sort comma-separated list of sort expressions; metrics will be sorted as specified
     */
    public gameCenterMatchmakingRulesMatchmakingRuleErrorsGetMetricsWithHttpInfo(id: string, granularity: 'P1D' | 'PT1H' | 'PT15M', limit?: number, groupBy?: Array<'gameCenterMatchmakingQueue'>, filterGameCenterMatchmakingQueue?: string, sort?: Array<'count' | '-count'>, _options?: Configuration): Promise<HttpInfo<GameCenterMatchmakingRuleErrorsV1MetricResponse>> {
        const result = this.api.gameCenterMatchmakingRulesMatchmakingRuleErrorsGetMetricsWithHttpInfo(id, granularity, limit, groupBy, filterGameCenterMatchmakingQueue, sort, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param granularity the granularity of the per-group dataset
     * @param limit maximum number of groups to return per page
     * @param groupBy the dimension by which to group the results
     * @param filterGameCenterMatchmakingQueue filter by \&#39;gameCenterMatchmakingQueue\&#39; relationship dimension
     * @param sort comma-separated list of sort expressions; metrics will be sorted as specified
     */
    public gameCenterMatchmakingRulesMatchmakingRuleErrorsGetMetrics(id: string, granularity: 'P1D' | 'PT1H' | 'PT15M', limit?: number, groupBy?: Array<'gameCenterMatchmakingQueue'>, filterGameCenterMatchmakingQueue?: string, sort?: Array<'count' | '-count'>, _options?: Configuration): Promise<GameCenterMatchmakingRuleErrorsV1MetricResponse> {
        const result = this.api.gameCenterMatchmakingRulesMatchmakingRuleErrorsGetMetrics(id, granularity, limit, groupBy, filterGameCenterMatchmakingQueue, sort, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterMatchmakingRuleUpdateRequest GameCenterMatchmakingRule representation
     */
    public gameCenterMatchmakingRulesUpdateInstanceWithHttpInfo(id: string, gameCenterMatchmakingRuleUpdateRequest: GameCenterMatchmakingRuleUpdateRequest, _options?: Configuration): Promise<HttpInfo<GameCenterMatchmakingRuleResponse>> {
        const result = this.api.gameCenterMatchmakingRulesUpdateInstanceWithHttpInfo(id, gameCenterMatchmakingRuleUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterMatchmakingRuleUpdateRequest GameCenterMatchmakingRule representation
     */
    public gameCenterMatchmakingRulesUpdateInstance(id: string, gameCenterMatchmakingRuleUpdateRequest: GameCenterMatchmakingRuleUpdateRequest, _options?: Configuration): Promise<GameCenterMatchmakingRuleResponse> {
        const result = this.api.gameCenterMatchmakingRulesUpdateInstance(id, gameCenterMatchmakingRuleUpdateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableGameCenterMatchmakingTeamsApi } from './ObservableAPI.ts';

import { GameCenterMatchmakingTeamsApiRequestFactory, GameCenterMatchmakingTeamsApiResponseProcessor} from "../apis/GameCenterMatchmakingTeamsApi.ts";
export class PromiseGameCenterMatchmakingTeamsApi {
    private api: ObservableGameCenterMatchmakingTeamsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: GameCenterMatchmakingTeamsApiRequestFactory,
        responseProcessor?: GameCenterMatchmakingTeamsApiResponseProcessor
    ) {
        this.api = new ObservableGameCenterMatchmakingTeamsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param gameCenterMatchmakingTeamCreateRequest GameCenterMatchmakingTeam representation
     */
    public gameCenterMatchmakingTeamsCreateInstanceWithHttpInfo(gameCenterMatchmakingTeamCreateRequest: GameCenterMatchmakingTeamCreateRequest, _options?: Configuration): Promise<HttpInfo<GameCenterMatchmakingTeamResponse>> {
        const result = this.api.gameCenterMatchmakingTeamsCreateInstanceWithHttpInfo(gameCenterMatchmakingTeamCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param gameCenterMatchmakingTeamCreateRequest GameCenterMatchmakingTeam representation
     */
    public gameCenterMatchmakingTeamsCreateInstance(gameCenterMatchmakingTeamCreateRequest: GameCenterMatchmakingTeamCreateRequest, _options?: Configuration): Promise<GameCenterMatchmakingTeamResponse> {
        const result = this.api.gameCenterMatchmakingTeamsCreateInstance(gameCenterMatchmakingTeamCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterMatchmakingTeamsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.gameCenterMatchmakingTeamsDeleteInstanceWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public gameCenterMatchmakingTeamsDeleteInstance(id: string, _options?: Configuration): Promise<void> {
        const result = this.api.gameCenterMatchmakingTeamsDeleteInstance(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterMatchmakingTeamUpdateRequest GameCenterMatchmakingTeam representation
     */
    public gameCenterMatchmakingTeamsUpdateInstanceWithHttpInfo(id: string, gameCenterMatchmakingTeamUpdateRequest: GameCenterMatchmakingTeamUpdateRequest, _options?: Configuration): Promise<HttpInfo<GameCenterMatchmakingTeamResponse>> {
        const result = this.api.gameCenterMatchmakingTeamsUpdateInstanceWithHttpInfo(id, gameCenterMatchmakingTeamUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param gameCenterMatchmakingTeamUpdateRequest GameCenterMatchmakingTeam representation
     */
    public gameCenterMatchmakingTeamsUpdateInstance(id: string, gameCenterMatchmakingTeamUpdateRequest: GameCenterMatchmakingTeamUpdateRequest, _options?: Configuration): Promise<GameCenterMatchmakingTeamResponse> {
        const result = this.api.gameCenterMatchmakingTeamsUpdateInstance(id, gameCenterMatchmakingTeamUpdateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableGameCenterPlayerAchievementSubmissionsApi } from './ObservableAPI.ts';

import { GameCenterPlayerAchievementSubmissionsApiRequestFactory, GameCenterPlayerAchievementSubmissionsApiResponseProcessor} from "../apis/GameCenterPlayerAchievementSubmissionsApi.ts";
export class PromiseGameCenterPlayerAchievementSubmissionsApi {
    private api: ObservableGameCenterPlayerAchievementSubmissionsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: GameCenterPlayerAchievementSubmissionsApiRequestFactory,
        responseProcessor?: GameCenterPlayerAchievementSubmissionsApiResponseProcessor
    ) {
        this.api = new ObservableGameCenterPlayerAchievementSubmissionsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param gameCenterPlayerAchievementSubmissionCreateRequest GameCenterPlayerAchievementSubmission representation
     */
    public gameCenterPlayerAchievementSubmissionsCreateInstanceWithHttpInfo(gameCenterPlayerAchievementSubmissionCreateRequest: GameCenterPlayerAchievementSubmissionCreateRequest, _options?: Configuration): Promise<HttpInfo<GameCenterPlayerAchievementSubmissionResponse>> {
        const result = this.api.gameCenterPlayerAchievementSubmissionsCreateInstanceWithHttpInfo(gameCenterPlayerAchievementSubmissionCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param gameCenterPlayerAchievementSubmissionCreateRequest GameCenterPlayerAchievementSubmission representation
     */
    public gameCenterPlayerAchievementSubmissionsCreateInstance(gameCenterPlayerAchievementSubmissionCreateRequest: GameCenterPlayerAchievementSubmissionCreateRequest, _options?: Configuration): Promise<GameCenterPlayerAchievementSubmissionResponse> {
        const result = this.api.gameCenterPlayerAchievementSubmissionsCreateInstance(gameCenterPlayerAchievementSubmissionCreateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableInAppPurchaseAppStoreReviewScreenshotsApi } from './ObservableAPI.ts';

import { InAppPurchaseAppStoreReviewScreenshotsApiRequestFactory, InAppPurchaseAppStoreReviewScreenshotsApiResponseProcessor} from "../apis/InAppPurchaseAppStoreReviewScreenshotsApi.ts";
export class PromiseInAppPurchaseAppStoreReviewScreenshotsApi {
    private api: ObservableInAppPurchaseAppStoreReviewScreenshotsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: InAppPurchaseAppStoreReviewScreenshotsApiRequestFactory,
        responseProcessor?: InAppPurchaseAppStoreReviewScreenshotsApiResponseProcessor
    ) {
        this.api = new ObservableInAppPurchaseAppStoreReviewScreenshotsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param inAppPurchaseAppStoreReviewScreenshotCreateRequest InAppPurchaseAppStoreReviewScreenshot representation
     */
    public inAppPurchaseAppStoreReviewScreenshotsCreateInstanceWithHttpInfo(inAppPurchaseAppStoreReviewScreenshotCreateRequest: InAppPurchaseAppStoreReviewScreenshotCreateRequest, _options?: Configuration): Promise<HttpInfo<InAppPurchaseAppStoreReviewScreenshotResponse>> {
        const result = this.api.inAppPurchaseAppStoreReviewScreenshotsCreateInstanceWithHttpInfo(inAppPurchaseAppStoreReviewScreenshotCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param inAppPurchaseAppStoreReviewScreenshotCreateRequest InAppPurchaseAppStoreReviewScreenshot representation
     */
    public inAppPurchaseAppStoreReviewScreenshotsCreateInstance(inAppPurchaseAppStoreReviewScreenshotCreateRequest: InAppPurchaseAppStoreReviewScreenshotCreateRequest, _options?: Configuration): Promise<InAppPurchaseAppStoreReviewScreenshotResponse> {
        const result = this.api.inAppPurchaseAppStoreReviewScreenshotsCreateInstance(inAppPurchaseAppStoreReviewScreenshotCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public inAppPurchaseAppStoreReviewScreenshotsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.inAppPurchaseAppStoreReviewScreenshotsDeleteInstanceWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public inAppPurchaseAppStoreReviewScreenshotsDeleteInstance(id: string, _options?: Configuration): Promise<void> {
        const result = this.api.inAppPurchaseAppStoreReviewScreenshotsDeleteInstance(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsInAppPurchaseAppStoreReviewScreenshots the fields to include for returned resources of type inAppPurchaseAppStoreReviewScreenshots
     * @param include comma-separated list of relationships to include
     */
    public inAppPurchaseAppStoreReviewScreenshotsGetInstanceWithHttpInfo(id: string, fieldsInAppPurchaseAppStoreReviewScreenshots?: Array<'assetDeliveryState' | 'assetToken' | 'assetType' | 'fileName' | 'fileSize' | 'imageAsset' | 'inAppPurchaseV2' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, include?: Array<'inAppPurchaseV2'>, _options?: Configuration): Promise<HttpInfo<InAppPurchaseAppStoreReviewScreenshotResponse>> {
        const result = this.api.inAppPurchaseAppStoreReviewScreenshotsGetInstanceWithHttpInfo(id, fieldsInAppPurchaseAppStoreReviewScreenshots, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsInAppPurchaseAppStoreReviewScreenshots the fields to include for returned resources of type inAppPurchaseAppStoreReviewScreenshots
     * @param include comma-separated list of relationships to include
     */
    public inAppPurchaseAppStoreReviewScreenshotsGetInstance(id: string, fieldsInAppPurchaseAppStoreReviewScreenshots?: Array<'assetDeliveryState' | 'assetToken' | 'assetType' | 'fileName' | 'fileSize' | 'imageAsset' | 'inAppPurchaseV2' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, include?: Array<'inAppPurchaseV2'>, _options?: Configuration): Promise<InAppPurchaseAppStoreReviewScreenshotResponse> {
        const result = this.api.inAppPurchaseAppStoreReviewScreenshotsGetInstance(id, fieldsInAppPurchaseAppStoreReviewScreenshots, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param inAppPurchaseAppStoreReviewScreenshotUpdateRequest InAppPurchaseAppStoreReviewScreenshot representation
     */
    public inAppPurchaseAppStoreReviewScreenshotsUpdateInstanceWithHttpInfo(id: string, inAppPurchaseAppStoreReviewScreenshotUpdateRequest: InAppPurchaseAppStoreReviewScreenshotUpdateRequest, _options?: Configuration): Promise<HttpInfo<InAppPurchaseAppStoreReviewScreenshotResponse>> {
        const result = this.api.inAppPurchaseAppStoreReviewScreenshotsUpdateInstanceWithHttpInfo(id, inAppPurchaseAppStoreReviewScreenshotUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param inAppPurchaseAppStoreReviewScreenshotUpdateRequest InAppPurchaseAppStoreReviewScreenshot representation
     */
    public inAppPurchaseAppStoreReviewScreenshotsUpdateInstance(id: string, inAppPurchaseAppStoreReviewScreenshotUpdateRequest: InAppPurchaseAppStoreReviewScreenshotUpdateRequest, _options?: Configuration): Promise<InAppPurchaseAppStoreReviewScreenshotResponse> {
        const result = this.api.inAppPurchaseAppStoreReviewScreenshotsUpdateInstance(id, inAppPurchaseAppStoreReviewScreenshotUpdateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableInAppPurchaseAvailabilitiesApi } from './ObservableAPI.ts';

import { InAppPurchaseAvailabilitiesApiRequestFactory, InAppPurchaseAvailabilitiesApiResponseProcessor} from "../apis/InAppPurchaseAvailabilitiesApi.ts";
export class PromiseInAppPurchaseAvailabilitiesApi {
    private api: ObservableInAppPurchaseAvailabilitiesApi

    public constructor(
        configuration: Configuration,
        requestFactory?: InAppPurchaseAvailabilitiesApiRequestFactory,
        responseProcessor?: InAppPurchaseAvailabilitiesApiResponseProcessor
    ) {
        this.api = new ObservableInAppPurchaseAvailabilitiesApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limit maximum resources per page
     */
    public inAppPurchaseAvailabilitiesAvailableTerritoriesGetToManyRelatedWithHttpInfo(id: string, fieldsTerritories?: Array<'currency'>, limit?: number, _options?: Configuration): Promise<HttpInfo<TerritoriesResponse>> {
        const result = this.api.inAppPurchaseAvailabilitiesAvailableTerritoriesGetToManyRelatedWithHttpInfo(id, fieldsTerritories, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limit maximum resources per page
     */
    public inAppPurchaseAvailabilitiesAvailableTerritoriesGetToManyRelated(id: string, fieldsTerritories?: Array<'currency'>, limit?: number, _options?: Configuration): Promise<TerritoriesResponse> {
        const result = this.api.inAppPurchaseAvailabilitiesAvailableTerritoriesGetToManyRelated(id, fieldsTerritories, limit, _options);
        return result.toPromise();
    }

    /**
     * @param inAppPurchaseAvailabilityCreateRequest InAppPurchaseAvailability representation
     */
    public inAppPurchaseAvailabilitiesCreateInstanceWithHttpInfo(inAppPurchaseAvailabilityCreateRequest: InAppPurchaseAvailabilityCreateRequest, _options?: Configuration): Promise<HttpInfo<InAppPurchaseAvailabilityResponse>> {
        const result = this.api.inAppPurchaseAvailabilitiesCreateInstanceWithHttpInfo(inAppPurchaseAvailabilityCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param inAppPurchaseAvailabilityCreateRequest InAppPurchaseAvailability representation
     */
    public inAppPurchaseAvailabilitiesCreateInstance(inAppPurchaseAvailabilityCreateRequest: InAppPurchaseAvailabilityCreateRequest, _options?: Configuration): Promise<InAppPurchaseAvailabilityResponse> {
        const result = this.api.inAppPurchaseAvailabilitiesCreateInstance(inAppPurchaseAvailabilityCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsInAppPurchaseAvailabilities the fields to include for returned resources of type inAppPurchaseAvailabilities
     * @param include comma-separated list of relationships to include
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limitAvailableTerritories maximum number of related availableTerritories returned (when they are included)
     */
    public inAppPurchaseAvailabilitiesGetInstanceWithHttpInfo(id: string, fieldsInAppPurchaseAvailabilities?: Array<'availableInNewTerritories' | 'availableTerritories' | 'inAppPurchase'>, include?: Array<'availableTerritories'>, fieldsTerritories?: Array<'currency'>, limitAvailableTerritories?: number, _options?: Configuration): Promise<HttpInfo<InAppPurchaseAvailabilityResponse>> {
        const result = this.api.inAppPurchaseAvailabilitiesGetInstanceWithHttpInfo(id, fieldsInAppPurchaseAvailabilities, include, fieldsTerritories, limitAvailableTerritories, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsInAppPurchaseAvailabilities the fields to include for returned resources of type inAppPurchaseAvailabilities
     * @param include comma-separated list of relationships to include
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limitAvailableTerritories maximum number of related availableTerritories returned (when they are included)
     */
    public inAppPurchaseAvailabilitiesGetInstance(id: string, fieldsInAppPurchaseAvailabilities?: Array<'availableInNewTerritories' | 'availableTerritories' | 'inAppPurchase'>, include?: Array<'availableTerritories'>, fieldsTerritories?: Array<'currency'>, limitAvailableTerritories?: number, _options?: Configuration): Promise<InAppPurchaseAvailabilityResponse> {
        const result = this.api.inAppPurchaseAvailabilitiesGetInstance(id, fieldsInAppPurchaseAvailabilities, include, fieldsTerritories, limitAvailableTerritories, _options);
        return result.toPromise();
    }


}



import { ObservableInAppPurchaseContentsApi } from './ObservableAPI.ts';

import { InAppPurchaseContentsApiRequestFactory, InAppPurchaseContentsApiResponseProcessor} from "../apis/InAppPurchaseContentsApi.ts";
export class PromiseInAppPurchaseContentsApi {
    private api: ObservableInAppPurchaseContentsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: InAppPurchaseContentsApiRequestFactory,
        responseProcessor?: InAppPurchaseContentsApiResponseProcessor
    ) {
        this.api = new ObservableInAppPurchaseContentsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsInAppPurchaseContents the fields to include for returned resources of type inAppPurchaseContents
     * @param include comma-separated list of relationships to include
     */
    public inAppPurchaseContentsGetInstanceWithHttpInfo(id: string, fieldsInAppPurchaseContents?: Array<'fileName' | 'fileSize' | 'inAppPurchaseV2' | 'lastModifiedDate' | 'url'>, include?: Array<'inAppPurchaseV2'>, _options?: Configuration): Promise<HttpInfo<InAppPurchaseContentResponse>> {
        const result = this.api.inAppPurchaseContentsGetInstanceWithHttpInfo(id, fieldsInAppPurchaseContents, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsInAppPurchaseContents the fields to include for returned resources of type inAppPurchaseContents
     * @param include comma-separated list of relationships to include
     */
    public inAppPurchaseContentsGetInstance(id: string, fieldsInAppPurchaseContents?: Array<'fileName' | 'fileSize' | 'inAppPurchaseV2' | 'lastModifiedDate' | 'url'>, include?: Array<'inAppPurchaseV2'>, _options?: Configuration): Promise<InAppPurchaseContentResponse> {
        const result = this.api.inAppPurchaseContentsGetInstance(id, fieldsInAppPurchaseContents, include, _options);
        return result.toPromise();
    }


}



import { ObservableInAppPurchaseLocalizationsApi } from './ObservableAPI.ts';

import { InAppPurchaseLocalizationsApiRequestFactory, InAppPurchaseLocalizationsApiResponseProcessor} from "../apis/InAppPurchaseLocalizationsApi.ts";
export class PromiseInAppPurchaseLocalizationsApi {
    private api: ObservableInAppPurchaseLocalizationsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: InAppPurchaseLocalizationsApiRequestFactory,
        responseProcessor?: InAppPurchaseLocalizationsApiResponseProcessor
    ) {
        this.api = new ObservableInAppPurchaseLocalizationsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param inAppPurchaseLocalizationCreateRequest InAppPurchaseLocalization representation
     */
    public inAppPurchaseLocalizationsCreateInstanceWithHttpInfo(inAppPurchaseLocalizationCreateRequest: InAppPurchaseLocalizationCreateRequest, _options?: Configuration): Promise<HttpInfo<InAppPurchaseLocalizationResponse>> {
        const result = this.api.inAppPurchaseLocalizationsCreateInstanceWithHttpInfo(inAppPurchaseLocalizationCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param inAppPurchaseLocalizationCreateRequest InAppPurchaseLocalization representation
     */
    public inAppPurchaseLocalizationsCreateInstance(inAppPurchaseLocalizationCreateRequest: InAppPurchaseLocalizationCreateRequest, _options?: Configuration): Promise<InAppPurchaseLocalizationResponse> {
        const result = this.api.inAppPurchaseLocalizationsCreateInstance(inAppPurchaseLocalizationCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public inAppPurchaseLocalizationsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.inAppPurchaseLocalizationsDeleteInstanceWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public inAppPurchaseLocalizationsDeleteInstance(id: string, _options?: Configuration): Promise<void> {
        const result = this.api.inAppPurchaseLocalizationsDeleteInstance(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsInAppPurchaseLocalizations the fields to include for returned resources of type inAppPurchaseLocalizations
     * @param include comma-separated list of relationships to include
     */
    public inAppPurchaseLocalizationsGetInstanceWithHttpInfo(id: string, fieldsInAppPurchaseLocalizations?: Array<'description' | 'inAppPurchaseV2' | 'locale' | 'name' | 'state'>, include?: Array<'inAppPurchaseV2'>, _options?: Configuration): Promise<HttpInfo<InAppPurchaseLocalizationResponse>> {
        const result = this.api.inAppPurchaseLocalizationsGetInstanceWithHttpInfo(id, fieldsInAppPurchaseLocalizations, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsInAppPurchaseLocalizations the fields to include for returned resources of type inAppPurchaseLocalizations
     * @param include comma-separated list of relationships to include
     */
    public inAppPurchaseLocalizationsGetInstance(id: string, fieldsInAppPurchaseLocalizations?: Array<'description' | 'inAppPurchaseV2' | 'locale' | 'name' | 'state'>, include?: Array<'inAppPurchaseV2'>, _options?: Configuration): Promise<InAppPurchaseLocalizationResponse> {
        const result = this.api.inAppPurchaseLocalizationsGetInstance(id, fieldsInAppPurchaseLocalizations, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param inAppPurchaseLocalizationUpdateRequest InAppPurchaseLocalization representation
     */
    public inAppPurchaseLocalizationsUpdateInstanceWithHttpInfo(id: string, inAppPurchaseLocalizationUpdateRequest: InAppPurchaseLocalizationUpdateRequest, _options?: Configuration): Promise<HttpInfo<InAppPurchaseLocalizationResponse>> {
        const result = this.api.inAppPurchaseLocalizationsUpdateInstanceWithHttpInfo(id, inAppPurchaseLocalizationUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param inAppPurchaseLocalizationUpdateRequest InAppPurchaseLocalization representation
     */
    public inAppPurchaseLocalizationsUpdateInstance(id: string, inAppPurchaseLocalizationUpdateRequest: InAppPurchaseLocalizationUpdateRequest, _options?: Configuration): Promise<InAppPurchaseLocalizationResponse> {
        const result = this.api.inAppPurchaseLocalizationsUpdateInstance(id, inAppPurchaseLocalizationUpdateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableInAppPurchasePriceSchedulesApi } from './ObservableAPI.ts';

import { InAppPurchasePriceSchedulesApiRequestFactory, InAppPurchasePriceSchedulesApiResponseProcessor} from "../apis/InAppPurchasePriceSchedulesApi.ts";
export class PromiseInAppPurchasePriceSchedulesApi {
    private api: ObservableInAppPurchasePriceSchedulesApi

    public constructor(
        configuration: Configuration,
        requestFactory?: InAppPurchasePriceSchedulesApiRequestFactory,
        responseProcessor?: InAppPurchasePriceSchedulesApiResponseProcessor
    ) {
        this.api = new ObservableInAppPurchasePriceSchedulesApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param id the id of the requested resource
     * @param filterTerritory filter by id(s) of related \&#39;territory\&#39;
     * @param fieldsInAppPurchasePricePoints the fields to include for returned resources of type inAppPurchasePricePoints
     * @param fieldsInAppPurchasePrices the fields to include for returned resources of type inAppPurchasePrices
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public inAppPurchasePriceSchedulesAutomaticPricesGetToManyRelatedWithHttpInfo(id: string, filterTerritory?: Array<string>, fieldsInAppPurchasePricePoints?: Array<'customerPrice' | 'inAppPurchaseV2' | 'priceTier' | 'proceeds' | 'territory'>, fieldsInAppPurchasePrices?: Array<'endDate' | 'inAppPurchasePricePoint' | 'inAppPurchaseV2' | 'manual' | 'startDate' | 'territory'>, fieldsTerritories?: Array<'currency'>, limit?: number, include?: Array<'inAppPurchasePricePoint' | 'territory'>, _options?: Configuration): Promise<HttpInfo<InAppPurchasePricesResponse>> {
        const result = this.api.inAppPurchasePriceSchedulesAutomaticPricesGetToManyRelatedWithHttpInfo(id, filterTerritory, fieldsInAppPurchasePricePoints, fieldsInAppPurchasePrices, fieldsTerritories, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterTerritory filter by id(s) of related \&#39;territory\&#39;
     * @param fieldsInAppPurchasePricePoints the fields to include for returned resources of type inAppPurchasePricePoints
     * @param fieldsInAppPurchasePrices the fields to include for returned resources of type inAppPurchasePrices
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public inAppPurchasePriceSchedulesAutomaticPricesGetToManyRelated(id: string, filterTerritory?: Array<string>, fieldsInAppPurchasePricePoints?: Array<'customerPrice' | 'inAppPurchaseV2' | 'priceTier' | 'proceeds' | 'territory'>, fieldsInAppPurchasePrices?: Array<'endDate' | 'inAppPurchasePricePoint' | 'inAppPurchaseV2' | 'manual' | 'startDate' | 'territory'>, fieldsTerritories?: Array<'currency'>, limit?: number, include?: Array<'inAppPurchasePricePoint' | 'territory'>, _options?: Configuration): Promise<InAppPurchasePricesResponse> {
        const result = this.api.inAppPurchasePriceSchedulesAutomaticPricesGetToManyRelated(id, filterTerritory, fieldsInAppPurchasePricePoints, fieldsInAppPurchasePrices, fieldsTerritories, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsTerritories the fields to include for returned resources of type territories
     */
    public inAppPurchasePriceSchedulesBaseTerritoryGetToOneRelatedWithHttpInfo(id: string, fieldsTerritories?: Array<'currency'>, _options?: Configuration): Promise<HttpInfo<TerritoryResponse>> {
        const result = this.api.inAppPurchasePriceSchedulesBaseTerritoryGetToOneRelatedWithHttpInfo(id, fieldsTerritories, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsTerritories the fields to include for returned resources of type territories
     */
    public inAppPurchasePriceSchedulesBaseTerritoryGetToOneRelated(id: string, fieldsTerritories?: Array<'currency'>, _options?: Configuration): Promise<TerritoryResponse> {
        const result = this.api.inAppPurchasePriceSchedulesBaseTerritoryGetToOneRelated(id, fieldsTerritories, _options);
        return result.toPromise();
    }

    /**
     * @param inAppPurchasePriceScheduleCreateRequest InAppPurchasePriceSchedule representation
     */
    public inAppPurchasePriceSchedulesCreateInstanceWithHttpInfo(inAppPurchasePriceScheduleCreateRequest: InAppPurchasePriceScheduleCreateRequest, _options?: Configuration): Promise<HttpInfo<InAppPurchasePriceScheduleResponse>> {
        const result = this.api.inAppPurchasePriceSchedulesCreateInstanceWithHttpInfo(inAppPurchasePriceScheduleCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param inAppPurchasePriceScheduleCreateRequest InAppPurchasePriceSchedule representation
     */
    public inAppPurchasePriceSchedulesCreateInstance(inAppPurchasePriceScheduleCreateRequest: InAppPurchasePriceScheduleCreateRequest, _options?: Configuration): Promise<InAppPurchasePriceScheduleResponse> {
        const result = this.api.inAppPurchasePriceSchedulesCreateInstance(inAppPurchasePriceScheduleCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsInAppPurchasePriceSchedules the fields to include for returned resources of type inAppPurchasePriceSchedules
     * @param include comma-separated list of relationships to include
     * @param fieldsInAppPurchasePrices the fields to include for returned resources of type inAppPurchasePrices
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limitAutomaticPrices maximum number of related automaticPrices returned (when they are included)
     * @param limitManualPrices maximum number of related manualPrices returned (when they are included)
     */
    public inAppPurchasePriceSchedulesGetInstanceWithHttpInfo(id: string, fieldsInAppPurchasePriceSchedules?: Array<'automaticPrices' | 'baseTerritory' | 'inAppPurchase' | 'manualPrices'>, include?: Array<'automaticPrices' | 'baseTerritory' | 'inAppPurchase' | 'manualPrices'>, fieldsInAppPurchasePrices?: Array<'endDate' | 'inAppPurchasePricePoint' | 'inAppPurchaseV2' | 'manual' | 'startDate' | 'territory'>, fieldsTerritories?: Array<'currency'>, limitAutomaticPrices?: number, limitManualPrices?: number, _options?: Configuration): Promise<HttpInfo<InAppPurchasePriceScheduleResponse>> {
        const result = this.api.inAppPurchasePriceSchedulesGetInstanceWithHttpInfo(id, fieldsInAppPurchasePriceSchedules, include, fieldsInAppPurchasePrices, fieldsTerritories, limitAutomaticPrices, limitManualPrices, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsInAppPurchasePriceSchedules the fields to include for returned resources of type inAppPurchasePriceSchedules
     * @param include comma-separated list of relationships to include
     * @param fieldsInAppPurchasePrices the fields to include for returned resources of type inAppPurchasePrices
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limitAutomaticPrices maximum number of related automaticPrices returned (when they are included)
     * @param limitManualPrices maximum number of related manualPrices returned (when they are included)
     */
    public inAppPurchasePriceSchedulesGetInstance(id: string, fieldsInAppPurchasePriceSchedules?: Array<'automaticPrices' | 'baseTerritory' | 'inAppPurchase' | 'manualPrices'>, include?: Array<'automaticPrices' | 'baseTerritory' | 'inAppPurchase' | 'manualPrices'>, fieldsInAppPurchasePrices?: Array<'endDate' | 'inAppPurchasePricePoint' | 'inAppPurchaseV2' | 'manual' | 'startDate' | 'territory'>, fieldsTerritories?: Array<'currency'>, limitAutomaticPrices?: number, limitManualPrices?: number, _options?: Configuration): Promise<InAppPurchasePriceScheduleResponse> {
        const result = this.api.inAppPurchasePriceSchedulesGetInstance(id, fieldsInAppPurchasePriceSchedules, include, fieldsInAppPurchasePrices, fieldsTerritories, limitAutomaticPrices, limitManualPrices, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterTerritory filter by id(s) of related \&#39;territory\&#39;
     * @param fieldsInAppPurchasePricePoints the fields to include for returned resources of type inAppPurchasePricePoints
     * @param fieldsInAppPurchasePrices the fields to include for returned resources of type inAppPurchasePrices
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public inAppPurchasePriceSchedulesManualPricesGetToManyRelatedWithHttpInfo(id: string, filterTerritory?: Array<string>, fieldsInAppPurchasePricePoints?: Array<'customerPrice' | 'inAppPurchaseV2' | 'priceTier' | 'proceeds' | 'territory'>, fieldsInAppPurchasePrices?: Array<'endDate' | 'inAppPurchasePricePoint' | 'inAppPurchaseV2' | 'manual' | 'startDate' | 'territory'>, fieldsTerritories?: Array<'currency'>, limit?: number, include?: Array<'inAppPurchasePricePoint' | 'territory'>, _options?: Configuration): Promise<HttpInfo<InAppPurchasePricesResponse>> {
        const result = this.api.inAppPurchasePriceSchedulesManualPricesGetToManyRelatedWithHttpInfo(id, filterTerritory, fieldsInAppPurchasePricePoints, fieldsInAppPurchasePrices, fieldsTerritories, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterTerritory filter by id(s) of related \&#39;territory\&#39;
     * @param fieldsInAppPurchasePricePoints the fields to include for returned resources of type inAppPurchasePricePoints
     * @param fieldsInAppPurchasePrices the fields to include for returned resources of type inAppPurchasePrices
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public inAppPurchasePriceSchedulesManualPricesGetToManyRelated(id: string, filterTerritory?: Array<string>, fieldsInAppPurchasePricePoints?: Array<'customerPrice' | 'inAppPurchaseV2' | 'priceTier' | 'proceeds' | 'territory'>, fieldsInAppPurchasePrices?: Array<'endDate' | 'inAppPurchasePricePoint' | 'inAppPurchaseV2' | 'manual' | 'startDate' | 'territory'>, fieldsTerritories?: Array<'currency'>, limit?: number, include?: Array<'inAppPurchasePricePoint' | 'territory'>, _options?: Configuration): Promise<InAppPurchasePricesResponse> {
        const result = this.api.inAppPurchasePriceSchedulesManualPricesGetToManyRelated(id, filterTerritory, fieldsInAppPurchasePricePoints, fieldsInAppPurchasePrices, fieldsTerritories, limit, include, _options);
        return result.toPromise();
    }


}



import { ObservableInAppPurchaseSubmissionsApi } from './ObservableAPI.ts';

import { InAppPurchaseSubmissionsApiRequestFactory, InAppPurchaseSubmissionsApiResponseProcessor} from "../apis/InAppPurchaseSubmissionsApi.ts";
export class PromiseInAppPurchaseSubmissionsApi {
    private api: ObservableInAppPurchaseSubmissionsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: InAppPurchaseSubmissionsApiRequestFactory,
        responseProcessor?: InAppPurchaseSubmissionsApiResponseProcessor
    ) {
        this.api = new ObservableInAppPurchaseSubmissionsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param inAppPurchaseSubmissionCreateRequest InAppPurchaseSubmission representation
     */
    public inAppPurchaseSubmissionsCreateInstanceWithHttpInfo(inAppPurchaseSubmissionCreateRequest: InAppPurchaseSubmissionCreateRequest, _options?: Configuration): Promise<HttpInfo<InAppPurchaseSubmissionResponse>> {
        const result = this.api.inAppPurchaseSubmissionsCreateInstanceWithHttpInfo(inAppPurchaseSubmissionCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param inAppPurchaseSubmissionCreateRequest InAppPurchaseSubmission representation
     */
    public inAppPurchaseSubmissionsCreateInstance(inAppPurchaseSubmissionCreateRequest: InAppPurchaseSubmissionCreateRequest, _options?: Configuration): Promise<InAppPurchaseSubmissionResponse> {
        const result = this.api.inAppPurchaseSubmissionsCreateInstance(inAppPurchaseSubmissionCreateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableInAppPurchasesApi } from './ObservableAPI.ts';

import { InAppPurchasesApiRequestFactory, InAppPurchasesApiResponseProcessor} from "../apis/InAppPurchasesApi.ts";
export class PromiseInAppPurchasesApi {
    private api: ObservableInAppPurchasesApi

    public constructor(
        configuration: Configuration,
        requestFactory?: InAppPurchasesApiRequestFactory,
        responseProcessor?: InAppPurchasesApiResponseProcessor
    ) {
        this.api = new ObservableInAppPurchasesApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsInAppPurchases the fields to include for returned resources of type inAppPurchases
     * @param include comma-separated list of relationships to include
     * @param limitApps maximum number of related apps returned (when they are included)
     */
    public inAppPurchasesGetInstanceWithHttpInfo(id: string, fieldsInAppPurchases?: Array<'apps' | 'inAppPurchaseType' | 'productId' | 'referenceName' | 'state'>, include?: Array<'apps'>, limitApps?: number, _options?: Configuration): Promise<HttpInfo<InAppPurchaseResponse>> {
        const result = this.api.inAppPurchasesGetInstanceWithHttpInfo(id, fieldsInAppPurchases, include, limitApps, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsInAppPurchases the fields to include for returned resources of type inAppPurchases
     * @param include comma-separated list of relationships to include
     * @param limitApps maximum number of related apps returned (when they are included)
     */
    public inAppPurchasesGetInstance(id: string, fieldsInAppPurchases?: Array<'apps' | 'inAppPurchaseType' | 'productId' | 'referenceName' | 'state'>, include?: Array<'apps'>, limitApps?: number, _options?: Configuration): Promise<InAppPurchaseResponse> {
        const result = this.api.inAppPurchasesGetInstance(id, fieldsInAppPurchases, include, limitApps, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsInAppPurchaseAppStoreReviewScreenshots the fields to include for returned resources of type inAppPurchaseAppStoreReviewScreenshots
     * @param fieldsInAppPurchases the fields to include for returned resources of type inAppPurchases
     * @param include comma-separated list of relationships to include
     */
    public inAppPurchasesV2AppStoreReviewScreenshotGetToOneRelatedWithHttpInfo(id: string, fieldsInAppPurchaseAppStoreReviewScreenshots?: Array<'assetDeliveryState' | 'assetToken' | 'assetType' | 'fileName' | 'fileSize' | 'imageAsset' | 'inAppPurchaseV2' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, fieldsInAppPurchases?: Array<'app' | 'appStoreReviewScreenshot' | 'content' | 'contentHosting' | 'familySharable' | 'iapPriceSchedule' | 'inAppPurchaseAvailability' | 'inAppPurchaseLocalizations' | 'inAppPurchaseType' | 'name' | 'pricePoints' | 'productId' | 'promotedPurchase' | 'reviewNote' | 'state'>, include?: Array<'inAppPurchaseV2'>, _options?: Configuration): Promise<HttpInfo<InAppPurchaseAppStoreReviewScreenshotResponse>> {
        const result = this.api.inAppPurchasesV2AppStoreReviewScreenshotGetToOneRelatedWithHttpInfo(id, fieldsInAppPurchaseAppStoreReviewScreenshots, fieldsInAppPurchases, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsInAppPurchaseAppStoreReviewScreenshots the fields to include for returned resources of type inAppPurchaseAppStoreReviewScreenshots
     * @param fieldsInAppPurchases the fields to include for returned resources of type inAppPurchases
     * @param include comma-separated list of relationships to include
     */
    public inAppPurchasesV2AppStoreReviewScreenshotGetToOneRelated(id: string, fieldsInAppPurchaseAppStoreReviewScreenshots?: Array<'assetDeliveryState' | 'assetToken' | 'assetType' | 'fileName' | 'fileSize' | 'imageAsset' | 'inAppPurchaseV2' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, fieldsInAppPurchases?: Array<'app' | 'appStoreReviewScreenshot' | 'content' | 'contentHosting' | 'familySharable' | 'iapPriceSchedule' | 'inAppPurchaseAvailability' | 'inAppPurchaseLocalizations' | 'inAppPurchaseType' | 'name' | 'pricePoints' | 'productId' | 'promotedPurchase' | 'reviewNote' | 'state'>, include?: Array<'inAppPurchaseV2'>, _options?: Configuration): Promise<InAppPurchaseAppStoreReviewScreenshotResponse> {
        const result = this.api.inAppPurchasesV2AppStoreReviewScreenshotGetToOneRelated(id, fieldsInAppPurchaseAppStoreReviewScreenshots, fieldsInAppPurchases, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsInAppPurchases the fields to include for returned resources of type inAppPurchases
     * @param fieldsInAppPurchaseContents the fields to include for returned resources of type inAppPurchaseContents
     * @param include comma-separated list of relationships to include
     */
    public inAppPurchasesV2ContentGetToOneRelatedWithHttpInfo(id: string, fieldsInAppPurchases?: Array<'app' | 'appStoreReviewScreenshot' | 'content' | 'contentHosting' | 'familySharable' | 'iapPriceSchedule' | 'inAppPurchaseAvailability' | 'inAppPurchaseLocalizations' | 'inAppPurchaseType' | 'name' | 'pricePoints' | 'productId' | 'promotedPurchase' | 'reviewNote' | 'state'>, fieldsInAppPurchaseContents?: Array<'fileName' | 'fileSize' | 'inAppPurchaseV2' | 'lastModifiedDate' | 'url'>, include?: Array<'inAppPurchaseV2'>, _options?: Configuration): Promise<HttpInfo<InAppPurchaseContentResponse>> {
        const result = this.api.inAppPurchasesV2ContentGetToOneRelatedWithHttpInfo(id, fieldsInAppPurchases, fieldsInAppPurchaseContents, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsInAppPurchases the fields to include for returned resources of type inAppPurchases
     * @param fieldsInAppPurchaseContents the fields to include for returned resources of type inAppPurchaseContents
     * @param include comma-separated list of relationships to include
     */
    public inAppPurchasesV2ContentGetToOneRelated(id: string, fieldsInAppPurchases?: Array<'app' | 'appStoreReviewScreenshot' | 'content' | 'contentHosting' | 'familySharable' | 'iapPriceSchedule' | 'inAppPurchaseAvailability' | 'inAppPurchaseLocalizations' | 'inAppPurchaseType' | 'name' | 'pricePoints' | 'productId' | 'promotedPurchase' | 'reviewNote' | 'state'>, fieldsInAppPurchaseContents?: Array<'fileName' | 'fileSize' | 'inAppPurchaseV2' | 'lastModifiedDate' | 'url'>, include?: Array<'inAppPurchaseV2'>, _options?: Configuration): Promise<InAppPurchaseContentResponse> {
        const result = this.api.inAppPurchasesV2ContentGetToOneRelated(id, fieldsInAppPurchases, fieldsInAppPurchaseContents, include, _options);
        return result.toPromise();
    }

    /**
     * @param inAppPurchaseV2CreateRequest InAppPurchase representation
     */
    public inAppPurchasesV2CreateInstanceWithHttpInfo(inAppPurchaseV2CreateRequest: InAppPurchaseV2CreateRequest, _options?: Configuration): Promise<HttpInfo<InAppPurchaseV2Response>> {
        const result = this.api.inAppPurchasesV2CreateInstanceWithHttpInfo(inAppPurchaseV2CreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param inAppPurchaseV2CreateRequest InAppPurchase representation
     */
    public inAppPurchasesV2CreateInstance(inAppPurchaseV2CreateRequest: InAppPurchaseV2CreateRequest, _options?: Configuration): Promise<InAppPurchaseV2Response> {
        const result = this.api.inAppPurchasesV2CreateInstance(inAppPurchaseV2CreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public inAppPurchasesV2DeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.inAppPurchasesV2DeleteInstanceWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public inAppPurchasesV2DeleteInstance(id: string, _options?: Configuration): Promise<void> {
        const result = this.api.inAppPurchasesV2DeleteInstance(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsInAppPurchases the fields to include for returned resources of type inAppPurchases
     * @param include comma-separated list of relationships to include
     * @param fieldsInAppPurchaseAvailabilities the fields to include for returned resources of type inAppPurchaseAvailabilities
     * @param fieldsInAppPurchaseAppStoreReviewScreenshots the fields to include for returned resources of type inAppPurchaseAppStoreReviewScreenshots
     * @param fieldsPromotedPurchases the fields to include for returned resources of type promotedPurchases
     * @param fieldsInAppPurchasePricePoints the fields to include for returned resources of type inAppPurchasePricePoints
     * @param fieldsInAppPurchaseLocalizations the fields to include for returned resources of type inAppPurchaseLocalizations
     * @param fieldsInAppPurchasePriceSchedules the fields to include for returned resources of type inAppPurchasePriceSchedules
     * @param fieldsInAppPurchaseContents the fields to include for returned resources of type inAppPurchaseContents
     * @param limitInAppPurchaseLocalizations maximum number of related inAppPurchaseLocalizations returned (when they are included)
     * @param limitPricePoints maximum number of related pricePoints returned (when they are included)
     */
    public inAppPurchasesV2GetInstanceWithHttpInfo(id: string, fieldsInAppPurchases?: Array<'app' | 'appStoreReviewScreenshot' | 'content' | 'contentHosting' | 'familySharable' | 'iapPriceSchedule' | 'inAppPurchaseAvailability' | 'inAppPurchaseLocalizations' | 'inAppPurchaseType' | 'name' | 'pricePoints' | 'productId' | 'promotedPurchase' | 'reviewNote' | 'state'>, include?: Array<'appStoreReviewScreenshot' | 'content' | 'iapPriceSchedule' | 'inAppPurchaseAvailability' | 'inAppPurchaseLocalizations' | 'pricePoints' | 'promotedPurchase'>, fieldsInAppPurchaseAvailabilities?: Array<'availableInNewTerritories' | 'availableTerritories' | 'inAppPurchase'>, fieldsInAppPurchaseAppStoreReviewScreenshots?: Array<'assetDeliveryState' | 'assetToken' | 'assetType' | 'fileName' | 'fileSize' | 'imageAsset' | 'inAppPurchaseV2' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, fieldsPromotedPurchases?: Array<'app' | 'enabled' | 'inAppPurchaseV2' | 'promotionImages' | 'state' | 'subscription' | 'visibleForAllUsers'>, fieldsInAppPurchasePricePoints?: Array<'customerPrice' | 'inAppPurchaseV2' | 'priceTier' | 'proceeds' | 'territory'>, fieldsInAppPurchaseLocalizations?: Array<'description' | 'inAppPurchaseV2' | 'locale' | 'name' | 'state'>, fieldsInAppPurchasePriceSchedules?: Array<'automaticPrices' | 'baseTerritory' | 'inAppPurchase' | 'manualPrices'>, fieldsInAppPurchaseContents?: Array<'fileName' | 'fileSize' | 'inAppPurchaseV2' | 'lastModifiedDate' | 'url'>, limitInAppPurchaseLocalizations?: number, limitPricePoints?: number, _options?: Configuration): Promise<HttpInfo<InAppPurchaseV2Response>> {
        const result = this.api.inAppPurchasesV2GetInstanceWithHttpInfo(id, fieldsInAppPurchases, include, fieldsInAppPurchaseAvailabilities, fieldsInAppPurchaseAppStoreReviewScreenshots, fieldsPromotedPurchases, fieldsInAppPurchasePricePoints, fieldsInAppPurchaseLocalizations, fieldsInAppPurchasePriceSchedules, fieldsInAppPurchaseContents, limitInAppPurchaseLocalizations, limitPricePoints, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsInAppPurchases the fields to include for returned resources of type inAppPurchases
     * @param include comma-separated list of relationships to include
     * @param fieldsInAppPurchaseAvailabilities the fields to include for returned resources of type inAppPurchaseAvailabilities
     * @param fieldsInAppPurchaseAppStoreReviewScreenshots the fields to include for returned resources of type inAppPurchaseAppStoreReviewScreenshots
     * @param fieldsPromotedPurchases the fields to include for returned resources of type promotedPurchases
     * @param fieldsInAppPurchasePricePoints the fields to include for returned resources of type inAppPurchasePricePoints
     * @param fieldsInAppPurchaseLocalizations the fields to include for returned resources of type inAppPurchaseLocalizations
     * @param fieldsInAppPurchasePriceSchedules the fields to include for returned resources of type inAppPurchasePriceSchedules
     * @param fieldsInAppPurchaseContents the fields to include for returned resources of type inAppPurchaseContents
     * @param limitInAppPurchaseLocalizations maximum number of related inAppPurchaseLocalizations returned (when they are included)
     * @param limitPricePoints maximum number of related pricePoints returned (when they are included)
     */
    public inAppPurchasesV2GetInstance(id: string, fieldsInAppPurchases?: Array<'app' | 'appStoreReviewScreenshot' | 'content' | 'contentHosting' | 'familySharable' | 'iapPriceSchedule' | 'inAppPurchaseAvailability' | 'inAppPurchaseLocalizations' | 'inAppPurchaseType' | 'name' | 'pricePoints' | 'productId' | 'promotedPurchase' | 'reviewNote' | 'state'>, include?: Array<'appStoreReviewScreenshot' | 'content' | 'iapPriceSchedule' | 'inAppPurchaseAvailability' | 'inAppPurchaseLocalizations' | 'pricePoints' | 'promotedPurchase'>, fieldsInAppPurchaseAvailabilities?: Array<'availableInNewTerritories' | 'availableTerritories' | 'inAppPurchase'>, fieldsInAppPurchaseAppStoreReviewScreenshots?: Array<'assetDeliveryState' | 'assetToken' | 'assetType' | 'fileName' | 'fileSize' | 'imageAsset' | 'inAppPurchaseV2' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, fieldsPromotedPurchases?: Array<'app' | 'enabled' | 'inAppPurchaseV2' | 'promotionImages' | 'state' | 'subscription' | 'visibleForAllUsers'>, fieldsInAppPurchasePricePoints?: Array<'customerPrice' | 'inAppPurchaseV2' | 'priceTier' | 'proceeds' | 'territory'>, fieldsInAppPurchaseLocalizations?: Array<'description' | 'inAppPurchaseV2' | 'locale' | 'name' | 'state'>, fieldsInAppPurchasePriceSchedules?: Array<'automaticPrices' | 'baseTerritory' | 'inAppPurchase' | 'manualPrices'>, fieldsInAppPurchaseContents?: Array<'fileName' | 'fileSize' | 'inAppPurchaseV2' | 'lastModifiedDate' | 'url'>, limitInAppPurchaseLocalizations?: number, limitPricePoints?: number, _options?: Configuration): Promise<InAppPurchaseV2Response> {
        const result = this.api.inAppPurchasesV2GetInstance(id, fieldsInAppPurchases, include, fieldsInAppPurchaseAvailabilities, fieldsInAppPurchaseAppStoreReviewScreenshots, fieldsPromotedPurchases, fieldsInAppPurchasePricePoints, fieldsInAppPurchaseLocalizations, fieldsInAppPurchasePriceSchedules, fieldsInAppPurchaseContents, limitInAppPurchaseLocalizations, limitPricePoints, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsInAppPurchasePrices the fields to include for returned resources of type inAppPurchasePrices
     * @param fieldsInAppPurchases the fields to include for returned resources of type inAppPurchases
     * @param fieldsInAppPurchasePriceSchedules the fields to include for returned resources of type inAppPurchasePriceSchedules
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limitManualPrices maximum number of related manualPrices returned (when they are included)
     * @param limitAutomaticPrices maximum number of related automaticPrices returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public inAppPurchasesV2IapPriceScheduleGetToOneRelatedWithHttpInfo(id: string, fieldsInAppPurchasePrices?: Array<'endDate' | 'inAppPurchasePricePoint' | 'inAppPurchaseV2' | 'manual' | 'startDate' | 'territory'>, fieldsInAppPurchases?: Array<'app' | 'appStoreReviewScreenshot' | 'content' | 'contentHosting' | 'familySharable' | 'iapPriceSchedule' | 'inAppPurchaseAvailability' | 'inAppPurchaseLocalizations' | 'inAppPurchaseType' | 'name' | 'pricePoints' | 'productId' | 'promotedPurchase' | 'reviewNote' | 'state'>, fieldsInAppPurchasePriceSchedules?: Array<'automaticPrices' | 'baseTerritory' | 'inAppPurchase' | 'manualPrices'>, fieldsTerritories?: Array<'currency'>, limitManualPrices?: number, limitAutomaticPrices?: number, include?: Array<'automaticPrices' | 'baseTerritory' | 'inAppPurchase' | 'manualPrices'>, _options?: Configuration): Promise<HttpInfo<InAppPurchasePriceScheduleResponse>> {
        const result = this.api.inAppPurchasesV2IapPriceScheduleGetToOneRelatedWithHttpInfo(id, fieldsInAppPurchasePrices, fieldsInAppPurchases, fieldsInAppPurchasePriceSchedules, fieldsTerritories, limitManualPrices, limitAutomaticPrices, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsInAppPurchasePrices the fields to include for returned resources of type inAppPurchasePrices
     * @param fieldsInAppPurchases the fields to include for returned resources of type inAppPurchases
     * @param fieldsInAppPurchasePriceSchedules the fields to include for returned resources of type inAppPurchasePriceSchedules
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limitManualPrices maximum number of related manualPrices returned (when they are included)
     * @param limitAutomaticPrices maximum number of related automaticPrices returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public inAppPurchasesV2IapPriceScheduleGetToOneRelated(id: string, fieldsInAppPurchasePrices?: Array<'endDate' | 'inAppPurchasePricePoint' | 'inAppPurchaseV2' | 'manual' | 'startDate' | 'territory'>, fieldsInAppPurchases?: Array<'app' | 'appStoreReviewScreenshot' | 'content' | 'contentHosting' | 'familySharable' | 'iapPriceSchedule' | 'inAppPurchaseAvailability' | 'inAppPurchaseLocalizations' | 'inAppPurchaseType' | 'name' | 'pricePoints' | 'productId' | 'promotedPurchase' | 'reviewNote' | 'state'>, fieldsInAppPurchasePriceSchedules?: Array<'automaticPrices' | 'baseTerritory' | 'inAppPurchase' | 'manualPrices'>, fieldsTerritories?: Array<'currency'>, limitManualPrices?: number, limitAutomaticPrices?: number, include?: Array<'automaticPrices' | 'baseTerritory' | 'inAppPurchase' | 'manualPrices'>, _options?: Configuration): Promise<InAppPurchasePriceScheduleResponse> {
        const result = this.api.inAppPurchasesV2IapPriceScheduleGetToOneRelated(id, fieldsInAppPurchasePrices, fieldsInAppPurchases, fieldsInAppPurchasePriceSchedules, fieldsTerritories, limitManualPrices, limitAutomaticPrices, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsInAppPurchaseAvailabilities the fields to include for returned resources of type inAppPurchaseAvailabilities
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limitAvailableTerritories maximum number of related availableTerritories returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public inAppPurchasesV2InAppPurchaseAvailabilityGetToOneRelatedWithHttpInfo(id: string, fieldsInAppPurchaseAvailabilities?: Array<'availableInNewTerritories' | 'availableTerritories' | 'inAppPurchase'>, fieldsTerritories?: Array<'currency'>, limitAvailableTerritories?: number, include?: Array<'availableTerritories'>, _options?: Configuration): Promise<HttpInfo<InAppPurchaseAvailabilityResponse>> {
        const result = this.api.inAppPurchasesV2InAppPurchaseAvailabilityGetToOneRelatedWithHttpInfo(id, fieldsInAppPurchaseAvailabilities, fieldsTerritories, limitAvailableTerritories, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsInAppPurchaseAvailabilities the fields to include for returned resources of type inAppPurchaseAvailabilities
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limitAvailableTerritories maximum number of related availableTerritories returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public inAppPurchasesV2InAppPurchaseAvailabilityGetToOneRelated(id: string, fieldsInAppPurchaseAvailabilities?: Array<'availableInNewTerritories' | 'availableTerritories' | 'inAppPurchase'>, fieldsTerritories?: Array<'currency'>, limitAvailableTerritories?: number, include?: Array<'availableTerritories'>, _options?: Configuration): Promise<InAppPurchaseAvailabilityResponse> {
        const result = this.api.inAppPurchasesV2InAppPurchaseAvailabilityGetToOneRelated(id, fieldsInAppPurchaseAvailabilities, fieldsTerritories, limitAvailableTerritories, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsInAppPurchaseLocalizations the fields to include for returned resources of type inAppPurchaseLocalizations
     * @param fieldsInAppPurchases the fields to include for returned resources of type inAppPurchases
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public inAppPurchasesV2InAppPurchaseLocalizationsGetToManyRelatedWithHttpInfo(id: string, fieldsInAppPurchaseLocalizations?: Array<'description' | 'inAppPurchaseV2' | 'locale' | 'name' | 'state'>, fieldsInAppPurchases?: Array<'app' | 'appStoreReviewScreenshot' | 'content' | 'contentHosting' | 'familySharable' | 'iapPriceSchedule' | 'inAppPurchaseAvailability' | 'inAppPurchaseLocalizations' | 'inAppPurchaseType' | 'name' | 'pricePoints' | 'productId' | 'promotedPurchase' | 'reviewNote' | 'state'>, limit?: number, include?: Array<'inAppPurchaseV2'>, _options?: Configuration): Promise<HttpInfo<InAppPurchaseLocalizationsResponse>> {
        const result = this.api.inAppPurchasesV2InAppPurchaseLocalizationsGetToManyRelatedWithHttpInfo(id, fieldsInAppPurchaseLocalizations, fieldsInAppPurchases, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsInAppPurchaseLocalizations the fields to include for returned resources of type inAppPurchaseLocalizations
     * @param fieldsInAppPurchases the fields to include for returned resources of type inAppPurchases
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public inAppPurchasesV2InAppPurchaseLocalizationsGetToManyRelated(id: string, fieldsInAppPurchaseLocalizations?: Array<'description' | 'inAppPurchaseV2' | 'locale' | 'name' | 'state'>, fieldsInAppPurchases?: Array<'app' | 'appStoreReviewScreenshot' | 'content' | 'contentHosting' | 'familySharable' | 'iapPriceSchedule' | 'inAppPurchaseAvailability' | 'inAppPurchaseLocalizations' | 'inAppPurchaseType' | 'name' | 'pricePoints' | 'productId' | 'promotedPurchase' | 'reviewNote' | 'state'>, limit?: number, include?: Array<'inAppPurchaseV2'>, _options?: Configuration): Promise<InAppPurchaseLocalizationsResponse> {
        const result = this.api.inAppPurchasesV2InAppPurchaseLocalizationsGetToManyRelated(id, fieldsInAppPurchaseLocalizations, fieldsInAppPurchases, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterPriceTier filter by attribute \&#39;priceTier\&#39;
     * @param filterTerritory filter by id(s) of related \&#39;territory\&#39;
     * @param fieldsInAppPurchasePricePoints the fields to include for returned resources of type inAppPurchasePricePoints
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public inAppPurchasesV2PricePointsGetToManyRelatedWithHttpInfo(id: string, filterPriceTier?: Array<string>, filterTerritory?: Array<string>, fieldsInAppPurchasePricePoints?: Array<'customerPrice' | 'inAppPurchaseV2' | 'priceTier' | 'proceeds' | 'territory'>, fieldsTerritories?: Array<'currency'>, limit?: number, include?: Array<'territory'>, _options?: Configuration): Promise<HttpInfo<InAppPurchasePricePointsResponse>> {
        const result = this.api.inAppPurchasesV2PricePointsGetToManyRelatedWithHttpInfo(id, filterPriceTier, filterTerritory, fieldsInAppPurchasePricePoints, fieldsTerritories, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterPriceTier filter by attribute \&#39;priceTier\&#39;
     * @param filterTerritory filter by id(s) of related \&#39;territory\&#39;
     * @param fieldsInAppPurchasePricePoints the fields to include for returned resources of type inAppPurchasePricePoints
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public inAppPurchasesV2PricePointsGetToManyRelated(id: string, filterPriceTier?: Array<string>, filterTerritory?: Array<string>, fieldsInAppPurchasePricePoints?: Array<'customerPrice' | 'inAppPurchaseV2' | 'priceTier' | 'proceeds' | 'territory'>, fieldsTerritories?: Array<'currency'>, limit?: number, include?: Array<'territory'>, _options?: Configuration): Promise<InAppPurchasePricePointsResponse> {
        const result = this.api.inAppPurchasesV2PricePointsGetToManyRelated(id, filterPriceTier, filterTerritory, fieldsInAppPurchasePricePoints, fieldsTerritories, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsPromotedPurchases the fields to include for returned resources of type promotedPurchases
     * @param fieldsSubscriptions the fields to include for returned resources of type subscriptions
     * @param fieldsInAppPurchases the fields to include for returned resources of type inAppPurchases
     * @param fieldsPromotedPurchaseImages the fields to include for returned resources of type promotedPurchaseImages
     * @param limitPromotionImages maximum number of related promotionImages returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public inAppPurchasesV2PromotedPurchaseGetToOneRelatedWithHttpInfo(id: string, fieldsPromotedPurchases?: Array<'app' | 'enabled' | 'inAppPurchaseV2' | 'promotionImages' | 'state' | 'subscription' | 'visibleForAllUsers'>, fieldsSubscriptions?: Array<'appStoreReviewScreenshot' | 'familySharable' | 'group' | 'groupLevel' | 'introductoryOffers' | 'name' | 'offerCodes' | 'pricePoints' | 'prices' | 'productId' | 'promotedPurchase' | 'promotionalOffers' | 'reviewNote' | 'state' | 'subscriptionAvailability' | 'subscriptionLocalizations' | 'subscriptionPeriod'>, fieldsInAppPurchases?: Array<'app' | 'appStoreReviewScreenshot' | 'content' | 'contentHosting' | 'familySharable' | 'iapPriceSchedule' | 'inAppPurchaseAvailability' | 'inAppPurchaseLocalizations' | 'inAppPurchaseType' | 'name' | 'pricePoints' | 'productId' | 'promotedPurchase' | 'reviewNote' | 'state'>, fieldsPromotedPurchaseImages?: Array<'assetToken' | 'assetType' | 'fileName' | 'fileSize' | 'imageAsset' | 'promotedPurchase' | 'sourceFileChecksum' | 'state' | 'uploadOperations' | 'uploaded'>, limitPromotionImages?: number, include?: Array<'inAppPurchaseV2' | 'promotionImages' | 'subscription'>, _options?: Configuration): Promise<HttpInfo<PromotedPurchaseResponse>> {
        const result = this.api.inAppPurchasesV2PromotedPurchaseGetToOneRelatedWithHttpInfo(id, fieldsPromotedPurchases, fieldsSubscriptions, fieldsInAppPurchases, fieldsPromotedPurchaseImages, limitPromotionImages, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsPromotedPurchases the fields to include for returned resources of type promotedPurchases
     * @param fieldsSubscriptions the fields to include for returned resources of type subscriptions
     * @param fieldsInAppPurchases the fields to include for returned resources of type inAppPurchases
     * @param fieldsPromotedPurchaseImages the fields to include for returned resources of type promotedPurchaseImages
     * @param limitPromotionImages maximum number of related promotionImages returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public inAppPurchasesV2PromotedPurchaseGetToOneRelated(id: string, fieldsPromotedPurchases?: Array<'app' | 'enabled' | 'inAppPurchaseV2' | 'promotionImages' | 'state' | 'subscription' | 'visibleForAllUsers'>, fieldsSubscriptions?: Array<'appStoreReviewScreenshot' | 'familySharable' | 'group' | 'groupLevel' | 'introductoryOffers' | 'name' | 'offerCodes' | 'pricePoints' | 'prices' | 'productId' | 'promotedPurchase' | 'promotionalOffers' | 'reviewNote' | 'state' | 'subscriptionAvailability' | 'subscriptionLocalizations' | 'subscriptionPeriod'>, fieldsInAppPurchases?: Array<'app' | 'appStoreReviewScreenshot' | 'content' | 'contentHosting' | 'familySharable' | 'iapPriceSchedule' | 'inAppPurchaseAvailability' | 'inAppPurchaseLocalizations' | 'inAppPurchaseType' | 'name' | 'pricePoints' | 'productId' | 'promotedPurchase' | 'reviewNote' | 'state'>, fieldsPromotedPurchaseImages?: Array<'assetToken' | 'assetType' | 'fileName' | 'fileSize' | 'imageAsset' | 'promotedPurchase' | 'sourceFileChecksum' | 'state' | 'uploadOperations' | 'uploaded'>, limitPromotionImages?: number, include?: Array<'inAppPurchaseV2' | 'promotionImages' | 'subscription'>, _options?: Configuration): Promise<PromotedPurchaseResponse> {
        const result = this.api.inAppPurchasesV2PromotedPurchaseGetToOneRelated(id, fieldsPromotedPurchases, fieldsSubscriptions, fieldsInAppPurchases, fieldsPromotedPurchaseImages, limitPromotionImages, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param inAppPurchaseV2UpdateRequest InAppPurchase representation
     */
    public inAppPurchasesV2UpdateInstanceWithHttpInfo(id: string, inAppPurchaseV2UpdateRequest: InAppPurchaseV2UpdateRequest, _options?: Configuration): Promise<HttpInfo<InAppPurchaseV2Response>> {
        const result = this.api.inAppPurchasesV2UpdateInstanceWithHttpInfo(id, inAppPurchaseV2UpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param inAppPurchaseV2UpdateRequest InAppPurchase representation
     */
    public inAppPurchasesV2UpdateInstance(id: string, inAppPurchaseV2UpdateRequest: InAppPurchaseV2UpdateRequest, _options?: Configuration): Promise<InAppPurchaseV2Response> {
        const result = this.api.inAppPurchasesV2UpdateInstance(id, inAppPurchaseV2UpdateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableMarketplaceDomainsApi } from './ObservableAPI.ts';

import { MarketplaceDomainsApiRequestFactory, MarketplaceDomainsApiResponseProcessor} from "../apis/MarketplaceDomainsApi.ts";
export class PromiseMarketplaceDomainsApi {
    private api: ObservableMarketplaceDomainsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: MarketplaceDomainsApiRequestFactory,
        responseProcessor?: MarketplaceDomainsApiResponseProcessor
    ) {
        this.api = new ObservableMarketplaceDomainsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param marketplaceDomainCreateRequest MarketplaceDomain representation
     */
    public marketplaceDomainsCreateInstanceWithHttpInfo(marketplaceDomainCreateRequest: MarketplaceDomainCreateRequest, _options?: Configuration): Promise<HttpInfo<MarketplaceDomainResponse>> {
        const result = this.api.marketplaceDomainsCreateInstanceWithHttpInfo(marketplaceDomainCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param marketplaceDomainCreateRequest MarketplaceDomain representation
     */
    public marketplaceDomainsCreateInstance(marketplaceDomainCreateRequest: MarketplaceDomainCreateRequest, _options?: Configuration): Promise<MarketplaceDomainResponse> {
        const result = this.api.marketplaceDomainsCreateInstance(marketplaceDomainCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public marketplaceDomainsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.marketplaceDomainsDeleteInstanceWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public marketplaceDomainsDeleteInstance(id: string, _options?: Configuration): Promise<void> {
        const result = this.api.marketplaceDomainsDeleteInstance(id, _options);
        return result.toPromise();
    }

    /**
     * @param fieldsMarketplaceDomains the fields to include for returned resources of type marketplaceDomains
     * @param limit maximum resources per page
     */
    public marketplaceDomainsGetCollectionWithHttpInfo(fieldsMarketplaceDomains?: Array<'createdDate' | 'domain' | 'referenceName'>, limit?: number, _options?: Configuration): Promise<HttpInfo<MarketplaceDomainsResponse>> {
        const result = this.api.marketplaceDomainsGetCollectionWithHttpInfo(fieldsMarketplaceDomains, limit, _options);
        return result.toPromise();
    }

    /**
     * @param fieldsMarketplaceDomains the fields to include for returned resources of type marketplaceDomains
     * @param limit maximum resources per page
     */
    public marketplaceDomainsGetCollection(fieldsMarketplaceDomains?: Array<'createdDate' | 'domain' | 'referenceName'>, limit?: number, _options?: Configuration): Promise<MarketplaceDomainsResponse> {
        const result = this.api.marketplaceDomainsGetCollection(fieldsMarketplaceDomains, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsMarketplaceDomains the fields to include for returned resources of type marketplaceDomains
     */
    public marketplaceDomainsGetInstanceWithHttpInfo(id: string, fieldsMarketplaceDomains?: Array<'createdDate' | 'domain' | 'referenceName'>, _options?: Configuration): Promise<HttpInfo<MarketplaceDomainResponse>> {
        const result = this.api.marketplaceDomainsGetInstanceWithHttpInfo(id, fieldsMarketplaceDomains, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsMarketplaceDomains the fields to include for returned resources of type marketplaceDomains
     */
    public marketplaceDomainsGetInstance(id: string, fieldsMarketplaceDomains?: Array<'createdDate' | 'domain' | 'referenceName'>, _options?: Configuration): Promise<MarketplaceDomainResponse> {
        const result = this.api.marketplaceDomainsGetInstance(id, fieldsMarketplaceDomains, _options);
        return result.toPromise();
    }


}



import { ObservableMarketplaceSearchDetailsApi } from './ObservableAPI.ts';

import { MarketplaceSearchDetailsApiRequestFactory, MarketplaceSearchDetailsApiResponseProcessor} from "../apis/MarketplaceSearchDetailsApi.ts";
export class PromiseMarketplaceSearchDetailsApi {
    private api: ObservableMarketplaceSearchDetailsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: MarketplaceSearchDetailsApiRequestFactory,
        responseProcessor?: MarketplaceSearchDetailsApiResponseProcessor
    ) {
        this.api = new ObservableMarketplaceSearchDetailsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param marketplaceSearchDetailCreateRequest MarketplaceSearchDetail representation
     */
    public marketplaceSearchDetailsCreateInstanceWithHttpInfo(marketplaceSearchDetailCreateRequest: MarketplaceSearchDetailCreateRequest, _options?: Configuration): Promise<HttpInfo<MarketplaceSearchDetailResponse>> {
        const result = this.api.marketplaceSearchDetailsCreateInstanceWithHttpInfo(marketplaceSearchDetailCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param marketplaceSearchDetailCreateRequest MarketplaceSearchDetail representation
     */
    public marketplaceSearchDetailsCreateInstance(marketplaceSearchDetailCreateRequest: MarketplaceSearchDetailCreateRequest, _options?: Configuration): Promise<MarketplaceSearchDetailResponse> {
        const result = this.api.marketplaceSearchDetailsCreateInstance(marketplaceSearchDetailCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public marketplaceSearchDetailsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.marketplaceSearchDetailsDeleteInstanceWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public marketplaceSearchDetailsDeleteInstance(id: string, _options?: Configuration): Promise<void> {
        const result = this.api.marketplaceSearchDetailsDeleteInstance(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param marketplaceSearchDetailUpdateRequest MarketplaceSearchDetail representation
     */
    public marketplaceSearchDetailsUpdateInstanceWithHttpInfo(id: string, marketplaceSearchDetailUpdateRequest: MarketplaceSearchDetailUpdateRequest, _options?: Configuration): Promise<HttpInfo<MarketplaceSearchDetailResponse>> {
        const result = this.api.marketplaceSearchDetailsUpdateInstanceWithHttpInfo(id, marketplaceSearchDetailUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param marketplaceSearchDetailUpdateRequest MarketplaceSearchDetail representation
     */
    public marketplaceSearchDetailsUpdateInstance(id: string, marketplaceSearchDetailUpdateRequest: MarketplaceSearchDetailUpdateRequest, _options?: Configuration): Promise<MarketplaceSearchDetailResponse> {
        const result = this.api.marketplaceSearchDetailsUpdateInstance(id, marketplaceSearchDetailUpdateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableMarketplaceWebhooksApi } from './ObservableAPI.ts';

import { MarketplaceWebhooksApiRequestFactory, MarketplaceWebhooksApiResponseProcessor} from "../apis/MarketplaceWebhooksApi.ts";
export class PromiseMarketplaceWebhooksApi {
    private api: ObservableMarketplaceWebhooksApi

    public constructor(
        configuration: Configuration,
        requestFactory?: MarketplaceWebhooksApiRequestFactory,
        responseProcessor?: MarketplaceWebhooksApiResponseProcessor
    ) {
        this.api = new ObservableMarketplaceWebhooksApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param marketplaceWebhookCreateRequest MarketplaceWebhook representation
     */
    public marketplaceWebhooksCreateInstanceWithHttpInfo(marketplaceWebhookCreateRequest: MarketplaceWebhookCreateRequest, _options?: Configuration): Promise<HttpInfo<MarketplaceWebhookResponse>> {
        const result = this.api.marketplaceWebhooksCreateInstanceWithHttpInfo(marketplaceWebhookCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param marketplaceWebhookCreateRequest MarketplaceWebhook representation
     */
    public marketplaceWebhooksCreateInstance(marketplaceWebhookCreateRequest: MarketplaceWebhookCreateRequest, _options?: Configuration): Promise<MarketplaceWebhookResponse> {
        const result = this.api.marketplaceWebhooksCreateInstance(marketplaceWebhookCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public marketplaceWebhooksDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.marketplaceWebhooksDeleteInstanceWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public marketplaceWebhooksDeleteInstance(id: string, _options?: Configuration): Promise<void> {
        const result = this.api.marketplaceWebhooksDeleteInstance(id, _options);
        return result.toPromise();
    }

    /**
     * @param fieldsMarketplaceWebhooks the fields to include for returned resources of type marketplaceWebhooks
     * @param limit maximum resources per page
     */
    public marketplaceWebhooksGetCollectionWithHttpInfo(fieldsMarketplaceWebhooks?: Array<'endpointUrl' | 'secret'>, limit?: number, _options?: Configuration): Promise<HttpInfo<MarketplaceWebhooksResponse>> {
        const result = this.api.marketplaceWebhooksGetCollectionWithHttpInfo(fieldsMarketplaceWebhooks, limit, _options);
        return result.toPromise();
    }

    /**
     * @param fieldsMarketplaceWebhooks the fields to include for returned resources of type marketplaceWebhooks
     * @param limit maximum resources per page
     */
    public marketplaceWebhooksGetCollection(fieldsMarketplaceWebhooks?: Array<'endpointUrl' | 'secret'>, limit?: number, _options?: Configuration): Promise<MarketplaceWebhooksResponse> {
        const result = this.api.marketplaceWebhooksGetCollection(fieldsMarketplaceWebhooks, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param marketplaceWebhookUpdateRequest MarketplaceWebhook representation
     */
    public marketplaceWebhooksUpdateInstanceWithHttpInfo(id: string, marketplaceWebhookUpdateRequest: MarketplaceWebhookUpdateRequest, _options?: Configuration): Promise<HttpInfo<MarketplaceWebhookResponse>> {
        const result = this.api.marketplaceWebhooksUpdateInstanceWithHttpInfo(id, marketplaceWebhookUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param marketplaceWebhookUpdateRequest MarketplaceWebhook representation
     */
    public marketplaceWebhooksUpdateInstance(id: string, marketplaceWebhookUpdateRequest: MarketplaceWebhookUpdateRequest, _options?: Configuration): Promise<MarketplaceWebhookResponse> {
        const result = this.api.marketplaceWebhooksUpdateInstance(id, marketplaceWebhookUpdateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableMetricsApi } from './ObservableAPI.ts';

import { MetricsApiRequestFactory, MetricsApiResponseProcessor} from "../apis/MetricsApi.ts";
export class PromiseMetricsApi {
    private api: ObservableMetricsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: MetricsApiRequestFactory,
        responseProcessor?: MetricsApiResponseProcessor
    ) {
        this.api = new ObservableMetricsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum number of groups to return per page
     * @param groupBy the dimension by which to group the results
     * @param filterBetaTesters filter by \&#39;betaTesters\&#39; relationship dimension
     * @param period the duration of the reporting period
     */
    public appsBetaTesterUsagesGetMetricsWithHttpInfo(id: string, limit?: number, groupBy?: Array<'betaTesters'>, filterBetaTesters?: string, period?: 'P7D' | 'P30D' | 'P90D' | 'P365D', _options?: Configuration): Promise<HttpInfo<AppsBetaTesterUsagesV1MetricResponse>> {
        const result = this.api.appsBetaTesterUsagesGetMetricsWithHttpInfo(id, limit, groupBy, filterBetaTesters, period, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum number of groups to return per page
     * @param groupBy the dimension by which to group the results
     * @param filterBetaTesters filter by \&#39;betaTesters\&#39; relationship dimension
     * @param period the duration of the reporting period
     */
    public appsBetaTesterUsagesGetMetrics(id: string, limit?: number, groupBy?: Array<'betaTesters'>, filterBetaTesters?: string, period?: 'P7D' | 'P30D' | 'P90D' | 'P365D', _options?: Configuration): Promise<AppsBetaTesterUsagesV1MetricResponse> {
        const result = this.api.appsBetaTesterUsagesGetMetrics(id, limit, groupBy, filterBetaTesters, period, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum number of groups to return per page
     * @param groupBy the dimension by which to group the results
     * @param filterBetaTesters filter by \&#39;betaTesters\&#39; relationship dimension
     * @param period the duration of the reporting period
     */
    public betaGroupsBetaTesterUsagesGetMetricsWithHttpInfo(id: string, limit?: number, groupBy?: Array<'betaTesters'>, filterBetaTesters?: string, period?: 'P7D' | 'P30D' | 'P90D' | 'P365D', _options?: Configuration): Promise<HttpInfo<AppsBetaTesterUsagesV1MetricResponse>> {
        const result = this.api.betaGroupsBetaTesterUsagesGetMetricsWithHttpInfo(id, limit, groupBy, filterBetaTesters, period, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum number of groups to return per page
     * @param groupBy the dimension by which to group the results
     * @param filterBetaTesters filter by \&#39;betaTesters\&#39; relationship dimension
     * @param period the duration of the reporting period
     */
    public betaGroupsBetaTesterUsagesGetMetrics(id: string, limit?: number, groupBy?: Array<'betaTesters'>, filterBetaTesters?: string, period?: 'P7D' | 'P30D' | 'P90D' | 'P365D', _options?: Configuration): Promise<AppsBetaTesterUsagesV1MetricResponse> {
        const result = this.api.betaGroupsBetaTesterUsagesGetMetrics(id, limit, groupBy, filterBetaTesters, period, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterApps filter by \&#39;apps\&#39; relationship dimension
     * @param limit maximum number of groups to return per page
     * @param period the duration of the reporting period
     */
    public betaTestersBetaTesterUsagesGetMetricsWithHttpInfo(id: string, filterApps: string, limit?: number, period?: 'P7D' | 'P30D' | 'P90D' | 'P365D', _options?: Configuration): Promise<HttpInfo<BetaTesterUsagesV1MetricResponse>> {
        const result = this.api.betaTestersBetaTesterUsagesGetMetricsWithHttpInfo(id, filterApps, limit, period, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterApps filter by \&#39;apps\&#39; relationship dimension
     * @param limit maximum number of groups to return per page
     * @param period the duration of the reporting period
     */
    public betaTestersBetaTesterUsagesGetMetrics(id: string, filterApps: string, limit?: number, period?: 'P7D' | 'P30D' | 'P90D' | 'P365D', _options?: Configuration): Promise<BetaTesterUsagesV1MetricResponse> {
        const result = this.api.betaTestersBetaTesterUsagesGetMetrics(id, filterApps, limit, period, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum number of groups to return per page
     */
    public buildsBetaBuildUsagesGetMetricsWithHttpInfo(id: string, limit?: number, _options?: Configuration): Promise<HttpInfo<BetaBuildUsagesV1MetricResponse>> {
        const result = this.api.buildsBetaBuildUsagesGetMetricsWithHttpInfo(id, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum number of groups to return per page
     */
    public buildsBetaBuildUsagesGetMetrics(id: string, limit?: number, _options?: Configuration): Promise<BetaBuildUsagesV1MetricResponse> {
        const result = this.api.buildsBetaBuildUsagesGetMetrics(id, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param granularity the granularity of the per-group dataset
     * @param limit maximum number of groups to return per page
     * @param groupBy the dimension by which to group the results
     * @param filterResult filter by \&#39;result\&#39; attribute dimension
     * @param sort comma-separated list of sort expressions; metrics will be sorted as specified
     */
    public gameCenterDetailsClassicMatchmakingRequestsGetMetricsWithHttpInfo(id: string, granularity: 'P1D' | 'PT1H' | 'PT15M', limit?: number, groupBy?: Array<'result'>, filterResult?: 'MATCHED' | 'CANCELED' | 'EXPIRED', sort?: Array<'averageSecondsInQueue' | '-averageSecondsInQueue' | 'count' | '-count' | 'p50SecondsInQueue' | '-p50SecondsInQueue' | 'p95SecondsInQueue' | '-p95SecondsInQueue'>, _options?: Configuration): Promise<HttpInfo<GameCenterMatchmakingAppRequestsV1MetricResponse>> {
        const result = this.api.gameCenterDetailsClassicMatchmakingRequestsGetMetricsWithHttpInfo(id, granularity, limit, groupBy, filterResult, sort, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param granularity the granularity of the per-group dataset
     * @param limit maximum number of groups to return per page
     * @param groupBy the dimension by which to group the results
     * @param filterResult filter by \&#39;result\&#39; attribute dimension
     * @param sort comma-separated list of sort expressions; metrics will be sorted as specified
     */
    public gameCenterDetailsClassicMatchmakingRequestsGetMetrics(id: string, granularity: 'P1D' | 'PT1H' | 'PT15M', limit?: number, groupBy?: Array<'result'>, filterResult?: 'MATCHED' | 'CANCELED' | 'EXPIRED', sort?: Array<'averageSecondsInQueue' | '-averageSecondsInQueue' | 'count' | '-count' | 'p50SecondsInQueue' | '-p50SecondsInQueue' | 'p95SecondsInQueue' | '-p95SecondsInQueue'>, _options?: Configuration): Promise<GameCenterMatchmakingAppRequestsV1MetricResponse> {
        const result = this.api.gameCenterDetailsClassicMatchmakingRequestsGetMetrics(id, granularity, limit, groupBy, filterResult, sort, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param granularity the granularity of the per-group dataset
     * @param limit maximum number of groups to return per page
     * @param groupBy the dimension by which to group the results
     * @param filterResult filter by \&#39;result\&#39; attribute dimension
     * @param sort comma-separated list of sort expressions; metrics will be sorted as specified
     */
    public gameCenterDetailsRuleBasedMatchmakingRequestsGetMetricsWithHttpInfo(id: string, granularity: 'P1D' | 'PT1H' | 'PT15M', limit?: number, groupBy?: Array<'result'>, filterResult?: 'MATCHED' | 'CANCELED' | 'EXPIRED', sort?: Array<'averageSecondsInQueue' | '-averageSecondsInQueue' | 'count' | '-count' | 'p50SecondsInQueue' | '-p50SecondsInQueue' | 'p95SecondsInQueue' | '-p95SecondsInQueue'>, _options?: Configuration): Promise<HttpInfo<GameCenterMatchmakingAppRequestsV1MetricResponse>> {
        const result = this.api.gameCenterDetailsRuleBasedMatchmakingRequestsGetMetricsWithHttpInfo(id, granularity, limit, groupBy, filterResult, sort, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param granularity the granularity of the per-group dataset
     * @param limit maximum number of groups to return per page
     * @param groupBy the dimension by which to group the results
     * @param filterResult filter by \&#39;result\&#39; attribute dimension
     * @param sort comma-separated list of sort expressions; metrics will be sorted as specified
     */
    public gameCenterDetailsRuleBasedMatchmakingRequestsGetMetrics(id: string, granularity: 'P1D' | 'PT1H' | 'PT15M', limit?: number, groupBy?: Array<'result'>, filterResult?: 'MATCHED' | 'CANCELED' | 'EXPIRED', sort?: Array<'averageSecondsInQueue' | '-averageSecondsInQueue' | 'count' | '-count' | 'p50SecondsInQueue' | '-p50SecondsInQueue' | 'p95SecondsInQueue' | '-p95SecondsInQueue'>, _options?: Configuration): Promise<GameCenterMatchmakingAppRequestsV1MetricResponse> {
        const result = this.api.gameCenterDetailsRuleBasedMatchmakingRequestsGetMetrics(id, granularity, limit, groupBy, filterResult, sort, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param granularity the granularity of the per-group dataset
     * @param limit maximum number of groups to return per page
     * @param sort comma-separated list of sort expressions; metrics will be sorted as specified
     */
    public gameCenterMatchmakingQueuesExperimentMatchmakingQueueSizesGetMetricsWithHttpInfo(id: string, granularity: 'P1D' | 'PT1H' | 'PT15M', limit?: number, sort?: Array<'averageNumberOfRequests' | '-averageNumberOfRequests' | 'count' | '-count' | 'p50NumberOfRequests' | '-p50NumberOfRequests' | 'p95NumberOfRequests' | '-p95NumberOfRequests'>, _options?: Configuration): Promise<HttpInfo<GameCenterMatchmakingQueueSizesV1MetricResponse>> {
        const result = this.api.gameCenterMatchmakingQueuesExperimentMatchmakingQueueSizesGetMetricsWithHttpInfo(id, granularity, limit, sort, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param granularity the granularity of the per-group dataset
     * @param limit maximum number of groups to return per page
     * @param sort comma-separated list of sort expressions; metrics will be sorted as specified
     */
    public gameCenterMatchmakingQueuesExperimentMatchmakingQueueSizesGetMetrics(id: string, granularity: 'P1D' | 'PT1H' | 'PT15M', limit?: number, sort?: Array<'averageNumberOfRequests' | '-averageNumberOfRequests' | 'count' | '-count' | 'p50NumberOfRequests' | '-p50NumberOfRequests' | 'p95NumberOfRequests' | '-p95NumberOfRequests'>, _options?: Configuration): Promise<GameCenterMatchmakingQueueSizesV1MetricResponse> {
        const result = this.api.gameCenterMatchmakingQueuesExperimentMatchmakingQueueSizesGetMetrics(id, granularity, limit, sort, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param granularity the granularity of the per-group dataset
     * @param limit maximum number of groups to return per page
     * @param groupBy the dimension by which to group the results
     * @param filterResult filter by \&#39;result\&#39; attribute dimension
     * @param filterGameCenterDetail filter by \&#39;gameCenterDetail\&#39; relationship dimension
     * @param sort comma-separated list of sort expressions; metrics will be sorted as specified
     */
    public gameCenterMatchmakingQueuesExperimentMatchmakingRequestsGetMetricsWithHttpInfo(id: string, granularity: 'P1D' | 'PT1H' | 'PT15M', limit?: number, groupBy?: Array<'gameCenterDetail' | 'result'>, filterResult?: 'MATCHED' | 'CANCELED' | 'EXPIRED', filterGameCenterDetail?: string, sort?: Array<'averageSecondsInQueue' | '-averageSecondsInQueue' | 'count' | '-count' | 'p50SecondsInQueue' | '-p50SecondsInQueue' | 'p95SecondsInQueue' | '-p95SecondsInQueue'>, _options?: Configuration): Promise<HttpInfo<GameCenterMatchmakingQueueRequestsV1MetricResponse>> {
        const result = this.api.gameCenterMatchmakingQueuesExperimentMatchmakingRequestsGetMetricsWithHttpInfo(id, granularity, limit, groupBy, filterResult, filterGameCenterDetail, sort, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param granularity the granularity of the per-group dataset
     * @param limit maximum number of groups to return per page
     * @param groupBy the dimension by which to group the results
     * @param filterResult filter by \&#39;result\&#39; attribute dimension
     * @param filterGameCenterDetail filter by \&#39;gameCenterDetail\&#39; relationship dimension
     * @param sort comma-separated list of sort expressions; metrics will be sorted as specified
     */
    public gameCenterMatchmakingQueuesExperimentMatchmakingRequestsGetMetrics(id: string, granularity: 'P1D' | 'PT1H' | 'PT15M', limit?: number, groupBy?: Array<'gameCenterDetail' | 'result'>, filterResult?: 'MATCHED' | 'CANCELED' | 'EXPIRED', filterGameCenterDetail?: string, sort?: Array<'averageSecondsInQueue' | '-averageSecondsInQueue' | 'count' | '-count' | 'p50SecondsInQueue' | '-p50SecondsInQueue' | 'p95SecondsInQueue' | '-p95SecondsInQueue'>, _options?: Configuration): Promise<GameCenterMatchmakingQueueRequestsV1MetricResponse> {
        const result = this.api.gameCenterMatchmakingQueuesExperimentMatchmakingRequestsGetMetrics(id, granularity, limit, groupBy, filterResult, filterGameCenterDetail, sort, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param granularity the granularity of the per-group dataset
     * @param limit maximum number of groups to return per page
     * @param sort comma-separated list of sort expressions; metrics will be sorted as specified
     */
    public gameCenterMatchmakingQueuesMatchmakingQueueSizesGetMetricsWithHttpInfo(id: string, granularity: 'P1D' | 'PT1H' | 'PT15M', limit?: number, sort?: Array<'averageNumberOfRequests' | '-averageNumberOfRequests' | 'count' | '-count' | 'p50NumberOfRequests' | '-p50NumberOfRequests' | 'p95NumberOfRequests' | '-p95NumberOfRequests'>, _options?: Configuration): Promise<HttpInfo<GameCenterMatchmakingQueueSizesV1MetricResponse>> {
        const result = this.api.gameCenterMatchmakingQueuesMatchmakingQueueSizesGetMetricsWithHttpInfo(id, granularity, limit, sort, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param granularity the granularity of the per-group dataset
     * @param limit maximum number of groups to return per page
     * @param sort comma-separated list of sort expressions; metrics will be sorted as specified
     */
    public gameCenterMatchmakingQueuesMatchmakingQueueSizesGetMetrics(id: string, granularity: 'P1D' | 'PT1H' | 'PT15M', limit?: number, sort?: Array<'averageNumberOfRequests' | '-averageNumberOfRequests' | 'count' | '-count' | 'p50NumberOfRequests' | '-p50NumberOfRequests' | 'p95NumberOfRequests' | '-p95NumberOfRequests'>, _options?: Configuration): Promise<GameCenterMatchmakingQueueSizesV1MetricResponse> {
        const result = this.api.gameCenterMatchmakingQueuesMatchmakingQueueSizesGetMetrics(id, granularity, limit, sort, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param granularity the granularity of the per-group dataset
     * @param limit maximum number of groups to return per page
     * @param groupBy the dimension by which to group the results
     * @param filterResult filter by \&#39;result\&#39; attribute dimension
     * @param filterGameCenterDetail filter by \&#39;gameCenterDetail\&#39; relationship dimension
     * @param sort comma-separated list of sort expressions; metrics will be sorted as specified
     */
    public gameCenterMatchmakingQueuesMatchmakingRequestsGetMetricsWithHttpInfo(id: string, granularity: 'P1D' | 'PT1H' | 'PT15M', limit?: number, groupBy?: Array<'gameCenterDetail' | 'result'>, filterResult?: 'MATCHED' | 'CANCELED' | 'EXPIRED', filterGameCenterDetail?: string, sort?: Array<'averageSecondsInQueue' | '-averageSecondsInQueue' | 'count' | '-count' | 'p50SecondsInQueue' | '-p50SecondsInQueue' | 'p95SecondsInQueue' | '-p95SecondsInQueue'>, _options?: Configuration): Promise<HttpInfo<GameCenterMatchmakingQueueRequestsV1MetricResponse>> {
        const result = this.api.gameCenterMatchmakingQueuesMatchmakingRequestsGetMetricsWithHttpInfo(id, granularity, limit, groupBy, filterResult, filterGameCenterDetail, sort, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param granularity the granularity of the per-group dataset
     * @param limit maximum number of groups to return per page
     * @param groupBy the dimension by which to group the results
     * @param filterResult filter by \&#39;result\&#39; attribute dimension
     * @param filterGameCenterDetail filter by \&#39;gameCenterDetail\&#39; relationship dimension
     * @param sort comma-separated list of sort expressions; metrics will be sorted as specified
     */
    public gameCenterMatchmakingQueuesMatchmakingRequestsGetMetrics(id: string, granularity: 'P1D' | 'PT1H' | 'PT15M', limit?: number, groupBy?: Array<'gameCenterDetail' | 'result'>, filterResult?: 'MATCHED' | 'CANCELED' | 'EXPIRED', filterGameCenterDetail?: string, sort?: Array<'averageSecondsInQueue' | '-averageSecondsInQueue' | 'count' | '-count' | 'p50SecondsInQueue' | '-p50SecondsInQueue' | 'p95SecondsInQueue' | '-p95SecondsInQueue'>, _options?: Configuration): Promise<GameCenterMatchmakingQueueRequestsV1MetricResponse> {
        const result = this.api.gameCenterMatchmakingQueuesMatchmakingRequestsGetMetrics(id, granularity, limit, groupBy, filterResult, filterGameCenterDetail, sort, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param granularity the granularity of the per-group dataset
     * @param limit maximum number of groups to return per page
     * @param sort comma-separated list of sort expressions; metrics will be sorted as specified
     */
    public gameCenterMatchmakingQueuesMatchmakingSessionsGetMetricsWithHttpInfo(id: string, granularity: 'P1D' | 'PT1H' | 'PT15M', limit?: number, sort?: Array<'averagePlayerCount' | '-averagePlayerCount' | 'count' | '-count' | 'p50PlayerCount' | '-p50PlayerCount' | 'p95PlayerCount' | '-p95PlayerCount'>, _options?: Configuration): Promise<HttpInfo<GameCenterMatchmakingSessionsV1MetricResponse>> {
        const result = this.api.gameCenterMatchmakingQueuesMatchmakingSessionsGetMetricsWithHttpInfo(id, granularity, limit, sort, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param granularity the granularity of the per-group dataset
     * @param limit maximum number of groups to return per page
     * @param sort comma-separated list of sort expressions; metrics will be sorted as specified
     */
    public gameCenterMatchmakingQueuesMatchmakingSessionsGetMetrics(id: string, granularity: 'P1D' | 'PT1H' | 'PT15M', limit?: number, sort?: Array<'averagePlayerCount' | '-averagePlayerCount' | 'count' | '-count' | 'p50PlayerCount' | '-p50PlayerCount' | 'p95PlayerCount' | '-p95PlayerCount'>, _options?: Configuration): Promise<GameCenterMatchmakingSessionsV1MetricResponse> {
        const result = this.api.gameCenterMatchmakingQueuesMatchmakingSessionsGetMetrics(id, granularity, limit, sort, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param granularity the granularity of the per-group dataset
     * @param limit maximum number of groups to return per page
     * @param groupBy the dimension by which to group the results
     * @param filterResult filter by \&#39;result\&#39; attribute dimension
     * @param filterGameCenterMatchmakingQueue filter by \&#39;gameCenterMatchmakingQueue\&#39; relationship dimension
     * @param sort comma-separated list of sort expressions; metrics will be sorted as specified
     */
    public gameCenterMatchmakingRulesMatchmakingBooleanRuleResultsGetMetricsWithHttpInfo(id: string, granularity: 'P1D' | 'PT1H' | 'PT15M', limit?: number, groupBy?: Array<'gameCenterMatchmakingQueue' | 'result'>, filterResult?: string, filterGameCenterMatchmakingQueue?: string, sort?: Array<'count' | '-count'>, _options?: Configuration): Promise<HttpInfo<GameCenterMatchmakingBooleanRuleResultsV1MetricResponse>> {
        const result = this.api.gameCenterMatchmakingRulesMatchmakingBooleanRuleResultsGetMetricsWithHttpInfo(id, granularity, limit, groupBy, filterResult, filterGameCenterMatchmakingQueue, sort, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param granularity the granularity of the per-group dataset
     * @param limit maximum number of groups to return per page
     * @param groupBy the dimension by which to group the results
     * @param filterResult filter by \&#39;result\&#39; attribute dimension
     * @param filterGameCenterMatchmakingQueue filter by \&#39;gameCenterMatchmakingQueue\&#39; relationship dimension
     * @param sort comma-separated list of sort expressions; metrics will be sorted as specified
     */
    public gameCenterMatchmakingRulesMatchmakingBooleanRuleResultsGetMetrics(id: string, granularity: 'P1D' | 'PT1H' | 'PT15M', limit?: number, groupBy?: Array<'gameCenterMatchmakingQueue' | 'result'>, filterResult?: string, filterGameCenterMatchmakingQueue?: string, sort?: Array<'count' | '-count'>, _options?: Configuration): Promise<GameCenterMatchmakingBooleanRuleResultsV1MetricResponse> {
        const result = this.api.gameCenterMatchmakingRulesMatchmakingBooleanRuleResultsGetMetrics(id, granularity, limit, groupBy, filterResult, filterGameCenterMatchmakingQueue, sort, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param granularity the granularity of the per-group dataset
     * @param limit maximum number of groups to return per page
     * @param groupBy the dimension by which to group the results
     * @param filterGameCenterMatchmakingQueue filter by \&#39;gameCenterMatchmakingQueue\&#39; relationship dimension
     * @param sort comma-separated list of sort expressions; metrics will be sorted as specified
     */
    public gameCenterMatchmakingRulesMatchmakingNumberRuleResultsGetMetricsWithHttpInfo(id: string, granularity: 'P1D' | 'PT1H' | 'PT15M', limit?: number, groupBy?: Array<'gameCenterMatchmakingQueue'>, filterGameCenterMatchmakingQueue?: string, sort?: Array<'averageResult' | '-averageResult' | 'count' | '-count' | 'p50Result' | '-p50Result' | 'p95Result' | '-p95Result'>, _options?: Configuration): Promise<HttpInfo<GameCenterMatchmakingNumberRuleResultsV1MetricResponse>> {
        const result = this.api.gameCenterMatchmakingRulesMatchmakingNumberRuleResultsGetMetricsWithHttpInfo(id, granularity, limit, groupBy, filterGameCenterMatchmakingQueue, sort, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param granularity the granularity of the per-group dataset
     * @param limit maximum number of groups to return per page
     * @param groupBy the dimension by which to group the results
     * @param filterGameCenterMatchmakingQueue filter by \&#39;gameCenterMatchmakingQueue\&#39; relationship dimension
     * @param sort comma-separated list of sort expressions; metrics will be sorted as specified
     */
    public gameCenterMatchmakingRulesMatchmakingNumberRuleResultsGetMetrics(id: string, granularity: 'P1D' | 'PT1H' | 'PT15M', limit?: number, groupBy?: Array<'gameCenterMatchmakingQueue'>, filterGameCenterMatchmakingQueue?: string, sort?: Array<'averageResult' | '-averageResult' | 'count' | '-count' | 'p50Result' | '-p50Result' | 'p95Result' | '-p95Result'>, _options?: Configuration): Promise<GameCenterMatchmakingNumberRuleResultsV1MetricResponse> {
        const result = this.api.gameCenterMatchmakingRulesMatchmakingNumberRuleResultsGetMetrics(id, granularity, limit, groupBy, filterGameCenterMatchmakingQueue, sort, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param granularity the granularity of the per-group dataset
     * @param limit maximum number of groups to return per page
     * @param groupBy the dimension by which to group the results
     * @param filterGameCenterMatchmakingQueue filter by \&#39;gameCenterMatchmakingQueue\&#39; relationship dimension
     * @param sort comma-separated list of sort expressions; metrics will be sorted as specified
     */
    public gameCenterMatchmakingRulesMatchmakingRuleErrorsGetMetricsWithHttpInfo(id: string, granularity: 'P1D' | 'PT1H' | 'PT15M', limit?: number, groupBy?: Array<'gameCenterMatchmakingQueue'>, filterGameCenterMatchmakingQueue?: string, sort?: Array<'count' | '-count'>, _options?: Configuration): Promise<HttpInfo<GameCenterMatchmakingRuleErrorsV1MetricResponse>> {
        const result = this.api.gameCenterMatchmakingRulesMatchmakingRuleErrorsGetMetricsWithHttpInfo(id, granularity, limit, groupBy, filterGameCenterMatchmakingQueue, sort, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param granularity the granularity of the per-group dataset
     * @param limit maximum number of groups to return per page
     * @param groupBy the dimension by which to group the results
     * @param filterGameCenterMatchmakingQueue filter by \&#39;gameCenterMatchmakingQueue\&#39; relationship dimension
     * @param sort comma-separated list of sort expressions; metrics will be sorted as specified
     */
    public gameCenterMatchmakingRulesMatchmakingRuleErrorsGetMetrics(id: string, granularity: 'P1D' | 'PT1H' | 'PT15M', limit?: number, groupBy?: Array<'gameCenterMatchmakingQueue'>, filterGameCenterMatchmakingQueue?: string, sort?: Array<'count' | '-count'>, _options?: Configuration): Promise<GameCenterMatchmakingRuleErrorsV1MetricResponse> {
        const result = this.api.gameCenterMatchmakingRulesMatchmakingRuleErrorsGetMetrics(id, granularity, limit, groupBy, filterGameCenterMatchmakingQueue, sort, _options);
        return result.toPromise();
    }


}



import { ObservablePreReleaseVersionsApi } from './ObservableAPI.ts';

import { PreReleaseVersionsApiRequestFactory, PreReleaseVersionsApiResponseProcessor} from "../apis/PreReleaseVersionsApi.ts";
export class PromisePreReleaseVersionsApi {
    private api: ObservablePreReleaseVersionsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: PreReleaseVersionsApiRequestFactory,
        responseProcessor?: PreReleaseVersionsApiResponseProcessor
    ) {
        this.api = new ObservablePreReleaseVersionsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsApps the fields to include for returned resources of type apps
     */
    public preReleaseVersionsAppGetToOneRelatedWithHttpInfo(id: string, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, _options?: Configuration): Promise<HttpInfo<AppWithoutIncludesResponse>> {
        const result = this.api.preReleaseVersionsAppGetToOneRelatedWithHttpInfo(id, fieldsApps, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsApps the fields to include for returned resources of type apps
     */
    public preReleaseVersionsAppGetToOneRelated(id: string, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, _options?: Configuration): Promise<AppWithoutIncludesResponse> {
        const result = this.api.preReleaseVersionsAppGetToOneRelated(id, fieldsApps, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param limit maximum resources per page
     */
    public preReleaseVersionsBuildsGetToManyRelatedWithHttpInfo(id: string, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, limit?: number, _options?: Configuration): Promise<HttpInfo<BuildsWithoutIncludesResponse>> {
        const result = this.api.preReleaseVersionsBuildsGetToManyRelatedWithHttpInfo(id, fieldsBuilds, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param limit maximum resources per page
     */
    public preReleaseVersionsBuildsGetToManyRelated(id: string, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, limit?: number, _options?: Configuration): Promise<BuildsWithoutIncludesResponse> {
        const result = this.api.preReleaseVersionsBuildsGetToManyRelated(id, fieldsBuilds, limit, _options);
        return result.toPromise();
    }

    /**
     * @param filterBuildsExpired filter by attribute \&#39;builds.expired\&#39;
     * @param filterBuildsProcessingState filter by attribute \&#39;builds.processingState\&#39;
     * @param filterBuildsVersion filter by attribute \&#39;builds.version\&#39;
     * @param filterPlatform filter by attribute \&#39;platform\&#39;
     * @param filterVersion filter by attribute \&#39;version\&#39;
     * @param filterApp filter by id(s) of related \&#39;app\&#39;
     * @param filterBuilds filter by id(s) of related \&#39;builds\&#39;
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsPreReleaseVersions the fields to include for returned resources of type preReleaseVersions
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param limitBuilds maximum number of related builds returned (when they are included)
     */
    public preReleaseVersionsGetCollectionWithHttpInfo(filterBuildsExpired?: Array<string>, filterBuildsProcessingState?: Array<'PROCESSING' | 'FAILED' | 'INVALID' | 'VALID'>, filterBuildsVersion?: Array<string>, filterPlatform?: Array<'IOS' | 'MAC_OS' | 'TV_OS' | 'VISION_OS'>, filterVersion?: Array<string>, filterApp?: Array<string>, filterBuilds?: Array<string>, sort?: Array<'version' | '-version'>, fieldsPreReleaseVersions?: Array<'app' | 'builds' | 'platform' | 'version'>, limit?: number, include?: Array<'app' | 'builds'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, limitBuilds?: number, _options?: Configuration): Promise<HttpInfo<PreReleaseVersionsResponse>> {
        const result = this.api.preReleaseVersionsGetCollectionWithHttpInfo(filterBuildsExpired, filterBuildsProcessingState, filterBuildsVersion, filterPlatform, filterVersion, filterApp, filterBuilds, sort, fieldsPreReleaseVersions, limit, include, fieldsApps, fieldsBuilds, limitBuilds, _options);
        return result.toPromise();
    }

    /**
     * @param filterBuildsExpired filter by attribute \&#39;builds.expired\&#39;
     * @param filterBuildsProcessingState filter by attribute \&#39;builds.processingState\&#39;
     * @param filterBuildsVersion filter by attribute \&#39;builds.version\&#39;
     * @param filterPlatform filter by attribute \&#39;platform\&#39;
     * @param filterVersion filter by attribute \&#39;version\&#39;
     * @param filterApp filter by id(s) of related \&#39;app\&#39;
     * @param filterBuilds filter by id(s) of related \&#39;builds\&#39;
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsPreReleaseVersions the fields to include for returned resources of type preReleaseVersions
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param limitBuilds maximum number of related builds returned (when they are included)
     */
    public preReleaseVersionsGetCollection(filterBuildsExpired?: Array<string>, filterBuildsProcessingState?: Array<'PROCESSING' | 'FAILED' | 'INVALID' | 'VALID'>, filterBuildsVersion?: Array<string>, filterPlatform?: Array<'IOS' | 'MAC_OS' | 'TV_OS' | 'VISION_OS'>, filterVersion?: Array<string>, filterApp?: Array<string>, filterBuilds?: Array<string>, sort?: Array<'version' | '-version'>, fieldsPreReleaseVersions?: Array<'app' | 'builds' | 'platform' | 'version'>, limit?: number, include?: Array<'app' | 'builds'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, limitBuilds?: number, _options?: Configuration): Promise<PreReleaseVersionsResponse> {
        const result = this.api.preReleaseVersionsGetCollection(filterBuildsExpired, filterBuildsProcessingState, filterBuildsVersion, filterPlatform, filterVersion, filterApp, filterBuilds, sort, fieldsPreReleaseVersions, limit, include, fieldsApps, fieldsBuilds, limitBuilds, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsPreReleaseVersions the fields to include for returned resources of type preReleaseVersions
     * @param include comma-separated list of relationships to include
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param limitBuilds maximum number of related builds returned (when they are included)
     */
    public preReleaseVersionsGetInstanceWithHttpInfo(id: string, fieldsPreReleaseVersions?: Array<'app' | 'builds' | 'platform' | 'version'>, include?: Array<'app' | 'builds'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, limitBuilds?: number, _options?: Configuration): Promise<HttpInfo<PrereleaseVersionResponse>> {
        const result = this.api.preReleaseVersionsGetInstanceWithHttpInfo(id, fieldsPreReleaseVersions, include, fieldsApps, fieldsBuilds, limitBuilds, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsPreReleaseVersions the fields to include for returned resources of type preReleaseVersions
     * @param include comma-separated list of relationships to include
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param fieldsBuilds the fields to include for returned resources of type builds
     * @param limitBuilds maximum number of related builds returned (when they are included)
     */
    public preReleaseVersionsGetInstance(id: string, fieldsPreReleaseVersions?: Array<'app' | 'builds' | 'platform' | 'version'>, include?: Array<'app' | 'builds'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, fieldsBuilds?: Array<'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version'>, limitBuilds?: number, _options?: Configuration): Promise<PrereleaseVersionResponse> {
        const result = this.api.preReleaseVersionsGetInstance(id, fieldsPreReleaseVersions, include, fieldsApps, fieldsBuilds, limitBuilds, _options);
        return result.toPromise();
    }


}



import { ObservableProfilesApi } from './ObservableAPI.ts';

import { ProfilesApiRequestFactory, ProfilesApiResponseProcessor} from "../apis/ProfilesApi.ts";
export class PromiseProfilesApi {
    private api: ObservableProfilesApi

    public constructor(
        configuration: Configuration,
        requestFactory?: ProfilesApiRequestFactory,
        responseProcessor?: ProfilesApiResponseProcessor
    ) {
        this.api = new ObservableProfilesApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBundleIds the fields to include for returned resources of type bundleIds
     */
    public profilesBundleIdGetToOneRelatedWithHttpInfo(id: string, fieldsBundleIds?: Array<'app' | 'bundleIdCapabilities' | 'identifier' | 'name' | 'platform' | 'profiles' | 'seedId'>, _options?: Configuration): Promise<HttpInfo<BundleIdWithoutIncludesResponse>> {
        const result = this.api.profilesBundleIdGetToOneRelatedWithHttpInfo(id, fieldsBundleIds, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsBundleIds the fields to include for returned resources of type bundleIds
     */
    public profilesBundleIdGetToOneRelated(id: string, fieldsBundleIds?: Array<'app' | 'bundleIdCapabilities' | 'identifier' | 'name' | 'platform' | 'profiles' | 'seedId'>, _options?: Configuration): Promise<BundleIdWithoutIncludesResponse> {
        const result = this.api.profilesBundleIdGetToOneRelated(id, fieldsBundleIds, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCertificates the fields to include for returned resources of type certificates
     * @param limit maximum resources per page
     */
    public profilesCertificatesGetToManyRelatedWithHttpInfo(id: string, fieldsCertificates?: Array<'certificateContent' | 'certificateType' | 'csrContent' | 'displayName' | 'expirationDate' | 'name' | 'platform' | 'serialNumber'>, limit?: number, _options?: Configuration): Promise<HttpInfo<CertificatesWithoutIncludesResponse>> {
        const result = this.api.profilesCertificatesGetToManyRelatedWithHttpInfo(id, fieldsCertificates, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsCertificates the fields to include for returned resources of type certificates
     * @param limit maximum resources per page
     */
    public profilesCertificatesGetToManyRelated(id: string, fieldsCertificates?: Array<'certificateContent' | 'certificateType' | 'csrContent' | 'displayName' | 'expirationDate' | 'name' | 'platform' | 'serialNumber'>, limit?: number, _options?: Configuration): Promise<CertificatesWithoutIncludesResponse> {
        const result = this.api.profilesCertificatesGetToManyRelated(id, fieldsCertificates, limit, _options);
        return result.toPromise();
    }

    /**
     * @param profileCreateRequest Profile representation
     */
    public profilesCreateInstanceWithHttpInfo(profileCreateRequest: ProfileCreateRequest, _options?: Configuration): Promise<HttpInfo<ProfileResponse>> {
        const result = this.api.profilesCreateInstanceWithHttpInfo(profileCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param profileCreateRequest Profile representation
     */
    public profilesCreateInstance(profileCreateRequest: ProfileCreateRequest, _options?: Configuration): Promise<ProfileResponse> {
        const result = this.api.profilesCreateInstance(profileCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public profilesDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.profilesDeleteInstanceWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public profilesDeleteInstance(id: string, _options?: Configuration): Promise<void> {
        const result = this.api.profilesDeleteInstance(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsDevices the fields to include for returned resources of type devices
     * @param limit maximum resources per page
     */
    public profilesDevicesGetToManyRelatedWithHttpInfo(id: string, fieldsDevices?: Array<'addedDate' | 'deviceClass' | 'model' | 'name' | 'platform' | 'status' | 'udid'>, limit?: number, _options?: Configuration): Promise<HttpInfo<DevicesWithoutIncludesResponse>> {
        const result = this.api.profilesDevicesGetToManyRelatedWithHttpInfo(id, fieldsDevices, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsDevices the fields to include for returned resources of type devices
     * @param limit maximum resources per page
     */
    public profilesDevicesGetToManyRelated(id: string, fieldsDevices?: Array<'addedDate' | 'deviceClass' | 'model' | 'name' | 'platform' | 'status' | 'udid'>, limit?: number, _options?: Configuration): Promise<DevicesWithoutIncludesResponse> {
        const result = this.api.profilesDevicesGetToManyRelated(id, fieldsDevices, limit, _options);
        return result.toPromise();
    }

    /**
     * @param filterName filter by attribute \&#39;name\&#39;
     * @param filterProfileState filter by attribute \&#39;profileState\&#39;
     * @param filterProfileType filter by attribute \&#39;profileType\&#39;
     * @param filterId filter by id(s)
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsProfiles the fields to include for returned resources of type profiles
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsCertificates the fields to include for returned resources of type certificates
     * @param fieldsDevices the fields to include for returned resources of type devices
     * @param fieldsBundleIds the fields to include for returned resources of type bundleIds
     * @param limitCertificates maximum number of related certificates returned (when they are included)
     * @param limitDevices maximum number of related devices returned (when they are included)
     */
    public profilesGetCollectionWithHttpInfo(filterName?: Array<string>, filterProfileState?: Array<'ACTIVE' | 'INVALID'>, filterProfileType?: Array<'IOS_APP_DEVELOPMENT' | 'IOS_APP_STORE' | 'IOS_APP_ADHOC' | 'IOS_APP_INHOUSE' | 'MAC_APP_DEVELOPMENT' | 'MAC_APP_STORE' | 'MAC_APP_DIRECT' | 'TVOS_APP_DEVELOPMENT' | 'TVOS_APP_STORE' | 'TVOS_APP_ADHOC' | 'TVOS_APP_INHOUSE' | 'MAC_CATALYST_APP_DEVELOPMENT' | 'MAC_CATALYST_APP_STORE' | 'MAC_CATALYST_APP_DIRECT'>, filterId?: Array<string>, sort?: Array<'id' | '-id' | 'name' | '-name' | 'profileState' | '-profileState' | 'profileType' | '-profileType'>, fieldsProfiles?: Array<'bundleId' | 'certificates' | 'createdDate' | 'devices' | 'expirationDate' | 'name' | 'platform' | 'profileContent' | 'profileState' | 'profileType' | 'uuid'>, limit?: number, include?: Array<'bundleId' | 'certificates' | 'devices'>, fieldsCertificates?: Array<'certificateContent' | 'certificateType' | 'csrContent' | 'displayName' | 'expirationDate' | 'name' | 'platform' | 'serialNumber'>, fieldsDevices?: Array<'addedDate' | 'deviceClass' | 'model' | 'name' | 'platform' | 'status' | 'udid'>, fieldsBundleIds?: Array<'app' | 'bundleIdCapabilities' | 'identifier' | 'name' | 'platform' | 'profiles' | 'seedId'>, limitCertificates?: number, limitDevices?: number, _options?: Configuration): Promise<HttpInfo<ProfilesResponse>> {
        const result = this.api.profilesGetCollectionWithHttpInfo(filterName, filterProfileState, filterProfileType, filterId, sort, fieldsProfiles, limit, include, fieldsCertificates, fieldsDevices, fieldsBundleIds, limitCertificates, limitDevices, _options);
        return result.toPromise();
    }

    /**
     * @param filterName filter by attribute \&#39;name\&#39;
     * @param filterProfileState filter by attribute \&#39;profileState\&#39;
     * @param filterProfileType filter by attribute \&#39;profileType\&#39;
     * @param filterId filter by id(s)
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsProfiles the fields to include for returned resources of type profiles
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsCertificates the fields to include for returned resources of type certificates
     * @param fieldsDevices the fields to include for returned resources of type devices
     * @param fieldsBundleIds the fields to include for returned resources of type bundleIds
     * @param limitCertificates maximum number of related certificates returned (when they are included)
     * @param limitDevices maximum number of related devices returned (when they are included)
     */
    public profilesGetCollection(filterName?: Array<string>, filterProfileState?: Array<'ACTIVE' | 'INVALID'>, filterProfileType?: Array<'IOS_APP_DEVELOPMENT' | 'IOS_APP_STORE' | 'IOS_APP_ADHOC' | 'IOS_APP_INHOUSE' | 'MAC_APP_DEVELOPMENT' | 'MAC_APP_STORE' | 'MAC_APP_DIRECT' | 'TVOS_APP_DEVELOPMENT' | 'TVOS_APP_STORE' | 'TVOS_APP_ADHOC' | 'TVOS_APP_INHOUSE' | 'MAC_CATALYST_APP_DEVELOPMENT' | 'MAC_CATALYST_APP_STORE' | 'MAC_CATALYST_APP_DIRECT'>, filterId?: Array<string>, sort?: Array<'id' | '-id' | 'name' | '-name' | 'profileState' | '-profileState' | 'profileType' | '-profileType'>, fieldsProfiles?: Array<'bundleId' | 'certificates' | 'createdDate' | 'devices' | 'expirationDate' | 'name' | 'platform' | 'profileContent' | 'profileState' | 'profileType' | 'uuid'>, limit?: number, include?: Array<'bundleId' | 'certificates' | 'devices'>, fieldsCertificates?: Array<'certificateContent' | 'certificateType' | 'csrContent' | 'displayName' | 'expirationDate' | 'name' | 'platform' | 'serialNumber'>, fieldsDevices?: Array<'addedDate' | 'deviceClass' | 'model' | 'name' | 'platform' | 'status' | 'udid'>, fieldsBundleIds?: Array<'app' | 'bundleIdCapabilities' | 'identifier' | 'name' | 'platform' | 'profiles' | 'seedId'>, limitCertificates?: number, limitDevices?: number, _options?: Configuration): Promise<ProfilesResponse> {
        const result = this.api.profilesGetCollection(filterName, filterProfileState, filterProfileType, filterId, sort, fieldsProfiles, limit, include, fieldsCertificates, fieldsDevices, fieldsBundleIds, limitCertificates, limitDevices, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsProfiles the fields to include for returned resources of type profiles
     * @param include comma-separated list of relationships to include
     * @param fieldsCertificates the fields to include for returned resources of type certificates
     * @param fieldsDevices the fields to include for returned resources of type devices
     * @param fieldsBundleIds the fields to include for returned resources of type bundleIds
     * @param limitCertificates maximum number of related certificates returned (when they are included)
     * @param limitDevices maximum number of related devices returned (when they are included)
     */
    public profilesGetInstanceWithHttpInfo(id: string, fieldsProfiles?: Array<'bundleId' | 'certificates' | 'createdDate' | 'devices' | 'expirationDate' | 'name' | 'platform' | 'profileContent' | 'profileState' | 'profileType' | 'uuid'>, include?: Array<'bundleId' | 'certificates' | 'devices'>, fieldsCertificates?: Array<'certificateContent' | 'certificateType' | 'csrContent' | 'displayName' | 'expirationDate' | 'name' | 'platform' | 'serialNumber'>, fieldsDevices?: Array<'addedDate' | 'deviceClass' | 'model' | 'name' | 'platform' | 'status' | 'udid'>, fieldsBundleIds?: Array<'app' | 'bundleIdCapabilities' | 'identifier' | 'name' | 'platform' | 'profiles' | 'seedId'>, limitCertificates?: number, limitDevices?: number, _options?: Configuration): Promise<HttpInfo<ProfileResponse>> {
        const result = this.api.profilesGetInstanceWithHttpInfo(id, fieldsProfiles, include, fieldsCertificates, fieldsDevices, fieldsBundleIds, limitCertificates, limitDevices, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsProfiles the fields to include for returned resources of type profiles
     * @param include comma-separated list of relationships to include
     * @param fieldsCertificates the fields to include for returned resources of type certificates
     * @param fieldsDevices the fields to include for returned resources of type devices
     * @param fieldsBundleIds the fields to include for returned resources of type bundleIds
     * @param limitCertificates maximum number of related certificates returned (when they are included)
     * @param limitDevices maximum number of related devices returned (when they are included)
     */
    public profilesGetInstance(id: string, fieldsProfiles?: Array<'bundleId' | 'certificates' | 'createdDate' | 'devices' | 'expirationDate' | 'name' | 'platform' | 'profileContent' | 'profileState' | 'profileType' | 'uuid'>, include?: Array<'bundleId' | 'certificates' | 'devices'>, fieldsCertificates?: Array<'certificateContent' | 'certificateType' | 'csrContent' | 'displayName' | 'expirationDate' | 'name' | 'platform' | 'serialNumber'>, fieldsDevices?: Array<'addedDate' | 'deviceClass' | 'model' | 'name' | 'platform' | 'status' | 'udid'>, fieldsBundleIds?: Array<'app' | 'bundleIdCapabilities' | 'identifier' | 'name' | 'platform' | 'profiles' | 'seedId'>, limitCertificates?: number, limitDevices?: number, _options?: Configuration): Promise<ProfileResponse> {
        const result = this.api.profilesGetInstance(id, fieldsProfiles, include, fieldsCertificates, fieldsDevices, fieldsBundleIds, limitCertificates, limitDevices, _options);
        return result.toPromise();
    }


}



import { ObservablePromotedPurchaseImagesApi } from './ObservableAPI.ts';

import { PromotedPurchaseImagesApiRequestFactory, PromotedPurchaseImagesApiResponseProcessor} from "../apis/PromotedPurchaseImagesApi.ts";
export class PromisePromotedPurchaseImagesApi {
    private api: ObservablePromotedPurchaseImagesApi

    public constructor(
        configuration: Configuration,
        requestFactory?: PromotedPurchaseImagesApiRequestFactory,
        responseProcessor?: PromotedPurchaseImagesApiResponseProcessor
    ) {
        this.api = new ObservablePromotedPurchaseImagesApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param promotedPurchaseImageCreateRequest PromotedPurchaseImage representation
     */
    public promotedPurchaseImagesCreateInstanceWithHttpInfo(promotedPurchaseImageCreateRequest: PromotedPurchaseImageCreateRequest, _options?: Configuration): Promise<HttpInfo<PromotedPurchaseImageResponse>> {
        const result = this.api.promotedPurchaseImagesCreateInstanceWithHttpInfo(promotedPurchaseImageCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param promotedPurchaseImageCreateRequest PromotedPurchaseImage representation
     */
    public promotedPurchaseImagesCreateInstance(promotedPurchaseImageCreateRequest: PromotedPurchaseImageCreateRequest, _options?: Configuration): Promise<PromotedPurchaseImageResponse> {
        const result = this.api.promotedPurchaseImagesCreateInstance(promotedPurchaseImageCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public promotedPurchaseImagesDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.promotedPurchaseImagesDeleteInstanceWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public promotedPurchaseImagesDeleteInstance(id: string, _options?: Configuration): Promise<void> {
        const result = this.api.promotedPurchaseImagesDeleteInstance(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsPromotedPurchaseImages the fields to include for returned resources of type promotedPurchaseImages
     * @param include comma-separated list of relationships to include
     */
    public promotedPurchaseImagesGetInstanceWithHttpInfo(id: string, fieldsPromotedPurchaseImages?: Array<'assetToken' | 'assetType' | 'fileName' | 'fileSize' | 'imageAsset' | 'promotedPurchase' | 'sourceFileChecksum' | 'state' | 'uploadOperations' | 'uploaded'>, include?: Array<'promotedPurchase'>, _options?: Configuration): Promise<HttpInfo<PromotedPurchaseImageResponse>> {
        const result = this.api.promotedPurchaseImagesGetInstanceWithHttpInfo(id, fieldsPromotedPurchaseImages, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsPromotedPurchaseImages the fields to include for returned resources of type promotedPurchaseImages
     * @param include comma-separated list of relationships to include
     */
    public promotedPurchaseImagesGetInstance(id: string, fieldsPromotedPurchaseImages?: Array<'assetToken' | 'assetType' | 'fileName' | 'fileSize' | 'imageAsset' | 'promotedPurchase' | 'sourceFileChecksum' | 'state' | 'uploadOperations' | 'uploaded'>, include?: Array<'promotedPurchase'>, _options?: Configuration): Promise<PromotedPurchaseImageResponse> {
        const result = this.api.promotedPurchaseImagesGetInstance(id, fieldsPromotedPurchaseImages, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param promotedPurchaseImageUpdateRequest PromotedPurchaseImage representation
     */
    public promotedPurchaseImagesUpdateInstanceWithHttpInfo(id: string, promotedPurchaseImageUpdateRequest: PromotedPurchaseImageUpdateRequest, _options?: Configuration): Promise<HttpInfo<PromotedPurchaseImageResponse>> {
        const result = this.api.promotedPurchaseImagesUpdateInstanceWithHttpInfo(id, promotedPurchaseImageUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param promotedPurchaseImageUpdateRequest PromotedPurchaseImage representation
     */
    public promotedPurchaseImagesUpdateInstance(id: string, promotedPurchaseImageUpdateRequest: PromotedPurchaseImageUpdateRequest, _options?: Configuration): Promise<PromotedPurchaseImageResponse> {
        const result = this.api.promotedPurchaseImagesUpdateInstance(id, promotedPurchaseImageUpdateRequest, _options);
        return result.toPromise();
    }


}



import { ObservablePromotedPurchasesApi } from './ObservableAPI.ts';

import { PromotedPurchasesApiRequestFactory, PromotedPurchasesApiResponseProcessor} from "../apis/PromotedPurchasesApi.ts";
export class PromisePromotedPurchasesApi {
    private api: ObservablePromotedPurchasesApi

    public constructor(
        configuration: Configuration,
        requestFactory?: PromotedPurchasesApiRequestFactory,
        responseProcessor?: PromotedPurchasesApiResponseProcessor
    ) {
        this.api = new ObservablePromotedPurchasesApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param promotedPurchaseCreateRequest PromotedPurchase representation
     */
    public promotedPurchasesCreateInstanceWithHttpInfo(promotedPurchaseCreateRequest: PromotedPurchaseCreateRequest, _options?: Configuration): Promise<HttpInfo<PromotedPurchaseResponse>> {
        const result = this.api.promotedPurchasesCreateInstanceWithHttpInfo(promotedPurchaseCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param promotedPurchaseCreateRequest PromotedPurchase representation
     */
    public promotedPurchasesCreateInstance(promotedPurchaseCreateRequest: PromotedPurchaseCreateRequest, _options?: Configuration): Promise<PromotedPurchaseResponse> {
        const result = this.api.promotedPurchasesCreateInstance(promotedPurchaseCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public promotedPurchasesDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.promotedPurchasesDeleteInstanceWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public promotedPurchasesDeleteInstance(id: string, _options?: Configuration): Promise<void> {
        const result = this.api.promotedPurchasesDeleteInstance(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsPromotedPurchases the fields to include for returned resources of type promotedPurchases
     * @param include comma-separated list of relationships to include
     * @param fieldsPromotedPurchaseImages the fields to include for returned resources of type promotedPurchaseImages
     * @param limitPromotionImages maximum number of related promotionImages returned (when they are included)
     */
    public promotedPurchasesGetInstanceWithHttpInfo(id: string, fieldsPromotedPurchases?: Array<'app' | 'enabled' | 'inAppPurchaseV2' | 'promotionImages' | 'state' | 'subscription' | 'visibleForAllUsers'>, include?: Array<'inAppPurchaseV2' | 'promotionImages' | 'subscription'>, fieldsPromotedPurchaseImages?: Array<'assetToken' | 'assetType' | 'fileName' | 'fileSize' | 'imageAsset' | 'promotedPurchase' | 'sourceFileChecksum' | 'state' | 'uploadOperations' | 'uploaded'>, limitPromotionImages?: number, _options?: Configuration): Promise<HttpInfo<PromotedPurchaseResponse>> {
        const result = this.api.promotedPurchasesGetInstanceWithHttpInfo(id, fieldsPromotedPurchases, include, fieldsPromotedPurchaseImages, limitPromotionImages, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsPromotedPurchases the fields to include for returned resources of type promotedPurchases
     * @param include comma-separated list of relationships to include
     * @param fieldsPromotedPurchaseImages the fields to include for returned resources of type promotedPurchaseImages
     * @param limitPromotionImages maximum number of related promotionImages returned (when they are included)
     */
    public promotedPurchasesGetInstance(id: string, fieldsPromotedPurchases?: Array<'app' | 'enabled' | 'inAppPurchaseV2' | 'promotionImages' | 'state' | 'subscription' | 'visibleForAllUsers'>, include?: Array<'inAppPurchaseV2' | 'promotionImages' | 'subscription'>, fieldsPromotedPurchaseImages?: Array<'assetToken' | 'assetType' | 'fileName' | 'fileSize' | 'imageAsset' | 'promotedPurchase' | 'sourceFileChecksum' | 'state' | 'uploadOperations' | 'uploaded'>, limitPromotionImages?: number, _options?: Configuration): Promise<PromotedPurchaseResponse> {
        const result = this.api.promotedPurchasesGetInstance(id, fieldsPromotedPurchases, include, fieldsPromotedPurchaseImages, limitPromotionImages, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsPromotedPurchases the fields to include for returned resources of type promotedPurchases
     * @param fieldsPromotedPurchaseImages the fields to include for returned resources of type promotedPurchaseImages
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public promotedPurchasesPromotionImagesGetToManyRelatedWithHttpInfo(id: string, fieldsPromotedPurchases?: Array<'app' | 'enabled' | 'inAppPurchaseV2' | 'promotionImages' | 'state' | 'subscription' | 'visibleForAllUsers'>, fieldsPromotedPurchaseImages?: Array<'assetToken' | 'assetType' | 'fileName' | 'fileSize' | 'imageAsset' | 'promotedPurchase' | 'sourceFileChecksum' | 'state' | 'uploadOperations' | 'uploaded'>, limit?: number, include?: Array<'promotedPurchase'>, _options?: Configuration): Promise<HttpInfo<PromotedPurchaseImagesResponse>> {
        const result = this.api.promotedPurchasesPromotionImagesGetToManyRelatedWithHttpInfo(id, fieldsPromotedPurchases, fieldsPromotedPurchaseImages, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsPromotedPurchases the fields to include for returned resources of type promotedPurchases
     * @param fieldsPromotedPurchaseImages the fields to include for returned resources of type promotedPurchaseImages
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public promotedPurchasesPromotionImagesGetToManyRelated(id: string, fieldsPromotedPurchases?: Array<'app' | 'enabled' | 'inAppPurchaseV2' | 'promotionImages' | 'state' | 'subscription' | 'visibleForAllUsers'>, fieldsPromotedPurchaseImages?: Array<'assetToken' | 'assetType' | 'fileName' | 'fileSize' | 'imageAsset' | 'promotedPurchase' | 'sourceFileChecksum' | 'state' | 'uploadOperations' | 'uploaded'>, limit?: number, include?: Array<'promotedPurchase'>, _options?: Configuration): Promise<PromotedPurchaseImagesResponse> {
        const result = this.api.promotedPurchasesPromotionImagesGetToManyRelated(id, fieldsPromotedPurchases, fieldsPromotedPurchaseImages, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param promotedPurchaseUpdateRequest PromotedPurchase representation
     */
    public promotedPurchasesUpdateInstanceWithHttpInfo(id: string, promotedPurchaseUpdateRequest: PromotedPurchaseUpdateRequest, _options?: Configuration): Promise<HttpInfo<PromotedPurchaseResponse>> {
        const result = this.api.promotedPurchasesUpdateInstanceWithHttpInfo(id, promotedPurchaseUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param promotedPurchaseUpdateRequest PromotedPurchase representation
     */
    public promotedPurchasesUpdateInstance(id: string, promotedPurchaseUpdateRequest: PromotedPurchaseUpdateRequest, _options?: Configuration): Promise<PromotedPurchaseResponse> {
        const result = this.api.promotedPurchasesUpdateInstance(id, promotedPurchaseUpdateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableReviewSubmissionItemsApi } from './ObservableAPI.ts';

import { ReviewSubmissionItemsApiRequestFactory, ReviewSubmissionItemsApiResponseProcessor} from "../apis/ReviewSubmissionItemsApi.ts";
export class PromiseReviewSubmissionItemsApi {
    private api: ObservableReviewSubmissionItemsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: ReviewSubmissionItemsApiRequestFactory,
        responseProcessor?: ReviewSubmissionItemsApiResponseProcessor
    ) {
        this.api = new ObservableReviewSubmissionItemsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param reviewSubmissionItemCreateRequest ReviewSubmissionItem representation
     */
    public reviewSubmissionItemsCreateInstanceWithHttpInfo(reviewSubmissionItemCreateRequest: ReviewSubmissionItemCreateRequest, _options?: Configuration): Promise<HttpInfo<ReviewSubmissionItemResponse>> {
        const result = this.api.reviewSubmissionItemsCreateInstanceWithHttpInfo(reviewSubmissionItemCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param reviewSubmissionItemCreateRequest ReviewSubmissionItem representation
     */
    public reviewSubmissionItemsCreateInstance(reviewSubmissionItemCreateRequest: ReviewSubmissionItemCreateRequest, _options?: Configuration): Promise<ReviewSubmissionItemResponse> {
        const result = this.api.reviewSubmissionItemsCreateInstance(reviewSubmissionItemCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public reviewSubmissionItemsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.reviewSubmissionItemsDeleteInstanceWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public reviewSubmissionItemsDeleteInstance(id: string, _options?: Configuration): Promise<void> {
        const result = this.api.reviewSubmissionItemsDeleteInstance(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param reviewSubmissionItemUpdateRequest ReviewSubmissionItem representation
     */
    public reviewSubmissionItemsUpdateInstanceWithHttpInfo(id: string, reviewSubmissionItemUpdateRequest: ReviewSubmissionItemUpdateRequest, _options?: Configuration): Promise<HttpInfo<ReviewSubmissionItemResponse>> {
        const result = this.api.reviewSubmissionItemsUpdateInstanceWithHttpInfo(id, reviewSubmissionItemUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param reviewSubmissionItemUpdateRequest ReviewSubmissionItem representation
     */
    public reviewSubmissionItemsUpdateInstance(id: string, reviewSubmissionItemUpdateRequest: ReviewSubmissionItemUpdateRequest, _options?: Configuration): Promise<ReviewSubmissionItemResponse> {
        const result = this.api.reviewSubmissionItemsUpdateInstance(id, reviewSubmissionItemUpdateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableReviewSubmissionsApi } from './ObservableAPI.ts';

import { ReviewSubmissionsApiRequestFactory, ReviewSubmissionsApiResponseProcessor} from "../apis/ReviewSubmissionsApi.ts";
export class PromiseReviewSubmissionsApi {
    private api: ObservableReviewSubmissionsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: ReviewSubmissionsApiRequestFactory,
        responseProcessor?: ReviewSubmissionsApiResponseProcessor
    ) {
        this.api = new ObservableReviewSubmissionsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param reviewSubmissionCreateRequest ReviewSubmission representation
     */
    public reviewSubmissionsCreateInstanceWithHttpInfo(reviewSubmissionCreateRequest: ReviewSubmissionCreateRequest, _options?: Configuration): Promise<HttpInfo<ReviewSubmissionResponse>> {
        const result = this.api.reviewSubmissionsCreateInstanceWithHttpInfo(reviewSubmissionCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param reviewSubmissionCreateRequest ReviewSubmission representation
     */
    public reviewSubmissionsCreateInstance(reviewSubmissionCreateRequest: ReviewSubmissionCreateRequest, _options?: Configuration): Promise<ReviewSubmissionResponse> {
        const result = this.api.reviewSubmissionsCreateInstance(reviewSubmissionCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param filterApp filter by id(s) of related \&#39;app\&#39;
     * @param filterPlatform filter by attribute \&#39;platform\&#39;
     * @param filterState filter by attribute \&#39;state\&#39;
     * @param fieldsReviewSubmissions the fields to include for returned resources of type reviewSubmissions
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsReviewSubmissionItems the fields to include for returned resources of type reviewSubmissionItems
     * @param limitItems maximum number of related items returned (when they are included)
     */
    public reviewSubmissionsGetCollectionWithHttpInfo(filterApp: Array<string>, filterPlatform?: Array<'IOS' | 'MAC_OS' | 'TV_OS' | 'VISION_OS'>, filterState?: Array<'READY_FOR_REVIEW' | 'WAITING_FOR_REVIEW' | 'IN_REVIEW' | 'UNRESOLVED_ISSUES' | 'CANCELING' | 'COMPLETING' | 'COMPLETE'>, fieldsReviewSubmissions?: Array<'app' | 'appStoreVersionForReview' | 'canceled' | 'items' | 'lastUpdatedByActor' | 'platform' | 'state' | 'submitted' | 'submittedByActor' | 'submittedDate'>, limit?: number, include?: Array<'app' | 'appStoreVersionForReview' | 'items' | 'lastUpdatedByActor' | 'submittedByActor'>, fieldsReviewSubmissionItems?: Array<'appCustomProductPageVersion' | 'appEvent' | 'appStoreVersion' | 'appStoreVersionExperiment' | 'appStoreVersionExperimentV2' | 'removed' | 'resolved' | 'reviewSubmission' | 'state'>, limitItems?: number, _options?: Configuration): Promise<HttpInfo<ReviewSubmissionsResponse>> {
        const result = this.api.reviewSubmissionsGetCollectionWithHttpInfo(filterApp, filterPlatform, filterState, fieldsReviewSubmissions, limit, include, fieldsReviewSubmissionItems, limitItems, _options);
        return result.toPromise();
    }

    /**
     * @param filterApp filter by id(s) of related \&#39;app\&#39;
     * @param filterPlatform filter by attribute \&#39;platform\&#39;
     * @param filterState filter by attribute \&#39;state\&#39;
     * @param fieldsReviewSubmissions the fields to include for returned resources of type reviewSubmissions
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsReviewSubmissionItems the fields to include for returned resources of type reviewSubmissionItems
     * @param limitItems maximum number of related items returned (when they are included)
     */
    public reviewSubmissionsGetCollection(filterApp: Array<string>, filterPlatform?: Array<'IOS' | 'MAC_OS' | 'TV_OS' | 'VISION_OS'>, filterState?: Array<'READY_FOR_REVIEW' | 'WAITING_FOR_REVIEW' | 'IN_REVIEW' | 'UNRESOLVED_ISSUES' | 'CANCELING' | 'COMPLETING' | 'COMPLETE'>, fieldsReviewSubmissions?: Array<'app' | 'appStoreVersionForReview' | 'canceled' | 'items' | 'lastUpdatedByActor' | 'platform' | 'state' | 'submitted' | 'submittedByActor' | 'submittedDate'>, limit?: number, include?: Array<'app' | 'appStoreVersionForReview' | 'items' | 'lastUpdatedByActor' | 'submittedByActor'>, fieldsReviewSubmissionItems?: Array<'appCustomProductPageVersion' | 'appEvent' | 'appStoreVersion' | 'appStoreVersionExperiment' | 'appStoreVersionExperimentV2' | 'removed' | 'resolved' | 'reviewSubmission' | 'state'>, limitItems?: number, _options?: Configuration): Promise<ReviewSubmissionsResponse> {
        const result = this.api.reviewSubmissionsGetCollection(filterApp, filterPlatform, filterState, fieldsReviewSubmissions, limit, include, fieldsReviewSubmissionItems, limitItems, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsReviewSubmissions the fields to include for returned resources of type reviewSubmissions
     * @param include comma-separated list of relationships to include
     * @param fieldsReviewSubmissionItems the fields to include for returned resources of type reviewSubmissionItems
     * @param limitItems maximum number of related items returned (when they are included)
     */
    public reviewSubmissionsGetInstanceWithHttpInfo(id: string, fieldsReviewSubmissions?: Array<'app' | 'appStoreVersionForReview' | 'canceled' | 'items' | 'lastUpdatedByActor' | 'platform' | 'state' | 'submitted' | 'submittedByActor' | 'submittedDate'>, include?: Array<'app' | 'appStoreVersionForReview' | 'items' | 'lastUpdatedByActor' | 'submittedByActor'>, fieldsReviewSubmissionItems?: Array<'appCustomProductPageVersion' | 'appEvent' | 'appStoreVersion' | 'appStoreVersionExperiment' | 'appStoreVersionExperimentV2' | 'removed' | 'resolved' | 'reviewSubmission' | 'state'>, limitItems?: number, _options?: Configuration): Promise<HttpInfo<ReviewSubmissionResponse>> {
        const result = this.api.reviewSubmissionsGetInstanceWithHttpInfo(id, fieldsReviewSubmissions, include, fieldsReviewSubmissionItems, limitItems, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsReviewSubmissions the fields to include for returned resources of type reviewSubmissions
     * @param include comma-separated list of relationships to include
     * @param fieldsReviewSubmissionItems the fields to include for returned resources of type reviewSubmissionItems
     * @param limitItems maximum number of related items returned (when they are included)
     */
    public reviewSubmissionsGetInstance(id: string, fieldsReviewSubmissions?: Array<'app' | 'appStoreVersionForReview' | 'canceled' | 'items' | 'lastUpdatedByActor' | 'platform' | 'state' | 'submitted' | 'submittedByActor' | 'submittedDate'>, include?: Array<'app' | 'appStoreVersionForReview' | 'items' | 'lastUpdatedByActor' | 'submittedByActor'>, fieldsReviewSubmissionItems?: Array<'appCustomProductPageVersion' | 'appEvent' | 'appStoreVersion' | 'appStoreVersionExperiment' | 'appStoreVersionExperimentV2' | 'removed' | 'resolved' | 'reviewSubmission' | 'state'>, limitItems?: number, _options?: Configuration): Promise<ReviewSubmissionResponse> {
        const result = this.api.reviewSubmissionsGetInstance(id, fieldsReviewSubmissions, include, fieldsReviewSubmissionItems, limitItems, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppStoreVersionExperiments the fields to include for returned resources of type appStoreVersionExperiments
     * @param fieldsReviewSubmissionItems the fields to include for returned resources of type reviewSubmissionItems
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsAppCustomProductPageVersions the fields to include for returned resources of type appCustomProductPageVersions
     * @param fieldsAppEvents the fields to include for returned resources of type appEvents
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public reviewSubmissionsItemsGetToManyRelatedWithHttpInfo(id: string, fieldsAppStoreVersionExperiments?: Array<'app' | 'appStoreVersion' | 'appStoreVersionExperimentTreatments' | 'controlVersions' | 'endDate' | 'latestControlVersion' | 'name' | 'platform' | 'reviewRequired' | 'startDate' | 'started' | 'state' | 'trafficProportion'>, fieldsReviewSubmissionItems?: Array<'appCustomProductPageVersion' | 'appEvent' | 'appStoreVersion' | 'appStoreVersionExperiment' | 'appStoreVersionExperimentV2' | 'removed' | 'resolved' | 'reviewSubmission' | 'state'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsAppCustomProductPageVersions?: Array<'appCustomProductPage' | 'appCustomProductPageLocalizations' | 'state' | 'version'>, fieldsAppEvents?: Array<'app' | 'archivedTerritorySchedules' | 'badge' | 'deepLink' | 'eventState' | 'localizations' | 'primaryLocale' | 'priority' | 'purchaseRequirement' | 'purpose' | 'referenceName' | 'territorySchedules'>, limit?: number, include?: Array<'appCustomProductPageVersion' | 'appEvent' | 'appStoreVersion' | 'appStoreVersionExperiment' | 'appStoreVersionExperimentV2'>, _options?: Configuration): Promise<HttpInfo<ReviewSubmissionItemsResponse>> {
        const result = this.api.reviewSubmissionsItemsGetToManyRelatedWithHttpInfo(id, fieldsAppStoreVersionExperiments, fieldsReviewSubmissionItems, fieldsAppStoreVersions, fieldsAppCustomProductPageVersions, fieldsAppEvents, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsAppStoreVersionExperiments the fields to include for returned resources of type appStoreVersionExperiments
     * @param fieldsReviewSubmissionItems the fields to include for returned resources of type reviewSubmissionItems
     * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions
     * @param fieldsAppCustomProductPageVersions the fields to include for returned resources of type appCustomProductPageVersions
     * @param fieldsAppEvents the fields to include for returned resources of type appEvents
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public reviewSubmissionsItemsGetToManyRelated(id: string, fieldsAppStoreVersionExperiments?: Array<'app' | 'appStoreVersion' | 'appStoreVersionExperimentTreatments' | 'controlVersions' | 'endDate' | 'latestControlVersion' | 'name' | 'platform' | 'reviewRequired' | 'startDate' | 'started' | 'state' | 'trafficProportion'>, fieldsReviewSubmissionItems?: Array<'appCustomProductPageVersion' | 'appEvent' | 'appStoreVersion' | 'appStoreVersionExperiment' | 'appStoreVersionExperimentV2' | 'removed' | 'resolved' | 'reviewSubmission' | 'state'>, fieldsAppStoreVersions?: Array<'ageRatingDeclaration' | 'alternativeDistributionPackage' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionExperimentsV2' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'appVersionState' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'reviewType' | 'routingAppCoverage' | 'versionString'>, fieldsAppCustomProductPageVersions?: Array<'appCustomProductPage' | 'appCustomProductPageLocalizations' | 'state' | 'version'>, fieldsAppEvents?: Array<'app' | 'archivedTerritorySchedules' | 'badge' | 'deepLink' | 'eventState' | 'localizations' | 'primaryLocale' | 'priority' | 'purchaseRequirement' | 'purpose' | 'referenceName' | 'territorySchedules'>, limit?: number, include?: Array<'appCustomProductPageVersion' | 'appEvent' | 'appStoreVersion' | 'appStoreVersionExperiment' | 'appStoreVersionExperimentV2'>, _options?: Configuration): Promise<ReviewSubmissionItemsResponse> {
        const result = this.api.reviewSubmissionsItemsGetToManyRelated(id, fieldsAppStoreVersionExperiments, fieldsReviewSubmissionItems, fieldsAppStoreVersions, fieldsAppCustomProductPageVersions, fieldsAppEvents, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param reviewSubmissionUpdateRequest ReviewSubmission representation
     */
    public reviewSubmissionsUpdateInstanceWithHttpInfo(id: string, reviewSubmissionUpdateRequest: ReviewSubmissionUpdateRequest, _options?: Configuration): Promise<HttpInfo<ReviewSubmissionResponse>> {
        const result = this.api.reviewSubmissionsUpdateInstanceWithHttpInfo(id, reviewSubmissionUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param reviewSubmissionUpdateRequest ReviewSubmission representation
     */
    public reviewSubmissionsUpdateInstance(id: string, reviewSubmissionUpdateRequest: ReviewSubmissionUpdateRequest, _options?: Configuration): Promise<ReviewSubmissionResponse> {
        const result = this.api.reviewSubmissionsUpdateInstance(id, reviewSubmissionUpdateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableRoutingAppCoveragesApi } from './ObservableAPI.ts';

import { RoutingAppCoveragesApiRequestFactory, RoutingAppCoveragesApiResponseProcessor} from "../apis/RoutingAppCoveragesApi.ts";
export class PromiseRoutingAppCoveragesApi {
    private api: ObservableRoutingAppCoveragesApi

    public constructor(
        configuration: Configuration,
        requestFactory?: RoutingAppCoveragesApiRequestFactory,
        responseProcessor?: RoutingAppCoveragesApiResponseProcessor
    ) {
        this.api = new ObservableRoutingAppCoveragesApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param routingAppCoverageCreateRequest RoutingAppCoverage representation
     */
    public routingAppCoveragesCreateInstanceWithHttpInfo(routingAppCoverageCreateRequest: RoutingAppCoverageCreateRequest, _options?: Configuration): Promise<HttpInfo<RoutingAppCoverageResponse>> {
        const result = this.api.routingAppCoveragesCreateInstanceWithHttpInfo(routingAppCoverageCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param routingAppCoverageCreateRequest RoutingAppCoverage representation
     */
    public routingAppCoveragesCreateInstance(routingAppCoverageCreateRequest: RoutingAppCoverageCreateRequest, _options?: Configuration): Promise<RoutingAppCoverageResponse> {
        const result = this.api.routingAppCoveragesCreateInstance(routingAppCoverageCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public routingAppCoveragesDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.routingAppCoveragesDeleteInstanceWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public routingAppCoveragesDeleteInstance(id: string, _options?: Configuration): Promise<void> {
        const result = this.api.routingAppCoveragesDeleteInstance(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsRoutingAppCoverages the fields to include for returned resources of type routingAppCoverages
     * @param include comma-separated list of relationships to include
     */
    public routingAppCoveragesGetInstanceWithHttpInfo(id: string, fieldsRoutingAppCoverages?: Array<'appStoreVersion' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, include?: Array<'appStoreVersion'>, _options?: Configuration): Promise<HttpInfo<RoutingAppCoverageResponse>> {
        const result = this.api.routingAppCoveragesGetInstanceWithHttpInfo(id, fieldsRoutingAppCoverages, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsRoutingAppCoverages the fields to include for returned resources of type routingAppCoverages
     * @param include comma-separated list of relationships to include
     */
    public routingAppCoveragesGetInstance(id: string, fieldsRoutingAppCoverages?: Array<'appStoreVersion' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded'>, include?: Array<'appStoreVersion'>, _options?: Configuration): Promise<RoutingAppCoverageResponse> {
        const result = this.api.routingAppCoveragesGetInstance(id, fieldsRoutingAppCoverages, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param routingAppCoverageUpdateRequest RoutingAppCoverage representation
     */
    public routingAppCoveragesUpdateInstanceWithHttpInfo(id: string, routingAppCoverageUpdateRequest: RoutingAppCoverageUpdateRequest, _options?: Configuration): Promise<HttpInfo<RoutingAppCoverageResponse>> {
        const result = this.api.routingAppCoveragesUpdateInstanceWithHttpInfo(id, routingAppCoverageUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param routingAppCoverageUpdateRequest RoutingAppCoverage representation
     */
    public routingAppCoveragesUpdateInstance(id: string, routingAppCoverageUpdateRequest: RoutingAppCoverageUpdateRequest, _options?: Configuration): Promise<RoutingAppCoverageResponse> {
        const result = this.api.routingAppCoveragesUpdateInstance(id, routingAppCoverageUpdateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableSalesReportsApi } from './ObservableAPI.ts';

import { SalesReportsApiRequestFactory, SalesReportsApiResponseProcessor} from "../apis/SalesReportsApi.ts";
export class PromiseSalesReportsApi {
    private api: ObservableSalesReportsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: SalesReportsApiRequestFactory,
        responseProcessor?: SalesReportsApiResponseProcessor
    ) {
        this.api = new ObservableSalesReportsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param filterFrequency filter by attribute \&#39;frequency\&#39;
     * @param filterReportSubType filter by attribute \&#39;reportSubType\&#39;
     * @param filterReportType filter by attribute \&#39;reportType\&#39;
     * @param filterVendorNumber filter by attribute \&#39;vendorNumber\&#39;
     * @param filterReportDate filter by attribute \&#39;reportDate\&#39;
     * @param filterVersion filter by attribute \&#39;version\&#39;
     */
    public salesReportsGetCollectionWithHttpInfo(filterFrequency: Array<'DAILY' | 'WEEKLY' | 'MONTHLY' | 'YEARLY'>, filterReportSubType: Array<'SUMMARY' | 'DETAILED' | 'SUMMARY_INSTALL_TYPE' | 'SUMMARY_TERRITORY' | 'SUMMARY_CHANNEL'>, filterReportType: Array<'SALES' | 'PRE_ORDER' | 'NEWSSTAND' | 'SUBSCRIPTION' | 'SUBSCRIPTION_EVENT' | 'SUBSCRIBER' | 'SUBSCRIPTION_OFFER_CODE_REDEMPTION' | 'INSTALLS' | 'FIRST_ANNUAL'>, filterVendorNumber: Array<string>, filterReportDate?: Array<string>, filterVersion?: Array<string>, _options?: Configuration): Promise<HttpInfo<HttpFile>> {
        const result = this.api.salesReportsGetCollectionWithHttpInfo(filterFrequency, filterReportSubType, filterReportType, filterVendorNumber, filterReportDate, filterVersion, _options);
        return result.toPromise();
    }

    /**
     * @param filterFrequency filter by attribute \&#39;frequency\&#39;
     * @param filterReportSubType filter by attribute \&#39;reportSubType\&#39;
     * @param filterReportType filter by attribute \&#39;reportType\&#39;
     * @param filterVendorNumber filter by attribute \&#39;vendorNumber\&#39;
     * @param filterReportDate filter by attribute \&#39;reportDate\&#39;
     * @param filterVersion filter by attribute \&#39;version\&#39;
     */
    public salesReportsGetCollection(filterFrequency: Array<'DAILY' | 'WEEKLY' | 'MONTHLY' | 'YEARLY'>, filterReportSubType: Array<'SUMMARY' | 'DETAILED' | 'SUMMARY_INSTALL_TYPE' | 'SUMMARY_TERRITORY' | 'SUMMARY_CHANNEL'>, filterReportType: Array<'SALES' | 'PRE_ORDER' | 'NEWSSTAND' | 'SUBSCRIPTION' | 'SUBSCRIPTION_EVENT' | 'SUBSCRIBER' | 'SUBSCRIPTION_OFFER_CODE_REDEMPTION' | 'INSTALLS' | 'FIRST_ANNUAL'>, filterVendorNumber: Array<string>, filterReportDate?: Array<string>, filterVersion?: Array<string>, _options?: Configuration): Promise<HttpFile> {
        const result = this.api.salesReportsGetCollection(filterFrequency, filterReportSubType, filterReportType, filterVendorNumber, filterReportDate, filterVersion, _options);
        return result.toPromise();
    }


}



import { ObservableSandboxTestersApi } from './ObservableAPI.ts';

import { SandboxTestersApiRequestFactory, SandboxTestersApiResponseProcessor} from "../apis/SandboxTestersApi.ts";
export class PromiseSandboxTestersApi {
    private api: ObservableSandboxTestersApi

    public constructor(
        configuration: Configuration,
        requestFactory?: SandboxTestersApiRequestFactory,
        responseProcessor?: SandboxTestersApiResponseProcessor
    ) {
        this.api = new ObservableSandboxTestersApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param fieldsSandboxTesters the fields to include for returned resources of type sandboxTesters
     * @param limit maximum resources per page
     */
    public sandboxTestersV2GetCollectionWithHttpInfo(fieldsSandboxTesters?: Array<'acAccountName' | 'applePayCompatible' | 'firstName' | 'interruptPurchases' | 'lastName' | 'subscriptionRenewalRate' | 'territory'>, limit?: number, _options?: Configuration): Promise<HttpInfo<SandboxTestersV2Response>> {
        const result = this.api.sandboxTestersV2GetCollectionWithHttpInfo(fieldsSandboxTesters, limit, _options);
        return result.toPromise();
    }

    /**
     * @param fieldsSandboxTesters the fields to include for returned resources of type sandboxTesters
     * @param limit maximum resources per page
     */
    public sandboxTestersV2GetCollection(fieldsSandboxTesters?: Array<'acAccountName' | 'applePayCompatible' | 'firstName' | 'interruptPurchases' | 'lastName' | 'subscriptionRenewalRate' | 'territory'>, limit?: number, _options?: Configuration): Promise<SandboxTestersV2Response> {
        const result = this.api.sandboxTestersV2GetCollection(fieldsSandboxTesters, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param sandboxTesterV2UpdateRequest SandboxTester representation
     */
    public sandboxTestersV2UpdateInstanceWithHttpInfo(id: string, sandboxTesterV2UpdateRequest: SandboxTesterV2UpdateRequest, _options?: Configuration): Promise<HttpInfo<SandboxTesterV2Response>> {
        const result = this.api.sandboxTestersV2UpdateInstanceWithHttpInfo(id, sandboxTesterV2UpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param sandboxTesterV2UpdateRequest SandboxTester representation
     */
    public sandboxTestersV2UpdateInstance(id: string, sandboxTesterV2UpdateRequest: SandboxTesterV2UpdateRequest, _options?: Configuration): Promise<SandboxTesterV2Response> {
        const result = this.api.sandboxTestersV2UpdateInstance(id, sandboxTesterV2UpdateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableSandboxTestersClearPurchaseHistoryRequestApi } from './ObservableAPI.ts';

import { SandboxTestersClearPurchaseHistoryRequestApiRequestFactory, SandboxTestersClearPurchaseHistoryRequestApiResponseProcessor} from "../apis/SandboxTestersClearPurchaseHistoryRequestApi.ts";
export class PromiseSandboxTestersClearPurchaseHistoryRequestApi {
    private api: ObservableSandboxTestersClearPurchaseHistoryRequestApi

    public constructor(
        configuration: Configuration,
        requestFactory?: SandboxTestersClearPurchaseHistoryRequestApiRequestFactory,
        responseProcessor?: SandboxTestersClearPurchaseHistoryRequestApiResponseProcessor
    ) {
        this.api = new ObservableSandboxTestersClearPurchaseHistoryRequestApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param sandboxTestersClearPurchaseHistoryRequestV2CreateRequest SandboxTestersClearPurchaseHistoryRequest representation
     */
    public sandboxTestersClearPurchaseHistoryRequestV2CreateInstanceWithHttpInfo(sandboxTestersClearPurchaseHistoryRequestV2CreateRequest: SandboxTestersClearPurchaseHistoryRequestV2CreateRequest, _options?: Configuration): Promise<HttpInfo<SandboxTestersClearPurchaseHistoryRequestV2Response>> {
        const result = this.api.sandboxTestersClearPurchaseHistoryRequestV2CreateInstanceWithHttpInfo(sandboxTestersClearPurchaseHistoryRequestV2CreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param sandboxTestersClearPurchaseHistoryRequestV2CreateRequest SandboxTestersClearPurchaseHistoryRequest representation
     */
    public sandboxTestersClearPurchaseHistoryRequestV2CreateInstance(sandboxTestersClearPurchaseHistoryRequestV2CreateRequest: SandboxTestersClearPurchaseHistoryRequestV2CreateRequest, _options?: Configuration): Promise<SandboxTestersClearPurchaseHistoryRequestV2Response> {
        const result = this.api.sandboxTestersClearPurchaseHistoryRequestV2CreateInstance(sandboxTestersClearPurchaseHistoryRequestV2CreateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableScmGitReferencesApi } from './ObservableAPI.ts';

import { ScmGitReferencesApiRequestFactory, ScmGitReferencesApiResponseProcessor} from "../apis/ScmGitReferencesApi.ts";
export class PromiseScmGitReferencesApi {
    private api: ObservableScmGitReferencesApi

    public constructor(
        configuration: Configuration,
        requestFactory?: ScmGitReferencesApiRequestFactory,
        responseProcessor?: ScmGitReferencesApiResponseProcessor
    ) {
        this.api = new ObservableScmGitReferencesApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsScmGitReferences the fields to include for returned resources of type scmGitReferences
     * @param include comma-separated list of relationships to include
     */
    public scmGitReferencesGetInstanceWithHttpInfo(id: string, fieldsScmGitReferences?: Array<'canonicalName' | 'isDeleted' | 'kind' | 'name' | 'repository'>, include?: Array<'repository'>, _options?: Configuration): Promise<HttpInfo<ScmGitReferenceResponse>> {
        const result = this.api.scmGitReferencesGetInstanceWithHttpInfo(id, fieldsScmGitReferences, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsScmGitReferences the fields to include for returned resources of type scmGitReferences
     * @param include comma-separated list of relationships to include
     */
    public scmGitReferencesGetInstance(id: string, fieldsScmGitReferences?: Array<'canonicalName' | 'isDeleted' | 'kind' | 'name' | 'repository'>, include?: Array<'repository'>, _options?: Configuration): Promise<ScmGitReferenceResponse> {
        const result = this.api.scmGitReferencesGetInstance(id, fieldsScmGitReferences, include, _options);
        return result.toPromise();
    }


}



import { ObservableScmProvidersApi } from './ObservableAPI.ts';

import { ScmProvidersApiRequestFactory, ScmProvidersApiResponseProcessor} from "../apis/ScmProvidersApi.ts";
export class PromiseScmProvidersApi {
    private api: ObservableScmProvidersApi

    public constructor(
        configuration: Configuration,
        requestFactory?: ScmProvidersApiRequestFactory,
        responseProcessor?: ScmProvidersApiResponseProcessor
    ) {
        this.api = new ObservableScmProvidersApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param fieldsScmProviders the fields to include for returned resources of type scmProviders
     * @param limit maximum resources per page
     * @param fieldsScmRepositories the fields to include for returned resources of type scmRepositories
     */
    public scmProvidersGetCollectionWithHttpInfo(fieldsScmProviders?: Array<'repositories' | 'scmProviderType' | 'url'>, limit?: number, fieldsScmRepositories?: Array<'defaultBranch' | 'gitReferences' | 'httpCloneUrl' | 'lastAccessedDate' | 'ownerName' | 'pullRequests' | 'repositoryName' | 'scmProvider' | 'sshCloneUrl'>, _options?: Configuration): Promise<HttpInfo<ScmProvidersResponse>> {
        const result = this.api.scmProvidersGetCollectionWithHttpInfo(fieldsScmProviders, limit, fieldsScmRepositories, _options);
        return result.toPromise();
    }

    /**
     * @param fieldsScmProviders the fields to include for returned resources of type scmProviders
     * @param limit maximum resources per page
     * @param fieldsScmRepositories the fields to include for returned resources of type scmRepositories
     */
    public scmProvidersGetCollection(fieldsScmProviders?: Array<'repositories' | 'scmProviderType' | 'url'>, limit?: number, fieldsScmRepositories?: Array<'defaultBranch' | 'gitReferences' | 'httpCloneUrl' | 'lastAccessedDate' | 'ownerName' | 'pullRequests' | 'repositoryName' | 'scmProvider' | 'sshCloneUrl'>, _options?: Configuration): Promise<ScmProvidersResponse> {
        const result = this.api.scmProvidersGetCollection(fieldsScmProviders, limit, fieldsScmRepositories, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsScmProviders the fields to include for returned resources of type scmProviders
     * @param fieldsScmRepositories the fields to include for returned resources of type scmRepositories
     */
    public scmProvidersGetInstanceWithHttpInfo(id: string, fieldsScmProviders?: Array<'repositories' | 'scmProviderType' | 'url'>, fieldsScmRepositories?: Array<'defaultBranch' | 'gitReferences' | 'httpCloneUrl' | 'lastAccessedDate' | 'ownerName' | 'pullRequests' | 'repositoryName' | 'scmProvider' | 'sshCloneUrl'>, _options?: Configuration): Promise<HttpInfo<ScmProviderResponse>> {
        const result = this.api.scmProvidersGetInstanceWithHttpInfo(id, fieldsScmProviders, fieldsScmRepositories, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsScmProviders the fields to include for returned resources of type scmProviders
     * @param fieldsScmRepositories the fields to include for returned resources of type scmRepositories
     */
    public scmProvidersGetInstance(id: string, fieldsScmProviders?: Array<'repositories' | 'scmProviderType' | 'url'>, fieldsScmRepositories?: Array<'defaultBranch' | 'gitReferences' | 'httpCloneUrl' | 'lastAccessedDate' | 'ownerName' | 'pullRequests' | 'repositoryName' | 'scmProvider' | 'sshCloneUrl'>, _options?: Configuration): Promise<ScmProviderResponse> {
        const result = this.api.scmProvidersGetInstance(id, fieldsScmProviders, fieldsScmRepositories, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterId filter by id(s)
     * @param fieldsScmGitReferences the fields to include for returned resources of type scmGitReferences
     * @param fieldsScmProviders the fields to include for returned resources of type scmProviders
     * @param fieldsScmRepositories the fields to include for returned resources of type scmRepositories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public scmProvidersRepositoriesGetToManyRelatedWithHttpInfo(id: string, filterId?: Array<string>, fieldsScmGitReferences?: Array<'canonicalName' | 'isDeleted' | 'kind' | 'name' | 'repository'>, fieldsScmProviders?: Array<'repositories' | 'scmProviderType' | 'url'>, fieldsScmRepositories?: Array<'defaultBranch' | 'gitReferences' | 'httpCloneUrl' | 'lastAccessedDate' | 'ownerName' | 'pullRequests' | 'repositoryName' | 'scmProvider' | 'sshCloneUrl'>, limit?: number, include?: Array<'defaultBranch' | 'scmProvider'>, _options?: Configuration): Promise<HttpInfo<ScmRepositoriesResponse>> {
        const result = this.api.scmProvidersRepositoriesGetToManyRelatedWithHttpInfo(id, filterId, fieldsScmGitReferences, fieldsScmProviders, fieldsScmRepositories, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterId filter by id(s)
     * @param fieldsScmGitReferences the fields to include for returned resources of type scmGitReferences
     * @param fieldsScmProviders the fields to include for returned resources of type scmProviders
     * @param fieldsScmRepositories the fields to include for returned resources of type scmRepositories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public scmProvidersRepositoriesGetToManyRelated(id: string, filterId?: Array<string>, fieldsScmGitReferences?: Array<'canonicalName' | 'isDeleted' | 'kind' | 'name' | 'repository'>, fieldsScmProviders?: Array<'repositories' | 'scmProviderType' | 'url'>, fieldsScmRepositories?: Array<'defaultBranch' | 'gitReferences' | 'httpCloneUrl' | 'lastAccessedDate' | 'ownerName' | 'pullRequests' | 'repositoryName' | 'scmProvider' | 'sshCloneUrl'>, limit?: number, include?: Array<'defaultBranch' | 'scmProvider'>, _options?: Configuration): Promise<ScmRepositoriesResponse> {
        const result = this.api.scmProvidersRepositoriesGetToManyRelated(id, filterId, fieldsScmGitReferences, fieldsScmProviders, fieldsScmRepositories, limit, include, _options);
        return result.toPromise();
    }


}



import { ObservableScmPullRequestsApi } from './ObservableAPI.ts';

import { ScmPullRequestsApiRequestFactory, ScmPullRequestsApiResponseProcessor} from "../apis/ScmPullRequestsApi.ts";
export class PromiseScmPullRequestsApi {
    private api: ObservableScmPullRequestsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: ScmPullRequestsApiRequestFactory,
        responseProcessor?: ScmPullRequestsApiResponseProcessor
    ) {
        this.api = new ObservableScmPullRequestsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsScmPullRequests the fields to include for returned resources of type scmPullRequests
     * @param include comma-separated list of relationships to include
     */
    public scmPullRequestsGetInstanceWithHttpInfo(id: string, fieldsScmPullRequests?: Array<'destinationBranchName' | 'destinationRepositoryName' | 'destinationRepositoryOwner' | 'isClosed' | 'isCrossRepository' | 'number' | 'repository' | 'sourceBranchName' | 'sourceRepositoryName' | 'sourceRepositoryOwner' | 'title' | 'webUrl'>, include?: Array<'repository'>, _options?: Configuration): Promise<HttpInfo<ScmPullRequestResponse>> {
        const result = this.api.scmPullRequestsGetInstanceWithHttpInfo(id, fieldsScmPullRequests, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsScmPullRequests the fields to include for returned resources of type scmPullRequests
     * @param include comma-separated list of relationships to include
     */
    public scmPullRequestsGetInstance(id: string, fieldsScmPullRequests?: Array<'destinationBranchName' | 'destinationRepositoryName' | 'destinationRepositoryOwner' | 'isClosed' | 'isCrossRepository' | 'number' | 'repository' | 'sourceBranchName' | 'sourceRepositoryName' | 'sourceRepositoryOwner' | 'title' | 'webUrl'>, include?: Array<'repository'>, _options?: Configuration): Promise<ScmPullRequestResponse> {
        const result = this.api.scmPullRequestsGetInstance(id, fieldsScmPullRequests, include, _options);
        return result.toPromise();
    }


}



import { ObservableScmRepositoriesApi } from './ObservableAPI.ts';

import { ScmRepositoriesApiRequestFactory, ScmRepositoriesApiResponseProcessor} from "../apis/ScmRepositoriesApi.ts";
export class PromiseScmRepositoriesApi {
    private api: ObservableScmRepositoriesApi

    public constructor(
        configuration: Configuration,
        requestFactory?: ScmRepositoriesApiRequestFactory,
        responseProcessor?: ScmRepositoriesApiResponseProcessor
    ) {
        this.api = new ObservableScmRepositoriesApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param filterId filter by id(s)
     * @param fieldsScmRepositories the fields to include for returned resources of type scmRepositories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsScmGitReferences the fields to include for returned resources of type scmGitReferences
     * @param fieldsScmPullRequests the fields to include for returned resources of type scmPullRequests
     */
    public scmRepositoriesGetCollectionWithHttpInfo(filterId?: Array<string>, fieldsScmRepositories?: Array<'defaultBranch' | 'gitReferences' | 'httpCloneUrl' | 'lastAccessedDate' | 'ownerName' | 'pullRequests' | 'repositoryName' | 'scmProvider' | 'sshCloneUrl'>, limit?: number, include?: Array<'defaultBranch' | 'scmProvider'>, fieldsScmGitReferences?: Array<'canonicalName' | 'isDeleted' | 'kind' | 'name' | 'repository'>, fieldsScmPullRequests?: Array<'destinationBranchName' | 'destinationRepositoryName' | 'destinationRepositoryOwner' | 'isClosed' | 'isCrossRepository' | 'number' | 'repository' | 'sourceBranchName' | 'sourceRepositoryName' | 'sourceRepositoryOwner' | 'title' | 'webUrl'>, _options?: Configuration): Promise<HttpInfo<ScmRepositoriesResponse>> {
        const result = this.api.scmRepositoriesGetCollectionWithHttpInfo(filterId, fieldsScmRepositories, limit, include, fieldsScmGitReferences, fieldsScmPullRequests, _options);
        return result.toPromise();
    }

    /**
     * @param filterId filter by id(s)
     * @param fieldsScmRepositories the fields to include for returned resources of type scmRepositories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsScmGitReferences the fields to include for returned resources of type scmGitReferences
     * @param fieldsScmPullRequests the fields to include for returned resources of type scmPullRequests
     */
    public scmRepositoriesGetCollection(filterId?: Array<string>, fieldsScmRepositories?: Array<'defaultBranch' | 'gitReferences' | 'httpCloneUrl' | 'lastAccessedDate' | 'ownerName' | 'pullRequests' | 'repositoryName' | 'scmProvider' | 'sshCloneUrl'>, limit?: number, include?: Array<'defaultBranch' | 'scmProvider'>, fieldsScmGitReferences?: Array<'canonicalName' | 'isDeleted' | 'kind' | 'name' | 'repository'>, fieldsScmPullRequests?: Array<'destinationBranchName' | 'destinationRepositoryName' | 'destinationRepositoryOwner' | 'isClosed' | 'isCrossRepository' | 'number' | 'repository' | 'sourceBranchName' | 'sourceRepositoryName' | 'sourceRepositoryOwner' | 'title' | 'webUrl'>, _options?: Configuration): Promise<ScmRepositoriesResponse> {
        const result = this.api.scmRepositoriesGetCollection(filterId, fieldsScmRepositories, limit, include, fieldsScmGitReferences, fieldsScmPullRequests, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsScmRepositories the fields to include for returned resources of type scmRepositories
     * @param include comma-separated list of relationships to include
     * @param fieldsScmGitReferences the fields to include for returned resources of type scmGitReferences
     * @param fieldsScmPullRequests the fields to include for returned resources of type scmPullRequests
     */
    public scmRepositoriesGetInstanceWithHttpInfo(id: string, fieldsScmRepositories?: Array<'defaultBranch' | 'gitReferences' | 'httpCloneUrl' | 'lastAccessedDate' | 'ownerName' | 'pullRequests' | 'repositoryName' | 'scmProvider' | 'sshCloneUrl'>, include?: Array<'defaultBranch' | 'scmProvider'>, fieldsScmGitReferences?: Array<'canonicalName' | 'isDeleted' | 'kind' | 'name' | 'repository'>, fieldsScmPullRequests?: Array<'destinationBranchName' | 'destinationRepositoryName' | 'destinationRepositoryOwner' | 'isClosed' | 'isCrossRepository' | 'number' | 'repository' | 'sourceBranchName' | 'sourceRepositoryName' | 'sourceRepositoryOwner' | 'title' | 'webUrl'>, _options?: Configuration): Promise<HttpInfo<ScmRepositoryResponse>> {
        const result = this.api.scmRepositoriesGetInstanceWithHttpInfo(id, fieldsScmRepositories, include, fieldsScmGitReferences, fieldsScmPullRequests, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsScmRepositories the fields to include for returned resources of type scmRepositories
     * @param include comma-separated list of relationships to include
     * @param fieldsScmGitReferences the fields to include for returned resources of type scmGitReferences
     * @param fieldsScmPullRequests the fields to include for returned resources of type scmPullRequests
     */
    public scmRepositoriesGetInstance(id: string, fieldsScmRepositories?: Array<'defaultBranch' | 'gitReferences' | 'httpCloneUrl' | 'lastAccessedDate' | 'ownerName' | 'pullRequests' | 'repositoryName' | 'scmProvider' | 'sshCloneUrl'>, include?: Array<'defaultBranch' | 'scmProvider'>, fieldsScmGitReferences?: Array<'canonicalName' | 'isDeleted' | 'kind' | 'name' | 'repository'>, fieldsScmPullRequests?: Array<'destinationBranchName' | 'destinationRepositoryName' | 'destinationRepositoryOwner' | 'isClosed' | 'isCrossRepository' | 'number' | 'repository' | 'sourceBranchName' | 'sourceRepositoryName' | 'sourceRepositoryOwner' | 'title' | 'webUrl'>, _options?: Configuration): Promise<ScmRepositoryResponse> {
        const result = this.api.scmRepositoriesGetInstance(id, fieldsScmRepositories, include, fieldsScmGitReferences, fieldsScmPullRequests, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsScmGitReferences the fields to include for returned resources of type scmGitReferences
     * @param fieldsScmRepositories the fields to include for returned resources of type scmRepositories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public scmRepositoriesGitReferencesGetToManyRelatedWithHttpInfo(id: string, fieldsScmGitReferences?: Array<'canonicalName' | 'isDeleted' | 'kind' | 'name' | 'repository'>, fieldsScmRepositories?: Array<'defaultBranch' | 'gitReferences' | 'httpCloneUrl' | 'lastAccessedDate' | 'ownerName' | 'pullRequests' | 'repositoryName' | 'scmProvider' | 'sshCloneUrl'>, limit?: number, include?: Array<'repository'>, _options?: Configuration): Promise<HttpInfo<ScmGitReferencesResponse>> {
        const result = this.api.scmRepositoriesGitReferencesGetToManyRelatedWithHttpInfo(id, fieldsScmGitReferences, fieldsScmRepositories, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsScmGitReferences the fields to include for returned resources of type scmGitReferences
     * @param fieldsScmRepositories the fields to include for returned resources of type scmRepositories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public scmRepositoriesGitReferencesGetToManyRelated(id: string, fieldsScmGitReferences?: Array<'canonicalName' | 'isDeleted' | 'kind' | 'name' | 'repository'>, fieldsScmRepositories?: Array<'defaultBranch' | 'gitReferences' | 'httpCloneUrl' | 'lastAccessedDate' | 'ownerName' | 'pullRequests' | 'repositoryName' | 'scmProvider' | 'sshCloneUrl'>, limit?: number, include?: Array<'repository'>, _options?: Configuration): Promise<ScmGitReferencesResponse> {
        const result = this.api.scmRepositoriesGitReferencesGetToManyRelated(id, fieldsScmGitReferences, fieldsScmRepositories, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsScmPullRequests the fields to include for returned resources of type scmPullRequests
     * @param fieldsScmRepositories the fields to include for returned resources of type scmRepositories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public scmRepositoriesPullRequestsGetToManyRelatedWithHttpInfo(id: string, fieldsScmPullRequests?: Array<'destinationBranchName' | 'destinationRepositoryName' | 'destinationRepositoryOwner' | 'isClosed' | 'isCrossRepository' | 'number' | 'repository' | 'sourceBranchName' | 'sourceRepositoryName' | 'sourceRepositoryOwner' | 'title' | 'webUrl'>, fieldsScmRepositories?: Array<'defaultBranch' | 'gitReferences' | 'httpCloneUrl' | 'lastAccessedDate' | 'ownerName' | 'pullRequests' | 'repositoryName' | 'scmProvider' | 'sshCloneUrl'>, limit?: number, include?: Array<'repository'>, _options?: Configuration): Promise<HttpInfo<ScmPullRequestsResponse>> {
        const result = this.api.scmRepositoriesPullRequestsGetToManyRelatedWithHttpInfo(id, fieldsScmPullRequests, fieldsScmRepositories, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsScmPullRequests the fields to include for returned resources of type scmPullRequests
     * @param fieldsScmRepositories the fields to include for returned resources of type scmRepositories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public scmRepositoriesPullRequestsGetToManyRelated(id: string, fieldsScmPullRequests?: Array<'destinationBranchName' | 'destinationRepositoryName' | 'destinationRepositoryOwner' | 'isClosed' | 'isCrossRepository' | 'number' | 'repository' | 'sourceBranchName' | 'sourceRepositoryName' | 'sourceRepositoryOwner' | 'title' | 'webUrl'>, fieldsScmRepositories?: Array<'defaultBranch' | 'gitReferences' | 'httpCloneUrl' | 'lastAccessedDate' | 'ownerName' | 'pullRequests' | 'repositoryName' | 'scmProvider' | 'sshCloneUrl'>, limit?: number, include?: Array<'repository'>, _options?: Configuration): Promise<ScmPullRequestsResponse> {
        const result = this.api.scmRepositoriesPullRequestsGetToManyRelated(id, fieldsScmPullRequests, fieldsScmRepositories, limit, include, _options);
        return result.toPromise();
    }


}



import { ObservableSubscriptionAppStoreReviewScreenshotsApi } from './ObservableAPI.ts';

import { SubscriptionAppStoreReviewScreenshotsApiRequestFactory, SubscriptionAppStoreReviewScreenshotsApiResponseProcessor} from "../apis/SubscriptionAppStoreReviewScreenshotsApi.ts";
export class PromiseSubscriptionAppStoreReviewScreenshotsApi {
    private api: ObservableSubscriptionAppStoreReviewScreenshotsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: SubscriptionAppStoreReviewScreenshotsApiRequestFactory,
        responseProcessor?: SubscriptionAppStoreReviewScreenshotsApiResponseProcessor
    ) {
        this.api = new ObservableSubscriptionAppStoreReviewScreenshotsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param subscriptionAppStoreReviewScreenshotCreateRequest SubscriptionAppStoreReviewScreenshot representation
     */
    public subscriptionAppStoreReviewScreenshotsCreateInstanceWithHttpInfo(subscriptionAppStoreReviewScreenshotCreateRequest: SubscriptionAppStoreReviewScreenshotCreateRequest, _options?: Configuration): Promise<HttpInfo<SubscriptionAppStoreReviewScreenshotResponse>> {
        const result = this.api.subscriptionAppStoreReviewScreenshotsCreateInstanceWithHttpInfo(subscriptionAppStoreReviewScreenshotCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param subscriptionAppStoreReviewScreenshotCreateRequest SubscriptionAppStoreReviewScreenshot representation
     */
    public subscriptionAppStoreReviewScreenshotsCreateInstance(subscriptionAppStoreReviewScreenshotCreateRequest: SubscriptionAppStoreReviewScreenshotCreateRequest, _options?: Configuration): Promise<SubscriptionAppStoreReviewScreenshotResponse> {
        const result = this.api.subscriptionAppStoreReviewScreenshotsCreateInstance(subscriptionAppStoreReviewScreenshotCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public subscriptionAppStoreReviewScreenshotsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.subscriptionAppStoreReviewScreenshotsDeleteInstanceWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public subscriptionAppStoreReviewScreenshotsDeleteInstance(id: string, _options?: Configuration): Promise<void> {
        const result = this.api.subscriptionAppStoreReviewScreenshotsDeleteInstance(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsSubscriptionAppStoreReviewScreenshots the fields to include for returned resources of type subscriptionAppStoreReviewScreenshots
     * @param include comma-separated list of relationships to include
     */
    public subscriptionAppStoreReviewScreenshotsGetInstanceWithHttpInfo(id: string, fieldsSubscriptionAppStoreReviewScreenshots?: Array<'assetDeliveryState' | 'assetToken' | 'assetType' | 'fileName' | 'fileSize' | 'imageAsset' | 'sourceFileChecksum' | 'subscription' | 'uploadOperations' | 'uploaded'>, include?: Array<'subscription'>, _options?: Configuration): Promise<HttpInfo<SubscriptionAppStoreReviewScreenshotResponse>> {
        const result = this.api.subscriptionAppStoreReviewScreenshotsGetInstanceWithHttpInfo(id, fieldsSubscriptionAppStoreReviewScreenshots, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsSubscriptionAppStoreReviewScreenshots the fields to include for returned resources of type subscriptionAppStoreReviewScreenshots
     * @param include comma-separated list of relationships to include
     */
    public subscriptionAppStoreReviewScreenshotsGetInstance(id: string, fieldsSubscriptionAppStoreReviewScreenshots?: Array<'assetDeliveryState' | 'assetToken' | 'assetType' | 'fileName' | 'fileSize' | 'imageAsset' | 'sourceFileChecksum' | 'subscription' | 'uploadOperations' | 'uploaded'>, include?: Array<'subscription'>, _options?: Configuration): Promise<SubscriptionAppStoreReviewScreenshotResponse> {
        const result = this.api.subscriptionAppStoreReviewScreenshotsGetInstance(id, fieldsSubscriptionAppStoreReviewScreenshots, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param subscriptionAppStoreReviewScreenshotUpdateRequest SubscriptionAppStoreReviewScreenshot representation
     */
    public subscriptionAppStoreReviewScreenshotsUpdateInstanceWithHttpInfo(id: string, subscriptionAppStoreReviewScreenshotUpdateRequest: SubscriptionAppStoreReviewScreenshotUpdateRequest, _options?: Configuration): Promise<HttpInfo<SubscriptionAppStoreReviewScreenshotResponse>> {
        const result = this.api.subscriptionAppStoreReviewScreenshotsUpdateInstanceWithHttpInfo(id, subscriptionAppStoreReviewScreenshotUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param subscriptionAppStoreReviewScreenshotUpdateRequest SubscriptionAppStoreReviewScreenshot representation
     */
    public subscriptionAppStoreReviewScreenshotsUpdateInstance(id: string, subscriptionAppStoreReviewScreenshotUpdateRequest: SubscriptionAppStoreReviewScreenshotUpdateRequest, _options?: Configuration): Promise<SubscriptionAppStoreReviewScreenshotResponse> {
        const result = this.api.subscriptionAppStoreReviewScreenshotsUpdateInstance(id, subscriptionAppStoreReviewScreenshotUpdateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableSubscriptionAvailabilitiesApi } from './ObservableAPI.ts';

import { SubscriptionAvailabilitiesApiRequestFactory, SubscriptionAvailabilitiesApiResponseProcessor} from "../apis/SubscriptionAvailabilitiesApi.ts";
export class PromiseSubscriptionAvailabilitiesApi {
    private api: ObservableSubscriptionAvailabilitiesApi

    public constructor(
        configuration: Configuration,
        requestFactory?: SubscriptionAvailabilitiesApiRequestFactory,
        responseProcessor?: SubscriptionAvailabilitiesApiResponseProcessor
    ) {
        this.api = new ObservableSubscriptionAvailabilitiesApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limit maximum resources per page
     */
    public subscriptionAvailabilitiesAvailableTerritoriesGetToManyRelatedWithHttpInfo(id: string, fieldsTerritories?: Array<'currency'>, limit?: number, _options?: Configuration): Promise<HttpInfo<TerritoriesResponse>> {
        const result = this.api.subscriptionAvailabilitiesAvailableTerritoriesGetToManyRelatedWithHttpInfo(id, fieldsTerritories, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limit maximum resources per page
     */
    public subscriptionAvailabilitiesAvailableTerritoriesGetToManyRelated(id: string, fieldsTerritories?: Array<'currency'>, limit?: number, _options?: Configuration): Promise<TerritoriesResponse> {
        const result = this.api.subscriptionAvailabilitiesAvailableTerritoriesGetToManyRelated(id, fieldsTerritories, limit, _options);
        return result.toPromise();
    }

    /**
     * @param subscriptionAvailabilityCreateRequest SubscriptionAvailability representation
     */
    public subscriptionAvailabilitiesCreateInstanceWithHttpInfo(subscriptionAvailabilityCreateRequest: SubscriptionAvailabilityCreateRequest, _options?: Configuration): Promise<HttpInfo<SubscriptionAvailabilityResponse>> {
        const result = this.api.subscriptionAvailabilitiesCreateInstanceWithHttpInfo(subscriptionAvailabilityCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param subscriptionAvailabilityCreateRequest SubscriptionAvailability representation
     */
    public subscriptionAvailabilitiesCreateInstance(subscriptionAvailabilityCreateRequest: SubscriptionAvailabilityCreateRequest, _options?: Configuration): Promise<SubscriptionAvailabilityResponse> {
        const result = this.api.subscriptionAvailabilitiesCreateInstance(subscriptionAvailabilityCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsSubscriptionAvailabilities the fields to include for returned resources of type subscriptionAvailabilities
     * @param include comma-separated list of relationships to include
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limitAvailableTerritories maximum number of related availableTerritories returned (when they are included)
     */
    public subscriptionAvailabilitiesGetInstanceWithHttpInfo(id: string, fieldsSubscriptionAvailabilities?: Array<'availableInNewTerritories' | 'availableTerritories' | 'subscription'>, include?: Array<'availableTerritories' | 'subscription'>, fieldsTerritories?: Array<'currency'>, limitAvailableTerritories?: number, _options?: Configuration): Promise<HttpInfo<SubscriptionAvailabilityResponse>> {
        const result = this.api.subscriptionAvailabilitiesGetInstanceWithHttpInfo(id, fieldsSubscriptionAvailabilities, include, fieldsTerritories, limitAvailableTerritories, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsSubscriptionAvailabilities the fields to include for returned resources of type subscriptionAvailabilities
     * @param include comma-separated list of relationships to include
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limitAvailableTerritories maximum number of related availableTerritories returned (when they are included)
     */
    public subscriptionAvailabilitiesGetInstance(id: string, fieldsSubscriptionAvailabilities?: Array<'availableInNewTerritories' | 'availableTerritories' | 'subscription'>, include?: Array<'availableTerritories' | 'subscription'>, fieldsTerritories?: Array<'currency'>, limitAvailableTerritories?: number, _options?: Configuration): Promise<SubscriptionAvailabilityResponse> {
        const result = this.api.subscriptionAvailabilitiesGetInstance(id, fieldsSubscriptionAvailabilities, include, fieldsTerritories, limitAvailableTerritories, _options);
        return result.toPromise();
    }


}



import { ObservableSubscriptionGracePeriodsApi } from './ObservableAPI.ts';

import { SubscriptionGracePeriodsApiRequestFactory, SubscriptionGracePeriodsApiResponseProcessor} from "../apis/SubscriptionGracePeriodsApi.ts";
export class PromiseSubscriptionGracePeriodsApi {
    private api: ObservableSubscriptionGracePeriodsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: SubscriptionGracePeriodsApiRequestFactory,
        responseProcessor?: SubscriptionGracePeriodsApiResponseProcessor
    ) {
        this.api = new ObservableSubscriptionGracePeriodsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsSubscriptionGracePeriods the fields to include for returned resources of type subscriptionGracePeriods
     */
    public subscriptionGracePeriodsGetInstanceWithHttpInfo(id: string, fieldsSubscriptionGracePeriods?: Array<'duration' | 'optIn' | 'renewalType' | 'sandboxOptIn'>, _options?: Configuration): Promise<HttpInfo<SubscriptionGracePeriodResponse>> {
        const result = this.api.subscriptionGracePeriodsGetInstanceWithHttpInfo(id, fieldsSubscriptionGracePeriods, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsSubscriptionGracePeriods the fields to include for returned resources of type subscriptionGracePeriods
     */
    public subscriptionGracePeriodsGetInstance(id: string, fieldsSubscriptionGracePeriods?: Array<'duration' | 'optIn' | 'renewalType' | 'sandboxOptIn'>, _options?: Configuration): Promise<SubscriptionGracePeriodResponse> {
        const result = this.api.subscriptionGracePeriodsGetInstance(id, fieldsSubscriptionGracePeriods, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param subscriptionGracePeriodUpdateRequest SubscriptionGracePeriod representation
     */
    public subscriptionGracePeriodsUpdateInstanceWithHttpInfo(id: string, subscriptionGracePeriodUpdateRequest: SubscriptionGracePeriodUpdateRequest, _options?: Configuration): Promise<HttpInfo<SubscriptionGracePeriodResponse>> {
        const result = this.api.subscriptionGracePeriodsUpdateInstanceWithHttpInfo(id, subscriptionGracePeriodUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param subscriptionGracePeriodUpdateRequest SubscriptionGracePeriod representation
     */
    public subscriptionGracePeriodsUpdateInstance(id: string, subscriptionGracePeriodUpdateRequest: SubscriptionGracePeriodUpdateRequest, _options?: Configuration): Promise<SubscriptionGracePeriodResponse> {
        const result = this.api.subscriptionGracePeriodsUpdateInstance(id, subscriptionGracePeriodUpdateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableSubscriptionGroupLocalizationsApi } from './ObservableAPI.ts';

import { SubscriptionGroupLocalizationsApiRequestFactory, SubscriptionGroupLocalizationsApiResponseProcessor} from "../apis/SubscriptionGroupLocalizationsApi.ts";
export class PromiseSubscriptionGroupLocalizationsApi {
    private api: ObservableSubscriptionGroupLocalizationsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: SubscriptionGroupLocalizationsApiRequestFactory,
        responseProcessor?: SubscriptionGroupLocalizationsApiResponseProcessor
    ) {
        this.api = new ObservableSubscriptionGroupLocalizationsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param subscriptionGroupLocalizationCreateRequest SubscriptionGroupLocalization representation
     */
    public subscriptionGroupLocalizationsCreateInstanceWithHttpInfo(subscriptionGroupLocalizationCreateRequest: SubscriptionGroupLocalizationCreateRequest, _options?: Configuration): Promise<HttpInfo<SubscriptionGroupLocalizationResponse>> {
        const result = this.api.subscriptionGroupLocalizationsCreateInstanceWithHttpInfo(subscriptionGroupLocalizationCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param subscriptionGroupLocalizationCreateRequest SubscriptionGroupLocalization representation
     */
    public subscriptionGroupLocalizationsCreateInstance(subscriptionGroupLocalizationCreateRequest: SubscriptionGroupLocalizationCreateRequest, _options?: Configuration): Promise<SubscriptionGroupLocalizationResponse> {
        const result = this.api.subscriptionGroupLocalizationsCreateInstance(subscriptionGroupLocalizationCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public subscriptionGroupLocalizationsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.subscriptionGroupLocalizationsDeleteInstanceWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public subscriptionGroupLocalizationsDeleteInstance(id: string, _options?: Configuration): Promise<void> {
        const result = this.api.subscriptionGroupLocalizationsDeleteInstance(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsSubscriptionGroupLocalizations the fields to include for returned resources of type subscriptionGroupLocalizations
     * @param include comma-separated list of relationships to include
     */
    public subscriptionGroupLocalizationsGetInstanceWithHttpInfo(id: string, fieldsSubscriptionGroupLocalizations?: Array<'customAppName' | 'locale' | 'name' | 'state' | 'subscriptionGroup'>, include?: Array<'subscriptionGroup'>, _options?: Configuration): Promise<HttpInfo<SubscriptionGroupLocalizationResponse>> {
        const result = this.api.subscriptionGroupLocalizationsGetInstanceWithHttpInfo(id, fieldsSubscriptionGroupLocalizations, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsSubscriptionGroupLocalizations the fields to include for returned resources of type subscriptionGroupLocalizations
     * @param include comma-separated list of relationships to include
     */
    public subscriptionGroupLocalizationsGetInstance(id: string, fieldsSubscriptionGroupLocalizations?: Array<'customAppName' | 'locale' | 'name' | 'state' | 'subscriptionGroup'>, include?: Array<'subscriptionGroup'>, _options?: Configuration): Promise<SubscriptionGroupLocalizationResponse> {
        const result = this.api.subscriptionGroupLocalizationsGetInstance(id, fieldsSubscriptionGroupLocalizations, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param subscriptionGroupLocalizationUpdateRequest SubscriptionGroupLocalization representation
     */
    public subscriptionGroupLocalizationsUpdateInstanceWithHttpInfo(id: string, subscriptionGroupLocalizationUpdateRequest: SubscriptionGroupLocalizationUpdateRequest, _options?: Configuration): Promise<HttpInfo<SubscriptionGroupLocalizationResponse>> {
        const result = this.api.subscriptionGroupLocalizationsUpdateInstanceWithHttpInfo(id, subscriptionGroupLocalizationUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param subscriptionGroupLocalizationUpdateRequest SubscriptionGroupLocalization representation
     */
    public subscriptionGroupLocalizationsUpdateInstance(id: string, subscriptionGroupLocalizationUpdateRequest: SubscriptionGroupLocalizationUpdateRequest, _options?: Configuration): Promise<SubscriptionGroupLocalizationResponse> {
        const result = this.api.subscriptionGroupLocalizationsUpdateInstance(id, subscriptionGroupLocalizationUpdateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableSubscriptionGroupSubmissionsApi } from './ObservableAPI.ts';

import { SubscriptionGroupSubmissionsApiRequestFactory, SubscriptionGroupSubmissionsApiResponseProcessor} from "../apis/SubscriptionGroupSubmissionsApi.ts";
export class PromiseSubscriptionGroupSubmissionsApi {
    private api: ObservableSubscriptionGroupSubmissionsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: SubscriptionGroupSubmissionsApiRequestFactory,
        responseProcessor?: SubscriptionGroupSubmissionsApiResponseProcessor
    ) {
        this.api = new ObservableSubscriptionGroupSubmissionsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param subscriptionGroupSubmissionCreateRequest SubscriptionGroupSubmission representation
     */
    public subscriptionGroupSubmissionsCreateInstanceWithHttpInfo(subscriptionGroupSubmissionCreateRequest: SubscriptionGroupSubmissionCreateRequest, _options?: Configuration): Promise<HttpInfo<SubscriptionGroupSubmissionResponse>> {
        const result = this.api.subscriptionGroupSubmissionsCreateInstanceWithHttpInfo(subscriptionGroupSubmissionCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param subscriptionGroupSubmissionCreateRequest SubscriptionGroupSubmission representation
     */
    public subscriptionGroupSubmissionsCreateInstance(subscriptionGroupSubmissionCreateRequest: SubscriptionGroupSubmissionCreateRequest, _options?: Configuration): Promise<SubscriptionGroupSubmissionResponse> {
        const result = this.api.subscriptionGroupSubmissionsCreateInstance(subscriptionGroupSubmissionCreateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableSubscriptionGroupsApi } from './ObservableAPI.ts';

import { SubscriptionGroupsApiRequestFactory, SubscriptionGroupsApiResponseProcessor} from "../apis/SubscriptionGroupsApi.ts";
export class PromiseSubscriptionGroupsApi {
    private api: ObservableSubscriptionGroupsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: SubscriptionGroupsApiRequestFactory,
        responseProcessor?: SubscriptionGroupsApiResponseProcessor
    ) {
        this.api = new ObservableSubscriptionGroupsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param subscriptionGroupCreateRequest SubscriptionGroup representation
     */
    public subscriptionGroupsCreateInstanceWithHttpInfo(subscriptionGroupCreateRequest: SubscriptionGroupCreateRequest, _options?: Configuration): Promise<HttpInfo<SubscriptionGroupResponse>> {
        const result = this.api.subscriptionGroupsCreateInstanceWithHttpInfo(subscriptionGroupCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param subscriptionGroupCreateRequest SubscriptionGroup representation
     */
    public subscriptionGroupsCreateInstance(subscriptionGroupCreateRequest: SubscriptionGroupCreateRequest, _options?: Configuration): Promise<SubscriptionGroupResponse> {
        const result = this.api.subscriptionGroupsCreateInstance(subscriptionGroupCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public subscriptionGroupsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.subscriptionGroupsDeleteInstanceWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public subscriptionGroupsDeleteInstance(id: string, _options?: Configuration): Promise<void> {
        const result = this.api.subscriptionGroupsDeleteInstance(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsSubscriptionGroups the fields to include for returned resources of type subscriptionGroups
     * @param include comma-separated list of relationships to include
     * @param fieldsSubscriptions the fields to include for returned resources of type subscriptions
     * @param fieldsSubscriptionGroupLocalizations the fields to include for returned resources of type subscriptionGroupLocalizations
     * @param limitSubscriptionGroupLocalizations maximum number of related subscriptionGroupLocalizations returned (when they are included)
     * @param limitSubscriptions maximum number of related subscriptions returned (when they are included)
     */
    public subscriptionGroupsGetInstanceWithHttpInfo(id: string, fieldsSubscriptionGroups?: Array<'app' | 'referenceName' | 'subscriptionGroupLocalizations' | 'subscriptions'>, include?: Array<'subscriptionGroupLocalizations' | 'subscriptions'>, fieldsSubscriptions?: Array<'appStoreReviewScreenshot' | 'familySharable' | 'group' | 'groupLevel' | 'introductoryOffers' | 'name' | 'offerCodes' | 'pricePoints' | 'prices' | 'productId' | 'promotedPurchase' | 'promotionalOffers' | 'reviewNote' | 'state' | 'subscriptionAvailability' | 'subscriptionLocalizations' | 'subscriptionPeriod'>, fieldsSubscriptionGroupLocalizations?: Array<'customAppName' | 'locale' | 'name' | 'state' | 'subscriptionGroup'>, limitSubscriptionGroupLocalizations?: number, limitSubscriptions?: number, _options?: Configuration): Promise<HttpInfo<SubscriptionGroupResponse>> {
        const result = this.api.subscriptionGroupsGetInstanceWithHttpInfo(id, fieldsSubscriptionGroups, include, fieldsSubscriptions, fieldsSubscriptionGroupLocalizations, limitSubscriptionGroupLocalizations, limitSubscriptions, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsSubscriptionGroups the fields to include for returned resources of type subscriptionGroups
     * @param include comma-separated list of relationships to include
     * @param fieldsSubscriptions the fields to include for returned resources of type subscriptions
     * @param fieldsSubscriptionGroupLocalizations the fields to include for returned resources of type subscriptionGroupLocalizations
     * @param limitSubscriptionGroupLocalizations maximum number of related subscriptionGroupLocalizations returned (when they are included)
     * @param limitSubscriptions maximum number of related subscriptions returned (when they are included)
     */
    public subscriptionGroupsGetInstance(id: string, fieldsSubscriptionGroups?: Array<'app' | 'referenceName' | 'subscriptionGroupLocalizations' | 'subscriptions'>, include?: Array<'subscriptionGroupLocalizations' | 'subscriptions'>, fieldsSubscriptions?: Array<'appStoreReviewScreenshot' | 'familySharable' | 'group' | 'groupLevel' | 'introductoryOffers' | 'name' | 'offerCodes' | 'pricePoints' | 'prices' | 'productId' | 'promotedPurchase' | 'promotionalOffers' | 'reviewNote' | 'state' | 'subscriptionAvailability' | 'subscriptionLocalizations' | 'subscriptionPeriod'>, fieldsSubscriptionGroupLocalizations?: Array<'customAppName' | 'locale' | 'name' | 'state' | 'subscriptionGroup'>, limitSubscriptionGroupLocalizations?: number, limitSubscriptions?: number, _options?: Configuration): Promise<SubscriptionGroupResponse> {
        const result = this.api.subscriptionGroupsGetInstance(id, fieldsSubscriptionGroups, include, fieldsSubscriptions, fieldsSubscriptionGroupLocalizations, limitSubscriptionGroupLocalizations, limitSubscriptions, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsSubscriptionGroups the fields to include for returned resources of type subscriptionGroups
     * @param fieldsSubscriptionGroupLocalizations the fields to include for returned resources of type subscriptionGroupLocalizations
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public subscriptionGroupsSubscriptionGroupLocalizationsGetToManyRelatedWithHttpInfo(id: string, fieldsSubscriptionGroups?: Array<'app' | 'referenceName' | 'subscriptionGroupLocalizations' | 'subscriptions'>, fieldsSubscriptionGroupLocalizations?: Array<'customAppName' | 'locale' | 'name' | 'state' | 'subscriptionGroup'>, limit?: number, include?: Array<'subscriptionGroup'>, _options?: Configuration): Promise<HttpInfo<SubscriptionGroupLocalizationsResponse>> {
        const result = this.api.subscriptionGroupsSubscriptionGroupLocalizationsGetToManyRelatedWithHttpInfo(id, fieldsSubscriptionGroups, fieldsSubscriptionGroupLocalizations, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsSubscriptionGroups the fields to include for returned resources of type subscriptionGroups
     * @param fieldsSubscriptionGroupLocalizations the fields to include for returned resources of type subscriptionGroupLocalizations
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public subscriptionGroupsSubscriptionGroupLocalizationsGetToManyRelated(id: string, fieldsSubscriptionGroups?: Array<'app' | 'referenceName' | 'subscriptionGroupLocalizations' | 'subscriptions'>, fieldsSubscriptionGroupLocalizations?: Array<'customAppName' | 'locale' | 'name' | 'state' | 'subscriptionGroup'>, limit?: number, include?: Array<'subscriptionGroup'>, _options?: Configuration): Promise<SubscriptionGroupLocalizationsResponse> {
        const result = this.api.subscriptionGroupsSubscriptionGroupLocalizationsGetToManyRelated(id, fieldsSubscriptionGroups, fieldsSubscriptionGroupLocalizations, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterName filter by attribute \&#39;name\&#39;
     * @param filterProductId filter by attribute \&#39;productId\&#39;
     * @param filterState filter by attribute \&#39;state\&#39;
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsPromotedPurchases the fields to include for returned resources of type promotedPurchases
     * @param fieldsSubscriptionPromotionalOffers the fields to include for returned resources of type subscriptionPromotionalOffers
     * @param fieldsSubscriptionOfferCodes the fields to include for returned resources of type subscriptionOfferCodes
     * @param fieldsSubscriptionAppStoreReviewScreenshots the fields to include for returned resources of type subscriptionAppStoreReviewScreenshots
     * @param fieldsSubscriptions the fields to include for returned resources of type subscriptions
     * @param fieldsSubscriptionAvailabilities the fields to include for returned resources of type subscriptionAvailabilities
     * @param fieldsSubscriptionGroups the fields to include for returned resources of type subscriptionGroups
     * @param fieldsSubscriptionIntroductoryOffers the fields to include for returned resources of type subscriptionIntroductoryOffers
     * @param fieldsSubscriptionPrices the fields to include for returned resources of type subscriptionPrices
     * @param fieldsSubscriptionLocalizations the fields to include for returned resources of type subscriptionLocalizations
     * @param limit maximum resources per page
     * @param limitSubscriptionLocalizations maximum number of related subscriptionLocalizations returned (when they are included)
     * @param limitIntroductoryOffers maximum number of related introductoryOffers returned (when they are included)
     * @param limitPromotionalOffers maximum number of related promotionalOffers returned (when they are included)
     * @param limitOfferCodes maximum number of related offerCodes returned (when they are included)
     * @param limitPrices maximum number of related prices returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public subscriptionGroupsSubscriptionsGetToManyRelatedWithHttpInfo(id: string, filterName?: Array<string>, filterProductId?: Array<string>, filterState?: Array<'MISSING_METADATA' | 'READY_TO_SUBMIT' | 'WAITING_FOR_REVIEW' | 'IN_REVIEW' | 'DEVELOPER_ACTION_NEEDED' | 'PENDING_BINARY_APPROVAL' | 'APPROVED' | 'DEVELOPER_REMOVED_FROM_SALE' | 'REMOVED_FROM_SALE' | 'REJECTED'>, sort?: Array<'name' | '-name'>, fieldsPromotedPurchases?: Array<'app' | 'enabled' | 'inAppPurchaseV2' | 'promotionImages' | 'state' | 'subscription' | 'visibleForAllUsers'>, fieldsSubscriptionPromotionalOffers?: Array<'duration' | 'name' | 'numberOfPeriods' | 'offerCode' | 'offerMode' | 'prices' | 'subscription'>, fieldsSubscriptionOfferCodes?: Array<'active' | 'customCodes' | 'customerEligibilities' | 'duration' | 'name' | 'numberOfPeriods' | 'offerEligibility' | 'offerMode' | 'oneTimeUseCodes' | 'prices' | 'subscription' | 'totalNumberOfCodes'>, fieldsSubscriptionAppStoreReviewScreenshots?: Array<'assetDeliveryState' | 'assetToken' | 'assetType' | 'fileName' | 'fileSize' | 'imageAsset' | 'sourceFileChecksum' | 'subscription' | 'uploadOperations' | 'uploaded'>, fieldsSubscriptions?: Array<'appStoreReviewScreenshot' | 'familySharable' | 'group' | 'groupLevel' | 'introductoryOffers' | 'name' | 'offerCodes' | 'pricePoints' | 'prices' | 'productId' | 'promotedPurchase' | 'promotionalOffers' | 'reviewNote' | 'state' | 'subscriptionAvailability' | 'subscriptionLocalizations' | 'subscriptionPeriod'>, fieldsSubscriptionAvailabilities?: Array<'availableInNewTerritories' | 'availableTerritories' | 'subscription'>, fieldsSubscriptionGroups?: Array<'app' | 'referenceName' | 'subscriptionGroupLocalizations' | 'subscriptions'>, fieldsSubscriptionIntroductoryOffers?: Array<'duration' | 'endDate' | 'numberOfPeriods' | 'offerMode' | 'startDate' | 'subscription' | 'subscriptionPricePoint' | 'territory'>, fieldsSubscriptionPrices?: Array<'preserveCurrentPrice' | 'preserved' | 'startDate' | 'subscription' | 'subscriptionPricePoint' | 'territory'>, fieldsSubscriptionLocalizations?: Array<'description' | 'locale' | 'name' | 'state' | 'subscription'>, limit?: number, limitSubscriptionLocalizations?: number, limitIntroductoryOffers?: number, limitPromotionalOffers?: number, limitOfferCodes?: number, limitPrices?: number, include?: Array<'appStoreReviewScreenshot' | 'group' | 'introductoryOffers' | 'offerCodes' | 'prices' | 'promotedPurchase' | 'promotionalOffers' | 'subscriptionAvailability' | 'subscriptionLocalizations'>, _options?: Configuration): Promise<HttpInfo<SubscriptionsResponse>> {
        const result = this.api.subscriptionGroupsSubscriptionsGetToManyRelatedWithHttpInfo(id, filterName, filterProductId, filterState, sort, fieldsPromotedPurchases, fieldsSubscriptionPromotionalOffers, fieldsSubscriptionOfferCodes, fieldsSubscriptionAppStoreReviewScreenshots, fieldsSubscriptions, fieldsSubscriptionAvailabilities, fieldsSubscriptionGroups, fieldsSubscriptionIntroductoryOffers, fieldsSubscriptionPrices, fieldsSubscriptionLocalizations, limit, limitSubscriptionLocalizations, limitIntroductoryOffers, limitPromotionalOffers, limitOfferCodes, limitPrices, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterName filter by attribute \&#39;name\&#39;
     * @param filterProductId filter by attribute \&#39;productId\&#39;
     * @param filterState filter by attribute \&#39;state\&#39;
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsPromotedPurchases the fields to include for returned resources of type promotedPurchases
     * @param fieldsSubscriptionPromotionalOffers the fields to include for returned resources of type subscriptionPromotionalOffers
     * @param fieldsSubscriptionOfferCodes the fields to include for returned resources of type subscriptionOfferCodes
     * @param fieldsSubscriptionAppStoreReviewScreenshots the fields to include for returned resources of type subscriptionAppStoreReviewScreenshots
     * @param fieldsSubscriptions the fields to include for returned resources of type subscriptions
     * @param fieldsSubscriptionAvailabilities the fields to include for returned resources of type subscriptionAvailabilities
     * @param fieldsSubscriptionGroups the fields to include for returned resources of type subscriptionGroups
     * @param fieldsSubscriptionIntroductoryOffers the fields to include for returned resources of type subscriptionIntroductoryOffers
     * @param fieldsSubscriptionPrices the fields to include for returned resources of type subscriptionPrices
     * @param fieldsSubscriptionLocalizations the fields to include for returned resources of type subscriptionLocalizations
     * @param limit maximum resources per page
     * @param limitSubscriptionLocalizations maximum number of related subscriptionLocalizations returned (when they are included)
     * @param limitIntroductoryOffers maximum number of related introductoryOffers returned (when they are included)
     * @param limitPromotionalOffers maximum number of related promotionalOffers returned (when they are included)
     * @param limitOfferCodes maximum number of related offerCodes returned (when they are included)
     * @param limitPrices maximum number of related prices returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public subscriptionGroupsSubscriptionsGetToManyRelated(id: string, filterName?: Array<string>, filterProductId?: Array<string>, filterState?: Array<'MISSING_METADATA' | 'READY_TO_SUBMIT' | 'WAITING_FOR_REVIEW' | 'IN_REVIEW' | 'DEVELOPER_ACTION_NEEDED' | 'PENDING_BINARY_APPROVAL' | 'APPROVED' | 'DEVELOPER_REMOVED_FROM_SALE' | 'REMOVED_FROM_SALE' | 'REJECTED'>, sort?: Array<'name' | '-name'>, fieldsPromotedPurchases?: Array<'app' | 'enabled' | 'inAppPurchaseV2' | 'promotionImages' | 'state' | 'subscription' | 'visibleForAllUsers'>, fieldsSubscriptionPromotionalOffers?: Array<'duration' | 'name' | 'numberOfPeriods' | 'offerCode' | 'offerMode' | 'prices' | 'subscription'>, fieldsSubscriptionOfferCodes?: Array<'active' | 'customCodes' | 'customerEligibilities' | 'duration' | 'name' | 'numberOfPeriods' | 'offerEligibility' | 'offerMode' | 'oneTimeUseCodes' | 'prices' | 'subscription' | 'totalNumberOfCodes'>, fieldsSubscriptionAppStoreReviewScreenshots?: Array<'assetDeliveryState' | 'assetToken' | 'assetType' | 'fileName' | 'fileSize' | 'imageAsset' | 'sourceFileChecksum' | 'subscription' | 'uploadOperations' | 'uploaded'>, fieldsSubscriptions?: Array<'appStoreReviewScreenshot' | 'familySharable' | 'group' | 'groupLevel' | 'introductoryOffers' | 'name' | 'offerCodes' | 'pricePoints' | 'prices' | 'productId' | 'promotedPurchase' | 'promotionalOffers' | 'reviewNote' | 'state' | 'subscriptionAvailability' | 'subscriptionLocalizations' | 'subscriptionPeriod'>, fieldsSubscriptionAvailabilities?: Array<'availableInNewTerritories' | 'availableTerritories' | 'subscription'>, fieldsSubscriptionGroups?: Array<'app' | 'referenceName' | 'subscriptionGroupLocalizations' | 'subscriptions'>, fieldsSubscriptionIntroductoryOffers?: Array<'duration' | 'endDate' | 'numberOfPeriods' | 'offerMode' | 'startDate' | 'subscription' | 'subscriptionPricePoint' | 'territory'>, fieldsSubscriptionPrices?: Array<'preserveCurrentPrice' | 'preserved' | 'startDate' | 'subscription' | 'subscriptionPricePoint' | 'territory'>, fieldsSubscriptionLocalizations?: Array<'description' | 'locale' | 'name' | 'state' | 'subscription'>, limit?: number, limitSubscriptionLocalizations?: number, limitIntroductoryOffers?: number, limitPromotionalOffers?: number, limitOfferCodes?: number, limitPrices?: number, include?: Array<'appStoreReviewScreenshot' | 'group' | 'introductoryOffers' | 'offerCodes' | 'prices' | 'promotedPurchase' | 'promotionalOffers' | 'subscriptionAvailability' | 'subscriptionLocalizations'>, _options?: Configuration): Promise<SubscriptionsResponse> {
        const result = this.api.subscriptionGroupsSubscriptionsGetToManyRelated(id, filterName, filterProductId, filterState, sort, fieldsPromotedPurchases, fieldsSubscriptionPromotionalOffers, fieldsSubscriptionOfferCodes, fieldsSubscriptionAppStoreReviewScreenshots, fieldsSubscriptions, fieldsSubscriptionAvailabilities, fieldsSubscriptionGroups, fieldsSubscriptionIntroductoryOffers, fieldsSubscriptionPrices, fieldsSubscriptionLocalizations, limit, limitSubscriptionLocalizations, limitIntroductoryOffers, limitPromotionalOffers, limitOfferCodes, limitPrices, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param subscriptionGroupUpdateRequest SubscriptionGroup representation
     */
    public subscriptionGroupsUpdateInstanceWithHttpInfo(id: string, subscriptionGroupUpdateRequest: SubscriptionGroupUpdateRequest, _options?: Configuration): Promise<HttpInfo<SubscriptionGroupResponse>> {
        const result = this.api.subscriptionGroupsUpdateInstanceWithHttpInfo(id, subscriptionGroupUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param subscriptionGroupUpdateRequest SubscriptionGroup representation
     */
    public subscriptionGroupsUpdateInstance(id: string, subscriptionGroupUpdateRequest: SubscriptionGroupUpdateRequest, _options?: Configuration): Promise<SubscriptionGroupResponse> {
        const result = this.api.subscriptionGroupsUpdateInstance(id, subscriptionGroupUpdateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableSubscriptionIntroductoryOffersApi } from './ObservableAPI.ts';

import { SubscriptionIntroductoryOffersApiRequestFactory, SubscriptionIntroductoryOffersApiResponseProcessor} from "../apis/SubscriptionIntroductoryOffersApi.ts";
export class PromiseSubscriptionIntroductoryOffersApi {
    private api: ObservableSubscriptionIntroductoryOffersApi

    public constructor(
        configuration: Configuration,
        requestFactory?: SubscriptionIntroductoryOffersApiRequestFactory,
        responseProcessor?: SubscriptionIntroductoryOffersApiResponseProcessor
    ) {
        this.api = new ObservableSubscriptionIntroductoryOffersApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param subscriptionIntroductoryOfferCreateRequest SubscriptionIntroductoryOffer representation
     */
    public subscriptionIntroductoryOffersCreateInstanceWithHttpInfo(subscriptionIntroductoryOfferCreateRequest: SubscriptionIntroductoryOfferCreateRequest, _options?: Configuration): Promise<HttpInfo<SubscriptionIntroductoryOfferResponse>> {
        const result = this.api.subscriptionIntroductoryOffersCreateInstanceWithHttpInfo(subscriptionIntroductoryOfferCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param subscriptionIntroductoryOfferCreateRequest SubscriptionIntroductoryOffer representation
     */
    public subscriptionIntroductoryOffersCreateInstance(subscriptionIntroductoryOfferCreateRequest: SubscriptionIntroductoryOfferCreateRequest, _options?: Configuration): Promise<SubscriptionIntroductoryOfferResponse> {
        const result = this.api.subscriptionIntroductoryOffersCreateInstance(subscriptionIntroductoryOfferCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public subscriptionIntroductoryOffersDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.subscriptionIntroductoryOffersDeleteInstanceWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public subscriptionIntroductoryOffersDeleteInstance(id: string, _options?: Configuration): Promise<void> {
        const result = this.api.subscriptionIntroductoryOffersDeleteInstance(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param subscriptionIntroductoryOfferUpdateRequest SubscriptionIntroductoryOffer representation
     */
    public subscriptionIntroductoryOffersUpdateInstanceWithHttpInfo(id: string, subscriptionIntroductoryOfferUpdateRequest: SubscriptionIntroductoryOfferUpdateRequest, _options?: Configuration): Promise<HttpInfo<SubscriptionIntroductoryOfferResponse>> {
        const result = this.api.subscriptionIntroductoryOffersUpdateInstanceWithHttpInfo(id, subscriptionIntroductoryOfferUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param subscriptionIntroductoryOfferUpdateRequest SubscriptionIntroductoryOffer representation
     */
    public subscriptionIntroductoryOffersUpdateInstance(id: string, subscriptionIntroductoryOfferUpdateRequest: SubscriptionIntroductoryOfferUpdateRequest, _options?: Configuration): Promise<SubscriptionIntroductoryOfferResponse> {
        const result = this.api.subscriptionIntroductoryOffersUpdateInstance(id, subscriptionIntroductoryOfferUpdateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableSubscriptionLocalizationsApi } from './ObservableAPI.ts';

import { SubscriptionLocalizationsApiRequestFactory, SubscriptionLocalizationsApiResponseProcessor} from "../apis/SubscriptionLocalizationsApi.ts";
export class PromiseSubscriptionLocalizationsApi {
    private api: ObservableSubscriptionLocalizationsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: SubscriptionLocalizationsApiRequestFactory,
        responseProcessor?: SubscriptionLocalizationsApiResponseProcessor
    ) {
        this.api = new ObservableSubscriptionLocalizationsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param subscriptionLocalizationCreateRequest SubscriptionLocalization representation
     */
    public subscriptionLocalizationsCreateInstanceWithHttpInfo(subscriptionLocalizationCreateRequest: SubscriptionLocalizationCreateRequest, _options?: Configuration): Promise<HttpInfo<SubscriptionLocalizationResponse>> {
        const result = this.api.subscriptionLocalizationsCreateInstanceWithHttpInfo(subscriptionLocalizationCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param subscriptionLocalizationCreateRequest SubscriptionLocalization representation
     */
    public subscriptionLocalizationsCreateInstance(subscriptionLocalizationCreateRequest: SubscriptionLocalizationCreateRequest, _options?: Configuration): Promise<SubscriptionLocalizationResponse> {
        const result = this.api.subscriptionLocalizationsCreateInstance(subscriptionLocalizationCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public subscriptionLocalizationsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.subscriptionLocalizationsDeleteInstanceWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public subscriptionLocalizationsDeleteInstance(id: string, _options?: Configuration): Promise<void> {
        const result = this.api.subscriptionLocalizationsDeleteInstance(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsSubscriptionLocalizations the fields to include for returned resources of type subscriptionLocalizations
     * @param include comma-separated list of relationships to include
     */
    public subscriptionLocalizationsGetInstanceWithHttpInfo(id: string, fieldsSubscriptionLocalizations?: Array<'description' | 'locale' | 'name' | 'state' | 'subscription'>, include?: Array<'subscription'>, _options?: Configuration): Promise<HttpInfo<SubscriptionLocalizationResponse>> {
        const result = this.api.subscriptionLocalizationsGetInstanceWithHttpInfo(id, fieldsSubscriptionLocalizations, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsSubscriptionLocalizations the fields to include for returned resources of type subscriptionLocalizations
     * @param include comma-separated list of relationships to include
     */
    public subscriptionLocalizationsGetInstance(id: string, fieldsSubscriptionLocalizations?: Array<'description' | 'locale' | 'name' | 'state' | 'subscription'>, include?: Array<'subscription'>, _options?: Configuration): Promise<SubscriptionLocalizationResponse> {
        const result = this.api.subscriptionLocalizationsGetInstance(id, fieldsSubscriptionLocalizations, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param subscriptionLocalizationUpdateRequest SubscriptionLocalization representation
     */
    public subscriptionLocalizationsUpdateInstanceWithHttpInfo(id: string, subscriptionLocalizationUpdateRequest: SubscriptionLocalizationUpdateRequest, _options?: Configuration): Promise<HttpInfo<SubscriptionLocalizationResponse>> {
        const result = this.api.subscriptionLocalizationsUpdateInstanceWithHttpInfo(id, subscriptionLocalizationUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param subscriptionLocalizationUpdateRequest SubscriptionLocalization representation
     */
    public subscriptionLocalizationsUpdateInstance(id: string, subscriptionLocalizationUpdateRequest: SubscriptionLocalizationUpdateRequest, _options?: Configuration): Promise<SubscriptionLocalizationResponse> {
        const result = this.api.subscriptionLocalizationsUpdateInstance(id, subscriptionLocalizationUpdateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableSubscriptionOfferCodeCustomCodesApi } from './ObservableAPI.ts';

import { SubscriptionOfferCodeCustomCodesApiRequestFactory, SubscriptionOfferCodeCustomCodesApiResponseProcessor} from "../apis/SubscriptionOfferCodeCustomCodesApi.ts";
export class PromiseSubscriptionOfferCodeCustomCodesApi {
    private api: ObservableSubscriptionOfferCodeCustomCodesApi

    public constructor(
        configuration: Configuration,
        requestFactory?: SubscriptionOfferCodeCustomCodesApiRequestFactory,
        responseProcessor?: SubscriptionOfferCodeCustomCodesApiResponseProcessor
    ) {
        this.api = new ObservableSubscriptionOfferCodeCustomCodesApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param subscriptionOfferCodeCustomCodeCreateRequest SubscriptionOfferCodeCustomCode representation
     */
    public subscriptionOfferCodeCustomCodesCreateInstanceWithHttpInfo(subscriptionOfferCodeCustomCodeCreateRequest: SubscriptionOfferCodeCustomCodeCreateRequest, _options?: Configuration): Promise<HttpInfo<SubscriptionOfferCodeCustomCodeResponse>> {
        const result = this.api.subscriptionOfferCodeCustomCodesCreateInstanceWithHttpInfo(subscriptionOfferCodeCustomCodeCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param subscriptionOfferCodeCustomCodeCreateRequest SubscriptionOfferCodeCustomCode representation
     */
    public subscriptionOfferCodeCustomCodesCreateInstance(subscriptionOfferCodeCustomCodeCreateRequest: SubscriptionOfferCodeCustomCodeCreateRequest, _options?: Configuration): Promise<SubscriptionOfferCodeCustomCodeResponse> {
        const result = this.api.subscriptionOfferCodeCustomCodesCreateInstance(subscriptionOfferCodeCustomCodeCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsSubscriptionOfferCodeCustomCodes the fields to include for returned resources of type subscriptionOfferCodeCustomCodes
     * @param include comma-separated list of relationships to include
     */
    public subscriptionOfferCodeCustomCodesGetInstanceWithHttpInfo(id: string, fieldsSubscriptionOfferCodeCustomCodes?: Array<'active' | 'createdDate' | 'customCode' | 'expirationDate' | 'numberOfCodes' | 'offerCode'>, include?: Array<'offerCode'>, _options?: Configuration): Promise<HttpInfo<SubscriptionOfferCodeCustomCodeResponse>> {
        const result = this.api.subscriptionOfferCodeCustomCodesGetInstanceWithHttpInfo(id, fieldsSubscriptionOfferCodeCustomCodes, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsSubscriptionOfferCodeCustomCodes the fields to include for returned resources of type subscriptionOfferCodeCustomCodes
     * @param include comma-separated list of relationships to include
     */
    public subscriptionOfferCodeCustomCodesGetInstance(id: string, fieldsSubscriptionOfferCodeCustomCodes?: Array<'active' | 'createdDate' | 'customCode' | 'expirationDate' | 'numberOfCodes' | 'offerCode'>, include?: Array<'offerCode'>, _options?: Configuration): Promise<SubscriptionOfferCodeCustomCodeResponse> {
        const result = this.api.subscriptionOfferCodeCustomCodesGetInstance(id, fieldsSubscriptionOfferCodeCustomCodes, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param subscriptionOfferCodeCustomCodeUpdateRequest SubscriptionOfferCodeCustomCode representation
     */
    public subscriptionOfferCodeCustomCodesUpdateInstanceWithHttpInfo(id: string, subscriptionOfferCodeCustomCodeUpdateRequest: SubscriptionOfferCodeCustomCodeUpdateRequest, _options?: Configuration): Promise<HttpInfo<SubscriptionOfferCodeCustomCodeResponse>> {
        const result = this.api.subscriptionOfferCodeCustomCodesUpdateInstanceWithHttpInfo(id, subscriptionOfferCodeCustomCodeUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param subscriptionOfferCodeCustomCodeUpdateRequest SubscriptionOfferCodeCustomCode representation
     */
    public subscriptionOfferCodeCustomCodesUpdateInstance(id: string, subscriptionOfferCodeCustomCodeUpdateRequest: SubscriptionOfferCodeCustomCodeUpdateRequest, _options?: Configuration): Promise<SubscriptionOfferCodeCustomCodeResponse> {
        const result = this.api.subscriptionOfferCodeCustomCodesUpdateInstance(id, subscriptionOfferCodeCustomCodeUpdateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableSubscriptionOfferCodeOneTimeUseCodesApi } from './ObservableAPI.ts';

import { SubscriptionOfferCodeOneTimeUseCodesApiRequestFactory, SubscriptionOfferCodeOneTimeUseCodesApiResponseProcessor} from "../apis/SubscriptionOfferCodeOneTimeUseCodesApi.ts";
export class PromiseSubscriptionOfferCodeOneTimeUseCodesApi {
    private api: ObservableSubscriptionOfferCodeOneTimeUseCodesApi

    public constructor(
        configuration: Configuration,
        requestFactory?: SubscriptionOfferCodeOneTimeUseCodesApiRequestFactory,
        responseProcessor?: SubscriptionOfferCodeOneTimeUseCodesApiResponseProcessor
    ) {
        this.api = new ObservableSubscriptionOfferCodeOneTimeUseCodesApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param subscriptionOfferCodeOneTimeUseCodeCreateRequest SubscriptionOfferCodeOneTimeUseCode representation
     */
    public subscriptionOfferCodeOneTimeUseCodesCreateInstanceWithHttpInfo(subscriptionOfferCodeOneTimeUseCodeCreateRequest: SubscriptionOfferCodeOneTimeUseCodeCreateRequest, _options?: Configuration): Promise<HttpInfo<SubscriptionOfferCodeOneTimeUseCodeResponse>> {
        const result = this.api.subscriptionOfferCodeOneTimeUseCodesCreateInstanceWithHttpInfo(subscriptionOfferCodeOneTimeUseCodeCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param subscriptionOfferCodeOneTimeUseCodeCreateRequest SubscriptionOfferCodeOneTimeUseCode representation
     */
    public subscriptionOfferCodeOneTimeUseCodesCreateInstance(subscriptionOfferCodeOneTimeUseCodeCreateRequest: SubscriptionOfferCodeOneTimeUseCodeCreateRequest, _options?: Configuration): Promise<SubscriptionOfferCodeOneTimeUseCodeResponse> {
        const result = this.api.subscriptionOfferCodeOneTimeUseCodesCreateInstance(subscriptionOfferCodeOneTimeUseCodeCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsSubscriptionOfferCodeOneTimeUseCodes the fields to include for returned resources of type subscriptionOfferCodeOneTimeUseCodes
     * @param include comma-separated list of relationships to include
     */
    public subscriptionOfferCodeOneTimeUseCodesGetInstanceWithHttpInfo(id: string, fieldsSubscriptionOfferCodeOneTimeUseCodes?: Array<'active' | 'createdDate' | 'expirationDate' | 'numberOfCodes' | 'offerCode' | 'values'>, include?: Array<'offerCode'>, _options?: Configuration): Promise<HttpInfo<SubscriptionOfferCodeOneTimeUseCodeResponse>> {
        const result = this.api.subscriptionOfferCodeOneTimeUseCodesGetInstanceWithHttpInfo(id, fieldsSubscriptionOfferCodeOneTimeUseCodes, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsSubscriptionOfferCodeOneTimeUseCodes the fields to include for returned resources of type subscriptionOfferCodeOneTimeUseCodes
     * @param include comma-separated list of relationships to include
     */
    public subscriptionOfferCodeOneTimeUseCodesGetInstance(id: string, fieldsSubscriptionOfferCodeOneTimeUseCodes?: Array<'active' | 'createdDate' | 'expirationDate' | 'numberOfCodes' | 'offerCode' | 'values'>, include?: Array<'offerCode'>, _options?: Configuration): Promise<SubscriptionOfferCodeOneTimeUseCodeResponse> {
        const result = this.api.subscriptionOfferCodeOneTimeUseCodesGetInstance(id, fieldsSubscriptionOfferCodeOneTimeUseCodes, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param subscriptionOfferCodeOneTimeUseCodeUpdateRequest SubscriptionOfferCodeOneTimeUseCode representation
     */
    public subscriptionOfferCodeOneTimeUseCodesUpdateInstanceWithHttpInfo(id: string, subscriptionOfferCodeOneTimeUseCodeUpdateRequest: SubscriptionOfferCodeOneTimeUseCodeUpdateRequest, _options?: Configuration): Promise<HttpInfo<SubscriptionOfferCodeOneTimeUseCodeResponse>> {
        const result = this.api.subscriptionOfferCodeOneTimeUseCodesUpdateInstanceWithHttpInfo(id, subscriptionOfferCodeOneTimeUseCodeUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param subscriptionOfferCodeOneTimeUseCodeUpdateRequest SubscriptionOfferCodeOneTimeUseCode representation
     */
    public subscriptionOfferCodeOneTimeUseCodesUpdateInstance(id: string, subscriptionOfferCodeOneTimeUseCodeUpdateRequest: SubscriptionOfferCodeOneTimeUseCodeUpdateRequest, _options?: Configuration): Promise<SubscriptionOfferCodeOneTimeUseCodeResponse> {
        const result = this.api.subscriptionOfferCodeOneTimeUseCodesUpdateInstance(id, subscriptionOfferCodeOneTimeUseCodeUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public subscriptionOfferCodeOneTimeUseCodesValuesGetToOneRelatedWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<string>> {
        const result = this.api.subscriptionOfferCodeOneTimeUseCodesValuesGetToOneRelatedWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public subscriptionOfferCodeOneTimeUseCodesValuesGetToOneRelated(id: string, _options?: Configuration): Promise<string> {
        const result = this.api.subscriptionOfferCodeOneTimeUseCodesValuesGetToOneRelated(id, _options);
        return result.toPromise();
    }


}



import { ObservableSubscriptionOfferCodesApi } from './ObservableAPI.ts';

import { SubscriptionOfferCodesApiRequestFactory, SubscriptionOfferCodesApiResponseProcessor} from "../apis/SubscriptionOfferCodesApi.ts";
export class PromiseSubscriptionOfferCodesApi {
    private api: ObservableSubscriptionOfferCodesApi

    public constructor(
        configuration: Configuration,
        requestFactory?: SubscriptionOfferCodesApiRequestFactory,
        responseProcessor?: SubscriptionOfferCodesApiResponseProcessor
    ) {
        this.api = new ObservableSubscriptionOfferCodesApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param subscriptionOfferCodeCreateRequest SubscriptionOfferCode representation
     */
    public subscriptionOfferCodesCreateInstanceWithHttpInfo(subscriptionOfferCodeCreateRequest: SubscriptionOfferCodeCreateRequest, _options?: Configuration): Promise<HttpInfo<SubscriptionOfferCodeResponse>> {
        const result = this.api.subscriptionOfferCodesCreateInstanceWithHttpInfo(subscriptionOfferCodeCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param subscriptionOfferCodeCreateRequest SubscriptionOfferCode representation
     */
    public subscriptionOfferCodesCreateInstance(subscriptionOfferCodeCreateRequest: SubscriptionOfferCodeCreateRequest, _options?: Configuration): Promise<SubscriptionOfferCodeResponse> {
        const result = this.api.subscriptionOfferCodesCreateInstance(subscriptionOfferCodeCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsSubscriptionOfferCodeCustomCodes the fields to include for returned resources of type subscriptionOfferCodeCustomCodes
     * @param fieldsSubscriptionOfferCodes the fields to include for returned resources of type subscriptionOfferCodes
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public subscriptionOfferCodesCustomCodesGetToManyRelatedWithHttpInfo(id: string, fieldsSubscriptionOfferCodeCustomCodes?: Array<'active' | 'createdDate' | 'customCode' | 'expirationDate' | 'numberOfCodes' | 'offerCode'>, fieldsSubscriptionOfferCodes?: Array<'active' | 'customCodes' | 'customerEligibilities' | 'duration' | 'name' | 'numberOfPeriods' | 'offerEligibility' | 'offerMode' | 'oneTimeUseCodes' | 'prices' | 'subscription' | 'totalNumberOfCodes'>, limit?: number, include?: Array<'offerCode'>, _options?: Configuration): Promise<HttpInfo<SubscriptionOfferCodeCustomCodesResponse>> {
        const result = this.api.subscriptionOfferCodesCustomCodesGetToManyRelatedWithHttpInfo(id, fieldsSubscriptionOfferCodeCustomCodes, fieldsSubscriptionOfferCodes, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsSubscriptionOfferCodeCustomCodes the fields to include for returned resources of type subscriptionOfferCodeCustomCodes
     * @param fieldsSubscriptionOfferCodes the fields to include for returned resources of type subscriptionOfferCodes
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public subscriptionOfferCodesCustomCodesGetToManyRelated(id: string, fieldsSubscriptionOfferCodeCustomCodes?: Array<'active' | 'createdDate' | 'customCode' | 'expirationDate' | 'numberOfCodes' | 'offerCode'>, fieldsSubscriptionOfferCodes?: Array<'active' | 'customCodes' | 'customerEligibilities' | 'duration' | 'name' | 'numberOfPeriods' | 'offerEligibility' | 'offerMode' | 'oneTimeUseCodes' | 'prices' | 'subscription' | 'totalNumberOfCodes'>, limit?: number, include?: Array<'offerCode'>, _options?: Configuration): Promise<SubscriptionOfferCodeCustomCodesResponse> {
        const result = this.api.subscriptionOfferCodesCustomCodesGetToManyRelated(id, fieldsSubscriptionOfferCodeCustomCodes, fieldsSubscriptionOfferCodes, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsSubscriptionOfferCodes the fields to include for returned resources of type subscriptionOfferCodes
     * @param include comma-separated list of relationships to include
     * @param fieldsSubscriptionOfferCodeCustomCodes the fields to include for returned resources of type subscriptionOfferCodeCustomCodes
     * @param fieldsSubscriptionOfferCodeOneTimeUseCodes the fields to include for returned resources of type subscriptionOfferCodeOneTimeUseCodes
     * @param fieldsSubscriptionOfferCodePrices the fields to include for returned resources of type subscriptionOfferCodePrices
     * @param limitCustomCodes maximum number of related customCodes returned (when they are included)
     * @param limitOneTimeUseCodes maximum number of related oneTimeUseCodes returned (when they are included)
     * @param limitPrices maximum number of related prices returned (when they are included)
     */
    public subscriptionOfferCodesGetInstanceWithHttpInfo(id: string, fieldsSubscriptionOfferCodes?: Array<'active' | 'customCodes' | 'customerEligibilities' | 'duration' | 'name' | 'numberOfPeriods' | 'offerEligibility' | 'offerMode' | 'oneTimeUseCodes' | 'prices' | 'subscription' | 'totalNumberOfCodes'>, include?: Array<'customCodes' | 'oneTimeUseCodes' | 'prices' | 'subscription'>, fieldsSubscriptionOfferCodeCustomCodes?: Array<'active' | 'createdDate' | 'customCode' | 'expirationDate' | 'numberOfCodes' | 'offerCode'>, fieldsSubscriptionOfferCodeOneTimeUseCodes?: Array<'active' | 'createdDate' | 'expirationDate' | 'numberOfCodes' | 'offerCode' | 'values'>, fieldsSubscriptionOfferCodePrices?: Array<'subscriptionPricePoint' | 'territory'>, limitCustomCodes?: number, limitOneTimeUseCodes?: number, limitPrices?: number, _options?: Configuration): Promise<HttpInfo<SubscriptionOfferCodeResponse>> {
        const result = this.api.subscriptionOfferCodesGetInstanceWithHttpInfo(id, fieldsSubscriptionOfferCodes, include, fieldsSubscriptionOfferCodeCustomCodes, fieldsSubscriptionOfferCodeOneTimeUseCodes, fieldsSubscriptionOfferCodePrices, limitCustomCodes, limitOneTimeUseCodes, limitPrices, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsSubscriptionOfferCodes the fields to include for returned resources of type subscriptionOfferCodes
     * @param include comma-separated list of relationships to include
     * @param fieldsSubscriptionOfferCodeCustomCodes the fields to include for returned resources of type subscriptionOfferCodeCustomCodes
     * @param fieldsSubscriptionOfferCodeOneTimeUseCodes the fields to include for returned resources of type subscriptionOfferCodeOneTimeUseCodes
     * @param fieldsSubscriptionOfferCodePrices the fields to include for returned resources of type subscriptionOfferCodePrices
     * @param limitCustomCodes maximum number of related customCodes returned (when they are included)
     * @param limitOneTimeUseCodes maximum number of related oneTimeUseCodes returned (when they are included)
     * @param limitPrices maximum number of related prices returned (when they are included)
     */
    public subscriptionOfferCodesGetInstance(id: string, fieldsSubscriptionOfferCodes?: Array<'active' | 'customCodes' | 'customerEligibilities' | 'duration' | 'name' | 'numberOfPeriods' | 'offerEligibility' | 'offerMode' | 'oneTimeUseCodes' | 'prices' | 'subscription' | 'totalNumberOfCodes'>, include?: Array<'customCodes' | 'oneTimeUseCodes' | 'prices' | 'subscription'>, fieldsSubscriptionOfferCodeCustomCodes?: Array<'active' | 'createdDate' | 'customCode' | 'expirationDate' | 'numberOfCodes' | 'offerCode'>, fieldsSubscriptionOfferCodeOneTimeUseCodes?: Array<'active' | 'createdDate' | 'expirationDate' | 'numberOfCodes' | 'offerCode' | 'values'>, fieldsSubscriptionOfferCodePrices?: Array<'subscriptionPricePoint' | 'territory'>, limitCustomCodes?: number, limitOneTimeUseCodes?: number, limitPrices?: number, _options?: Configuration): Promise<SubscriptionOfferCodeResponse> {
        const result = this.api.subscriptionOfferCodesGetInstance(id, fieldsSubscriptionOfferCodes, include, fieldsSubscriptionOfferCodeCustomCodes, fieldsSubscriptionOfferCodeOneTimeUseCodes, fieldsSubscriptionOfferCodePrices, limitCustomCodes, limitOneTimeUseCodes, limitPrices, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsSubscriptionOfferCodes the fields to include for returned resources of type subscriptionOfferCodes
     * @param fieldsSubscriptionOfferCodeOneTimeUseCodes the fields to include for returned resources of type subscriptionOfferCodeOneTimeUseCodes
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public subscriptionOfferCodesOneTimeUseCodesGetToManyRelatedWithHttpInfo(id: string, fieldsSubscriptionOfferCodes?: Array<'active' | 'customCodes' | 'customerEligibilities' | 'duration' | 'name' | 'numberOfPeriods' | 'offerEligibility' | 'offerMode' | 'oneTimeUseCodes' | 'prices' | 'subscription' | 'totalNumberOfCodes'>, fieldsSubscriptionOfferCodeOneTimeUseCodes?: Array<'active' | 'createdDate' | 'expirationDate' | 'numberOfCodes' | 'offerCode' | 'values'>, limit?: number, include?: Array<'offerCode'>, _options?: Configuration): Promise<HttpInfo<SubscriptionOfferCodeOneTimeUseCodesResponse>> {
        const result = this.api.subscriptionOfferCodesOneTimeUseCodesGetToManyRelatedWithHttpInfo(id, fieldsSubscriptionOfferCodes, fieldsSubscriptionOfferCodeOneTimeUseCodes, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsSubscriptionOfferCodes the fields to include for returned resources of type subscriptionOfferCodes
     * @param fieldsSubscriptionOfferCodeOneTimeUseCodes the fields to include for returned resources of type subscriptionOfferCodeOneTimeUseCodes
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public subscriptionOfferCodesOneTimeUseCodesGetToManyRelated(id: string, fieldsSubscriptionOfferCodes?: Array<'active' | 'customCodes' | 'customerEligibilities' | 'duration' | 'name' | 'numberOfPeriods' | 'offerEligibility' | 'offerMode' | 'oneTimeUseCodes' | 'prices' | 'subscription' | 'totalNumberOfCodes'>, fieldsSubscriptionOfferCodeOneTimeUseCodes?: Array<'active' | 'createdDate' | 'expirationDate' | 'numberOfCodes' | 'offerCode' | 'values'>, limit?: number, include?: Array<'offerCode'>, _options?: Configuration): Promise<SubscriptionOfferCodeOneTimeUseCodesResponse> {
        const result = this.api.subscriptionOfferCodesOneTimeUseCodesGetToManyRelated(id, fieldsSubscriptionOfferCodes, fieldsSubscriptionOfferCodeOneTimeUseCodes, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterTerritory filter by id(s) of related \&#39;territory\&#39;
     * @param fieldsSubscriptionPricePoints the fields to include for returned resources of type subscriptionPricePoints
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param fieldsSubscriptionOfferCodePrices the fields to include for returned resources of type subscriptionOfferCodePrices
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public subscriptionOfferCodesPricesGetToManyRelatedWithHttpInfo(id: string, filterTerritory?: Array<string>, fieldsSubscriptionPricePoints?: Array<'customerPrice' | 'equalizations' | 'proceeds' | 'proceedsYear2' | 'subscription' | 'territory'>, fieldsTerritories?: Array<'currency'>, fieldsSubscriptionOfferCodePrices?: Array<'subscriptionPricePoint' | 'territory'>, limit?: number, include?: Array<'subscriptionPricePoint' | 'territory'>, _options?: Configuration): Promise<HttpInfo<SubscriptionOfferCodePricesResponse>> {
        const result = this.api.subscriptionOfferCodesPricesGetToManyRelatedWithHttpInfo(id, filterTerritory, fieldsSubscriptionPricePoints, fieldsTerritories, fieldsSubscriptionOfferCodePrices, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterTerritory filter by id(s) of related \&#39;territory\&#39;
     * @param fieldsSubscriptionPricePoints the fields to include for returned resources of type subscriptionPricePoints
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param fieldsSubscriptionOfferCodePrices the fields to include for returned resources of type subscriptionOfferCodePrices
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public subscriptionOfferCodesPricesGetToManyRelated(id: string, filterTerritory?: Array<string>, fieldsSubscriptionPricePoints?: Array<'customerPrice' | 'equalizations' | 'proceeds' | 'proceedsYear2' | 'subscription' | 'territory'>, fieldsTerritories?: Array<'currency'>, fieldsSubscriptionOfferCodePrices?: Array<'subscriptionPricePoint' | 'territory'>, limit?: number, include?: Array<'subscriptionPricePoint' | 'territory'>, _options?: Configuration): Promise<SubscriptionOfferCodePricesResponse> {
        const result = this.api.subscriptionOfferCodesPricesGetToManyRelated(id, filterTerritory, fieldsSubscriptionPricePoints, fieldsTerritories, fieldsSubscriptionOfferCodePrices, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param subscriptionOfferCodeUpdateRequest SubscriptionOfferCode representation
     */
    public subscriptionOfferCodesUpdateInstanceWithHttpInfo(id: string, subscriptionOfferCodeUpdateRequest: SubscriptionOfferCodeUpdateRequest, _options?: Configuration): Promise<HttpInfo<SubscriptionOfferCodeResponse>> {
        const result = this.api.subscriptionOfferCodesUpdateInstanceWithHttpInfo(id, subscriptionOfferCodeUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param subscriptionOfferCodeUpdateRequest SubscriptionOfferCode representation
     */
    public subscriptionOfferCodesUpdateInstance(id: string, subscriptionOfferCodeUpdateRequest: SubscriptionOfferCodeUpdateRequest, _options?: Configuration): Promise<SubscriptionOfferCodeResponse> {
        const result = this.api.subscriptionOfferCodesUpdateInstance(id, subscriptionOfferCodeUpdateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableSubscriptionPricePointsApi } from './ObservableAPI.ts';

import { SubscriptionPricePointsApiRequestFactory, SubscriptionPricePointsApiResponseProcessor} from "../apis/SubscriptionPricePointsApi.ts";
export class PromiseSubscriptionPricePointsApi {
    private api: ObservableSubscriptionPricePointsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: SubscriptionPricePointsApiRequestFactory,
        responseProcessor?: SubscriptionPricePointsApiResponseProcessor
    ) {
        this.api = new ObservableSubscriptionPricePointsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param id the id of the requested resource
     * @param filterSubscription filter by id(s) of related \&#39;subscription\&#39;
     * @param filterTerritory filter by id(s) of related \&#39;territory\&#39;
     * @param fieldsSubscriptionPricePoints the fields to include for returned resources of type subscriptionPricePoints
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public subscriptionPricePointsEqualizationsGetToManyRelatedWithHttpInfo(id: string, filterSubscription?: Array<string>, filterTerritory?: Array<string>, fieldsSubscriptionPricePoints?: Array<'customerPrice' | 'equalizations' | 'proceeds' | 'proceedsYear2' | 'subscription' | 'territory'>, fieldsTerritories?: Array<'currency'>, limit?: number, include?: Array<'territory'>, _options?: Configuration): Promise<HttpInfo<SubscriptionPricePointsResponse>> {
        const result = this.api.subscriptionPricePointsEqualizationsGetToManyRelatedWithHttpInfo(id, filterSubscription, filterTerritory, fieldsSubscriptionPricePoints, fieldsTerritories, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterSubscription filter by id(s) of related \&#39;subscription\&#39;
     * @param filterTerritory filter by id(s) of related \&#39;territory\&#39;
     * @param fieldsSubscriptionPricePoints the fields to include for returned resources of type subscriptionPricePoints
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public subscriptionPricePointsEqualizationsGetToManyRelated(id: string, filterSubscription?: Array<string>, filterTerritory?: Array<string>, fieldsSubscriptionPricePoints?: Array<'customerPrice' | 'equalizations' | 'proceeds' | 'proceedsYear2' | 'subscription' | 'territory'>, fieldsTerritories?: Array<'currency'>, limit?: number, include?: Array<'territory'>, _options?: Configuration): Promise<SubscriptionPricePointsResponse> {
        const result = this.api.subscriptionPricePointsEqualizationsGetToManyRelated(id, filterSubscription, filterTerritory, fieldsSubscriptionPricePoints, fieldsTerritories, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsSubscriptionPricePoints the fields to include for returned resources of type subscriptionPricePoints
     * @param include comma-separated list of relationships to include
     */
    public subscriptionPricePointsGetInstanceWithHttpInfo(id: string, fieldsSubscriptionPricePoints?: Array<'customerPrice' | 'equalizations' | 'proceeds' | 'proceedsYear2' | 'subscription' | 'territory'>, include?: Array<'territory'>, _options?: Configuration): Promise<HttpInfo<SubscriptionPricePointResponse>> {
        const result = this.api.subscriptionPricePointsGetInstanceWithHttpInfo(id, fieldsSubscriptionPricePoints, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsSubscriptionPricePoints the fields to include for returned resources of type subscriptionPricePoints
     * @param include comma-separated list of relationships to include
     */
    public subscriptionPricePointsGetInstance(id: string, fieldsSubscriptionPricePoints?: Array<'customerPrice' | 'equalizations' | 'proceeds' | 'proceedsYear2' | 'subscription' | 'territory'>, include?: Array<'territory'>, _options?: Configuration): Promise<SubscriptionPricePointResponse> {
        const result = this.api.subscriptionPricePointsGetInstance(id, fieldsSubscriptionPricePoints, include, _options);
        return result.toPromise();
    }


}



import { ObservableSubscriptionPricesApi } from './ObservableAPI.ts';

import { SubscriptionPricesApiRequestFactory, SubscriptionPricesApiResponseProcessor} from "../apis/SubscriptionPricesApi.ts";
export class PromiseSubscriptionPricesApi {
    private api: ObservableSubscriptionPricesApi

    public constructor(
        configuration: Configuration,
        requestFactory?: SubscriptionPricesApiRequestFactory,
        responseProcessor?: SubscriptionPricesApiResponseProcessor
    ) {
        this.api = new ObservableSubscriptionPricesApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param subscriptionPriceCreateRequest SubscriptionPrice representation
     */
    public subscriptionPricesCreateInstanceWithHttpInfo(subscriptionPriceCreateRequest: SubscriptionPriceCreateRequest, _options?: Configuration): Promise<HttpInfo<SubscriptionPriceResponse>> {
        const result = this.api.subscriptionPricesCreateInstanceWithHttpInfo(subscriptionPriceCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param subscriptionPriceCreateRequest SubscriptionPrice representation
     */
    public subscriptionPricesCreateInstance(subscriptionPriceCreateRequest: SubscriptionPriceCreateRequest, _options?: Configuration): Promise<SubscriptionPriceResponse> {
        const result = this.api.subscriptionPricesCreateInstance(subscriptionPriceCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public subscriptionPricesDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.subscriptionPricesDeleteInstanceWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public subscriptionPricesDeleteInstance(id: string, _options?: Configuration): Promise<void> {
        const result = this.api.subscriptionPricesDeleteInstance(id, _options);
        return result.toPromise();
    }


}



import { ObservableSubscriptionPromotionalOffersApi } from './ObservableAPI.ts';

import { SubscriptionPromotionalOffersApiRequestFactory, SubscriptionPromotionalOffersApiResponseProcessor} from "../apis/SubscriptionPromotionalOffersApi.ts";
export class PromiseSubscriptionPromotionalOffersApi {
    private api: ObservableSubscriptionPromotionalOffersApi

    public constructor(
        configuration: Configuration,
        requestFactory?: SubscriptionPromotionalOffersApiRequestFactory,
        responseProcessor?: SubscriptionPromotionalOffersApiResponseProcessor
    ) {
        this.api = new ObservableSubscriptionPromotionalOffersApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param subscriptionPromotionalOfferCreateRequest SubscriptionPromotionalOffer representation
     */
    public subscriptionPromotionalOffersCreateInstanceWithHttpInfo(subscriptionPromotionalOfferCreateRequest: SubscriptionPromotionalOfferCreateRequest, _options?: Configuration): Promise<HttpInfo<SubscriptionPromotionalOfferResponse>> {
        const result = this.api.subscriptionPromotionalOffersCreateInstanceWithHttpInfo(subscriptionPromotionalOfferCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param subscriptionPromotionalOfferCreateRequest SubscriptionPromotionalOffer representation
     */
    public subscriptionPromotionalOffersCreateInstance(subscriptionPromotionalOfferCreateRequest: SubscriptionPromotionalOfferCreateRequest, _options?: Configuration): Promise<SubscriptionPromotionalOfferResponse> {
        const result = this.api.subscriptionPromotionalOffersCreateInstance(subscriptionPromotionalOfferCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public subscriptionPromotionalOffersDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.subscriptionPromotionalOffersDeleteInstanceWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public subscriptionPromotionalOffersDeleteInstance(id: string, _options?: Configuration): Promise<void> {
        const result = this.api.subscriptionPromotionalOffersDeleteInstance(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsSubscriptionPromotionalOffers the fields to include for returned resources of type subscriptionPromotionalOffers
     * @param include comma-separated list of relationships to include
     * @param fieldsSubscriptionPromotionalOfferPrices the fields to include for returned resources of type subscriptionPromotionalOfferPrices
     * @param limitPrices maximum number of related prices returned (when they are included)
     */
    public subscriptionPromotionalOffersGetInstanceWithHttpInfo(id: string, fieldsSubscriptionPromotionalOffers?: Array<'duration' | 'name' | 'numberOfPeriods' | 'offerCode' | 'offerMode' | 'prices' | 'subscription'>, include?: Array<'prices' | 'subscription'>, fieldsSubscriptionPromotionalOfferPrices?: Array<'subscriptionPricePoint' | 'territory'>, limitPrices?: number, _options?: Configuration): Promise<HttpInfo<SubscriptionPromotionalOfferResponse>> {
        const result = this.api.subscriptionPromotionalOffersGetInstanceWithHttpInfo(id, fieldsSubscriptionPromotionalOffers, include, fieldsSubscriptionPromotionalOfferPrices, limitPrices, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsSubscriptionPromotionalOffers the fields to include for returned resources of type subscriptionPromotionalOffers
     * @param include comma-separated list of relationships to include
     * @param fieldsSubscriptionPromotionalOfferPrices the fields to include for returned resources of type subscriptionPromotionalOfferPrices
     * @param limitPrices maximum number of related prices returned (when they are included)
     */
    public subscriptionPromotionalOffersGetInstance(id: string, fieldsSubscriptionPromotionalOffers?: Array<'duration' | 'name' | 'numberOfPeriods' | 'offerCode' | 'offerMode' | 'prices' | 'subscription'>, include?: Array<'prices' | 'subscription'>, fieldsSubscriptionPromotionalOfferPrices?: Array<'subscriptionPricePoint' | 'territory'>, limitPrices?: number, _options?: Configuration): Promise<SubscriptionPromotionalOfferResponse> {
        const result = this.api.subscriptionPromotionalOffersGetInstance(id, fieldsSubscriptionPromotionalOffers, include, fieldsSubscriptionPromotionalOfferPrices, limitPrices, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterTerritory filter by id(s) of related \&#39;territory\&#39;
     * @param fieldsSubscriptionPricePoints the fields to include for returned resources of type subscriptionPricePoints
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param fieldsSubscriptionPromotionalOfferPrices the fields to include for returned resources of type subscriptionPromotionalOfferPrices
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public subscriptionPromotionalOffersPricesGetToManyRelatedWithHttpInfo(id: string, filterTerritory?: Array<string>, fieldsSubscriptionPricePoints?: Array<'customerPrice' | 'equalizations' | 'proceeds' | 'proceedsYear2' | 'subscription' | 'territory'>, fieldsTerritories?: Array<'currency'>, fieldsSubscriptionPromotionalOfferPrices?: Array<'subscriptionPricePoint' | 'territory'>, limit?: number, include?: Array<'subscriptionPricePoint' | 'territory'>, _options?: Configuration): Promise<HttpInfo<SubscriptionPromotionalOfferPricesResponse>> {
        const result = this.api.subscriptionPromotionalOffersPricesGetToManyRelatedWithHttpInfo(id, filterTerritory, fieldsSubscriptionPricePoints, fieldsTerritories, fieldsSubscriptionPromotionalOfferPrices, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterTerritory filter by id(s) of related \&#39;territory\&#39;
     * @param fieldsSubscriptionPricePoints the fields to include for returned resources of type subscriptionPricePoints
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param fieldsSubscriptionPromotionalOfferPrices the fields to include for returned resources of type subscriptionPromotionalOfferPrices
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public subscriptionPromotionalOffersPricesGetToManyRelated(id: string, filterTerritory?: Array<string>, fieldsSubscriptionPricePoints?: Array<'customerPrice' | 'equalizations' | 'proceeds' | 'proceedsYear2' | 'subscription' | 'territory'>, fieldsTerritories?: Array<'currency'>, fieldsSubscriptionPromotionalOfferPrices?: Array<'subscriptionPricePoint' | 'territory'>, limit?: number, include?: Array<'subscriptionPricePoint' | 'territory'>, _options?: Configuration): Promise<SubscriptionPromotionalOfferPricesResponse> {
        const result = this.api.subscriptionPromotionalOffersPricesGetToManyRelated(id, filterTerritory, fieldsSubscriptionPricePoints, fieldsTerritories, fieldsSubscriptionPromotionalOfferPrices, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param subscriptionPromotionalOfferUpdateRequest SubscriptionPromotionalOffer representation
     */
    public subscriptionPromotionalOffersUpdateInstanceWithHttpInfo(id: string, subscriptionPromotionalOfferUpdateRequest: SubscriptionPromotionalOfferUpdateRequest, _options?: Configuration): Promise<HttpInfo<SubscriptionPromotionalOfferResponse>> {
        const result = this.api.subscriptionPromotionalOffersUpdateInstanceWithHttpInfo(id, subscriptionPromotionalOfferUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param subscriptionPromotionalOfferUpdateRequest SubscriptionPromotionalOffer representation
     */
    public subscriptionPromotionalOffersUpdateInstance(id: string, subscriptionPromotionalOfferUpdateRequest: SubscriptionPromotionalOfferUpdateRequest, _options?: Configuration): Promise<SubscriptionPromotionalOfferResponse> {
        const result = this.api.subscriptionPromotionalOffersUpdateInstance(id, subscriptionPromotionalOfferUpdateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableSubscriptionSubmissionsApi } from './ObservableAPI.ts';

import { SubscriptionSubmissionsApiRequestFactory, SubscriptionSubmissionsApiResponseProcessor} from "../apis/SubscriptionSubmissionsApi.ts";
export class PromiseSubscriptionSubmissionsApi {
    private api: ObservableSubscriptionSubmissionsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: SubscriptionSubmissionsApiRequestFactory,
        responseProcessor?: SubscriptionSubmissionsApiResponseProcessor
    ) {
        this.api = new ObservableSubscriptionSubmissionsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param subscriptionSubmissionCreateRequest SubscriptionSubmission representation
     */
    public subscriptionSubmissionsCreateInstanceWithHttpInfo(subscriptionSubmissionCreateRequest: SubscriptionSubmissionCreateRequest, _options?: Configuration): Promise<HttpInfo<SubscriptionSubmissionResponse>> {
        const result = this.api.subscriptionSubmissionsCreateInstanceWithHttpInfo(subscriptionSubmissionCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param subscriptionSubmissionCreateRequest SubscriptionSubmission representation
     */
    public subscriptionSubmissionsCreateInstance(subscriptionSubmissionCreateRequest: SubscriptionSubmissionCreateRequest, _options?: Configuration): Promise<SubscriptionSubmissionResponse> {
        const result = this.api.subscriptionSubmissionsCreateInstance(subscriptionSubmissionCreateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableSubscriptionsApi } from './ObservableAPI.ts';

import { SubscriptionsApiRequestFactory, SubscriptionsApiResponseProcessor} from "../apis/SubscriptionsApi.ts";
export class PromiseSubscriptionsApi {
    private api: ObservableSubscriptionsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: SubscriptionsApiRequestFactory,
        responseProcessor?: SubscriptionsApiResponseProcessor
    ) {
        this.api = new ObservableSubscriptionsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsSubscriptionAppStoreReviewScreenshots the fields to include for returned resources of type subscriptionAppStoreReviewScreenshots
     * @param fieldsSubscriptions the fields to include for returned resources of type subscriptions
     * @param include comma-separated list of relationships to include
     */
    public subscriptionsAppStoreReviewScreenshotGetToOneRelatedWithHttpInfo(id: string, fieldsSubscriptionAppStoreReviewScreenshots?: Array<'assetDeliveryState' | 'assetToken' | 'assetType' | 'fileName' | 'fileSize' | 'imageAsset' | 'sourceFileChecksum' | 'subscription' | 'uploadOperations' | 'uploaded'>, fieldsSubscriptions?: Array<'appStoreReviewScreenshot' | 'familySharable' | 'group' | 'groupLevel' | 'introductoryOffers' | 'name' | 'offerCodes' | 'pricePoints' | 'prices' | 'productId' | 'promotedPurchase' | 'promotionalOffers' | 'reviewNote' | 'state' | 'subscriptionAvailability' | 'subscriptionLocalizations' | 'subscriptionPeriod'>, include?: Array<'subscription'>, _options?: Configuration): Promise<HttpInfo<SubscriptionAppStoreReviewScreenshotResponse>> {
        const result = this.api.subscriptionsAppStoreReviewScreenshotGetToOneRelatedWithHttpInfo(id, fieldsSubscriptionAppStoreReviewScreenshots, fieldsSubscriptions, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsSubscriptionAppStoreReviewScreenshots the fields to include for returned resources of type subscriptionAppStoreReviewScreenshots
     * @param fieldsSubscriptions the fields to include for returned resources of type subscriptions
     * @param include comma-separated list of relationships to include
     */
    public subscriptionsAppStoreReviewScreenshotGetToOneRelated(id: string, fieldsSubscriptionAppStoreReviewScreenshots?: Array<'assetDeliveryState' | 'assetToken' | 'assetType' | 'fileName' | 'fileSize' | 'imageAsset' | 'sourceFileChecksum' | 'subscription' | 'uploadOperations' | 'uploaded'>, fieldsSubscriptions?: Array<'appStoreReviewScreenshot' | 'familySharable' | 'group' | 'groupLevel' | 'introductoryOffers' | 'name' | 'offerCodes' | 'pricePoints' | 'prices' | 'productId' | 'promotedPurchase' | 'promotionalOffers' | 'reviewNote' | 'state' | 'subscriptionAvailability' | 'subscriptionLocalizations' | 'subscriptionPeriod'>, include?: Array<'subscription'>, _options?: Configuration): Promise<SubscriptionAppStoreReviewScreenshotResponse> {
        const result = this.api.subscriptionsAppStoreReviewScreenshotGetToOneRelated(id, fieldsSubscriptionAppStoreReviewScreenshots, fieldsSubscriptions, include, _options);
        return result.toPromise();
    }

    /**
     * @param subscriptionCreateRequest Subscription representation
     */
    public subscriptionsCreateInstanceWithHttpInfo(subscriptionCreateRequest: SubscriptionCreateRequest, _options?: Configuration): Promise<HttpInfo<SubscriptionResponse>> {
        const result = this.api.subscriptionsCreateInstanceWithHttpInfo(subscriptionCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param subscriptionCreateRequest Subscription representation
     */
    public subscriptionsCreateInstance(subscriptionCreateRequest: SubscriptionCreateRequest, _options?: Configuration): Promise<SubscriptionResponse> {
        const result = this.api.subscriptionsCreateInstance(subscriptionCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public subscriptionsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.subscriptionsDeleteInstanceWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public subscriptionsDeleteInstance(id: string, _options?: Configuration): Promise<void> {
        const result = this.api.subscriptionsDeleteInstance(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsSubscriptions the fields to include for returned resources of type subscriptions
     * @param include comma-separated list of relationships to include
     * @param fieldsPromotedPurchases the fields to include for returned resources of type promotedPurchases
     * @param fieldsSubscriptionPricePoints the fields to include for returned resources of type subscriptionPricePoints
     * @param fieldsSubscriptionPromotionalOffers the fields to include for returned resources of type subscriptionPromotionalOffers
     * @param fieldsSubscriptionOfferCodes the fields to include for returned resources of type subscriptionOfferCodes
     * @param fieldsSubscriptionAppStoreReviewScreenshots the fields to include for returned resources of type subscriptionAppStoreReviewScreenshots
     * @param fieldsSubscriptionAvailabilities the fields to include for returned resources of type subscriptionAvailabilities
     * @param fieldsSubscriptionPrices the fields to include for returned resources of type subscriptionPrices
     * @param fieldsSubscriptionIntroductoryOffers the fields to include for returned resources of type subscriptionIntroductoryOffers
     * @param fieldsSubscriptionLocalizations the fields to include for returned resources of type subscriptionLocalizations
     * @param limitIntroductoryOffers maximum number of related introductoryOffers returned (when they are included)
     * @param limitOfferCodes maximum number of related offerCodes returned (when they are included)
     * @param limitPrices maximum number of related prices returned (when they are included)
     * @param limitPromotionalOffers maximum number of related promotionalOffers returned (when they are included)
     * @param limitSubscriptionLocalizations maximum number of related subscriptionLocalizations returned (when they are included)
     */
    public subscriptionsGetInstanceWithHttpInfo(id: string, fieldsSubscriptions?: Array<'appStoreReviewScreenshot' | 'familySharable' | 'group' | 'groupLevel' | 'introductoryOffers' | 'name' | 'offerCodes' | 'pricePoints' | 'prices' | 'productId' | 'promotedPurchase' | 'promotionalOffers' | 'reviewNote' | 'state' | 'subscriptionAvailability' | 'subscriptionLocalizations' | 'subscriptionPeriod'>, include?: Array<'appStoreReviewScreenshot' | 'group' | 'introductoryOffers' | 'offerCodes' | 'prices' | 'promotedPurchase' | 'promotionalOffers' | 'subscriptionAvailability' | 'subscriptionLocalizations'>, fieldsPromotedPurchases?: Array<'app' | 'enabled' | 'inAppPurchaseV2' | 'promotionImages' | 'state' | 'subscription' | 'visibleForAllUsers'>, fieldsSubscriptionPricePoints?: Array<'customerPrice' | 'equalizations' | 'proceeds' | 'proceedsYear2' | 'subscription' | 'territory'>, fieldsSubscriptionPromotionalOffers?: Array<'duration' | 'name' | 'numberOfPeriods' | 'offerCode' | 'offerMode' | 'prices' | 'subscription'>, fieldsSubscriptionOfferCodes?: Array<'active' | 'customCodes' | 'customerEligibilities' | 'duration' | 'name' | 'numberOfPeriods' | 'offerEligibility' | 'offerMode' | 'oneTimeUseCodes' | 'prices' | 'subscription' | 'totalNumberOfCodes'>, fieldsSubscriptionAppStoreReviewScreenshots?: Array<'assetDeliveryState' | 'assetToken' | 'assetType' | 'fileName' | 'fileSize' | 'imageAsset' | 'sourceFileChecksum' | 'subscription' | 'uploadOperations' | 'uploaded'>, fieldsSubscriptionAvailabilities?: Array<'availableInNewTerritories' | 'availableTerritories' | 'subscription'>, fieldsSubscriptionPrices?: Array<'preserveCurrentPrice' | 'preserved' | 'startDate' | 'subscription' | 'subscriptionPricePoint' | 'territory'>, fieldsSubscriptionIntroductoryOffers?: Array<'duration' | 'endDate' | 'numberOfPeriods' | 'offerMode' | 'startDate' | 'subscription' | 'subscriptionPricePoint' | 'territory'>, fieldsSubscriptionLocalizations?: Array<'description' | 'locale' | 'name' | 'state' | 'subscription'>, limitIntroductoryOffers?: number, limitOfferCodes?: number, limitPrices?: number, limitPromotionalOffers?: number, limitSubscriptionLocalizations?: number, _options?: Configuration): Promise<HttpInfo<SubscriptionResponse>> {
        const result = this.api.subscriptionsGetInstanceWithHttpInfo(id, fieldsSubscriptions, include, fieldsPromotedPurchases, fieldsSubscriptionPricePoints, fieldsSubscriptionPromotionalOffers, fieldsSubscriptionOfferCodes, fieldsSubscriptionAppStoreReviewScreenshots, fieldsSubscriptionAvailabilities, fieldsSubscriptionPrices, fieldsSubscriptionIntroductoryOffers, fieldsSubscriptionLocalizations, limitIntroductoryOffers, limitOfferCodes, limitPrices, limitPromotionalOffers, limitSubscriptionLocalizations, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsSubscriptions the fields to include for returned resources of type subscriptions
     * @param include comma-separated list of relationships to include
     * @param fieldsPromotedPurchases the fields to include for returned resources of type promotedPurchases
     * @param fieldsSubscriptionPricePoints the fields to include for returned resources of type subscriptionPricePoints
     * @param fieldsSubscriptionPromotionalOffers the fields to include for returned resources of type subscriptionPromotionalOffers
     * @param fieldsSubscriptionOfferCodes the fields to include for returned resources of type subscriptionOfferCodes
     * @param fieldsSubscriptionAppStoreReviewScreenshots the fields to include for returned resources of type subscriptionAppStoreReviewScreenshots
     * @param fieldsSubscriptionAvailabilities the fields to include for returned resources of type subscriptionAvailabilities
     * @param fieldsSubscriptionPrices the fields to include for returned resources of type subscriptionPrices
     * @param fieldsSubscriptionIntroductoryOffers the fields to include for returned resources of type subscriptionIntroductoryOffers
     * @param fieldsSubscriptionLocalizations the fields to include for returned resources of type subscriptionLocalizations
     * @param limitIntroductoryOffers maximum number of related introductoryOffers returned (when they are included)
     * @param limitOfferCodes maximum number of related offerCodes returned (when they are included)
     * @param limitPrices maximum number of related prices returned (when they are included)
     * @param limitPromotionalOffers maximum number of related promotionalOffers returned (when they are included)
     * @param limitSubscriptionLocalizations maximum number of related subscriptionLocalizations returned (when they are included)
     */
    public subscriptionsGetInstance(id: string, fieldsSubscriptions?: Array<'appStoreReviewScreenshot' | 'familySharable' | 'group' | 'groupLevel' | 'introductoryOffers' | 'name' | 'offerCodes' | 'pricePoints' | 'prices' | 'productId' | 'promotedPurchase' | 'promotionalOffers' | 'reviewNote' | 'state' | 'subscriptionAvailability' | 'subscriptionLocalizations' | 'subscriptionPeriod'>, include?: Array<'appStoreReviewScreenshot' | 'group' | 'introductoryOffers' | 'offerCodes' | 'prices' | 'promotedPurchase' | 'promotionalOffers' | 'subscriptionAvailability' | 'subscriptionLocalizations'>, fieldsPromotedPurchases?: Array<'app' | 'enabled' | 'inAppPurchaseV2' | 'promotionImages' | 'state' | 'subscription' | 'visibleForAllUsers'>, fieldsSubscriptionPricePoints?: Array<'customerPrice' | 'equalizations' | 'proceeds' | 'proceedsYear2' | 'subscription' | 'territory'>, fieldsSubscriptionPromotionalOffers?: Array<'duration' | 'name' | 'numberOfPeriods' | 'offerCode' | 'offerMode' | 'prices' | 'subscription'>, fieldsSubscriptionOfferCodes?: Array<'active' | 'customCodes' | 'customerEligibilities' | 'duration' | 'name' | 'numberOfPeriods' | 'offerEligibility' | 'offerMode' | 'oneTimeUseCodes' | 'prices' | 'subscription' | 'totalNumberOfCodes'>, fieldsSubscriptionAppStoreReviewScreenshots?: Array<'assetDeliveryState' | 'assetToken' | 'assetType' | 'fileName' | 'fileSize' | 'imageAsset' | 'sourceFileChecksum' | 'subscription' | 'uploadOperations' | 'uploaded'>, fieldsSubscriptionAvailabilities?: Array<'availableInNewTerritories' | 'availableTerritories' | 'subscription'>, fieldsSubscriptionPrices?: Array<'preserveCurrentPrice' | 'preserved' | 'startDate' | 'subscription' | 'subscriptionPricePoint' | 'territory'>, fieldsSubscriptionIntroductoryOffers?: Array<'duration' | 'endDate' | 'numberOfPeriods' | 'offerMode' | 'startDate' | 'subscription' | 'subscriptionPricePoint' | 'territory'>, fieldsSubscriptionLocalizations?: Array<'description' | 'locale' | 'name' | 'state' | 'subscription'>, limitIntroductoryOffers?: number, limitOfferCodes?: number, limitPrices?: number, limitPromotionalOffers?: number, limitSubscriptionLocalizations?: number, _options?: Configuration): Promise<SubscriptionResponse> {
        const result = this.api.subscriptionsGetInstance(id, fieldsSubscriptions, include, fieldsPromotedPurchases, fieldsSubscriptionPricePoints, fieldsSubscriptionPromotionalOffers, fieldsSubscriptionOfferCodes, fieldsSubscriptionAppStoreReviewScreenshots, fieldsSubscriptionAvailabilities, fieldsSubscriptionPrices, fieldsSubscriptionIntroductoryOffers, fieldsSubscriptionLocalizations, limitIntroductoryOffers, limitOfferCodes, limitPrices, limitPromotionalOffers, limitSubscriptionLocalizations, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param subscriptionIntroductoryOffersLinkagesRequest List of related linkages
     */
    public subscriptionsIntroductoryOffersDeleteToManyRelationshipWithHttpInfo(id: string, subscriptionIntroductoryOffersLinkagesRequest: SubscriptionIntroductoryOffersLinkagesRequest, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.subscriptionsIntroductoryOffersDeleteToManyRelationshipWithHttpInfo(id, subscriptionIntroductoryOffersLinkagesRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param subscriptionIntroductoryOffersLinkagesRequest List of related linkages
     */
    public subscriptionsIntroductoryOffersDeleteToManyRelationship(id: string, subscriptionIntroductoryOffersLinkagesRequest: SubscriptionIntroductoryOffersLinkagesRequest, _options?: Configuration): Promise<void> {
        const result = this.api.subscriptionsIntroductoryOffersDeleteToManyRelationship(id, subscriptionIntroductoryOffersLinkagesRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterTerritory filter by id(s) of related \&#39;territory\&#39;
     * @param fieldsSubscriptionPricePoints the fields to include for returned resources of type subscriptionPricePoints
     * @param fieldsSubscriptions the fields to include for returned resources of type subscriptions
     * @param fieldsSubscriptionIntroductoryOffers the fields to include for returned resources of type subscriptionIntroductoryOffers
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public subscriptionsIntroductoryOffersGetToManyRelatedWithHttpInfo(id: string, filterTerritory?: Array<string>, fieldsSubscriptionPricePoints?: Array<'customerPrice' | 'equalizations' | 'proceeds' | 'proceedsYear2' | 'subscription' | 'territory'>, fieldsSubscriptions?: Array<'appStoreReviewScreenshot' | 'familySharable' | 'group' | 'groupLevel' | 'introductoryOffers' | 'name' | 'offerCodes' | 'pricePoints' | 'prices' | 'productId' | 'promotedPurchase' | 'promotionalOffers' | 'reviewNote' | 'state' | 'subscriptionAvailability' | 'subscriptionLocalizations' | 'subscriptionPeriod'>, fieldsSubscriptionIntroductoryOffers?: Array<'duration' | 'endDate' | 'numberOfPeriods' | 'offerMode' | 'startDate' | 'subscription' | 'subscriptionPricePoint' | 'territory'>, fieldsTerritories?: Array<'currency'>, limit?: number, include?: Array<'subscription' | 'subscriptionPricePoint' | 'territory'>, _options?: Configuration): Promise<HttpInfo<SubscriptionIntroductoryOffersResponse>> {
        const result = this.api.subscriptionsIntroductoryOffersGetToManyRelatedWithHttpInfo(id, filterTerritory, fieldsSubscriptionPricePoints, fieldsSubscriptions, fieldsSubscriptionIntroductoryOffers, fieldsTerritories, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterTerritory filter by id(s) of related \&#39;territory\&#39;
     * @param fieldsSubscriptionPricePoints the fields to include for returned resources of type subscriptionPricePoints
     * @param fieldsSubscriptions the fields to include for returned resources of type subscriptions
     * @param fieldsSubscriptionIntroductoryOffers the fields to include for returned resources of type subscriptionIntroductoryOffers
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public subscriptionsIntroductoryOffersGetToManyRelated(id: string, filterTerritory?: Array<string>, fieldsSubscriptionPricePoints?: Array<'customerPrice' | 'equalizations' | 'proceeds' | 'proceedsYear2' | 'subscription' | 'territory'>, fieldsSubscriptions?: Array<'appStoreReviewScreenshot' | 'familySharable' | 'group' | 'groupLevel' | 'introductoryOffers' | 'name' | 'offerCodes' | 'pricePoints' | 'prices' | 'productId' | 'promotedPurchase' | 'promotionalOffers' | 'reviewNote' | 'state' | 'subscriptionAvailability' | 'subscriptionLocalizations' | 'subscriptionPeriod'>, fieldsSubscriptionIntroductoryOffers?: Array<'duration' | 'endDate' | 'numberOfPeriods' | 'offerMode' | 'startDate' | 'subscription' | 'subscriptionPricePoint' | 'territory'>, fieldsTerritories?: Array<'currency'>, limit?: number, include?: Array<'subscription' | 'subscriptionPricePoint' | 'territory'>, _options?: Configuration): Promise<SubscriptionIntroductoryOffersResponse> {
        const result = this.api.subscriptionsIntroductoryOffersGetToManyRelated(id, filterTerritory, fieldsSubscriptionPricePoints, fieldsSubscriptions, fieldsSubscriptionIntroductoryOffers, fieldsTerritories, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public subscriptionsIntroductoryOffersGetToManyRelationshipWithHttpInfo(id: string, limit?: number, _options?: Configuration): Promise<HttpInfo<SubscriptionIntroductoryOffersLinkagesResponse>> {
        const result = this.api.subscriptionsIntroductoryOffersGetToManyRelationshipWithHttpInfo(id, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public subscriptionsIntroductoryOffersGetToManyRelationship(id: string, limit?: number, _options?: Configuration): Promise<SubscriptionIntroductoryOffersLinkagesResponse> {
        const result = this.api.subscriptionsIntroductoryOffersGetToManyRelationship(id, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterTerritory filter by territory
     * @param fieldsSubscriptionOfferCodeCustomCodes the fields to include for returned resources of type subscriptionOfferCodeCustomCodes
     * @param fieldsSubscriptionOfferCodes the fields to include for returned resources of type subscriptionOfferCodes
     * @param fieldsSubscriptionOfferCodeOneTimeUseCodes the fields to include for returned resources of type subscriptionOfferCodeOneTimeUseCodes
     * @param fieldsSubscriptions the fields to include for returned resources of type subscriptions
     * @param fieldsSubscriptionOfferCodePrices the fields to include for returned resources of type subscriptionOfferCodePrices
     * @param limit maximum resources per page
     * @param limitOneTimeUseCodes maximum number of related oneTimeUseCodes returned (when they are included)
     * @param limitCustomCodes maximum number of related customCodes returned (when they are included)
     * @param limitPrices maximum number of related prices returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public subscriptionsOfferCodesGetToManyRelatedWithHttpInfo(id: string, filterTerritory?: Array<string>, fieldsSubscriptionOfferCodeCustomCodes?: Array<'active' | 'createdDate' | 'customCode' | 'expirationDate' | 'numberOfCodes' | 'offerCode'>, fieldsSubscriptionOfferCodes?: Array<'active' | 'customCodes' | 'customerEligibilities' | 'duration' | 'name' | 'numberOfPeriods' | 'offerEligibility' | 'offerMode' | 'oneTimeUseCodes' | 'prices' | 'subscription' | 'totalNumberOfCodes'>, fieldsSubscriptionOfferCodeOneTimeUseCodes?: Array<'active' | 'createdDate' | 'expirationDate' | 'numberOfCodes' | 'offerCode' | 'values'>, fieldsSubscriptions?: Array<'appStoreReviewScreenshot' | 'familySharable' | 'group' | 'groupLevel' | 'introductoryOffers' | 'name' | 'offerCodes' | 'pricePoints' | 'prices' | 'productId' | 'promotedPurchase' | 'promotionalOffers' | 'reviewNote' | 'state' | 'subscriptionAvailability' | 'subscriptionLocalizations' | 'subscriptionPeriod'>, fieldsSubscriptionOfferCodePrices?: Array<'subscriptionPricePoint' | 'territory'>, limit?: number, limitOneTimeUseCodes?: number, limitCustomCodes?: number, limitPrices?: number, include?: Array<'customCodes' | 'oneTimeUseCodes' | 'prices' | 'subscription'>, _options?: Configuration): Promise<HttpInfo<SubscriptionOfferCodesResponse>> {
        const result = this.api.subscriptionsOfferCodesGetToManyRelatedWithHttpInfo(id, filterTerritory, fieldsSubscriptionOfferCodeCustomCodes, fieldsSubscriptionOfferCodes, fieldsSubscriptionOfferCodeOneTimeUseCodes, fieldsSubscriptions, fieldsSubscriptionOfferCodePrices, limit, limitOneTimeUseCodes, limitCustomCodes, limitPrices, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterTerritory filter by territory
     * @param fieldsSubscriptionOfferCodeCustomCodes the fields to include for returned resources of type subscriptionOfferCodeCustomCodes
     * @param fieldsSubscriptionOfferCodes the fields to include for returned resources of type subscriptionOfferCodes
     * @param fieldsSubscriptionOfferCodeOneTimeUseCodes the fields to include for returned resources of type subscriptionOfferCodeOneTimeUseCodes
     * @param fieldsSubscriptions the fields to include for returned resources of type subscriptions
     * @param fieldsSubscriptionOfferCodePrices the fields to include for returned resources of type subscriptionOfferCodePrices
     * @param limit maximum resources per page
     * @param limitOneTimeUseCodes maximum number of related oneTimeUseCodes returned (when they are included)
     * @param limitCustomCodes maximum number of related customCodes returned (when they are included)
     * @param limitPrices maximum number of related prices returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public subscriptionsOfferCodesGetToManyRelated(id: string, filterTerritory?: Array<string>, fieldsSubscriptionOfferCodeCustomCodes?: Array<'active' | 'createdDate' | 'customCode' | 'expirationDate' | 'numberOfCodes' | 'offerCode'>, fieldsSubscriptionOfferCodes?: Array<'active' | 'customCodes' | 'customerEligibilities' | 'duration' | 'name' | 'numberOfPeriods' | 'offerEligibility' | 'offerMode' | 'oneTimeUseCodes' | 'prices' | 'subscription' | 'totalNumberOfCodes'>, fieldsSubscriptionOfferCodeOneTimeUseCodes?: Array<'active' | 'createdDate' | 'expirationDate' | 'numberOfCodes' | 'offerCode' | 'values'>, fieldsSubscriptions?: Array<'appStoreReviewScreenshot' | 'familySharable' | 'group' | 'groupLevel' | 'introductoryOffers' | 'name' | 'offerCodes' | 'pricePoints' | 'prices' | 'productId' | 'promotedPurchase' | 'promotionalOffers' | 'reviewNote' | 'state' | 'subscriptionAvailability' | 'subscriptionLocalizations' | 'subscriptionPeriod'>, fieldsSubscriptionOfferCodePrices?: Array<'subscriptionPricePoint' | 'territory'>, limit?: number, limitOneTimeUseCodes?: number, limitCustomCodes?: number, limitPrices?: number, include?: Array<'customCodes' | 'oneTimeUseCodes' | 'prices' | 'subscription'>, _options?: Configuration): Promise<SubscriptionOfferCodesResponse> {
        const result = this.api.subscriptionsOfferCodesGetToManyRelated(id, filterTerritory, fieldsSubscriptionOfferCodeCustomCodes, fieldsSubscriptionOfferCodes, fieldsSubscriptionOfferCodeOneTimeUseCodes, fieldsSubscriptions, fieldsSubscriptionOfferCodePrices, limit, limitOneTimeUseCodes, limitCustomCodes, limitPrices, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterTerritory filter by id(s) of related \&#39;territory\&#39;
     * @param fieldsSubscriptionPricePoints the fields to include for returned resources of type subscriptionPricePoints
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public subscriptionsPricePointsGetToManyRelatedWithHttpInfo(id: string, filterTerritory?: Array<string>, fieldsSubscriptionPricePoints?: Array<'customerPrice' | 'equalizations' | 'proceeds' | 'proceedsYear2' | 'subscription' | 'territory'>, fieldsTerritories?: Array<'currency'>, limit?: number, include?: Array<'territory'>, _options?: Configuration): Promise<HttpInfo<SubscriptionPricePointsResponse>> {
        const result = this.api.subscriptionsPricePointsGetToManyRelatedWithHttpInfo(id, filterTerritory, fieldsSubscriptionPricePoints, fieldsTerritories, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterTerritory filter by id(s) of related \&#39;territory\&#39;
     * @param fieldsSubscriptionPricePoints the fields to include for returned resources of type subscriptionPricePoints
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public subscriptionsPricePointsGetToManyRelated(id: string, filterTerritory?: Array<string>, fieldsSubscriptionPricePoints?: Array<'customerPrice' | 'equalizations' | 'proceeds' | 'proceedsYear2' | 'subscription' | 'territory'>, fieldsTerritories?: Array<'currency'>, limit?: number, include?: Array<'territory'>, _options?: Configuration): Promise<SubscriptionPricePointsResponse> {
        const result = this.api.subscriptionsPricePointsGetToManyRelated(id, filterTerritory, fieldsSubscriptionPricePoints, fieldsTerritories, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param subscriptionPricesLinkagesRequest List of related linkages
     */
    public subscriptionsPricesDeleteToManyRelationshipWithHttpInfo(id: string, subscriptionPricesLinkagesRequest: SubscriptionPricesLinkagesRequest, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.subscriptionsPricesDeleteToManyRelationshipWithHttpInfo(id, subscriptionPricesLinkagesRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param subscriptionPricesLinkagesRequest List of related linkages
     */
    public subscriptionsPricesDeleteToManyRelationship(id: string, subscriptionPricesLinkagesRequest: SubscriptionPricesLinkagesRequest, _options?: Configuration): Promise<void> {
        const result = this.api.subscriptionsPricesDeleteToManyRelationship(id, subscriptionPricesLinkagesRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterSubscriptionPricePoint filter by id(s) of related \&#39;subscriptionPricePoint\&#39;
     * @param filterTerritory filter by id(s) of related \&#39;territory\&#39;
     * @param fieldsSubscriptionPricePoints the fields to include for returned resources of type subscriptionPricePoints
     * @param fieldsSubscriptionPrices the fields to include for returned resources of type subscriptionPrices
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public subscriptionsPricesGetToManyRelatedWithHttpInfo(id: string, filterSubscriptionPricePoint?: Array<string>, filterTerritory?: Array<string>, fieldsSubscriptionPricePoints?: Array<'customerPrice' | 'equalizations' | 'proceeds' | 'proceedsYear2' | 'subscription' | 'territory'>, fieldsSubscriptionPrices?: Array<'preserveCurrentPrice' | 'preserved' | 'startDate' | 'subscription' | 'subscriptionPricePoint' | 'territory'>, fieldsTerritories?: Array<'currency'>, limit?: number, include?: Array<'subscriptionPricePoint' | 'territory'>, _options?: Configuration): Promise<HttpInfo<SubscriptionPricesResponse>> {
        const result = this.api.subscriptionsPricesGetToManyRelatedWithHttpInfo(id, filterSubscriptionPricePoint, filterTerritory, fieldsSubscriptionPricePoints, fieldsSubscriptionPrices, fieldsTerritories, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterSubscriptionPricePoint filter by id(s) of related \&#39;subscriptionPricePoint\&#39;
     * @param filterTerritory filter by id(s) of related \&#39;territory\&#39;
     * @param fieldsSubscriptionPricePoints the fields to include for returned resources of type subscriptionPricePoints
     * @param fieldsSubscriptionPrices the fields to include for returned resources of type subscriptionPrices
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public subscriptionsPricesGetToManyRelated(id: string, filterSubscriptionPricePoint?: Array<string>, filterTerritory?: Array<string>, fieldsSubscriptionPricePoints?: Array<'customerPrice' | 'equalizations' | 'proceeds' | 'proceedsYear2' | 'subscription' | 'territory'>, fieldsSubscriptionPrices?: Array<'preserveCurrentPrice' | 'preserved' | 'startDate' | 'subscription' | 'subscriptionPricePoint' | 'territory'>, fieldsTerritories?: Array<'currency'>, limit?: number, include?: Array<'subscriptionPricePoint' | 'territory'>, _options?: Configuration): Promise<SubscriptionPricesResponse> {
        const result = this.api.subscriptionsPricesGetToManyRelated(id, filterSubscriptionPricePoint, filterTerritory, fieldsSubscriptionPricePoints, fieldsSubscriptionPrices, fieldsTerritories, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public subscriptionsPricesGetToManyRelationshipWithHttpInfo(id: string, limit?: number, _options?: Configuration): Promise<HttpInfo<SubscriptionPricesLinkagesResponse>> {
        const result = this.api.subscriptionsPricesGetToManyRelationshipWithHttpInfo(id, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public subscriptionsPricesGetToManyRelationship(id: string, limit?: number, _options?: Configuration): Promise<SubscriptionPricesLinkagesResponse> {
        const result = this.api.subscriptionsPricesGetToManyRelationship(id, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsPromotedPurchases the fields to include for returned resources of type promotedPurchases
     * @param fieldsSubscriptions the fields to include for returned resources of type subscriptions
     * @param fieldsInAppPurchases the fields to include for returned resources of type inAppPurchases
     * @param fieldsPromotedPurchaseImages the fields to include for returned resources of type promotedPurchaseImages
     * @param limitPromotionImages maximum number of related promotionImages returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public subscriptionsPromotedPurchaseGetToOneRelatedWithHttpInfo(id: string, fieldsPromotedPurchases?: Array<'app' | 'enabled' | 'inAppPurchaseV2' | 'promotionImages' | 'state' | 'subscription' | 'visibleForAllUsers'>, fieldsSubscriptions?: Array<'appStoreReviewScreenshot' | 'familySharable' | 'group' | 'groupLevel' | 'introductoryOffers' | 'name' | 'offerCodes' | 'pricePoints' | 'prices' | 'productId' | 'promotedPurchase' | 'promotionalOffers' | 'reviewNote' | 'state' | 'subscriptionAvailability' | 'subscriptionLocalizations' | 'subscriptionPeriod'>, fieldsInAppPurchases?: Array<'app' | 'appStoreReviewScreenshot' | 'content' | 'contentHosting' | 'familySharable' | 'iapPriceSchedule' | 'inAppPurchaseAvailability' | 'inAppPurchaseLocalizations' | 'inAppPurchaseType' | 'name' | 'pricePoints' | 'productId' | 'promotedPurchase' | 'reviewNote' | 'state'>, fieldsPromotedPurchaseImages?: Array<'assetToken' | 'assetType' | 'fileName' | 'fileSize' | 'imageAsset' | 'promotedPurchase' | 'sourceFileChecksum' | 'state' | 'uploadOperations' | 'uploaded'>, limitPromotionImages?: number, include?: Array<'inAppPurchaseV2' | 'promotionImages' | 'subscription'>, _options?: Configuration): Promise<HttpInfo<PromotedPurchaseResponse>> {
        const result = this.api.subscriptionsPromotedPurchaseGetToOneRelatedWithHttpInfo(id, fieldsPromotedPurchases, fieldsSubscriptions, fieldsInAppPurchases, fieldsPromotedPurchaseImages, limitPromotionImages, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsPromotedPurchases the fields to include for returned resources of type promotedPurchases
     * @param fieldsSubscriptions the fields to include for returned resources of type subscriptions
     * @param fieldsInAppPurchases the fields to include for returned resources of type inAppPurchases
     * @param fieldsPromotedPurchaseImages the fields to include for returned resources of type promotedPurchaseImages
     * @param limitPromotionImages maximum number of related promotionImages returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public subscriptionsPromotedPurchaseGetToOneRelated(id: string, fieldsPromotedPurchases?: Array<'app' | 'enabled' | 'inAppPurchaseV2' | 'promotionImages' | 'state' | 'subscription' | 'visibleForAllUsers'>, fieldsSubscriptions?: Array<'appStoreReviewScreenshot' | 'familySharable' | 'group' | 'groupLevel' | 'introductoryOffers' | 'name' | 'offerCodes' | 'pricePoints' | 'prices' | 'productId' | 'promotedPurchase' | 'promotionalOffers' | 'reviewNote' | 'state' | 'subscriptionAvailability' | 'subscriptionLocalizations' | 'subscriptionPeriod'>, fieldsInAppPurchases?: Array<'app' | 'appStoreReviewScreenshot' | 'content' | 'contentHosting' | 'familySharable' | 'iapPriceSchedule' | 'inAppPurchaseAvailability' | 'inAppPurchaseLocalizations' | 'inAppPurchaseType' | 'name' | 'pricePoints' | 'productId' | 'promotedPurchase' | 'reviewNote' | 'state'>, fieldsPromotedPurchaseImages?: Array<'assetToken' | 'assetType' | 'fileName' | 'fileSize' | 'imageAsset' | 'promotedPurchase' | 'sourceFileChecksum' | 'state' | 'uploadOperations' | 'uploaded'>, limitPromotionImages?: number, include?: Array<'inAppPurchaseV2' | 'promotionImages' | 'subscription'>, _options?: Configuration): Promise<PromotedPurchaseResponse> {
        const result = this.api.subscriptionsPromotedPurchaseGetToOneRelated(id, fieldsPromotedPurchases, fieldsSubscriptions, fieldsInAppPurchases, fieldsPromotedPurchaseImages, limitPromotionImages, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterTerritory filter by territory
     * @param fieldsSubscriptionPromotionalOffers the fields to include for returned resources of type subscriptionPromotionalOffers
     * @param fieldsSubscriptions the fields to include for returned resources of type subscriptions
     * @param fieldsSubscriptionPromotionalOfferPrices the fields to include for returned resources of type subscriptionPromotionalOfferPrices
     * @param limit maximum resources per page
     * @param limitPrices maximum number of related prices returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public subscriptionsPromotionalOffersGetToManyRelatedWithHttpInfo(id: string, filterTerritory?: Array<string>, fieldsSubscriptionPromotionalOffers?: Array<'duration' | 'name' | 'numberOfPeriods' | 'offerCode' | 'offerMode' | 'prices' | 'subscription'>, fieldsSubscriptions?: Array<'appStoreReviewScreenshot' | 'familySharable' | 'group' | 'groupLevel' | 'introductoryOffers' | 'name' | 'offerCodes' | 'pricePoints' | 'prices' | 'productId' | 'promotedPurchase' | 'promotionalOffers' | 'reviewNote' | 'state' | 'subscriptionAvailability' | 'subscriptionLocalizations' | 'subscriptionPeriod'>, fieldsSubscriptionPromotionalOfferPrices?: Array<'subscriptionPricePoint' | 'territory'>, limit?: number, limitPrices?: number, include?: Array<'prices' | 'subscription'>, _options?: Configuration): Promise<HttpInfo<SubscriptionPromotionalOffersResponse>> {
        const result = this.api.subscriptionsPromotionalOffersGetToManyRelatedWithHttpInfo(id, filterTerritory, fieldsSubscriptionPromotionalOffers, fieldsSubscriptions, fieldsSubscriptionPromotionalOfferPrices, limit, limitPrices, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param filterTerritory filter by territory
     * @param fieldsSubscriptionPromotionalOffers the fields to include for returned resources of type subscriptionPromotionalOffers
     * @param fieldsSubscriptions the fields to include for returned resources of type subscriptions
     * @param fieldsSubscriptionPromotionalOfferPrices the fields to include for returned resources of type subscriptionPromotionalOfferPrices
     * @param limit maximum resources per page
     * @param limitPrices maximum number of related prices returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public subscriptionsPromotionalOffersGetToManyRelated(id: string, filterTerritory?: Array<string>, fieldsSubscriptionPromotionalOffers?: Array<'duration' | 'name' | 'numberOfPeriods' | 'offerCode' | 'offerMode' | 'prices' | 'subscription'>, fieldsSubscriptions?: Array<'appStoreReviewScreenshot' | 'familySharable' | 'group' | 'groupLevel' | 'introductoryOffers' | 'name' | 'offerCodes' | 'pricePoints' | 'prices' | 'productId' | 'promotedPurchase' | 'promotionalOffers' | 'reviewNote' | 'state' | 'subscriptionAvailability' | 'subscriptionLocalizations' | 'subscriptionPeriod'>, fieldsSubscriptionPromotionalOfferPrices?: Array<'subscriptionPricePoint' | 'territory'>, limit?: number, limitPrices?: number, include?: Array<'prices' | 'subscription'>, _options?: Configuration): Promise<SubscriptionPromotionalOffersResponse> {
        const result = this.api.subscriptionsPromotionalOffersGetToManyRelated(id, filterTerritory, fieldsSubscriptionPromotionalOffers, fieldsSubscriptions, fieldsSubscriptionPromotionalOfferPrices, limit, limitPrices, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsSubscriptionAvailabilities the fields to include for returned resources of type subscriptionAvailabilities
     * @param fieldsSubscriptions the fields to include for returned resources of type subscriptions
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limitAvailableTerritories maximum number of related availableTerritories returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public subscriptionsSubscriptionAvailabilityGetToOneRelatedWithHttpInfo(id: string, fieldsSubscriptionAvailabilities?: Array<'availableInNewTerritories' | 'availableTerritories' | 'subscription'>, fieldsSubscriptions?: Array<'appStoreReviewScreenshot' | 'familySharable' | 'group' | 'groupLevel' | 'introductoryOffers' | 'name' | 'offerCodes' | 'pricePoints' | 'prices' | 'productId' | 'promotedPurchase' | 'promotionalOffers' | 'reviewNote' | 'state' | 'subscriptionAvailability' | 'subscriptionLocalizations' | 'subscriptionPeriod'>, fieldsTerritories?: Array<'currency'>, limitAvailableTerritories?: number, include?: Array<'availableTerritories' | 'subscription'>, _options?: Configuration): Promise<HttpInfo<SubscriptionAvailabilityResponse>> {
        const result = this.api.subscriptionsSubscriptionAvailabilityGetToOneRelatedWithHttpInfo(id, fieldsSubscriptionAvailabilities, fieldsSubscriptions, fieldsTerritories, limitAvailableTerritories, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsSubscriptionAvailabilities the fields to include for returned resources of type subscriptionAvailabilities
     * @param fieldsSubscriptions the fields to include for returned resources of type subscriptions
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limitAvailableTerritories maximum number of related availableTerritories returned (when they are included)
     * @param include comma-separated list of relationships to include
     */
    public subscriptionsSubscriptionAvailabilityGetToOneRelated(id: string, fieldsSubscriptionAvailabilities?: Array<'availableInNewTerritories' | 'availableTerritories' | 'subscription'>, fieldsSubscriptions?: Array<'appStoreReviewScreenshot' | 'familySharable' | 'group' | 'groupLevel' | 'introductoryOffers' | 'name' | 'offerCodes' | 'pricePoints' | 'prices' | 'productId' | 'promotedPurchase' | 'promotionalOffers' | 'reviewNote' | 'state' | 'subscriptionAvailability' | 'subscriptionLocalizations' | 'subscriptionPeriod'>, fieldsTerritories?: Array<'currency'>, limitAvailableTerritories?: number, include?: Array<'availableTerritories' | 'subscription'>, _options?: Configuration): Promise<SubscriptionAvailabilityResponse> {
        const result = this.api.subscriptionsSubscriptionAvailabilityGetToOneRelated(id, fieldsSubscriptionAvailabilities, fieldsSubscriptions, fieldsTerritories, limitAvailableTerritories, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsSubscriptions the fields to include for returned resources of type subscriptions
     * @param fieldsSubscriptionLocalizations the fields to include for returned resources of type subscriptionLocalizations
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public subscriptionsSubscriptionLocalizationsGetToManyRelatedWithHttpInfo(id: string, fieldsSubscriptions?: Array<'appStoreReviewScreenshot' | 'familySharable' | 'group' | 'groupLevel' | 'introductoryOffers' | 'name' | 'offerCodes' | 'pricePoints' | 'prices' | 'productId' | 'promotedPurchase' | 'promotionalOffers' | 'reviewNote' | 'state' | 'subscriptionAvailability' | 'subscriptionLocalizations' | 'subscriptionPeriod'>, fieldsSubscriptionLocalizations?: Array<'description' | 'locale' | 'name' | 'state' | 'subscription'>, limit?: number, include?: Array<'subscription'>, _options?: Configuration): Promise<HttpInfo<SubscriptionLocalizationsResponse>> {
        const result = this.api.subscriptionsSubscriptionLocalizationsGetToManyRelatedWithHttpInfo(id, fieldsSubscriptions, fieldsSubscriptionLocalizations, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsSubscriptions the fields to include for returned resources of type subscriptions
     * @param fieldsSubscriptionLocalizations the fields to include for returned resources of type subscriptionLocalizations
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     */
    public subscriptionsSubscriptionLocalizationsGetToManyRelated(id: string, fieldsSubscriptions?: Array<'appStoreReviewScreenshot' | 'familySharable' | 'group' | 'groupLevel' | 'introductoryOffers' | 'name' | 'offerCodes' | 'pricePoints' | 'prices' | 'productId' | 'promotedPurchase' | 'promotionalOffers' | 'reviewNote' | 'state' | 'subscriptionAvailability' | 'subscriptionLocalizations' | 'subscriptionPeriod'>, fieldsSubscriptionLocalizations?: Array<'description' | 'locale' | 'name' | 'state' | 'subscription'>, limit?: number, include?: Array<'subscription'>, _options?: Configuration): Promise<SubscriptionLocalizationsResponse> {
        const result = this.api.subscriptionsSubscriptionLocalizationsGetToManyRelated(id, fieldsSubscriptions, fieldsSubscriptionLocalizations, limit, include, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param subscriptionUpdateRequest Subscription representation
     */
    public subscriptionsUpdateInstanceWithHttpInfo(id: string, subscriptionUpdateRequest: SubscriptionUpdateRequest, _options?: Configuration): Promise<HttpInfo<SubscriptionResponse>> {
        const result = this.api.subscriptionsUpdateInstanceWithHttpInfo(id, subscriptionUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param subscriptionUpdateRequest Subscription representation
     */
    public subscriptionsUpdateInstance(id: string, subscriptionUpdateRequest: SubscriptionUpdateRequest, _options?: Configuration): Promise<SubscriptionResponse> {
        const result = this.api.subscriptionsUpdateInstance(id, subscriptionUpdateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableTerritoriesApi } from './ObservableAPI.ts';

import { TerritoriesApiRequestFactory, TerritoriesApiResponseProcessor} from "../apis/TerritoriesApi.ts";
export class PromiseTerritoriesApi {
    private api: ObservableTerritoriesApi

    public constructor(
        configuration: Configuration,
        requestFactory?: TerritoriesApiRequestFactory,
        responseProcessor?: TerritoriesApiResponseProcessor
    ) {
        this.api = new ObservableTerritoriesApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limit maximum resources per page
     */
    public territoriesGetCollectionWithHttpInfo(fieldsTerritories?: Array<'currency'>, limit?: number, _options?: Configuration): Promise<HttpInfo<TerritoriesResponse>> {
        const result = this.api.territoriesGetCollectionWithHttpInfo(fieldsTerritories, limit, _options);
        return result.toPromise();
    }

    /**
     * @param fieldsTerritories the fields to include for returned resources of type territories
     * @param limit maximum resources per page
     */
    public territoriesGetCollection(fieldsTerritories?: Array<'currency'>, limit?: number, _options?: Configuration): Promise<TerritoriesResponse> {
        const result = this.api.territoriesGetCollection(fieldsTerritories, limit, _options);
        return result.toPromise();
    }


}



import { ObservableTerritoryAvailabilitiesApi } from './ObservableAPI.ts';

import { TerritoryAvailabilitiesApiRequestFactory, TerritoryAvailabilitiesApiResponseProcessor} from "../apis/TerritoryAvailabilitiesApi.ts";
export class PromiseTerritoryAvailabilitiesApi {
    private api: ObservableTerritoryAvailabilitiesApi

    public constructor(
        configuration: Configuration,
        requestFactory?: TerritoryAvailabilitiesApiRequestFactory,
        responseProcessor?: TerritoryAvailabilitiesApiResponseProcessor
    ) {
        this.api = new ObservableTerritoryAvailabilitiesApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param id the id of the requested resource
     * @param territoryAvailabilityUpdateRequest TerritoryAvailability representation
     */
    public territoryAvailabilitiesUpdateInstanceWithHttpInfo(id: string, territoryAvailabilityUpdateRequest: TerritoryAvailabilityUpdateRequest, _options?: Configuration): Promise<HttpInfo<TerritoryAvailabilityResponse>> {
        const result = this.api.territoryAvailabilitiesUpdateInstanceWithHttpInfo(id, territoryAvailabilityUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param territoryAvailabilityUpdateRequest TerritoryAvailability representation
     */
    public territoryAvailabilitiesUpdateInstance(id: string, territoryAvailabilityUpdateRequest: TerritoryAvailabilityUpdateRequest, _options?: Configuration): Promise<TerritoryAvailabilityResponse> {
        const result = this.api.territoryAvailabilitiesUpdateInstance(id, territoryAvailabilityUpdateRequest, _options);
        return result.toPromise();
    }


}



import { ObservableUserInvitationsApi } from './ObservableAPI.ts';

import { UserInvitationsApiRequestFactory, UserInvitationsApiResponseProcessor} from "../apis/UserInvitationsApi.ts";
export class PromiseUserInvitationsApi {
    private api: ObservableUserInvitationsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: UserInvitationsApiRequestFactory,
        responseProcessor?: UserInvitationsApiResponseProcessor
    ) {
        this.api = new ObservableUserInvitationsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param userInvitationCreateRequest UserInvitation representation
     */
    public userInvitationsCreateInstanceWithHttpInfo(userInvitationCreateRequest: UserInvitationCreateRequest, _options?: Configuration): Promise<HttpInfo<UserInvitationResponse>> {
        const result = this.api.userInvitationsCreateInstanceWithHttpInfo(userInvitationCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param userInvitationCreateRequest UserInvitation representation
     */
    public userInvitationsCreateInstance(userInvitationCreateRequest: UserInvitationCreateRequest, _options?: Configuration): Promise<UserInvitationResponse> {
        const result = this.api.userInvitationsCreateInstance(userInvitationCreateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public userInvitationsDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.userInvitationsDeleteInstanceWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public userInvitationsDeleteInstance(id: string, _options?: Configuration): Promise<void> {
        const result = this.api.userInvitationsDeleteInstance(id, _options);
        return result.toPromise();
    }

    /**
     * @param filterEmail filter by attribute \&#39;email\&#39;
     * @param filterRoles filter by attribute \&#39;roles\&#39;
     * @param filterVisibleApps filter by id(s) of related \&#39;visibleApps\&#39;
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsUserInvitations the fields to include for returned resources of type userInvitations
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param limitVisibleApps maximum number of related visibleApps returned (when they are included)
     */
    public userInvitationsGetCollectionWithHttpInfo(filterEmail?: Array<string>, filterRoles?: Array<'ADMIN' | 'FINANCE' | 'ACCOUNT_HOLDER' | 'SALES' | 'MARKETING' | 'APP_MANAGER' | 'DEVELOPER' | 'ACCESS_TO_REPORTS' | 'CUSTOMER_SUPPORT' | 'IMAGE_MANAGER' | 'CREATE_APPS' | 'CLOUD_MANAGED_DEVELOPER_ID' | 'CLOUD_MANAGED_APP_DISTRIBUTION' | 'GENERATE_INDIVIDUAL_KEYS'>, filterVisibleApps?: Array<string>, sort?: Array<'email' | '-email' | 'lastName' | '-lastName'>, fieldsUserInvitations?: Array<'allAppsVisible' | 'email' | 'expirationDate' | 'firstName' | 'lastName' | 'provisioningAllowed' | 'roles' | 'visibleApps'>, limit?: number, include?: Array<'visibleApps'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, limitVisibleApps?: number, _options?: Configuration): Promise<HttpInfo<UserInvitationsResponse>> {
        const result = this.api.userInvitationsGetCollectionWithHttpInfo(filterEmail, filterRoles, filterVisibleApps, sort, fieldsUserInvitations, limit, include, fieldsApps, limitVisibleApps, _options);
        return result.toPromise();
    }

    /**
     * @param filterEmail filter by attribute \&#39;email\&#39;
     * @param filterRoles filter by attribute \&#39;roles\&#39;
     * @param filterVisibleApps filter by id(s) of related \&#39;visibleApps\&#39;
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsUserInvitations the fields to include for returned resources of type userInvitations
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param limitVisibleApps maximum number of related visibleApps returned (when they are included)
     */
    public userInvitationsGetCollection(filterEmail?: Array<string>, filterRoles?: Array<'ADMIN' | 'FINANCE' | 'ACCOUNT_HOLDER' | 'SALES' | 'MARKETING' | 'APP_MANAGER' | 'DEVELOPER' | 'ACCESS_TO_REPORTS' | 'CUSTOMER_SUPPORT' | 'IMAGE_MANAGER' | 'CREATE_APPS' | 'CLOUD_MANAGED_DEVELOPER_ID' | 'CLOUD_MANAGED_APP_DISTRIBUTION' | 'GENERATE_INDIVIDUAL_KEYS'>, filterVisibleApps?: Array<string>, sort?: Array<'email' | '-email' | 'lastName' | '-lastName'>, fieldsUserInvitations?: Array<'allAppsVisible' | 'email' | 'expirationDate' | 'firstName' | 'lastName' | 'provisioningAllowed' | 'roles' | 'visibleApps'>, limit?: number, include?: Array<'visibleApps'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, limitVisibleApps?: number, _options?: Configuration): Promise<UserInvitationsResponse> {
        const result = this.api.userInvitationsGetCollection(filterEmail, filterRoles, filterVisibleApps, sort, fieldsUserInvitations, limit, include, fieldsApps, limitVisibleApps, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsUserInvitations the fields to include for returned resources of type userInvitations
     * @param include comma-separated list of relationships to include
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param limitVisibleApps maximum number of related visibleApps returned (when they are included)
     */
    public userInvitationsGetInstanceWithHttpInfo(id: string, fieldsUserInvitations?: Array<'allAppsVisible' | 'email' | 'expirationDate' | 'firstName' | 'lastName' | 'provisioningAllowed' | 'roles' | 'visibleApps'>, include?: Array<'visibleApps'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, limitVisibleApps?: number, _options?: Configuration): Promise<HttpInfo<UserInvitationResponse>> {
        const result = this.api.userInvitationsGetInstanceWithHttpInfo(id, fieldsUserInvitations, include, fieldsApps, limitVisibleApps, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsUserInvitations the fields to include for returned resources of type userInvitations
     * @param include comma-separated list of relationships to include
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param limitVisibleApps maximum number of related visibleApps returned (when they are included)
     */
    public userInvitationsGetInstance(id: string, fieldsUserInvitations?: Array<'allAppsVisible' | 'email' | 'expirationDate' | 'firstName' | 'lastName' | 'provisioningAllowed' | 'roles' | 'visibleApps'>, include?: Array<'visibleApps'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, limitVisibleApps?: number, _options?: Configuration): Promise<UserInvitationResponse> {
        const result = this.api.userInvitationsGetInstance(id, fieldsUserInvitations, include, fieldsApps, limitVisibleApps, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param limit maximum resources per page
     */
    public userInvitationsVisibleAppsGetToManyRelatedWithHttpInfo(id: string, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, limit?: number, _options?: Configuration): Promise<HttpInfo<AppsWithoutIncludesResponse>> {
        const result = this.api.userInvitationsVisibleAppsGetToManyRelatedWithHttpInfo(id, fieldsApps, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param limit maximum resources per page
     */
    public userInvitationsVisibleAppsGetToManyRelated(id: string, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, limit?: number, _options?: Configuration): Promise<AppsWithoutIncludesResponse> {
        const result = this.api.userInvitationsVisibleAppsGetToManyRelated(id, fieldsApps, limit, _options);
        return result.toPromise();
    }


}



import { ObservableUsersApi } from './ObservableAPI.ts';

import { UsersApiRequestFactory, UsersApiResponseProcessor} from "../apis/UsersApi.ts";
export class PromiseUsersApi {
    private api: ObservableUsersApi

    public constructor(
        configuration: Configuration,
        requestFactory?: UsersApiRequestFactory,
        responseProcessor?: UsersApiResponseProcessor
    ) {
        this.api = new ObservableUsersApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param id the id of the requested resource
     */
    public usersDeleteInstanceWithHttpInfo(id: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.usersDeleteInstanceWithHttpInfo(id, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     */
    public usersDeleteInstance(id: string, _options?: Configuration): Promise<void> {
        const result = this.api.usersDeleteInstance(id, _options);
        return result.toPromise();
    }

    /**
     * @param filterRoles filter by attribute \&#39;roles\&#39;
     * @param filterUsername filter by attribute \&#39;username\&#39;
     * @param filterVisibleApps filter by id(s) of related \&#39;visibleApps\&#39;
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsUsers the fields to include for returned resources of type users
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param limitVisibleApps maximum number of related visibleApps returned (when they are included)
     */
    public usersGetCollectionWithHttpInfo(filterRoles?: Array<'ADMIN' | 'FINANCE' | 'ACCOUNT_HOLDER' | 'SALES' | 'MARKETING' | 'APP_MANAGER' | 'DEVELOPER' | 'ACCESS_TO_REPORTS' | 'CUSTOMER_SUPPORT' | 'IMAGE_MANAGER' | 'CREATE_APPS' | 'CLOUD_MANAGED_DEVELOPER_ID' | 'CLOUD_MANAGED_APP_DISTRIBUTION' | 'GENERATE_INDIVIDUAL_KEYS'>, filterUsername?: Array<string>, filterVisibleApps?: Array<string>, sort?: Array<'lastName' | '-lastName' | 'username' | '-username'>, fieldsUsers?: Array<'allAppsVisible' | 'firstName' | 'lastName' | 'provisioningAllowed' | 'roles' | 'username' | 'visibleApps'>, limit?: number, include?: Array<'visibleApps'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, limitVisibleApps?: number, _options?: Configuration): Promise<HttpInfo<UsersResponse>> {
        const result = this.api.usersGetCollectionWithHttpInfo(filterRoles, filterUsername, filterVisibleApps, sort, fieldsUsers, limit, include, fieldsApps, limitVisibleApps, _options);
        return result.toPromise();
    }

    /**
     * @param filterRoles filter by attribute \&#39;roles\&#39;
     * @param filterUsername filter by attribute \&#39;username\&#39;
     * @param filterVisibleApps filter by id(s) of related \&#39;visibleApps\&#39;
     * @param sort comma-separated list of sort expressions; resources will be sorted as specified
     * @param fieldsUsers the fields to include for returned resources of type users
     * @param limit maximum resources per page
     * @param include comma-separated list of relationships to include
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param limitVisibleApps maximum number of related visibleApps returned (when they are included)
     */
    public usersGetCollection(filterRoles?: Array<'ADMIN' | 'FINANCE' | 'ACCOUNT_HOLDER' | 'SALES' | 'MARKETING' | 'APP_MANAGER' | 'DEVELOPER' | 'ACCESS_TO_REPORTS' | 'CUSTOMER_SUPPORT' | 'IMAGE_MANAGER' | 'CREATE_APPS' | 'CLOUD_MANAGED_DEVELOPER_ID' | 'CLOUD_MANAGED_APP_DISTRIBUTION' | 'GENERATE_INDIVIDUAL_KEYS'>, filterUsername?: Array<string>, filterVisibleApps?: Array<string>, sort?: Array<'lastName' | '-lastName' | 'username' | '-username'>, fieldsUsers?: Array<'allAppsVisible' | 'firstName' | 'lastName' | 'provisioningAllowed' | 'roles' | 'username' | 'visibleApps'>, limit?: number, include?: Array<'visibleApps'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, limitVisibleApps?: number, _options?: Configuration): Promise<UsersResponse> {
        const result = this.api.usersGetCollection(filterRoles, filterUsername, filterVisibleApps, sort, fieldsUsers, limit, include, fieldsApps, limitVisibleApps, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsUsers the fields to include for returned resources of type users
     * @param include comma-separated list of relationships to include
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param limitVisibleApps maximum number of related visibleApps returned (when they are included)
     */
    public usersGetInstanceWithHttpInfo(id: string, fieldsUsers?: Array<'allAppsVisible' | 'firstName' | 'lastName' | 'provisioningAllowed' | 'roles' | 'username' | 'visibleApps'>, include?: Array<'visibleApps'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, limitVisibleApps?: number, _options?: Configuration): Promise<HttpInfo<UserResponse>> {
        const result = this.api.usersGetInstanceWithHttpInfo(id, fieldsUsers, include, fieldsApps, limitVisibleApps, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsUsers the fields to include for returned resources of type users
     * @param include comma-separated list of relationships to include
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param limitVisibleApps maximum number of related visibleApps returned (when they are included)
     */
    public usersGetInstance(id: string, fieldsUsers?: Array<'allAppsVisible' | 'firstName' | 'lastName' | 'provisioningAllowed' | 'roles' | 'username' | 'visibleApps'>, include?: Array<'visibleApps'>, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, limitVisibleApps?: number, _options?: Configuration): Promise<UserResponse> {
        const result = this.api.usersGetInstance(id, fieldsUsers, include, fieldsApps, limitVisibleApps, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param userUpdateRequest User representation
     */
    public usersUpdateInstanceWithHttpInfo(id: string, userUpdateRequest: UserUpdateRequest, _options?: Configuration): Promise<HttpInfo<UserResponse>> {
        const result = this.api.usersUpdateInstanceWithHttpInfo(id, userUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param userUpdateRequest User representation
     */
    public usersUpdateInstance(id: string, userUpdateRequest: UserUpdateRequest, _options?: Configuration): Promise<UserResponse> {
        const result = this.api.usersUpdateInstance(id, userUpdateRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param userVisibleAppsLinkagesRequest List of related linkages
     */
    public usersVisibleAppsCreateToManyRelationshipWithHttpInfo(id: string, userVisibleAppsLinkagesRequest: UserVisibleAppsLinkagesRequest, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.usersVisibleAppsCreateToManyRelationshipWithHttpInfo(id, userVisibleAppsLinkagesRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param userVisibleAppsLinkagesRequest List of related linkages
     */
    public usersVisibleAppsCreateToManyRelationship(id: string, userVisibleAppsLinkagesRequest: UserVisibleAppsLinkagesRequest, _options?: Configuration): Promise<void> {
        const result = this.api.usersVisibleAppsCreateToManyRelationship(id, userVisibleAppsLinkagesRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param userVisibleAppsLinkagesRequest List of related linkages
     */
    public usersVisibleAppsDeleteToManyRelationshipWithHttpInfo(id: string, userVisibleAppsLinkagesRequest: UserVisibleAppsLinkagesRequest, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.usersVisibleAppsDeleteToManyRelationshipWithHttpInfo(id, userVisibleAppsLinkagesRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param userVisibleAppsLinkagesRequest List of related linkages
     */
    public usersVisibleAppsDeleteToManyRelationship(id: string, userVisibleAppsLinkagesRequest: UserVisibleAppsLinkagesRequest, _options?: Configuration): Promise<void> {
        const result = this.api.usersVisibleAppsDeleteToManyRelationship(id, userVisibleAppsLinkagesRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param limit maximum resources per page
     */
    public usersVisibleAppsGetToManyRelatedWithHttpInfo(id: string, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, limit?: number, _options?: Configuration): Promise<HttpInfo<AppsWithoutIncludesResponse>> {
        const result = this.api.usersVisibleAppsGetToManyRelatedWithHttpInfo(id, fieldsApps, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param fieldsApps the fields to include for returned resources of type apps
     * @param limit maximum resources per page
     */
    public usersVisibleAppsGetToManyRelated(id: string, fieldsApps?: Array<'alternativeDistributionKey' | 'analyticsReportRequests' | 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEncryptionDeclarations' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersionExperimentsV2' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterDetail' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'marketplaceSearchDetail' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox'>, limit?: number, _options?: Configuration): Promise<AppsWithoutIncludesResponse> {
        const result = this.api.usersVisibleAppsGetToManyRelated(id, fieldsApps, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public usersVisibleAppsGetToManyRelationshipWithHttpInfo(id: string, limit?: number, _options?: Configuration): Promise<HttpInfo<UserVisibleAppsLinkagesResponse>> {
        const result = this.api.usersVisibleAppsGetToManyRelationshipWithHttpInfo(id, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param limit maximum resources per page
     */
    public usersVisibleAppsGetToManyRelationship(id: string, limit?: number, _options?: Configuration): Promise<UserVisibleAppsLinkagesResponse> {
        const result = this.api.usersVisibleAppsGetToManyRelationship(id, limit, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param userVisibleAppsLinkagesRequest List of related linkages
     */
    public usersVisibleAppsReplaceToManyRelationshipWithHttpInfo(id: string, userVisibleAppsLinkagesRequest: UserVisibleAppsLinkagesRequest, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.usersVisibleAppsReplaceToManyRelationshipWithHttpInfo(id, userVisibleAppsLinkagesRequest, _options);
        return result.toPromise();
    }

    /**
     * @param id the id of the requested resource
     * @param userVisibleAppsLinkagesRequest List of related linkages
     */
    public usersVisibleAppsReplaceToManyRelationship(id: string, userVisibleAppsLinkagesRequest: UserVisibleAppsLinkagesRequest, _options?: Configuration): Promise<void> {
        const result = this.api.usersVisibleAppsReplaceToManyRelationship(id, userVisibleAppsLinkagesRequest, _options);
        return result.toPromise();
    }


}



